id,quality_attribute,keyword,matched_word,match_idx,sentence,source,filename,author,repo,version,wiki,url
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp:176,Modifiability,variab,variable,176,"// We search in the redecl context because of transparent contexts.; // E.g. a simple C language enum is a transparent context:; // enum E { A, B };; // Now if we had a global variable in the TU; // int A;; // then the enum constant 'A' and the variable 'A' violates ODR.; // We can diagnose this only if we search in the redecl context.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp:245,Modifiability,variab,variable,245,"// We search in the redecl context because of transparent contexts.; // E.g. a simple C language enum is a transparent context:; // enum E { A, B };; // Now if we had a global variable in the TU; // int A;; // then the enum constant 'A' and the variable 'A' violates ODR.; // We can diagnose this only if we search in the redecl context.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp:79,Usability,simpl,simple,79,"// We search in the redecl context because of transparent contexts.; // E.g. a simple C language enum is a transparent context:; // enum E { A, B };; // Now if we had a global variable in the TU; // int A;; // then the enum constant 'A' and the variable 'A' violates ODR.; // We can diagnose this only if we search in the redecl context.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp:203,Performance,load,load,203,"// We must search by the slow case of localUncachedLookup because that is; // working even if there is no LookupPtr for the DC. We could use; // DC::buildLookup() to create the LookupPtr, but that would load external; // decls again, we must avoid that case.; // Also, even if we had the LookupPtr, we must find Decls which are not; // in the LookupPtr, so we need the slow case.; // These cases are handled in ASTImporterLookupTable, but we cannot use; // that with LLDB since that traverses through the AST which initiates the; // load of external decls again via DC::decls(). And again, we must avoid; // loading external decls during the import.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp:533,Performance,load,load,533,"// We must search by the slow case of localUncachedLookup because that is; // working even if there is no LookupPtr for the DC. We could use; // DC::buildLookup() to create the LookupPtr, but that would load external; // decls again, we must avoid that case.; // Also, even if we had the LookupPtr, we must find Decls which are not; // in the LookupPtr, so we need the slow case.; // These cases are handled in ASTImporterLookupTable, but we cannot use; // that with LLDB since that traverses through the AST which initiates the; // load of external decls again via DC::decls(). And again, we must avoid; // loading external decls during the import.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp:608,Performance,load,loading,608,"// We must search by the slow case of localUncachedLookup because that is; // working even if there is no LookupPtr for the DC. We could use; // DC::buildLookup() to create the LookupPtr, but that would load external; // decls again, we must avoid that case.; // Also, even if we had the LookupPtr, we must find Decls which are not; // in the LookupPtr, so we need the slow case.; // These cases are handled in ASTImporterLookupTable, but we cannot use; // that with LLDB since that traverses through the AST which initiates the; // load of external decls again via DC::decls(). And again, we must avoid; // loading external decls during the import.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp:242,Safety,avoid,avoid,242,"// We must search by the slow case of localUncachedLookup because that is; // working even if there is no LookupPtr for the DC. We could use; // DC::buildLookup() to create the LookupPtr, but that would load external; // decls again, we must avoid that case.; // Also, even if we had the LookupPtr, we must find Decls which are not; // in the LookupPtr, so we need the slow case.; // These cases are handled in ASTImporterLookupTable, but we cannot use; // that with LLDB since that traverses through the AST which initiates the; // load of external decls again via DC::decls(). And again, we must avoid; // loading external decls during the import.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp:598,Safety,avoid,avoid,598,"// We must search by the slow case of localUncachedLookup because that is; // working even if there is no LookupPtr for the DC. We could use; // DC::buildLookup() to create the LookupPtr, but that would load external; // decls again, we must avoid that case.; // Also, even if we had the LookupPtr, we must find Decls which are not; // in the LookupPtr, so we need the slow case.; // These cases are handled in ASTImporterLookupTable, but we cannot use; // that with LLDB since that traverses through the AST which initiates the; // load of external decls again via DC::decls(). And again, we must avoid; // loading external decls during the import.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp:146,Performance,perform,performs,146,"// To use this object, it should be created before the new attribute is created,; // and destructed after it is created. The construction already performs the; // import of the data.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp:146,Performance,perform,performs,146,"// To use this object, it should be created before the new attribute is created,; // and destructed after it is created. The construction already performs the; // import of the data. The array data is accessible in a pointer form, this form; // is used by the attribute classes. This object should be created once for the; // array data to be imported (the array size is not imported, just copied).",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp:201,Security,access,accessible,201,"// To use this object, it should be created before the new attribute is created,; // and destructed after it is created. The construction already performs the; // import of the data. The array data is accessible in a pointer form, this form; // is used by the attribute classes. This object should be created once for the; // array data to be imported (the array size is not imported, just copied).",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp:14,Security,access,accessing,14,// Useful for accessing the imported attribute.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp:452,Availability,error,error,452,"// Create an attribute object with the specified arguments.; // The 'FromAttr' is the original (not imported) attribute, the 'ImportedArg'; // should be values that are passed to the 'Create' function of the attribute.; // (The 'Create' with 'ASTContext' first and 'AttributeCommonInfo' last is; // used here.) As much data is copied or imported from the old attribute; // as possible. The passed arguments should be already imported.; // If an import error happens, the internal error is set to it, and any; // further import attempt is ignored.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp:480,Availability,error,error,480,"// Create an attribute object with the specified arguments.; // The 'FromAttr' is the original (not imported) attribute, the 'ImportedArg'; // should be values that are passed to the 'Create' function of the attribute.; // (The 'Create' with 'ASTContext' first and 'AttributeCommonInfo' last is; // used here.) As much data is copied or imported from the old attribute; // as possible. The passed arguments should be already imported.; // If an import error happens, the internal error is set to it, and any; // further import attempt is ignored.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp:84,Availability,error,error,84,// Check whether there was a previous failed import.; // If yes return the existing error.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp:59,Availability,error,error,59,// Already imported (possibly from another TU) and with an error.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp:21,Deployability,update,updated,21,"// If FromD has some updated flags after last import, apply it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp:179,Availability,error,error,179,"// FIXME: AST may contain remaining references to the failed object.; // However, the ImportDeclErrors in the shared state contains all the; // failed objects together with their error.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp:3,Availability,Error,Error,3,// Error encountered for the first time.; // After takeError the error is not usable any more in ToDOrErr.; // Get a copy of the error object (any more simple solution for this?).,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp:65,Availability,error,error,65,// Error encountered for the first time.; // After takeError the error is not usable any more in ToDOrErr.; // Get a copy of the error object (any more simple solution for this?).,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp:129,Availability,error,error,129,// Error encountered for the first time.; // After takeError the error is not usable any more in ToDOrErr.; // Get a copy of the error object (any more simple solution for this?).,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp:78,Usability,usab,usable,78,// Error encountered for the first time.; // After takeError the error is not usable any more in ToDOrErr.; // Get a copy of the error object (any more simple solution for this?).,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp:152,Usability,simpl,simple,152,// Error encountered for the first time.; // After takeError the error is not usable any more in ToDOrErr.; // Get a copy of the error object (any more simple solution for this?).,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp:11,Availability,error,error,11,"// Set the error for the mapped to Decl, which is in the ""to"" context.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp:11,Availability,error,error,11,// Set the error for all nodes which have been created before we; // recognized the error.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp:84,Availability,error,error,84,// Set the error for all nodes which have been created before we; // recognized the error.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp:35,Integrability,depend,dependency,35,// The import path contains import-dependency nodes first.; // Save the node that was imported as dependency of the current node.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp:98,Integrability,depend,dependency,98,// The import path contains import-dependency nodes first.; // Save the node that was imported as dependency of the current node.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp:28,Availability,error,error,28,// We should not set import error on a node and all following nodes in; // the path if child import errors are ignored.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp:100,Availability,error,errors,100,// We should not set import error on a node and all following nodes in; // the path if child import errors are ignored.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp:69,Availability,error,error,69,"//FIXME Should we remove these Decls from ImportedDecls?; // Set the error for the mapped to Decl, which is in the ""to"" context.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp:27,Availability,error,error,27,"// Do not return ToDOrErr, error was taken out of it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp:44,Availability,error,error,44,"// FIXME: Handle the ""already imported with error"" case. We can get here; // nullptr only if GetImportedOrCreateDecl returned nullptr (after a; // previously failed create was requested).; // Later GetImportedOrCreateDecl can be updated to return the error.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp:251,Availability,error,error,251,"// FIXME: Handle the ""already imported with error"" case. We can get here; // nullptr only if GetImportedOrCreateDecl returned nullptr (after a; // previously failed create was requested).; // Later GetImportedOrCreateDecl can be updated to return the error.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp:229,Deployability,update,updated,229,"// FIXME: Handle the ""already imported with error"" case. We can get here; // nullptr only if GetImportedOrCreateDecl returned nullptr (after a; // previously failed create was requested).; // Later GetImportedOrCreateDecl can be updated to return the error.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp:47,Availability,error,error,47,// We could import from the current TU without error. But previously we; // already had imported a Decl as `ToD` from another TU (with another; // ASTImporter object) and with an error.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp:179,Availability,error,error,179,// We could import from the current TU without error. But previously we; // already had imported a Decl as `ToD` from another TU (with another; // ASTImporter object) and with an error.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp:52,Integrability,protocol,protocol,52,"// When we're using a record/enum/Objective-C class/protocol as a context, we; // need it to have a definition.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp:289,Modifiability,inherit,inherit,289,// If FromRecord is not defined we need to force it to be.; // Simply calling CompleteDecl(...) for a RecordDecl will break some cases; // it will start the definition but we never finish it.; // If there are base classes they won't be imported and we will; // be missing anything that we inherit from those bases.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp:63,Usability,Simpl,Simply,63,// If FromRecord is not defined we need to force it to be.; // Simply calling CompleteDecl(...) for a RecordDecl will break some cases; // it will start the definition but we never finish it.; // If there are base classes they won't be imported and we will; // be missing anything that we inherit from those bases.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp:10,Testability,assert,assert,10,// FIXME: assert?,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp:10,Availability,error,error,10,// Report error at any name conflict.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp:21,Availability,error,error,21,"// Either we set the error for the first time, or we already had set one and; // now we want to set the same error.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp:109,Availability,error,error,109,"// Either we set the error for the first time, or we already had set one and; // now we want to set the same error.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTImporterLookupTable.cpp:23,Integrability,depend,dependent,23,"// A FriendDecl with a dependent type (e.g. ClassTemplateSpecialization); // always has that decl as child node.; // However, there are non-dependent cases which does not have the; // type as a child node. We have to dig up that type now.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ASTImporterLookupTable.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTImporterLookupTable.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTImporterLookupTable.cpp:140,Integrability,depend,dependent,140,"// A FriendDecl with a dependent type (e.g. ClassTemplateSpecialization); // always has that decl as child node.; // However, there are non-dependent cases which does not have the; // type as a child node. We have to dig up that type now.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ASTImporterLookupTable.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTImporterLookupTable.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTStructuralEquivalence.cpp:773,Performance,Queue,Queue,773,"//===- ASTStructuralEquivalence.cpp ---------------------------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implement StructuralEquivalenceContext class and helper functions; // for layout matching.; //; // The structural equivalence check could have been implemented as a parallel; // BFS on a pair of graphs. That must have been the original approach at the; // beginning.; // Let's consider this simple BFS algorithm from the `s` source:; // ```; // void bfs(Graph G, int s); // {; // Queue<Integer> queue = new Queue<Integer>();; // marked[s] = true; // Mark the source; // queue.enqueue(s); // and put it on the queue.; // while (!q.isEmpty()) {; // int v = queue.dequeue(); // Remove next vertex from the queue.; // for (int w : G.adj(v)); // if (!marked[w]) // For every unmarked adjacent vertex,; // {; // marked[w] = true;; // queue.enqueue(w);; // }; // }; // }; // ```; // Indeed, it has it's queue, which holds pairs of nodes, one from each graph,; // this is the `DeclsToCheck` member. `VisitedDecls` plays the role of the; // marking (`marked`) functionality above, we use it to check whether we've; // already seen a pair of nodes.; //; // We put in the elements into the queue only in the toplevel decl check; // function:; // ```; // static bool IsStructurallyEquivalent(StructuralEquivalenceContext &Context,; // Decl *D1, Decl *D2);; // ```; // The `while` loop where we iterate over the children is implemented in; // `Finish()`. And `Finish` is called only from the two **member** functions; // which check the equivalency of two Decls or two Types. ASTImporter (and; // other clients) call only these functions.; //; // The `static` implementation functions are called from `Finish`, these push",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ASTStructuralEquivalence.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTStructuralEquivalence.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTStructuralEquivalence.cpp:788,Performance,queue,queue,788,"//===- ASTStructuralEquivalence.cpp ---------------------------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implement StructuralEquivalenceContext class and helper functions; // for layout matching.; //; // The structural equivalence check could have been implemented as a parallel; // BFS on a pair of graphs. That must have been the original approach at the; // beginning.; // Let's consider this simple BFS algorithm from the `s` source:; // ```; // void bfs(Graph G, int s); // {; // Queue<Integer> queue = new Queue<Integer>();; // marked[s] = true; // Mark the source; // queue.enqueue(s); // and put it on the queue.; // while (!q.isEmpty()) {; // int v = queue.dequeue(); // Remove next vertex from the queue.; // for (int w : G.adj(v)); // if (!marked[w]) // For every unmarked adjacent vertex,; // {; // marked[w] = true;; // queue.enqueue(w);; // }; // }; // }; // ```; // Indeed, it has it's queue, which holds pairs of nodes, one from each graph,; // this is the `DeclsToCheck` member. `VisitedDecls` plays the role of the; // marking (`marked`) functionality above, we use it to check whether we've; // already seen a pair of nodes.; //; // We put in the elements into the queue only in the toplevel decl check; // function:; // ```; // static bool IsStructurallyEquivalent(StructuralEquivalenceContext &Context,; // Decl *D1, Decl *D2);; // ```; // The `while` loop where we iterate over the children is implemented in; // `Finish()`. And `Finish` is called only from the two **member** functions; // which check the equivalency of two Decls or two Types. ASTImporter (and; // other clients) call only these functions.; //; // The `static` implementation functions are called from `Finish`, these push",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ASTStructuralEquivalence.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTStructuralEquivalence.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTStructuralEquivalence.cpp:800,Performance,Queue,Queue,800,"//===- ASTStructuralEquivalence.cpp ---------------------------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implement StructuralEquivalenceContext class and helper functions; // for layout matching.; //; // The structural equivalence check could have been implemented as a parallel; // BFS on a pair of graphs. That must have been the original approach at the; // beginning.; // Let's consider this simple BFS algorithm from the `s` source:; // ```; // void bfs(Graph G, int s); // {; // Queue<Integer> queue = new Queue<Integer>();; // marked[s] = true; // Mark the source; // queue.enqueue(s); // and put it on the queue.; // while (!q.isEmpty()) {; // int v = queue.dequeue(); // Remove next vertex from the queue.; // for (int w : G.adj(v)); // if (!marked[w]) // For every unmarked adjacent vertex,; // {; // marked[w] = true;; // queue.enqueue(w);; // }; // }; // }; // ```; // Indeed, it has it's queue, which holds pairs of nodes, one from each graph,; // this is the `DeclsToCheck` member. `VisitedDecls` plays the role of the; // marking (`marked`) functionality above, we use it to check whether we've; // already seen a pair of nodes.; //; // We put in the elements into the queue only in the toplevel decl check; // function:; // ```; // static bool IsStructurallyEquivalent(StructuralEquivalenceContext &Context,; // Decl *D1, Decl *D2);; // ```; // The `while` loop where we iterate over the children is implemented in; // `Finish()`. And `Finish` is called only from the two **member** functions; // which check the equivalency of two Decls or two Types. ASTImporter (and; // other clients) call only these functions.; //; // The `static` implementation functions are called from `Finish`, these push",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ASTStructuralEquivalence.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTStructuralEquivalence.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTStructuralEquivalence.cpp:863,Performance,queue,queue,863,"//===- ASTStructuralEquivalence.cpp ---------------------------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implement StructuralEquivalenceContext class and helper functions; // for layout matching.; //; // The structural equivalence check could have been implemented as a parallel; // BFS on a pair of graphs. That must have been the original approach at the; // beginning.; // Let's consider this simple BFS algorithm from the `s` source:; // ```; // void bfs(Graph G, int s); // {; // Queue<Integer> queue = new Queue<Integer>();; // marked[s] = true; // Mark the source; // queue.enqueue(s); // and put it on the queue.; // while (!q.isEmpty()) {; // int v = queue.dequeue(); // Remove next vertex from the queue.; // for (int w : G.adj(v)); // if (!marked[w]) // For every unmarked adjacent vertex,; // {; // marked[w] = true;; // queue.enqueue(w);; // }; // }; // }; // ```; // Indeed, it has it's queue, which holds pairs of nodes, one from each graph,; // this is the `DeclsToCheck` member. `VisitedDecls` plays the role of the; // marking (`marked`) functionality above, we use it to check whether we've; // already seen a pair of nodes.; //; // We put in the elements into the queue only in the toplevel decl check; // function:; // ```; // static bool IsStructurallyEquivalent(StructuralEquivalenceContext &Context,; // Decl *D1, Decl *D2);; // ```; // The `while` loop where we iterate over the children is implemented in; // `Finish()`. And `Finish` is called only from the two **member** functions; // which check the equivalency of two Decls or two Types. ASTImporter (and; // other clients) call only these functions.; //; // The `static` implementation functions are called from `Finish`, these push",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ASTStructuralEquivalence.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTStructuralEquivalence.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTStructuralEquivalence.cpp:902,Performance,queue,queue,902,"//===- ASTStructuralEquivalence.cpp ---------------------------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implement StructuralEquivalenceContext class and helper functions; // for layout matching.; //; // The structural equivalence check could have been implemented as a parallel; // BFS on a pair of graphs. That must have been the original approach at the; // beginning.; // Let's consider this simple BFS algorithm from the `s` source:; // ```; // void bfs(Graph G, int s); // {; // Queue<Integer> queue = new Queue<Integer>();; // marked[s] = true; // Mark the source; // queue.enqueue(s); // and put it on the queue.; // while (!q.isEmpty()) {; // int v = queue.dequeue(); // Remove next vertex from the queue.; // for (int w : G.adj(v)); // if (!marked[w]) // For every unmarked adjacent vertex,; // {; // marked[w] = true;; // queue.enqueue(w);; // }; // }; // }; // ```; // Indeed, it has it's queue, which holds pairs of nodes, one from each graph,; // this is the `DeclsToCheck` member. `VisitedDecls` plays the role of the; // marking (`marked`) functionality above, we use it to check whether we've; // already seen a pair of nodes.; //; // We put in the elements into the queue only in the toplevel decl check; // function:; // ```; // static bool IsStructurallyEquivalent(StructuralEquivalenceContext &Context,; // Decl *D1, Decl *D2);; // ```; // The `while` loop where we iterate over the children is implemented in; // `Finish()`. And `Finish` is called only from the two **member** functions; // which check the equivalency of two Decls or two Types. ASTImporter (and; // other clients) call only these functions.; //; // The `static` implementation functions are called from `Finish`, these push",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ASTStructuralEquivalence.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTStructuralEquivalence.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTStructuralEquivalence.cpp:948,Performance,queue,queue,948,"//===- ASTStructuralEquivalence.cpp ---------------------------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implement StructuralEquivalenceContext class and helper functions; // for layout matching.; //; // The structural equivalence check could have been implemented as a parallel; // BFS on a pair of graphs. That must have been the original approach at the; // beginning.; // Let's consider this simple BFS algorithm from the `s` source:; // ```; // void bfs(Graph G, int s); // {; // Queue<Integer> queue = new Queue<Integer>();; // marked[s] = true; // Mark the source; // queue.enqueue(s); // and put it on the queue.; // while (!q.isEmpty()) {; // int v = queue.dequeue(); // Remove next vertex from the queue.; // for (int w : G.adj(v)); // if (!marked[w]) // For every unmarked adjacent vertex,; // {; // marked[w] = true;; // queue.enqueue(w);; // }; // }; // }; // ```; // Indeed, it has it's queue, which holds pairs of nodes, one from each graph,; // this is the `DeclsToCheck` member. `VisitedDecls` plays the role of the; // marking (`marked`) functionality above, we use it to check whether we've; // already seen a pair of nodes.; //; // We put in the elements into the queue only in the toplevel decl check; // function:; // ```; // static bool IsStructurallyEquivalent(StructuralEquivalenceContext &Context,; // Decl *D1, Decl *D2);; // ```; // The `while` loop where we iterate over the children is implemented in; // `Finish()`. And `Finish` is called only from the two **member** functions; // which check the equivalency of two Decls or two Types. ASTImporter (and; // other clients) call only these functions.; //; // The `static` implementation functions are called from `Finish`, these push",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ASTStructuralEquivalence.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTStructuralEquivalence.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTStructuralEquivalence.cpp:996,Performance,queue,queue,996,"//===- ASTStructuralEquivalence.cpp ---------------------------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implement StructuralEquivalenceContext class and helper functions; // for layout matching.; //; // The structural equivalence check could have been implemented as a parallel; // BFS on a pair of graphs. That must have been the original approach at the; // beginning.; // Let's consider this simple BFS algorithm from the `s` source:; // ```; // void bfs(Graph G, int s); // {; // Queue<Integer> queue = new Queue<Integer>();; // marked[s] = true; // Mark the source; // queue.enqueue(s); // and put it on the queue.; // while (!q.isEmpty()) {; // int v = queue.dequeue(); // Remove next vertex from the queue.; // for (int w : G.adj(v)); // if (!marked[w]) // For every unmarked adjacent vertex,; // {; // marked[w] = true;; // queue.enqueue(w);; // }; // }; // }; // ```; // Indeed, it has it's queue, which holds pairs of nodes, one from each graph,; // this is the `DeclsToCheck` member. `VisitedDecls` plays the role of the; // marking (`marked`) functionality above, we use it to check whether we've; // already seen a pair of nodes.; //; // We put in the elements into the queue only in the toplevel decl check; // function:; // ```; // static bool IsStructurallyEquivalent(StructuralEquivalenceContext &Context,; // Decl *D1, Decl *D2);; // ```; // The `while` loop where we iterate over the children is implemented in; // `Finish()`. And `Finish` is called only from the two **member** functions; // which check the equivalency of two Decls or two Types. ASTImporter (and; // other clients) call only these functions.; //; // The `static` implementation functions are called from `Finish`, these push",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ASTStructuralEquivalence.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTStructuralEquivalence.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTStructuralEquivalence.cpp:1121,Performance,queue,queue,1121,"-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implement StructuralEquivalenceContext class and helper functions; // for layout matching.; //; // The structural equivalence check could have been implemented as a parallel; // BFS on a pair of graphs. That must have been the original approach at the; // beginning.; // Let's consider this simple BFS algorithm from the `s` source:; // ```; // void bfs(Graph G, int s); // {; // Queue<Integer> queue = new Queue<Integer>();; // marked[s] = true; // Mark the source; // queue.enqueue(s); // and put it on the queue.; // while (!q.isEmpty()) {; // int v = queue.dequeue(); // Remove next vertex from the queue.; // for (int w : G.adj(v)); // if (!marked[w]) // For every unmarked adjacent vertex,; // {; // marked[w] = true;; // queue.enqueue(w);; // }; // }; // }; // ```; // Indeed, it has it's queue, which holds pairs of nodes, one from each graph,; // this is the `DeclsToCheck` member. `VisitedDecls` plays the role of the; // marking (`marked`) functionality above, we use it to check whether we've; // already seen a pair of nodes.; //; // We put in the elements into the queue only in the toplevel decl check; // function:; // ```; // static bool IsStructurallyEquivalent(StructuralEquivalenceContext &Context,; // Decl *D1, Decl *D2);; // ```; // The `while` loop where we iterate over the children is implemented in; // `Finish()`. And `Finish` is called only from the two **member** functions; // which check the equivalency of two Decls or two Types. ASTImporter (and; // other clients) call only these functions.; //; // The `static` implementation functions are called from `Finish`, these push; // the children nodes to the queue via `static bool; // IsStructurallyEq",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ASTStructuralEquivalence.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTStructuralEquivalence.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTStructuralEquivalence.cpp:1189,Performance,queue,queue,1189,"or license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implement StructuralEquivalenceContext class and helper functions; // for layout matching.; //; // The structural equivalence check could have been implemented as a parallel; // BFS on a pair of graphs. That must have been the original approach at the; // beginning.; // Let's consider this simple BFS algorithm from the `s` source:; // ```; // void bfs(Graph G, int s); // {; // Queue<Integer> queue = new Queue<Integer>();; // marked[s] = true; // Mark the source; // queue.enqueue(s); // and put it on the queue.; // while (!q.isEmpty()) {; // int v = queue.dequeue(); // Remove next vertex from the queue.; // for (int w : G.adj(v)); // if (!marked[w]) // For every unmarked adjacent vertex,; // {; // marked[w] = true;; // queue.enqueue(w);; // }; // }; // }; // ```; // Indeed, it has it's queue, which holds pairs of nodes, one from each graph,; // this is the `DeclsToCheck` member. `VisitedDecls` plays the role of the; // marking (`marked`) functionality above, we use it to check whether we've; // already seen a pair of nodes.; //; // We put in the elements into the queue only in the toplevel decl check; // function:; // ```; // static bool IsStructurallyEquivalent(StructuralEquivalenceContext &Context,; // Decl *D1, Decl *D2);; // ```; // The `while` loop where we iterate over the children is implemented in; // `Finish()`. And `Finish` is called only from the two **member** functions; // which check the equivalency of two Decls or two Types. ASTImporter (and; // other clients) call only these functions.; //; // The `static` implementation functions are called from `Finish`, these push; // the children nodes to the queue via `static bool; // IsStructurallyEquivalent(StructuralEquivalenceContext &Context, Decl *D1,; // Decl *D2)`. So far so good, this is almost like the BFS. However, if",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ASTStructuralEquivalence.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTStructuralEquivalence.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTStructuralEquivalence.cpp:1472,Performance,queue,queue,1472,"ir of graphs. That must have been the original approach at the; // beginning.; // Let's consider this simple BFS algorithm from the `s` source:; // ```; // void bfs(Graph G, int s); // {; // Queue<Integer> queue = new Queue<Integer>();; // marked[s] = true; // Mark the source; // queue.enqueue(s); // and put it on the queue.; // while (!q.isEmpty()) {; // int v = queue.dequeue(); // Remove next vertex from the queue.; // for (int w : G.adj(v)); // if (!marked[w]) // For every unmarked adjacent vertex,; // {; // marked[w] = true;; // queue.enqueue(w);; // }; // }; // }; // ```; // Indeed, it has it's queue, which holds pairs of nodes, one from each graph,; // this is the `DeclsToCheck` member. `VisitedDecls` plays the role of the; // marking (`marked`) functionality above, we use it to check whether we've; // already seen a pair of nodes.; //; // We put in the elements into the queue only in the toplevel decl check; // function:; // ```; // static bool IsStructurallyEquivalent(StructuralEquivalenceContext &Context,; // Decl *D1, Decl *D2);; // ```; // The `while` loop where we iterate over the children is implemented in; // `Finish()`. And `Finish` is called only from the two **member** functions; // which check the equivalency of two Decls or two Types. ASTImporter (and; // other clients) call only these functions.; //; // The `static` implementation functions are called from `Finish`, these push; // the children nodes to the queue via `static bool; // IsStructurallyEquivalent(StructuralEquivalenceContext &Context, Decl *D1,; // Decl *D2)`. So far so good, this is almost like the BFS. However, if we; // let a static implementation function to call `Finish` via another **member**; // function that means we end up with two nested while loops each of them; // working on the same queue. This is wrong and nobody can reason about it's; // doing. Thus, static implementation functions must not call the **member**; // functions.; //; //===-------------------------------------",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ASTStructuralEquivalence.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTStructuralEquivalence.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTStructuralEquivalence.cpp:2032,Performance,queue,queue,2032,"riginal approach at the; // beginning.; // Let's consider this simple BFS algorithm from the `s` source:; // ```; // void bfs(Graph G, int s); // {; // Queue<Integer> queue = new Queue<Integer>();; // marked[s] = true; // Mark the source; // queue.enqueue(s); // and put it on the queue.; // while (!q.isEmpty()) {; // int v = queue.dequeue(); // Remove next vertex from the queue.; // for (int w : G.adj(v)); // if (!marked[w]) // For every unmarked adjacent vertex,; // {; // marked[w] = true;; // queue.enqueue(w);; // }; // }; // }; // ```; // Indeed, it has it's queue, which holds pairs of nodes, one from each graph,; // this is the `DeclsToCheck` member. `VisitedDecls` plays the role of the; // marking (`marked`) functionality above, we use it to check whether we've; // already seen a pair of nodes.; //; // We put in the elements into the queue only in the toplevel decl check; // function:; // ```; // static bool IsStructurallyEquivalent(StructuralEquivalenceContext &Context,; // Decl *D1, Decl *D2);; // ```; // The `while` loop where we iterate over the children is implemented in; // `Finish()`. And `Finish` is called only from the two **member** functions; // which check the equivalency of two Decls or two Types. ASTImporter (and; // other clients) call only these functions.; //; // The `static` implementation functions are called from `Finish`, these push; // the children nodes to the queue via `static bool; // IsStructurallyEquivalent(StructuralEquivalenceContext &Context, Decl *D1,; // Decl *D2)`. So far so good, this is almost like the BFS. However, if we; // let a static implementation function to call `Finish` via another **member**; // function that means we end up with two nested while loops each of them; // working on the same queue. This is wrong and nobody can reason about it's; // doing. Thus, static implementation functions must not call the **member**; // functions.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ASTStructuralEquivalence.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTStructuralEquivalence.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTStructuralEquivalence.cpp:2389,Performance,queue,queue,2389,"riginal approach at the; // beginning.; // Let's consider this simple BFS algorithm from the `s` source:; // ```; // void bfs(Graph G, int s); // {; // Queue<Integer> queue = new Queue<Integer>();; // marked[s] = true; // Mark the source; // queue.enqueue(s); // and put it on the queue.; // while (!q.isEmpty()) {; // int v = queue.dequeue(); // Remove next vertex from the queue.; // for (int w : G.adj(v)); // if (!marked[w]) // For every unmarked adjacent vertex,; // {; // marked[w] = true;; // queue.enqueue(w);; // }; // }; // }; // ```; // Indeed, it has it's queue, which holds pairs of nodes, one from each graph,; // this is the `DeclsToCheck` member. `VisitedDecls` plays the role of the; // marking (`marked`) functionality above, we use it to check whether we've; // already seen a pair of nodes.; //; // We put in the elements into the queue only in the toplevel decl check; // function:; // ```; // static bool IsStructurallyEquivalent(StructuralEquivalenceContext &Context,; // Decl *D1, Decl *D2);; // ```; // The `while` loop where we iterate over the children is implemented in; // `Finish()`. And `Finish` is called only from the two **member** functions; // which check the equivalency of two Decls or two Types. ASTImporter (and; // other clients) call only these functions.; //; // The `static` implementation functions are called from `Finish`, these push; // the children nodes to the queue via `static bool; // IsStructurallyEquivalent(StructuralEquivalenceContext &Context, Decl *D1,; // Decl *D2)`. So far so good, this is almost like the BFS. However, if we; // let a static implementation function to call `Finish` via another **member**; // function that means we end up with two nested while loops each of them; // working on the same queue. This is wrong and nobody can reason about it's; // doing. Thus, static implementation functions must not call the **member**; // functions.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ASTStructuralEquivalence.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTStructuralEquivalence.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTStructuralEquivalence.cpp:684,Usability,simpl,simple,684,"//===- ASTStructuralEquivalence.cpp ---------------------------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implement StructuralEquivalenceContext class and helper functions; // for layout matching.; //; // The structural equivalence check could have been implemented as a parallel; // BFS on a pair of graphs. That must have been the original approach at the; // beginning.; // Let's consider this simple BFS algorithm from the `s` source:; // ```; // void bfs(Graph G, int s); // {; // Queue<Integer> queue = new Queue<Integer>();; // marked[s] = true; // Mark the source; // queue.enqueue(s); // and put it on the queue.; // while (!q.isEmpty()) {; // int v = queue.dequeue(); // Remove next vertex from the queue.; // for (int w : G.adj(v)); // if (!marked[w]) // For every unmarked adjacent vertex,; // {; // marked[w] = true;; // queue.enqueue(w);; // }; // }; // }; // ```; // Indeed, it has it's queue, which holds pairs of nodes, one from each graph,; // this is the `DeclsToCheck` member. `VisitedDecls` plays the role of the; // marking (`marked`) functionality above, we use it to check whether we've; // already seen a pair of nodes.; //; // We put in the elements into the queue only in the toplevel decl check; // function:; // ```; // static bool IsStructurallyEquivalent(StructuralEquivalenceContext &Context,; // Decl *D1, Decl *D2);; // ```; // The `while` loop where we iterate over the children is implemented in; // `Finish()`. And `Finish` is called only from the two **member** functions; // which check the equivalency of two Decls or two Types. ASTImporter (and; // other clients) call only these functions.; //; // The `static` implementation functions are called from `Finish`, these push",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ASTStructuralEquivalence.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTStructuralEquivalence.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTStructuralEquivalence.cpp:33,Testability,log,logic,33,/// Encapsulates Stmt comparison logic.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ASTStructuralEquivalence.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTStructuralEquivalence.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTStructuralEquivalence.cpp:18,Integrability,depend,depend,18,// Semantics only depend on children.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ASTStructuralEquivalence.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTStructuralEquivalence.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTStructuralEquivalence.cpp:315,Performance,optimiz,optimization,315,"// Number of children is actually checked by the generic children comparison; // code, but a CompoundStmt is one of the few statements where the number of; // children frequently differs and the number of statements is also always; // precomputed. Directly comparing the number of children here is thus; // just an optimization.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ASTStructuralEquivalence.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTStructuralEquivalence.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTStructuralEquivalence.cpp:8,Integrability,wrap,wraps,8,// Just wraps a StringLiteral child.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ASTStructuralEquivalence.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTStructuralEquivalence.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTStructuralEquivalence.cpp:18,Integrability,depend,depend,18,// Semantics only depend on children.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ASTStructuralEquivalence.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTStructuralEquivalence.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTStructuralEquivalence.cpp:80,Availability,down,down,80,"// We aren't being strict about token-to-token equivalence of types,; // so map down to the canonical type.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ASTStructuralEquivalence.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTStructuralEquivalence.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTStructuralEquivalence.cpp:180,Performance,Load,LoadFieldsFromExternalStorage,180,// If any of the records has external storage and we do a minimal check (or; // AST import) we assume they are equivalent. (If we didn't have this; // assumption then `RecordDecl::LoadFieldsFromExternalStorage` could trigger; // another AST import which in turn would call the structural equivalency; // check again and finally we'd have an improper result.),MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ASTStructuralEquivalence.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTStructuralEquivalence.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTStructuralEquivalence.cpp:33,Modifiability,inherit,inheritance,33,// Check virtual vs. non-virtual inheritance mismatch.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ASTStructuralEquivalence.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTStructuralEquivalence.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTStructuralEquivalence.cpp:11,Integrability,protocol,protocols,11,// Compare protocols.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ASTStructuralEquivalence.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTStructuralEquivalence.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTStructuralEquivalence.cpp:267,Availability,fault,faulty,267,"// Ensure that the implementation functions (all static functions in this TU); // never call the public ASTStructuralEquivalence::IsEquivalent() functions,; // because that will wreak havoc the internal state (DeclsToCheck and; // VisitedDecls members) and can cause faulty behaviour.; // In other words: Do not start a graph search from a new node with the; // internal data of another search in progress.; // FIXME: Better encapsulation and separation of internal and public; // functionality.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ASTStructuralEquivalence.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTStructuralEquivalence.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTTypeTraits.cpp:549,Safety,safe,safe,549,"//===--- ASTTypeTraits.cpp --------------------------------------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // Provides a dynamic type identifier and a dynamically typed node container; // that can be used to store an AST base node at runtime in the same storage in; // a type safe way.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ASTTypeTraits.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTTypeTraits.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/AttrImpl.cpp:37,Testability,test,testing,37,// Use fake syntax because it is for testing and debugging purpose only.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/AttrImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/AttrImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Comment.cpp:69,Energy Efficiency,allocate,allocated,69,// Check that no comment class has a non-trival destructor. They are allocated; // with a BumpPtrAllocator and therefore their destructor is not executed.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/Comment.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Comment.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Comment.cpp:20,Energy Efficiency,allocate,allocated,20,// DeclInfo is also allocated with a BumpPtrAllocator.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/Comment.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Comment.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Comment.cpp:182,Integrability,wrap,wrapper,182,"// If we have a typedef to a template specialization with exactly one; // template argument of a function type, this looks like std::function,; // boost::function, or other function wrapper. Treat these typedefs as; // functions.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/Comment.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Comment.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/CommentCommandTraits.cpp:94,Testability,log,logic,94,"// Single-character command impostures, such as \t or \n, should not go; // through the fixit logic.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/CommentCommandTraits.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/CommentCommandTraits.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/CommentCommandTraits.cpp:131,Integrability,wrap,wrap,131,"// We only have a limited number of bits to encode command IDs in the; // CommandInfo structure, so the ID numbers can potentially wrap around.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/CommentCommandTraits.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/CommentCommandTraits.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/CommentSema.cpp:28,Integrability,interface,interface,28,"// Allow @class command on @interface declarations.; // FIXME. Currently, \class and @class are indistinguishable. So,; // \class is also allowed on an @interface declaration",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/CommentSema.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/CommentSema.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/CommentSema.cpp:153,Integrability,interface,interface,153,"// Allow @class command on @interface declarations.; // FIXME. Currently, \class and @class are indistinguishable. So,; // \class is also allowed on an @interface declaration",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/CommentSema.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/CommentSema.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ComparisonCategories.cpp:9,Modifiability,Extend,Extend,9,// TODO: Extend support for operator<=> to ObjC types.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ComparisonCategories.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ComparisonCategories.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ComparisonCategories.cpp:30,Performance,cache,cache,30,// Check if we already have a cache entry for this value.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ComparisonCategories.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ComparisonCategories.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ComparisonCategories.cpp:45,Modifiability,variab,variable,45,// We don't have a cached result. Lookup the variable declaration and create; // a new entry representing it.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ComparisonCategories.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ComparisonCategories.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ComparisonCategories.cpp:19,Performance,cache,cached,19,// We don't have a cached result. Lookup the variable declaration and create; // a new entry representing it.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ComparisonCategories.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ComparisonCategories.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ComparisonCategories.cpp:62,Performance,cache,cached,62,// Check to see if we have information for the specified type cached.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ComparisonCategories.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ComparisonCategories.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ComparisonCategories.cpp:57,Performance,cache,cache,57,// We've found the comparison category type. Build a new cache entry for; // it.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ComparisonCategories.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ComparisonCategories.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ComputeDependence.cpp:111,Integrability,depend,dependent,111,// C++ [temp.dep.constexpr]p5:; // An expression of the form & qualified-id where the qualified-id names a; // dependent member of the current instantiation is value-dependent. An; // expression of the form & cast-expression is also value-dependent if; // evaluating cast-expression as a core constant expression succeeds and; // the result of the evaluation refers to a templated entity that is an; // object with static or thread storage duration or a member function.; //; // What this amounts to is: constant-evaluate the operand and check whether it; // refers to a templated entity other than a variable with local storage.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ComputeDependence.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ComputeDependence.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ComputeDependence.cpp:166,Integrability,depend,dependent,166,// C++ [temp.dep.constexpr]p5:; // An expression of the form & qualified-id where the qualified-id names a; // dependent member of the current instantiation is value-dependent. An; // expression of the form & cast-expression is also value-dependent if; // evaluating cast-expression as a core constant expression succeeds and; // the result of the evaluation refers to a templated entity that is an; // object with static or thread storage duration or a member function.; //; // What this amounts to is: constant-evaluate the operand and check whether it; // refers to a templated entity other than a variable with local storage.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ComputeDependence.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ComputeDependence.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ComputeDependence.cpp:239,Integrability,depend,dependent,239,// C++ [temp.dep.constexpr]p5:; // An expression of the form & qualified-id where the qualified-id names a; // dependent member of the current instantiation is value-dependent. An; // expression of the form & cast-expression is also value-dependent if; // evaluating cast-expression as a core constant expression succeeds and; // the result of the evaluation refers to a templated entity that is an; // object with static or thread storage duration or a member function.; //; // What this amounts to is: constant-evaluate the operand and check whether it; // refers to a templated entity other than a variable with local storage.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ComputeDependence.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ComputeDependence.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ComputeDependence.cpp:601,Modifiability,variab,variable,601,// C++ [temp.dep.constexpr]p5:; // An expression of the form & qualified-id where the qualified-id names a; // dependent member of the current instantiation is value-dependent. An; // expression of the form & cast-expression is also value-dependent if; // evaluating cast-expression as a core constant expression succeeds and; // the result of the evaluation refers to a templated entity that is an; // object with static or thread storage duration or a member function.; //; // What this amounts to is: constant-evaluate the operand and check whether it; // refers to a templated entity other than a variable with local storage.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ComputeDependence.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ComputeDependence.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ComputeDependence.cpp:14,Integrability,depend,dependent,14,// Never type-dependent (C++ [temp.dep.expr]p3).; // Value-dependent if the argument is type-dependent.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ComputeDependence.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ComputeDependence.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ComputeDependence.cpp:59,Integrability,depend,dependent,59,// Never type-dependent (C++ [temp.dep.expr]p3).; // Value-dependent if the argument is type-dependent.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ComputeDependence.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ComputeDependence.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ComputeDependence.cpp:93,Integrability,depend,dependent,93,// Never type-dependent (C++ [temp.dep.expr]p3).; // Value-dependent if the argument is type-dependent.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ComputeDependence.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ComputeDependence.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ComputeDependence.cpp:9,Integrability,depend,dependent,9,// Value-dependent if the argument is type-dependent.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ComputeDependence.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ComputeDependence.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ComputeDependence.cpp:43,Integrability,depend,dependent,43,// Value-dependent if the argument is type-dependent.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ComputeDependence.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ComputeDependence.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ComputeDependence.cpp:77,Integrability,depend,dependent,77,// Check to see if we are in the situation where alignof(decl) should be; // dependent because decl's alignment is dependent.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ComputeDependence.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ComputeDependence.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ComputeDependence.cpp:115,Integrability,depend,dependent,115,// Check to see if we are in the situation where alignof(decl) should be; // dependent because decl's alignment is dependent.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ComputeDependence.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ComputeDependence.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ComputeDependence.cpp:50,Integrability,depend,dependence,50,"// We model implicit conversions as combining the dependence of their; // subexpression, apart from its type, with the semantic portion of the; // target type.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ComputeDependence.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ComputeDependence.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ComputeDependence.cpp:29,Integrability,depend,dependent,29,"// Cast expressions are type-dependent if the type is; // dependent (C++ [temp.dep.expr]p3).; // Cast expressions are value-dependent if the type is; // dependent or if the subexpression is value-dependent.; //; // Note that we also need to consider the dependence of the actual type here,; // because when the type as written is a deduced type, that type is not; // dependent, but it may be deduced as a dependent type.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ComputeDependence.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ComputeDependence.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ComputeDependence.cpp:58,Integrability,depend,dependent,58,"// Cast expressions are type-dependent if the type is; // dependent (C++ [temp.dep.expr]p3).; // Cast expressions are value-dependent if the type is; // dependent or if the subexpression is value-dependent.; //; // Note that we also need to consider the dependence of the actual type here,; // because when the type as written is a deduced type, that type is not; // dependent, but it may be deduced as a dependent type.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ComputeDependence.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ComputeDependence.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ComputeDependence.cpp:124,Integrability,depend,dependent,124,"// Cast expressions are type-dependent if the type is; // dependent (C++ [temp.dep.expr]p3).; // Cast expressions are value-dependent if the type is; // dependent or if the subexpression is value-dependent.; //; // Note that we also need to consider the dependence of the actual type here,; // because when the type as written is a deduced type, that type is not; // dependent, but it may be deduced as a dependent type.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ComputeDependence.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ComputeDependence.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ComputeDependence.cpp:153,Integrability,depend,dependent,153,"// Cast expressions are type-dependent if the type is; // dependent (C++ [temp.dep.expr]p3).; // Cast expressions are value-dependent if the type is; // dependent or if the subexpression is value-dependent.; //; // Note that we also need to consider the dependence of the actual type here,; // because when the type as written is a deduced type, that type is not; // dependent, but it may be deduced as a dependent type.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ComputeDependence.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ComputeDependence.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ComputeDependence.cpp:196,Integrability,depend,dependent,196,"// Cast expressions are type-dependent if the type is; // dependent (C++ [temp.dep.expr]p3).; // Cast expressions are value-dependent if the type is; // dependent or if the subexpression is value-dependent.; //; // Note that we also need to consider the dependence of the actual type here,; // because when the type as written is a deduced type, that type is not; // dependent, but it may be deduced as a dependent type.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ComputeDependence.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ComputeDependence.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ComputeDependence.cpp:254,Integrability,depend,dependence,254,"// Cast expressions are type-dependent if the type is; // dependent (C++ [temp.dep.expr]p3).; // Cast expressions are value-dependent if the type is; // dependent or if the subexpression is value-dependent.; //; // Note that we also need to consider the dependence of the actual type here,; // because when the type as written is a deduced type, that type is not; // dependent, but it may be deduced as a dependent type.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ComputeDependence.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ComputeDependence.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ComputeDependence.cpp:367,Integrability,depend,dependent,367,"// Cast expressions are type-dependent if the type is; // dependent (C++ [temp.dep.expr]p3).; // Cast expressions are value-dependent if the type is; // dependent or if the subexpression is value-dependent.; //; // Note that we also need to consider the dependence of the actual type here,; // because when the type as written is a deduced type, that type is not; // dependent, but it may be deduced as a dependent type.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ComputeDependence.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ComputeDependence.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ComputeDependence.cpp:405,Integrability,depend,dependent,405,"// Cast expressions are type-dependent if the type is; // dependent (C++ [temp.dep.expr]p3).; // Cast expressions are value-dependent if the type is; // dependent or if the subexpression is value-dependent.; //; // Note that we also need to consider the dependence of the actual type here,; // because when the type as written is a deduced type, that type is not; // dependent, but it may be deduced as a dependent type.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ComputeDependence.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ComputeDependence.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ComputeDependence.cpp:40,Integrability,depend,depends,40,"// The type of the conditional operator depends on the type of the conditional; // to support the GCC vector conditional extension. Additionally,; // [temp.dep.expr] does specify state that this should be dependent on ALL sub; // expressions.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ComputeDependence.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ComputeDependence.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ComputeDependence.cpp:205,Integrability,depend,dependent,205,"// The type of the conditional operator depends on the type of the conditional; // to support the GCC vector conditional extension. Additionally,; // [temp.dep.expr] does specify state that this should be dependent on ALL sub; // expressions.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ComputeDependence.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ComputeDependence.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ComputeDependence.cpp:13,Integrability,depend,dependence,13,// Propagate dependence of the result.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ComputeDependence.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ComputeDependence.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ComputeDependence.cpp:46,Integrability,depend,dependent,46,// Note: we treat a statement-expression in a dependent context as always; // being value- and instantiation-dependent. This matches the behavior of; // lambda-expressions and GCC.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ComputeDependence.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ComputeDependence.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ComputeDependence.cpp:109,Integrability,depend,dependent,109,// Note: we treat a statement-expression in a dependent context as always; // being value- and instantiation-dependent. This matches the behavior of; // lambda-expressions and GCC.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ComputeDependence.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ComputeDependence.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ComputeDependence.cpp:25,Integrability,depend,dependency,25,// Take type- and value- dependency from the active branch. Propagate all; // other flags from all branches.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ComputeDependence.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ComputeDependence.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ComputeDependence.cpp:24,Integrability,depend,dependent,24,// typeid is never type-dependent (C++ [temp.dep.expr]p4),MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ComputeDependence.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ComputeDependence.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ComputeDependence.cpp:18,Integrability,depend,dependent,18,// 'this' is type-dependent if the class type of the enclosing; // member function is dependent (C++ [temp.dep.expr]p2),MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ComputeDependence.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ComputeDependence.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ComputeDependence.cpp:86,Integrability,depend,dependent,86,// 'this' is type-dependent if the class type of the enclosing; // member function is dependent (C++ [temp.dep.expr]p2),MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ComputeDependence.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ComputeDependence.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ComputeDependence.cpp:14,Integrability,depend,dependent,14,// Never type-dependent.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ComputeDependence.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ComputeDependence.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ComputeDependence.cpp:9,Integrability,depend,dependent,9,// Value-dependent if the argument is type-dependent.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ComputeDependence.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ComputeDependence.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ComputeDependence.cpp:43,Integrability,depend,dependent,43,// Value-dependent if the argument is type-dependent.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ComputeDependence.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ComputeDependence.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ComputeDependence.cpp:50,Integrability,depend,dependent,50,"// If the type is omitted, it's 'int', and is not dependent in any way.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ComputeDependence.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ComputeDependence.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ComputeDependence.cpp:49,Integrability,depend,dependence,49,"/// Compute the type-, value-, and instantiation-dependence of a; /// declaration reference; /// based on the declaration being referenced.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ComputeDependence.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ComputeDependence.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ComputeDependence.cpp:55,Integrability,depend,dependent,55,"// C++ [temp.dep.expr]p3:; // An id-expression is type-dependent if it contains:; // - an identifier associated by name lookup with one or more declarations; // declared with a dependent type; // - an identifier associated by name lookup with an entity captured by; // copy ([expr.prim.lambda.capture]); // in a lambda-expression that has an explicit object parameter whose; // type is dependent ([dcl.fct]),; //; // [The ""or more"" case is not modeled as a DeclRefExpr. There are a bunch; // more bullets here that we handle by treating the declaration as having a; // dependent type if they involve a placeholder type that can't be deduced.]",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ComputeDependence.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ComputeDependence.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ComputeDependence.cpp:177,Integrability,depend,dependent,177,"// C++ [temp.dep.expr]p3:; // An id-expression is type-dependent if it contains:; // - an identifier associated by name lookup with one or more declarations; // declared with a dependent type; // - an identifier associated by name lookup with an entity captured by; // copy ([expr.prim.lambda.capture]); // in a lambda-expression that has an explicit object parameter whose; // type is dependent ([dcl.fct]),; //; // [The ""or more"" case is not modeled as a DeclRefExpr. There are a bunch; // more bullets here that we handle by treating the declaration as having a; // dependent type if they involve a placeholder type that can't be deduced.]",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ComputeDependence.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ComputeDependence.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ComputeDependence.cpp:386,Integrability,depend,dependent,386,"// C++ [temp.dep.expr]p3:; // An id-expression is type-dependent if it contains:; // - an identifier associated by name lookup with one or more declarations; // declared with a dependent type; // - an identifier associated by name lookup with an entity captured by; // copy ([expr.prim.lambda.capture]); // in a lambda-expression that has an explicit object parameter whose; // type is dependent ([dcl.fct]),; //; // [The ""or more"" case is not modeled as a DeclRefExpr. There are a bunch; // more bullets here that we handle by treating the declaration as having a; // dependent type if they involve a placeholder type that can't be deduced.]",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ComputeDependence.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ComputeDependence.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ComputeDependence.cpp:569,Integrability,depend,dependent,569,"// C++ [temp.dep.expr]p3:; // An id-expression is type-dependent if it contains:; // - an identifier associated by name lookup with one or more declarations; // declared with a dependent type; // - an identifier associated by name lookup with an entity captured by; // copy ([expr.prim.lambda.capture]); // in a lambda-expression that has an explicit object parameter whose; // type is dependent ([dcl.fct]),; //; // [The ""or more"" case is not modeled as a DeclRefExpr. There are a bunch; // more bullets here that we handle by treating the declaration as having a; // dependent type if they involve a placeholder type that can't be deduced.]",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ComputeDependence.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ComputeDependence.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ComputeDependence.cpp:47,Integrability,depend,dependent,47,// - a conversion-function-id that specifies a dependent type,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ComputeDependence.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ComputeDependence.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ComputeDependence.cpp:27,Integrability,depend,dependent,27,"// - a template-id that is dependent,; // - a nested-name-specifier or a qualified-id that names a member of an; // unknown specialization; // [These are not modeled as DeclRefExprs.]; // or if it names a dependent member of the current instantiation that is a; // static data member of type ""array of unknown bound of T"" for some T; // [handled below].; // C++ [temp.dep.constexpr]p2:; // An id-expression is value-dependent if:; // - it is type-dependent [handled above]; // - it is the name of a non-type template parameter,",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ComputeDependence.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ComputeDependence.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ComputeDependence.cpp:205,Integrability,depend,dependent,205,"// - a template-id that is dependent,; // - a nested-name-specifier or a qualified-id that names a member of an; // unknown specialization; // [These are not modeled as DeclRefExprs.]; // or if it names a dependent member of the current instantiation that is a; // static data member of type ""array of unknown bound of T"" for some T; // [handled below].; // C++ [temp.dep.constexpr]p2:; // An id-expression is value-dependent if:; // - it is type-dependent [handled above]; // - it is the name of a non-type template parameter,",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ComputeDependence.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ComputeDependence.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ComputeDependence.cpp:416,Integrability,depend,dependent,416,"// - a template-id that is dependent,; // - a nested-name-specifier or a qualified-id that names a member of an; // unknown specialization; // [These are not modeled as DeclRefExprs.]; // or if it names a dependent member of the current instantiation that is a; // static data member of type ""array of unknown bound of T"" for some T; // [handled below].; // C++ [temp.dep.constexpr]p2:; // An id-expression is value-dependent if:; // - it is type-dependent [handled above]; // - it is the name of a non-type template parameter,",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ComputeDependence.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ComputeDependence.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ComputeDependence.cpp:447,Integrability,depend,dependent,447,"// - a template-id that is dependent,; // - a nested-name-specifier or a qualified-id that names a member of an; // unknown specialization; // [These are not modeled as DeclRefExprs.]; // or if it names a dependent member of the current instantiation that is a; // static data member of type ""array of unknown bound of T"" for some T; // [handled below].; // C++ [temp.dep.constexpr]p2:; // An id-expression is value-dependent if:; // - it is type-dependent [handled above]; // - it is the name of a non-type template parameter,",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ComputeDependence.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ComputeDependence.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ComputeDependence.cpp:103,Integrability,depend,dependent,103,// - it names a potentially-constant variable that is initialized with an; // expression that is value-dependent,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ComputeDependence.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ComputeDependence.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ComputeDependence.cpp:37,Modifiability,variab,variable,37,// - it names a potentially-constant variable that is initialized with an; // expression that is value-dependent,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ComputeDependence.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ComputeDependence.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ComputeDependence.cpp:45,Integrability,depend,dependent,45,"// - it names a static data member that is a dependent member of the; // current instantiation and is not initialized in a member-declarator,",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ComputeDependence.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ComputeDependence.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ComputeDependence.cpp:49,Integrability,depend,dependent,49,"// - it names a static member function that is a dependent member of the; // current instantiation; //; // FIXME: It's unclear that the restriction to static members here has any; // effect: any use of a non-static member function name requires either; // forming a pointer-to-member or providing an object parameter, either of; // which makes the overall expression value-dependent.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ComputeDependence.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ComputeDependence.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ComputeDependence.cpp:373,Integrability,depend,dependent,373,"// - it names a static member function that is a dependent member of the; // current instantiation; //; // FIXME: It's unclear that the restriction to static members here has any; // effect: any use of a non-static member function name requires either; // forming a pointer-to-member or providing an object parameter, either of; // which makes the overall expression value-dependent.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ComputeDependence.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ComputeDependence.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ComputeDependence.cpp:3,Availability,Recover,RecoveryExpr,3,"// RecoveryExpr is; // - always value-dependent, and therefore instantiation dependent; // - contains errors (ExprDependence::Error), by definition; // - type-dependent if we don't know the type (fallback to an opaque; // dependent type), or the type is known and dependent, or it has; // type-dependent subexpressions.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ComputeDependence.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ComputeDependence.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ComputeDependence.cpp:102,Availability,error,errors,102,"// RecoveryExpr is; // - always value-dependent, and therefore instantiation dependent; // - contains errors (ExprDependence::Error), by definition; // - type-dependent if we don't know the type (fallback to an opaque; // dependent type), or the type is known and dependent, or it has; // type-dependent subexpressions.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ComputeDependence.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ComputeDependence.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ComputeDependence.cpp:126,Availability,Error,Error,126,"// RecoveryExpr is; // - always value-dependent, and therefore instantiation dependent; // - contains errors (ExprDependence::Error), by definition; // - type-dependent if we don't know the type (fallback to an opaque; // dependent type), or the type is known and dependent, or it has; // type-dependent subexpressions.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ComputeDependence.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ComputeDependence.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ComputeDependence.cpp:38,Integrability,depend,dependent,38,"// RecoveryExpr is; // - always value-dependent, and therefore instantiation dependent; // - contains errors (ExprDependence::Error), by definition; // - type-dependent if we don't know the type (fallback to an opaque; // dependent type), or the type is known and dependent, or it has; // type-dependent subexpressions.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ComputeDependence.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ComputeDependence.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ComputeDependence.cpp:77,Integrability,depend,dependent,77,"// RecoveryExpr is; // - always value-dependent, and therefore instantiation dependent; // - contains errors (ExprDependence::Error), by definition; // - type-dependent if we don't know the type (fallback to an opaque; // dependent type), or the type is known and dependent, or it has; // type-dependent subexpressions.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ComputeDependence.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ComputeDependence.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ComputeDependence.cpp:159,Integrability,depend,dependent,159,"// RecoveryExpr is; // - always value-dependent, and therefore instantiation dependent; // - contains errors (ExprDependence::Error), by definition; // - type-dependent if we don't know the type (fallback to an opaque; // dependent type), or the type is known and dependent, or it has; // type-dependent subexpressions.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ComputeDependence.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ComputeDependence.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ComputeDependence.cpp:222,Integrability,depend,dependent,222,"// RecoveryExpr is; // - always value-dependent, and therefore instantiation dependent; // - contains errors (ExprDependence::Error), by definition; // - type-dependent if we don't know the type (fallback to an opaque; // dependent type), or the type is known and dependent, or it has; // type-dependent subexpressions.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ComputeDependence.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ComputeDependence.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ComputeDependence.cpp:264,Integrability,depend,dependent,264,"// RecoveryExpr is; // - always value-dependent, and therefore instantiation dependent; // - contains errors (ExprDependence::Error), by definition; // - type-dependent if we don't know the type (fallback to an opaque; // dependent type), or the type is known and dependent, or it has; // type-dependent subexpressions.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ComputeDependence.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ComputeDependence.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ComputeDependence.cpp:294,Integrability,depend,dependent,294,"// RecoveryExpr is; // - always value-dependent, and therefore instantiation dependent; // - contains errors (ExprDependence::Error), by definition; // - type-dependent if we don't know the type (fallback to an opaque; // dependent type), or the type is known and dependent, or it has; // type-dependent subexpressions.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ComputeDependence.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ComputeDependence.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ComputeDependence.cpp:3,Safety,Recover,RecoveryExpr,3,"// RecoveryExpr is; // - always value-dependent, and therefore instantiation dependent; // - contains errors (ExprDependence::Error), by definition; // - type-dependent if we don't know the type (fallback to an opaque; // dependent type), or the type is known and dependent, or it has; // type-dependent subexpressions.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ComputeDependence.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ComputeDependence.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ComputeDependence.cpp:72,Availability,Recover,RecoveryExpr,72,"// FIXME: remove the type-dependent bit from subexpressions, if the; // RecoveryExpr has a non-dependent type.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ComputeDependence.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ComputeDependence.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ComputeDependence.cpp:26,Integrability,depend,dependent,26,"// FIXME: remove the type-dependent bit from subexpressions, if the; // RecoveryExpr has a non-dependent type.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ComputeDependence.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ComputeDependence.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ComputeDependence.cpp:95,Integrability,depend,dependent,95,"// FIXME: remove the type-dependent bit from subexpressions, if the; // RecoveryExpr has a non-dependent type.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ComputeDependence.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ComputeDependence.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ComputeDependence.cpp:72,Safety,Recover,RecoveryExpr,72,"// FIXME: remove the type-dependent bit from subexpressions, if the; // RecoveryExpr has a non-dependent type.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ComputeDependence.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ComputeDependence.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ComputeDependence.cpp:43,Modifiability,variab,variables,43,// dyn_cast_or_null is used to handle objC variables which do not; // have a declaration context.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ComputeDependence.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ComputeDependence.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ComputeDependence.cpp:23,Integrability,depend,dependent,23,// Bitfield with value-dependent width is type-dependent.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ComputeDependence.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ComputeDependence.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ComputeDependence.cpp:47,Integrability,depend,dependent,47,// Bitfield with value-dependent width is type-dependent.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ComputeDependence.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ComputeDependence.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ComputeDependence.cpp:25,Integrability,depend,dependence,25,// FIXME: move remaining dependence computation from MemberExpr::Create(),MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ComputeDependence.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ComputeDependence.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ComputeDependence.cpp:53,Integrability,depend,dependent,53,"// If we have explicit template arguments, check for dependent; // template arguments and whether they contain any unexpanded pack; // expansions.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ComputeDependence.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ComputeDependence.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/CXXABI.h:22,Integrability,Interface,Interface,22,"//===----- CXXABI.h - Interface to C++ ABIs ---------------------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This provides an abstract class for C++ AST support. Concrete; // subclasses of this implement AST support for specific C++ ABIs.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/CXXABI.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/CXXABI.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/CXXInheritance.cpp:402,Integrability,rout,routines,402,"//===- CXXInheritance.cpp - C++ Inheritance -------------------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file provides routines that help analyzing C++ inheritance hierarchies.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/CXXInheritance.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/CXXInheritance.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/CXXInheritance.cpp:32,Modifiability,Inherit,Inheritance,32,"//===- CXXInheritance.cpp - C++ Inheritance -------------------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file provides routines that help analyzing C++ inheritance hierarchies.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/CXXInheritance.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/CXXInheritance.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/CXXInheritance.cpp:435,Modifiability,inherit,inheritance,435,"//===- CXXInheritance.cpp - C++ Inheritance -------------------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file provides routines that help analyzing C++ inheritance hierarchies.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/CXXInheritance.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/CXXInheritance.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/CXXInheritance.cpp:4,Usability,clear,clear,4,/// clear - Clear out all prior path information.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/CXXInheritance.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/CXXInheritance.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/CXXInheritance.cpp:12,Usability,Clear,Clear,12,/// clear - Clear out all prior path information.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/CXXInheritance.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/CXXInheritance.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/CXXInheritance.cpp:2,Safety,Detect,DetectVirtual,2,/*DetectVirtual=*/,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/CXXInheritance.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/CXXInheritance.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/CXXInheritance.cpp:2,Safety,Detect,DetectVirtual,2,/*DetectVirtual=*/,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/CXXInheritance.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/CXXInheritance.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/CXXInheritance.cpp:18,Performance,queue,queue,18,// not actually a queue.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/CXXInheritance.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/CXXInheritance.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/CXXInheritance.cpp:26,Availability,down,down,26,// The access of the path down to this record.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/CXXInheritance.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/CXXInheritance.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/CXXInheritance.cpp:7,Security,access,access,7,// The access of the path down to this record.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/CXXInheritance.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/CXXInheritance.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/CXXInheritance.cpp:138,Integrability,depend,depends,138,"// C++ [temp.dep]p3:; // In the definition of a class template or a member of a class template,; // if a base class of the class template depends on a template-parameter,; // the base class scope is not examined during unqualified name lookup; // either at the point of definition of the class template or member or; // during an instantiation of the class tem- plate or member.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/CXXInheritance.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/CXXInheritance.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/CXXInheritance.cpp:22,Availability,down,down,22,"// Calculate the ""top-down"" access to this base class.; // The spec actually describes this bottom-up, but top-down is; // equivalent because the definition works out as follows:; // 1. Write down the access along each step in the inheritance; // chain, followed by the access of the decl itself.; // For example, in; // class A { public: int foo; };; // class B : protected A {};; // class C : public B {};; // class D : private C {};; // we would write:; // private public protected public; // 2. If 'private' appears anywhere except far-left, access is denied.; // 3. Otherwise, overall access is determined by the most restrictive; // access in the sequence.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/CXXInheritance.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/CXXInheritance.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/CXXInheritance.cpp:111,Availability,down,down,111,"// Calculate the ""top-down"" access to this base class.; // The spec actually describes this bottom-up, but top-down is; // equivalent because the definition works out as follows:; // 1. Write down the access along each step in the inheritance; // chain, followed by the access of the decl itself.; // For example, in; // class A { public: int foo; };; // class B : protected A {};; // class C : public B {};; // class D : private C {};; // we would write:; // private public protected public; // 2. If 'private' appears anywhere except far-left, access is denied.; // 3. Otherwise, overall access is determined by the most restrictive; // access in the sequence.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/CXXInheritance.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/CXXInheritance.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/CXXInheritance.cpp:192,Availability,down,down,192,"// Calculate the ""top-down"" access to this base class.; // The spec actually describes this bottom-up, but top-down is; // equivalent because the definition works out as follows:; // 1. Write down the access along each step in the inheritance; // chain, followed by the access of the decl itself.; // For example, in; // class A { public: int foo; };; // class B : protected A {};; // class C : public B {};; // class D : private C {};; // we would write:; // private public protected public; // 2. If 'private' appears anywhere except far-left, access is denied.; // 3. Otherwise, overall access is determined by the most restrictive; // access in the sequence.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/CXXInheritance.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/CXXInheritance.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/CXXInheritance.cpp:231,Modifiability,inherit,inheritance,231,"// Calculate the ""top-down"" access to this base class.; // The spec actually describes this bottom-up, but top-down is; // equivalent because the definition works out as follows:; // 1. Write down the access along each step in the inheritance; // chain, followed by the access of the decl itself.; // For example, in; // class A { public: int foo; };; // class B : protected A {};; // class C : public B {};; // class D : private C {};; // we would write:; // private public protected public; // 2. If 'private' appears anywhere except far-left, access is denied.; // 3. Otherwise, overall access is determined by the most restrictive; // access in the sequence.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/CXXInheritance.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/CXXInheritance.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/CXXInheritance.cpp:28,Security,access,access,28,"// Calculate the ""top-down"" access to this base class.; // The spec actually describes this bottom-up, but top-down is; // equivalent because the definition works out as follows:; // 1. Write down the access along each step in the inheritance; // chain, followed by the access of the decl itself.; // For example, in; // class A { public: int foo; };; // class B : protected A {};; // class C : public B {};; // class D : private C {};; // we would write:; // private public protected public; // 2. If 'private' appears anywhere except far-left, access is denied.; // 3. Otherwise, overall access is determined by the most restrictive; // access in the sequence.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/CXXInheritance.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/CXXInheritance.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/CXXInheritance.cpp:201,Security,access,access,201,"// Calculate the ""top-down"" access to this base class.; // The spec actually describes this bottom-up, but top-down is; // equivalent because the definition works out as follows:; // 1. Write down the access along each step in the inheritance; // chain, followed by the access of the decl itself.; // For example, in; // class A { public: int foo; };; // class B : protected A {};; // class C : public B {};; // class D : private C {};; // we would write:; // private public protected public; // 2. If 'private' appears anywhere except far-left, access is denied.; // 3. Otherwise, overall access is determined by the most restrictive; // access in the sequence.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/CXXInheritance.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/CXXInheritance.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/CXXInheritance.cpp:270,Security,access,access,270,"// Calculate the ""top-down"" access to this base class.; // The spec actually describes this bottom-up, but top-down is; // equivalent because the definition works out as follows:; // 1. Write down the access along each step in the inheritance; // chain, followed by the access of the decl itself.; // For example, in; // class A { public: int foo; };; // class B : protected A {};; // class C : public B {};; // class D : private C {};; // we would write:; // private public protected public; // 2. If 'private' appears anywhere except far-left, access is denied.; // 3. Otherwise, overall access is determined by the most restrictive; // access in the sequence.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/CXXInheritance.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/CXXInheritance.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/CXXInheritance.cpp:546,Security,access,access,546,"// Calculate the ""top-down"" access to this base class.; // The spec actually describes this bottom-up, but top-down is; // equivalent because the definition works out as follows:; // 1. Write down the access along each step in the inheritance; // chain, followed by the access of the decl itself.; // For example, in; // class A { public: int foo; };; // class B : protected A {};; // class C : public B {};; // class D : private C {};; // we would write:; // private public protected public; // 2. If 'private' appears anywhere except far-left, access is denied.; // 3. Otherwise, overall access is determined by the most restrictive; // access in the sequence.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/CXXInheritance.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/CXXInheritance.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/CXXInheritance.cpp:590,Security,access,access,590,"// Calculate the ""top-down"" access to this base class.; // The spec actually describes this bottom-up, but top-down is; // equivalent because the definition works out as follows:; // 1. Write down the access along each step in the inheritance; // chain, followed by the access of the decl itself.; // For example, in; // class A { public: int foo; };; // class B : protected A {};; // class C : public B {};; // class D : private C {};; // we would write:; // private public protected public; // 2. If 'private' appears anywhere except far-left, access is denied.; // 3. Otherwise, overall access is determined by the most restrictive; // access in the sequence.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/CXXInheritance.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/CXXInheritance.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/CXXInheritance.cpp:639,Security,access,access,639,"// Calculate the ""top-down"" access to this base class.; // The spec actually describes this bottom-up, but top-down is; // equivalent because the definition works out as follows:; // 1. Write down the access along each step in the inheritance; // chain, followed by the access of the decl itself.; // For example, in; // class A { public: int foo; };; // class B : protected A {};; // class C : public B {};; // class D : private C {};; // we would write:; // private public protected public; // 2. If 'private' appears anywhere except far-left, access is denied.; // 3. Otherwise, overall access is determined by the most restrictive; // access in the sequence.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/CXXInheritance.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/CXXInheritance.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/CXXInheritance.cpp:26,Security,access,access,26,// Reset the scratch path access.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/CXXInheritance.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/CXXInheritance.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/CXXInheritance.cpp:230,Deployability,patch,patch,230,"// The declaration(s) we found along this path were found in a; // subobject of a virtual base. Check whether this virtual; // base is a subobject of any other path; if so, then the; // declaration in this path are hidden by that patch.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/CXXInheritance.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/CXXInheritance.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/CXXInheritance.cpp:3,Performance,Perform,Perform,3,// Perform lookup into our base classes.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/CXXInheritance.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/CXXInheritance.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/CXXInheritance.cpp:177,Performance,cache,cached,177,"// Collect all of the overridders from the base class subobject; // and merge them into the set of overridders for this class.; // For virtual base classes, populate or use the cached virtual; // overrides so that we do not walk the virtual base class (and; // its base classes) more than once.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/CXXInheritance.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/CXXInheritance.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/CXXInheritance.cpp:223,Availability,down,down,223,"// This virtual method overrides other virtual methods, so it does; // not add any new slots into the set of overriders. Instead, we; // replace entries in the set of overriders with the new; // overrider. To do so, we dig down to the original virtual; // functions using data recursion and update all of the methods it; // overrides.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/CXXInheritance.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/CXXInheritance.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/CXXInheritance.cpp:291,Deployability,update,update,291,"// This virtual method overrides other virtual methods, so it does; // not add any new slots into the set of overriders. Instead, we; // replace entries in the set of overriders with the new; // overrider. To do so, we dig down to the original virtual; // functions using data recursion and update all of the methods it; // overrides.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/CXXInheritance.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/CXXInheritance.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/CXXInheritance.cpp:209,Modifiability,inherit,inherits,209,"// C++ [class.virtual]p2:; // A virtual member function C::vf of a class object S is; // a final overrider unless the most derived class (1.8); // of which S is a base class subobject (if any) declares; // or inherits another member function that overrides vf.; //; // Treating this object like the most derived class, we; // replace any overrides from base classes with this; // overriding virtual function.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/CXXInheritance.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/CXXInheritance.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Decl.cpp:988,Modifiability,variab,variable,988,"----------------------------------===//; // NamedDecl Implementation; //===----------------------------------------------------------------------===//; // Visibility rules aren't rigorously externally specified, but here; // are the basic principles behind what we implement:; //; // 1. An explicit visibility attribute is generally a direct expression; // of the user's intent and should be honored. Only the innermost; // visibility attribute applies. If no visibility attribute applies,; // global visibility settings are considered.; //; // 2. There is one caveat to the above: on or in a template pattern,; // an explicit visibility attribute is just a default rule, and; // visibility can be decreased by the visibility of template; // arguments. But this, too, has an exception: an attribute on an; // explicit specialization or instantiation causes all the visibility; // restrictions of the template arguments to be ignored.; //; // 3. A variable that does not otherwise have explicit visibility can; // be restricted by the visibility of its type.; //; // 4. A visibility restriction is explicit if it comes from an; // attribute (or something like it), not a global visibility setting.; // When emitting a reference to an external symbol, visibility; // restrictions are ignored unless they are explicit.; //; // 5. When computing the visibility of a non-type, including a; // non-type member of a class, only non-type visibility restrictions; // are considered: the 'visibility' attribute, global value-visibility; // settings, and a few special cases like __private_extern.; //; // 6. When computing the visibility of a type, including a type member; // of a class, only type visibility restrictions are considered:; // the 'type_visibility' attribute and global type-visibility settings.; // However, a 'visibility' attribute counts as a 'type_visibility'; // attribute on any declaration that only has the former.; //; // The visibility of a ""secondary"" entity, like a template argument",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/Decl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Decl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Decl.cpp:188,Integrability,depend,dependent,188,"// Non-type template parameters can be restricted by the value type, e.g.; // template <enum X> class A { ... };; // We have to be careful here, though, because we can be dealing with; // dependent types.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/Decl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Decl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Decl.cpp:729,Testability,log,logic,729,"// Include visibility from the template parameters and arguments; // only if this is not an explicit instantiation or specialization; // with direct explicit visibility (and note that implicit; // instantiations won't have a direct attribute).; //; // Furthermore, we want to ignore template parameters and arguments; // for an explicit specialization when computing the visibility of a; // member thereof with explicit visibility.; //; // This is a bit complex; let's unpack it.; //; // An explicit class specialization is an independent, top-level; // declaration. As such, if it or any of its members has an; // explicit visibility attribute, that must directly express the; // user's intent, and we should honor it. The same logic applies to; // an explicit instantiation of a member of such a thing.; // Fast path: if this is not an explicit instantiation or; // specialization, we always want to consider template-related; // visibility restrictions.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/Decl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Decl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Decl.cpp:106,Modifiability,variab,variable,106,"/// Should we consider visibility associated with the template; /// arguments and parameters of the given variable template; /// specialization? As usual, follow class template specialization; /// logic up to initialization.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/Decl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Decl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Decl.cpp:197,Testability,log,logic,197,"/// Should we consider visibility associated with the template; /// arguments and parameters of the given variable template; /// specialization? As usual, follow class template specialization; /// logic up to initialization.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/Decl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Decl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Decl.cpp:15,Modifiability,variab,variable,15,"// An explicit variable specialization is an independent, top-level; // declaration. As such, if it has an explicit visibility attribute,; // that must directly express the user's intent, and we should honor; // it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/Decl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Decl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Decl.cpp:72,Modifiability,variab,variable,72,"/// Merge in template-related linkage and visibility for the given; /// variable template specialization. As usual, follow class template; /// specialization logic up to initialization.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/Decl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Decl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Decl.cpp:158,Testability,log,logic,158,"/// Merge in template-related linkage and visibility for the given; /// variable template specialization. As usual, follow class template; /// specialization logic up to initialization.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/Decl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Decl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Decl.cpp:7,Modifiability,variab,variable,7,"// - a variable, variable template, function, or function template; // that is explicitly declared static; or; // (This bullet corresponds to C99 6.2.2p3.)",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/Decl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Decl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Decl.cpp:17,Modifiability,variab,variable,17,"// - a variable, variable template, function, or function template; // that is explicitly declared static; or; // (This bullet corresponds to C99 6.2.2p3.)",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/Decl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Decl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Decl.cpp:165,Integrability,interface,interface,165,"// - a non-template variable of non-volatile const-qualified type, unless; // - it is explicitly declared extern, or; // - it is declared in the purview of a module interface unit; // (outside the private-module-fragment, if any) or module partition, or; // - it is inline, or; // - it was previously declared and the prior declaration did not have; // internal linkage; // (There is no equivalent in C99.)",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/Decl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Decl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Decl.cpp:20,Modifiability,variab,variable,20,"// - a non-template variable of non-volatile const-qualified type, unless; // - it is explicitly declared extern, or; // - it is declared in the purview of a module interface unit; // (outside the private-module-fragment, if any) or module partition, or; // - it is inline, or; // - it was previously declared and the prior declaration did not have; // internal linkage; // (There is no equivalent in C99.)",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/Decl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Decl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Decl.cpp:132,Safety,avoid,avoid,132,"// FIXME: The check for extern ""C"" here is not justified by the standard; // wording, but we retain it from the pre-DR1113 model to avoid breaking; // code.; //; // C++11 [basic.link]p4:; // An unnamed namespace or a namespace declared directly or indirectly; // within an unnamed namespace has internal linkage.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/Decl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Decl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Decl.cpp:573,Modifiability,variab,variable,573,"// C++ [basic.link]p4:; // A name having namespace scope that has not been given internal linkage; // above and that is the name of; // [...bullets...]; // has its linkage determined as follows:; // - if the enclosing namespace has internal linkage, the name has; // internal linkage; [handled above]; // - otherwise, if the declaration of the name is attached to a named; // module and is not exported, the name has module linkage;; // - otherwise, the name has external linkage.; // LV is currently set up to handle the last two bullets.; //; // The bullets are:; // - a variable; or",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/Decl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Decl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Decl.cpp:45,Modifiability,variab,variables,45,"// GCC applies the following optimization to variables and static; // data members, but not to functions:; //; // Modify the variable's LV by the LV of its type unless this is; // C or extern ""C"". This follows from [basic.link]p9:; // A type without linkage shall not be used as the type of a; // variable or function with external linkage unless; // - the entity has C language linkage, or; // - the entity is declared within an unnamed namespace, or; // - the entity is not used or is defined in the same; // translation unit.; // and [basic.link]p10:; // ...the types specified by all declarations referring to a; // given variable or function shall be identical...; // C does not have an equivalent rule.; //; // Ignore this if we've got an explicit attribute; the user; // probably knows what they're doing.; //; // Note that we don't want to make the variable non-external; // because of this, but unique-external linkage suits us.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/Decl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Decl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Decl.cpp:125,Modifiability,variab,variable,125,"// GCC applies the following optimization to variables and static; // data members, but not to functions:; //; // Modify the variable's LV by the LV of its type unless this is; // C or extern ""C"". This follows from [basic.link]p9:; // A type without linkage shall not be used as the type of a; // variable or function with external linkage unless; // - the entity has C language linkage, or; // - the entity is declared within an unnamed namespace, or; // - the entity is not used or is defined in the same; // translation unit.; // and [basic.link]p10:; // ...the types specified by all declarations referring to a; // given variable or function shall be identical...; // C does not have an equivalent rule.; //; // Ignore this if we've got an explicit attribute; the user; // probably knows what they're doing.; //; // Note that we don't want to make the variable non-external; // because of this, but unique-external linkage suits us.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/Decl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Decl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Decl.cpp:297,Modifiability,variab,variable,297,"// GCC applies the following optimization to variables and static; // data members, but not to functions:; //; // Modify the variable's LV by the LV of its type unless this is; // C or extern ""C"". This follows from [basic.link]p9:; // A type without linkage shall not be used as the type of a; // variable or function with external linkage unless; // - the entity has C language linkage, or; // - the entity is declared within an unnamed namespace, or; // - the entity is not used or is defined in the same; // translation unit.; // and [basic.link]p10:; // ...the types specified by all declarations referring to a; // given variable or function shall be identical...; // C does not have an equivalent rule.; //; // Ignore this if we've got an explicit attribute; the user; // probably knows what they're doing.; //; // Note that we don't want to make the variable non-external; // because of this, but unique-external linkage suits us.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/Decl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Decl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Decl.cpp:626,Modifiability,variab,variable,626,"// GCC applies the following optimization to variables and static; // data members, but not to functions:; //; // Modify the variable's LV by the LV of its type unless this is; // C or extern ""C"". This follows from [basic.link]p9:; // A type without linkage shall not be used as the type of a; // variable or function with external linkage unless; // - the entity has C language linkage, or; // - the entity is declared within an unnamed namespace, or; // - the entity is not used or is defined in the same; // translation unit.; // and [basic.link]p10:; // ...the types specified by all declarations referring to a; // given variable or function shall be identical...; // C does not have an equivalent rule.; //; // Ignore this if we've got an explicit attribute; the user; // probably knows what they're doing.; //; // Note that we don't want to make the variable non-external; // because of this, but unique-external linkage suits us.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/Decl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Decl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Decl.cpp:857,Modifiability,variab,variable,857,"// GCC applies the following optimization to variables and static; // data members, but not to functions:; //; // Modify the variable's LV by the LV of its type unless this is; // C or extern ""C"". This follows from [basic.link]p9:; // A type without linkage shall not be used as the type of a; // variable or function with external linkage unless; // - the entity has C language linkage, or; // - the entity is declared within an unnamed namespace, or; // - the entity is not used or is defined in the same; // translation unit.; // and [basic.link]p10:; // ...the types specified by all declarations referring to a; // given variable or function shall be identical...; // C does not have an equivalent rule.; //; // Ignore this if we've got an explicit attribute; the user; // probably knows what they're doing.; //; // Note that we don't want to make the variable non-external; // because of this, but unique-external linkage suits us.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/Decl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Decl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Decl.cpp:29,Performance,optimiz,optimization,29,"// GCC applies the following optimization to variables and static; // data members, but not to functions:; //; // Modify the variable's LV by the LV of its type unless this is; // C or extern ""C"". This follows from [basic.link]p9:; // A type without linkage shall not be used as the type of a; // variable or function with external linkage unless; // - the entity has C language linkage, or; // - the entity is declared within an unnamed namespace, or; // - the entity is not used or is defined in the same; // translation unit.; // and [basic.link]p10:; // ...the types specified by all declarations referring to a; // given variable or function shall be identical...; // C does not have an equivalent rule.; //; // Ignore this if we've got an explicit attribute; the user; // probably knows what they're doing.; //; // Note that we don't want to make the variable non-external; // because of this, but unique-external linkage suits us.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/Decl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Decl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Decl.cpp:121,Modifiability,variab,variables,121,"// In theory, we can modify the function's LV by the LV of its; // type unless it has C linkage (see comment above about variables; // for justification). In practice, GCC doesn't do this, so it's; // just too painful to make work.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/Decl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Decl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Decl.cpp:289,Usability,usab,usable,289,"// Note that Sema::MergeCompatibleFunctionDecls already takes care of; // merging storage classes and visibility attributes, so we don't have to; // look at previous decls in here.; // In C++, then if the type of the function uses a type with; // unique-external linkage, it's not legally usable from outside; // this translation unit. However, we should use the C linkage; // rules instead for extern ""C"" declarations.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/Decl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Decl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Decl.cpp:63,Integrability,interface,interfaces,63,"// By extension, we assign external linkage to Objective-C; // interfaces.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/Decl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Decl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Decl.cpp:33,Modifiability,variab,variable,33,// A GUID behaves like an inline variable with external linkage. Fall; // through.; // Everything not covered here has no linkage.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/Decl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Decl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Decl.cpp:5,Usability,GUID,GUID,5,// A GUID behaves like an inline variable with external linkage. Fall; // through.; // Everything not covered here has no linkage.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/Decl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Decl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Decl.cpp:14,Modifiability,variab,variable,14,"// Modify the variable's linkage by its type, but ignore the; // type's visibility unless it's a definition.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/Decl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Decl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Decl.cpp:3,Performance,optimiz,optimization,3,// optimization: hasDVA() is true only with explicit visibility.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/Decl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Decl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Decl.cpp:113,Modifiability,variab,variable,113,"// [C++2c] [basic.scope.scope]/p5; // A declaration is name-independent if its name is _ and it declares; // - a variable with automatic storage duration,; // - a structured binding not inhabiting a namespace scope,; // - the variable introduced by an init-capture; // - or a non-static data member.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/Decl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Decl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Decl.cpp:226,Modifiability,variab,variable,226,"// [C++2c] [basic.scope.scope]/p5; // A declaration is name-independent if its name is _ and it declares; // - a variable with automatic storage duration,; // - a structured binding not inhabiting a namespace scope,; // - the variable introduced by an init-capture; // - or a non-static data member.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/Decl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Decl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Decl.cpp:21,Modifiability,variab,variable,21,// and it declares a variable with automatic storage duration,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/Decl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Decl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Decl.cpp:93,Modifiability,variab,variable,93,"// C++ [dcl.link]/7:; // Two declarations [conflict] if [...] one declares a function or; // variable with C language linkage, and the other declares [...] a; // variable that belongs to the global scope.; //; // Therefore names that are reserved at global scope are also reserved as; // names of variables and functions with C language linkage.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/Decl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Decl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Decl.cpp:162,Modifiability,variab,variable,162,"// C++ [dcl.link]/7:; // Two declarations [conflict] if [...] one declares a function or; // variable with C language linkage, and the other declares [...] a; // variable that belongs to the global scope.; //; // Therefore names that are reserved at global scope are also reserved as; // names of variables and functions with C language linkage.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/Decl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Decl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Decl.cpp:297,Modifiability,variab,variables,297,"// C++ [dcl.link]/7:; // Two declarations [conflict] if [...] one declares a function or; // variable with C language linkage, and the other declares [...] a; // variable that belongs to the global scope.; //; // Therefore names that are reserved at global scope are also reserved as; // names of variables and functions with C language linkage.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/Decl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Decl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Decl.cpp:160,Modifiability,variab,variables,160,"// If a function is hidden by -fvisibility-inlines-hidden option and; // is not explicitly attributed as a hidden function,; // we should not make static local variables in the function hidden.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/Decl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Decl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Decl.cpp:76,Integrability,interface,interface,76,"// For ObjC methods and properties, look through categories and use the; // interface as context.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/Decl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Decl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Decl.cpp:57,Availability,error,error,57,"// For parameters, pick the newer one. This is either an error or (in; // Objective-C) permitted as an extension.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/Decl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Decl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Decl.cpp:39,Energy Efficiency,allocate,allocated,39,// Make sure the extended decl info is allocated.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/Decl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Decl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Decl.cpp:17,Modifiability,extend,extended,17,// Make sure the extended decl info is allocated.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/Decl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Decl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Decl.cpp:13,Modifiability,extend,extended,13,// Save (non-extended) type source info pointer.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/Decl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Decl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Decl.cpp:3,Energy Efficiency,Allocate,Allocate,3,// Allocate external info struct.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/Decl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Decl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Decl.cpp:28,Modifiability,extend,extended,28,// Restore savedTInfo into (extended) decl info.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/Decl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Decl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Decl.cpp:39,Energy Efficiency,allocate,allocated,39,// Make sure the extended decl info is allocated.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/Decl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Decl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Decl.cpp:17,Modifiability,extend,extended,17,// Make sure the extended decl info is allocated.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/Decl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Decl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Decl.cpp:13,Modifiability,extend,extended,13,// Save (non-extended) type source info pointer.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/Decl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Decl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Decl.cpp:3,Energy Efficiency,Allocate,Allocate,3,// Allocate external info struct.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/Decl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Decl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Decl.cpp:28,Modifiability,extend,extended,28,// Restore savedTInfo into (extended) decl info.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/Decl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Decl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Decl.cpp:39,Energy Efficiency,allocate,allocated,39,// Make sure the extended decl info is allocated.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/Decl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Decl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Decl.cpp:17,Modifiability,extend,extended,17,// Make sure the extended decl info is allocated.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/Decl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Decl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Decl.cpp:13,Modifiability,extend,extended,13,// Save (non-extended) type source info pointer.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/Decl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Decl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Decl.cpp:3,Energy Efficiency,Allocate,Allocate,3,// Allocate external info struct.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/Decl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Decl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Decl.cpp:28,Modifiability,extend,extended,28,// Restore savedTInfo into (extended) decl info.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/Decl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Decl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Decl.cpp:46,Modifiability,extend,extends,46,// If the declaration has no name or the type extends past the name take the; // end location of the type.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/Decl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Decl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Decl.cpp:87,Modifiability,variab,variable,87,"// C++ [dcl.link]p1: All function types, function names with external linkage,; // and variable names with external linkage have a language linkage.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/Decl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Decl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Decl.cpp:188,Availability,error,error,188,"// If the first decl is in an extern ""C"" context, any other redeclaration; // will have C language linkage. If the first one is not in an extern ""C""; // context, we would have reported an error for any other decl being in one.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/Decl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Decl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Decl.cpp:319,Modifiability,variab,variable,319,"// C++ [basic.def]p2:; // A declaration is a definition unless [...] it contains the 'extern'; // specifier or a linkage-specification and neither an initializer [...],; // it declares a non-inline static data member in a class declaration [...],; // it declares a static data member outside a class definition and the variable; // was defined within the class with the constexpr specifier [...],; // C++1y [temp.expl.spec]p15:; // An explicit specialization of a static data member or an explicit; // specialization of a static data member template is a definition if the; // declaration includes an initializer; otherwise, it is a declaration.; //; // FIXME: How do you declare (but not define) a partial specialization of; // a static data member template outside the containing class?",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/Decl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Decl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Decl.cpp:123,Modifiability,variab,variable,123,"// If the first declaration is out-of-line, this may be an; // instantiation of an out-of-line partial specialization of a variable; // template for which we have not yet instantiated the initializer.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/Decl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Decl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Decl.cpp:5,Modifiability,variab,variable,5,// A variable template specialization (other than a static data member; // template or an explicit specialization) is a declaration until we; // instantiate its initializer.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/Decl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Decl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Decl.cpp:33,Modifiability,variab,variables,33,"// OpenCL permits const integral variables to be used in constant; // expressions, like in C++98.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/Decl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Decl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Decl.cpp:33,Usability,usab,usable,33,// Function parameters are never usable in constant expressions.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/Decl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Decl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Decl.cpp:22,Modifiability,variab,variables,22,// The values of weak variables are never usable in constant expressions.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/Decl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Decl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Decl.cpp:42,Usability,usab,usable,42,// The values of weak variables are never usable in constant expressions.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/Decl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Decl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Decl.cpp:17,Modifiability,variab,variable,17,"// In C++11, any variable of reference type can be used in a constant; // expression if it is initialized by a constant expression.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/Decl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Decl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Decl.cpp:97,Modifiability,variab,variable,97,"// Only const objects can be used in constant expressions in C++. C++98 does; // not require the variable to be non-volatile, but we consider this to be a; // defect.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/Decl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Decl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Decl.cpp:31,Modifiability,variab,variables,31,"// In C++, const, non-volatile variables of integral or enumeration types; // can be used in constant expressions.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/Decl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Decl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Decl.cpp:50,Modifiability,variab,variables,50,"// Additionally, in C++11, non-volatile constexpr variables can be used in; // constant expressions.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/Decl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Decl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Decl.cpp:31,Modifiability,variab,variable,31,// C++2a [expr.const]p3:; // A variable is usable in constant expressions after its initializing; // declaration is encountered...,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/Decl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Decl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Decl.cpp:43,Usability,usab,usable,43,// C++2a [expr.const]p3:; // A variable is usable in constant expressions after its initializing; // declaration is encountered...,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/Decl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Decl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Decl.cpp:28,Modifiability,variab,variable,28,"// ... if it is a constexpr variable, or it is of reference type or of; // const-qualified integral or enumeration type, ...",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/Decl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Decl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Decl.cpp:90,Modifiability,variab,variables,90,// C++98 [expr.const]p1:; // An integral constant-expression can involve only [...] const variables; // or static data members of integral or enumeration types initialized with; // [integer] constant expressions (dcl.init),MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/Decl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Decl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Decl.cpp:82,Energy Efficiency,allocate,allocated,82,"// Note: EvaluatedStmt contains an APValue, which usually holds; // resources not allocated from the ASTContext. We need to do some; // work to avoid leaking those, but we do so in VarDecl::evaluateValue; // where we can detect whether there's anything to clean up or not.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/Decl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Decl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Decl.cpp:144,Safety,avoid,avoid,144,"// Note: EvaluatedStmt contains an APValue, which usually holds; // resources not allocated from the ASTContext. We need to do some; // work to avoid leaking those, but we do so in VarDecl::evaluateValue; // where we can detect whether there's anything to clean up or not.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/Decl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Decl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Decl.cpp:221,Safety,detect,detect,221,"// Note: EvaluatedStmt contains an APValue, which usually holds; // resources not allocated from the ASTContext. We need to do some; // work to avoid leaking those, but we do so in VarDecl::evaluateValue; // where we can detect whether there's anything to clean up or not.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/Decl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Decl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Decl.cpp:14,Integrability,depend,depends,14,"// In C++, it depends on whether the evaluation at the point of definition; // was evaluatable as a constant initializer.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/Decl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Decl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Decl.cpp:27,Modifiability,variab,variable,27,"// If it's an instantiated variable template specialization, find the; // template or partial specialization from which it was instantiated.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/Decl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Decl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Decl.cpp:31,Modifiability,variab,variable,31,"// If this is the pattern of a variable template, find where it was; // instantiated from. FIXME: Is this necessary?",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/Decl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Decl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Decl.cpp:49,Modifiability,variab,variables,49,"// In CUDA mode without relocatable device code, variables of form 'extern; // __shared__ Foo foo[]' are pointers to the base of the GPU core's shared; // memory pool. These are never undefined variables, even if they appear; // inside of an anon namespace or static function.; //; // With CUDA relocatable device code enabled, these variables don't get; // special handling; they're treated like regular extern variables.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/Decl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Decl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Decl.cpp:194,Modifiability,variab,variables,194,"// In CUDA mode without relocatable device code, variables of form 'extern; // __shared__ Foo foo[]' are pointers to the base of the GPU core's shared; // memory pool. These are never undefined variables, even if they appear; // inside of an anon namespace or static function.; //; // With CUDA relocatable device code enabled, these variables don't get; // special handling; they're treated like regular extern variables.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/Decl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Decl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Decl.cpp:334,Modifiability,variab,variables,334,"// In CUDA mode without relocatable device code, variables of form 'extern; // __shared__ Foo foo[]' are pointers to the base of the GPU core's shared; // memory pool. These are never undefined variables, even if they appear; // inside of an anon namespace or static function.; //; // With CUDA relocatable device code enabled, these variables don't get; // special handling; they're treated like regular extern variables.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/Decl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Decl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Decl.cpp:412,Modifiability,variab,variables,412,"// In CUDA mode without relocatable device code, variables of form 'extern; // __shared__ Foo foo[]' are pointers to the base of the GPU core's shared; // memory pool. These are never undefined variables, even if they appear; // inside of an anon namespace or static function.; //; // With CUDA relocatable device code enabled, these variables don't get; // special handling; they're treated like regular extern variables.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/Decl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Decl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Decl.cpp:461,Availability,error,error,461,"// If this is a friend function defined in a class template, it does not; // have a body until it is used, nevertheless it is a definition, see; // [temp.inst]p2:; //; // ... for the purpose of determining whether an instantiated redeclaration; // is valid according to [basic.def.odr] and [class.mem], a declaration that; // corresponds to a definition in the template is considered to be a; // definition.; //; // The following code must produce redefinition error:; //; // template<typename T> struct C20 { friend void func_20() {} };; // C20<int> c20i;; // void func_20() {}; //",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/Decl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Decl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Decl.cpp:146,Integrability,depend,depends,146,// C++20 [temp.friend]p9:; // A non-template friend declaration with a requires-clause [or]; // a friend function template with a constraint that depends on a template; // parameter from an enclosing template [...] does not declare the same; // function or function template as a declaration in any other scope.; // If this isn't a friend then it's not a member-like constrained friend.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/Decl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Decl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Decl.cpp:124,Usability,simpl,simple,124,"// If these friends don't have constraints, they aren't constrained, and; // thus don't fall under temp.friend p9. Else the simple presence of a; // constraint makes them unique.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/Decl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Decl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Decl.cpp:569,Integrability,wrap,wrapper,569,"/// Returns a value indicating whether this function corresponds to a builtin; /// function.; ///; /// The function corresponds to a built-in function if it is declared at; /// translation scope or within an extern ""C"" block and its name matches with; /// the name of a builtin. The returned value will be 0 for functions that do; /// not correspond to a builtin, a value of type \c Builtin::ID if in the; /// target-independent range \c [1,Builtin::First), or a target-specific builtin; /// value.; ///; /// \param ConsiderWrapperFunctions If true, we should consider wrapper; /// functions as their wrapped builtins. This shouldn't be done in general, but; /// it's useful in Sema to diagnose calls to wrappers based on their semantics.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/Decl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Decl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Decl.cpp:601,Integrability,wrap,wrapped,601,"/// Returns a value indicating whether this function corresponds to a builtin; /// function.; ///; /// The function corresponds to a built-in function if it is declared at; /// translation scope or within an extern ""C"" block and its name matches with; /// the name of a builtin. The returned value will be 0 for functions that do; /// not correspond to a builtin, a value of type \c Builtin::ID if in the; /// target-independent range \c [1,Builtin::First), or a target-specific builtin; /// value.; ///; /// \param ConsiderWrapperFunctions If true, we should consider wrapper; /// functions as their wrapped builtins. This shouldn't be done in general, but; /// it's useful in Sema to diagnose calls to wrappers based on their semantics.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/Decl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Decl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Decl.cpp:704,Integrability,wrap,wrappers,704,"/// Returns a value indicating whether this function corresponds to a builtin; /// function.; ///; /// The function corresponds to a built-in function if it is declared at; /// translation scope or within an extern ""C"" block and its name matches with; /// the name of a builtin. The returned value will be 0 for functions that do; /// not correspond to a builtin, a value of type \c Builtin::ID if in the; /// target-independent range \c [1,Builtin::First), or a target-specific builtin; /// value.; ///; /// \param ConsiderWrapperFunctions If true, we should consider wrapper; /// functions as their wrapped builtins. This shouldn't be done in general, but; /// it's useful in Sema to diagnose calls to wrappers based on their semantics.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/Decl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Decl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Decl.cpp:94,Availability,avail,available,94,// OpenCL v1.2 s6.9.f - The library functions defined in; // the C99 standard headers are not available.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/Decl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Decl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Decl.cpp:49,Testability,test,test,49,// Only consider file-scope declarations in this test.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/Decl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Decl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Decl.cpp:196,Availability,avail,available,196,"/// For an inline function definition in C, or for a gnu_inline function; /// in C++, determine whether the definition will be externally visible.; ///; /// Inline function definitions are always available for inlining optimizations.; /// However, depending on the language dialect, declaration specifiers, and; /// attributes, the definition of an inline function may or may not be; /// ""externally"" visible to other translation units in the program.; ///; /// In C99, inline definitions are not externally visible by default. However,; /// if even one of the global-scope declarations is marked ""extern inline"", the; /// inline definition becomes externally visible (C99 6.7.4p6).; ///; /// In GNU89 mode, or if the gnu_inline attribute is attached to the function; /// definition, we use the GNU semantics for inline, which are nearly the; /// opposite of C99 semantics. In particular, ""inline"" by itself will create; /// an externally visible symbol, but ""extern inline"" will not create an; /// externally visible symbol.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/Decl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Decl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Decl.cpp:248,Integrability,depend,depending,248,"/// For an inline function definition in C, or for a gnu_inline function; /// in C++, determine whether the definition will be externally visible.; ///; /// Inline function definitions are always available for inlining optimizations.; /// However, depending on the language dialect, declaration specifiers, and; /// attributes, the definition of an inline function may or may not be; /// ""externally"" visible to other translation units in the program.; ///; /// In C99, inline definitions are not externally visible by default. However,; /// if even one of the global-scope declarations is marked ""extern inline"", the; /// inline definition becomes externally visible (C99 6.7.4p6).; ///; /// In GNU89 mode, or if the gnu_inline attribute is attached to the function; /// definition, we use the GNU semantics for inline, which are nearly the; /// opposite of C99 semantics. In particular, ""inline"" by itself will create; /// an externally visible symbol, but ""extern inline"" will not create an; /// externally visible symbol.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/Decl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Decl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Decl.cpp:219,Performance,optimiz,optimizations,219,"/// For an inline function definition in C, or for a gnu_inline function; /// in C++, determine whether the definition will be externally visible.; ///; /// Inline function definitions are always available for inlining optimizations.; /// However, depending on the language dialect, declaration specifiers, and; /// attributes, the definition of an inline function may or may not be; /// ""externally"" visible to other translation units in the program.; ///; /// In C99, inline definitions are not externally visible by default. However,; /// if even one of the global-scope declarations is marked ""extern inline"", the; /// inline definition becomes externally visible (C99 6.7.4p6).; ///; /// In GNU89 mode, or if the gnu_inline attribute is attached to the function; /// definition, we use the GNU semantics for inline, which are nearly the; /// opposite of C99 semantics. In particular, ""inline"" by itself will create; /// an externally visible symbol, but ""extern inline"" will not create an; /// externally visible symbol.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/Decl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Decl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Decl.cpp:27,Testability,log,logic,27,"// Note: If you change the logic here, please change; // doesDeclarationForceExternallyVisibleDefinition as well.; //; // If it's not the case that both 'inline' and 'extern' are; // specified on the definition, then this inline definition is; // externally visible.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/Decl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Decl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Decl.cpp:32,Usability,clear,clear,32,"// FIXME: Remove this, it's not clear what it means. (Which template; // specialization kind?)",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/Decl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Decl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Decl.cpp:5,Integrability,depend,dependent,5,"// A dependent function template specialization is an explicit specialization,; // except when it's a friend declaration.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/Decl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Decl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Decl.cpp:399,Integrability,depend,dependent,399,"// This is the same as getTemplateSpecializationKind(), except that for a; // function that is both a function template specialization and a member; // specialization, we prefer the member specialization information. Eg:; //; // template<typename T> struct A {; // template<typename U> void f() {}; // template<> void f<int>() {}; // };; //; // Within the templated CXXRecordDecl, A<T>::f<int> is a dependent function; // template specialization; both getTemplateSpecializationKind() and; // getTemplateSpecializationKindForInstantiation() will return; // TSK_ExplicitSpecialization.; //; // For A<int>::f<int>():; // * getTemplateSpecializationKind() will return TSK_ExplicitSpecialization; // * getTemplateSpecializationKindForInstantiation() will return; // TSK_ImplicitInstantiation; //; // This reflects the facts that A<int>::f<int> is an explicit specialization; // of A<int>::f, and that A<int>::f<int> should be implicitly instantiated; // from A::f<int> if a definition is needed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/Decl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Decl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Decl.cpp:44,Energy Efficiency,allocate,allocated,44,// Make sure the extended qualifier info is allocated.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/Decl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Decl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Decl.cpp:17,Modifiability,extend,extended,17,// Make sure the extended qualifier info is allocated.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/Decl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Decl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Decl.cpp:39,Energy Efficiency,allocate,allocated,39,// Make sure the extended decl info is allocated.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/Decl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Decl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Decl.cpp:17,Modifiability,extend,extended,17,// Make sure the extended decl info is allocated.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/Decl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Decl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Decl.cpp:3,Energy Efficiency,Allocate,Allocate,3,// Allocate external info struct.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/Decl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Decl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Decl.cpp:85,Testability,test,test,85,// This is necessary for correctness for C++ with modules.; // FIXME: Come up with a test case that breaks without definition.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/Decl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Decl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Decl.cpp:18,Security,hash,hash,18,// Only calculate hash on first call of getODRHash per record.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/Decl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Decl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Decl.cpp:98,Security,hash,hash,98,"// For RecordDecl the ODRHash is stored in the remaining 26; // bit of RecordDeclBits, adjust the hash to accomodate.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/Decl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Decl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclarationName.cpp:38,Usability,guid,guide,38,"// We never want to compare deduction guide names for templates from; // different scopes, so just compare the template-name.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/DeclarationName.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclarationName.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclarationName.cpp:38,Integrability,depend,dependent,38,// A class-scope deduction guide in a dependent context has a dependent name.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/DeclarationName.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclarationName.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclarationName.cpp:62,Integrability,depend,dependent,62,// A class-scope deduction guide in a dependent context has a dependent name.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/DeclarationName.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclarationName.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclarationName.cpp:27,Usability,guid,guide,27,// A class-scope deduction guide in a dependent context has a dependent name.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/DeclarationName.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclarationName.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclBase.cpp:3,Energy Efficiency,Allocate,Allocate,3,"// Allocate an extra 8 bytes worth of storage, which ensures that the; // resulting pointer will still be 8-byte aligned.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/DeclBase.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclBase.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclBase.cpp:188,Energy Efficiency,allocate,allocate,188,"// With local visibility enabled, we track the owning module even for local; // declarations. We create the TU decl early and may not yet know what the; // LangOpts are, so conservatively allocate the storage.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/DeclBase.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclBase.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclBase.cpp:154,Safety,avoid,avoid,154,"// Defensive maneuver for ill-formed code: we're likely not to make it to; // a point where we set the access specifier, so default it to ""public""; // to avoid triggering asserts elsewhere in the front end.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/DeclBase.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclBase.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclBase.cpp:103,Security,access,access,103,"// Defensive maneuver for ill-formed code: we're likely not to make it to; // a point where we set the access specifier, so default it to ""public""; // to avoid triggering asserts elsewhere in the front end.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/DeclBase.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclBase.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclBase.cpp:171,Testability,assert,asserts,171,"// Defensive maneuver for ill-formed code: we're likely not to make it to; // a point where we set the access specifier, so default it to ""public""; // to avoid triggering asserts elsewhere in the front end.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/DeclBase.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclBase.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclBase.cpp:175,Integrability,depend,dependent,175,"// A declaration is templated if it is a template or a template pattern, or; // is within (lexcially for a friend or local function declaration,; // semantically otherwise) a dependent context.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/DeclBase.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclBase.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclBase.cpp:16,Integrability,depend,dependent,16,"// If this is a dependent lambda, there might be an enclosing variable; // template. In this case, the next step is not the parent DeclContext (or; // even a DeclContext at all).",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/DeclBase.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclBase.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclBase.cpp:62,Modifiability,variab,variable,62,"// If this is a dependent lambda, there might be an enclosing variable; // template. In this case, the next step is not the parent DeclContext (or; // even a DeclContext at all).",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/DeclBase.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclBase.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclBase.cpp:81,Modifiability,flexible,flexible,81,"// For compatibility with existing code, we treat arrays of length 0 or; // 1 as flexible array members.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/DeclBase.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclBase.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclBase.cpp:3,Testability,Test,Test,3,// Test that the field is the last in the structure.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/DeclBase.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclBase.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclBase.cpp:94,Integrability,depend,depending,94,/// Helper to get the language options from the ASTContext.; /// Defined out of line to avoid depending on ASTContext.h.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/DeclBase.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclBase.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclBase.cpp:88,Safety,avoid,avoid,88,/// Helper to get the language options from the ASTContext.; /// Defined out of line to avoid depending on ASTContext.h.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/DeclBase.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclBase.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclBase.cpp:18,Availability,avail,availability,18,"/// Determine the availability of the given declaration based on; /// the target platform.; ///; /// When it returns an availability result other than \c AR_Available,; /// if the \p Message parameter is non-NULL, it will be set to a; /// string describing why the entity is unavailable.; ///; /// FIXME: Make these strings localizable, since they end up in; /// diagnostics.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/DeclBase.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclBase.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclBase.cpp:120,Availability,avail,availability,120,"/// Determine the availability of the given declaration based on; /// the target platform.; ///; /// When it returns an availability result other than \c AR_Available,; /// if the \p Message parameter is non-NULL, it will be set to a; /// string describing why the entity is unavailable.; ///; /// FIXME: Make these strings localizable, since they end up in; /// diagnostics.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/DeclBase.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclBase.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclBase.cpp:183,Integrability,Message,Message,183,"/// Determine the availability of the given declaration based on; /// the target platform.; ///; /// When it returns an availability result other than \c AR_Available,; /// if the \p Message parameter is non-NULL, it will be set to a; /// string describing why the entity is unavailable.; ///; /// FIXME: Make these strings localizable, since they end up in; /// diagnostics.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/DeclBase.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclBase.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclBase.cpp:3,Modifiability,Variab,Variables,3,"// Variables, if they aren't definitions.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/DeclBase.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclBase.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclBase.cpp:13,Modifiability,inherit,inheritance,13,"// Attribute inheritance is processed after attribute parsing. To keep the; // order as in the source code, add inherited attributes before non-inherited; // ones.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/DeclBase.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclBase.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclBase.cpp:112,Modifiability,inherit,inherited,112,"// Attribute inheritance is processed after attribute parsing. To keep the; // order as in the source code, add inherited attributes before non-inherited; // ones.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/DeclBase.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclBase.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclBase.cpp:144,Modifiability,inherit,inherited,144,"// Attribute inheritance is processed after attribute parsing. To keep the; // order as in the source code, add inherited attributes before non-inherited; // ones.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/DeclBase.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclBase.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclBase.cpp:39,Safety,avoid,avoid,39,// Special handling of FunctionDecl to avoid de-serializing the body from PCH.; // FunctionDecl stores EndRangeLoc for this purpose.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/DeclBase.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclBase.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclBase.cpp:404,Modifiability,extend,extended,404,// Suppress this check if any of the following hold:; // 1. this is the translation unit (and thus has no parent); // 2. this is a template parameter (and thus doesn't belong to its context); // 3. this is a non-type template parameter; // 4. the context is not a record; // 5. it's invalid; // 6. it's a C++0x static_assert.; // 7. it's a block literal declaration; // 8. it's a temporary with lifetime extended due to being default value.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/DeclBase.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclBase.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclBase.cpp:81,Security,access,access,81,// FIXME: a ClassTemplateSpecialization or CXXRecordDecl can have; // AS_none as access specifier.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/DeclBase.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclBase.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclBase.cpp:36,Integrability,depend,dependent,36,// Friend function declarations are dependent if their *lexical*; // context is dependent.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/DeclBase.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclBase.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclBase.cpp:80,Integrability,depend,dependent,80,// Friend function declarations are dependent if their *lexical*; // context is dependent.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/DeclBase.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclBase.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclBase.cpp:35,Integrability,depend,dependent,35,"// FIXME: A variable template is a dependent context, but is not a; // DeclContext. A context within it (such as a lambda-expression); // should be considered dependent.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/DeclBase.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclBase.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclBase.cpp:159,Integrability,depend,dependent,159,"// FIXME: A variable template is a dependent context, but is not a; // DeclContext. A context within it (such as a lambda-expression); // should be considered dependent.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/DeclBase.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclBase.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclBase.cpp:12,Modifiability,variab,variable,12,"// FIXME: A variable template is a dependent context, but is not a; // DeclContext. A context within it (such as a lambda-expression); // should be considered dependent.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/DeclBase.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclBase.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclBase.cpp:245,Security,expose,exposed,245,"// Each buffer, even with the same name, is a distinct construct.; // Multiple buffers with the same name are allowed for backward; // compatibility.; // As long as buffers have unique resource bindings the names don't matter.; // The names get exposed via the CPU-side reflection API which; // supports querying bindings, so we cannot remove them.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/DeclBase.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclBase.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclBase.cpp:4,Performance,Load,Load,4,/// Load the declarations within this lexical storage from an; /// external source.; /// \return \c true if any declarations were added.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/DeclBase.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclBase.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclBase.cpp:3,Performance,Load,Load,3,"// Load the external declarations, if any.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/DeclBase.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclBase.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclBase.cpp:23,Performance,load,loaded,23,"// We may have already loaded just the fields of this record, in which case; // we need to ignore them.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/DeclBase.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclBase.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclBase.cpp:76,Deployability,update,update,76,"// Notify a C++ record declaration that we've added a member, so it can; // update its class-specific state.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/DeclBase.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclBase.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclBase.cpp:101,Performance,load,loaded,101,"// If we have an external source, ensure that any later redeclarations of this; // context have been loaded, since they may add names to the result of this; // lookup (or add external visible storage).",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/DeclBase.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclBase.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclBase.cpp:40,Performance,perform,perform,40,"// If there's no external storage, just perform a normal lookup and copy; // the results.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/DeclBase.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclBase.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclBase.cpp:47,Performance,perform,perform,47,"// If we already have a lookup data structure, perform the insertion into; // it. If we might have externally-stored decls with this name, look them; // up and perform the insertion. If this decl was declared outside its; // semantic context, buildLookup won't add it, so add it now.; //; // FIXME: As a performance hack, don't add such decls into the translation; // unit unless we're in C++, since qualified lookup into the TU is never; // performed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/DeclBase.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclBase.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclBase.cpp:160,Performance,perform,perform,160,"// If we already have a lookup data structure, perform the insertion into; // it. If we might have externally-stored decls with this name, look them; // up and perform the insertion. If this decl was declared outside its; // semantic context, buildLookup won't add it, so add it now.; //; // FIXME: As a performance hack, don't add such decls into the translation; // unit unless we're in C++, since qualified lookup into the TU is never; // performed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/DeclBase.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclBase.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclBase.cpp:304,Performance,perform,performance,304,"// If we already have a lookup data structure, perform the insertion into; // it. If we might have externally-stored decls with this name, look them; // up and perform the insertion. If this decl was declared outside its; // semantic context, buildLookup won't add it, so add it now.; //; // FIXME: As a performance hack, don't add such decls into the translation; // unit unless we're in C++, since qualified lookup into the TU is never; // performed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/DeclBase.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclBase.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclBase.cpp:442,Performance,perform,performed,442,"// If we already have a lookup data structure, perform the insertion into; // it. If we might have externally-stored decls with this name, look them; // up and perform the insertion. If this decl was declared outside its; // semantic context, buildLookup won't add it, so add it now.; //; // FIXME: As a performance hack, don't add such decls into the translation; // unit unless we're in C++, since qualified lookup into the TU is never; // performed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/DeclBase.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclBase.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclBase.cpp:39,Performance,load,load,39,"// If there is an external AST source, load any declarations it knows about; // with this declaration's name.; // If the lookup table contains an entry about this name it means that we; // have already checked the external source.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/DeclBase.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclBase.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclBase.cpp:37,Performance,load,loading,37,"// If this is being added as part of loading an external declaration,; // this may not be the only external declaration with this name.; // In this case, we never try to replace an existing declaration; we'll; // handle that when we finalize the list of declarations for this name.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/DeclBase.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclBase.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclBase.cpp:29,Energy Efficiency,efficient,efficient,29,"// FIXME: Use something more efficient than normal lookup for using; // directives. In C++, using directives are looked up more than anything else.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/DeclBase.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclBase.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclBase.cpp:23,Integrability,Depend,DependentStoredDeclsMaps,23,// It's okay to delete DependentStoredDeclsMaps via a StoredDeclsMap; // pointer because the subclass doesn't add anything that needs to; // be deleted.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/DeclBase.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclBase.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclBase.cpp:3,Energy Efficiency,Allocate,Allocate,3,"// Allocate the copy of the PartialDiagnostic via the ASTContext's; // BumpPtrAllocator, rather than the ASTContext itself.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/DeclBase.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclBase.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclCXX.cpp:17,Modifiability,inherit,inherited,17,// Keep track of inherited vbases for this base class.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/DeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclCXX.cpp:8,Integrability,depend,dependent,8,// Skip dependent types; we can't do any checking on them now.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/DeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclCXX.cpp:55,Modifiability,inherit,inherits,55,// C++ [class.virtual]p1:; // A class that declares or inherits a virtual function is called a; // polymorphic class.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/DeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclCXX.cpp:99,Modifiability,polymorphi,polymorphic,99,// C++ [class.virtual]p1:; // A class that declares or inherits a virtual function is called a; // polymorphic class.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/DeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclCXX.cpp:94,Performance,perform,perform,94,"// If the base class doesn't have a simple move constructor, we'll eagerly; // declare it and perform overload resolution to determine which function; // it actually calls. If it does have a simple move constructor, this; // check is correct.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/DeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclCXX.cpp:36,Usability,simpl,simple,36,"// If the base class doesn't have a simple move constructor, we'll eagerly; // declare it and perform overload resolution to determine which function; // it actually calls. If it does have a simple move constructor, this; // check is correct.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/DeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclCXX.cpp:191,Usability,simpl,simple,191,"// If the base class doesn't have a simple move constructor, we'll eagerly; // declare it and perform overload resolution to determine which function; // it actually calls. If it does have a simple move constructor, this; // check is correct.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/DeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclCXX.cpp:93,Performance,perform,perform,93,"// If the base class doesn't have a simple move assignment, we'll eagerly; // declare it and perform overload resolution to determine which function; // it actually calls. If it does have a simple move assignment, this; // check is correct.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/DeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclCXX.cpp:36,Usability,simpl,simple,36,"// If the base class doesn't have a simple move assignment, we'll eagerly; // declare it and perform overload resolution to determine which function; // it actually calls. If it does have a simple move assignment, this; // check is correct.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/DeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclCXX.cpp:190,Usability,simpl,simple,190,"// If the base class doesn't have a simple move assignment, we'll eagerly; // declare it and perform overload resolution to determine which function; // it actually calls. If it does have a simple move assignment, this; // check is correct.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/DeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclCXX.cpp:25,Security,hash,hash,25,// Previously calculated hash is stored in DefinitionData.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/DeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclCXX.cpp:18,Security,hash,hash,18,// Only calculate hash on first call of getODRHash per record.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/DeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclCXX.cpp:55,Modifiability,inherit,inherits,55,// C++ [class.virtual]p1:; // A class that declares or inherits a virtual function is called a; // polymorphic class.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/DeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclCXX.cpp:99,Modifiability,polymorphi,polymorphic,99,// C++ [class.virtual]p1:; // A class that declares or inherits a virtual function is called a; // polymorphic class.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/DeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclCXX.cpp:116,Usability,clear,clear,116,"// C++ [class]p4:; // A POD-struct is an aggregate class [...]; // Since the POD bit is meant to be C++03 POD-ness, clear it even if; // the type is technically an aggregate in C++0x since it wouldn't be; // in 03.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/DeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclCXX.cpp:40,Modifiability,inherit,inherited,40,"// Handle constructors, including those inherited from base classes.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/DeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclCXX.cpp:212,Modifiability,inherit,inherited,212,// Record if we see any constexpr constructors which are neither copy; // nor move constructors.; // C++1z [basic.types]p10:; // [...] has at least one constexpr constructor or constructor template; // (possibly inherited from a base class) that is not a copy or move; // constructor [...],MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/DeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclCXX.cpp:22,Safety,unsafe,unsafe,22,"// FIXME: We use the 'unsafe' accessor for the access specifier here,; // because Sema may not have set it yet. That's really just a misdesign; // in Sema. However, LLDB *will* have set the access specifier correctly,; // and adds declarations after the class is technically completed,; // so completeDefinition()'s overriding of the access specifiers doesn't; // work.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/DeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclCXX.cpp:30,Security,access,accessor,30,"// FIXME: We use the 'unsafe' accessor for the access specifier here,; // because Sema may not have set it yet. That's really just a misdesign; // in Sema. However, LLDB *will* have set the access specifier correctly,; // and adds declarations after the class is technically completed,; // so completeDefinition()'s overriding of the access specifiers doesn't; // work.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/DeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclCXX.cpp:47,Security,access,access,47,"// FIXME: We use the 'unsafe' accessor for the access specifier here,; // because Sema may not have set it yet. That's really just a misdesign; // in Sema. However, LLDB *will* have set the access specifier correctly,; // and adds declarations after the class is technically completed,; // so completeDefinition()'s overriding of the access specifiers doesn't; // work.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/DeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclCXX.cpp:190,Security,access,access,190,"// FIXME: We use the 'unsafe' accessor for the access specifier here,; // because Sema may not have set it yet. That's really just a misdesign; // in Sema. However, LLDB *will* have set the access specifier correctly,; // and adds declarations after the class is technically completed,; // so completeDefinition()'s overriding of the access specifiers doesn't; // work.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/DeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclCXX.cpp:334,Security,access,access,334,"// FIXME: We use the 'unsafe' accessor for the access specifier here,; // because Sema may not have set it yet. That's really just a misdesign; // in Sema. However, LLDB *will* have set the access specifier correctly,; // and adds declarations after the class is technically completed,; // so completeDefinition()'s overriding of the access specifiers doesn't; // work.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/DeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclCXX.cpp:270,Usability,clear,clear,270,"// C++03 [class]p4:; // A POD-struct is an aggregate class that has [...] no user-defined; // copy assignment operator and no user-defined destructor.; //; // Since the POD bit is meant to be C++03 POD-ness, and in C++03,; // aggregates could not have any constructors, clear it even for an; // explicitly defaulted or deleted constructor.; // type is technically an aggregate in C++0x since it wouldn't be in; // 03.; //; // Also, a user-declared move assignment operator makes a class; // non-POD. This is an extension in C++03.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/DeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclCXX.cpp:95,Security,access,access,95,"// C++0x [class]p7:; // A standard-layout class is a class that:; // [...]; // -- has the same access control for all non-static data members,",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/DeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclCXX.cpp:18,Performance,perform,perform,18,// We may need to perform overload resolution to determine whether a; // field can be moved if it's const or volatile qualified.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/DeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclCXX.cpp:63,Performance,perform,perform,63,"// For an anonymous union member, our overload resolution will perform; // overload resolution for its members.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/DeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclCXX.cpp:31,Usability,simpl,simple,31,"// If the field doesn't have a simple move constructor, we'll eagerly; // declare the move constructor for this class and we'll decide whether; // it's trivial then.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/DeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclCXX.cpp:31,Usability,simpl,simple,31,"// If the field doesn't have a simple move assignment, we'll eagerly; // declare the move assignment for this class and we'll decide whether; // it's trivial then.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/DeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclCXX.cpp:76,Modifiability,inherit,inherited,76,// C++1z [dcl.init.aggr]p1:; // An aggregate is [...] a class [...] with no inherited constructors,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/DeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclCXX.cpp:115,Usability,clear,clear,115,"// If the destructor is explicitly defaulted and not trivial or not public; // or if the destructor is deleted, we clear HasIrrelevantDestructor in; // finishedDefaultedOrDeletedMember.; // C++11 [class.dtor]p5:; // A destructor is trivial if [...] the destructor is not virtual.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/DeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclCXX.cpp:3,Deployability,Update,Update,3,// Update which trivial / non-trivial special members we have.; // addedMember will have skipped this step for this member.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/DeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclCXX.cpp:260,Modifiability,inherit,inheritance,260,/// Collect the visible conversions of a base class.; ///; /// \param Record a base class of the class we're considering; /// \param InVirtual whether this base class is a virtual base (or a base; /// of a virtual base); /// \param Access the access along the inheritance path to this base; /// \param ParentHiddenTypes the conversions provided by the inheritors; /// of this base; /// \param Output the set to which to add conversions from non-virtual bases; /// \param VOutput the set to which to add conversions from virtual bases; /// \param HiddenVBaseCs the set of conversions which were hidden in a; /// virtual base along some inheritance path,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/DeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclCXX.cpp:352,Modifiability,inherit,inheritors,352,/// Collect the visible conversions of a base class.; ///; /// \param Record a base class of the class we're considering; /// \param InVirtual whether this base class is a virtual base (or a base; /// of a virtual base); /// \param Access the access along the inheritance path to this base; /// \param ParentHiddenTypes the conversions provided by the inheritors; /// of this base; /// \param Output the set to which to add conversions from non-virtual bases; /// \param VOutput the set to which to add conversions from virtual bases; /// \param HiddenVBaseCs the set of conversions which were hidden in a; /// virtual base along some inheritance path,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/DeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclCXX.cpp:635,Modifiability,inherit,inheritance,635,/// Collect the visible conversions of a base class.; ///; /// \param Record a base class of the class we're considering; /// \param InVirtual whether this base class is a virtual base (or a base; /// of a virtual base); /// \param Access the access along the inheritance path to this base; /// \param ParentHiddenTypes the conversions provided by the inheritors; /// of this base; /// \param Output the set to which to add conversions from non-virtual bases; /// \param VOutput the set to which to add conversions from virtual bases; /// \param HiddenVBaseCs the set of conversions which were hidden in a; /// virtual base along some inheritance path,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/DeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclCXX.cpp:232,Security,Access,Access,232,/// Collect the visible conversions of a base class.; ///; /// \param Record a base class of the class we're considering; /// \param InVirtual whether this base class is a virtual base (or a base; /// of a virtual base); /// \param Access the access along the inheritance path to this base; /// \param ParentHiddenTypes the conversions provided by the inheritors; /// of this base; /// \param Output the set to which to add conversions from non-virtual bases; /// \param VOutput the set to which to add conversions from virtual bases; /// \param HiddenVBaseCs the set of conversions which were hidden in a; /// virtual base along some inheritance path,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/DeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclCXX.cpp:243,Security,access,access,243,/// Collect the visible conversions of a base class.; ///; /// \param Record a base class of the class we're considering; /// \param InVirtual whether this base class is a virtual base (or a base; /// of a virtual base); /// \param Access the access along the inheritance path to this base; /// \param ParentHiddenTypes the conversions provided by the inheritors; /// of this base; /// \param Output the set to which to add conversions from non-virtual bases; /// \param VOutput the set to which to add conversions from virtual bases; /// \param HiddenVBaseCs the set of conversions which were hidden in a; /// virtual base along some inheritance path,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/DeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclCXX.cpp:86,Performance,optimiz,optimization,86,"// The set of types which have conversions in this class or its; // subclasses. As an optimization, we don't copy the derived set; // unless it might change.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/DeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclCXX.cpp:102,Modifiability,inherit,inheritance,102,"// If this conversion is hidden and we're in a virtual base,; // remember that it's hidden along some inheritance path.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/DeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclCXX.cpp:107,Integrability,depend,dependent,107,"// If a destructor was marked as not selected, we skip it. We don't always; // have a selected destructor: dependent types, unnamed structs.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/DeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclCXX.cpp:37,Integrability,interface,interface-like,37,// All __interfaces are inheritently interface-like.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/DeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclCXX.cpp:24,Modifiability,inherit,inheritently,24,// All __interfaces are inheritently interface-like.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/DeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclCXX.cpp:3,Integrability,Interface,Interface-like,3,"// Interface-like types cannot have a user declared constructor, destructor,; // friends, VBases, conversion functions, or fields. Additionally, lambdas; // cannot be interface types.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/DeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclCXX.cpp:167,Integrability,interface,interface,167,"// Interface-like types cannot have a user declared constructor, destructor,; // friends, VBases, conversion functions, or fields. Additionally, lambdas; // cannot be interface types.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/DeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclCXX.cpp:6,Integrability,interface,interface-like,6,// No interface-like type can have a method with a definition.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/DeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclCXX.cpp:67,Integrability,interface,interface,67,"// FIXME: Any access specifiers is supposed to make this no longer interface; // like.; // If this isn't a 'special' type, it must have a single interface-like base.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/DeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclCXX.cpp:145,Integrability,interface,interface-like,145,"// FIXME: Any access specifiers is supposed to make this no longer interface; // like.; // If this isn't a 'special' type, it must have a single interface-like base.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/DeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclCXX.cpp:14,Security,access,access,14,"// FIXME: Any access specifiers is supposed to make this no longer interface; // like.; // If this isn't a 'special' type, it must have a single interface-like base.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/DeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclCXX.cpp:69,Modifiability,inherit,inherits,69,// C++ [class.abstract]p4:; // A class is abstract if it contains or inherits at least one; // pure virtual function for which the final overrider is pure; // virtual.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/DeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclCXX.cpp:7,Security,access,access,7,// Set access bits correctly on the directly-declared conversions.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/DeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclCXX.cpp:116,Deployability,patch,patching,116,"// When building with -fapple-kext, all calls must go through the vtable since; // the kernel linker can do runtime patching of vtables.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/DeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclCXX.cpp:42,Security,access,accessed,42,"// We can devirtualize calls on an object accessed by a class member access; // expression, since by C++11 [basic.life]p6 we know that it can't refer to; // a derived class object constructed in the same location.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/DeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclCXX.cpp:69,Security,access,access,69,"// We can devirtualize calls on an object accessed by a class member access; // expression, since by C++11 [basic.life]p6 we know that it can't refer to; // a derived class object constructed in the same location.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/DeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclCXX.cpp:35,Security,access,accessed,35,// Likewise for calls on an object accessed by a (non-reference) pointer to; // member access.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/DeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclCXX.cpp:87,Security,access,access,87,// Likewise for calls on an object accessed by a (non-reference) pointer to; // member access.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/DeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclCXX.cpp:520,Usability,clear,clear,520,"// C++ <=14 [basic.stc.dynamic.deallocation]p2:; // [...] If class T does not declare such an operator delete but does; // declare a member deallocation function named operator delete with; // exactly two parameters, the second of which has type std::size_t (18.1),; // then this function is a usual deallocation function.; //; // C++17 says a usual deallocation function is one with the signature; // (void* [, size_t] [, std::align_val_t] [, ...]); // and all such functions are usual deallocation functions. It's not clear; // that allowing varargs functions was intentional.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/DeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclCXX.cpp:79,Usability,GUID,GUID,79,"// FIXME: We only need to check this once, not once each time we compute a; // GUID APValue.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/DeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclObjC.cpp:56,Integrability,interface,interface,56,// Get the local instance/class method declared in this interface.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/DeclObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclObjC.cpp:31,Integrability,protocol,protocol,31,"// If this context is a hidden protocol definition, don't find any; // methods there.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/DeclObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclObjC.cpp:121,Integrability,interface,interface,121,"// Since instance & class methods can have the same name, the loop below; // ensures we get the correct method.; //; // @interface Whatever; // - (int) class_method;; // + (float) class_method;; // @end",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/DeclObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclObjC.cpp:9,Integrability,rout,routine,9,"/// This routine returns 'true' if a user declared setter method was; /// found in the class, its protocols, its super classes or categories.; /// It also returns 'true' if one of its categories has declared a 'readwrite'; /// property. This is because, user must provide a setter method for the; /// category's 'readwrite' property.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/DeclObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclObjC.cpp:98,Integrability,protocol,protocols,98,"/// This routine returns 'true' if a user declared setter method was; /// found in the class, its protocols, its super classes or categories.; /// It also returns 'true' if one of its categories has declared a 'readwrite'; /// property. This is because, user must provide a setter method for the; /// category's 'readwrite' property.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/DeclObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclObjC.cpp:18,Integrability,protocol,protocols,18,"// Also look into protocols, for a user declared instance method.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/DeclObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclObjC.cpp:31,Integrability,protocol,protocol,31,"// If this context is a hidden protocol definition, don't find any; // property.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/DeclObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclObjC.cpp:39,Integrability,protocol,protocol,39,// Don't find properties within hidden protocol definitions.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/DeclObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclObjC.cpp:16,Integrability,protocol,protocols,16,// Look through protocols.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/DeclObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclObjC.cpp:16,Integrability,protocol,protocols,16,// Look through protocols.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/DeclObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclObjC.cpp:143,Integrability,protocol,protocols,143,/// FindPropertyVisibleInPrimaryClass - Finds declaration of the property; /// with name 'PropertyId' in the primary class; including those in protocols; /// (direct or indirect) used by the primary class.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/DeclObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclObjC.cpp:16,Integrability,protocol,protocols,16,// Look through protocols.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/DeclObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclObjC.cpp:94,Integrability,interface,interface,94,"// Note, the properties declared only in class extensions are still copied; // into the main @interface's property list, and therefore we don't; // explicitly, have to search class extension properties.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/DeclObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclObjC.cpp:23,Integrability,protocol,protocol,23,// Check for duplicate protocol in class's protocol list.; // This is O(n*m). But it is extremely rare and number of protocols in; // class or its extension are very few.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/DeclObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclObjC.cpp:43,Integrability,protocol,protocol,43,// Check for duplicate protocol in class's protocol list.; // This is O(n*m). But it is extremely rare and number of protocols in; // class or its extension are very few.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/DeclObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclObjC.cpp:117,Integrability,protocol,protocols,117,// Check for duplicate protocol in class's protocol list.; // This is O(n*m). But it is extremely rare and number of protocols in; // class or its extension are very few.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/DeclObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclObjC.cpp:27,Integrability,protocol,protocol,27,// Do we want to warn on a protocol in extension class which; // already exist in the class? Probably not.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/DeclObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclObjC.cpp:9,Integrability,Protocol,ProtocolRefs,9,// Merge ProtocolRefs into class's protocol list;,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/DeclObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclObjC.cpp:35,Integrability,protocol,protocol,35,// Merge ProtocolRefs into class's protocol list;,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/DeclObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclObjC.cpp:134,Safety,avoid,avoid,134,// If the class introduced initializers we conservatively assume that we; // don't know if any of them is a designated initializer to avoid possible; // misleading warnings.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/DeclObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclObjC.cpp:39,Availability,recover,recover,39,// Check for a complete definition and recover if not so.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/DeclObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclObjC.cpp:39,Safety,recover,recover,39,// Check for a complete definition and recover if not so.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/DeclObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclObjC.cpp:39,Availability,recover,recover,39,// Check for a complete definition and recover if not so.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/DeclObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclObjC.cpp:39,Safety,recover,recover,39,// Check for a complete definition and recover if not so.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/DeclObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclObjC.cpp:3,Deployability,Update,Update,3,// Update all of the declarations with a pointer to the definition.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/DeclObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclObjC.cpp:57,Integrability,protocol,protocols,57,// 3. Didn't find one yet - look through primary class's protocols.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/DeclObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclObjC.cpp:57,Integrability,protocol,protocols,57,// 4. Didn't find one yet - now look through categories' protocols,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/DeclObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclObjC.cpp:38,Integrability,protocol,protocols,38,// Didn't find one yet - look through protocols.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/DeclObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclObjC.cpp:25,Security,hash,hash,25,// Previously calculated hash is stored in DefinitionData.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/DeclObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclObjC.cpp:18,Security,hash,hash,18,// Only calculate hash on first call of getODRHash per record.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/DeclObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclObjC.cpp:33,Integrability,interface,interface,33,/// A definition will return its interface declaration.; /// An interface declaration will return its definition.; /// Otherwise it will return itself.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/DeclObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclObjC.cpp:64,Integrability,interface,interface,64,/// A definition will return its interface declaration.; /// An interface declaration will return its definition.; /// Otherwise it will return itself.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/DeclObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclObjC.cpp:138,Integrability,Interface,Interface,138,"// When the container is the ObjCImplementationDecl (the primary; // @implementation), then the canonical Decl is either in; // the class Interface, or in any of its extension.; //; // So when we don't find it in the ObjCInterfaceDecl,; // sift through extensions too.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/DeclObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclObjC.cpp:3,Performance,Cache,Cache,3,// Cache the result.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/DeclObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclObjC.cpp:44,Availability,error,error,44,// There may be no interface context due to error in declaration; // of the interface (which has been reported). Recover gracefully.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/DeclObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclObjC.cpp:113,Availability,Recover,Recover,113,// There may be no interface context due to error in declaration; // of the interface (which has been reported). Recover gracefully.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/DeclObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclObjC.cpp:19,Integrability,interface,interface,19,// There may be no interface context due to error in declaration; // of the interface (which has been reported). Recover gracefully.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/DeclObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclObjC.cpp:76,Integrability,interface,interface,76,// There may be no interface context due to error in declaration; // of the interface (which has been reported). Recover gracefully.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/DeclObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclObjC.cpp:113,Safety,Recover,Recover,113,// There may be no interface context due to error in declaration; // of the interface (which has been reported). Recover gracefully.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/DeclObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclObjC.cpp:50,Integrability,protocol,protocols,50,"// In categories look for overridden methods from protocols. A method from; // category is not ""overridden"" since it is considered as the ""same"" method; // (same USR) as the one from the interface.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/DeclObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclObjC.cpp:187,Integrability,interface,interface,187,"// In categories look for overridden methods from protocols. A method from; // category is not ""overridden"" since it is considered as the ""same"" method; // (same USR) as the one from the interface.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/DeclObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclObjC.cpp:80,Integrability,protocol,protocols,80,// We found an override at this category; there is no need to look; // into its protocols.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/DeclObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclObjC.cpp:79,Integrability,protocol,protocols,79,// We found an override at this level; there is no need to look; // into other protocols or categories.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/DeclObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclObjC.cpp:72,Integrability,interface,interface,72,// Start searching for overridden methods using the method from the; // interface as starting point.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/DeclObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclObjC.cpp:72,Integrability,interface,interface,72,// Start searching for overridden methods using the method from the; // interface as starting point.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/DeclObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclObjC.cpp:38,Integrability,interface,interface,38,"// For accessor stubs, go back to the interface.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/DeclObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclObjC.cpp:7,Security,access,accessor,7,"// For accessor stubs, go back to the interface.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/DeclObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclObjC.cpp:16,Testability,stub,stubs,16,"// For accessor stubs, go back to the interface.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/DeclObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclObjC.cpp:39,Availability,recover,recover,39,// Check for a complete definition and recover if not so.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/DeclObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclObjC.cpp:39,Safety,recover,recover,39,// Check for a complete definition and recover if not so.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/DeclObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclObjC.cpp:39,Availability,recover,recover,39,// Check for a complete definition and recover if not so.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/DeclObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclObjC.cpp:39,Safety,recover,recover,39,// Check for a complete definition and recover if not so.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/DeclObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclObjC.cpp:290,Deployability,update,updated,290,"// namespace; /// all_declared_ivar_begin - return first ivar declared in this class,; /// its extensions and its implementation. Lazily build the list on first; /// access.; ///; /// Caveat: The list returned by this method reflects the current; /// state of the parser. The cache will be updated for every ivar; /// added by an extension or the implementation when they are; /// encountered.; /// See also ObjCIvarDecl::Create().",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/DeclObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclObjC.cpp:276,Performance,cache,cache,276,"// namespace; /// all_declared_ivar_begin - return first ivar declared in this class,; /// its extensions and its implementation. Lazily build the list on first; /// access.; ///; /// Caveat: The list returned by this method reflects the current; /// state of the parser. The cache will be updated for every ivar; /// added by an extension or the implementation when they are; /// encountered.; /// See also ObjCIvarDecl::Create().",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/DeclObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclObjC.cpp:166,Security,access,access,166,"// namespace; /// all_declared_ivar_begin - return first ivar declared in this class,; /// its extensions and its implementation. Lazily build the list on first; /// access.; ///; /// Caveat: The list returned by this method reflects the current; /// state of the parser. The cache will be updated for every ivar; /// added by an extension or the implementation when they are; /// encountered.; /// See also ObjCIvarDecl::Create().",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/DeclObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclObjC.cpp:3,Performance,cache,cached,3,// cached and complete!,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/DeclObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclObjC.cpp:51,Integrability,protocol,protocol,51,"/// ClassImplementsProtocol - Checks that 'lProto' protocol; /// has been implemented in IDecl class, its super class or categories (if; /// lookupCategory is true).",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/DeclObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclObjC.cpp:320,Availability,error,error,320,"// This is dubious and is added to be compatible with gcc. In gcc, it is; // also allowed assigning a protocol-qualified 'id' type to a LHS object; // when protocol in qualified LHS is in list of protocols in the rhs 'id'; // object. This IMO, should be a bug.; // FIXME: Treat this as an extension, and flag this as an error when GCC; // extensions are not enabled.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/DeclObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclObjC.cpp:102,Integrability,protocol,protocol-qualified,102,"// This is dubious and is added to be compatible with gcc. In gcc, it is; // also allowed assigning a protocol-qualified 'id' type to a LHS object; // when protocol in qualified LHS is in list of protocols in the rhs 'id'; // object. This IMO, should be a bug.; // FIXME: Treat this as an extension, and flag this as an error when GCC; // extensions are not enabled.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/DeclObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclObjC.cpp:156,Integrability,protocol,protocol,156,"// This is dubious and is added to be compatible with gcc. In gcc, it is; // also allowed assigning a protocol-qualified 'id' type to a LHS object; // when protocol in qualified LHS is in list of protocols in the rhs 'id'; // object. This IMO, should be a bug.; // FIXME: Treat this as an extension, and flag this as an error when GCC; // extensions are not enabled.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/DeclObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclObjC.cpp:196,Integrability,protocol,protocols,196,"// This is dubious and is added to be compatible with gcc. In gcc, it is; // also allowed assigning a protocol-qualified 'id' type to a LHS object; // when protocol in qualified LHS is in list of protocols in the rhs 'id'; // object. This IMO, should be a bug.; // FIXME: Treat this as an extension, and flag this as an error when GCC; // extensions are not enabled.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/DeclObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclObjC.cpp:399,Availability,error,error,399,"// Ivar's can only appear in interfaces, implementations (via synthesized; // properties), and class extensions (via direct declaration, or synthesized; // properties).; //; // FIXME: This should really be asserting this:; // (isa<ObjCCategoryDecl>(DC) &&; // cast<ObjCCategoryDecl>(DC)->IsClassExtension())); // but unfortunately we sometimes place ivars into non-class extension; // categories on error. This breaks an AST invariant, and should not be; // fixed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/DeclObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclObjC.cpp:29,Integrability,interface,interfaces,29,"// Ivar's can only appear in interfaces, implementations (via synthesized; // properties), and class extensions (via direct declaration, or synthesized; // properties).; //; // FIXME: This should really be asserting this:; // (isa<ObjCCategoryDecl>(DC) &&; // cast<ObjCCategoryDecl>(DC)->IsClassExtension())); // but unfortunately we sometimes place ivars into non-class extension; // categories on error. This breaks an AST invariant, and should not be; // fixed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/DeclObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclObjC.cpp:206,Testability,assert,asserting,206,"// Ivar's can only appear in interfaces, implementations (via synthesized; // properties), and class extensions (via direct declaration, or synthesized; // properties).; //; // FIXME: This should really be asserting this:; // (isa<ObjCCategoryDecl>(DC) &&; // cast<ObjCCategoryDecl>(DC)->IsClassExtension())); // but unfortunately we sometimes place ivars into non-class extension; // categories on error. This breaks an AST invariant, and should not be; // fixed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/DeclObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclObjC.cpp:56,Integrability,protocol,protocol,56,// lookupMethod - Lookup a instance/class method in the protocol and protocols; // it inherited.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/DeclObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclObjC.cpp:69,Integrability,protocol,protocols,69,// lookupMethod - Lookup a instance/class method in the protocol and protocols; // it inherited.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/DeclObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclObjC.cpp:86,Modifiability,inherit,inherited,86,// lookupMethod - Lookup a instance/class method in the protocol and protocols; // it inherited.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/DeclObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclObjC.cpp:3,Deployability,Update,Update,3,// Update all of the declarations with a pointer to the definition.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/DeclObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclObjC.cpp:16,Integrability,protocol,protocol,16,// Scan through protocol's protocols.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/DeclObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclObjC.cpp:27,Integrability,protocol,protocols,27,// Scan through protocol's protocols.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/DeclObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclObjC.cpp:16,Integrability,protocol,protocol,16,// Scan through protocol's protocols which did not have a matching property.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/DeclObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclObjC.cpp:27,Integrability,protocol,protocols,27,// Scan through protocol's protocols which did not have a matching property.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/DeclObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclObjC.cpp:25,Security,hash,hash,25,// Previously calculated hash is stored in DefinitionData.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/DeclObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclObjC.cpp:18,Security,hash,hash,18,// Only calculate hash on first call of getODRHash per record.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/DeclObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclObjC.cpp:13,Integrability,interface,interface,13,// The class interface might be NULL if we are working with invalid code.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/DeclObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclPrinter.cpp:25,Availability,error,error,25,// This must be a syntax error.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/DeclPrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclPrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclPrinter.cpp:19,Modifiability,variab,variable,19,"// In case it is a variable declaration with a ctor, then allow; // printing on the left side for readbility.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/DeclPrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclPrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclPrinter.cpp:242,Safety,avoid,avoid,242,"// The next bits of code handle stuff like ""struct {int x;} a,b""; we're; // forced to merge the declarations because there's no other way to; // refer to the struct in question. When that struct is named instead, we; // also need to merge to avoid splitting off a stand-alone struct; // declaration that produces the warning ext_no_declarators in some; // contexts.; //; // This limited merging is safe without a bunch of other checks because it; // only merges declarations directly referring to the tag, not typedefs.; //; // Check whether the current declaration should be grouped with a previous; // non-free-standing tag declaration.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/DeclPrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclPrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclPrinter.cpp:398,Safety,safe,safe,398,"// The next bits of code handle stuff like ""struct {int x;} a,b""; we're; // forced to merge the declarations because there's no other way to; // refer to the struct in question. When that struct is named instead, we; // also need to merge to avoid splitting off a stand-alone struct; // declaration that produces the warning ext_no_declarators in some; // contexts.; //; // This limited merging is safe without a bunch of other checks because it; // only merges declarations directly referring to the tag, not typedefs.; //; // Check whether the current declaration should be grouped with a previous; // non-free-standing tag declaration.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/DeclPrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclPrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclPrinter.cpp:55,Security,access,access,55,"// Print the class definition; // FIXME: Doesn't print access specifiers, e.g., ""public:""",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/DeclPrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclPrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclPrinter.cpp:46,Usability,guid,guides,46,"// Never print ""instantiations"" for deduction guides (they don't really; // have them).",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/DeclPrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclPrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclPrinter.cpp:3,Integrability,Protocol,Protocols,3,// Protocols?,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/DeclPrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclPrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclPrinter.cpp:3,Integrability,Protocol,Protocols,3,// Protocols?,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/DeclPrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclPrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclPrinter.cpp:74,Modifiability,inherit,inheriting,74,// Use the correct record name when the using declaration is used for; // inheriting constructors.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/DeclPrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclPrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclTemplate.cpp:39,Energy Efficiency,allocate,allocate,39,"// If we never found a common pointer, allocate one now.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/DeclTemplate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclTemplate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclTemplate.cpp:82,Deployability,update,update,82,"// FIXME: If any of the declarations is from an AST file, we probably; // need an update record to add the common data.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/DeclTemplate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclTemplate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclTemplate.cpp:3,Deployability,Update,Update,3,// Update any previous declarations we saw with the common pointer.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/DeclTemplate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclTemplate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclTemplate.cpp:52,Performance,load,loaded,52,// Grab the most recent declaration to ensure we've loaded any lazy; // redeclarations of this template.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/DeclTemplate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclTemplate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclTemplate.cpp:21,Performance,load,loaded,21,// Skip over already loaded specializations.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/DeclTemplate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclTemplate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclTemplate.cpp:16,Performance,load,loaded,16,// Note that we loaded the specialization.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/DeclTemplate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclTemplate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclTemplate.cpp:49,Performance,load,load,49,"// Due to hash collisions, it can happen that we load another template; // specialization with the same hash. This is fine, as long as the next; // call to findSpecializationImpl does not find a matching Decl for the; // template arguments.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/DeclTemplate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclTemplate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclTemplate.cpp:10,Security,hash,hash,10,"// Due to hash collisions, it can happen that we load another template; // specialization with the same hash. This is fine, as long as the next; // call to findSpecializationImpl does not find a matching Decl for the; // template arguments.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/DeclTemplate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclTemplate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclTemplate.cpp:104,Security,hash,hash,104,"// Due to hash collisions, it can happen that we load another template; // specialization with the same hash. This is fine, as long as the next; // call to findSpecializationImpl does not find a matching Decl for the; // template arguments.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/DeclTemplate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclTemplate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclTemplate.cpp:20,Availability,avail,available,20,// No explicit info available.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/DeclTemplate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclTemplate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Expr.cpp:3,Testability,Log,Logical,3,// Logical OR operator.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/Expr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Expr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Expr.cpp:126,Modifiability,variab,variable,126,"// For blocks we only emit something if it is enclosed in a function; // For top-level block we'd like to include the name of variable, but we; // don't have it at this point.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/Expr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Expr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Expr.cpp:87,Safety,avoid,avoid,87,"// For incorrect code, there might not be an ObjCInterfaceDecl. Do; // a null check to avoid a crash.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/Expr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Expr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Expr.cpp:37,Modifiability,extend,extended,37,"// A character literal might be sign-extended, which; // would result in an invalid \U escape sequence.; // FIXME: multicharacter literals such as '\xFF\xFF\xFF\xFF'; // are not correctly handled.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/Expr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Expr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Expr.cpp:3,Safety,Avoid,Avoid,3,"// Avoid the expensive division. The compiler should be able to figure it; // out by itself. However as of clang 7, even with the appropriate; // llvm_unreachable added just here, it is not able to do so.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/Expr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Expr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Expr.cpp:64,Safety,safe,safe,64,// Initialize the trailing array of SourceLocation.; // This is safe since SourceLocation is POD-like.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/Expr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Expr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Expr.cpp:522,Deployability,update,updates,522,"/// getLocationOfByte - Return a source location that points to the specified; /// byte of this string literal.; ///; /// Strings are amazingly complex. They can be formed from multiple tokens and; /// can have escape sequences in them in addition to the usual trigraph and; /// escaped newline business. This routine handles this complexity.; ///; /// The *StartToken sets the first token to be searched in this function and; /// the *StartTokenByteOffset is the byte offset of the first token. Before; /// returning, it updates the *StartToken to the TokNo of the token being found; /// and sets *StartTokenByteOffset to the byte offset of the token in the; /// string.; /// Using these two parameters can reduce the time complexity from O(n^2) to; /// O(n) if one wants to get the location of byte for all the tokens in a; /// string.; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/Expr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Expr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Expr.cpp:708,Energy Efficiency,reduce,reduce,708,"/// getLocationOfByte - Return a source location that points to the specified; /// byte of this string literal.; ///; /// Strings are amazingly complex. They can be formed from multiple tokens and; /// can have escape sequences in them in addition to the usual trigraph and; /// escaped newline business. This routine handles this complexity.; ///; /// The *StartToken sets the first token to be searched in this function and; /// the *StartTokenByteOffset is the byte offset of the first token. Before; /// returning, it updates the *StartToken to the TokNo of the token being found; /// and sets *StartTokenByteOffset to the byte offset of the token in the; /// string.; /// Using these two parameters can reduce the time complexity from O(n^2) to; /// O(n) if one wants to get the location of byte for all the tokens in a; /// string.; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/Expr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Expr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Expr.cpp:310,Integrability,rout,routine,310,"/// getLocationOfByte - Return a source location that points to the specified; /// byte of this string literal.; ///; /// Strings are amazingly complex. They can be formed from multiple tokens and; /// can have escape sequences in them in addition to the usual trigraph and; /// escaped newline business. This routine handles this complexity.; ///; /// The *StartToken sets the first token to be searched in this function and; /// the *StartTokenByteOffset is the byte offset of the first token. Before; /// returning, it updates the *StartToken to the TokNo of the token being found; /// and sets *StartTokenByteOffset to the byte offset of the token in the; /// string.; /// Using these two parameters can reduce the time complexity from O(n^2) to; /// O(n) if one wants to get the location of byte for all the tokens in a; /// string.; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/Expr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Expr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Expr.cpp:69,Integrability,depend,dependent,69,"// If the Callee is a record type, then it is a not-yet-resolved; // dependent call to the call operator of that type.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/Expr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Expr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Expr.cpp:27,Integrability,depend,dependence,27,// FIXME: remove remaining dependence computation to computeDependence().,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/Expr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Expr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Expr.cpp:73,Safety,detect,detect,73,"// FIXME: We don't want this to happen. Rather, we should be able to; // detect all kinds of implicit accesses more cleanly.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/Expr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Expr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Expr.cpp:102,Security,access,accesses,102,"// FIXME: We don't want this to happen. Rather, we should be able to; // detect all kinds of implicit accesses more cleanly.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/Expr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Expr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Expr.cpp:28,Modifiability,inherit,inheritance,28,// These should not have an inheritance path.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/Expr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Expr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Expr.cpp:6,Integrability,depend,dependent,6,"// In dependent contexts, function names may change.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/Expr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Expr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Expr.cpp:104,Integrability,Rout,Routines,104,//===----------------------------------------------------------------------===//; // Generic Expression Routines; //===----------------------------------------------------------------------===//,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/Expr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Expr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Expr.cpp:18,Security,access,access,18,"// - class member access (5.2.5),",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/Expr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Expr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Expr.cpp:34,Integrability,depend,dependent,34,// Don't warn if the expr is type dependent. The type could end up; // instantiating to void.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/Expr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Expr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Expr.cpp:70,Integrability,depend,dependent,70,// This is just the 'operator co_await' call inside the guts of a; // dependent co_await call.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/Expr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Expr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Expr.cpp:3,Security,access,accessing,3,// accessing a piece of a volatile complex is a side-effect.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/Expr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Expr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Expr.cpp:358,Deployability,update,updated,358,"// Warn about operator ==,!=,<,>,<=, and >= even when user-defined operator; // overloads as there is no reasonable way to define these such that they; // have non-trivial, desirable side-effects. See the -Wunused-comparison; // warning: operators == and != are commonly typo'ed, and so warning on them; // provides additional value as well. If this list is updated,; // DiagnoseUnusedComparison should be as well.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/Expr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Expr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Expr.cpp:211,Deployability,update,updated,211,"// If the callee has attribute pure, const, or warn_unused_result, warn; // about it. void foo() { strlen(""bar""); } should warn.; //; // Note: If new cases are added here, DiagnoseUnusedExprResult should be; // updated to match for QoI.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/Expr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Expr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Expr.cpp:25,Testability,log,logically,25,"// Statement exprs don't logically have side effects themselves, but are; // sometimes used in macros in ways that give them a type that is unused.; // For example ({ blah; foo(); }) will end up with a type if foo has a type.; // however, if the result of the stmt expr is dead, we don't want to emit a; // warning.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/Expr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Expr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Expr.cpp:368,Performance,load,load,368,"// Ignore an explicit cast to void, except in C++98 if the operand is a; // volatile glvalue for which we would trigger an implicit read in any; // other language mode. (Such an implicit read always happens as part of; // the lvalue conversion in C, and happens in C++ for expressions of all; // forms where it seems likely the user intended to trigger a volatile; // load.)",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/Expr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Expr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Expr.cpp:104,Modifiability,variab,variable,104,"// Suppress the ""unused value"" warning for idiomatic usage of; // '(void)var;' used to suppress ""unused variable"" warnings.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/Expr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Expr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Expr.cpp:159,Performance,load,load,159,"// The lvalue-to-rvalue conversion would have no effect for an array.; // It's implausible that the programmer expected this to result in a; // volatile array load, so don't warn.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/Expr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Expr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Expr.cpp:44,Integrability,message,message,44,"// In this context, property reference is a message call and is pr-value.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/Expr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Expr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Expr.cpp:94,Integrability,depend,dependent,94,/// hasAnyTypeDependentArguments - Determines if any of the expressions; /// in Exprs is type-dependent.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/Expr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Expr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Expr.cpp:80,Availability,error,error,80,"// FIXME: We should be able to return ""true"" here, but it can lead to extra; // error messages. E.g. in Sema/array-init.c.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/Expr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Expr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Expr.cpp:86,Integrability,message,messages,86,"// FIXME: We should be able to return ""true"" here, but it can lead to extra; // error messages. E.g. in Sema/array-init.c.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/Expr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Expr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Expr.cpp:38,Integrability,depend,dependent,38,// Make a conservative assumption for dependent nodes.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/Expr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Expr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Expr.cpp:145,Safety,detect,detected,145,"/// isNullPointerConstant - C99 6.3.2.3p3 - Return whether this is a null; /// pointer constant or not, as well as the specific kind of constant detected.; /// Null pointer constants can be integer constant expressions with the; /// value zero, casts of zero to void*, nullptr (C++0X), or __null; /// (a GNU extension).",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/Expr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Expr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Expr.cpp:3,Availability,Error,Error-dependent,3,// Error-dependent expr should never be a null pointer.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/Expr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Expr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Expr.cpp:9,Integrability,depend,dependent,9,// Error-dependent expr should never be a null pointer.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/Expr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Expr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Expr.cpp:79,Testability,test,test,79,"// If we have an integer constant expression, we need to *evaluate* it and; // test for the value 0.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/Expr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Expr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Expr.cpp:19,Modifiability,variab,variable,19,// A static member variable can end the MemberExpr chain with either; // a MemberExpr or a DeclRefExpr.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/Expr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Expr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Expr.cpp:59,Security,access,access,59,/// containsDuplicateElements - Return true if any element access is repeated.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/Expr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Expr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Expr.cpp:10,Modifiability,Refactor,Refactor,10,"// FIXME: Refactor this code to an accessor on the AST node which returns the; // ""type"" of component access, and share with code below and in Sema.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/Expr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Expr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Expr.cpp:35,Security,access,accessor,35,"// FIXME: Refactor this code to an accessor on the AST node which returns the; // ""type"" of component access, and share with code below and in Sema.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/Expr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Expr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Expr.cpp:102,Security,access,access,102,"// FIXME: Refactor this code to an accessor on the AST node which returns the; // ""type"" of component access, and share with code below and in Sema.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/Expr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Expr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Expr.cpp:70,Integrability,depend,dependence,70,"// Copy the designators and their subexpressions, computing; // value-dependence along the way.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/Expr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Expr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprClassification.cpp:15,Testability,assert,assertion,15,// Enable this assertion for testing.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ExprClassification.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprClassification.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprClassification.cpp:29,Testability,test,testing,29,// Enable this assertion for testing.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ExprClassification.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprClassification.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprClassification.cpp:17,Modifiability,variab,variables,17,// ObjC instance variables are lvalues; // FIXME: ObjC++0x might have different rules,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ExprClassification.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprClassification.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprClassification.cpp:248,Security,access,access,248,"// C, C++98 [expr.sub]p1: The result is an lvalue of type ""T"".; // C++11 (DR1213): in the case of an array operand, the result is an lvalue; // if that operand is an lvalue and an xvalue otherwise.; // Subscripting vector types is more like member access.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ExprClassification.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprClassification.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprClassification.cpp:49,Security,access,accesses,49,// Subscripting matrix types behaves like member accesses.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ExprClassification.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprClassification.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprClassification.cpp:89,Modifiability,variab,variable,89,// C++ [expr.prim.general]p3: The result is an lvalue if the entity is a; // function or variable and a prvalue otherwise.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ExprClassification.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprClassification.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprClassification.cpp:10,Security,access,access,10,// Member access is complex.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ExprClassification.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprClassification.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprClassification.cpp:47,Performance,perform,performs,47,// C++ [expr.unary.op]p1: The unary * operator performs indirection:; // [...] the result is an lvalue referring to the object or function; // to which the expression points.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ExprClassification.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprClassification.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprClassification.cpp:19,Usability,simpl,simply,19,"// GNU extensions, simply look through them.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ExprClassification.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprClassification.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprClassification.cpp:44,Deployability,update,updated,44,"// C++ [expr.pre.incr]p1: The result is the updated operand; it is an; // lvalue, [...]; // Not so in C.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ExprClassification.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprClassification.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprClassification.cpp:3,Modifiability,Extend,Extended,3,// Extended vector element access is an lvalue unless there are duplicates; // in the shuffle expression.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ExprClassification.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprClassification.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprClassification.cpp:27,Security,access,access,27,// Extended vector element access is an lvalue unless there are duplicates; // in the shuffle expression.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ExprClassification.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprClassification.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprClassification.cpp:3,Usability,Simpl,Simply,3,// Simply look at the actual default argument.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ExprClassification.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprClassification.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprClassification.cpp:9,Integrability,depend,depend,9,// Casts depend completely on the target type. All casts work the same.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ExprClassification.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprClassification.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprClassification.cpp:8,Integrability,message,message,8,"// ObjC message sends are effectively function calls, if the target function; // is known.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ExprClassification.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprClassification.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprClassification.cpp:253,Performance,tune,tune,253,"// An init list can be an lvalue if it is bound to a reference and; // contains only one element. In that case, we look at that element; // for an exact classification. Init list creation takes care of the; // value kind for us, so we only need to fine-tune.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ExprClassification.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprClassification.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprClassification.cpp:87,Modifiability,variab,variable,87,"// C++ [expr.prim.general]p6: The result is an lvalue if the entity is a; // function, variable, or data member and a prvalue otherwise.; // In C, functions are not lvalues.; // In addition, NonTypeTemplateParmDecl derives from VarDecl but isn't an; // lvalue unless it's a reference type (C++ [temp.param]p6), so we need to; // special-case this.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ExprClassification.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprClassification.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprClassification.cpp:29,Security,access,access,29,"// C99 6.5.2.3p3; // For dot access, the expression is an lvalue if the first part is. For; // arrow access, it always is an lvalue.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ExprClassification.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprClassification.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprClassification.cpp:101,Security,access,access,101,"// C99 6.5.2.3p3; // For dot access, the expression is an lvalue if the first part is. For; // arrow access, it always is an lvalue.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ExprClassification.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprClassification.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprClassification.cpp:17,Security,access,accesses,17,"// ObjC property accesses are not lvalues, but get special treatment.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ExprClassification.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprClassification.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprClassification.cpp:44,Performance,perform,performed,44,"// Note that at this point, we have already performed all conversions; // according to [expr.cond]p3.; // C++ [expr.cond]p4: If the second and third operands are glvalues of the; // same value category [...], the result is of that [...] value category.; // C++ [expr.cond]p5: Otherwise, the result is a prvalue.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ExprClassification.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprClassification.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprClassification.cpp:58,Security,access,access,58,// Assignment to a property in ObjC is an implicit setter access. But a; // setter might not exist.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ExprClassification.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprClassification.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConcepts.cpp:58,Availability,Recover,RecoveryExpr,58,"// Search through the requirements, and see if any have a RecoveryExpr in it,; // which means this RequiresExpr ALSO needs to be invalid.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ExprConcepts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConcepts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConcepts.cpp:58,Safety,Recover,RecoveryExpr,58,"// Search through the requirements, and see if any have a RecoveryExpr in it,; // which means this RequiresExpr ALSO needs to be invalid.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ExprConcepts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConcepts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConcepts.cpp:29,Integrability,depend,dependency,29,// FIXME: move the computing dependency logic to ComputeDependence.h,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ExprConcepts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConcepts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConcepts.cpp:40,Testability,log,logic,40,// FIXME: move the computing dependency logic to ComputeDependence.h,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ExprConcepts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConcepts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConcepts.cpp:58,Integrability,depend,dependent,58,"// FIXME: this is incorrect for cases where we have a non-dependent; // requirement, but its parameters are instantiation-dependent. RequiresExpr; // should be instantiation-dependent if it has instantiation-dependent; // parameters.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ExprConcepts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConcepts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConcepts.cpp:122,Integrability,depend,dependent,122,"// FIXME: this is incorrect for cases where we have a non-dependent; // requirement, but its parameters are instantiation-dependent. RequiresExpr; // should be instantiation-dependent if it has instantiation-dependent; // parameters.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ExprConcepts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConcepts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConcepts.cpp:174,Integrability,depend,dependent,174,"// FIXME: this is incorrect for cases where we have a non-dependent; // requirement, but its parameters are instantiation-dependent. RequiresExpr; // should be instantiation-dependent if it has instantiation-dependent; // parameters.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ExprConcepts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConcepts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConcepts.cpp:208,Integrability,depend,dependent,208,"// FIXME: this is incorrect for cases where we have a non-dependent; // requirement, but its parameters are instantiation-dependent. RequiresExpr; // should be instantiation-dependent if it has instantiation-dependent; // parameters.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ExprConcepts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConcepts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp:520,Availability,failure,failure,520,"//===--- ExprConstant.cpp - Expression Constant Evaluator -----------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements the Expr constant evaluator.; //; // Constant expression evaluation produces four main results:; //; // * A success/failure flag indicating whether constant folding was successful.; // This is the 'bool' return value used by most of the code in this file. A; // 'false' return value indicates that constant folding has failed, and any; // appropriate diagnostic has already been produced.; //; // * An evaluated result, valid only if constant folding has not failed.; //; // * A flag indicating if evaluation encountered (unevaluated) side-effects.; // These arise in cases such as (sideEffect(), 0) and (sideEffect() || 1),; // where it is possible to determine the evaluated result regardless.; //; // * A set of notes indicating why the evaluation was not a constant expression; // (under the C++11 / C++1y rules only, at the moment), or, if folding failed; // too, why the expression could not be folded.; //; // If we are checking for a potential constant expression, failure to constant; // fold a potential constant sub-expression will be indicated by a 'false'; // return value (the expression could not be folded) and no diagnostic (the; // expression is not necessarily non-constant).; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp:1377,Availability,failure,failure,1377,"//===--- ExprConstant.cpp - Expression Constant Evaluator -----------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements the Expr constant evaluator.; //; // Constant expression evaluation produces four main results:; //; // * A success/failure flag indicating whether constant folding was successful.; // This is the 'bool' return value used by most of the code in this file. A; // 'false' return value indicates that constant folding has failed, and any; // appropriate diagnostic has already been produced.; //; // * An evaluated result, valid only if constant folding has not failed.; //; // * A flag indicating if evaluation encountered (unevaluated) side-effects.; // These arise in cases such as (sideEffect(), 0) and (sideEffect() || 1),; // where it is possible to determine the evaluated result regardless.; //; // * A set of notes indicating why the evaluation was not a constant expression; // (under the C++11 / C++1y rules only, at the moment), or, if folding failed; // too, why the expression could not be folded.; //; // If we are checking for a potential constant expression, failure to constant; // fold a potential constant sub-expression will be indicated by a 'false'; // return value (the expression could not be folded) and no diagnostic (the; // expression is not necessarily non-constant).; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp:20,Modifiability,variab,variable,20,"// If we're doing a variable assignment from e.g. malloc(N), there will; // probably be a cast of some kind. In exotic cases, we might also see a; // top-level ExprWithCleanups. Ignore them either way.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp:173,Performance,perform,perform,173,"/// True if the subobject was named in a manner not supported by C++11. Such; /// lvalues can still be folded, but they are not core constant expressions; /// and we cannot perform lvalue-to-rvalue conversions on them.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp:82,Availability,failure,failure,82,/// Determine what the most derived array's size is. Results in an assertion; /// failure if the most derived array lacks a size.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp:67,Testability,assert,assertion,67,/// Determine what the most derived array's size is. Results in an assertion; /// failure if the most derived array lacks a size.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp:4,Deployability,Update,Update,4,/// Update this designator to refer to the first element within this array.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp:4,Deployability,Update,Update,4,/// Update this designator to refer to the first element within the array of; /// elements of type T. This is an array of unknown size.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp:4,Deployability,Update,Update,4,/// Update this designator to refer to the given base or member of this; /// object.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp:4,Deployability,Update,Update,4,/// Update this designator to refer to the given complex component.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp:370,Modifiability,variab,variables,370,// FIXME: Adding this to every 'CallStackFrame' may have a nontrivial impact; // on the overall stack usage of deeply-recursing constexpr evaluations.; // (We should cache this map rather than recomputing it repeatedly.); // But let's try this and see how it goes; we can look into caching the map; // as a later change.; /// LambdaCaptureFields - Mapping from captured variables/this to; /// corresponding data members in the closure class.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp:166,Performance,cache,cache,166,// FIXME: Adding this to every 'CallStackFrame' may have a nontrivial impact; // on the overall stack usage of deeply-recursing constexpr evaluations.; // (We should cache this map rather than recomputing it repeatedly.); // But let's try this and see how it goes; we can look into caching the map; // as a later change.; /// LambdaCaptureFields - Mapping from captured variables/this to; /// corresponding data members in the closure class.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp:4,Energy Efficiency,Allocate,Allocate,4,"/// Allocate storage for an object of type T in this stack frame.; /// Populates LV with a handle to the created object. Key identifies; /// the temporary within the stack frame, and must not be reused without; /// bumping the temporary version number.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp:4,Energy Efficiency,Allocate,Allocate,4,/// Allocate storage for a parameter of a function call made in this frame.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp:123,Testability,test,test,123,"// A shorthand time trace scope struct, prints source range, for example; // {""name"":""EvaluateAsRValue"",""args"":{""detail"":""<test.cc:8:21, col:25>""}}}",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp:60,Modifiability,extend,extended,60,"/// A cleanup, and a flag indicating whether it is lifetime-extended.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp:45,Performance,perform,performed,45,/// Determine whether this cleanup should be performed at the end of the; /// given kind of scope.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp:18,Energy Efficiency,allocate,allocated,18,/// A dynamically-allocated heap object.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp:27,Energy Efficiency,allocate,allocated,27,/// The value of this heap-allocated object.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp:171,Energy Efficiency,allocate,allocate,171,/// The allocating expression; used for diagnostics. Either a CXXNewExpr; /// or a CallExpr (the latter is for direct calls to operator new inside; /// std::allocator<T>::allocate).,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp:81,Performance,perform,perform,81,/// StepsLeft - The remaining number of evaluation steps we're permitted; /// to perform. This is essentially a limit for the number of statements; /// we will evaluate.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp:116,Availability,error,error,116,"/// Enable the experimental new constant interpreter. If an expression is; /// not supported by the interpreter, an error is triggered.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp:74,Energy Efficiency,allocate,allocated,74,"/// Current heap allocations, along with the location where each was; /// allocated. We use std::map here because we need stable addresses; /// for the stored APValues.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp:35,Performance,perform,performed,35,/// The number of heap allocations performed so far in this evaluation.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp:53,Performance,perform,performing,53,"/// The current array initialization index, if we're performing array; /// initialization.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp:154,Performance,optimiz,optimizer,154,"/// Evaluate as a constant expression. Stop if we find that the expression; /// is not a constant expression. Some expressions can be retried in the; /// optimizer if we don't constant fold them here, but in an unevaluated; /// context we try to fold them immediately since the optimizer never; /// gets a chance to look at it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp:278,Performance,optimiz,optimizer,278,"/// Evaluate as a constant expression. Stop if we find that the expression; /// is not a constant expression. Some expressions can be retried in the; /// optimizer if we don't constant fold them here, but in an unevaluated; /// context we try to fold them immediately since the optimizer never; /// gets a chance to look at it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp:9,Performance,perform,perform,9,// Don't perform any constexpr calls (other than the call we're checking); // when checking a potential constant expression.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp:21,Integrability,wrap,wrapped,21,// NextCallIndex has wrapped around.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp:29,Energy Efficiency,allocate,allocate,29,"// FIXME: GH63562; // Arrays allocate an APValue per element.; // We use the number of constexpr steps as a proxy for the maximum size; // of arrays to avoid exhausting the system resources, as initialization; // of each element is likely to take some number of steps anyway.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp:152,Safety,avoid,avoid,152,"// FIXME: GH63562; // Arrays allocate an APValue per element.; // We use the number of constexpr steps as a proxy for the maximum size; // of arrays to avoid exhausting the system resources, as initialization; // of each element is likely to take some number of steps anyway.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp:12,Energy Efficiency,allocate,allocated,12,/// Get the allocated storage for the given parameter of the given call.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp:63,Energy Efficiency,allocate,allocate,63,/// Information about a stack frame for std::allocator<T>::[de]allocate.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp:37,Modifiability,extend,extended,37,// Disable the cleanups for lifetime-extended temporaries.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp:105,Energy Efficiency,reduce,reduced,105,/// Should we continue evaluation as much as possible after encountering a; /// construct which can't be reduced to a value?,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp:88,Integrability,depend,depend,88,"/// Notes that we failed to evaluate an expression that other expressions; /// directly depend on, and determine if we should keep evaluating. This; /// should only be called if we actually intend to keep evaluating.; ///; /// Call noteSideEffect() instead if we may be able to ignore the value that; /// we failed to evaluate, e.g. if we failed to evaluate Foo() in:; ///; /// (Foo(), 1) // use noteSideEffect; /// (Foo() || true) // use noteSideEffect; /// Foo() + 1 // use noteFailure",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp:3,Availability,Failure,Failure,3,"// Failure when evaluating some expression often means there is some; // subexpression whose evaluation was skipped. Therefore, (because we; // don't track whether we skipped an expression when unwinding after an; // evaluation failure) every evaluation failure that bubbles up from a; // subexpression implies that a side-effect has potentially happened. We; // skip setting the HasSideEffects flag to true until we decide to; // continue evaluating after that point, which happens here.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp:228,Availability,failure,failure,228,"// Failure when evaluating some expression often means there is some; // subexpression whose evaluation was skipped. Therefore, (because we; // don't track whether we skipped an expression when unwinding after an; // evaluation failure) every evaluation failure that bubbles up from a; // subexpression implies that a side-effect has potentially happened. We; // skip setting the HasSideEffects flag to true until we decide to; // continue evaluating after that point, which happens here.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp:254,Availability,failure,failure,254,"// Failure when evaluating some expression often means there is some; // subexpression whose evaluation was skipped. Therefore, (because we; // don't track whether we skipped an expression when unwinding after an; // evaluation failure) every evaluation failure that bubbles up from a; // subexpression implies that a side-effect has potentially happened. We; // skip setting the HasSideEffects flag to true until we decide to; // continue evaluating after that point, which happens here.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp:16,Integrability,wrap,wrapping,16,"/// RAII object wrapping a full-expression or block scope, and handling; /// the ending of the lifetime of temporaries created within it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp:56,Modifiability,extend,extended,56,"// Run all cleanups for a block scope, and non-lifetime-extended cleanups; // for a full-expression scope.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp:15,Security,access,access,15,/// Is this an access per the C++ definition?,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp:52,Integrability,wrap,wrapping,52,"// Compute the new offset in the appropriate width, wrapping at 64 bits.; // FIXME: When compiling for a 32-bit target, we should use 32-bit; // offsets.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp:63,Availability,down,down,63,/// Perform a cast towards the class of the Decl (either up or down the; /// hierarchy).,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp:4,Performance,Perform,Perform,4,/// Perform a cast towards the class of the Decl (either up or down the; /// hierarchy).,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp:4,Performance,Perform,Perform,4,/// Perform a base-to-derived member pointer cast.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp:4,Performance,Perform,Perform,4,/// Perform a derived-to-base member pointer cast.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp:293,Modifiability,extend,extending,293,"//===----------------------------------------------------------------------===//; // Misc utilities; //===----------------------------------------------------------------------===//; /// Negate an APSInt in place, converting it to a signed form if necessary, and; /// preserving its value (by extending by up to one bit as needed).",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp:4,Energy Efficiency,Allocate,Allocate,4,/// Allocate storage for a parameter of a function call made in this frame.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp:159,Modifiability,portab,portable,159,"// We always destroy parameters at the end of the call, even if we'd allow; // them to live to the end of the full-expression at runtime, in order to; // give portable results and match other compilers.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp:59,Usability,GUID,GUID,59,"// ... the address of a function,; // ... the address of a GUID [MS extension],; // ... the address of an unnamed global constant",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp:53,Modifiability,extend,extended,53,// A materialized temporary might have been lifetime-extended to static; // storage duration.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp:84,Modifiability,variab,variables,84,// A Block literal expression may be used as the initialization value for; // Block variables at global or local static scope.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp:178,Modifiability,variab,variable,178,"// FIXME:; // We can never form an lvalue with an implicit value initialization as its; // base through expression evaluation, so these only appear in one case: the; // implicit variable declaration we invent when checking whether a constexpr; // constructor can produce a constant expression. We must assume that such; // an expression might be a global lvalue.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp:30,Modifiability,variab,variables,30,// Non-static local constexpr variables have unintuitive semantics:; // constexpr int a = 1;; // constexpr const int *p = &a;; // ... is invalid because the address of 'a' is not constant. Suggest; // adding a 'static' in this case.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp:35,Modifiability,variab,variable,35,// Check if this is a thread-local variable.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp:15,Modifiability,variab,variable,15,"// A dllimport variable never acts like a constant, unless we're; // evaluating a value for use only in name mangling.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp:52,Modifiability,variab,variables,52,"// In CUDA/HIP device compilation, only device side variables have; // constant addresses.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp:548,Performance,perform,perform,548,"// __declspec(dllimport) must be handled very carefully:; // We must never initialize an expression with the thunk in C++.; // Doing otherwise would allow the same id-expression to yield; // different addresses for the same function in different translation; // units. However, this means that we must dynamically initialize the; // expression with the contents of the import address table at runtime.; //; // The C language has no notion of ODR; furthermore, it has no notion of; // dynamic initialization. This means that we are permitted to; // perform initialization with the address of the thunk.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp:68,Performance,load,loaded,68,/// Check that this evaluated value is fully-initialized and can be loaded by; /// an lvalue-to-rvalue conversion.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp:86,Energy Efficiency,allocate,allocated,86,"/// Enforce C++2a [expr.const]/4.17, which disallows new-expressions unless; /// ""the allocated storage is deallocated within the evaluation"".",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp:206,Integrability,depend,depend,206,"/// Get rounding mode to use in evaluation of the specified expression.; ///; /// If rounding mode is unknown at compile time, still try to evaluate the; /// expression. If the result is exact, it does not depend on rounding mode.; /// So return ""tonearest"" mode instead of ""dynamic"".",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp:32,Integrability,depend,depends,32,"// Inexact result means that it depends on rounding mode. If the requested; // mode is dynamic, the evaluation cannot be made in compile time.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp:168,Modifiability,variab,variable,168,"// FIXME: if:; // - evaluation triggered other FP exception, and; // - exception mode is not ""ignore"", and; // - the expression being evaluated is not a part of global variable; // initializer,; // the evaluation probably need to be rejected.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp:37,Modifiability,extend,extend,37,"// Figure out if this is a truncate, extend or noop cast.; // If the input is signed, do a sign extend, noop, or truncate.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp:96,Modifiability,extend,extend,96,"// Figure out if this is a truncate, extend or noop cast.; // If the input is signed, do a sign extend, noop, or truncate.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp:4,Performance,Perform,Perform,4,"/// Perform the given integer operation, which is known to need at most BitWidth; /// bits, and check for overflow in the original type (if that type was not an; /// unsigned type).",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp:4,Performance,Perform,Perform,4,/// Perform the given binary integer operation.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp:4,Performance,Perform,Perform,4,"/// Perform the given binary floating-point operation, in-place, on LHS.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp:89,Availability,mask,mask,89,// The boolean operations on these vector types use an instruction that; // results in a mask of '-1' for the 'truth' value. Ensure that we negate 1; // to -1 to make sure that we produce the correct value.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp:3,Performance,Perform,Perform,3,"// Perform binary operations for vector types, in place on the LHS.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp:2,Safety,Detect,DetectVirtual,2,/*DetectVirtual=*/,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp:4,Deployability,Update,Update,4,"/// Update LVal to refer to the given field, which must be a member of the type; /// currently described by LVal.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp:4,Deployability,Update,Update,4,/// Update LVal to refer to the given indirect field.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp:4,Deployability,Update,Update,4,"/// Update a pointer value to model pointer arithmetic.; /// \param Info - Information about the ongoing evaluation.; /// \param E - The expression being evaluated, for diagnostic purposes.; /// \param LVal - The pointer value to be updated.; /// \param EltTy - The pointee type represented by LVal.; /// \param Adjustment - The adjustment, in objects of type EltTy, to add.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp:233,Deployability,update,updated,233,"/// Update a pointer value to model pointer arithmetic.; /// \param Info - Information about the ongoing evaluation.; /// \param E - The expression being evaluated, for diagnostic purposes.; /// \param LVal - The pointer value to be updated.; /// \param EltTy - The pointee type represented by LVal.; /// \param Adjustment - The adjustment, in objects of type EltTy, to add.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp:4,Deployability,Update,Update,4,"/// Update an lvalue to refer to a component of a complex number.; /// \param Info - Information about the ongoing evaluation.; /// \param LVal - The lvalue to be updated.; /// \param EltTy - The complex number's component type.; /// \param Imag - False for the real component, true for the imaginary.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp:163,Deployability,update,updated,163,"/// Update an lvalue to refer to a component of a complex number.; /// \param Info - Information about the ongoing evaluation.; /// \param LVal - The lvalue to be updated.; /// \param EltTy - The complex number's component type.; /// \param Imag - False for the real component, true for the imaginary.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp:42,Modifiability,variab,variable,42,/// Try to evaluate the initializer for a variable declaration.; ///; /// \param Info Information about the ongoing evaluation.; /// \param E An expression to be used when printing diagnostics.; /// \param VD The variable whose initializer should be obtained.; /// \param Version The version of the variable within the frame.; /// \param Frame The frame in which the variable was created. Must be null; /// if this variable is not local to the evaluation.; /// \param Result Filled in with a pointer to the value of the variable.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp:213,Modifiability,variab,variable,213,/// Try to evaluate the initializer for a variable declaration.; ///; /// \param Info Information about the ongoing evaluation.; /// \param E An expression to be used when printing diagnostics.; /// \param VD The variable whose initializer should be obtained.; /// \param Version The version of the variable within the frame.; /// \param Frame The frame in which the variable was created. Must be null; /// if this variable is not local to the evaluation.; /// \param Result Filled in with a pointer to the value of the variable.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp:299,Modifiability,variab,variable,299,/// Try to evaluate the initializer for a variable declaration.; ///; /// \param Info Information about the ongoing evaluation.; /// \param E An expression to be used when printing diagnostics.; /// \param VD The variable whose initializer should be obtained.; /// \param Version The version of the variable within the frame.; /// \param Frame The frame in which the variable was created. Must be null; /// if this variable is not local to the evaluation.; /// \param Result Filled in with a pointer to the value of the variable.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp:367,Modifiability,variab,variable,367,/// Try to evaluate the initializer for a variable declaration.; ///; /// \param Info Information about the ongoing evaluation.; /// \param E An expression to be used when printing diagnostics.; /// \param VD The variable whose initializer should be obtained.; /// \param Version The version of the variable within the frame.; /// \param Frame The frame in which the variable was created. Must be null; /// if this variable is not local to the evaluation.; /// \param Result Filled in with a pointer to the value of the variable.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp:415,Modifiability,variab,variable,415,/// Try to evaluate the initializer for a variable declaration.; ///; /// \param Info Information about the ongoing evaluation.; /// \param E An expression to be used when printing diagnostics.; /// \param VD The variable whose initializer should be obtained.; /// \param Version The version of the variable within the frame.; /// \param Frame The frame in which the variable was created. Must be null; /// if this variable is not local to the evaluation.; /// \param Result Filled in with a pointer to the value of the variable.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp:520,Modifiability,variab,variable,520,/// Try to evaluate the initializer for a variable declaration.; ///; /// \param Info Information about the ongoing evaluation.; /// \param E An expression to be used when printing diagnostics.; /// \param VD The variable whose initializer should be obtained.; /// \param Version The version of the variable within the frame.; /// \param Frame The frame in which the variable was created. Must be null; /// if this variable is not local to the evaluation.; /// \param Result Filled in with a pointer to the value of the variable.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp:22,Modifiability,variab,variable,22,"// If this is a local variable, dig out its value.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp:10,Modifiability,variab,variables,10,"// Assume variables referenced within a lambda's call operator that were; // not declared within the call operator are captures and during checking; // of a potential constant expression, assume they are unknown constant; // expressions.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp:60,Usability,usab,usable,60,// Assume parameters of a potential constant expression are usable in; // constant expressions.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp:126,Modifiability,variab,variable,126,"// Dig out the initializer, and use the declaration which it's attached to.; // FIXME: We should eventually check whether the variable has a reachable; // initializing declaration.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp:32,Integrability,depend,dependent,32,"// The DeclRefExpr is not value-dependent, but the variable it refers to; // has a value-dependent initializer. This should only happen in; // constant-folding cases, where the variable is not actually of a suitable; // type for use in a constant expression (otherwise the DeclRefExpr would; // have been value-dependent too), so diagnose that.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp:89,Integrability,depend,dependent,89,"// The DeclRefExpr is not value-dependent, but the variable it refers to; // has a value-dependent initializer. This should only happen in; // constant-folding cases, where the variable is not actually of a suitable; // type for use in a constant expression (otherwise the DeclRefExpr would; // have been value-dependent too), so diagnose that.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp:311,Integrability,depend,dependent,311,"// The DeclRefExpr is not value-dependent, but the variable it refers to; // has a value-dependent initializer. This should only happen in; // constant-folding cases, where the variable is not actually of a suitable; // type for use in a constant expression (otherwise the DeclRefExpr would; // have been value-dependent too), so diagnose that.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp:51,Modifiability,variab,variable,51,"// The DeclRefExpr is not value-dependent, but the variable it refers to; // has a value-dependent initializer. This should only happen in; // constant-folding cases, where the variable is not actually of a suitable; // type for use in a constant expression (otherwise the DeclRefExpr would; // have been value-dependent too), so diagnose that.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp:177,Modifiability,variab,variable,177,"// The DeclRefExpr is not value-dependent, but the variable it refers to; // has a value-dependent initializer. This should only happen in; // constant-folding cases, where the variable is not actually of a suitable; // type for use in a constant expression (otherwise the DeclRefExpr would; // have been value-dependent too), so diagnose that.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp:18,Modifiability,variab,variable,18,"// Check that the variable is actually usable in constant expressions. For a; // const integral variable or a reference, we might have a non-constant; // initializer that we can nonetheless evaluate the initializer for. Such; // variables are not usable in constant expressions. In C++98, the; // initializer also syntactically needs to be an ICE.; //; // FIXME: We don't diagnose cases that aren't potentially usable in constant; // expressions here; doing so would regress diagnostics for things like; // reading from a volatile constexpr variable.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp:96,Modifiability,variab,variable,96,"// Check that the variable is actually usable in constant expressions. For a; // const integral variable or a reference, we might have a non-constant; // initializer that we can nonetheless evaluate the initializer for. Such; // variables are not usable in constant expressions. In C++98, the; // initializer also syntactically needs to be an ICE.; //; // FIXME: We don't diagnose cases that aren't potentially usable in constant; // expressions here; doing so would regress diagnostics for things like; // reading from a volatile constexpr variable.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp:229,Modifiability,variab,variables,229,"// Check that the variable is actually usable in constant expressions. For a; // const integral variable or a reference, we might have a non-constant; // initializer that we can nonetheless evaluate the initializer for. Such; // variables are not usable in constant expressions. In C++98, the; // initializer also syntactically needs to be an ICE.; //; // FIXME: We don't diagnose cases that aren't potentially usable in constant; // expressions here; doing so would regress diagnostics for things like; // reading from a volatile constexpr variable.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp:541,Modifiability,variab,variable,541,"// Check that the variable is actually usable in constant expressions. For a; // const integral variable or a reference, we might have a non-constant; // initializer that we can nonetheless evaluate the initializer for. Such; // variables are not usable in constant expressions. In C++98, the; // initializer also syntactically needs to be an ICE.; //; // FIXME: We don't diagnose cases that aren't potentially usable in constant; // expressions here; doing so would regress diagnostics for things like; // reading from a volatile constexpr variable.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp:39,Usability,usab,usable,39,"// Check that the variable is actually usable in constant expressions. For a; // const integral variable or a reference, we might have a non-constant; // initializer that we can nonetheless evaluate the initializer for. Such; // variables are not usable in constant expressions. In C++98, the; // initializer also syntactically needs to be an ICE.; //; // FIXME: We don't diagnose cases that aren't potentially usable in constant; // expressions here; doing so would regress diagnostics for things like; // reading from a volatile constexpr variable.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp:247,Usability,usab,usable,247,"// Check that the variable is actually usable in constant expressions. For a; // const integral variable or a reference, we might have a non-constant; // initializer that we can nonetheless evaluate the initializer for. Such; // variables are not usable in constant expressions. In C++98, the; // initializer also syntactically needs to be an ICE.; //; // FIXME: We don't diagnose cases that aren't potentially usable in constant; // expressions here; doing so would regress diagnostics for things like; // reading from a volatile constexpr variable.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp:411,Usability,usab,usable,411,"// Check that the variable is actually usable in constant expressions. For a; // const integral variable or a reference, we might have a non-constant; // initializer that we can nonetheless evaluate the initializer for. Such; // variables are not usable in constant expressions. In C++98, the; // initializer also syntactically needs to be an ICE.; //; // FIXME: We don't diagnose cases that aren't potentially usable in constant; // expressions here; doing so would regress diagnostics for things like; // reading from a volatile constexpr variable.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp:39,Modifiability,variab,variable,39,"// Never use the initializer of a weak variable, not even for constant; // folding. We can't be sure that this is the definition that will be used.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp:7,Modifiability,variab,variable,7,// The variable whose initializer we're evaluating.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp:24,Modifiability,extend,extended,24,// A temporary lifetime-extended by the variable whose initializer we're; // evaluating.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp:40,Modifiability,variab,variable,40,// A temporary lifetime-extended by the variable whose initializer we're; // evaluating.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp:30,Modifiability,extend,extend,30,"// FIXME: We can meaningfully extend this to cover non-const objects, but; // we will need special handling: we should be able to access only; // subobjects of such objects that are themselves declared const.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp:130,Security,access,access,130,"// FIXME: We can meaningfully extend this to cover non-const objects, but; // we will need special handling: we should be able to access only; // subobjects of such objects that are themselves declared const.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp:26,Security,access,access,26,"// If this isn't a ""real"" access (eg, if it's just accessing the type; // info), allow it. We assume the type doesn't change dynamically for; // subobjects of constexpr objects (even though we'd hit UB here if it; // did). FIXME: Is this right?",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp:51,Security,access,accessing,51,"// If this isn't a ""real"" access (eg, if it's just accessing the type; // info), allow it. We assume the type doesn't change dynamically for; // subobjects of constexpr objects (even though we'd hit UB here if it; // did). FIXME: Is this right?",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp:3,Security,Access,Accesses,3,// Accesses to volatile objects are prohibited.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp:150,Performance,perform,perform,150,"// If we are reading an object of class type, there may still be more; // things we need to check: if there are any mutable subobjects, we; // cannot perform this read. (This only happens when performing a trivial; // copy or assignment.)",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp:193,Performance,perform,performing,193,"// If we are reading an object of class type, there may still be more; // things we need to check: if there are any mutable subobjects, we; // cannot perform this read. (This only happens when performing a trivial; // copy or assignment.)",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp:4,Deployability,Update,Update,4,/// Update the designated sub-object of an rvalue to the given value.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp:24,Usability,GUID,GUID,24,// Allow reading from a GUID declaration.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp:112,Modifiability,variab,variables,112,"// In C++98, const, non-volatile integers initialized with ICEs are ICEs.; // In C++11, constexpr, non-volatile variables initialized with constant; // expressions are constant expressions too. Inside constexpr functions,; // parameters are constant expressions even if they're non-const.; // In C++1y, objects local to a constant expression (those with a Frame) are; // both readable and writable inside constant expressions.; // In C, such things can also be folded, although they are not ICEs.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp:35,Modifiability,variab,variable,35,"// Unless we're looking at a local variable or argument in a constexpr call,; // the variable we're reading must be const.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp:85,Modifiability,variab,variable,85,"// Unless we're looking at a local variable or argument in a constexpr call,; // the variable we're reading must be const.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp:3,Security,Access,Access,3,"// Access of a parameter that's not associated with a frame isn't going; // to work out, but we can leave it to evaluateVarDeclInit to provide a; // suitable diagnostic.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp:24,Modifiability,variab,variable,24,"// OK, we can read this variable.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp:8,Modifiability,variab,variable,8,// This variable might end up being constexpr. Don't diagnose it yet.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp:196,Modifiability,extend,extended,196,"// C++20 [expr.const]p4: [DR2126]; // An object or reference is usable in constant expressions if it is; // - a temporary object of non-volatile const-qualified literal type; // whose lifetime is extended to that of a variable that is usable; // in constant expressions; //; // C++20 [expr.const]p5:; // an lvalue-to-rvalue conversion [is not allowed unless it applies to]; // - a non-volatile glvalue that refers to an object that is usable; // in constant expressions, or; // - a non-volatile glvalue of literal type that refers to a; // non-volatile object whose lifetime began within the evaluation; // of E;; //; // C++11 misses the 'began within the evaluation of e' check and; // instead allows all temporaries, including things like:; // int &&r = 1;; // int x = ++r;; // constexpr int k = r;; // Therefore we use the C++14-onwards rules in C++11 too.; //; // Note that temporaries whose lifetimes began while evaluating a; // variable's constructor are not usable while evaluating the; // corresponding destructor, not even if they're of const-qualified; // types.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp:218,Modifiability,variab,variable,218,"// C++20 [expr.const]p4: [DR2126]; // An object or reference is usable in constant expressions if it is; // - a temporary object of non-volatile const-qualified literal type; // whose lifetime is extended to that of a variable that is usable; // in constant expressions; //; // C++20 [expr.const]p5:; // an lvalue-to-rvalue conversion [is not allowed unless it applies to]; // - a non-volatile glvalue that refers to an object that is usable; // in constant expressions, or; // - a non-volatile glvalue of literal type that refers to a; // non-volatile object whose lifetime began within the evaluation; // of E;; //; // C++11 misses the 'began within the evaluation of e' check and; // instead allows all temporaries, including things like:; // int &&r = 1;; // int x = ++r;; // constexpr int k = r;; // Therefore we use the C++14-onwards rules in C++11 too.; //; // Note that temporaries whose lifetimes began while evaluating a; // variable's constructor are not usable while evaluating the; // corresponding destructor, not even if they're of const-qualified; // types.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp:935,Modifiability,variab,variable,935,"// C++20 [expr.const]p4: [DR2126]; // An object or reference is usable in constant expressions if it is; // - a temporary object of non-volatile const-qualified literal type; // whose lifetime is extended to that of a variable that is usable; // in constant expressions; //; // C++20 [expr.const]p5:; // an lvalue-to-rvalue conversion [is not allowed unless it applies to]; // - a non-volatile glvalue that refers to an object that is usable; // in constant expressions, or; // - a non-volatile glvalue of literal type that refers to a; // non-volatile object whose lifetime began within the evaluation; // of E;; //; // C++11 misses the 'began within the evaluation of e' check and; // instead allows all temporaries, including things like:; // int &&r = 1;; // int x = ++r;; // constexpr int k = r;; // Therefore we use the C++14-onwards rules in C++11 too.; //; // Note that temporaries whose lifetimes began while evaluating a; // variable's constructor are not usable while evaluating the; // corresponding destructor, not even if they're of const-qualified; // types.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp:64,Usability,usab,usable,64,"// C++20 [expr.const]p4: [DR2126]; // An object or reference is usable in constant expressions if it is; // - a temporary object of non-volatile const-qualified literal type; // whose lifetime is extended to that of a variable that is usable; // in constant expressions; //; // C++20 [expr.const]p5:; // an lvalue-to-rvalue conversion [is not allowed unless it applies to]; // - a non-volatile glvalue that refers to an object that is usable; // in constant expressions, or; // - a non-volatile glvalue of literal type that refers to a; // non-volatile object whose lifetime began within the evaluation; // of E;; //; // C++11 misses the 'began within the evaluation of e' check and; // instead allows all temporaries, including things like:; // int &&r = 1;; // int x = ++r;; // constexpr int k = r;; // Therefore we use the C++14-onwards rules in C++11 too.; //; // Note that temporaries whose lifetimes began while evaluating a; // variable's constructor are not usable while evaluating the; // corresponding destructor, not even if they're of const-qualified; // types.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp:235,Usability,usab,usable,235,"// C++20 [expr.const]p4: [DR2126]; // An object or reference is usable in constant expressions if it is; // - a temporary object of non-volatile const-qualified literal type; // whose lifetime is extended to that of a variable that is usable; // in constant expressions; //; // C++20 [expr.const]p5:; // an lvalue-to-rvalue conversion [is not allowed unless it applies to]; // - a non-volatile glvalue that refers to an object that is usable; // in constant expressions, or; // - a non-volatile glvalue of literal type that refers to a; // non-volatile object whose lifetime began within the evaluation; // of E;; //; // C++11 misses the 'began within the evaluation of e' check and; // instead allows all temporaries, including things like:; // int &&r = 1;; // int x = ++r;; // constexpr int k = r;; // Therefore we use the C++14-onwards rules in C++11 too.; //; // Note that temporaries whose lifetimes began while evaluating a; // variable's constructor are not usable while evaluating the; // corresponding destructor, not even if they're of const-qualified; // types.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp:435,Usability,usab,usable,435,"// C++20 [expr.const]p4: [DR2126]; // An object or reference is usable in constant expressions if it is; // - a temporary object of non-volatile const-qualified literal type; // whose lifetime is extended to that of a variable that is usable; // in constant expressions; //; // C++20 [expr.const]p5:; // an lvalue-to-rvalue conversion [is not allowed unless it applies to]; // - a non-volatile glvalue that refers to an object that is usable; // in constant expressions, or; // - a non-volatile glvalue of literal type that refers to a; // non-volatile object whose lifetime began within the evaluation; // of E;; //; // C++11 misses the 'began within the evaluation of e' check and; // instead allows all temporaries, including things like:; // int &&r = 1;; // int x = ++r;; // constexpr int k = r;; // Therefore we use the C++14-onwards rules in C++11 too.; //; // Note that temporaries whose lifetimes began while evaluating a; // variable's constructor are not usable while evaluating the; // corresponding destructor, not even if they're of const-qualified; // types.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp:966,Usability,usab,usable,966,"// C++20 [expr.const]p4: [DR2126]; // An object or reference is usable in constant expressions if it is; // - a temporary object of non-volatile const-qualified literal type; // whose lifetime is extended to that of a variable that is usable; // in constant expressions; //; // C++20 [expr.const]p5:; // an lvalue-to-rvalue conversion [is not allowed unless it applies to]; // - a non-volatile glvalue that refers to an object that is usable; // in constant expressions, or; // - a non-volatile glvalue of literal type that refers to a; // non-volatile object whose lifetime began within the evaluation; // of E;; //; // C++11 misses the 'began within the evaluation of e' check and; // instead allows all temporaries, including things like:; // int &&r = 1;; // int x = ++r;; // constexpr int k = r;; // Therefore we use the C++14-onwards rules in C++11 too.; //; // Note that temporaries whose lifetimes began while evaluating a; // variable's constructor are not usable while evaluating the; // corresponding destructor, not even if they're of const-qualified; // types.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp:22,Safety,safe,safely,22,"// In C++14, we can't safely access any mutable state when we might be; // evaluating after an unmodeled side effect. Parameters are modeled as state; // in the caller, but aren't visible once the call returns, so they can be; // modified in a speculatively-evaluated call.; //; // FIXME: Not all local state is mutable. Allow local constant subobjects; // to be read here (but take care with 'mutable' fields).",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp:29,Security,access,access,29,"// In C++14, we can't safely access any mutable state when we might be; // evaluating after an unmodeled side effect. Parameters are modeled as state; // in the caller, but aren't visible once the call returns, so they can be; // modified in a speculatively-evaluated call.; //; // FIXME: Not all local state is mutable. Allow local constant subobjects; // to be read here (but take care with 'mutable' fields).",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp:4,Performance,Perform,Perform,4,"/// Perform an lvalue-to-rvalue conversion on the given glvalue. This; /// can also be used for 'lvalue-to-lvalue' conversions for looking up the; /// glvalue referred to by an entity of reference type.; ///; /// \param Info - Information about the ongoing evaluation.; /// \param Conv - The expression for which we are performing the conversion.; /// Used for diagnostics.; /// \param Type - The type of the glvalue (before stripping cv-qualifiers in the; /// case of a non-class type).; /// \param LVal - The glvalue on which we are attempting to perform this action.; /// \param RVal - The produced value will be placed here.; /// \param WantObjectRepresentation - If true, we're looking for the object; /// representation rather than the value, and in particular,; /// there is no requirement that the result be fully initialized.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp:320,Performance,perform,performing,320,"/// Perform an lvalue-to-rvalue conversion on the given glvalue. This; /// can also be used for 'lvalue-to-lvalue' conversions for looking up the; /// glvalue referred to by an entity of reference type.; ///; /// \param Info - Information about the ongoing evaluation.; /// \param Conv - The expression for which we are performing the conversion.; /// Used for diagnostics.; /// \param Type - The type of the glvalue (before stripping cv-qualifiers in the; /// case of a non-class type).; /// \param LVal - The glvalue on which we are attempting to perform this action.; /// \param RVal - The produced value will be placed here.; /// \param WantObjectRepresentation - If true, we're looking for the object; /// representation rather than the value, and in particular,; /// there is no requirement that the result be fully initialized.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp:549,Performance,perform,perform,549,"/// Perform an lvalue-to-rvalue conversion on the given glvalue. This; /// can also be used for 'lvalue-to-lvalue' conversions for looking up the; /// glvalue referred to by an entity of reference type.; ///; /// \param Info - Information about the ongoing evaluation.; /// \param Conv - The expression for which we are performing the conversion.; /// Used for diagnostics.; /// \param Type - The type of the glvalue (before stripping cv-qualifiers in the; /// case of a non-class type).; /// \param LVal - The glvalue on which we are attempting to perform this action.; /// \param RVal - The produced value will be placed here.; /// \param WantObjectRepresentation - If true, we're looking for the object; /// representation rather than the value, and in particular,; /// there is no requirement that the result be fully initialized.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp:348,Modifiability,variab,variable,348,"// According to GCC info page:; //; // 6.28 Compound Literals; //; // As an optimization, G++ sometimes gives array compound literals longer; // lifetimes: when the array either appears outside a function or has a; // const-qualified type. If foo and its initializer had elements of type; // char *const rather than char *, or if foo were a global variable, the; // array would have static storage duration. But it is probably safest; // just to avoid the use of array compound literals in C++ code.; //; // Obey that rule by checking constness for converted array types.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp:76,Performance,optimiz,optimization,76,"// According to GCC info page:; //; // 6.28 Compound Literals; //; // As an optimization, G++ sometimes gives array compound literals longer; // lifetimes: when the array either appears outside a function or has a; // const-qualified type. If foo and its initializer had elements of type; // char *const rather than char *, or if foo were a global variable, the; // array would have static storage duration. But it is probably safest; // just to avoid the use of array compound literals in C++ code.; //; // Obey that rule by checking constness for converted array types.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp:427,Safety,safe,safest,427,"// According to GCC info page:; //; // 6.28 Compound Literals; //; // As an optimization, G++ sometimes gives array compound literals longer; // lifetimes: when the array either appears outside a function or has a; // const-qualified type. If foo and its initializer had elements of type; // char *const rather than char *, or if foo were a global variable, the; // array would have static storage duration. But it is probably safest; // just to avoid the use of array compound literals in C++ code.; //; // Obey that rule by checking constness for converted array types.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp:446,Safety,avoid,avoid,446,"// According to GCC info page:; //; // 6.28 Compound Literals; //; // As an optimization, G++ sometimes gives array compound literals longer; // lifetimes: when the array either appears outside a function or has a; // const-qualified type. If foo and its initializer had elements of type; // char *const rather than char *, or if foo were a global variable, the; // array would have static storage duration. But it is probably safest; // just to avoid the use of array compound literals in C++ code.; //; // Obey that rule by checking constness for converted array types.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp:4,Performance,Perform,Perform,4,/// Perform an assignment of Val to LVal. Takes ownership of Val.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp:4,Performance,Perform,Perform,4,/// Perform a compound assignment of LVal <op>= RVal.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp:29,Usability,clear,clear,29,"// Stash the old value. Also clear Old, so we don't clobber it later; // if we're post-incrementing a complex.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp:80,Energy Efficiency,reduce,reduce,80,"// bool arithmetic promotes to int, and the conversion back to bool; // doesn't reduce mod 2^n, so special-case it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp:32,Performance,Perform,Perform,32,// end anonymous namespace; /// Perform an increment or decrement on LVal.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp:50,Security,access,access,50,"/// HandleMemberPointerAccess - Evaluate a member access operation and build an; /// lvalue referring to the result.; ///; /// \param Info - Information about the ongoing evaluation.; /// \param LV - An lvalue referring to the base of the member pointer.; /// \param RHS - The member pointer expression.; /// \param IncludeMember - Specifies whether the member itself is included in; /// the resulting LValue subobject designator. This is not possible when; /// creating a bound member function.; /// \return The field or method declaration to which the member pointer refers,; /// or 0 if evaluation fails.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp:3,Modifiability,Extend,Extend,3,// Extend the LValue path with the member pointer's path.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp:8,Availability,down,down,8,// Walk down to the appropriate base class.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp:35,Modifiability,variab,variable,35,/// Evaluate a condition (either a variable declaration or an expression).,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp:80,Performance,Cache,Cache,80,// Find the switch case corresponding to the value of the condition.; // FIXME: Cache this lookup.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp:185,Modifiability,variab,variable,185,// An expression E is a core constant expression unless the evaluation of E; // would evaluate one of the following: [C++23] - a control flow that passes; // through a declaration of a variable with static or thread storage duration; // unless that variable is usable in constant expressions.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp:249,Modifiability,variab,variable,249,// An expression E is a core constant expression unless the evaluation of E; // would evaluate one of the following: [C++23] - a control flow that passes; // through a declaration of a variable with static or thread storage duration; // unless that variable is usable in constant expressions.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp:261,Usability,usab,usable,261,// An expression E is a core constant expression unless the evaluation of E; // would evaluate one of the following: [C++23] - a control flow that passes; // through a declaration of a variable with static or thread storage duration; // unless that variable is usable in constant expressions.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp:20,Availability,down,down,20,"// If we're hunting down a 'case' or 'default' label, recurse through; // substatements until we hit the label.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp:120,Performance,perform,performing,120,"// FIXME: Precompute which substatement of a compound statement we; // would jump to, and go straight there rather than performing a; // linear scan each time.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp:3,Integrability,Wrap,Wrap,3,"// Wrap the evaluation in a block scope, in case it's a DeclStmt; // preceded by our switch label.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp:73,Modifiability,variab,variable,73,// Step into the init statement in case it brings an (uninitialized); // variable into scope.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp:13,Modifiability,variab,variable,13,"// Condition variable must be initialized if it exists.; // FIXME: We can skip evaluating the body if there's a condition; // variable, as there can't be any case labels within it.; // (The same is true for 'for' statements.)",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp:126,Modifiability,variab,variable,126,"// Condition variable must be initialized if it exists.; // FIXME: We can skip evaluating the body if there's a condition; // variable, as there can't be any case labels within it.; // (The same is true for 'for' statements.)",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp:73,Modifiability,variab,variable,73,// Step into the init statement in case it brings an (uninitialized); // variable into scope.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp:43,Modifiability,variab,variables,43,// Start the lifetime of any uninitialized variables we encounter. They; // might be used by the selected branch of the switch.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp:17,Modifiability,variab,variable,17,"// FIXME: If the variable has initialization that can't be jumped; // over, bail out of any immediately-surrounding compound-statement; // too. There can't be any case labels here.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp:26,Modifiability,variab,variable,26,// Initialize the __range variable.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp:6,Availability,error,error-recovery,6,// In error-recovery cases it's possible to get here even if we failed to; // synthesize the __begin and __end variables.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp:111,Modifiability,variab,variables,111,// In error-recovery cases it's possible to get here even if we failed to; // synthesize the __begin and __end variables.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp:12,Safety,recover,recovery,12,// In error-recovery cases it's possible to get here even if we failed to; // synthesize the __begin and __end variables.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp:10,Modifiability,variab,variable,10,"// User's variable declaration, initialized by *__begin.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp:54,Modifiability,inherit,inherited,54,"// If this function is not constexpr because it is an inherited; // non-constexpr constructor, diagnose that directly.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp:82,Modifiability,inherit,inheriting,82,"// FIXME: If DiagDecl is an implicitly-declared special member function; // or an inheriting constructor, we should be much more explicit about why; // it's not constexpr.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp:50,Security,access,access,50,// end anonymous namespace; /// Check that we can access the notional vptr of an object / determine its; /// dynamic type.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp:21,Usability,usab,usable,21,"// The object is not usable in constant expressions, so we can't inspect; // its value to see if it's in-lifetime or what the active union members; // are. We can still check for a one-past-the-end lvalue.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp:38,Modifiability,polymorphi,polymorphic,38,// Conservatively refuse to perform a polymorphic operation if we would; // not be able to read a notional 'vptr' value.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp:28,Performance,perform,perform,28,// Conservatively refuse to perform a polymorphic operation if we would; // not be able to read a notional 'vptr' value.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp:162,Modifiability,polymorphi,polymorphic,162,"// CWG issue 1517: we're constructing a base class of the object described by; // 'This', so that object has not yet begun its period of construction and; // any polymorphic operation on it results in undefined behavior.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp:4,Performance,Perform,Perform,4,/// Perform virtual dispatch.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp:3,Performance,Perform,Perform,3,// Perform 'this' adjustment.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp:4,Performance,Perform,Perform,4,"/// Perform the adjustment from a value returned by a virtual function to; /// a value of the statically expected type, which may be a pointer or; /// reference to a base class of the returned type.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp:34,Modifiability,inherit,inheritance,34,// We can only walk across public inheritance edges.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp:2,Safety,Detect,DetectVirtual,2,/*DetectVirtual=*/,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp:3,Availability,Down,Downcast,3,// Downcast to the dynamic type...,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp:22,Performance,perform,perform,22,"// We are supposed to perform no initialization but begin the lifetime of; // the object. We interpret that as meaning to do what default; // initialization of the object would do if all constructors involved were; // trivial:; // * All base, non-variant member, and array element subobjects' lifetimes; // begin; // * No variant members' lifetimes begin; // * All scalar subobjects whose lifetimes begin have indeterminate values",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp:137,Security,access,access,137,"/// Handle a builtin simple-assignment or a call to a trivial assignment; /// operator whose left-hand side might involve a union member access. If it; /// does, implicitly start the lifetime of any accessed union elements per; /// C++20 [class.union]5.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp:199,Security,access,accessed,199,"/// Handle a builtin simple-assignment or a call to a trivial assignment; /// operator whose left-hand side might involve a union member access. If it; /// does, implicitly start the lifetime of any accessed union elements per; /// C++20 [class.union]5.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp:21,Usability,simpl,simple-assignment,21,"/// Handle a builtin simple-assignment or a call to a trivial assignment; /// operator whose left-hand side might involve a union member access. If it; /// does, implicitly start the lifetime of any accessed union elements per; /// C++20 [class.union]5.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp:31,Security,access,access,31,"// if modification of X [would access an inactive union member], an object; // of the type of X is implicitly created",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp:203,Performance,perform,performing,203,"// Create the parameter slot and register its destruction. For a vararg; // argument, create a temporary.; // FIXME: For calling conventions that destroy parameters in the callee,; // should we consider performing destruction when the function returns; // instead?",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp:4,Performance,Perform,Perform,4,"/// Perform a trivial copy from Param, which is the parameter of a copy or move; /// constructor or assignment operator.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp:42,Performance,perform,perform,42,"// For a trivial copy or move assignment, perform an APValue copy. This is; // essential for unions, where the operations performed by the assignment; // operator cannot be represented as statements.; //; // Skip this for non-union classes with no fields; in that case, the defaulted; // copy/move does not actually read the object.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp:122,Performance,perform,performed,122,"// For a trivial copy or move assignment, perform an APValue copy. This is; // essential for unions, where the operations performed by the assignment; // operator cannot be represented as statements.; //; // Skip this for non-union classes with no fields; in that case, the defaulted; // copy/move does not actually read the object.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp:280,Security,access,access,280,"// We're in a lambda; determine the lambda capture field maps unless we're; // just constexpr checking a lambda's call operator. constexpr checking is; // done before the captures have been added to the closure object (unless; // we're inferring constexpr-ness), so we don't have access to them in this; // case. But since we don't need the captures to constexpr check, we can; // just ignore them.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp:43,Performance,perform,perform,43,"// For a trivial copy or move constructor, perform an APValue copy. This is; // essential for unions (or classes with anonymous union members), where the; // operations performed by the constructor cannot be represented by; // ctor-initializers.; //; // Skip this for empty non-union classes; we should not perform an; // lvalue-to-rvalue conversion on them because their copy constructor does not; // actually read them.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp:169,Performance,perform,performed,169,"// For a trivial copy or move constructor, perform an APValue copy. This is; // essential for unions (or classes with anonymous union members), where the; // operations performed by the constructor cannot be represented by; // ctor-initializers.; //; // Skip this for empty non-union classes; we should not perform an; // lvalue-to-rvalue conversion on them because their copy constructor does not; // actually read them.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp:307,Performance,perform,perform,307,"// For a trivial copy or move constructor, perform an APValue copy. This is; // essential for unions (or classes with anonymous union members), where the; // operations performed by the constructor cannot be represented by; // ctor-initializers.; //; // Skip this for empty non-union classes; we should not perform an; // lvalue-to-rvalue conversion on them because their copy constructor does not; // actually read them.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp:36,Modifiability,extend,extended,36,// A scope for temporaries lifetime-extended by reference members.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp:45,Availability,avail,available,45,"// Ensure that we have actual array elements available to destroy; the; // destructors might mutate the value, so we can't run them on the array; // filler.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp:4,Performance,Perform,Perform,4,"/// Perform a destructor or pseudo-destructor call on the given object, which; /// might in general not be a complete object.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp:4,Performance,Perform,Perform,4,/// Perform a call to 'operator new' or to `__builtin_operator_new'.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp:62,Energy Efficiency,allocate,allocate,62,// This is permitted only within a call to std::allocator<T>::allocate.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp:222,Availability,failure,failure,222,"/// Check that the given object is a suitable pointer to a heap allocation that; /// still exists and is of the right kind for the purpose of a deletion.; ///; /// On success, returns the heap allocation to deallocate. On failure, produces; /// a diagnostic and returns std::nullopt.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp:3,Performance,Perform,Perform,3,// Perform a call to 'operator delete' or '__builtin_operator_delete'.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp:111,Integrability,contract,contract,111,"// Deleting a null pointer would have no effect, but it's not permitted by; // std::allocator<T>::deallocate's contract.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp:123,Usability,simpl,simply,123,"// The vector's size in bits is not a multiple of the target's byte size,; // so its layout is unspecified. For now, we'll simply treat these cases; // as unsupported (this should only be possible with OpenCL bool vectors; // whose element count isn't a multiple of the byte size).",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp:37,Availability,error,error,37,"// Emit an unsupported bit_cast type error. Sema refuses to build a bit_cast; // with an invalid type, so anything left is a deficiency on our part (FIXME).; // Ideally this will be unreachable.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp:62,Testability,log,logic,62,"// FIXME: We don't currently support bit-fields. A lot of the logic for; // this is in CodeGen, so we need to factor it around.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp:123,Usability,simpl,simply,123,"// The vector's size in bits is not a multiple of the target's byte size,; // so its layout is unspecified. For now, we'll simply treat these cases; // as unsupported (this should only be possible with OpenCL bool vectors; // whose element count isn't a multiple of the byte size).",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp:497,Security,access,accessed,497,"// Special handling for OpenCL bool vectors:; // Since these vectors are stored as packed bits, but we can't read; // individual bits from the BitCastBuffer, we'll buffer all of the; // elements together into an appropriately sized APInt and write them all; // out at once. Because we don't accept vectors where NElts * EltSize; // isn't a multiple of the char size, there will be no padding space, so; // we don't have to worry about reading any padding data which didn't; // actually need to be accessed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp:25,Availability,error,error,25,"/// Report an evaluation error. This should only be called when an error is; /// first discovered. When propagating an error, just return false.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp:67,Availability,error,error,67,"/// Report an evaluation error. This should only be called when an error is; /// first discovered. When propagating an error, just return false.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp:119,Availability,error,error,119,"/// Report an evaluation error. This should only be called when an error is; /// first discovered. When propagating an error, just return false.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp:16,Performance,cache,cache,16,"// Evaluate and cache the common expression. We treat it as a temporary,; // even though it's not quite the same thing.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp:30,Usability,simpl,simple,30,"// If this is syntactically a simple assignment using a trivial; // assignment operator, start the lifetimes of union members as needed,; // per C++20 [class.union]5.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp:3,Performance,Perform,Perform,3,"// Perform virtual dispatch, if necessary.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp:1123,Modifiability,extend,extended,1123,"//===----------------------------------------------------------------------===//; // LValue Evaluation; //; // This is used for evaluating lvalues (in C and C++), xvalues (in C++11),; // function designators (in C), decl references to void objects (in C), and; // temporaries (if building with -Wno-address-of-temporary).; //; // LValue evaluation produces values comprising a base expression of one of the; // following types:; // - Declarations; // * VarDecl; // * FunctionDecl; // - Literals; // * CompoundLiteralExpr in C (and in global scope in C++); // * StringLiteral; // * PredefinedExpr; // * ObjCStringLiteralExpr; // * ObjCEncodeExpr; // * AddrLabelExpr; // * BlockExpr; // * CallExpr for a MakeStringConstant builtin; // - typeid(T) expressions, as TypeInfoLValues; // - Locals and temporaries; // * MaterializeTemporaryExpr; // * Any Expr, with a CallIndex indicating the function in which the temporary; // was evaluated, for cases where the MaterializeTemporaryExpr is missing; // from the AST (FIXME).; // * A MaterializeTemporaryExpr that has static storage duration, with no; // CallIndex, for a lifetime-extended temporary.; // * The ConstantExpr that is currently being evaluated during evaluation of an; // immediate invocation.; // plus an offset in bytes.; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp:12,Deployability,update,update,12,// ... then update it to refer to the field of the closure object; // that represents the capture.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp:42,Deployability,update,update,42,"// And if the field is of reference type, update 'Result' to refer to what; // the field refers to.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp:19,Modifiability,variab,variable,19,"// Only if a local variable was declared in the function currently being; // evaluated, do we expect to be able to find its value in the current; // frame. (Otherwise it was likely declared in an enclosing context and; // could either have a valid evaluatable value (for e.g. a constexpr; // variable) or be ill-formed (and trigger an appropriate evaluation; // diagnostic)).",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp:292,Modifiability,variab,variable,292,"// Only if a local variable was declared in the function currently being; // evaluated, do we expect to be able to find its value in the current; // frame. (Otherwise it was likely declared in an enclosing context and; // could either have a valid evaluatable value (for e.g. a constexpr; // variable) or be ill-formed (and trigger an appropriate evaluation; // diagnostic)).",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp:104,Modifiability,inherit,inherited,104,"// Function parameters are stored in some caller's frame. (Usually the; // immediate caller, but for an inherited constructor they may be more; // distant.)",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp:231,Availability,avail,available,231,//===----------------------------------------------------------------------===//; // Pointer Evaluation; //===----------------------------------------------------------------------===//; /// Attempts to compute the number of bytes available at the pointer; /// returned by a function with the alloc_size attribute. Returns true if we; /// were successful. Places an unsigned number into `Result`.; ///; /// This expects the given CallExpr to be a call to a function with an; /// alloc_size attribute.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp:67,Modifiability,variab,variables,67,"// Because we do no form of static analysis, we only support const variables.; //; // Additionally, we can't support parameters, nor can we support static; // variables (in the latter case, use-before-assign isn't UB; in the former,; // we have no clue what they'll be assigned to).",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp:159,Modifiability,variab,variables,159,"// Because we do no form of static analysis, we only support const variables.; //; // Additionally, we can't support parameters, nor can we support static; // variables (in the latter case, use-before-assign isn't UB; in the former,; // we have no clue what they'll be assigned to).",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp:96,Availability,error,error,96,"// Ensure we actually have captured 'this'. If something was wrong with; // 'this' capture, the error would have been previously reported.; // Otherwise we can be inside of a default initialization of an object; // declared by lambda's body, so no need to return false.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp:244,Deployability,Update,Update,244,"// If we have captured 'this', the 'this' expression refers; // to the enclosing '*this' object (either by value or reference) which is; // either copied into the closure object's field that represents the; // '*this' or refers to '*this'.; // Update 'Result' to refer to the data member/field of the closure object; // that represents the '*this' capture.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp:20,Integrability,protocol,protocol,20,"// FIXME: Missing: @protocol, @selector",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp:40,Energy Efficiency,allocate,allocate,40,"// 1. We'll allow it in std::allocator::allocate, and anything which that; // calls.; // 2. HACK 2022-03-28: Work around an issue with libstdc++'s; // <source_location> header. Fixed in GCC 12 and later (2022-04-??).; // We'll allow it in the body of std::source_location::current. GCC's; // implementation had a parameter of type `void*`, and casts from; // that back to `const __impl*` in its body.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp:54,Testability,log,logic,54,"// The kinds of expressions that we have special-case logic here for; // should be kept up to date with the special checks for those; // expressions in Sema.; // alignof decl is always accepted, even if it doesn't make sense: we default; // to 1 in those cases.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp:72,Availability,down,down,72,"/// Evaluate the value of the alignment argument to __builtin_align_{up,down},; /// __builtin_is_aligned and __builtin_assume_aligned.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp:87,Testability,assert,assert,87,// Ensure both alignment and source value have the same bit width so that we; // don't assert when computing the resulting value.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp:9,Usability,clear,clear,9,// To be clear: this happily visits unsupported builtins. Better name welcomed.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp:81,Testability,assert,asserted,81,"// We need to be very careful here because: if the pointer does not have the; // asserted alignment, then the behavior is undefined, and undefined; // behavior is non-constant.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp:332,Performance,perform,perform,332,"// The alignment could be greater than the minimum at run-time, so we cannot; // infer much about the resulting pointer value. One case is possible:; // For `_Alignas(32) char buf[N]; __builtin_align_down(&buf[idx], 32)` we; // can infer the correct index if the requested alignment is smaller than; // the base alignment so we can perform the computation on the offset.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp:418,Modifiability,extend,extended,418,"// The only new-placement list we support is of the form (std::nothrow).; //; // FIXME: There is no restriction on this, but it's not clear that any; // other form makes any sense. We get here for cases such as:; //; // new (std::align_val_t{N}) X(int); //; // (which should presumably be valid only if N is a multiple of; // alignof(int), and in any case can't be deallocated unless N is; // alignof(X) and X has new-extended alignment).",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp:134,Usability,clear,clear,134,"// The only new-placement list we support is of the form (std::nothrow).; //; // FIXME: There is no restriction on this, but it's not clear that any; // other form makes any sense. We get here for cases such as:; //; // new (std::align_val_t{N}) X(int); //; // (which should presumably be valid only if N is a multiple of; // alignof(int), and in any case can't be deallocated unless N is; // alignof(X) and X has new-extended alignment).",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp:45,Energy Efficiency,allocate,allocated,45,// -- its value is such that the size of the allocated object would; // exceed the implementation-defined limit,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp:24,Performance,perform,performed,24,// No initialization is performed.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp:3,Performance,Perform,Perform,3,// Perform the allocation and obtain a pointer to the resulting object.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp:4,Performance,Perform,Perform,4,"/// Perform zero-initialization on an object of non-union class type.; /// C++11 [dcl.init]p5:; /// To zero-initialize an object or reference of type T means:; /// [...]; /// -- if T is a (possibly cv-qualified) non-union class type,; /// each non-static data member and each base-class subobject is; /// zero-initialized",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp:53,Performance,perform,performed,53,"// -- if T is a reference type, no initialization is performed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp:3,Performance,Perform,Perform,3,// Perform an implicit value-initialization for members beyond the end of; // the initializer list.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp:20,Performance,perform,performed,20,"// If we've already performed zero-initialization, we're already done.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp:3,Safety,Avoid,Avoid,3,// Avoid materializing a temporary for an elidable copy/move constructor.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp:32,Usability,simpl,simplest,32,"// FIXME: This only handles the simplest case, where the source object; // is passed directly as the first argument to the constructor.; // This should also handle stepping though implicit casts and; // and conversion sequences which involve two steps, with a; // conversion operator followed by a converting constructor.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp:10,Performance,Perform,Perform,10,// FIXME: Perform the checks on the field types in SemaInit.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp:58,Availability,error,error,58,"// If there is no initializer, either this is a VLA or an error has; // occurred.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp:40,Modifiability,flexible,flexible,40,"// We can be asked to zero-initialize a flexible array member; this; // is represented as an ImplicitValueInitExpr of incomplete array; // type. In this case, the array has zero elements.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp:46,Integrability,depend,depend,46,// Return true iff the given array filler may depend on the element index.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp:28,Integrability,depend,depend,28,"// If the initializer might depend on the array index, run it for each; // array element.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp:200,Safety,avoid,avoid,200,"// We do the whole initialization in two passes, first for just one element,; // then for the whole array. It's possible we may find out we can't do const; // init in the first pass, in which case we avoid allocating a potentially; // large array. We don't do more passes because expanding array requires; // copying the data, which is wasteful.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp:77,Availability,error,error,77,// When checking for const initilization any diagnostic is considered; // an error.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp:413,Usability,simpl,simple,413,"// end anonymous namespace; /// EvaluateIntegerOrLValue - Evaluate an rvalue integral-typed expression, and; /// produce either the integer value or a pointer.; ///; /// GCC has a heinous extension which folds casts between pointer types and; /// pointer-sized integral types. We support this by allowing the evaluation of; /// an integer rvalue to produce a pointer (represented as an lvalue) instead.; /// Some simple arithmetic on such values is supported (they are treated much; /// like char*).",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp:42,Testability,assert,assertions,42,// Get rid of mismatch (otherwise Success assertions will fail); // by computing a new value matching the type of E.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp:92,Usability,simpl,simple,92,"// We only conservatively allow a few kinds of casts, because this code is; // inherently a simple solution that seeks to support the common case.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp:4,Testability,Test,Tests,4,"/// Tests to see if the LValue has a user-specified designator (that isn't; /// necessarily valid). Note that this always returns 'true' if the LValue has; /// an unsized array as its first designator entry, because there's currently no; /// way to tell if the user typed *foo or foo[0].",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp:16,Safety,detect,detect,16,/// Attempts to detect a user writing into a piece of memory that's impossible; /// to figure out the size of by just using types.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp:254,Modifiability,flexible,flexible,254,"// Notes:; // - Users can only write off of the end when we have an invalid base. Invalid; // bases imply we don't know where the memory came from.; // - We used to be a bit more aggressive here; we'd only be conservative if; // the array at the end was flexible, or if it had 0 or 1 elements. This; // broke some common standard library extensions (PR30346), but was; // otherwise seemingly fine. It may be useful to reintroduce this behavior; // with some sort of list. OTOH, it seems that GCC is always; // conservative with the last element in structs (if it's an array), so our; // current behavior is more compatible than an explicit list approach would; // be.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp:88,Modifiability,flexible,flexible,88,"/// If we're evaluating the object size of an instance of a struct that; /// contains a flexible array member, add the size of the initializer.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp:225,Integrability,depend,depending,225,"/// Helper for tryEvaluateBuiltinObjectSize -- Given an LValue, this will; /// determine how many bytes exist from the beginning of the object to either; /// the end of the current subobject, or the end of the object itself, depending; /// on what the LValue looks like + the value of Type.; ///; /// If this returns false, the value of Result is undefined.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp:192,Availability,failure,failure,192,"/// Tries to evaluate the __builtin_object_size for @p E. If successful,; /// returns true and stores the result in @p Size.; ///; /// If @p WasError is non-null, this will report whether the failure to evaluate; /// is to be treated as an Error in IntExprEvaluator.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp:240,Availability,Error,Error,240,"/// Tries to evaluate the __builtin_object_size for @p E. If successful,; /// returns true and stores the result in @p Size.; ///; /// If @p WasError is non-null, this will report whether the failure to evaluate; /// is to be treated as an Error in IntExprEvaluator.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp:63,Security,access,accessible,63,"// If we point to before the start of the object, there are no accessible; // bytes.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp:3,Energy Efficiency,Reduce,Reduce,3,// Reduce it to a constant now.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp:119,Availability,down,down,119,"// Otherwise we can't infer whether the value is sufficiently aligned.; // TODO: __builtin_is_aligned(__builtin_align_{down,up{(expr, N), N); // in cases where we can't fully evaluate the pointer.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp:105,Safety,avoid,avoid,105,"// Outside a constant context, eagerly evaluate to false in the presence; // of side-effects in order to avoid -Wunsequenced false-positives in; // a branch on __builtin_constant_p(expr).",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp:31,Safety,avoid,avoid,31,// FIXME: Find a better way to avoid duplicated diagnostics.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp:67,Energy Efficiency,power,power,67,"// For __atomic_is_lock_free(sizeof(_Atomic(T))), if the size is a power; // of two less than or equal to the maximum inline atomic width, we know it; // is lock-free. If the size isn't a power of two, or greater than the; // maximum alignment where we promote atomics, we know it is not lock-free; // (at least not in the sense of atomic_is_lock_free). Otherwise,; // the answer can only be determined at runtime; for example, 16-byte; // atomics have lock-free implementations on some, but not all,; // x86-64 processors.; // Check power-of-two.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp:188,Energy Efficiency,power,power,188,"// For __atomic_is_lock_free(sizeof(_Atomic(T))), if the size is a power; // of two less than or equal to the maximum inline atomic width, we know it; // is lock-free. If the size isn't a power of two, or greater than the; // maximum alignment where we promote atomics, we know it is not lock-free; // (at least not in the sense of atomic_is_lock_free). Otherwise,; // the answer can only be determined at runtime; for example, 16-byte; // atomics have lock-free implementations on some, but not all,; // x86-64 processors.; // Check power-of-two.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp:534,Energy Efficiency,power,power-of-two,534,"// For __atomic_is_lock_free(sizeof(_Atomic(T))), if the size is a power; // of two less than or equal to the maximum inline atomic width, we know it; // is lock-free. If the size isn't a power of two, or greater than the; // maximum alignment where we promote atomics, we know it is not lock-free; // (at least not in the sense of atomic_is_lock_free). Otherwise,; // the answer can only be determined at runtime; for example, 16-byte; // atomics have lock-free implementations on some, but not all,; // x86-64 processors.; // Check power-of-two.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp:141,Testability,log,logical,141,"/// True if \param E is a binary operator that we are going to handle; /// data recursively.; /// We handle binary operators that are comma, logical, or that have operands; /// with integral or enumeration type.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp:52,Integrability,wrap,wrapping,52,"// Compute the new offset in the appropriate width, wrapping at 64 bits.; // FIXME: When compiling for a 32-bit target, we should use 32-bit; // offsets.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp:102,Performance,perform,performing,102,"// Set up the width and signedness manually, in case it can't be deduced; // from the operation we're performing.; // FIXME: Don't do this in the cases where we can deduce it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp:272,Security,access,access,272,"// C++11 [expr.rel]p2:; // - If two pointers point to non-static data members of the same object,; // or to subobjects or array elements fo such members, recursively, the; // pointer to the later declared member compares greater provided the; // two members have the same access control and provided their class is; // not a union.; // [...]; // - Otherwise pointer comparisons are unspecified.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp:195,Security,access,access,195,"// At the point where the designators diverge, the comparison has a; // specified value if:; // - we are comparing array indices; // - we are comparing fields of a union, or fields with the same access; // Otherwise, the result is unspecified and thus the comparison is not a; // constant expression.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp:45,Performance,perform,performed,45,"// The comparison here must be unsigned, and performed with the same; // width as the pointer.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp:147,Integrability,depend,depends,147,"// If there is a base and this is a relational operator, we can only; // compare pointers within the object in question; otherwise, the result; // depends on where the object is located in memory.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp:95,Usability,clear,clear,95,"// FIXME: Should extension allow i-c-e extension expressions in its scope?; // If so, we could clear the diagnostic ID.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp:211,Safety,detect,detect,211,// Allow casts of address-of-label differences if they are no-ops; // or narrowing. (The narrowing case isn't actually guaranteed to; // be constant-evaluatable except in some narrow cases which are hard; // to detect here. We let it through on the assumption the user knows; // what they are doing.),MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp:222,Modifiability,variab,variable,222,// We know if we are here that we are in a context that we might require; // a constant expression or a context that requires a constant; // value. But if we are initializing a value we don't know if it is a; // constexpr variable or not. We can check the EvaluatingDecl to determine; // if it constexpr or not. If not then we don't want to emit a diagnostic.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp:146,Availability,down,down,146,"// Only allow based lvalue casts if they are lossless.; // FIXME: Allow a larger integer size than the pointer size, and allow; // narrowing back down to pointer width in subsequent integral casts.; // FIXME: Check integer type's active bits, not its type size.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp:99,Usability,simpl,simplify,99,// Track whether the LHS or RHS is real at the type system level. When this is; // the case we can simplify our evaluation strategy.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp:72,Availability,robust,robustly,72,"// In the fully general case, we need to handle NaNs and infinities; // robustly.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp:11,Performance,optimiz,optimizations,11,"// No real optimizations we can do here, stub out with zero.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp:41,Testability,stub,stub,41,"// No real optimizations we can do here, stub out with zero.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp:83,Integrability,wrap,wrapped,83,"// For atomic-qualified class (and array) types in C++, initialize the; // _Atomic-wrapped subobject directly, in-place.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp:182,Energy Efficiency,allocate,allocated,182,"// This is the only case where we need to produce an extension warning:; // the only other way we can succeed is if we find a dynamic allocation,; // and we will have warned when we allocated it in that case.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp:56,Performance,perform,performing,56,"/// EvaluateAsRValue - Try to evaluate this expression, performing an implicit; /// lvalue-to-rvalue cast if it is an lvalue.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp:293,Testability,test,test,293,"// C++23 [intro.execution]/p5; // A full-expression is ... an init-declarator ([dcl.decl]) or a; // mem-initializer.; // So we need to make sure temporary objects are destroyed after having; // evaluated the expression (per C++23 [class.temporary]/p4).; //; // FIXME: Otherwise this may break test/Modules/pr68702.cpp because the; // serialization code calls ParmVarDecl::getDefaultArg() which strips the; // outermost FullExpr, such as ExprWithCleanups.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp:31,Modifiability,extend,extended,31,"// At this point, any lifetime-extended temporaries are completely; // initialized.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp:110,Usability,usab,usable,110,// Only treat the destruction as constant destruction if we formally have; // constant initialization (or are usable in a constant expression).,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp:470,Energy Efficiency,reduce,reduce,470,"/// isIntegerConstantExpr - this recursive routine will test if an expression is; /// an integer constant expression.; /// FIXME: Pass up a reason why! Invalid operation in i-c-e, division by zero,; /// comma, etc; // CheckICE - This function does the fundamental ICE checking: the returned; // ICEDiag contains an ICEKind indicating whether the expression is an ICE,; // and a (possibly null) SourceLocation indicating the location of the problem.; //; // Note that to reduce code duplication, this helper does no evaluation; // itself; the caller checks whether the expression is evaluatable, and; // in the rare cases where CheckICE actually cares about the evaluated; // value, it calls into Evaluate.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp:43,Integrability,rout,routine,43,"/// isIntegerConstantExpr - this recursive routine will test if an expression is; /// an integer constant expression.; /// FIXME: Pass up a reason why! Invalid operation in i-c-e, division by zero,; /// comma, etc; // CheckICE - This function does the fundamental ICE checking: the returned; // ICEDiag contains an ICEKind indicating whether the expression is an ICE,; // and a (possibly null) SourceLocation indicating the location of the problem.; //; // Note that to reduce code duplication, this helper does no evaluation; // itself; the caller checks whether the expression is evaluatable, and; // in the rare cases where CheckICE actually cares about the evaluated; // value, it calls into Evaluate.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp:56,Testability,test,test,56,"/// isIntegerConstantExpr - this recursive routine will test if an expression is; /// an integer constant expression.; /// FIXME: Pass up a reason why! Invalid operation in i-c-e, division by zero,; /// comma, etc; // CheckICE - This function does the fundamental ICE checking: the returned; // ICEDiag contains an ICEKind indicating whether the expression is an ICE,; // and a (possibly null) SourceLocation indicating the location of the problem.; //; // Note that to reduce code duplication, this helper does no evaluation; // itself; the caller checks whether the expression is evaluatable, and; // in the rare cases where CheckICE actually cares about the evaluated; // value, it calls into Evaluate.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp:85,Modifiability,variab,variables,85,"// C++ and OpenCL (FIXME: spec reference?) allow reading const-qualified; // integer variables in constant expressions:; //; // C++ 7.1.5.1p2; // A variable of non-volatile const-qualified integral or enumeration; // type initialized by an ICE can be used in ICEs.; //; // We sometimes use CheckICE to check the C++98 rules in C++11 mode. In; // that mode, use of reference variables should not be allowed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp:148,Modifiability,variab,variable,148,"// C++ and OpenCL (FIXME: spec reference?) allow reading const-qualified; // integer variables in constant expressions:; //; // C++ 7.1.5.1p2; // A variable of non-volatile const-qualified integral or enumeration; // type initialized by an ICE can be used in ICEs.; //; // We sometimes use CheckICE to check the C++98 rules in C++11 mode. In; // that mode, use of reference variables should not be allowed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp:374,Modifiability,variab,variables,374,"// C++ and OpenCL (FIXME: spec reference?) allow reading const-qualified; // integer variables in constant expressions:; //; // C++ 7.1.5.1p2; // A variable of non-volatile const-qualified integral or enumeration; // type initialized by an ICE can be used in ICEs.; //; // We sometimes use CheckICE to check the C++98 rules in C++11 mode. In; // that mode, use of reference variables should not be allowed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp:29,Availability,error,error,29,"// EvaluateAsRValue gives an error for undefined Div/Rem, so make sure; // we don't evaluate one.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp:35,Integrability,depend,depend,35,"// Rare case where the diagnostics depend on which side is evaluated; // Note that if we get here, CondResult is 0, and at least one of; // TrueResult and FalseResult is non-zero.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp:43,Integrability,depend,dependent,43,// Expression evaluator can't succeed on a dependent expression.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp:61,Safety,safe,safe,61,// Ignore any side-effects from a failed evaluation. This is safe because; // they can't interfere with any other argument evaluation.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp:61,Safety,safe,safe,61,// Ignore any side-effects from a failed evaluation. This is safe because; // they can't interfere with any other argument evaluation.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp:186,Integrability,depend,dependent,186,"// FIXME: It would be useful to check constexpr function templates, but at the; // moment the constant expression evaluator cannot cope with the non-rigorous; // ASTs which we build for dependent expressions.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprCXX.cpp:61,Modifiability,rewrite,rewrite,61,// Remove an outer '!' if it exists (only happens for a '!=' rewrite).,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprCXX.cpp:29,Modifiability,rewrite,rewrite,29,"// If this isn't a spaceship rewrite, we're done.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprCXX.cpp:98,Modifiability,polymorphi,polymorphic,98,"// C++11 [expr.typeid]p3:; // When typeid is applied to an expression other than a glvalue of; // polymorphic class type, [...] the expression is an unevaluated operand.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprCXX.cpp:53,Integrability,depend,dependent,53,// The type-to-delete may not be a pointer if it's a dependent type.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprCXX.cpp:3,Integrability,Depend,DependentScopeDeclRefExpr,3,// DependentScopeDeclRefExpr,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprCXX.cpp:3,Energy Efficiency,Allocate,Allocate,3,// Allocate storage for the trailing objects of CallExpr.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprCXX.cpp:3,Energy Efficiency,Allocate,Allocate,3,// Allocate storage for the trailing objects of CallExpr.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprCXX.cpp:3,Energy Efficiency,Allocate,Allocate,3,// Allocate storage for the trailing objects of CallExpr.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprCXX.cpp:3,Energy Efficiency,Allocate,Allocate,3,// Allocate storage for the trailing objects of CallExpr.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprCXX.cpp:71,Deployability,Update,Update,71,// FIXME: Will eventually need to cope with member pointers.; // NOTE: Update makeTailCallIfSwiftAsync on fixing this.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprCXX.cpp:3,Energy Efficiency,Allocate,Allocate,3,// Allocate storage for the trailing objects of CallExpr.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprCXX.cpp:3,Energy Efficiency,Allocate,Allocate,3,// Allocate storage for the trailing objects of CallExpr.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprCXX.cpp:3,Integrability,Depend,Dependent,3,// Dependent,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprCXX.cpp:156,Integrability,depend,dependent,156,"// Unlike for UnresolvedLookupExpr, it is very easy to re-derive this.; // If there was a nested name specifier, it names the naming class.; // It can't be dependent: after all, we were actually able to do the; // lookup.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprCXX.cpp:18,Energy Efficiency,allocate,allocate,18,// We may need to allocate extra storage for the mangling number and the; // extended-by ValueDecl.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprCXX.cpp:77,Modifiability,extend,extended-by,77,// We may need to allocate extra storage for the mangling number and the; // extended-by ValueDecl.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprCXX.cpp:191,Modifiability,extend,extended,191,// C++20 [expr.const]p4:; // An object or reference is usable in constant expressions if it is [...]; // a temporary object of non-volatile const-qualified literal type; // whose lifetime is extended to that of a variable that is usable; // in constant expressions,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprCXX.cpp:213,Modifiability,variab,variable,213,// C++20 [expr.const]p4:; // An object or reference is usable in constant expressions if it is [...]; // a temporary object of non-volatile const-qualified literal type; // whose lifetime is extended to that of a variable that is usable; // in constant expressions,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprCXX.cpp:55,Usability,usab,usable,55,// C++20 [expr.const]p4:; // An object or reference is usable in constant expressions if it is [...]; // a temporary object of non-volatile const-qualified literal type; // whose lifetime is extended to that of a variable that is usable; // in constant expressions,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprCXX.cpp:230,Usability,usab,usable,230,// C++20 [expr.const]p4:; // An object or reference is usable in constant expressions if it is [...]; // a temporary object of non-volatile const-qualified literal type; // whose lifetime is extended to that of a variable that is usable; // in constant expressions,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprCXX.cpp:3,Energy Efficiency,Allocate,Allocate,3,// Allocate storage for the trailing objects of CallExpr.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprCXX.cpp:3,Energy Efficiency,Allocate,Allocate,3,// Allocate storage for the trailing objects of CallExpr.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExternalASTMerger.cpp:52,Integrability,Interface,Interface,52,"//===- ExternalASTMerger.cpp - Merging External AST Interface ---*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements the ExternalASTMerger, which vends a combination of; // ASTs from several different ASTContext/FileManager pairs; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ExternalASTMerger.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExternalASTMerger.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExternalASTMerger.cpp:52,Performance,perform,perform,52,"/// For the given DC, return the DC that is safe to perform lookups on. This is; /// the DC we actually want to work with most of the time.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ExternalASTMerger.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExternalASTMerger.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExternalASTMerger.cpp:44,Safety,safe,safe,44,"/// For the given DC, return the DC that is safe to perform lookups on. This is; /// the DC we actually want to work with most of the time.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ExternalASTMerger.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExternalASTMerger.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExternalASTMerger.cpp:490,Deployability,update,updates,490,"/// A custom implementation of ASTImporter, for ExternalASTMerger's purposes.; ///; /// There are several modifications:; ///; /// - It enables lazy lookup (via the HasExternalLexicalStorage flag and a few; /// others), which instructs Clang to refer to ExternalASTMerger. Also, it; /// forces MinimalImport to true, which is necessary to make this work.; /// - It maintains a reverse importer for use with names. This allows lookup of; /// arbitrary names in the source context.; /// - It updates the ExternalASTMerger's origin map as needed whenever a; /// it sees a DeclContext.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ExternalASTMerger.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExternalASTMerger.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExternalASTMerger.cpp:617,Safety,safe,safely,617,"// If we get here, then this source is importing from a temporary ASTContext; // that also has another ExternalASTMerger attached. It could be; // possible that the current ExternalASTMerger and the temporary ASTContext; // share a common ImporterSource, which means that the temporary; // AST could contain declarations that were imported from a source; // that this ExternalASTMerger can access directly. Instead of importing; // such declarations from the temporary ASTContext, they should instead; // be directly imported by this ExternalASTMerger from the original; // source. This way the ExternalASTMerger can safely do a minimal import; // without creating incomplete declarations originated from a temporary; // ASTContext. If we would try to complete such declarations later on, we; // would fail to do so as their temporary AST could be deleted (which means; // that the missing parts of the minimally imported declaration in that; // ASTContext were also deleted).; //; // The following code tracks back any declaration that needs to be; // imported from the temporary ASTContext to a persistent ASTContext.; // Then the ExternalASTMerger tries to import from the persistent; // ASTContext directly by using the associated ASTImporter. If that; // succeeds, this ASTImporter just maps the declarations imported by; // the other (persistent) ASTImporter to this (temporary) ASTImporter.; // The steps can be visualized like this:; //; // Target AST <--- 3. Indirect import --- Persistent AST; // ^ of persistent decl ^; // | |; // 1. Current import 2. Tracking back to persistent decl; // 4. Map persistent decl |; // & pretend we imported. |; // | |; // Temporary AST -------------------------------'; // First, ask the ExternalASTMerger of the source where the temporary; // declaration originated from.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ExternalASTMerger.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExternalASTMerger.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExternalASTMerger.cpp:390,Security,access,access,390,"// If we get here, then this source is importing from a temporary ASTContext; // that also has another ExternalASTMerger attached. It could be; // possible that the current ExternalASTMerger and the temporary ASTContext; // share a common ImporterSource, which means that the temporary; // AST could contain declarations that were imported from a source; // that this ExternalASTMerger can access directly. Instead of importing; // such declarations from the temporary ASTContext, they should instead; // be directly imported by this ExternalASTMerger from the original; // source. This way the ExternalASTMerger can safely do a minimal import; // without creating incomplete declarations originated from a temporary; // ASTContext. If we would try to complete such declarations later on, we; // would fail to do so as their temporary AST could be deleted (which means; // that the missing parts of the minimally imported declaration in that; // ASTContext were also deleted).; //; // The following code tracks back any declaration that needs to be; // imported from the temporary ASTContext to a persistent ASTContext.; // Then the ExternalASTMerger tries to import from the persistent; // ASTContext directly by using the associated ASTImporter. If that; // succeeds, this ASTImporter just maps the declarations imported by; // the other (persistent) ASTImporter to this (temporary) ASTImporter.; // The steps can be visualized like this:; //; // Target AST <--- 3. Indirect import --- Persistent AST; // ^ of persistent decl ^; // | |; // 1. Current import 2. Tracking back to persistent decl; // 4. Map persistent decl |; // & pretend we imported. |; // | |; // Temporary AST -------------------------------'; // First, ask the ExternalASTMerger of the source where the temporary; // declaration originated from.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ExternalASTMerger.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExternalASTMerger.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExternalASTMerger.cpp:3,Availability,Error,Errors,3,// Errors when importing the persistent decl are treated as if we; // had errors with importing the temporary decl.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ExternalASTMerger.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExternalASTMerger.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExternalASTMerger.cpp:74,Availability,error,errors,74,// Errors when importing the persistent decl are treated as if we; // had errors with importing the temporary decl.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ExternalASTMerger.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExternalASTMerger.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExternalASTMerger.cpp:31,Integrability,interface,interface,31,/// Implements the ASTImporter interface for tracking back a declaration; /// to its original declaration it came from.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ExternalASTMerger.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExternalASTMerger.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExternalASTMerger.cpp:51,Availability,avail,available,51,"// If we don't import specialization, they are not available via lookup; // because the lookup result is imported TemplateDecl and it does not; // reference its specializations until they are imported explicitly.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ExternalASTMerger.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExternalASTMerger.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExternalASTSource.cpp:53,Integrability,Interface,Interface,53,"//===- ExternalASTSource.cpp - Abstract External AST Interface ------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file provides the default implementation of the ExternalASTSource; // interface, which enables construction of AST nodes from some external; // source.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ExternalASTSource.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExternalASTSource.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExternalASTSource.cpp:458,Integrability,interface,interface,458,"//===- ExternalASTSource.cpp - Abstract External AST Interface ------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file provides the default implementation of the ExternalASTSource; // interface, which enables construction of AST nodes from some external; // source.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ExternalASTSource.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExternalASTSource.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/FormatString.cpp:3,Deployability,Update,Update,3,// Update the caller's pointer if we decided to consume; // these characters.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/FormatString.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/FormatString.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/FormatString.cpp:150,Deployability,update,updated,150,"// If the invalid specifier is a multibyte UTF-8 string, return the; // total length accordingly so that the conversion specifier can be; // properly updated to reflect a complete UTF-8 specifier.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/FormatString.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/FormatString.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/FormatString.cpp:29,Integrability,bridg,bridging,29,// Handle implicit toll-free bridging.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/FormatString.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/FormatString.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/FormatString.cpp:117,Integrability,bridg,bridged,117,"// Things such as CFTypeRef are really just opaque pointers; // to C structs representing CF types that can often be bridged; // to Objective-C objects. Since the compiler doesn't know which; // structs can be toll-free bridged, we just accept them all.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/FormatString.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/FormatString.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/FormatString.cpp:220,Integrability,bridg,bridged,220,"// Things such as CFTypeRef are really just opaque pointers; // to C structs representing CF types that can often be bridged; // to Objective-C objects. Since the compiler doesn't know which; // structs can be toll-free bridged, we just accept them all.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/FormatString.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/FormatString.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/FormatStringParsing.h:52,Deployability,install,installed,52,"/// Returns true if a LengthModifier was parsed and installed in the; /// FormatSpecifier& argument, and false otherwise.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/FormatStringParsing.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/FormatStringParsing.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/InheritViz.cpp:7,Modifiability,Inherit,InheritViz,7,"//===- InheritViz.cpp - Graphviz visualization for inheritance --*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements CXXRecordDecl::viewInheritance, which; // generates a GraphViz DOT file that depicts the class inheritance; // diagram and then calls Graphviz/dot+gv on it.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/InheritViz.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/InheritViz.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/InheritViz.cpp:51,Modifiability,inherit,inheritance,51,"//===- InheritViz.cpp - Graphviz visualization for inheritance --*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements CXXRecordDecl::viewInheritance, which; // generates a GraphViz DOT file that depicts the class inheritance; // diagram and then calls Graphviz/dot+gv on it.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/InheritViz.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/InheritViz.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/InheritViz.cpp:499,Modifiability,inherit,inheritance,499,"//===- InheritViz.cpp - Graphviz visualization for inheritance --*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements CXXRecordDecl::viewInheritance, which; // generates a GraphViz DOT file that depicts the class inheritance; // diagram and then calls Graphviz/dot+gv on it.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/InheritViz.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/InheritViz.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/InheritViz.cpp:225,Integrability,interface,interface,225,"/// InheritanceHierarchyWriter - Helper class that writes out a; /// GraphViz file that diagrams the inheritance hierarchy starting at; /// a given C++ class type. Note that we do not use LLVM's; /// GraphWriter, because the interface does not permit us to properly; /// differentiate between uses of types as virtual bases; /// vs. non-virtual bases.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/InheritViz.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/InheritViz.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/InheritViz.cpp:4,Modifiability,Inherit,InheritanceHierarchyWriter,4,"/// InheritanceHierarchyWriter - Helper class that writes out a; /// GraphViz file that diagrams the inheritance hierarchy starting at; /// a given C++ class type. Note that we do not use LLVM's; /// GraphWriter, because the interface does not permit us to properly; /// differentiate between uses of types as virtual bases; /// vs. non-virtual bases.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/InheritViz.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/InheritViz.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/InheritViz.cpp:101,Modifiability,inherit,inheritance,101,"/// InheritanceHierarchyWriter - Helper class that writes out a; /// GraphViz file that diagrams the inheritance hierarchy starting at; /// a given C++ class type. Note that we do not use LLVM's; /// GraphWriter, because the interface does not permit us to properly; /// differentiate between uses of types as virtual bases; /// vs. non-virtual bases.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/InheritViz.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/InheritViz.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/InheritViz.cpp:57,Modifiability,inherit,inheritance,57,"/// WriteNode - Write out the description of node in the inheritance; /// diagram, which may be a base class or it may be the root node.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/InheritViz.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/InheritViz.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/InheritViz.cpp:26,Modifiability,inherit,inheritance,26,"// If this is not virtual inheritance, bump the direct base; // count for the type.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/InheritViz.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/InheritViz.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/InheritViz.cpp:49,Modifiability,inherit,inheritance,49,// Write out edge attributes to show the kind of inheritance.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/InheritViz.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/InheritViz.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/InheritViz.cpp:34,Modifiability,inherit,inheritance,34,/// viewInheritance - Display the inheritance hierarchy of this C++; /// class using GraphViz.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/InheritViz.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/InheritViz.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ItaniumCXXABI.cpp:4,Modifiability,Variab,Variable,4,/// Variable decls are numbered by identifier.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ItaniumCXXABI.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ItaniumCXXABI.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ItaniumMangle.cpp:213,Modifiability,variab,variable,213,"/// In the ""DisableDerivedAbiTags"" mode derived ABI tags are not calculated.; /// This mode is used when mangler creates another mangler recursively to; /// calculate ABI tags for the function return value or the variable type.; /// Also it is required to avoid infinite recursion in some cases.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ItaniumMangle.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ItaniumMangle.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ItaniumMangle.cpp:256,Safety,avoid,avoid,256,"/// In the ""DisableDerivedAbiTags"" mode derived ABI tags are not calculated.; /// This mode is used when mangler creates another mangler recursively to; /// calculate ABI tags for the function return value or the variable type.; /// Also it is required to avoid infinite recursion in some cases.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ItaniumMangle.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ItaniumMangle.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ItaniumMangle.cpp:3,Performance,Perform,Perform,3,// Perform the same check for block literals.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ItaniumMangle.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ItaniumMangle.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ItaniumMangle.cpp:49,Usability,simpl,simple,49,// C++ functions and those whose names are not a simple identifier need; // mangling.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ItaniumMangle.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ItaniumMangle.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ItaniumMangle.cpp:5,Modifiability,variab,variables,5,// C variables are not mangled.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ItaniumMangle.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ItaniumMangle.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ItaniumMangle.cpp:3,Modifiability,Variab,Variables,3,// Variables at global scope are not mangled unless they have internal; // linkage or are specializations or are attached to a named module.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ItaniumMangle.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ItaniumMangle.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ItaniumMangle.cpp:20,Modifiability,variab,variable,20,// Check for extern variable declared locally.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ItaniumMangle.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ItaniumMangle.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ItaniumMangle.cpp:42,Usability,simpl,simplest,42,"// There are no tags for return type, the simplest case. Enter the function; // parameter scope before mangling the name, because a template using; // constrained `auto` can have references to its parameters within its; // template argument list:; //; // template<typename T> void f(T x, C<decltype(x)> auto); // ... is mangled as ...; // template<typename T, C<decltype(param 1)> U> void f(T, U)",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ItaniumMangle.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ItaniumMangle.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ItaniumMangle.cpp:20,Modifiability,inherit,inheriting,20,"// When mangling an inheriting constructor, the bare function type used is; // that of the inherited constructor.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ItaniumMangle.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ItaniumMangle.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ItaniumMangle.cpp:91,Modifiability,inherit,inherited,91,"// When mangling an inheriting constructor, the bare function type used is; // that of the inherited constructor.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ItaniumMangle.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ItaniumMangle.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ItaniumMangle.cpp:68,Integrability,depend,depends,68,"// Whether the mangling of a function type includes the return type depends on; // the context and the nature of the function. The rules for deciding whether; // the return type is included are:; //; // 1. Template functions (names or types) have return types encoded, with; // the exceptions listed below.; // 2. Function types not appearing as part of a function name mangling,; // e.g. parameters, pointer types, etc., have return type encoded, with the; // exceptions listed below.; // 3. Non-template function names do not have return types encoded.; //; // The exceptions mentioned in (1) and (2) above, for which the return type is; // never included, are; // 1. Constructors.; // 2. Destructors.; // 3. Conversion operator functions, e.g. operator int.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ItaniumMangle.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ItaniumMangle.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ItaniumMangle.cpp:22,Modifiability,variab,variable,22,// Check if we have a variable template.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ItaniumMangle.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ItaniumMangle.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ItaniumMangle.cpp:3,Modifiability,Variab,Variables,3,// Variables should have implicit tags from its type.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ItaniumMangle.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ItaniumMangle.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ItaniumMangle.cpp:18,Modifiability,variab,variable,18,// Simple case no variable type tags.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ItaniumMangle.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ItaniumMangle.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ItaniumMangle.cpp:3,Usability,Simpl,Simple,3,// Simple case no variable type tags.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ItaniumMangle.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ItaniumMangle.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ItaniumMangle.cpp:10,Modifiability,variab,variable,10,// Mangle variable name to null stream to collect tags.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ItaniumMangle.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ItaniumMangle.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ItaniumMangle.cpp:17,Modifiability,variab,variable,17,// Get tags from variable type that are not present in its name.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ItaniumMangle.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ItaniumMangle.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ItaniumMangle.cpp:24,Modifiability,variab,variable,24,"// If this is an extern variable declared locally, the relevant DeclContext; // is that of the containing namespace, or the translation unit.; // FIXME: This is a hack; extern variables declared locally should have; // a proper semantic declaration context!",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ItaniumMangle.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ItaniumMangle.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ItaniumMangle.cpp:176,Modifiability,variab,variables,176,"// If this is an extern variable declared locally, the relevant DeclContext; // is that of the containing namespace, or the translation unit.; // FIXME: This is a hack; extern variables declared locally should have; // a proper semantic declaration context!",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ItaniumMangle.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ItaniumMangle.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ItaniumMangle.cpp:3,Energy Efficiency,Allocate,Allocate,3,// Allocate a buffer of the right number of characters.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ItaniumMangle.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ItaniumMangle.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ItaniumMangle.cpp:102,Integrability,depend,dependent,102,// FIXME: GCC does not appear to mangle the template arguments when; // the template in question is a dependent template name. Should we; // emulate that badness?,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ItaniumMangle.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ItaniumMangle.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ItaniumMangle.cpp:102,Integrability,depend,dependent,102,// FIXME: GCC does not appear to mangle the template arguments when; // the template in question is a dependent template name. Should we; // emulate that badness?,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ItaniumMangle.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ItaniumMangle.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ItaniumMangle.cpp:31,Usability,simpl,simple-id,31,// <base-unresolved-name> ::= <simple-id>,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ItaniumMangle.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ItaniumMangle.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ItaniumMangle.cpp:8,Usability,simpl,simple-id,8,// The <simple-id> and on <operator-name> productions end in an optional; // <template-args>.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ItaniumMangle.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ItaniumMangle.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ItaniumMangle.cpp:64,Modifiability,variab,variables,64,// We follow MSVC in mangling GUID declarations as if they were variables; // with a particular reserved name. Continue the pretense here.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ItaniumMangle.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ItaniumMangle.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ItaniumMangle.cpp:30,Usability,GUID,GUID,30,// We follow MSVC in mangling GUID declarations as if they were variables; // with a particular reserved name. Continue the pretense here.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ItaniumMangle.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ItaniumMangle.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ItaniumMangle.cpp:298,Testability,test,test,298,"// Match GCC's naming convention for internal linkage symbols, for; // symbols that are not actually visible outside of this TU. GCC; // distinguishes between internal and external linkage symbols in; // its mangling, to support cases like this that were valid C++ prior; // to DR426:; //; // void test() { extern void foo(); }; // static void foo();; //; // Don't bother with the L marker for names in anonymous namespaces; the; // 12_GLOBAL__N_1 mangling is quite sufficient there, and this better; // matches GCC anyway, because GCC does not treat anonymous namespaces as; // implying internal linkage.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ItaniumMangle.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ItaniumMangle.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ItaniumMangle.cpp:321,Safety,safe,safety,321,"// Class extensions have no name as a category, and it's possible; // for them to be the semantic parent of certain declarations; // (primarily, tag decls defined within declarations). Such; // declarations will always have internal linkage, so the name; // doesn't really matter, but we shouldn't crash on them. For; // safety, just handle all ObjC containers here.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ItaniumMangle.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ItaniumMangle.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ItaniumMangle.cpp:35,Modifiability,variab,variable,35,"// A <closure-prefix> represents a variable or field, not a regular; // DeclContext, so needs special handling. In this case we're mangling a; // limited form of <nested-name>:; //; // <nested-name> ::= N <closure-prefix> <closure-type-name> E",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ItaniumMangle.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ItaniumMangle.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ItaniumMangle.cpp:46,Availability,avail,available,46,"// Implicit ABI tags (from namespace) are not available in the following; // entity; reset to actually emitted tags, which are available.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ItaniumMangle.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ItaniumMangle.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ItaniumMangle.cpp:127,Availability,avail,available,127,"// Implicit ABI tags (from namespace) are not available in the following; // entity; reset to actually emitted tags, which are available.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ItaniumMangle.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ItaniumMangle.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ItaniumMangle.cpp:54,Integrability,depend,dependent,54,// Clang 11 and before mangled the substitution for a dependent template name; // after already having emitted (a substitution for) the prefix.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ItaniumMangle.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ItaniumMangle.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ItaniumMangle.cpp:54,Modifiability,variab,variable,54,// Only lambdas within the initializer of a non-local variable or non-static; // data member get a <closure-prefix>.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ItaniumMangle.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ItaniumMangle.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ItaniumMangle.cpp:14,Usability,clear,clear,14,"// FIXME: not clear how to mangle this!; // template <template <class> class T...> class A {; // template <template <class> class U...> void foo(B<T,U> x...);; // };",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ItaniumMangle.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ItaniumMangle.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ItaniumMangle.cpp:14,Usability,clear,clear,14,// FIXME: not clear how to mangle this!; // template <class T...> class A {; // template <class U...> void foo(decltype(T::foo(U())) x...);; // };,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ItaniumMangle.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ItaniumMangle.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ItaniumMangle.cpp:14,Usability,clear,clear,14,// FIXME: not clear how to mangle this!; // template <template <class U> class T...> class A {; // template <class U...> void foo(decltype(T<U>::foo) x...);; // };,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ItaniumMangle.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ItaniumMangle.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ItaniumMangle.cpp:250,Safety,safe,safe,250,"// The __unsafe_unretained qualifier is *not* mangled, so that; // __unsafe_unretained types in ARC produce the same manglings as the; // equivalent (but, naturally, unqualified) types in non-ARC, providing; // better ABI compatibility.; //; // It's safe to do this because unqualified 'id' won't show up; // in any type signatures that need to be mangled.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ItaniumMangle.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ItaniumMangle.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ItaniumMangle.cpp:32,Integrability,depend,dependent,32,"// If our type is instantiation-dependent but not dependent, we mangle; // it as it was written in the source, removing any top-level sugar.; // Otherwise, use the canonical type.; //; // FIXME: This is an approximation of the instantiation-dependent name; // mangling rules, since we should really be using the type as written and; // augmented via semantic analysis (i.e., with implicit conversions and; // default template arguments) for any instantiation-dependent type.; // Unfortunately, that requires several changes to our AST:; // - Instantiation-dependent TemplateSpecializationTypes will need to be; // uniqued, so that we can handle substitutions properly; // - Default template arguments will need to be represented in the; // TemplateSpecializationType, since they need to be mangled even though; // they aren't written.; // - Conversions on non-type template arguments need to be expressed, since; // they can affect the mangling of sizeof/alignof.; //; // FIXME: This is wrong when mapping to the canonical type for a dependent; // type discards instantiation-dependent portions of the type, such as for:; //; // template<typename T, int N> void f(T (&)[sizeof(N)]);; // template<typename T> void f(T() throw(typename T::type)); (pre-C++17); //; // It's also wrong in the opposite direction when instantiation-dependent,; // canonically-equivalent types differ in some irrelevant portion of inner; // type sugar. In such cases, we fail to form correct substitutions, eg:; //; // template<int N> void f(A<sizeof(N)> *, A<sizeof(N)> (*));; //; // We should instead canonicalize the non-instantiation-dependent parts,; // regardless of whether the type as a whole is dependent or instantiation; // dependent.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ItaniumMangle.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ItaniumMangle.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ItaniumMangle.cpp:50,Integrability,depend,dependent,50,"// If our type is instantiation-dependent but not dependent, we mangle; // it as it was written in the source, removing any top-level sugar.; // Otherwise, use the canonical type.; //; // FIXME: This is an approximation of the instantiation-dependent name; // mangling rules, since we should really be using the type as written and; // augmented via semantic analysis (i.e., with implicit conversions and; // default template arguments) for any instantiation-dependent type.; // Unfortunately, that requires several changes to our AST:; // - Instantiation-dependent TemplateSpecializationTypes will need to be; // uniqued, so that we can handle substitutions properly; // - Default template arguments will need to be represented in the; // TemplateSpecializationType, since they need to be mangled even though; // they aren't written.; // - Conversions on non-type template arguments need to be expressed, since; // they can affect the mangling of sizeof/alignof.; //; // FIXME: This is wrong when mapping to the canonical type for a dependent; // type discards instantiation-dependent portions of the type, such as for:; //; // template<typename T, int N> void f(T (&)[sizeof(N)]);; // template<typename T> void f(T() throw(typename T::type)); (pre-C++17); //; // It's also wrong in the opposite direction when instantiation-dependent,; // canonically-equivalent types differ in some irrelevant portion of inner; // type sugar. In such cases, we fail to form correct substitutions, eg:; //; // template<int N> void f(A<sizeof(N)> *, A<sizeof(N)> (*));; //; // We should instead canonicalize the non-instantiation-dependent parts,; // regardless of whether the type as a whole is dependent or instantiation; // dependent.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ItaniumMangle.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ItaniumMangle.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ItaniumMangle.cpp:241,Integrability,depend,dependent,241,"// If our type is instantiation-dependent but not dependent, we mangle; // it as it was written in the source, removing any top-level sugar.; // Otherwise, use the canonical type.; //; // FIXME: This is an approximation of the instantiation-dependent name; // mangling rules, since we should really be using the type as written and; // augmented via semantic analysis (i.e., with implicit conversions and; // default template arguments) for any instantiation-dependent type.; // Unfortunately, that requires several changes to our AST:; // - Instantiation-dependent TemplateSpecializationTypes will need to be; // uniqued, so that we can handle substitutions properly; // - Default template arguments will need to be represented in the; // TemplateSpecializationType, since they need to be mangled even though; // they aren't written.; // - Conversions on non-type template arguments need to be expressed, since; // they can affect the mangling of sizeof/alignof.; //; // FIXME: This is wrong when mapping to the canonical type for a dependent; // type discards instantiation-dependent portions of the type, such as for:; //; // template<typename T, int N> void f(T (&)[sizeof(N)]);; // template<typename T> void f(T() throw(typename T::type)); (pre-C++17); //; // It's also wrong in the opposite direction when instantiation-dependent,; // canonically-equivalent types differ in some irrelevant portion of inner; // type sugar. In such cases, we fail to form correct substitutions, eg:; //; // template<int N> void f(A<sizeof(N)> *, A<sizeof(N)> (*));; //; // We should instead canonicalize the non-instantiation-dependent parts,; // regardless of whether the type as a whole is dependent or instantiation; // dependent.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ItaniumMangle.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ItaniumMangle.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ItaniumMangle.cpp:459,Integrability,depend,dependent,459,"// If our type is instantiation-dependent but not dependent, we mangle; // it as it was written in the source, removing any top-level sugar.; // Otherwise, use the canonical type.; //; // FIXME: This is an approximation of the instantiation-dependent name; // mangling rules, since we should really be using the type as written and; // augmented via semantic analysis (i.e., with implicit conversions and; // default template arguments) for any instantiation-dependent type.; // Unfortunately, that requires several changes to our AST:; // - Instantiation-dependent TemplateSpecializationTypes will need to be; // uniqued, so that we can handle substitutions properly; // - Default template arguments will need to be represented in the; // TemplateSpecializationType, since they need to be mangled even though; // they aren't written.; // - Conversions on non-type template arguments need to be expressed, since; // they can affect the mangling of sizeof/alignof.; //; // FIXME: This is wrong when mapping to the canonical type for a dependent; // type discards instantiation-dependent portions of the type, such as for:; //; // template<typename T, int N> void f(T (&)[sizeof(N)]);; // template<typename T> void f(T() throw(typename T::type)); (pre-C++17); //; // It's also wrong in the opposite direction when instantiation-dependent,; // canonically-equivalent types differ in some irrelevant portion of inner; // type sugar. In such cases, we fail to form correct substitutions, eg:; //; // template<int N> void f(A<sizeof(N)> *, A<sizeof(N)> (*));; //; // We should instead canonicalize the non-instantiation-dependent parts,; // regardless of whether the type as a whole is dependent or instantiation; // dependent.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ItaniumMangle.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ItaniumMangle.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ItaniumMangle.cpp:556,Integrability,depend,dependent,556,"// If our type is instantiation-dependent but not dependent, we mangle; // it as it was written in the source, removing any top-level sugar.; // Otherwise, use the canonical type.; //; // FIXME: This is an approximation of the instantiation-dependent name; // mangling rules, since we should really be using the type as written and; // augmented via semantic analysis (i.e., with implicit conversions and; // default template arguments) for any instantiation-dependent type.; // Unfortunately, that requires several changes to our AST:; // - Instantiation-dependent TemplateSpecializationTypes will need to be; // uniqued, so that we can handle substitutions properly; // - Default template arguments will need to be represented in the; // TemplateSpecializationType, since they need to be mangled even though; // they aren't written.; // - Conversions on non-type template arguments need to be expressed, since; // they can affect the mangling of sizeof/alignof.; //; // FIXME: This is wrong when mapping to the canonical type for a dependent; // type discards instantiation-dependent portions of the type, such as for:; //; // template<typename T, int N> void f(T (&)[sizeof(N)]);; // template<typename T> void f(T() throw(typename T::type)); (pre-C++17); //; // It's also wrong in the opposite direction when instantiation-dependent,; // canonically-equivalent types differ in some irrelevant portion of inner; // type sugar. In such cases, we fail to form correct substitutions, eg:; //; // template<int N> void f(A<sizeof(N)> *, A<sizeof(N)> (*));; //; // We should instead canonicalize the non-instantiation-dependent parts,; // regardless of whether the type as a whole is dependent or instantiation; // dependent.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ItaniumMangle.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ItaniumMangle.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ItaniumMangle.cpp:1034,Integrability,depend,dependent,1034,"// If our type is instantiation-dependent but not dependent, we mangle; // it as it was written in the source, removing any top-level sugar.; // Otherwise, use the canonical type.; //; // FIXME: This is an approximation of the instantiation-dependent name; // mangling rules, since we should really be using the type as written and; // augmented via semantic analysis (i.e., with implicit conversions and; // default template arguments) for any instantiation-dependent type.; // Unfortunately, that requires several changes to our AST:; // - Instantiation-dependent TemplateSpecializationTypes will need to be; // uniqued, so that we can handle substitutions properly; // - Default template arguments will need to be represented in the; // TemplateSpecializationType, since they need to be mangled even though; // they aren't written.; // - Conversions on non-type template arguments need to be expressed, since; // they can affect the mangling of sizeof/alignof.; //; // FIXME: This is wrong when mapping to the canonical type for a dependent; // type discards instantiation-dependent portions of the type, such as for:; //; // template<typename T, int N> void f(T (&)[sizeof(N)]);; // template<typename T> void f(T() throw(typename T::type)); (pre-C++17); //; // It's also wrong in the opposite direction when instantiation-dependent,; // canonically-equivalent types differ in some irrelevant portion of inner; // type sugar. In such cases, we fail to form correct substitutions, eg:; //; // template<int N> void f(A<sizeof(N)> *, A<sizeof(N)> (*));; //; // We should instead canonicalize the non-instantiation-dependent parts,; // regardless of whether the type as a whole is dependent or instantiation; // dependent.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ItaniumMangle.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ItaniumMangle.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ItaniumMangle.cpp:1076,Integrability,depend,dependent,1076,"// If our type is instantiation-dependent but not dependent, we mangle; // it as it was written in the source, removing any top-level sugar.; // Otherwise, use the canonical type.; //; // FIXME: This is an approximation of the instantiation-dependent name; // mangling rules, since we should really be using the type as written and; // augmented via semantic analysis (i.e., with implicit conversions and; // default template arguments) for any instantiation-dependent type.; // Unfortunately, that requires several changes to our AST:; // - Instantiation-dependent TemplateSpecializationTypes will need to be; // uniqued, so that we can handle substitutions properly; // - Default template arguments will need to be represented in the; // TemplateSpecializationType, since they need to be mangled even though; // they aren't written.; // - Conversions on non-type template arguments need to be expressed, since; // they can affect the mangling of sizeof/alignof.; //; // FIXME: This is wrong when mapping to the canonical type for a dependent; // type discards instantiation-dependent portions of the type, such as for:; //; // template<typename T, int N> void f(T (&)[sizeof(N)]);; // template<typename T> void f(T() throw(typename T::type)); (pre-C++17); //; // It's also wrong in the opposite direction when instantiation-dependent,; // canonically-equivalent types differ in some irrelevant portion of inner; // type sugar. In such cases, we fail to form correct substitutions, eg:; //; // template<int N> void f(A<sizeof(N)> *, A<sizeof(N)> (*));; //; // We should instead canonicalize the non-instantiation-dependent parts,; // regardless of whether the type as a whole is dependent or instantiation; // dependent.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ItaniumMangle.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ItaniumMangle.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ItaniumMangle.cpp:1326,Integrability,depend,dependent,1326,"// If our type is instantiation-dependent but not dependent, we mangle; // it as it was written in the source, removing any top-level sugar.; // Otherwise, use the canonical type.; //; // FIXME: This is an approximation of the instantiation-dependent name; // mangling rules, since we should really be using the type as written and; // augmented via semantic analysis (i.e., with implicit conversions and; // default template arguments) for any instantiation-dependent type.; // Unfortunately, that requires several changes to our AST:; // - Instantiation-dependent TemplateSpecializationTypes will need to be; // uniqued, so that we can handle substitutions properly; // - Default template arguments will need to be represented in the; // TemplateSpecializationType, since they need to be mangled even though; // they aren't written.; // - Conversions on non-type template arguments need to be expressed, since; // they can affect the mangling of sizeof/alignof.; //; // FIXME: This is wrong when mapping to the canonical type for a dependent; // type discards instantiation-dependent portions of the type, such as for:; //; // template<typename T, int N> void f(T (&)[sizeof(N)]);; // template<typename T> void f(T() throw(typename T::type)); (pre-C++17); //; // It's also wrong in the opposite direction when instantiation-dependent,; // canonically-equivalent types differ in some irrelevant portion of inner; // type sugar. In such cases, we fail to form correct substitutions, eg:; //; // template<int N> void f(A<sizeof(N)> *, A<sizeof(N)> (*));; //; // We should instead canonicalize the non-instantiation-dependent parts,; // regardless of whether the type as a whole is dependent or instantiation; // dependent.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ItaniumMangle.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ItaniumMangle.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ItaniumMangle.cpp:1614,Integrability,depend,dependent,1614,"// If our type is instantiation-dependent but not dependent, we mangle; // it as it was written in the source, removing any top-level sugar.; // Otherwise, use the canonical type.; //; // FIXME: This is an approximation of the instantiation-dependent name; // mangling rules, since we should really be using the type as written and; // augmented via semantic analysis (i.e., with implicit conversions and; // default template arguments) for any instantiation-dependent type.; // Unfortunately, that requires several changes to our AST:; // - Instantiation-dependent TemplateSpecializationTypes will need to be; // uniqued, so that we can handle substitutions properly; // - Default template arguments will need to be represented in the; // TemplateSpecializationType, since they need to be mangled even though; // they aren't written.; // - Conversions on non-type template arguments need to be expressed, since; // they can affect the mangling of sizeof/alignof.; //; // FIXME: This is wrong when mapping to the canonical type for a dependent; // type discards instantiation-dependent portions of the type, such as for:; //; // template<typename T, int N> void f(T (&)[sizeof(N)]);; // template<typename T> void f(T() throw(typename T::type)); (pre-C++17); //; // It's also wrong in the opposite direction when instantiation-dependent,; // canonically-equivalent types differ in some irrelevant portion of inner; // type sugar. In such cases, we fail to form correct substitutions, eg:; //; // template<int N> void f(A<sizeof(N)> *, A<sizeof(N)> (*));; //; // We should instead canonicalize the non-instantiation-dependent parts,; // regardless of whether the type as a whole is dependent or instantiation; // dependent.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ItaniumMangle.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ItaniumMangle.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ItaniumMangle.cpp:1680,Integrability,depend,dependent,1680,"// If our type is instantiation-dependent but not dependent, we mangle; // it as it was written in the source, removing any top-level sugar.; // Otherwise, use the canonical type.; //; // FIXME: This is an approximation of the instantiation-dependent name; // mangling rules, since we should really be using the type as written and; // augmented via semantic analysis (i.e., with implicit conversions and; // default template arguments) for any instantiation-dependent type.; // Unfortunately, that requires several changes to our AST:; // - Instantiation-dependent TemplateSpecializationTypes will need to be; // uniqued, so that we can handle substitutions properly; // - Default template arguments will need to be represented in the; // TemplateSpecializationType, since they need to be mangled even though; // they aren't written.; // - Conversions on non-type template arguments need to be expressed, since; // they can affect the mangling of sizeof/alignof.; //; // FIXME: This is wrong when mapping to the canonical type for a dependent; // type discards instantiation-dependent portions of the type, such as for:; //; // template<typename T, int N> void f(T (&)[sizeof(N)]);; // template<typename T> void f(T() throw(typename T::type)); (pre-C++17); //; // It's also wrong in the opposite direction when instantiation-dependent,; // canonically-equivalent types differ in some irrelevant portion of inner; // type sugar. In such cases, we fail to form correct substitutions, eg:; //; // template<int N> void f(A<sizeof(N)> *, A<sizeof(N)> (*));; //; // We should instead canonicalize the non-instantiation-dependent parts,; // regardless of whether the type as a whole is dependent or instantiation; // dependent.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ItaniumMangle.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ItaniumMangle.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ItaniumMangle.cpp:1711,Integrability,depend,dependent,1711,"// If our type is instantiation-dependent but not dependent, we mangle; // it as it was written in the source, removing any top-level sugar.; // Otherwise, use the canonical type.; //; // FIXME: This is an approximation of the instantiation-dependent name; // mangling rules, since we should really be using the type as written and; // augmented via semantic analysis (i.e., with implicit conversions and; // default template arguments) for any instantiation-dependent type.; // Unfortunately, that requires several changes to our AST:; // - Instantiation-dependent TemplateSpecializationTypes will need to be; // uniqued, so that we can handle substitutions properly; // - Default template arguments will need to be represented in the; // TemplateSpecializationType, since they need to be mangled even though; // they aren't written.; // - Conversions on non-type template arguments need to be expressed, since; // they can affect the mangling of sizeof/alignof.; //; // FIXME: This is wrong when mapping to the canonical type for a dependent; // type discards instantiation-dependent portions of the type, such as for:; //; // template<typename T, int N> void f(T (&)[sizeof(N)]);; // template<typename T> void f(T() throw(typename T::type)); (pre-C++17); //; // It's also wrong in the opposite direction when instantiation-dependent,; // canonically-equivalent types differ in some irrelevant portion of inner; // type sugar. In such cases, we fail to form correct substitutions, eg:; //; // template<int N> void f(A<sizeof(N)> *, A<sizeof(N)> (*));; //; // We should instead canonicalize the non-instantiation-dependent parts,; // regardless of whether the type as a whole is dependent or instantiation; // dependent.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ItaniumMangle.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ItaniumMangle.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ItaniumMangle.cpp:82,Integrability,depend,dependent,82,// FIXME: We presumably shouldn't strip off ElaboratedTypes with; // instantation-dependent qualifiers. See; // https://github.com/itanium-cxx-abi/cxx-abi/issues/114.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ItaniumMangle.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ItaniumMangle.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ItaniumMangle.cpp:22,Deployability,update,update,22,// Note that we don't update T: we want to add the; // substitution at the original type.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ItaniumMangle.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ItaniumMangle.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ItaniumMangle.cpp:1124,Modifiability,extend,extended,1124,"// <type> ::= <builtin-type>; // <builtin-type> ::= v # void; // ::= w # wchar_t; // ::= b # bool; // ::= c # char; // ::= a # signed char; // ::= h # unsigned char; // ::= s # short; // ::= t # unsigned short; // ::= i # int; // ::= j # unsigned int; // ::= l # long; // ::= m # unsigned long; // ::= x # long long, __int64; // ::= y # unsigned long long, __int64; // ::= n # __int128; // ::= o # unsigned __int128; // ::= f # float; // ::= d # double; // ::= e # long double, __float80; // ::= g # __float128; // ::= g # __ibm128; // UNSUPPORTED: ::= Dd # IEEE 754r decimal floating point (64 bits); // UNSUPPORTED: ::= De # IEEE 754r decimal floating point (128 bits); // UNSUPPORTED: ::= Df # IEEE 754r decimal floating point (32 bits); // ::= Dh # IEEE 754r half-precision floating point (16 bits); // ::= DF <number> _ # ISO/IEC TS 18661 binary floating point type _FloatN (N bits);; // ::= Di # char32_t; // ::= Ds # char16_t; // ::= Dn # std::nullptr_t (i.e., decltype(nullptr)); // ::= [DS] DA # N1169 fixed-point [_Sat] T _Accum; // ::= [DS] DR # N1169 fixed-point [_Sat] T _Fract; // ::= u <source-name> # vendor extended type; //; // <fixed-point-size>; // ::= s # short; // ::= t # unsigned short; // ::= i # plain; // ::= j # unsigned; // ::= l # long; // ::= m # unsigned long",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ItaniumMangle.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ItaniumMangle.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ItaniumMangle.cpp:37,Modifiability,extend,extended,37,// Normalize integer types as vendor extended types:; // u<length>i<type size>; // u<length>u<type size>,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ItaniumMangle.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ItaniumMangle.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ItaniumMangle.cpp:24,Integrability,depend,dependent,24,"// Mangle instantiation-dependent exception-specification, if present,; // per cxx-abi-dev proposal on 2016-10-11.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ItaniumMangle.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ItaniumMangle.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ItaniumMangle.cpp:10,Modifiability,extend,extended,10,// Mangle extended parameter info as order-sensitive qualifiers here.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ItaniumMangle.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ItaniumMangle.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ItaniumMangle.cpp:5,Integrability,Depend,DependentSizedArrayType,5,// A DependentSizedArrayType might not have size expression as below; //; // template<int ...N> int arr[] = {N...};,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ItaniumMangle.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ItaniumMangle.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ItaniumMangle.cpp:14,Usability,clear,clear,14,// FIXME: not clear how to mangle this!; // template <class T...> class A {; // template <class U...> void foo(T(*)(U) x...);; // };,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ItaniumMangle.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ItaniumMangle.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ItaniumMangle.cpp:120,Modifiability,extend,extended,120,// GNU extension: vector types; // <type> ::= <vector-type>; // <vector-type> ::= Dv <positive dimension number> _; // <extended element type>; // ::= Dv [<dimension expression>] _ <element type>; // <extended element type> ::= <element type>; // ::= p # AltiVec vector pixel; // ::= b # Altivec vector bool,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ItaniumMangle.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ItaniumMangle.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ItaniumMangle.cpp:201,Modifiability,extend,extended,201,// GNU extension: vector types; // <type> ::= <vector-type>; // <vector-type> ::= Dv <positive dimension number> _; // <extended element type>; // ::= Dv [<dimension expression>] _ <element type>; // <extended element type> ::= <element type>; // ::= p # AltiVec vector pixel; // ::= b # Altivec vector bool,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ItaniumMangle.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ItaniumMangle.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ItaniumMangle.cpp:35,Modifiability,extend,extended,35,// Mangle matrix types as a vendor extended type:; // u<Len>matrix_typeI<Rows><Columns><element type>E,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ItaniumMangle.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ItaniumMangle.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ItaniumMangle.cpp:35,Modifiability,extend,extended,35,// Mangle matrix types as a vendor extended type:; // u<Len>matrix_typeI<row expr><column expr><element type>E,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ItaniumMangle.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ItaniumMangle.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ItaniumMangle.cpp:30,Modifiability,extend,extended,30,// Treat __kindof as a vendor extended type qualifier.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ItaniumMangle.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ItaniumMangle.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ItaniumMangle.cpp:10,Integrability,protocol,protocol,10,// Mangle protocol qualifiers.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ItaniumMangle.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ItaniumMangle.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ItaniumMangle.cpp:10,Integrability,inject,injected,10,"// Mangle injected class name types as if the user had written the; // specialization out fully. It may not actually be possible to see; // this mangling, though.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ItaniumMangle.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ItaniumMangle.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ItaniumMangle.cpp:10,Security,inject,injected,10,"// Mangle injected class name types as if the user had written the; // specialization out fully. It may not actually be possible to see; // this mangling, though.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ItaniumMangle.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ItaniumMangle.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ItaniumMangle.cpp:102,Integrability,depend,dependent,102,// FIXME: GCC does not appear to mangle the template arguments when; // the template in question is a dependent template name. Should we; // emulate that badness?,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ItaniumMangle.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ItaniumMangle.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ItaniumMangle.cpp:78,Integrability,depend,dependent,78,"// Proposal by cxx-abi-dev, 2014-03-26; // <class-enum-type> ::= <name> # non-dependent or dependent type name or; // # dependent elaborated type specifier using; // # 'typename'; // ::= Ts <name> # dependent elaborated type specifier using; // # 'struct' or 'class'; // ::= Tu <name> # dependent elaborated type specifier using; // # 'union'; // ::= Te <name> # dependent elaborated type specifier using; // # 'enum'",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ItaniumMangle.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ItaniumMangle.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ItaniumMangle.cpp:91,Integrability,depend,dependent,91,"// Proposal by cxx-abi-dev, 2014-03-26; // <class-enum-type> ::= <name> # non-dependent or dependent type name or; // # dependent elaborated type specifier using; // # 'typename'; // ::= Ts <name> # dependent elaborated type specifier using; // # 'struct' or 'class'; // ::= Tu <name> # dependent elaborated type specifier using; // # 'union'; // ::= Te <name> # dependent elaborated type specifier using; // # 'enum'",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ItaniumMangle.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ItaniumMangle.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ItaniumMangle.cpp:120,Integrability,depend,dependent,120,"// Proposal by cxx-abi-dev, 2014-03-26; // <class-enum-type> ::= <name> # non-dependent or dependent type name or; // # dependent elaborated type specifier using; // # 'typename'; // ::= Ts <name> # dependent elaborated type specifier using; // # 'struct' or 'class'; // ::= Tu <name> # dependent elaborated type specifier using; // # 'union'; // ::= Te <name> # dependent elaborated type specifier using; // # 'enum'",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ItaniumMangle.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ItaniumMangle.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ItaniumMangle.cpp:199,Integrability,depend,dependent,199,"// Proposal by cxx-abi-dev, 2014-03-26; // <class-enum-type> ::= <name> # non-dependent or dependent type name or; // # dependent elaborated type specifier using; // # 'typename'; // ::= Ts <name> # dependent elaborated type specifier using; // # 'struct' or 'class'; // ::= Tu <name> # dependent elaborated type specifier using; // # 'union'; // ::= Te <name> # dependent elaborated type specifier using; // # 'enum'",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ItaniumMangle.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ItaniumMangle.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ItaniumMangle.cpp:287,Integrability,depend,dependent,287,"// Proposal by cxx-abi-dev, 2014-03-26; // <class-enum-type> ::= <name> # non-dependent or dependent type name or; // # dependent elaborated type specifier using; // # 'typename'; // ::= Ts <name> # dependent elaborated type specifier using; // # 'struct' or 'class'; // ::= Tu <name> # dependent elaborated type specifier using; // # 'union'; // ::= Te <name> # dependent elaborated type specifier using; // # 'enum'",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ItaniumMangle.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ItaniumMangle.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ItaniumMangle.cpp:363,Integrability,depend,dependent,363,"// Proposal by cxx-abi-dev, 2014-03-26; // <class-enum-type> ::= <name> # non-dependent or dependent type name or; // # dependent elaborated type specifier using; // # 'typename'; // ::= Ts <name> # dependent elaborated type specifier using; // # 'struct' or 'class'; // ::= Tu <name> # dependent elaborated type specifier using; // # 'union'; // ::= Te <name> # dependent elaborated type specifier using; // # 'enum'",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ItaniumMangle.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ItaniumMangle.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ItaniumMangle.cpp:3,Integrability,Depend,Dependently-scoped,3,// Dependently-scoped template types are nested if they have a prefix.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ItaniumMangle.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ItaniumMangle.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ItaniumMangle.cpp:9,Safety,avoid,avoid,9,// TODO: avoid making this TemplateName.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ItaniumMangle.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ItaniumMangle.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ItaniumMangle.cpp:102,Integrability,depend,dependent,102,// FIXME: GCC does not appear to mangle the template arguments when; // the template in question is a dependent template name. Should we; // emulate that badness?,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ItaniumMangle.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ItaniumMangle.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ItaniumMangle.cpp:83,Security,access,access,83,// type ::= Dt <expression> E # decltype of an id-expression; // # or class member access; // ::= DT <expression> E # decltype of an expression; // This purports to be an exhaustive list of id-expressions and; // class member accesses. Note that we do not ignore parentheses;; // parentheses change the semantics of decltype for these; // expressions (and cause the mangler to use the other form).,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ItaniumMangle.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ItaniumMangle.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ItaniumMangle.cpp:226,Security,access,accesses,226,// type ::= Dt <expression> E # decltype of an id-expression; // # or class member access; // ::= DT <expression> E # decltype of an expression; // This purports to be an exhaustive list of id-expressions and; // class member accesses. Note that we do not ignore parentheses;; // parentheses change the semantics of decltype for these; // expressions (and cause the mangler to use the other form).,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ItaniumMangle.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ItaniumMangle.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ItaniumMangle.cpp:14,Integrability,depend,dependent,14,"// If this is dependent, we need to record that. If not, we simply; // mangle it as the underlying type since they are equivalent.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ItaniumMangle.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ItaniumMangle.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ItaniumMangle.cpp:60,Usability,simpl,simply,60,"// If this is dependent, we need to record that. If not, we simply; // mangle it as the underlying type since they are equivalent.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ItaniumMangle.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ItaniumMangle.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ItaniumMangle.cpp:46,Modifiability,extend,extended,46,// <type> ::= U <source-name> <type> # vendor extended type qualifier; // (Until there's a standardized mangling...),MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ItaniumMangle.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ItaniumMangle.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ItaniumMangle.cpp:67,Integrability,depend,dependent,67,// 5.1.5.2 Builtin types; // <type> ::= DB <number | instantiation-dependent expression> _; // ::= DU <number | instantiation-dependent expression> _,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ItaniumMangle.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ItaniumMangle.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ItaniumMangle.cpp:126,Integrability,depend,dependent,126,// 5.1.5.2 Builtin types; // <type> ::= DB <number | instantiation-dependent expression> _; // ::= DU <number | instantiation-dependent expression> _,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ItaniumMangle.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ItaniumMangle.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ItaniumMangle.cpp:67,Integrability,depend,dependent,67,// 5.1.5.2 Builtin types; // <type> ::= DB <number | instantiation-dependent expression> _; // ::= DU <number | instantiation-dependent expression> _,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ItaniumMangle.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ItaniumMangle.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ItaniumMangle.cpp:126,Integrability,depend,dependent,126,// 5.1.5.2 Builtin types; // <type> ::= DB <number | instantiation-dependent expression> _; // ::= DU <number | instantiation-dependent expression> _,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ItaniumMangle.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ItaniumMangle.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ItaniumMangle.cpp:71,Usability,clear,clear,71,// TODO: We can't mangle the result of a failed substitution. It's not clear; // whether we should be mangling the original form prior to any substitution; // instead. See https://lists.isocpp.org/core/2023/04/14118.php,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ItaniumMangle.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ItaniumMangle.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ItaniumMangle.cpp:811,Integrability,depend,dependent,811,"// <expression> ::= <unary operator-name> <expression>; // ::= <binary operator-name> <expression> <expression>; // ::= <trinary operator-name> <expression> <expression> <expression>; // ::= cv <type> expression # conversion with one argument; // ::= cv <type> _ <expression>* E # conversion with a different number of arguments; // ::= dc <type> <expression> # dynamic_cast<type> (expression); // ::= sc <type> <expression> # static_cast<type> (expression); // ::= cc <type> <expression> # const_cast<type> (expression); // ::= rc <type> <expression> # reinterpret_cast<type> (expression); // ::= st <type> # sizeof (a type); // ::= at <type> # alignof (a type); // ::= <template-param>; // ::= <function-param>; // ::= fpT # 'this' expression (part of <function-param>); // ::= sr <type> <unqualified-name> # dependent name; // ::= sr <type> <unqualified-name> <template-args> # dependent template-id; // ::= ds <expression> <expression> # expr.*expr; // ::= sZ <template-param> # size of a parameter pack; // ::= sZ <function-param> # size of a function parameter pack; // ::= u <source-name> <template-arg>* E # vendor extended expression; // ::= <expr-primary>; // <expr-primary> ::= L <type> <value number> E # integer literal; // ::= L <type> <value float> E # floating literal; // ::= L <type> <string type> E # string literal; // ::= L <nullptr type> E # nullptr literal ""LDnE""; // ::= L <pointer type> 0 E # null pointer template argument; // ::= L <type> <real-part float> _ <imag-part float> E # complex floating point literal (C99); not used by clang; // ::= L <mangled-name> E # external name",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ItaniumMangle.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ItaniumMangle.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ItaniumMangle.cpp:881,Integrability,depend,dependent,881,"// <expression> ::= <unary operator-name> <expression>; // ::= <binary operator-name> <expression> <expression>; // ::= <trinary operator-name> <expression> <expression> <expression>; // ::= cv <type> expression # conversion with one argument; // ::= cv <type> _ <expression>* E # conversion with a different number of arguments; // ::= dc <type> <expression> # dynamic_cast<type> (expression); // ::= sc <type> <expression> # static_cast<type> (expression); // ::= cc <type> <expression> # const_cast<type> (expression); // ::= rc <type> <expression> # reinterpret_cast<type> (expression); // ::= st <type> # sizeof (a type); // ::= at <type> # alignof (a type); // ::= <template-param>; // ::= <function-param>; // ::= fpT # 'this' expression (part of <function-param>); // ::= sr <type> <unqualified-name> # dependent name; // ::= sr <type> <unqualified-name> <template-args> # dependent template-id; // ::= ds <expression> <expression> # expr.*expr; // ::= sZ <template-param> # size of a parameter pack; // ::= sZ <function-param> # size of a function parameter pack; // ::= u <source-name> <template-arg>* E # vendor extended expression; // ::= <expr-primary>; // <expr-primary> ::= L <type> <value number> E # integer literal; // ::= L <type> <value float> E # floating literal; // ::= L <type> <string type> E # string literal; // ::= L <nullptr type> E # nullptr literal ""LDnE""; // ::= L <pointer type> 0 E # null pointer template argument; // ::= L <type> <real-part float> _ <imag-part float> E # complex floating point literal (C99); not used by clang; // ::= L <mangled-name> E # external name",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ItaniumMangle.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ItaniumMangle.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ItaniumMangle.cpp:1123,Modifiability,extend,extended,1123,"// <expression> ::= <unary operator-name> <expression>; // ::= <binary operator-name> <expression> <expression>; // ::= <trinary operator-name> <expression> <expression> <expression>; // ::= cv <type> expression # conversion with one argument; // ::= cv <type> _ <expression>* E # conversion with a different number of arguments; // ::= dc <type> <expression> # dynamic_cast<type> (expression); // ::= sc <type> <expression> # static_cast<type> (expression); // ::= cc <type> <expression> # const_cast<type> (expression); // ::= rc <type> <expression> # reinterpret_cast<type> (expression); // ::= st <type> # sizeof (a type); // ::= at <type> # alignof (a type); // ::= <template-param>; // ::= <function-param>; // ::= fpT # 'this' expression (part of <function-param>); // ::= sr <type> <unqualified-name> # dependent name; // ::= sr <type> <unqualified-name> <template-args> # dependent template-id; // ::= ds <expression> <expression> # expr.*expr; // ::= sZ <template-param> # size of a parameter pack; // ::= sZ <function-param> # size of a function parameter pack; // ::= u <source-name> <template-arg>* E # vendor extended expression; // ::= <expr-primary>; // <expr-primary> ::= L <type> <value number> E # integer literal; // ::= L <type> <value float> E # floating literal; // ::= L <type> <string type> E # string literal; // ::= L <nullptr type> E # nullptr literal ""LDnE""; // ::= L <pointer type> 0 E # null pointer template argument; // ::= L <type> <real-part float> _ <imag-part float> E # complex floating point literal (C99); not used by clang; // ::= L <mangled-name> E # external name",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ItaniumMangle.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ItaniumMangle.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ItaniumMangle.cpp:64,Integrability,wrap,wrapped,64,// A top-level expression that's not <expr-primary> needs to be wrapped in; // X...E in a template arg.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ItaniumMangle.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ItaniumMangle.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ItaniumMangle.cpp:42,Usability,simpl,simple,42,"// 'goto recurse' is used when handling a simple ""unwrapping"" node which; // produces no output, where ImplicitlyConvertedToType and AsTemplateArg need; // to be preserved.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ItaniumMangle.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ItaniumMangle.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ItaniumMangle.cpp:57,Modifiability,variab,variable-initialization,57,// fallthrough; // These all can only appear in local or variable-initialization; // contexts and so should never appear in a mangling.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ItaniumMangle.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ItaniumMangle.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ItaniumMangle.cpp:42,Modifiability,extend,extended,42,"// As of clang 12, uuidof uses the vendor extended expression; // mangling. Previously, it used a special-cased nonstandard extension.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ItaniumMangle.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ItaniumMangle.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ItaniumMangle.cpp:24,Usability,simpl,simple-id,24,"// <expression> ::= cp <simple-id> <expression>* E; // We use this mangling only when the call would use ADL except; // for being parenthesized. Per discussion with David; // Vandervoorde, 2011.04.25.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ItaniumMangle.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ItaniumMangle.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ItaniumMangle.cpp:117,Usability,simpl,simple-id,117,// The callee here is a parenthesized UnresolvedLookupExpr with; // no qualifier and should always get mangled as a <simple-id>; // anyway.; // <expression> ::= cl <expression>* E,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ItaniumMangle.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ItaniumMangle.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ItaniumMangle.cpp:21,Integrability,depend,dependent,21,// Non-instantiation-dependent traits are an <expr-primary> integer literal.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ItaniumMangle.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ItaniumMangle.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ItaniumMangle.cpp:96,Integrability,depend,dependent,96,"// Itanium C++ ABI:; // If the operand of a sizeof or alignof operator is not; // instantiation-dependent it is encoded as an integer literal; // reflecting the result of the operator.; //; // If the result of the operator is implicitly converted to a known; // integer type, that type is used for the literal; otherwise, the type; // of std::size_t or std::ptrdiff_t is used.; //; // FIXME: We still include the operand in the profile in this case. This; // can lead to mangling collisions between function templates that we; // consider to be different.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ItaniumMangle.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ItaniumMangle.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ItaniumMangle.cpp:38,Modifiability,extend,extended,38,"// Mangle ownership casts as a vendor extended operator __bridge,; // __bridge_transfer, or __bridge_retain.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ItaniumMangle.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ItaniumMangle.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ItaniumMangle.cpp:14,Usability,clear,clear,14,// FIXME: not clear how to mangle this!; // template <unsigned N...> class A {; // template <class U...> void foo(U (&x)[N]...);; // };,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ItaniumMangle.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ItaniumMangle.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ItaniumMangle.cpp:14,Usability,clear,clear,14,// FIXME: not clear how to mangle this!,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ItaniumMangle.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ItaniumMangle.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ItaniumMangle.cpp:53,Modifiability,variab,variable,53,"/// Mangle an expression which refers to a parameter variable.; ///; /// <expression> ::= <function-param>; /// <function-param> ::= fp <top-level CV-qualifiers> _ # L == 0, I == 0; /// <function-param> ::= fp <top-level CV-qualifiers>; /// <parameter-2 non-negative number> _ # L == 0, I > 0; /// <function-param> ::= fL <L-1 non-negative number>; /// p <top-level CV-qualifiers> _ # L > 0, I == 0; /// <function-param> ::= fL <L-1 non-negative number>; /// p <top-level CV-qualifiers>; /// <I-1 non-negative number> _ # L > 0, I > 0; ///; /// L is the nesting depth of the parameter, defined as 1 if the; /// parameter comes from the innermost function prototype scope; /// enclosing the current context, 2 if from the next enclosing; /// function prototype scope, and so on, with one special case: if; /// we've processed the full parameter clause for the innermost; /// function type, then L is one less. This definition conveniently; /// makes it irrelevant whether a function's result type was written; /// trailing or leading, but is otherwise overly complicated; the; /// numbering was first designed without considering references to; /// parameter in locations other than return types, and then the; /// mangling had to be generalized without changing the existing; /// manglings.; ///; /// I is the zero-based index of the parameter within its parameter; /// declaration clause. Note that the original ABI document describes; /// this using 1-based ordinals.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ItaniumMangle.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ItaniumMangle.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ItaniumMangle.cpp:124,Modifiability,inherit,inheriting,124,"// <ctor-dtor-name> ::= C1 # complete object constructor; // ::= C2 # base object constructor; // ::= CI1 <type> # complete inheriting constructor; // ::= CI2 <type> # base inheriting constructor; //; // In addition, C5 is a comdat name with C1 and C2 in it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ItaniumMangle.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ItaniumMangle.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ItaniumMangle.cpp:173,Modifiability,inherit,inheriting,173,"// <ctor-dtor-name> ::= C1 # complete object constructor; // ::= C2 # base object constructor; // ::= CI1 <type> # complete inheriting constructor; // ::= CI2 <type> # base inheriting constructor; //; // In addition, C5 is a comdat name with C1 and C2 in it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ItaniumMangle.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ItaniumMangle.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ItaniumMangle.cpp:271,Integrability,depend,dependent,271,"// For a non-type template parameter, the natural parameter is `T V` (for a; // prvalue argument) or `T &V` (for a glvalue argument), where `T` is the; // type of the argument, which we require to exactly match. If the actual; // parameter has a deduced or instantiation-dependent type, it is not; // equivalent to the natural parameter.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ItaniumMangle.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ItaniumMangle.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ItaniumMangle.cpp:111,Usability,simpl,simple,111,// <template-arg> ::= <type> # type or template; // ::= X <expression> E # expression; // ::= <expr-primary> # simple expressions; // ::= J <template-arg>* E # argument pack,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ItaniumMangle.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ItaniumMangle.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ItaniumMangle.cpp:3,Usability,Simpl,Simple,3,// Simple pointer-to-member with no conversion.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ItaniumMangle.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ItaniumMangle.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ItaniumMangle.cpp:215,Usability,guid,guidance,215,"// Consider only the fields in declaration order, searched depth-first. We; // don't care about the active member of the union, as all we are doing is; // looking for a valid name. We also don't check bases, due to guidance from; // the Itanium ABI folks.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ItaniumMangle.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ItaniumMangle.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ItaniumMangle.cpp:61,Integrability,wrap,wrapped,61,// A top-level expression that's not a primary expression is wrapped in X...E.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ItaniumMangle.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ItaniumMangle.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ItaniumMangle.cpp:3,Testability,log,log,3,// log(2**32) / log(36) ~= 7,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ItaniumMangle.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ItaniumMangle.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ItaniumMangle.cpp:16,Testability,log,log,16,// log(2**32) / log(36) ~= 7,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ItaniumMangle.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ItaniumMangle.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ItaniumMangle.cpp:42,Integrability,depend,depending,42,// Plain 'char' is named Char_S or Char_U depending on the target ABI.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ItaniumMangle.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ItaniumMangle.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ItaniumMangle.cpp:160,Integrability,rout,routine,160,"//; /// Mangles the name of the declaration D and emits that name to the given; /// output stream.; ///; /// If the declaration D requires a mangled name, this routine will emit that; /// mangled name to \p os and return true. Otherwise, \p os will be unchanged; /// and this routine will return false. In this case, the caller should just; /// emit the identifier of the declaration (\c D->getIdentifier()) as its; /// name.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ItaniumMangle.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ItaniumMangle.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ItaniumMangle.cpp:276,Integrability,rout,routine,276,"//; /// Mangles the name of the declaration D and emits that name to the given; /// output stream.; ///; /// If the declaration D requires a mangled name, this routine will emit that; /// mangled name to \p os and return true. Otherwise, \p os will be unchanged; /// and this routine will return false. In this case, the caller should just; /// emit the identifier of the declaration (\c D->getIdentifier()) as its; /// name.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ItaniumMangle.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ItaniumMangle.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ItaniumMangle.cpp:41,Modifiability,variab,variable,41,/// Returns the mangled name for a guard variable for the passed in VarDecl.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ItaniumMangle.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ItaniumMangle.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ItaniumMangle.cpp:47,Modifiability,variab,variable,47,// <special-name> ::= GV <object name> # Guard variable for one-time; // # initialization,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ItaniumMangle.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ItaniumMangle.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ItaniumMangle.cpp:159,Safety,avoid,avoid,159,"// These symbols are internal in the Itanium ABI, so the names don't matter.; // Clang has traditionally used this symbol and allowed LLVM to adjust it to; // avoid duplicate symbols.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ItaniumMangle.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ItaniumMangle.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/JSONNodeDumper.cpp:23,Modifiability,inherit,inheritance,23,"// Because of multiple inheritance, a DeclContext pointer does not produce; // the same pointer representation as a Decl pointer that references the; // same AST Node.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/JSONNodeDumper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/JSONNodeDumper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/JSONNodeDumper.cpp:191,Availability,failure,failures,191,"// If the declaration is dependent or is in a dependent context, then the; // mangling is unlikely to be meaningful (and in some cases may cause; // ""don't know how to mangle this"" assertion failures.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/JSONNodeDumper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/JSONNodeDumper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/JSONNodeDumper.cpp:25,Integrability,depend,dependent,25,"// If the declaration is dependent or is in a dependent context, then the; // mangling is unlikely to be meaningful (and in some cases may cause; // ""don't know how to mangle this"" assertion failures.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/JSONNodeDumper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/JSONNodeDumper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/JSONNodeDumper.cpp:46,Integrability,depend,dependent,46,"// If the declaration is dependent or is in a dependent context, then the; // mangling is unlikely to be meaningful (and in some cases may cause; // ""don't know how to mangle this"" assertion failures.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/JSONNodeDumper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/JSONNodeDumper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/JSONNodeDumper.cpp:181,Testability,assert,assertion,181,"// If the declaration is dependent or is in a dependent context, then the; // mangling is unlikely to be meaningful (and in some cases may cause; // ""don't know how to mangle this"" assertion failures.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/JSONNodeDumper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/JSONNodeDumper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/JSONNodeDumper.cpp:36,Usability,guid,guides,36,// Do not mangle template deduction guides.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/JSONNodeDumper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/JSONNodeDumper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Linkage.h:13,Performance,cache,cache,13,"// We have a cache for repeated linkage/visibility computations. This saves us; // from exponential behavior in heavily templated code, such as:; //; // template <typename T, typename V> struct {};; // using A = int;; // using B = Foo<A, A>;; // using C = Foo<B, B>;; // using D = Foo<C, C>;; //; // The integer represents an LVComputationKind.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/Linkage.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Linkage.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Mangle.cpp:260,Safety,avoid,avoid,260,"// Adding the prefix can cause problems when one file has a ""foo"" and; // another has a ""\01foo"". That is known to happen on ELF with the; // tricks normally used for producing aliases (PR9177). Fortunately the; // llvm mangler on ELF is a nop, so we can just avoid adding the \01; // marker.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/Mangle.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Mangle.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Mangle.cpp:148,Usability,simpl,simply,148,// If an argument type is incomplete there is no way to get its size to; // correctly encode into the mangling scheme.; // Follow GCCs behaviour by simply breaking out of the loop.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/Mangle.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Mangle.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Mangle.cpp:50,Usability,GUID,GUID,50,"// For now, follow the MSVC naming convention for GUID objects on all; // targets.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/Mangle.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Mangle.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/MicrosoftCXXABI.cpp:119,Modifiability,inherit,inherit,119,"// getNumBases() seems to only give us the number of direct bases, and not the; // total. This function tells us if we inherit from anybody that uses MI, or if; // we have a non-primary base class, which uses the multiple inheritance model.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/MicrosoftCXXABI.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/MicrosoftCXXABI.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/MicrosoftCXXABI.cpp:222,Modifiability,inherit,inheritance,222,"// getNumBases() seems to only give us the number of direct bases, and not the; // total. This function tells us if we inherit from anybody that uses MI, or if; // we have a non-primary base class, which uses the multiple inheritance model.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/MicrosoftCXXABI.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/MicrosoftCXXABI.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/MicrosoftCXXABI.cpp:259,Modifiability,inherit,inheritance,259,"// Returns the number of pointer and integer slots used to represent a member; // pointer in the MS C++ ABI.; //; // Member function pointers have the following general form; however, fields; // are dropped as permitted (under the MSVC interpretation) by the inheritance; // model of the actual class.; //; // struct {; // // A pointer to the member function to call. If the member function is; // // virtual, this will be a thunk that forwards to the appropriate vftable; // // slot.; // void *FunctionPointerOrVirtualThunk;; //; // // An offset to add to the address of the vbtable pointer after; // // (possibly) selecting the virtual base but before resolving and calling; // // the function.; // // Only needed if the class has any virtual bases or bases at a non-zero; // // offset.; // int NonVirtualBaseAdjustment;; //; // // The offset of the vb-table pointer within the object. Only needed for; // // incomplete types.; // int VBPtrOffset;; //; // // An offset within the vb-table that selects the virtual base containing; // // the member. Loading from this offset produces a new offset that is; // // added to the address of the vb-table pointer to produce the base.; // int VirtualBaseAdjustmentOffset;; // };",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/MicrosoftCXXABI.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/MicrosoftCXXABI.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/MicrosoftCXXABI.cpp:1051,Performance,Load,Loading,1051,"// Returns the number of pointer and integer slots used to represent a member; // pointer in the MS C++ ABI.; //; // Member function pointers have the following general form; however, fields; // are dropped as permitted (under the MSVC interpretation) by the inheritance; // model of the actual class.; //; // struct {; // // A pointer to the member function to call. If the member function is; // // virtual, this will be a thunk that forwards to the appropriate vftable; // // slot.; // void *FunctionPointerOrVirtualThunk;; //; // // An offset to add to the address of the vbtable pointer after; // // (possibly) selecting the virtual base but before resolving and calling; // // the function.; // // Only needed if the class has any virtual bases or bases at a non-zero; // // offset.; // int NonVirtualBaseAdjustment;; //; // // The offset of the vb-table pointer within the object. Only needed for; // // incomplete types.; // int VBPtrOffset;; //; // // An offset within the vb-table that selects the virtual base containing; // // the member. Loading from this offset produces a new offset that is; // // added to the address of the vb-table pointer to produce the base.; // int VirtualBaseAdjustmentOffset;; // };",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/MicrosoftCXXABI.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/MicrosoftCXXABI.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/MicrosoftMangle.cpp:3,Performance,Perform,Perform,3,// Perform the same check for block literals.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/MicrosoftMangle.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/MicrosoftMangle.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/MicrosoftMangle.cpp:35,Security,hash,hash,35,"// To mangle anonymous namespaces, hash the path to the main source file. The; // path should be whatever (probably relative) path was passed on the command; // line. The goal is for the compiler to produce the same output regardless of; // working directory, so use the uncanonicalized relative path.; //; // It's important to make the mangled names unique because, when CodeView; // debug info is in use, the debugger uses mangled type names to distinguish; // between otherwise identically named types in anonymous namespaces.; //; // These symbols are always internal, so there is no need for the hash to; // match what MSVC produces. For the same reason, clang is free to change the; // hash at any time without breaking compatibility with old versions of clang.; // The generated names are intended to look similar to what MSVC generates,; // which are something like ""?A0x01234567@"".",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/MicrosoftMangle.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/MicrosoftMangle.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/MicrosoftMangle.cpp:601,Security,hash,hash,601,"// To mangle anonymous namespaces, hash the path to the main source file. The; // path should be whatever (probably relative) path was passed on the command; // line. The goal is for the compiler to produce the same output regardless of; // working directory, so use the uncanonicalized relative path.; //; // It's important to make the mangled names unique because, when CodeView; // debug info is in use, the debugger uses mangled type names to distinguish; // between otherwise identically named types in anonymous namespaces.; //; // These symbols are always internal, so there is no need for the hash to; // match what MSVC produces. For the same reason, clang is free to change the; // hash at any time without breaking compatibility with old versions of clang.; // The generated names are intended to look similar to what MSVC generates,; // which are something like ""?A0x01234567@"".",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/MicrosoftMangle.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/MicrosoftMangle.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/MicrosoftMangle.cpp:692,Security,hash,hash,692,"// To mangle anonymous namespaces, hash the path to the main source file. The; // path should be whatever (probably relative) path was passed on the command; // line. The goal is for the compiler to produce the same output regardless of; // working directory, so use the uncanonicalized relative path.; //; // It's important to make the mangled names unique because, when CodeView; // debug info is in use, the debugger uses mangled type names to distinguish; // between otherwise identically named types in anonymous namespaces.; //; // These symbols are always internal, so there is no need for the hash to; // match what MSVC produces. For the same reason, clang is free to change the; // hash at any time without breaking compatibility with old versions of clang.; // The generated names are intended to look similar to what MSVC generates,; // which are something like ""?A0x01234567@"".",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/MicrosoftMangle.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/MicrosoftMangle.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/MicrosoftMangle.cpp:16,Security,hash,hash,16,// Truncate the hash so we get 8 characters of hexadecimal.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/MicrosoftMangle.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/MicrosoftMangle.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/MicrosoftMangle.cpp:49,Usability,simpl,simple,49,// C++ functions and those whose names are not a simple identifier need; // mangling.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/MicrosoftMangle.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/MicrosoftMangle.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/MicrosoftMangle.cpp:5,Modifiability,variab,variables,5,// C variables are not mangled.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/MicrosoftMangle.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/MicrosoftMangle.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/MicrosoftMangle.cpp:3,Modifiability,Variab,Variables,3,// Variables at global scope with internal linkage are not mangled.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/MicrosoftMangle.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/MicrosoftMangle.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/MicrosoftMangle.cpp:20,Modifiability,variab,variable,20,// Check for extern variable declared locally.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/MicrosoftMangle.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/MicrosoftMangle.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/MicrosoftMangle.cpp:48,Modifiability,variab,variables,48,// MSVC appears to mangle GUIDs as if they were variables of type; // 'const struct __s_GUID'.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/MicrosoftMangle.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/MicrosoftMangle.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/MicrosoftMangle.cpp:26,Usability,GUID,GUIDs,26,// MSVC appears to mangle GUIDs as if they were variables of type; // 'const struct __s_GUID'.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/MicrosoftMangle.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/MicrosoftMangle.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/MicrosoftMangle.cpp:40,Modifiability,variab,variable-type,40,// <type-encoding> ::= <storage-class> <variable-type>; // <storage-class> ::= 0 # private static member; // ::= 1 # protected static member; // ::= 2 # public static member; // ::= 3 # global; // ::= 4 # static local; // The first character in the encoding (after the name) is the storage class.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/MicrosoftMangle.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/MicrosoftMangle.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/MicrosoftMangle.cpp:48,Security,access,access,48,"// If it's a static member, it also encodes the access level.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/MicrosoftMangle.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/MicrosoftMangle.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/MicrosoftMangle.cpp:29,Modifiability,variab,variable-type,29,"// Now mangle the type.; // <variable-type> ::= <type> <cvr-qualifiers>; // ::= <type> <pointee-cvr-qualifiers> # pointers, references; // Pointers and references are odd. The type of 'int * const foo;' gets; // mangled as 'QAHA' instead of 'PAHB', for example.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/MicrosoftMangle.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/MicrosoftMangle.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/MicrosoftMangle.cpp:15,Modifiability,inherit,inheritance,15,// Null single inheritance member functions are encoded as a simple nullptr.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/MicrosoftMangle.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/MicrosoftMangle.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/MicrosoftMangle.cpp:61,Usability,simpl,simple,61,// Null single inheritance member functions are encoded as a simple nullptr.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/MicrosoftMangle.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/MicrosoftMangle.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/MicrosoftMangle.cpp:22,Modifiability,variab,variable,22,// Check if we have a variable template.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/MicrosoftMangle.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/MicrosoftMangle.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/MicrosoftMangle.cpp:725,Performance,cache,cache,725,"// Here comes the tricky thing: if we need to mangle something like; // void foo(A::X<Y>, B::X<Y>),; // the X<Y> part is aliased. However, if you need to mangle; // void foo(A::X<A::Y>, A::X<B::Y>),; // the A::X<> part is not aliased.; // That is, from the mangler's perspective we have a structure like this:; // namespace[s] -> type[ -> template-parameters]; // but from the Clang perspective we have; // type [ -> template-parameters]; // \-> namespace[s]; // What we do is we create a new mangler, mangle the same type (without; // a namespace suffix) to a string using the extra mangler and then use; // the mangled type name as a key to check the mangling of different types; // for aliasing.; // It's important to key cache reads off ND, not TD -- the same TD can; // be used with different TemplateArgs, but ND uniquely identifies; // TD / TemplateArg pairs.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/MicrosoftMangle.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/MicrosoftMangle.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/MicrosoftMangle.cpp:40,Modifiability,variab,variable,40,// Mangle a GUID object as if it were a variable with the corresponding; // mangled name.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/MicrosoftMangle.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/MicrosoftMangle.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/MicrosoftMangle.cpp:12,Usability,GUID,GUID,12,// Mangle a GUID object as if it were a variable with the corresponding; // mangled name.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/MicrosoftMangle.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/MicrosoftMangle.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/MicrosoftMangle.cpp:23,Modifiability,variab,variable,23,"// If the context is a variable or a class member and not a parameter,; // it is encoded in a qualified name.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/MicrosoftMangle.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/MicrosoftMangle.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/MicrosoftMangle.cpp:87,Integrability,depend,depends,87,// This is reachable only when constructing an outlined SEH finally; // block. Nothing depends on this mangling and it's used only with; // functinos with internal linkage.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/MicrosoftMangle.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/MicrosoftMangle.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/MicrosoftMangle.cpp:144,Availability,avail,available,144,// See if it's worth creating a back reference.; // Only types longer than 1 character are considered; // and only 10 back references slots are available:,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/MicrosoftMangle.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/MicrosoftMangle.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/MicrosoftMangle.cpp:7,Integrability,depend,dependent,7,// The dependent expression has to be folded into a constant (TODO).,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/MicrosoftMangle.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/MicrosoftMangle.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/MicrosoftMangle.cpp:39,Availability,down,down,39,"// For pointer size address spaces, go down the same type mangling path as; // non address space types.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/MicrosoftMangle.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/MicrosoftMangle.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/MicrosoftMangle.cpp:8,Integrability,interface,interfaces,8,// ObjC interfaces have structs underlying them.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/MicrosoftMangle.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/MicrosoftMangle.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/MicrosoftMangle.cpp:30,Security,access,access,30,"// Usually the thunk uses the access specifier of the new method, but if this; // is a covariant return thunk, then MSVC always uses the public access; // specifier, and we do the same.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/MicrosoftMangle.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/MicrosoftMangle.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/MicrosoftMangle.cpp:144,Security,access,access,144,"// Usually the thunk uses the access specifier of the new method, but if this; // is a covariant return thunk, then MSVC always uses the public access; // specifier, and we do the same.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/MicrosoftMangle.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/MicrosoftMangle.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/MicrosoftMangle.cpp:309,Modifiability,variab,variables,309,"// <guard-name> ::= ?_B <postfix> @5 <scope-depth>; // ::= ?__J <postfix> @5 <scope-depth>; // ::= ?$S <guard-num> @ <postfix> @4IA; // The first mangling is what MSVC uses to guard static locals in inline; // functions. It uses a different mangling in external functions to support; // guarding more than 32 variables. MSVC rejects inline functions with more; // than 32 static locals. We don't fully implement the second mangling; // because those guards are not externally visible, and instead use LLVM's; // default renaming when creating a new guard variable.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/MicrosoftMangle.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/MicrosoftMangle.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/MicrosoftMangle.cpp:555,Modifiability,variab,variable,555,"// <guard-name> ::= ?_B <postfix> @5 <scope-depth>; // ::= ?__J <postfix> @5 <scope-depth>; // ::= ?$S <guard-num> @ <postfix> @4IA; // The first mangling is what MSVC uses to guard static locals in inline; // functions. It uses a different mangling in external functions to support; // guarding more than 32 variables. MSVC rejects inline functions with more; // than 32 static locals. We don't fully implement the second mangling; // because those guards are not externally visible, and instead use LLVM's; // default renaming when creating a new guard variable.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/MicrosoftMangle.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/MicrosoftMangle.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/MicrosoftMangle.cpp:62,Modifiability,variab,variable,62,"// If we do not have a discriminator and are emitting a guard variable for; // use at global scope, then mangling the nested name will not be enough to; // remove ambiguities.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/MicrosoftMangle.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/MicrosoftMangle.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/MicrosoftMangle.cpp:46,Testability,stub,stubs,46,"// This is the function class mangling. These stubs are global, non-variadic,; // cdecl functions that return void and take no args.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/MicrosoftMangle.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/MicrosoftMangle.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/MicrosoftMangle.cpp:355,Usability,simpl,simple,355,"// <char-type> ::= 0 # char, char16_t, char32_t; // # (little endian char data in mangling); // ::= 1 # wchar_t (big endian char data in mangling); //; // <literal-length> ::= <non-negative integer> # the length of the literal; //; // <encoded-crc> ::= <hex digit>+ @ # crc of the literal including; // # trailing null bytes; //; // <encoded-string> ::= <simple character> # uninteresting character; // ::= '?$' <hex digit> <hex digit> # these two nibbles; // # encode the byte for the; // # character; // ::= '?' [a-z] # \xe1 - \xfa; // ::= '?' [A-Z] # \xc1 - \xda; // ::= '?' [0-9] # [,/\:. \n\t'-]; //; // <literal> ::= '??_C@_' <char-type> <literal-length> <encoded-crc>; // <encoded-string> '@'",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/MicrosoftMangle.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/MicrosoftMangle.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/NestedNameSpecifier.cpp:42,Integrability,depend,dependent,42,// Identifier specifiers always represent dependent types,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/NestedNameSpecifier.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/NestedNameSpecifier.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/NestedNameSpecifier.cpp:37,Integrability,depend,dependent,37,// FIXME: must also be instantiation-dependent.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/NestedNameSpecifier.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/NestedNameSpecifier.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/NestedNameSpecifier.cpp:287,Integrability,depend,dependent,287,"// Nested-name-specifiers are intended to contain minimally-qualified; // types. An actual ElaboratedType will not occur, since we'll store; // just the type that is referred to in the nested-name-specifier (e.g.,; // a TypedefType, TagType, etc.). However, when we are dealing with; // dependent template-id types (e.g., Outer<T>::template Inner<U>),; // the type requires its own nested-name-specifier for uniqueness, so we; // suppress that nested-name-specifier during printing.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/NestedNameSpecifier.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/NestedNameSpecifier.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/NestedNameSpecifier.cpp:4,Performance,Load,Load,4,/// Load a (possibly unaligned) source location from a given address; /// and offset.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/NestedNameSpecifier.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/NestedNameSpecifier.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/NestedNameSpecifier.cpp:4,Performance,Load,Load,4,/// Load a (possibly unaligned) pointer from a given address and; /// offset.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/NestedNameSpecifier.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/NestedNameSpecifier.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/NestedNameSpecifier.cpp:124,Energy Efficiency,allocate,allocated,124,"// FIXME: After copying the source-location information, should we free; // our (temporary) buffer and adopt the ASTContext-allocated memory?; // Doing so would optimize repeated calls to getWithLocInContext().",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/NestedNameSpecifier.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/NestedNameSpecifier.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/NestedNameSpecifier.cpp:161,Performance,optimiz,optimize,161,"// FIXME: After copying the source-location information, should we free; // our (temporary) buffer and adopt the ASTContext-allocated memory?; // Doing so would optimize repeated calls to getWithLocInContext().",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/NestedNameSpecifier.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/NestedNameSpecifier.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ODRDiagsEmitter.cpp:15,Security,hash,hash,15,// Compute the hash of the method as if it has no body.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ODRDiagsEmitter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ODRDiagsEmitter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ODRDiagsEmitter.cpp:161,Safety,detect,detecting,161,"// Compare the hash generated to the hash stored. A difference means; // that a body was present in the original source. Due to merging,; // the standard way of detecting a body will not work.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ODRDiagsEmitter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ODRDiagsEmitter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ODRDiagsEmitter.cpp:15,Security,hash,hash,15,"// Compare the hash generated to the hash stored. A difference means; // that a body was present in the original source. Due to merging,; // the standard way of detecting a body will not work.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ODRDiagsEmitter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ODRDiagsEmitter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ODRDiagsEmitter.cpp:37,Security,hash,hash,37,"// Compare the hash generated to the hash stored. A difference means; // that a body was present in the original source. Due to merging,; // the standard way of detecting a body will not work.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ODRDiagsEmitter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ODRDiagsEmitter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ODRDiagsEmitter.cpp:9,Availability,error,error,9,"// If no error has been generated before now, assume the problem is in; // the body and generate a message.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ODRDiagsEmitter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ODRDiagsEmitter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ODRDiagsEmitter.cpp:99,Integrability,message,message,99,"// If no error has been generated before now, assume the problem is in; // the body and generate a message.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ODRDiagsEmitter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ODRDiagsEmitter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ODRDiagsEmitter.cpp:14,Integrability,interface,interfaces,14,// Check both interfaces reference the same protocols.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ODRDiagsEmitter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ODRDiagsEmitter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ODRDiagsEmitter.cpp:44,Integrability,protocol,protocols,44,// Check both interfaces reference the same protocols.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ODRDiagsEmitter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ODRDiagsEmitter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ODRDiagsEmitter.cpp:16,Security,access,access,16,// Check if the access match.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ODRDiagsEmitter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ODRDiagsEmitter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ODRDiagsEmitter.cpp:14,Integrability,protocol,protocols,14,// Check both protocols reference the same protocols.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ODRDiagsEmitter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ODRDiagsEmitter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ODRDiagsEmitter.cpp:43,Integrability,protocol,protocols,43,// Check both protocols reference the same protocols.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ODRDiagsEmitter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ODRDiagsEmitter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ODRHash.cpp:46,Availability,failure,failures,46,"//===-- ODRHash.cpp - Hashing to diagnose ODR failures ----------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; ///; /// \file; /// This file implements the ODRHash class, which calculates a hash based; /// on AST nodes, which is stable across different runs.; ///; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ODRHash.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ODRHash.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ODRHash.cpp:22,Security,Hash,Hashing,22,"//===-- ODRHash.cpp - Hashing to diagnose ODR failures ----------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; ///; /// \file; /// This file implements the ODRHash class, which calculates a hash based; /// on AST nodes, which is stable across different runs.; ///; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ODRHash.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ODRHash.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ODRHash.cpp:455,Security,hash,hash,455,"//===-- ODRHash.cpp - Hashing to diagnose ODR failures ----------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; ///; /// \file; /// This file implements the ODRHash class, which calculates a hash based; /// on AST nodes, which is stable across different runs.; ///; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ODRHash.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ODRHash.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ODRHash.cpp:119,Security,hash,hash,119,"// There are integrals (e.g.: _BitInt(128)) that cannot be represented as; // any builtin integral type, so we use the hash of APSInt instead.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ODRHash.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ODRHash.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ODRHash.cpp:19,Integrability,protocol,protocols,19,// Hash referenced protocols.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ODRHash.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ODRHash.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ODRHash.cpp:3,Security,Hash,Hash,3,// Hash referenced protocols.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ODRHash.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ODRHash.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ODRHash.cpp:38,Integrability,protocol,protocol,38,// Hash the name only as a referenced protocol can be a forward declaration.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ODRHash.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ODRHash.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ODRHash.cpp:3,Security,Hash,Hash,3,// Hash the name only as a referenced protocol can be a forward declaration.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ODRHash.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ODRHash.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ODRHash.cpp:19,Integrability,protocol,protocols,19,// Hash referenced protocols.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ODRHash.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ODRHash.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ODRHash.cpp:3,Security,Hash,Hash,3,// Hash referenced protocols.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ODRHash.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ODRHash.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ODRHash.cpp:38,Integrability,protocol,protocol,38,// Hash the name only as a referenced protocol can be a forward declaration.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ODRHash.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ODRHash.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ODRHash.cpp:3,Security,Hash,Hash,3,// Hash the name only as a referenced protocol can be a forward declaration.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ODRHash.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ODRHash.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ODRHash.cpp:102,Energy Efficiency,reduce,reduce,102,// If this was a specialization we should take into account its template; // arguments. This helps to reduce collisions coming when visiting template; // specialization types (eg. when processing type template arguments).,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ODRHash.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ODRHash.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ODRHash.cpp:50,Security,hash,hash,50,"// 'APValue::Profile' uses pointer values to make hash for LValue and; // MemberPointer, but they differ from one compiler invocation to another.; // So, handle them explicitly here.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ODRHash.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ODRHash.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/OpenMPClause.cpp:3,Energy Efficiency,Allocate,Allocate,3,// Allocate space for private variables and initializer expressions.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/OpenMPClause.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/OpenMPClause.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/OpenMPClause.cpp:30,Modifiability,variab,variables,30,// Allocate space for private variables and initializer expressions.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/OpenMPClause.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/OpenMPClause.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/OpenMPClause.cpp:44,Deployability,Update,Updates,44,"// Allocate space for 5 lists (Vars, Inits, Updates, Finals), 2 expressions; // (Step and CalcStep), list of used expression + step.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/OpenMPClause.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/OpenMPClause.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/OpenMPClause.cpp:3,Energy Efficiency,Allocate,Allocate,3,"// Allocate space for 5 lists (Vars, Inits, Updates, Finals), 2 expressions; // (Step and CalcStep), list of used expression + step.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/OpenMPClause.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/OpenMPClause.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/OpenMPClause.cpp:8,Deployability,update,update,8,"// Fill update and final expressions with zeroes, they are provided later,; // after the directive construction.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/OpenMPClause.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/OpenMPClause.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/OpenMPClause.cpp:44,Deployability,Update,Updates,44,"// Allocate space for 5 lists (Vars, Inits, Updates, Finals), 2 expressions; // (Step and CalcStep), list of used expression + step.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/OpenMPClause.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/OpenMPClause.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/OpenMPClause.cpp:3,Energy Efficiency,Allocate,Allocate,3,"// Allocate space for 5 lists (Vars, Inits, Updates, Finals), 2 expressions; // (Step and CalcStep), list of used expression + step.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/OpenMPClause.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/OpenMPClause.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/OpenMPClause.cpp:3,Energy Efficiency,Allocate,Allocate,3,// Allocate space for private variables and initializer expressions.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/OpenMPClause.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/OpenMPClause.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/OpenMPClause.cpp:30,Modifiability,variab,variables,30,// Allocate space for private variables and initializer expressions.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/OpenMPClause.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/OpenMPClause.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/OpenMPClause.cpp:2,Integrability,depend,depend-modifier,2,/*depend-modifier*/,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/OpenMPClause.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/OpenMPClause.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/OpenMPClause.cpp:2,Integrability,depend,depend-modifier,2,/*depend-modifier*/,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/OpenMPClause.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/OpenMPClause.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/OpenMPClause.cpp:14,Energy Efficiency,allocate,allocate,14,// We need to allocate:; // 2 x NumVars x Expr* - we have an original list expression and an associated; // user-defined mapper for each clause list entry.; // NumUniqueDeclarations x ValueDecl* - unique base declarations associated; // with each component list.; // (NumUniqueDeclarations + NumComponentLists) x unsigned - we specify the; // number of lists for each unique declaration and the size of each component; // list.; // NumComponents x MappableComponent - the total of all the components in all; // the lists.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/OpenMPClause.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/OpenMPClause.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/OpenMPClause.cpp:14,Energy Efficiency,allocate,allocate,14,// We need to allocate:; // 2 x NumVars x Expr* - we have an original list expression and an associated; // user-defined mapper for each clause list entry.; // NumUniqueDeclarations x ValueDecl* - unique base declarations associated; // with each component list.; // (NumUniqueDeclarations + NumComponentLists) x unsigned - we specify the; // number of lists for each unique declaration and the size of each component; // list.; // NumComponents x MappableComponent - the total of all the components in all; // the lists.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/OpenMPClause.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/OpenMPClause.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/OpenMPClause.cpp:14,Energy Efficiency,allocate,allocate,14,// We need to allocate:; // 2 x NumVars x Expr* - we have an original list expression and an associated; // user-defined mapper for each clause list entry.; // NumUniqueDeclarations x ValueDecl* - unique base declarations associated; // with each component list.; // (NumUniqueDeclarations + NumComponentLists) x unsigned - we specify the; // number of lists for each unique declaration and the size of each component; // list.; // NumComponents x MappableComponent - the total of all the components in all; // the lists.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/OpenMPClause.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/OpenMPClause.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/OpenMPClause.cpp:14,Energy Efficiency,allocate,allocate,14,// We need to allocate:; // NumVars x Expr* - we have an original list expression for each clause; // list entry.; // NumUniqueDeclarations x ValueDecl* - unique base declarations associated; // with each component list.; // (NumUniqueDeclarations + NumComponentLists) x unsigned - we specify the; // number of lists for each unique declaration and the size of each component; // list.; // NumComponents x MappableComponent - the total of all the components in all; // the lists.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/OpenMPClause.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/OpenMPClause.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/OpenMPClause.cpp:14,Energy Efficiency,allocate,allocate,14,// We need to allocate:; // 3 x NumVars x Expr* - we have an original list expression for each clause; // list entry and an equal number of private copies and inits.; // NumUniqueDeclarations x ValueDecl* - unique base declarations associated; // with each component list.; // (NumUniqueDeclarations + NumComponentLists) x unsigned - we specify the; // number of lists for each unique declaration and the size of each component; // list.; // NumComponents x MappableComponent - the total of all the components in all; // the lists.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/OpenMPClause.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/OpenMPClause.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/OpenMPClause.cpp:14,Energy Efficiency,allocate,allocate,14,// We need to allocate:; // NumVars x Expr* - we have an original list expression for each clause list; // entry.; // NumUniqueDeclarations x ValueDecl* - unique base declarations associated; // with each component list.; // (NumUniqueDeclarations + NumComponentLists) x unsigned - we specify the; // number of lists for each unique declaration and the size of each component; // list.; // NumComponents x MappableComponent - the total of all the components in all; // the lists.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/OpenMPClause.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/OpenMPClause.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/OpenMPClause.cpp:14,Energy Efficiency,allocate,allocate,14,// We need to allocate:; // NumVars x Expr* - we have an original list expression for each clause list; // entry.; // NumUniqueDeclarations x ValueDecl* - unique base declarations associated; // with each component list.; // (NumUniqueDeclarations + NumComponentLists) x unsigned - we specify the; // number of lists for each unique declaration and the size of each component; // list.; // NumComponents x MappableComponent - the total of all the components in all; // the lists.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/OpenMPClause.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/OpenMPClause.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/OpenMPClause.cpp:3,Energy Efficiency,Allocate,Allocate,3,// Allocate space for nontemporal variables + private references.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/OpenMPClause.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/OpenMPClause.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/OpenMPClause.cpp:34,Modifiability,variab,variables,34,// Allocate space for nontemporal variables + private references.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/OpenMPClause.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/OpenMPClause.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ParentMap.cpp:33,Usability,clear,clear,33,"// If we are rebuilding the map, clear out any existing state.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ParentMap.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ParentMap.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ParentMap.cpp:39,Energy Efficiency,consumption,consumption,39,// Ignore parents that don't guarantee consumption.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ParentMap.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ParentMap.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ParentMapContext.cpp:100,Availability,avail,available,100,"// FIXME: Currently we add the same parent multiple times, but only; // when no memoization data is available for the type.; // For example when we visit all subexpressions of template; // instantiations; this is suboptimal, but benign: the only way to; // visit those is with hasAncestor / hasParent, and those do not create; // new matches.; // The plan is to enable DynTypedNode to be storable in a map or hash; // map. The main problem there is to implement hash functions /; // comparison operators for all types that DynTypedNode supports that; // do not have pointer identity.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ParentMapContext.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ParentMapContext.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ParentMapContext.cpp:409,Security,hash,hash,409,"// FIXME: Currently we add the same parent multiple times, but only; // when no memoization data is available for the type.; // For example when we visit all subexpressions of template; // instantiations; this is suboptimal, but benign: the only way to; // visit those is with hasAncestor / hasParent, and those do not create; // new matches.; // The plan is to enable DynTypedNode to be storable in a map or hash; // map. The main problem there is to implement hash functions /; // comparison operators for all types that DynTypedNode supports that; // do not have pointer identity.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ParentMapContext.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ParentMapContext.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ParentMapContext.cpp:462,Security,hash,hash,462,"// FIXME: Currently we add the same parent multiple times, but only; // when no memoization data is available for the type.; // For example when we visit all subexpressions of template; // instantiations; this is suboptimal, but benign: the only way to; // visit those is with hasAncestor / hasParent, and those do not create; // new matches.; // The plan is to enable DynTypedNode to be storable in a map or hash; // map. The main problem there is to implement hash functions /; // comparison operators for all types that DynTypedNode supports that; // do not have pointer identity.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ParentMapContext.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ParentMapContext.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/PrintfFormatString.cpp:53,Availability,error,errors,53,"// Detect spurious null characters, which are likely errors.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/PrintfFormatString.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/PrintfFormatString.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/PrintfFormatString.cpp:3,Safety,Detect,Detect,3,"// Detect spurious null characters, which are likely errors.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/PrintfFormatString.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/PrintfFormatString.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/PrintfFormatString.cpp:152,Availability,error,error,152,"// Look for the Objective-C modifier flags, if any.; // We parse these here, even if they don't apply to; // the conversion specifier, and then emit an error; // later if the conversion specifier isn't '@'. This; // enables better recovery, and we don't know if; // these flags are applicable until later.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/PrintfFormatString.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/PrintfFormatString.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/PrintfFormatString.cpp:231,Availability,recover,recovery,231,"// Look for the Objective-C modifier flags, if any.; // We parse these here, even if they don't apply to; // the conversion specifier, and then emit an error; // later if the conversion specifier isn't '@'. This; // enables better recovery, and we don't know if; // these flags are applicable until later.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/PrintfFormatString.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/PrintfFormatString.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/PrintfFormatString.cpp:231,Safety,recover,recovery,231,"// Look for the Objective-C modifier flags, if any.; // We parse these here, even if they don't apply to; // the conversion specifier, and then emit an error; // later if the conversion specifier isn't '@'. This; // enables better recovery, and we don't know if; // these flags are applicable until later.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/PrintfFormatString.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/PrintfFormatString.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/PrintfFormatString.cpp:53,Availability,error,errors,53,"// Detect spurious null characters, which are likely errors.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/PrintfFormatString.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/PrintfFormatString.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/PrintfFormatString.cpp:3,Safety,Detect,Detect,3,"// Detect spurious null characters, which are likely errors.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/PrintfFormatString.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/PrintfFormatString.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/PrintfFormatString.cpp:19,Availability,error,error,19,"// Did a fail-stop error of any kind occur when parsing the specifier?; // If so, don't do any more processing.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/PrintfFormatString.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/PrintfFormatString.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/PrintfFormatString.cpp:45,Availability,error,error,45,// Did we exhaust the string or encounter an error that; // we can recover from?,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/PrintfFormatString.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/PrintfFormatString.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/PrintfFormatString.cpp:67,Availability,recover,recover,67,// Did we exhaust the string or encounter an error that; // we can recover from?,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/PrintfFormatString.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/PrintfFormatString.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/PrintfFormatString.cpp:67,Safety,recover,recover,67,// Did we exhaust the string or encounter an error that; // we can recover from?,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/PrintfFormatString.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/PrintfFormatString.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/PrintfFormatString.cpp:19,Availability,error,error,19,"// Did a fail-stop error of any kind occur when parsing the specifier?; // If so, don't do any more processing.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/PrintfFormatString.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/PrintfFormatString.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/PrintfFormatString.cpp:45,Availability,error,error,45,// Did we exhaust the string or encounter an error that; // we can recover from?,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/PrintfFormatString.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/PrintfFormatString.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/PrintfFormatString.cpp:67,Availability,recover,recover,67,// Did we exhaust the string or encounter an error that; // we can recover from?,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/PrintfFormatString.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/PrintfFormatString.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/PrintfFormatString.cpp:67,Safety,recover,recover,67,// Did we exhaust the string or encounter an error that; // we can recover from?,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/PrintfFormatString.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/PrintfFormatString.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/PrintfFormatString.cpp:3,Testability,Test,Test,3,// Test for Floating type first as LongDouble can pass isUnsignedIntegerType,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/PrintfFormatString.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/PrintfFormatString.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/QualTypeNames.cpp:68,Integrability,depend,dependent,68,// ArgTDecl won't be NULL because we asserted that this isn't a; // dependent context very early in the call chain.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/QualTypeNames.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/QualTypeNames.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/QualTypeNames.cpp:37,Testability,assert,asserted,37,// ArgTDecl won't be NULL because we asserted that this isn't a; // dependent context very early in the call chain.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/QualTypeNames.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/QualTypeNames.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/QualTypeNames.cpp:191,Availability,error,error,191,"// DependentTemplateTypes exist within template declarations and; // definitions. Therefore we shouldn't encounter them at the end of; // a translation unit. If we do, the caller has made an error.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/QualTypeNames.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/QualTypeNames.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/QualTypeNames.cpp:3,Integrability,Depend,DependentTemplateTypes,3,"// DependentTemplateTypes exist within template declarations and; // definitions. Therefore we shouldn't encounter them at the end of; // a translation unit. If we do, the caller has made an error.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/QualTypeNames.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/QualTypeNames.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/QualTypeNames.cpp:71,Energy Efficiency,allocate,allocate,71,"// If a fully qualified arg is different from the unqualified arg,; // allocate new type in the AST.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/QualTypeNames.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/QualTypeNames.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/QualTypeNames.cpp:71,Energy Efficiency,allocate,allocate,71,"// If a fully qualified arg is different from the unqualified arg,; // allocate new type in the AST.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/QualTypeNames.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/QualTypeNames.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/QualTypeNames.cpp:97,Integrability,depend,dependent,97,"// We are in the case of a type(def) that was declared in a; // class template but is *not* type dependent. In clang, it; // gets attached to the class template declaration rather than; // any specific class template instantiation. This result in; // 'odd' fully qualified typename:; //; // vector<_Tp,_Alloc>::size_type; //; // Make the situation is 'useable' but looking a bit odd by; // picking a random instance as the declaring context.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/QualTypeNames.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/QualTypeNames.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/QualTypeNames.cpp:125,Security,access,accessible,125,"// Decl's context was neither the TU, a namespace, nor a; // TagDecl, which means it is a type local to a scope, and not; // accessible at the end of the TU.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/QualTypeNames.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/QualTypeNames.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Randstruct.cpp:74,Performance,cache,cache-line,74,// The Bucket class holds the struct fields we're trying to fill to a; // cache-line.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/Randstruct.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Randstruct.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Randstruct.cpp:46,Performance,cache,cache-line,46,// All of the Buckets produced by best-effort cache-line algorithm.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/Randstruct.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Randstruct.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Randstruct.cpp:64,Performance,cache,cache-line,64,// The current bucket of fields that we are trying to fill to a cache-line.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/Randstruct.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Randstruct.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Randstruct.cpp:27,Modifiability,flexible,flexible,27,"// Struct might end with a flexible array or an array of size 0 or 1,; // in which case we don't want to randomize it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/Randstruct.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Randstruct.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Randstruct.cpp:16,Modifiability,flexible,flexible,16,// Add back the flexible array.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/Randstruct.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Randstruct.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/RawCommentList.cpp:39,Security,access,accessor,39,// Lazily initialize RawText using the accessor before using it.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/RawCommentList.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/RawCommentList.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/RawCommentList.cpp:39,Security,access,accessor,39,// Lazily initialize RawText using the accessor before using it.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/RawCommentList.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/RawCommentList.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/RecordLayout.cpp:418,Integrability,interface,interface,418,"//===- RecordLayout.cpp - Layout information for a struct/union -----------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file defines the RecordLayout interface.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/RecordLayout.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/RecordLayout.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/RecordLayoutBuilder.cpp:373,Energy Efficiency,allocate,allocated,373,"/// BaseSubobjectInfo - Represents a single base subobject in a complete class.; /// For a class hierarchy like; ///; /// class A { };; /// class B : A { };; /// class C : A, B { };; ///; /// The BaseSubobjectInfo graph for C will have three BaseSubobjectInfo; /// instances, one for B and two for A.; ///; /// If a base is virtual, it will only have one BaseSubobjectInfo allocated.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/RecordLayoutBuilder.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/RecordLayoutBuilder.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/RecordLayoutBuilder.cpp:123,Availability,avail,available,123,"/// Externally provided layout. Typically used when the AST source, such; /// as DWARF, lacks all the information that was available at compile time, such; /// as alignment attributes on fields and pragmas in effect.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/RecordLayoutBuilder.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/RecordLayoutBuilder.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/RecordLayoutBuilder.cpp:92,Safety,avoid,avoid,92,"// If we have empty structures inside a union, we can assign both; // the same offset. Just avoid pushing them twice in the list.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/RecordLayoutBuilder.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/RecordLayoutBuilder.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/RecordLayoutBuilder.cpp:3,Deployability,Update,Update,3,// Update the empty class offset.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/RecordLayoutBuilder.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/RecordLayoutBuilder.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/RecordLayoutBuilder.cpp:23,Modifiability,variab,variables,23,// Traverse all member variables.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/RecordLayoutBuilder.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/RecordLayoutBuilder.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/RecordLayoutBuilder.cpp:23,Modifiability,variab,variables,23,// Traverse all member variables.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/RecordLayoutBuilder.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/RecordLayoutBuilder.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/RecordLayoutBuilder.cpp:62,Deployability,update,update,62,// We are able to place the base at this offset. Make sure to update the; // empty base subobject map.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/RecordLayoutBuilder.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/RecordLayoutBuilder.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/RecordLayoutBuilder.cpp:23,Modifiability,variab,variables,23,// Traverse all member variables.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/RecordLayoutBuilder.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/RecordLayoutBuilder.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/RecordLayoutBuilder.cpp:77,Deployability,update,update,77,// We are able to place the member variable at this offset.; // Make sure to update the empty field subobject map.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/RecordLayoutBuilder.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/RecordLayoutBuilder.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/RecordLayoutBuilder.cpp:35,Modifiability,variab,variable,35,// We are able to place the member variable at this offset.; // Make sure to update the empty field subobject map.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/RecordLayoutBuilder.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/RecordLayoutBuilder.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/RecordLayoutBuilder.cpp:23,Modifiability,variab,variables,23,// Traverse all member variables.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/RecordLayoutBuilder.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/RecordLayoutBuilder.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/RecordLayoutBuilder.cpp:39,Deployability,update,update,39,// If we have an array type we need to update every element.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/RecordLayoutBuilder.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/RecordLayoutBuilder.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/RecordLayoutBuilder.cpp:94,Modifiability,inherit,inheriting,94,"/// HasOwnVFPtr - Whether the class provides its own vtable/vftbl; /// pointer, as opposed to inheriting one from a primary base class.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/RecordLayoutBuilder.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/RecordLayoutBuilder.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/RecordLayoutBuilder.cpp:78,Modifiability,inherit,inheritance,78,/// FirstNearlyEmptyVBase - The first nearly empty virtual base class in; /// inheritance graph order. Used for determining the primary base class.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/RecordLayoutBuilder.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/RecordLayoutBuilder.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/RecordLayoutBuilder.cpp:79,Safety,avoid,avoid,79,"/// VisitedVirtualBases - A set of all the visited virtual bases, used to; /// avoid visiting virtual bases more than once.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/RecordLayoutBuilder.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/RecordLayoutBuilder.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/RecordLayoutBuilder.cpp:3,Deployability,Update,Update,3,// Update the alignment.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/RecordLayoutBuilder.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/RecordLayoutBuilder.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/RecordLayoutBuilder.cpp:8,Energy Efficiency,power,power,8,// AIX `power` alignment does not apply the preferred alignment for; // non-union classes if the source of the alignment (the current base in; // this context) follows introduction of the first subobject with; // exclusively allocated space or zero-extent array.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/RecordLayoutBuilder.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/RecordLayoutBuilder.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/RecordLayoutBuilder.cpp:225,Energy Efficiency,allocate,allocated,225,// AIX `power` alignment does not apply the preferred alignment for; // non-union classes if the source of the alignment (the current base in; // this context) follows introduction of the first subobject with; // exclusively allocated space or zero-extent array.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/RecordLayoutBuilder.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/RecordLayoutBuilder.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/RecordLayoutBuilder.cpp:78,Modifiability,inherit,inherited,78,"// By handling a base class that is not empty, we're handling the; // ""first (inherited) member"".",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/RecordLayoutBuilder.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/RecordLayoutBuilder.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/RecordLayoutBuilder.cpp:21,Deployability,update,update,21,"// On PS4/PS5, don't update the alignment, to preserve compatibility.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/RecordLayoutBuilder.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/RecordLayoutBuilder.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/RecordLayoutBuilder.cpp:3,Deployability,Update,Update,3,// Update the data size.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/RecordLayoutBuilder.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/RecordLayoutBuilder.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/RecordLayoutBuilder.cpp:3,Deployability,Update,Update,3,// Update based on external alignment.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/RecordLayoutBuilder.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/RecordLayoutBuilder.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/RecordLayoutBuilder.cpp:19,Energy Efficiency,allocate,allocated,19,"// The bitfield is allocated starting at the next offset aligned; // appropriately for T', with length n bits.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/RecordLayoutBuilder.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/RecordLayoutBuilder.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/RecordLayoutBuilder.cpp:3,Deployability,Update,Update,3,// Update the size.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/RecordLayoutBuilder.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/RecordLayoutBuilder.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/RecordLayoutBuilder.cpp:122,Availability,avail,available,122,"// UnfilledBitsInLastUnit is the difference between the end of the; // last allocated bitfield (i.e. the first bit offset available for; // bitfields) and the end of the current data size in bits (i.e. the; // first bit offset available for non-bitfields). The current data; // size in bits is always a multiple of the char size; additionally,; // for ms_struct records it's also a multiple of the; // LastBitfieldStorageUnitSize (if set).; // The struct-layout algorithm is dictated by the platform ABI,; // which in principle could use almost any rules it likes. In; // practice, UNIXy targets tend to inherit the algorithm described; // in the System V generic ABI. The basic bitfield layout rule in; // System V is to place bitfields at the next available bit offset; // where the entire bitfield would fit in an aligned storage unit of; // the declared type; it's okay if an earlier or later non-bitfield; // is allocated in the same storage unit. However, some targets; // (those that !useBitFieldTypeAlignment(), e.g. ARM APCS) don't; // require this storage unit to be aligned, and therefore always put; // the bitfield at the next available bit offset.; // ms_struct basically requests a complete replacement of the; // platform ABI's struct-layout algorithm, with the high-level goal; // of duplicating MSVC's layout. For non-bitfields, this follows; // the standard algorithm. The basic bitfield layout rule is to; // allocate an entire unit of the bitfield's declared type; // (e.g. 'unsigned long'), then parcel it up among successive; // bitfields whose declared types have the same size, making a new; // unit as soon as the last can no longer store the whole value.; // Since it completely replaces the platform ABI's algorithm,; // settings like !useBitFieldTypeAlignment() do not apply.; // A zero-width bitfield forces the use of a new storage unit for; // later bitfields. In general, this occurs by rounding up the; // current size of the struct as if the algorithm were about to;",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/RecordLayoutBuilder.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/RecordLayoutBuilder.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/RecordLayoutBuilder.cpp:227,Availability,avail,available,227,"// UnfilledBitsInLastUnit is the difference between the end of the; // last allocated bitfield (i.e. the first bit offset available for; // bitfields) and the end of the current data size in bits (i.e. the; // first bit offset available for non-bitfields). The current data; // size in bits is always a multiple of the char size; additionally,; // for ms_struct records it's also a multiple of the; // LastBitfieldStorageUnitSize (if set).; // The struct-layout algorithm is dictated by the platform ABI,; // which in principle could use almost any rules it likes. In; // practice, UNIXy targets tend to inherit the algorithm described; // in the System V generic ABI. The basic bitfield layout rule in; // System V is to place bitfields at the next available bit offset; // where the entire bitfield would fit in an aligned storage unit of; // the declared type; it's okay if an earlier or later non-bitfield; // is allocated in the same storage unit. However, some targets; // (those that !useBitFieldTypeAlignment(), e.g. ARM APCS) don't; // require this storage unit to be aligned, and therefore always put; // the bitfield at the next available bit offset.; // ms_struct basically requests a complete replacement of the; // platform ABI's struct-layout algorithm, with the high-level goal; // of duplicating MSVC's layout. For non-bitfields, this follows; // the standard algorithm. The basic bitfield layout rule is to; // allocate an entire unit of the bitfield's declared type; // (e.g. 'unsigned long'), then parcel it up among successive; // bitfields whose declared types have the same size, making a new; // unit as soon as the last can no longer store the whole value.; // Since it completely replaces the platform ABI's algorithm,; // settings like !useBitFieldTypeAlignment() do not apply.; // A zero-width bitfield forces the use of a new storage unit for; // later bitfields. In general, this occurs by rounding up the; // current size of the struct as if the algorithm were about to;",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/RecordLayoutBuilder.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/RecordLayoutBuilder.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/RecordLayoutBuilder.cpp:750,Availability,avail,available,750,"// UnfilledBitsInLastUnit is the difference between the end of the; // last allocated bitfield (i.e. the first bit offset available for; // bitfields) and the end of the current data size in bits (i.e. the; // first bit offset available for non-bitfields). The current data; // size in bits is always a multiple of the char size; additionally,; // for ms_struct records it's also a multiple of the; // LastBitfieldStorageUnitSize (if set).; // The struct-layout algorithm is dictated by the platform ABI,; // which in principle could use almost any rules it likes. In; // practice, UNIXy targets tend to inherit the algorithm described; // in the System V generic ABI. The basic bitfield layout rule in; // System V is to place bitfields at the next available bit offset; // where the entire bitfield would fit in an aligned storage unit of; // the declared type; it's okay if an earlier or later non-bitfield; // is allocated in the same storage unit. However, some targets; // (those that !useBitFieldTypeAlignment(), e.g. ARM APCS) don't; // require this storage unit to be aligned, and therefore always put; // the bitfield at the next available bit offset.; // ms_struct basically requests a complete replacement of the; // platform ABI's struct-layout algorithm, with the high-level goal; // of duplicating MSVC's layout. For non-bitfields, this follows; // the standard algorithm. The basic bitfield layout rule is to; // allocate an entire unit of the bitfield's declared type; // (e.g. 'unsigned long'), then parcel it up among successive; // bitfields whose declared types have the same size, making a new; // unit as soon as the last can no longer store the whole value.; // Since it completely replaces the platform ABI's algorithm,; // settings like !useBitFieldTypeAlignment() do not apply.; // A zero-width bitfield forces the use of a new storage unit for; // later bitfields. In general, this occurs by rounding up the; // current size of the struct as if the algorithm were about to;",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/RecordLayoutBuilder.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/RecordLayoutBuilder.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/RecordLayoutBuilder.cpp:1140,Availability,avail,available,1140,"ld (i.e. the first bit offset available for; // bitfields) and the end of the current data size in bits (i.e. the; // first bit offset available for non-bitfields). The current data; // size in bits is always a multiple of the char size; additionally,; // for ms_struct records it's also a multiple of the; // LastBitfieldStorageUnitSize (if set).; // The struct-layout algorithm is dictated by the platform ABI,; // which in principle could use almost any rules it likes. In; // practice, UNIXy targets tend to inherit the algorithm described; // in the System V generic ABI. The basic bitfield layout rule in; // System V is to place bitfields at the next available bit offset; // where the entire bitfield would fit in an aligned storage unit of; // the declared type; it's okay if an earlier or later non-bitfield; // is allocated in the same storage unit. However, some targets; // (those that !useBitFieldTypeAlignment(), e.g. ARM APCS) don't; // require this storage unit to be aligned, and therefore always put; // the bitfield at the next available bit offset.; // ms_struct basically requests a complete replacement of the; // platform ABI's struct-layout algorithm, with the high-level goal; // of duplicating MSVC's layout. For non-bitfields, this follows; // the standard algorithm. The basic bitfield layout rule is to; // allocate an entire unit of the bitfield's declared type; // (e.g. 'unsigned long'), then parcel it up among successive; // bitfields whose declared types have the same size, making a new; // unit as soon as the last can no longer store the whole value.; // Since it completely replaces the platform ABI's algorithm,; // settings like !useBitFieldTypeAlignment() do not apply.; // A zero-width bitfield forces the use of a new storage unit for; // later bitfields. In general, this occurs by rounding up the; // current size of the struct as if the algorithm were about to; // place a non-bitfield of the field's formal type. Usually this; // does not change the al",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/RecordLayoutBuilder.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/RecordLayoutBuilder.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/RecordLayoutBuilder.cpp:2866,Availability,avail,available,2866,"/ platform ABI's struct-layout algorithm, with the high-level goal; // of duplicating MSVC's layout. For non-bitfields, this follows; // the standard algorithm. The basic bitfield layout rule is to; // allocate an entire unit of the bitfield's declared type; // (e.g. 'unsigned long'), then parcel it up among successive; // bitfields whose declared types have the same size, making a new; // unit as soon as the last can no longer store the whole value.; // Since it completely replaces the platform ABI's algorithm,; // settings like !useBitFieldTypeAlignment() do not apply.; // A zero-width bitfield forces the use of a new storage unit for; // later bitfields. In general, this occurs by rounding up the; // current size of the struct as if the algorithm were about to; // place a non-bitfield of the field's formal type. Usually this; // does not change the alignment of the struct itself, but it does; // on some targets (those that useZeroLengthBitfieldAlignment(),; // e.g. ARM). In ms_struct layout, zero-width bitfields are; // ignored unless they follow a non-zero-width bitfield.; // A field alignment restriction (e.g. from #pragma pack) or; // specification (e.g. from __attribute__((aligned))) changes the; // formal alignment of the field. For System V, this alters the; // required alignment of the notional storage unit that must contain; // the bitfield. For ms_struct, this only affects the placement of; // new storage units. In both cases, the effect of #pragma pack is; // ignored on zero-width bitfields.; // On System V, a packed field (e.g. from #pragma pack or; // __attribute__((packed))) always uses the next available bit; // offset.; // In an ms_struct struct, the alignment of a fundamental type is; // always equal to its size. This is necessary in order to mimic; // the i386 alignment rules on targets which might not fully align; // all types (e.g. Darwin PPC32, where alignof(long long) == 4).; // First, some simple bookkeeping to perform for ms_struct structs.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/RecordLayoutBuilder.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/RecordLayoutBuilder.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/RecordLayoutBuilder.cpp:76,Energy Efficiency,allocate,allocated,76,"// UnfilledBitsInLastUnit is the difference between the end of the; // last allocated bitfield (i.e. the first bit offset available for; // bitfields) and the end of the current data size in bits (i.e. the; // first bit offset available for non-bitfields). The current data; // size in bits is always a multiple of the char size; additionally,; // for ms_struct records it's also a multiple of the; // LastBitfieldStorageUnitSize (if set).; // The struct-layout algorithm is dictated by the platform ABI,; // which in principle could use almost any rules it likes. In; // practice, UNIXy targets tend to inherit the algorithm described; // in the System V generic ABI. The basic bitfield layout rule in; // System V is to place bitfields at the next available bit offset; // where the entire bitfield would fit in an aligned storage unit of; // the declared type; it's okay if an earlier or later non-bitfield; // is allocated in the same storage unit. However, some targets; // (those that !useBitFieldTypeAlignment(), e.g. ARM APCS) don't; // require this storage unit to be aligned, and therefore always put; // the bitfield at the next available bit offset.; // ms_struct basically requests a complete replacement of the; // platform ABI's struct-layout algorithm, with the high-level goal; // of duplicating MSVC's layout. For non-bitfields, this follows; // the standard algorithm. The basic bitfield layout rule is to; // allocate an entire unit of the bitfield's declared type; // (e.g. 'unsigned long'), then parcel it up among successive; // bitfields whose declared types have the same size, making a new; // unit as soon as the last can no longer store the whole value.; // Since it completely replaces the platform ABI's algorithm,; // settings like !useBitFieldTypeAlignment() do not apply.; // A zero-width bitfield forces the use of a new storage unit for; // later bitfields. In general, this occurs by rounding up the; // current size of the struct as if the algorithm were about to;",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/RecordLayoutBuilder.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/RecordLayoutBuilder.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/RecordLayoutBuilder.cpp:917,Energy Efficiency,allocate,allocated,917,"// UnfilledBitsInLastUnit is the difference between the end of the; // last allocated bitfield (i.e. the first bit offset available for; // bitfields) and the end of the current data size in bits (i.e. the; // first bit offset available for non-bitfields). The current data; // size in bits is always a multiple of the char size; additionally,; // for ms_struct records it's also a multiple of the; // LastBitfieldStorageUnitSize (if set).; // The struct-layout algorithm is dictated by the platform ABI,; // which in principle could use almost any rules it likes. In; // practice, UNIXy targets tend to inherit the algorithm described; // in the System V generic ABI. The basic bitfield layout rule in; // System V is to place bitfields at the next available bit offset; // where the entire bitfield would fit in an aligned storage unit of; // the declared type; it's okay if an earlier or later non-bitfield; // is allocated in the same storage unit. However, some targets; // (those that !useBitFieldTypeAlignment(), e.g. ARM APCS) don't; // require this storage unit to be aligned, and therefore always put; // the bitfield at the next available bit offset.; // ms_struct basically requests a complete replacement of the; // platform ABI's struct-layout algorithm, with the high-level goal; // of duplicating MSVC's layout. For non-bitfields, this follows; // the standard algorithm. The basic bitfield layout rule is to; // allocate an entire unit of the bitfield's declared type; // (e.g. 'unsigned long'), then parcel it up among successive; // bitfields whose declared types have the same size, making a new; // unit as soon as the last can no longer store the whole value.; // Since it completely replaces the platform ABI's algorithm,; // settings like !useBitFieldTypeAlignment() do not apply.; // A zero-width bitfield forces the use of a new storage unit for; // later bitfields. In general, this occurs by rounding up the; // current size of the struct as if the algorithm were about to;",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/RecordLayoutBuilder.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/RecordLayoutBuilder.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/RecordLayoutBuilder.cpp:1429,Energy Efficiency,allocate,allocate,1429,"; // The struct-layout algorithm is dictated by the platform ABI,; // which in principle could use almost any rules it likes. In; // practice, UNIXy targets tend to inherit the algorithm described; // in the System V generic ABI. The basic bitfield layout rule in; // System V is to place bitfields at the next available bit offset; // where the entire bitfield would fit in an aligned storage unit of; // the declared type; it's okay if an earlier or later non-bitfield; // is allocated in the same storage unit. However, some targets; // (those that !useBitFieldTypeAlignment(), e.g. ARM APCS) don't; // require this storage unit to be aligned, and therefore always put; // the bitfield at the next available bit offset.; // ms_struct basically requests a complete replacement of the; // platform ABI's struct-layout algorithm, with the high-level goal; // of duplicating MSVC's layout. For non-bitfields, this follows; // the standard algorithm. The basic bitfield layout rule is to; // allocate an entire unit of the bitfield's declared type; // (e.g. 'unsigned long'), then parcel it up among successive; // bitfields whose declared types have the same size, making a new; // unit as soon as the last can no longer store the whole value.; // Since it completely replaces the platform ABI's algorithm,; // settings like !useBitFieldTypeAlignment() do not apply.; // A zero-width bitfield forces the use of a new storage unit for; // later bitfields. In general, this occurs by rounding up the; // current size of the struct as if the algorithm were about to; // place a non-bitfield of the field's formal type. Usually this; // does not change the alignment of the struct itself, but it does; // on some targets (those that useZeroLengthBitfieldAlignment(),; // e.g. ARM). In ms_struct layout, zero-width bitfields are; // ignored unless they follow a non-zero-width bitfield.; // A field alignment restriction (e.g. from #pragma pack) or; // specification (e.g. from __attribute__((aligned))) cha",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/RecordLayoutBuilder.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/RecordLayoutBuilder.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/RecordLayoutBuilder.cpp:604,Modifiability,inherit,inherit,604,"// UnfilledBitsInLastUnit is the difference between the end of the; // last allocated bitfield (i.e. the first bit offset available for; // bitfields) and the end of the current data size in bits (i.e. the; // first bit offset available for non-bitfields). The current data; // size in bits is always a multiple of the char size; additionally,; // for ms_struct records it's also a multiple of the; // LastBitfieldStorageUnitSize (if set).; // The struct-layout algorithm is dictated by the platform ABI,; // which in principle could use almost any rules it likes. In; // practice, UNIXy targets tend to inherit the algorithm described; // in the System V generic ABI. The basic bitfield layout rule in; // System V is to place bitfields at the next available bit offset; // where the entire bitfield would fit in an aligned storage unit of; // the declared type; it's okay if an earlier or later non-bitfield; // is allocated in the same storage unit. However, some targets; // (those that !useBitFieldTypeAlignment(), e.g. ARM APCS) don't; // require this storage unit to be aligned, and therefore always put; // the bitfield at the next available bit offset.; // ms_struct basically requests a complete replacement of the; // platform ABI's struct-layout algorithm, with the high-level goal; // of duplicating MSVC's layout. For non-bitfields, this follows; // the standard algorithm. The basic bitfield layout rule is to; // allocate an entire unit of the bitfield's declared type; // (e.g. 'unsigned long'), then parcel it up among successive; // bitfields whose declared types have the same size, making a new; // unit as soon as the last can no longer store the whole value.; // Since it completely replaces the platform ABI's algorithm,; // settings like !useBitFieldTypeAlignment() do not apply.; // A zero-width bitfield forces the use of a new storage unit for; // later bitfields. In general, this occurs by rounding up the; // current size of the struct as if the algorithm were about to;",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/RecordLayoutBuilder.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/RecordLayoutBuilder.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/RecordLayoutBuilder.cpp:3197,Performance,perform,perform,3197,"/ platform ABI's struct-layout algorithm, with the high-level goal; // of duplicating MSVC's layout. For non-bitfields, this follows; // the standard algorithm. The basic bitfield layout rule is to; // allocate an entire unit of the bitfield's declared type; // (e.g. 'unsigned long'), then parcel it up among successive; // bitfields whose declared types have the same size, making a new; // unit as soon as the last can no longer store the whole value.; // Since it completely replaces the platform ABI's algorithm,; // settings like !useBitFieldTypeAlignment() do not apply.; // A zero-width bitfield forces the use of a new storage unit for; // later bitfields. In general, this occurs by rounding up the; // current size of the struct as if the algorithm were about to; // place a non-bitfield of the field's formal type. Usually this; // does not change the alignment of the struct itself, but it does; // on some targets (those that useZeroLengthBitfieldAlignment(),; // e.g. ARM). In ms_struct layout, zero-width bitfields are; // ignored unless they follow a non-zero-width bitfield.; // A field alignment restriction (e.g. from #pragma pack) or; // specification (e.g. from __attribute__((aligned))) changes the; // formal alignment of the field. For System V, this alters the; // required alignment of the notional storage unit that must contain; // the bitfield. For ms_struct, this only affects the placement of; // new storage units. In both cases, the effect of #pragma pack is; // ignored on zero-width bitfields.; // On System V, a packed field (e.g. from #pragma pack or; // __attribute__((packed))) always uses the next available bit; // offset.; // In an ms_struct struct, the alignment of a fundamental type is; // always equal to its size. This is necessary in order to mimic; // the i386 alignment rules on targets which might not fully align; // all types (e.g. Darwin PPC32, where alignof(long long) == 4).; // First, some simple bookkeeping to perform for ms_struct structs.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/RecordLayoutBuilder.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/RecordLayoutBuilder.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/RecordLayoutBuilder.cpp:3175,Usability,simpl,simple,3175,"/ platform ABI's struct-layout algorithm, with the high-level goal; // of duplicating MSVC's layout. For non-bitfields, this follows; // the standard algorithm. The basic bitfield layout rule is to; // allocate an entire unit of the bitfield's declared type; // (e.g. 'unsigned long'), then parcel it up among successive; // bitfields whose declared types have the same size, making a new; // unit as soon as the last can no longer store the whole value.; // Since it completely replaces the platform ABI's algorithm,; // settings like !useBitFieldTypeAlignment() do not apply.; // A zero-width bitfield forces the use of a new storage unit for; // later bitfields. In general, this occurs by rounding up the; // current size of the struct as if the algorithm were about to; // place a non-bitfield of the field's formal type. Usually this; // does not change the alignment of the struct itself, but it does; // on some targets (those that useZeroLengthBitfieldAlignment(),; // e.g. ARM). In ms_struct layout, zero-width bitfields are; // ignored unless they follow a non-zero-width bitfield.; // A field alignment restriction (e.g. from #pragma pack) or; // specification (e.g. from __attribute__((aligned))) changes the; // formal alignment of the field. For System V, this alters the; // required alignment of the notional storage unit that must contain; // the bitfield. For ms_struct, this only affects the placement of; // new storage units. In both cases, the effect of #pragma pack is; // ignored on zero-width bitfields.; // On System V, a packed field (e.g. from #pragma pack or; // __attribute__((packed))) always uses the next available bit; // offset.; // In an ms_struct struct, the alignment of a fundamental type is; // always equal to its size. This is necessary in order to mimic; // the i386 alignment rules on targets which might not fully align; // all types (e.g. Darwin PPC32, where alignof(long long) == 4).; // First, some simple bookkeeping to perform for ms_struct structs.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/RecordLayoutBuilder.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/RecordLayoutBuilder.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/RecordLayoutBuilder.cpp:20,Availability,avail,available,20,// Compute the next available bit offset.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/RecordLayoutBuilder.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/RecordLayoutBuilder.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/RecordLayoutBuilder.cpp:3,Deployability,Update,Update,3,"// Update DataSize to include the last byte containing (part of) the bitfield.; // For unions, this is just a max operation, as usual.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/RecordLayoutBuilder.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/RecordLayoutBuilder.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/RecordLayoutBuilder.cpp:18,Energy Efficiency,allocate,allocate,18,"// For ms_struct, allocate the entire storage unit --- unless this; // is a zero-width bitfield, in which case just use a size of 1.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/RecordLayoutBuilder.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/RecordLayoutBuilder.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/RecordLayoutBuilder.cpp:14,Energy Efficiency,allocate,allocate,14,"// Otherwise, allocate just the number of bytes required to store; // the bitfield.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/RecordLayoutBuilder.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/RecordLayoutBuilder.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/RecordLayoutBuilder.cpp:54,Energy Efficiency,allocate,allocate,54,"// For non-zero-width bitfields in ms_struct structs, allocate a new; // storage unit if necessary.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/RecordLayoutBuilder.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/RecordLayoutBuilder.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/RecordLayoutBuilder.cpp:18,Usability,clear,cleared,18,// We should have cleared UnfilledBitsInLastUnit in every case; // where we changed storage units.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/RecordLayoutBuilder.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/RecordLayoutBuilder.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/RecordLayoutBuilder.cpp:3,Deployability,Update,Update,3,// Update the size.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/RecordLayoutBuilder.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/RecordLayoutBuilder.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/RecordLayoutBuilder.cpp:3,Modifiability,Flexible,Flexible,3,"// Flexible array members don't have any size, but they have to be; // aligned appropriately for their element type.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/RecordLayoutBuilder.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/RecordLayoutBuilder.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/RecordLayoutBuilder.cpp:153,Availability,down,down,153,"// If MS bitfield layout is required, figure out what type is being; // laid out and align the field to the width of that type.; // Resolve all typedefs down to their base type and round up the field; // alignment if necessary.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/RecordLayoutBuilder.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/RecordLayoutBuilder.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/RecordLayoutBuilder.cpp:997,Availability,error,error,997,"// Base types with sizes that aren't a power of two don't work; // with the layout rules for MS structs. This isn't an issue in; // MSVC itself since there are no such base data types there.; // On e.g. x86_32 mingw and linux, long double is 12 bytes though.; // Any structs involving that data type obviously can't be ABI; // compatible with MSVC regardless of how it is laid out.; // Since ms_struct can be mass enabled (via a pragma or via the; // -mms-bitfields command line parameter), this can trigger for; // structs that don't actually need MSVC compatibility, so we; // need to be able to sidestep the ms_struct layout for these types.; // Since the combination of -mms-bitfields together with structs; // like max_align_t (which contains a long double) for mingw is; // quite common (and GCC handles it silently), just handle it; // silently there. For other targets that have ms_struct enabled; // (most probably via a pragma or attribute), trigger a diagnostic; // that defaults to an error.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/RecordLayoutBuilder.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/RecordLayoutBuilder.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/RecordLayoutBuilder.cpp:39,Energy Efficiency,power,power,39,"// Base types with sizes that aren't a power of two don't work; // with the layout rules for MS structs. This isn't an issue in; // MSVC itself since there are no such base data types there.; // On e.g. x86_32 mingw and linux, long double is 12 bytes though.; // Any structs involving that data type obviously can't be ABI; // compatible with MSVC regardless of how it is laid out.; // Since ms_struct can be mass enabled (via a pragma or via the; // -mms-bitfields command line parameter), this can trigger for; // structs that don't actually need MSVC compatibility, so we; // need to be able to sidestep the ms_struct layout for these types.; // Since the combination of -mms-bitfields together with structs; // like max_align_t (which contains a long double) for mingw is; // quite common (and GCC handles it silently), just handle it; // silently there. For other targets that have ms_struct enabled; // (most probably via a pragma or attribute), trigger a diagnostic; // that defaults to an error.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/RecordLayoutBuilder.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/RecordLayoutBuilder.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/RecordLayoutBuilder.cpp:224,Deployability,upgrade,upgrade,224,"// When used as part of a typedef, or together with a 'packed' attribute, the; // 'aligned' attribute can be used to decrease alignment. In that case, it; // overrides any computed alignment we have, and there is no need to upgrade; // the alignment.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/RecordLayoutBuilder.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/RecordLayoutBuilder.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/RecordLayoutBuilder.cpp:123,Deployability,upgrade,upgrade,123,"// Enum alignment sources can be safely ignored here, because this only; // helps decide whether we need the AIX alignment upgrade, which only; // applies to floating-point types.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/RecordLayoutBuilder.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/RecordLayoutBuilder.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/RecordLayoutBuilder.cpp:33,Safety,safe,safely,33,"// Enum alignment sources can be safely ignored here, because this only; // helps decide whether we need the AIX alignment upgrade, which only; // applies to floating-point types.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/RecordLayoutBuilder.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/RecordLayoutBuilder.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/RecordLayoutBuilder.cpp:12,Energy Efficiency,power,power,12,"// The AIX `power` alignment rules apply the natural alignment of the; // ""first member"" if it is of a floating-point data type (or is an aggregate; // whose recursively ""first"" member or element is such a type). The alignment; // associated with these types for subsequent members use an alignment value; // where the floating-point data type is considered to have 4-byte alignment.; //; // For the purposes of the foregoing: vtable pointers, non-empty base classes,; // and zero-width bit-fields count as prior members; members of empty class; // types marked `no_unique_address` are not considered to be prior members.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/RecordLayoutBuilder.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/RecordLayoutBuilder.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/RecordLayoutBuilder.cpp:80,Integrability,message,message,80,/// Get diagnostic %select index for tag kind for; /// field padding diagnostic message.; /// WARNING: Indexes apply to particular diagnostics only!; ///; /// \returns diagnostic %select index.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/RecordLayoutBuilder.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/RecordLayoutBuilder.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/RecordLayoutBuilder.cpp:43,Integrability,interface,interfaces,43,"// We let objc ivars without warning, objc interfaces generally are not used; // for padding tricks.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/RecordLayoutBuilder.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/RecordLayoutBuilder.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/RecordLayoutBuilder.cpp:20,Modifiability,polymorphi,polymorphic,20,// If a class isn't polymorphic it doesn't have a key function.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/RecordLayoutBuilder.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/RecordLayoutBuilder.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/RecordLayoutBuilder.cpp:115,Security,access,accessible,115,"// While compiler may see key method in this TU, during CUDA; // compilation we should ignore methods that are not accessible; // on this side of compilation.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/RecordLayoutBuilder.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/RecordLayoutBuilder.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/RecordLayoutBuilder.cpp:5636,Availability,fault,fault,5636,"t from all of its fields and bases.; // * __declspec(align) on bitfields has the effect of changing the bitfield's; // alignment instead of its required alignment. This is the only known way; // to make the alignment of a struct bigger than 8. Interestingly enough; // this alignment is also immune to the effects of #pragma pack and can be; // used to create structures with large alignment under #pragma pack.; // However, because it does not impact required alignment, such a structure,; // when used as a field or base, will not be aligned if #pragma pack is; // still active at the time of use.; //; // Known incompatibilities:; // * all: #pragma pack between fields in a record; // * 2010 and back: If the last field in a record is a bitfield, every object; // laid out after the record will have extra padding inserted before it. The; // extra padding will have size equal to the size of the storage class of the; // bitfield. 0 sized bitfields don't exhibit this behavior and the extra; // padding can be avoided by adding a 0 sized bitfield after the non-zero-; // sized bitfield.; // * 2012 and back: In 64-bit mode, if the alignment of a record is 16 or; // greater due to __declspec(align()) then a second layout phase occurs after; // The locations of the vf and vb pointers are known. This layout phase; // suffers from the ""last field is a bitfield"" bug in 2010 and results in; // _every_ field getting padding put in front of it, potentially including the; // vfptr, leaving the vfprt at a non-zero location which results in a fault if; // anything tries to read the vftbl. The second layout phase also treats; // bitfields as separate entities and gives them each storage rather than; // packing them. Additionally, because this phase appears to perform a; // (an unstable) sort on the members before laying them out and because merged; // bitfields have the same address, the bitfields end up in whatever order; // the sort left them in, a behavior we could never hope to replicate.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/RecordLayoutBuilder.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/RecordLayoutBuilder.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/RecordLayoutBuilder.cpp:1477,Energy Efficiency,allocate,allocated,1477," the purposes of layout. All bases; // with vfptrs are laid out first, followed by all bases without vfptrs.; // * The Itanium equivalent vtable pointers are split into a vfptr (virtual; // function pointer) and a vbptr (virtual base pointer). They can each be; // shared with a, non-virtual bases. These bases need not be the same. vfptrs; // always occur at offset 0. vbptrs can occur at an arbitrary offset and are; // placed after the lexicographically last non-virtual base. This placement; // is always before fields but can be in the middle of the non-virtual bases; // due to the two-pass layout scheme for non-virtual-bases.; // * Virtual bases sometimes require a 'vtordisp' field that is laid out before; // the virtual base and is used in conjunction with virtual overrides during; // construction and destruction. This is always a 4 byte value and is used as; // an alternative to constructor vtables.; // * vtordisps are allocated in a block of memory with size and alignment equal; // to the alignment of the completed structure (before applying __declspec(; // align())). The vtordisp always occur at the end of the allocation block,; // immediately prior to the virtual base.; // * vfptrs are injected after all bases and fields have been laid out. In; // order to guarantee proper alignment of all fields, the vfptr injection; // pushes all bases and fields back by the alignment imposed by those bases; // and fields. This can potentially add a significant amount of padding.; // vfptrs are always injected at offset 0.; // * vbptrs are injected after all bases and fields have been laid out. In; // order to guarantee proper alignment of all fields, the vfptr injection; // pushes all bases and fields back by the alignment imposed by those bases; // and fields. This can potentially add a significant amount of padding.; // vbptrs are injected immediately after the last non-virtual base as; // lexicographically ordered in the code. If this site isn't pointer aligned; // the vbp",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/RecordLayoutBuilder.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/RecordLayoutBuilder.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/RecordLayoutBuilder.cpp:1752,Integrability,inject,injected,1752," base pointer). They can each be; // shared with a, non-virtual bases. These bases need not be the same. vfptrs; // always occur at offset 0. vbptrs can occur at an arbitrary offset and are; // placed after the lexicographically last non-virtual base. This placement; // is always before fields but can be in the middle of the non-virtual bases; // due to the two-pass layout scheme for non-virtual-bases.; // * Virtual bases sometimes require a 'vtordisp' field that is laid out before; // the virtual base and is used in conjunction with virtual overrides during; // construction and destruction. This is always a 4 byte value and is used as; // an alternative to constructor vtables.; // * vtordisps are allocated in a block of memory with size and alignment equal; // to the alignment of the completed structure (before applying __declspec(; // align())). The vtordisp always occur at the end of the allocation block,; // immediately prior to the virtual base.; // * vfptrs are injected after all bases and fields have been laid out. In; // order to guarantee proper alignment of all fields, the vfptr injection; // pushes all bases and fields back by the alignment imposed by those bases; // and fields. This can potentially add a significant amount of padding.; // vfptrs are always injected at offset 0.; // * vbptrs are injected after all bases and fields have been laid out. In; // order to guarantee proper alignment of all fields, the vfptr injection; // pushes all bases and fields back by the alignment imposed by those bases; // and fields. This can potentially add a significant amount of padding.; // vbptrs are injected immediately after the last non-virtual base as; // lexicographically ordered in the code. If this site isn't pointer aligned; // the vbptr is placed at the next properly aligned location. Enough padding; // is added to guarantee a fit.; // * The last zero sized non-virtual base can be placed at the end of the; // struct (potentially aliasing another object), or ",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/RecordLayoutBuilder.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/RecordLayoutBuilder.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/RecordLayoutBuilder.cpp:1876,Integrability,inject,injection,1876," occur at offset 0. vbptrs can occur at an arbitrary offset and are; // placed after the lexicographically last non-virtual base. This placement; // is always before fields but can be in the middle of the non-virtual bases; // due to the two-pass layout scheme for non-virtual-bases.; // * Virtual bases sometimes require a 'vtordisp' field that is laid out before; // the virtual base and is used in conjunction with virtual overrides during; // construction and destruction. This is always a 4 byte value and is used as; // an alternative to constructor vtables.; // * vtordisps are allocated in a block of memory with size and alignment equal; // to the alignment of the completed structure (before applying __declspec(; // align())). The vtordisp always occur at the end of the allocation block,; // immediately prior to the virtual base.; // * vfptrs are injected after all bases and fields have been laid out. In; // order to guarantee proper alignment of all fields, the vfptr injection; // pushes all bases and fields back by the alignment imposed by those bases; // and fields. This can potentially add a significant amount of padding.; // vfptrs are always injected at offset 0.; // * vbptrs are injected after all bases and fields have been laid out. In; // order to guarantee proper alignment of all fields, the vfptr injection; // pushes all bases and fields back by the alignment imposed by those bases; // and fields. This can potentially add a significant amount of padding.; // vbptrs are injected immediately after the last non-virtual base as; // lexicographically ordered in the code. If this site isn't pointer aligned; // the vbptr is placed at the next properly aligned location. Enough padding; // is added to guarantee a fit.; // * The last zero sized non-virtual base can be placed at the end of the; // struct (potentially aliasing another object), or may alias with the first; // field, even if they are of the same type.; // * The last zero size virtual base may be placed",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/RecordLayoutBuilder.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/RecordLayoutBuilder.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/RecordLayoutBuilder.cpp:2059,Integrability,inject,injected,2059,"fields but can be in the middle of the non-virtual bases; // due to the two-pass layout scheme for non-virtual-bases.; // * Virtual bases sometimes require a 'vtordisp' field that is laid out before; // the virtual base and is used in conjunction with virtual overrides during; // construction and destruction. This is always a 4 byte value and is used as; // an alternative to constructor vtables.; // * vtordisps are allocated in a block of memory with size and alignment equal; // to the alignment of the completed structure (before applying __declspec(; // align())). The vtordisp always occur at the end of the allocation block,; // immediately prior to the virtual base.; // * vfptrs are injected after all bases and fields have been laid out. In; // order to guarantee proper alignment of all fields, the vfptr injection; // pushes all bases and fields back by the alignment imposed by those bases; // and fields. This can potentially add a significant amount of padding.; // vfptrs are always injected at offset 0.; // * vbptrs are injected after all bases and fields have been laid out. In; // order to guarantee proper alignment of all fields, the vfptr injection; // pushes all bases and fields back by the alignment imposed by those bases; // and fields. This can potentially add a significant amount of padding.; // vbptrs are injected immediately after the last non-virtual base as; // lexicographically ordered in the code. If this site isn't pointer aligned; // the vbptr is placed at the next properly aligned location. Enough padding; // is added to guarantee a fit.; // * The last zero sized non-virtual base can be placed at the end of the; // struct (potentially aliasing another object), or may alias with the first; // field, even if they are of the same type.; // * The last zero size virtual base may be placed at the end of the struct; // potentially aliasing another object.; // * The ABI attempts to avoid aliasing of zero sized bases by adding padding; // between bases o",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/RecordLayoutBuilder.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/RecordLayoutBuilder.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/RecordLayoutBuilder.cpp:2098,Integrability,inject,injected,2098,"// due to the two-pass layout scheme for non-virtual-bases.; // * Virtual bases sometimes require a 'vtordisp' field that is laid out before; // the virtual base and is used in conjunction with virtual overrides during; // construction and destruction. This is always a 4 byte value and is used as; // an alternative to constructor vtables.; // * vtordisps are allocated in a block of memory with size and alignment equal; // to the alignment of the completed structure (before applying __declspec(; // align())). The vtordisp always occur at the end of the allocation block,; // immediately prior to the virtual base.; // * vfptrs are injected after all bases and fields have been laid out. In; // order to guarantee proper alignment of all fields, the vfptr injection; // pushes all bases and fields back by the alignment imposed by those bases; // and fields. This can potentially add a significant amount of padding.; // vfptrs are always injected at offset 0.; // * vbptrs are injected after all bases and fields have been laid out. In; // order to guarantee proper alignment of all fields, the vfptr injection; // pushes all bases and fields back by the alignment imposed by those bases; // and fields. This can potentially add a significant amount of padding.; // vbptrs are injected immediately after the last non-virtual base as; // lexicographically ordered in the code. If this site isn't pointer aligned; // the vbptr is placed at the next properly aligned location. Enough padding; // is added to guarantee a fit.; // * The last zero sized non-virtual base can be placed at the end of the; // struct (potentially aliasing another object), or may alias with the first; // field, even if they are of the same type.; // * The last zero size virtual base may be placed at the end of the struct; // potentially aliasing another object.; // * The ABI attempts to avoid aliasing of zero sized bases by adding padding; // between bases or vbases with specific properties. The criteria for; // add",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/RecordLayoutBuilder.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/RecordLayoutBuilder.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/RecordLayoutBuilder.cpp:2222,Integrability,inject,injection,2222,"is laid out before; // the virtual base and is used in conjunction with virtual overrides during; // construction and destruction. This is always a 4 byte value and is used as; // an alternative to constructor vtables.; // * vtordisps are allocated in a block of memory with size and alignment equal; // to the alignment of the completed structure (before applying __declspec(; // align())). The vtordisp always occur at the end of the allocation block,; // immediately prior to the virtual base.; // * vfptrs are injected after all bases and fields have been laid out. In; // order to guarantee proper alignment of all fields, the vfptr injection; // pushes all bases and fields back by the alignment imposed by those bases; // and fields. This can potentially add a significant amount of padding.; // vfptrs are always injected at offset 0.; // * vbptrs are injected after all bases and fields have been laid out. In; // order to guarantee proper alignment of all fields, the vfptr injection; // pushes all bases and fields back by the alignment imposed by those bases; // and fields. This can potentially add a significant amount of padding.; // vbptrs are injected immediately after the last non-virtual base as; // lexicographically ordered in the code. If this site isn't pointer aligned; // the vbptr is placed at the next properly aligned location. Enough padding; // is added to guarantee a fit.; // * The last zero sized non-virtual base can be placed at the end of the; // struct (potentially aliasing another object), or may alias with the first; // field, even if they are of the same type.; // * The last zero size virtual base may be placed at the end of the struct; // potentially aliasing another object.; // * The ABI attempts to avoid aliasing of zero sized bases by adding padding; // between bases or vbases with specific properties. The criteria for; // additional padding between two bases is that the first base is zero sized; // or ends with a zero sized subobject and the sec",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/RecordLayoutBuilder.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/RecordLayoutBuilder.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/RecordLayoutBuilder.cpp:2398,Integrability,inject,injected,2398,"structor vtables.; // * vtordisps are allocated in a block of memory with size and alignment equal; // to the alignment of the completed structure (before applying __declspec(; // align())). The vtordisp always occur at the end of the allocation block,; // immediately prior to the virtual base.; // * vfptrs are injected after all bases and fields have been laid out. In; // order to guarantee proper alignment of all fields, the vfptr injection; // pushes all bases and fields back by the alignment imposed by those bases; // and fields. This can potentially add a significant amount of padding.; // vfptrs are always injected at offset 0.; // * vbptrs are injected after all bases and fields have been laid out. In; // order to guarantee proper alignment of all fields, the vfptr injection; // pushes all bases and fields back by the alignment imposed by those bases; // and fields. This can potentially add a significant amount of padding.; // vbptrs are injected immediately after the last non-virtual base as; // lexicographically ordered in the code. If this site isn't pointer aligned; // the vbptr is placed at the next properly aligned location. Enough padding; // is added to guarantee a fit.; // * The last zero sized non-virtual base can be placed at the end of the; // struct (potentially aliasing another object), or may alias with the first; // field, even if they are of the same type.; // * The last zero size virtual base may be placed at the end of the struct; // potentially aliasing another object.; // * The ABI attempts to avoid aliasing of zero sized bases by adding padding; // between bases or vbases with specific properties. The criteria for; // additional padding between two bases is that the first base is zero sized; // or ends with a zero sized subobject and the second base is zero sized or; // trails with a zero sized base or field (sharing of vfptrs can reorder the; // layout of the so the leading base is not always the first one declared).; // This rule does ",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/RecordLayoutBuilder.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/RecordLayoutBuilder.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/RecordLayoutBuilder.cpp:3628,Integrability,depend,depends,3628,"ero sized non-virtual base can be placed at the end of the; // struct (potentially aliasing another object), or may alias with the first; // field, even if they are of the same type.; // * The last zero size virtual base may be placed at the end of the struct; // potentially aliasing another object.; // * The ABI attempts to avoid aliasing of zero sized bases by adding padding; // between bases or vbases with specific properties. The criteria for; // additional padding between two bases is that the first base is zero sized; // or ends with a zero sized subobject and the second base is zero sized or; // trails with a zero sized base or field (sharing of vfptrs can reorder the; // layout of the so the leading base is not always the first one declared).; // This rule does take into account fields that are not records, so padding; // will occur even if the last field is, e.g. an int. The padding added for; // bases is 1 byte. The padding added between vbases depends on the alignment; // of the object but is at least 4 bytes (in both 32 and 64 bit modes).; // * There is no concept of non-virtual alignment, non-virtual alignment and; // alignment are always identical.; // * There is a distinction between alignment and required alignment.; // __declspec(align) changes the required alignment of a struct. This; // alignment is _always_ obeyed, even in the presence of #pragma pack. A; // record inherits required alignment from all of its fields and bases.; // * __declspec(align) on bitfields has the effect of changing the bitfield's; // alignment instead of its required alignment. This is the only known way; // to make the alignment of a struct bigger than 8. Interestingly enough; // this alignment is also immune to the effects of #pragma pack and can be; // used to create structures with large alignment under #pragma pack.; // However, because it does not impact required alignment, such a structure,; // when used as a field or base, will not be aligned if #pragma pack is; // ",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/RecordLayoutBuilder.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/RecordLayoutBuilder.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/RecordLayoutBuilder.cpp:4067,Modifiability,inherit,inherits,4067,"s. The criteria for; // additional padding between two bases is that the first base is zero sized; // or ends with a zero sized subobject and the second base is zero sized or; // trails with a zero sized base or field (sharing of vfptrs can reorder the; // layout of the so the leading base is not always the first one declared).; // This rule does take into account fields that are not records, so padding; // will occur even if the last field is, e.g. an int. The padding added for; // bases is 1 byte. The padding added between vbases depends on the alignment; // of the object but is at least 4 bytes (in both 32 and 64 bit modes).; // * There is no concept of non-virtual alignment, non-virtual alignment and; // alignment are always identical.; // * There is a distinction between alignment and required alignment.; // __declspec(align) changes the required alignment of a struct. This; // alignment is _always_ obeyed, even in the presence of #pragma pack. A; // record inherits required alignment from all of its fields and bases.; // * __declspec(align) on bitfields has the effect of changing the bitfield's; // alignment instead of its required alignment. This is the only known way; // to make the alignment of a struct bigger than 8. Interestingly enough; // this alignment is also immune to the effects of #pragma pack and can be; // used to create structures with large alignment under #pragma pack.; // However, because it does not impact required alignment, such a structure,; // when used as a field or base, will not be aligned if #pragma pack is; // still active at the time of use.; //; // Known incompatibilities:; // * all: #pragma pack between fields in a record; // * 2010 and back: If the last field in a record is a bitfield, every object; // laid out after the record will have extra padding inserted before it. The; // extra padding will have size equal to the size of the storage class of the; // bitfield. 0 sized bitfields don't exhibit this behavior and the extra; // ",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/RecordLayoutBuilder.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/RecordLayoutBuilder.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/RecordLayoutBuilder.cpp:5856,Performance,perform,perform,5856,"t from all of its fields and bases.; // * __declspec(align) on bitfields has the effect of changing the bitfield's; // alignment instead of its required alignment. This is the only known way; // to make the alignment of a struct bigger than 8. Interestingly enough; // this alignment is also immune to the effects of #pragma pack and can be; // used to create structures with large alignment under #pragma pack.; // However, because it does not impact required alignment, such a structure,; // when used as a field or base, will not be aligned if #pragma pack is; // still active at the time of use.; //; // Known incompatibilities:; // * all: #pragma pack between fields in a record; // * 2010 and back: If the last field in a record is a bitfield, every object; // laid out after the record will have extra padding inserted before it. The; // extra padding will have size equal to the size of the storage class of the; // bitfield. 0 sized bitfields don't exhibit this behavior and the extra; // padding can be avoided by adding a 0 sized bitfield after the non-zero-; // sized bitfield.; // * 2012 and back: In 64-bit mode, if the alignment of a record is 16 or; // greater due to __declspec(align()) then a second layout phase occurs after; // The locations of the vf and vb pointers are known. This layout phase; // suffers from the ""last field is a bitfield"" bug in 2010 and results in; // _every_ field getting padding put in front of it, potentially including the; // vfptr, leaving the vfprt at a non-zero location which results in a fault if; // anything tries to read the vftbl. The second layout phase also treats; // bitfields as separate entities and gives them each storage rather than; // packing them. Additionally, because this phase appears to perform a; // (an unstable) sort on the members before laying them out and because merged; // bitfields have the same address, the bitfields end up in whatever order; // the sort left them in, a behavior we could never hope to replicate.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/RecordLayoutBuilder.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/RecordLayoutBuilder.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/RecordLayoutBuilder.cpp:2986,Safety,avoid,avoid,2986,"of padding.; // vfptrs are always injected at offset 0.; // * vbptrs are injected after all bases and fields have been laid out. In; // order to guarantee proper alignment of all fields, the vfptr injection; // pushes all bases and fields back by the alignment imposed by those bases; // and fields. This can potentially add a significant amount of padding.; // vbptrs are injected immediately after the last non-virtual base as; // lexicographically ordered in the code. If this site isn't pointer aligned; // the vbptr is placed at the next properly aligned location. Enough padding; // is added to guarantee a fit.; // * The last zero sized non-virtual base can be placed at the end of the; // struct (potentially aliasing another object), or may alias with the first; // field, even if they are of the same type.; // * The last zero size virtual base may be placed at the end of the struct; // potentially aliasing another object.; // * The ABI attempts to avoid aliasing of zero sized bases by adding padding; // between bases or vbases with specific properties. The criteria for; // additional padding between two bases is that the first base is zero sized; // or ends with a zero sized subobject and the second base is zero sized or; // trails with a zero sized base or field (sharing of vfptrs can reorder the; // layout of the so the leading base is not always the first one declared).; // This rule does take into account fields that are not records, so padding; // will occur even if the last field is, e.g. an int. The padding added for; // bases is 1 byte. The padding added between vbases depends on the alignment; // of the object but is at least 4 bytes (in both 32 and 64 bit modes).; // * There is no concept of non-virtual alignment, non-virtual alignment and; // alignment are always identical.; // * There is a distinction between alignment and required alignment.; // __declspec(align) changes the required alignment of a struct. This; // alignment is _always_ obeyed, even in th",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/RecordLayoutBuilder.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/RecordLayoutBuilder.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/RecordLayoutBuilder.cpp:5106,Safety,avoid,avoided,5106,"t from all of its fields and bases.; // * __declspec(align) on bitfields has the effect of changing the bitfield's; // alignment instead of its required alignment. This is the only known way; // to make the alignment of a struct bigger than 8. Interestingly enough; // this alignment is also immune to the effects of #pragma pack and can be; // used to create structures with large alignment under #pragma pack.; // However, because it does not impact required alignment, such a structure,; // when used as a field or base, will not be aligned if #pragma pack is; // still active at the time of use.; //; // Known incompatibilities:; // * all: #pragma pack between fields in a record; // * 2010 and back: If the last field in a record is a bitfield, every object; // laid out after the record will have extra padding inserted before it. The; // extra padding will have size equal to the size of the storage class of the; // bitfield. 0 sized bitfields don't exhibit this behavior and the extra; // padding can be avoided by adding a 0 sized bitfield after the non-zero-; // sized bitfield.; // * 2012 and back: In 64-bit mode, if the alignment of a record is 16 or; // greater due to __declspec(align()) then a second layout phase occurs after; // The locations of the vf and vb pointers are known. This layout phase; // suffers from the ""last field is a bitfield"" bug in 2010 and results in; // _every_ field getting padding put in front of it, potentially including the; // vfptr, leaving the vfprt at a non-zero location which results in a fault if; // anything tries to read the vftbl. The second layout phase also treats; // bitfields as separate entities and gives them each storage rather than; // packing them. Additionally, because this phase appears to perform a; // (an unstable) sort on the members before laying them out and because merged; // bitfields have the same address, the bitfields end up in whatever order; // the sort left them in, a behavior we could never hope to replicate.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/RecordLayoutBuilder.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/RecordLayoutBuilder.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/RecordLayoutBuilder.cpp:1752,Security,inject,injected,1752," base pointer). They can each be; // shared with a, non-virtual bases. These bases need not be the same. vfptrs; // always occur at offset 0. vbptrs can occur at an arbitrary offset and are; // placed after the lexicographically last non-virtual base. This placement; // is always before fields but can be in the middle of the non-virtual bases; // due to the two-pass layout scheme for non-virtual-bases.; // * Virtual bases sometimes require a 'vtordisp' field that is laid out before; // the virtual base and is used in conjunction with virtual overrides during; // construction and destruction. This is always a 4 byte value and is used as; // an alternative to constructor vtables.; // * vtordisps are allocated in a block of memory with size and alignment equal; // to the alignment of the completed structure (before applying __declspec(; // align())). The vtordisp always occur at the end of the allocation block,; // immediately prior to the virtual base.; // * vfptrs are injected after all bases and fields have been laid out. In; // order to guarantee proper alignment of all fields, the vfptr injection; // pushes all bases and fields back by the alignment imposed by those bases; // and fields. This can potentially add a significant amount of padding.; // vfptrs are always injected at offset 0.; // * vbptrs are injected after all bases and fields have been laid out. In; // order to guarantee proper alignment of all fields, the vfptr injection; // pushes all bases and fields back by the alignment imposed by those bases; // and fields. This can potentially add a significant amount of padding.; // vbptrs are injected immediately after the last non-virtual base as; // lexicographically ordered in the code. If this site isn't pointer aligned; // the vbptr is placed at the next properly aligned location. Enough padding; // is added to guarantee a fit.; // * The last zero sized non-virtual base can be placed at the end of the; // struct (potentially aliasing another object), or ",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/RecordLayoutBuilder.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/RecordLayoutBuilder.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/RecordLayoutBuilder.cpp:1876,Security,inject,injection,1876," occur at offset 0. vbptrs can occur at an arbitrary offset and are; // placed after the lexicographically last non-virtual base. This placement; // is always before fields but can be in the middle of the non-virtual bases; // due to the two-pass layout scheme for non-virtual-bases.; // * Virtual bases sometimes require a 'vtordisp' field that is laid out before; // the virtual base and is used in conjunction with virtual overrides during; // construction and destruction. This is always a 4 byte value and is used as; // an alternative to constructor vtables.; // * vtordisps are allocated in a block of memory with size and alignment equal; // to the alignment of the completed structure (before applying __declspec(; // align())). The vtordisp always occur at the end of the allocation block,; // immediately prior to the virtual base.; // * vfptrs are injected after all bases and fields have been laid out. In; // order to guarantee proper alignment of all fields, the vfptr injection; // pushes all bases and fields back by the alignment imposed by those bases; // and fields. This can potentially add a significant amount of padding.; // vfptrs are always injected at offset 0.; // * vbptrs are injected after all bases and fields have been laid out. In; // order to guarantee proper alignment of all fields, the vfptr injection; // pushes all bases and fields back by the alignment imposed by those bases; // and fields. This can potentially add a significant amount of padding.; // vbptrs are injected immediately after the last non-virtual base as; // lexicographically ordered in the code. If this site isn't pointer aligned; // the vbptr is placed at the next properly aligned location. Enough padding; // is added to guarantee a fit.; // * The last zero sized non-virtual base can be placed at the end of the; // struct (potentially aliasing another object), or may alias with the first; // field, even if they are of the same type.; // * The last zero size virtual base may be placed",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/RecordLayoutBuilder.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/RecordLayoutBuilder.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/RecordLayoutBuilder.cpp:2059,Security,inject,injected,2059,"fields but can be in the middle of the non-virtual bases; // due to the two-pass layout scheme for non-virtual-bases.; // * Virtual bases sometimes require a 'vtordisp' field that is laid out before; // the virtual base and is used in conjunction with virtual overrides during; // construction and destruction. This is always a 4 byte value and is used as; // an alternative to constructor vtables.; // * vtordisps are allocated in a block of memory with size and alignment equal; // to the alignment of the completed structure (before applying __declspec(; // align())). The vtordisp always occur at the end of the allocation block,; // immediately prior to the virtual base.; // * vfptrs are injected after all bases and fields have been laid out. In; // order to guarantee proper alignment of all fields, the vfptr injection; // pushes all bases and fields back by the alignment imposed by those bases; // and fields. This can potentially add a significant amount of padding.; // vfptrs are always injected at offset 0.; // * vbptrs are injected after all bases and fields have been laid out. In; // order to guarantee proper alignment of all fields, the vfptr injection; // pushes all bases and fields back by the alignment imposed by those bases; // and fields. This can potentially add a significant amount of padding.; // vbptrs are injected immediately after the last non-virtual base as; // lexicographically ordered in the code. If this site isn't pointer aligned; // the vbptr is placed at the next properly aligned location. Enough padding; // is added to guarantee a fit.; // * The last zero sized non-virtual base can be placed at the end of the; // struct (potentially aliasing another object), or may alias with the first; // field, even if they are of the same type.; // * The last zero size virtual base may be placed at the end of the struct; // potentially aliasing another object.; // * The ABI attempts to avoid aliasing of zero sized bases by adding padding; // between bases o",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/RecordLayoutBuilder.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/RecordLayoutBuilder.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/RecordLayoutBuilder.cpp:2098,Security,inject,injected,2098,"// due to the two-pass layout scheme for non-virtual-bases.; // * Virtual bases sometimes require a 'vtordisp' field that is laid out before; // the virtual base and is used in conjunction with virtual overrides during; // construction and destruction. This is always a 4 byte value and is used as; // an alternative to constructor vtables.; // * vtordisps are allocated in a block of memory with size and alignment equal; // to the alignment of the completed structure (before applying __declspec(; // align())). The vtordisp always occur at the end of the allocation block,; // immediately prior to the virtual base.; // * vfptrs are injected after all bases and fields have been laid out. In; // order to guarantee proper alignment of all fields, the vfptr injection; // pushes all bases and fields back by the alignment imposed by those bases; // and fields. This can potentially add a significant amount of padding.; // vfptrs are always injected at offset 0.; // * vbptrs are injected after all bases and fields have been laid out. In; // order to guarantee proper alignment of all fields, the vfptr injection; // pushes all bases and fields back by the alignment imposed by those bases; // and fields. This can potentially add a significant amount of padding.; // vbptrs are injected immediately after the last non-virtual base as; // lexicographically ordered in the code. If this site isn't pointer aligned; // the vbptr is placed at the next properly aligned location. Enough padding; // is added to guarantee a fit.; // * The last zero sized non-virtual base can be placed at the end of the; // struct (potentially aliasing another object), or may alias with the first; // field, even if they are of the same type.; // * The last zero size virtual base may be placed at the end of the struct; // potentially aliasing another object.; // * The ABI attempts to avoid aliasing of zero sized bases by adding padding; // between bases or vbases with specific properties. The criteria for; // add",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/RecordLayoutBuilder.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/RecordLayoutBuilder.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/RecordLayoutBuilder.cpp:2222,Security,inject,injection,2222,"is laid out before; // the virtual base and is used in conjunction with virtual overrides during; // construction and destruction. This is always a 4 byte value and is used as; // an alternative to constructor vtables.; // * vtordisps are allocated in a block of memory with size and alignment equal; // to the alignment of the completed structure (before applying __declspec(; // align())). The vtordisp always occur at the end of the allocation block,; // immediately prior to the virtual base.; // * vfptrs are injected after all bases and fields have been laid out. In; // order to guarantee proper alignment of all fields, the vfptr injection; // pushes all bases and fields back by the alignment imposed by those bases; // and fields. This can potentially add a significant amount of padding.; // vfptrs are always injected at offset 0.; // * vbptrs are injected after all bases and fields have been laid out. In; // order to guarantee proper alignment of all fields, the vfptr injection; // pushes all bases and fields back by the alignment imposed by those bases; // and fields. This can potentially add a significant amount of padding.; // vbptrs are injected immediately after the last non-virtual base as; // lexicographically ordered in the code. If this site isn't pointer aligned; // the vbptr is placed at the next properly aligned location. Enough padding; // is added to guarantee a fit.; // * The last zero sized non-virtual base can be placed at the end of the; // struct (potentially aliasing another object), or may alias with the first; // field, even if they are of the same type.; // * The last zero size virtual base may be placed at the end of the struct; // potentially aliasing another object.; // * The ABI attempts to avoid aliasing of zero sized bases by adding padding; // between bases or vbases with specific properties. The criteria for; // additional padding between two bases is that the first base is zero sized; // or ends with a zero sized subobject and the sec",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/RecordLayoutBuilder.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/RecordLayoutBuilder.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/RecordLayoutBuilder.cpp:2398,Security,inject,injected,2398,"structor vtables.; // * vtordisps are allocated in a block of memory with size and alignment equal; // to the alignment of the completed structure (before applying __declspec(; // align())). The vtordisp always occur at the end of the allocation block,; // immediately prior to the virtual base.; // * vfptrs are injected after all bases and fields have been laid out. In; // order to guarantee proper alignment of all fields, the vfptr injection; // pushes all bases and fields back by the alignment imposed by those bases; // and fields. This can potentially add a significant amount of padding.; // vfptrs are always injected at offset 0.; // * vbptrs are injected after all bases and fields have been laid out. In; // order to guarantee proper alignment of all fields, the vfptr injection; // pushes all bases and fields back by the alignment imposed by those bases; // and fields. This can potentially add a significant amount of padding.; // vbptrs are injected immediately after the last non-virtual base as; // lexicographically ordered in the code. If this site isn't pointer aligned; // the vbptr is placed at the next properly aligned location. Enough padding; // is added to guarantee a fit.; // * The last zero sized non-virtual base can be placed at the end of the; // struct (potentially aliasing another object), or may alias with the first; // field, even if they are of the same type.; // * The last zero size virtual base may be placed at the end of the struct; // potentially aliasing another object.; // * The ABI attempts to avoid aliasing of zero sized bases by adding padding; // between bases or vbases with specific properties. The criteria for; // additional padding between two bases is that the first base is zero sized; // or ends with a zero sized subobject and the second base is zero sized or; // trails with a zero sized base or field (sharing of vfptrs can reorder the; // layout of the so the leading base is not always the first one declared).; // This rule does ",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/RecordLayoutBuilder.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/RecordLayoutBuilder.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/RecordLayoutBuilder.cpp:92,Testability,test,tests,92,"// This section contains an implementation of struct layout that is, up to the; // included tests, compatible with cl.exe (2013). The layout produced is; // significantly different than those produced by the Itanium ABI. Here we note; // the most important differences.; //; // * The alignment of bitfields in unions is ignored when computing the; // alignment of the union.; // * The existence of zero-width bitfield that occurs after anything other than; // a non-zero length bitfield is ignored.; // * There is no explicit primary base for the purposes of layout. All bases; // with vfptrs are laid out first, followed by all bases without vfptrs.; // * The Itanium equivalent vtable pointers are split into a vfptr (virtual; // function pointer) and a vbptr (virtual base pointer). They can each be; // shared with a, non-virtual bases. These bases need not be the same. vfptrs; // always occur at offset 0. vbptrs can occur at an arbitrary offset and are; // placed after the lexicographically last non-virtual base. This placement; // is always before fields but can be in the middle of the non-virtual bases; // due to the two-pass layout scheme for non-virtual-bases.; // * Virtual bases sometimes require a 'vtordisp' field that is laid out before; // the virtual base and is used in conjunction with virtual overrides during; // construction and destruction. This is always a 4 byte value and is used as; // an alternative to constructor vtables.; // * vtordisps are allocated in a block of memory with size and alignment equal; // to the alignment of the completed structure (before applying __declspec(; // align())). The vtordisp always occur at the end of the allocation block,; // immediately prior to the virtual base.; // * vfptrs are injected after all bases and fields have been laid out. In; // order to guarantee proper alignment of all fields, the vfptr injection; // pushes all bases and fields back by the alignment imposed by those bases; // and fields. This can potentially a",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/RecordLayoutBuilder.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/RecordLayoutBuilder.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/RecordLayoutBuilder.cpp:111,Deployability,update,updates,111,/// Gets the size and alignment of a field taking pragma pack and; /// __declspec(align) into account. It also updates RequiredAlignment as a; /// side effect because it is most convenient to do so here.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/RecordLayoutBuilder.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/RecordLayoutBuilder.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/RecordLayoutBuilder.cpp:55,Availability,avail,available,55,// Track zero-sized subobjects here where it's already available.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/RecordLayoutBuilder.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/RecordLayoutBuilder.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/RecordLayoutBuilder.cpp:28,Performance,perform,perform,28,// In 64-bit mode we always perform an alignment step after laying out vbases.; // In 32-bit mode we do not. The check to see if we need to perform alignment; // checks the RequiredAlignment field and performs alignment if it isn't 0.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/RecordLayoutBuilder.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/RecordLayoutBuilder.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/RecordLayoutBuilder.cpp:140,Performance,perform,perform,140,// In 64-bit mode we always perform an alignment step after laying out vbases.; // In 32-bit mode we do not. The check to see if we need to perform alignment; // checks the RequiredAlignment field and performs alignment if it isn't 0.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/RecordLayoutBuilder.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/RecordLayoutBuilder.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/RecordLayoutBuilder.cpp:201,Performance,perform,performs,201,// In 64-bit mode we always perform an alignment step after laying out vbases.; // In 32-bit mode we do not. The check to see if we need to perform alignment; // checks the RequiredAlignment field and performs alignment if it isn't 0.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/RecordLayoutBuilder.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/RecordLayoutBuilder.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/RecordLayoutBuilder.cpp:80,Integrability,inject,injection,80,// Calculate pointer size and alignment. These are used for vfptr and vbprt; // injection.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/RecordLayoutBuilder.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/RecordLayoutBuilder.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/RecordLayoutBuilder.cpp:80,Security,inject,injection,80,// Calculate pointer size and alignment. These are used for vfptr and vbprt; // injection.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/RecordLayoutBuilder.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/RecordLayoutBuilder.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/RecordLayoutBuilder.cpp:27,Modifiability,extend,extendable,27,// Only lay out bases with extendable VFPtrs on the first pass.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/RecordLayoutBuilder.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/RecordLayoutBuilder.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/RecordLayoutBuilder.cpp:25,Modifiability,polymorphi,polymorphism,25,"// This class introduces polymorphism, so we need a vftable to store the; // RTTI information.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/RecordLayoutBuilder.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/RecordLayoutBuilder.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/RecordLayoutBuilder.cpp:13,Modifiability,polymorphi,polymorphic,13,// We have a polymorphic base class but can't extend its vftable. Add a; // new vfptr if we would use any vftable slots.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/RecordLayoutBuilder.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/RecordLayoutBuilder.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/RecordLayoutBuilder.cpp:46,Modifiability,extend,extend,46,// We have a polymorphic base class but can't extend its vftable. Add a; // new vfptr if we would use any vftable slots.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/RecordLayoutBuilder.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/RecordLayoutBuilder.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/RecordLayoutBuilder.cpp:30,Modifiability,extend,extendable,30,// Only lay out bases without extendable VFPtrs on the second pass.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/RecordLayoutBuilder.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/RecordLayoutBuilder.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/RecordLayoutBuilder.cpp:111,Availability,error,error,111,// Clamp the bitfield to a containable size for the sake of being able; // to lay them out. Sema will throw an error.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/RecordLayoutBuilder.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/RecordLayoutBuilder.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/RecordLayoutBuilder.cpp:3,Energy Efficiency,Allocate,Allocate,3,// Allocate a new block of memory and place the bitfield in it.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/RecordLayoutBuilder.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/RecordLayoutBuilder.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/RecordLayoutBuilder.cpp:3,Integrability,Inject,Inject,3,// Inject the VBPointer at the injection site.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/RecordLayoutBuilder.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/RecordLayoutBuilder.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/RecordLayoutBuilder.cpp:31,Integrability,inject,injection,31,// Inject the VBPointer at the injection site.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/RecordLayoutBuilder.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/RecordLayoutBuilder.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/RecordLayoutBuilder.cpp:3,Security,Inject,Inject,3,// Inject the VBPointer at the injection site.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/RecordLayoutBuilder.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/RecordLayoutBuilder.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/RecordLayoutBuilder.cpp:31,Security,inject,injection,31,// Inject the VBPointer at the injection site.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/RecordLayoutBuilder.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/RecordLayoutBuilder.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/RecordLayoutBuilder.cpp:36,Availability,down,down,36,"// Shift everything after the vbptr down, unless we're using an external; // layout.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/RecordLayoutBuilder.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/RecordLayoutBuilder.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/RecordLayoutBuilder.cpp:55,Integrability,interface,interface,55,// The class may have size 0 and a vfptr (e.g. it's an interface class). The; // size was not correctly set before in this case.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/RecordLayoutBuilder.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/RecordLayoutBuilder.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/RecordLayoutBuilder.cpp:150,Integrability,inject,injection,150,// The alignment of the vtordisp is at least the required alignment of the; // entire record. This requirement may be present to support vtordisp; // injection.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/RecordLayoutBuilder.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/RecordLayoutBuilder.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/RecordLayoutBuilder.cpp:150,Security,inject,injection,150,// The alignment of the vtordisp is at least the required alignment of the; // entire record. This requirement may be present to support vtordisp; // injection.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/RecordLayoutBuilder.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/RecordLayoutBuilder.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/RecordLayoutBuilder.cpp:113,Deployability,update,updated,113,// Respect required alignment. Note that in 32-bit mode Required alignment; // may be 0 and cause size not to be updated.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/RecordLayoutBuilder.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/RecordLayoutBuilder.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/RecordLayoutBuilder.cpp:9,Testability,assert,asserts,9,// These asserts test different things. A record has a definition; // as soon as we begin to parse the definition. That definition is; // not a complete definition (which is what isDefinition() tests); // until we *finish* parsing the definition.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/RecordLayoutBuilder.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/RecordLayoutBuilder.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/RecordLayoutBuilder.cpp:17,Testability,test,test,17,// These asserts test different things. A record has a definition; // as soon as we begin to parse the definition. That definition is; // not a complete definition (which is what isDefinition() tests); // until we *finish* parsing the definition.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/RecordLayoutBuilder.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/RecordLayoutBuilder.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/RecordLayoutBuilder.cpp:194,Testability,test,tests,194,// These asserts test different things. A record has a definition; // as soon as we begin to parse the definition. That definition is; // not a complete definition (which is what isDefinition() tests); // until we *finish* parsing the definition.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/RecordLayoutBuilder.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/RecordLayoutBuilder.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/RecordLayoutBuilder.cpp:113,Integrability,depend,dependent,113,"// In certain situations, we are allowed to lay out objects in the; // tail-padding of base classes. This is ABI-dependent.; // FIXME: this should be stored in the record layout.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/RecordLayoutBuilder.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/RecordLayoutBuilder.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/RecordLayoutBuilder.cpp:15,Performance,cache,cache,15,"// Look up the cache entry. Since we're working with the first; // declaration, its parent must be the class definition, which is; // the correct key for the KeyFunctions hash.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/RecordLayoutBuilder.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/RecordLayoutBuilder.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/RecordLayoutBuilder.cpp:171,Security,hash,hash,171,"// Look up the cache entry. Since we're working with the first; // declaration, its parent must be the class definition, which is; // the correct key for the KeyFunctions hash.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/RecordLayoutBuilder.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/RecordLayoutBuilder.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/RecordLayoutBuilder.cpp:15,Performance,cache,cached,15,"// If it's not cached, there's nothing to do.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/RecordLayoutBuilder.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/RecordLayoutBuilder.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/RecordLayoutBuilder.cpp:12,Performance,cache,cached,12,"// If it is cached, check whether it's the target method, and if so,; // remove it from the cache. Note, the call to 'get' might invalidate; // the iterator and the LazyDeclPtr object within the map.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/RecordLayoutBuilder.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/RecordLayoutBuilder.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/RecordLayoutBuilder.cpp:92,Performance,cache,cache,92,"// If it is cached, check whether it's the target method, and if so,; // remove it from the cache. Note, the call to 'get' might invalidate; // the iterator and the LazyDeclPtr object within the map.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/RecordLayoutBuilder.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/RecordLayoutBuilder.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/RecordLayoutBuilder.cpp:82,Integrability,interface,interface,82,"/// getObjCLayout - Get or compute information about the layout of the; /// given interface.; ///; /// \param Impl - If given, also include the layout of the interface's; /// implementation. This may differ by including synthesized ivars.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/RecordLayoutBuilder.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/RecordLayoutBuilder.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/RecordLayoutBuilder.cpp:158,Integrability,interface,interface,158,"/// getObjCLayout - Get or compute information about the layout of the; /// given interface.; ///; /// \param Impl - If given, also include the layout of the interface's; /// implementation. This may differ by including synthesized ivars.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/RecordLayoutBuilder.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/RecordLayoutBuilder.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/RecordLayoutBuilder.cpp:56,Integrability,interface,interface,56,// If there aren't any synthesized ivars then reuse the interface; // entry. Note we can't cache this because we simply free all; // entries later; however we shouldn't look up implementations; // frequently.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/RecordLayoutBuilder.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/RecordLayoutBuilder.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/RecordLayoutBuilder.cpp:91,Performance,cache,cache,91,// If there aren't any synthesized ivars then reuse the interface; // entry. Note we can't cache this because we simply free all; // entries later; however we shouldn't look up implementations; // frequently.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/RecordLayoutBuilder.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/RecordLayoutBuilder.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/RecordLayoutBuilder.cpp:113,Usability,simpl,simply,113,// If there aren't any synthesized ivars then reuse the interface; // entry. Note we can't cache this because we simply free all; // entries later; however we shouldn't look up implementations; // frequently.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/RecordLayoutBuilder.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/RecordLayoutBuilder.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/RecordLayoutBuilder.cpp:291,Deployability,update,update,291,"// The ""simple"" format is designed to be parsed by the; // layout-override testing code. There shouldn't be any external; // uses of this format --- when LLDB overrides a layout, it sets up; // the data structures directly --- so feel free to adjust this as; // you like as long as you also update the rudimentary parser for it; // in libFrontend.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/RecordLayoutBuilder.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/RecordLayoutBuilder.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/RecordLayoutBuilder.cpp:75,Testability,test,testing,75,"// The ""simple"" format is designed to be parsed by the; // layout-override testing code. There shouldn't be any external; // uses of this format --- when LLDB overrides a layout, it sets up; // the data structures directly --- so feel free to adjust this as; // you like as long as you also update the rudimentary parser for it; // in libFrontend.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/RecordLayoutBuilder.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/RecordLayoutBuilder.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/RecordLayoutBuilder.cpp:8,Usability,simpl,simple,8,"// The ""simple"" format is designed to be parsed by the; // layout-override testing code. There shouldn't be any external; // uses of this format --- when LLDB overrides a layout, it sets up; // the data structures directly --- so feel free to adjust this as; // you like as long as you also update the rudimentary parser for it; // in libFrontend.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/RecordLayoutBuilder.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/RecordLayoutBuilder.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ScanfFormatString.cpp:84,Modifiability,refactor,refactor,84,// FIXME: Much of this is copy-paste from ParsePrintfSpecifier.; // We can possibly refactor.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ScanfFormatString.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ScanfFormatString.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ScanfFormatString.cpp:53,Availability,error,errors,53,"// Detect spurious null characters, which are likely errors.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ScanfFormatString.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ScanfFormatString.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ScanfFormatString.cpp:3,Safety,Detect,Detect,3,"// Detect spurious null characters, which are likely errors.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ScanfFormatString.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ScanfFormatString.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ScanfFormatString.cpp:53,Availability,error,errors,53,"// Detect spurious null characters, which are likely errors.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ScanfFormatString.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ScanfFormatString.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ScanfFormatString.cpp:3,Safety,Detect,Detect,3,"// Detect spurious null characters, which are likely errors.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ScanfFormatString.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ScanfFormatString.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ScanfFormatString.cpp:19,Availability,error,error,19,"// Did a fail-stop error of any kind occur when parsing the specifier?; // If so, don't do any more processing.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ScanfFormatString.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ScanfFormatString.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ScanfFormatString.cpp:45,Availability,error,error,45,// Did we exhaust the string or encounter an error that; // we can recover from?,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ScanfFormatString.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ScanfFormatString.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ScanfFormatString.cpp:67,Availability,recover,recover,67,// Did we exhaust the string or encounter an error that; // we can recover from?,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ScanfFormatString.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ScanfFormatString.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ScanfFormatString.cpp:67,Safety,recover,recover,67,// Did we exhaust the string or encounter an error that; // we can recover from?,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ScanfFormatString.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ScanfFormatString.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Stmt.cpp:49,Modifiability,polymorphi,polymorphic,49,// Check that no statement / expression class is polymorphic. LLVM style RTTI; // should be used instead. If absolutely needed an exception can still be added; // here by defining the appropriate macro (but please don't do this).,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/Stmt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Stmt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Stmt.cpp:110,Energy Efficiency,allocate,allocated,110,// Check that no statement / expression class has a non-trival destructor.; // Statements and expressions are allocated with the BumpPtrAllocator from; // ASTContext and therefore their destructor is not executed.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/Stmt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Stmt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Stmt.cpp:136,Availability,error,errors,136,"/// AnalyzeAsmString - Analyze the asm string of the current asm, decomposing; /// it into pieces. If the asm string is erroneous, emit errors and return; /// true, otherwise return false.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/Stmt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Stmt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Stmt.cpp:4,Usability,Simpl,Simple,4,"// ""Simple"" inline asms have no constraints or operands, just convert the asm; // string to escape $'s.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/Stmt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Stmt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Stmt.cpp:10,Safety,Avoid,Avoid,10,// FIXME: Avoid the allocation/copy if at all possible.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/Stmt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Stmt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/StmtIterator.cpp:26,Integrability,depend,dependent-sized,26,// FIXME: Add support for dependent-sized array types in C++?; // Does it even make sense to build a CFG for an uninstantiated template?,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/StmtIterator.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/StmtIterator.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/StmtOpenMP.cpp:82,Deployability,update,update,82,"// Special case: 'omp target enter data', 'omp target exit data',; // 'omp target update' are stand-alone directives, but for implementation; // reasons they have empty synthetic structured block, to simplify codegen.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/StmtOpenMP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/StmtOpenMP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/StmtOpenMP.cpp:200,Usability,simpl,simplify,200,"// Special case: 'omp target enter data', 'omp target exit data',; // 'omp target update' are stand-alone directives, but for implementation; // reasons they have empty synthetic structured block, to simplify codegen.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/StmtOpenMP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/StmtOpenMP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/StmtOpenMP.cpp:122,Integrability,depend,dependent,122,"// The loop transformation construct has generated loops, but these; // may not have been generated yet due to being in a dependent; // context.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/StmtOpenMP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/StmtOpenMP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/StmtPrinter.cpp:30,Usability,simpl,simply,30,"// No need to print anything, simply forward to the subexpression.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/StmtPrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/StmtPrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/StmtPrinter.cpp:129,Usability,clear,clear,129,"// There's no way to express this expression in any of our supported; // languages, so just emit something terse and (hopefully) clear.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/StmtPrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/StmtPrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/StmtProfile.cpp:33,Modifiability,variab,variables,33,/// Process clauses with list of variables.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/StmtProfile.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/StmtProfile.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/StmtProfile.cpp:155,Usability,simpl,simple-requirement,155,// C++2a [expr.prim.req.compound]p1 Example:; // [...] The compound-requirement in C1 requires that x++ is a valid; // expression. It is equivalent to the simple-requirement x++; [...]; // We therefore do not profile isSimple() here.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/StmtProfile.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/StmtProfile.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/StmtProfile.cpp:150,Deployability,update,update,150,"// Work around https://developercommunity.visualstudio.com/content/problem/84002/clang-cl-when-built-with-vc-2017-crashes-cause-vc.html; // MSVC 2017 update 3 miscompiles this function, and a clang built with it; // will crash in stage 2 of a bootstrap build.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/StmtProfile.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/StmtProfile.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/StmtProfile.cpp:8,Integrability,depend,dependent,8,"// Type-dependent operator calls are profiled like their underlying; // syntactic operator.; //; // An operator call to operator-> is always implicit, so just skip it. The; // enclosing MemberExpr will profile the actual member access.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/StmtProfile.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/StmtProfile.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/StmtProfile.cpp:228,Security,access,access,228,"// Type-dependent operator calls are profiled like their underlying; // syntactic operator.; //; // An operator call to operator-> is always implicit, so just skip it. The; // enclosing MemberExpr will profile the actual member access.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/StmtProfile.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/StmtProfile.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/StmtProfile.cpp:48,Integrability,depend,dependent,48,"// If a rewritten operator were ever to be type-dependent, we should profile; // it following its syntactic operator.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/StmtProfile.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/StmtProfile.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/StmtProfile.cpp:129,Safety,safe,safe,129,"// Do not recursively visit the children of this expression. Profiling the; // body would result in unnecessary work, and is not safe to do during; // deserialization.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/StmtProfile.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/StmtProfile.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/TemplateBase.cpp:73,Modifiability,extend,extended,73,"// In Sema::CheckTemplateArugment, enum template arguments value are; // extended to the size of the integer underlying the enum type. This; // may create a size difference between the enum value and template; // argument value, requiring isSameValue here instead of operator==.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/TemplateBase.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/TemplateBase.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/TemplateBase.cpp:38,Security,expose,expose,38,// FIXME: The Declaration form should expose a const ValueDecl*.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/TemplateBase.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/TemplateBase.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/TemplateName.cpp:418,Integrability,interface,interface,418,"//===- TemplateName.cpp - C++ Template Name Representation ----------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file defines the TemplateName interface and subclasses.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/TemplateName.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/TemplateName.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/TemplateName.cpp:18,Integrability,depend,dependent,18,// Substituting a dependent template name: preserve it as written.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/TemplateName.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/TemplateName.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/TextNodeDumper.cpp:95,Usability,simpl,simple,95,// To save some vertical space we print up to MaxChildrenPerLine APValues; // considered to be simple (by isSimpleAPValue) on a single line.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/TextNodeDumper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/TextNodeDumper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/TextNodeDumper.cpp:42,Usability,simpl,simple,42,"// If the union value is considered to be simple, fold it into the; // current line to save some vertical space.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/TextNodeDumper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/TextNodeDumper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/TextNodeDumper.cpp:54,Availability,avail,available,54,// Can't translate locations if a SourceManager isn't available.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/TextNodeDumper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/TextNodeDumper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/TextNodeDumper.cpp:59,Availability,error,error,59,"// We could dump the deallocation function used in case of error, but it's; // usually not that interesting.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/TextNodeDumper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/TextNodeDumper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Type.cpp:40,Integrability,depend,dependent,40,"// C++ [temp.dep.type]p1:; // A type is dependent if it is...; // - an array type constructed from any dependent type or whose; // size is specified by a constant expression that is; // value-dependent,",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/Type.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Type.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Type.cpp:103,Integrability,depend,dependent,103,"// C++ [temp.dep.type]p1:; // A type is dependent if it is...; // - an array type constructed from any dependent type or whose; // size is specified by a constant expression that is; // value-dependent,",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/Type.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Type.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Type.cpp:192,Integrability,depend,dependent,192,"// C++ [temp.dep.type]p1:; // A type is dependent if it is...; // - an array type constructed from any dependent type or whose; // size is specified by a constant expression that is; // value-dependent,",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/Type.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Type.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Type.cpp:30,Integrability,Depend,DependentSizedArrayType,30,"// Note, we need to check for DependentSizedArrayType explicitly here; // because we use a DependentSizedArrayType with no size expression as the; // type of a dependent array of unknown bound with a dependent braced; // initializer:; //; // template<int ...N> int arr[] = {N...};",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/Type.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Type.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Type.cpp:91,Integrability,Depend,DependentSizedArrayType,91,"// Note, we need to check for DependentSizedArrayType explicitly here; // because we use a DependentSizedArrayType with no size expression as the; // type of a dependent array of unknown bound with a dependent braced; // initializer:; //; // template<int ...N> int arr[] = {N...};",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/Type.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Type.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Type.cpp:160,Integrability,depend,dependent,160,"// Note, we need to check for DependentSizedArrayType explicitly here; // because we use a DependentSizedArrayType with no size expression as the; // type of a dependent array of unknown bound with a dependent braced; // initializer:; //; // template<int ...N> int arr[] = {N...};",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/Type.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Type.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Type.cpp:200,Integrability,depend,dependent,200,"// Note, we need to check for DependentSizedArrayType explicitly here; // because we use a DependentSizedArrayType with no size expression as the; // type of a dependent array of unknown bound with a dependent braced; // initializer:; //; // template<int ...N> int arr[] = {N...};",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/Type.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Type.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Type.cpp:108,Energy Efficiency,allocate,allocates,108,"// Fast path the common cases so we can avoid the conservative computation; // below, which in common cases allocates ""large"" APSInt values, which are; // slow.; // If the element size is a power of 2, we can directly compute the additional; // number of addressing bits beyond those required for the element count.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/Type.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Type.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Type.cpp:190,Energy Efficiency,power,power,190,"// Fast path the common cases so we can avoid the conservative computation; // below, which in common cases allocates ""large"" APSInt values, which are; // slow.; // If the element size is a power of 2, we can directly compute the additional; // number of addressing bits beyond those required for the element count.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/Type.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Type.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Type.cpp:40,Safety,avoid,avoid,40,"// Fast path the common cases so we can avoid the conservative computation; // below, which in common cases allocates ""large"" APSInt values, which are; // slow.; // If the element size is a power of 2, we can directly compute the additional; // number of addressing bits beyond those required for the element count.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/Type.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Type.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Type.cpp:31,Modifiability,polymorphi,polymorphic,31,// Check that no type class is polymorphic. LLVM style RTTI should be used; // instead. If absolutely needed an exception can still be added here by; // defining the appropriate macro (but please don't do this).,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/Type.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Type.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Type.cpp:71,Energy Efficiency,allocate,allocated,71,// Check that no type class has a non-trival destructor. Types are; // allocated with the BumpPtrAllocator from ASTContext and therefore; // their destructor is not executed.; //; // FIXME: ConstantArrayType is not trivially destructible because of its; // APInt member. It should be replaced in favor of ASTContext allocation.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/Type.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Type.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Type.cpp:29,Safety,abort,aborting,29,"// Do a single-step desugar, aborting the loop if the type isn't; // sugared.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/Type.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Type.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Type.cpp:72,Deployability,update,update,72,"// Otherwise, split the underlying type. If that yields qualifiers,; // update the information.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/Type.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Type.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Type.cpp:46,Safety,safe,safe,46,// FIXME: this seems inherently un-qualifiers-safe.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/Type.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Type.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Type.cpp:18,Integrability,protocol,protocol,18,// Initialize the protocol qualifiers. The protocol storage is known; // after we set number of type arguments.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/Type.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Type.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Type.cpp:43,Integrability,protocol,protocol,43,// Initialize the protocol qualifiers. The protocol storage is known; // after we set number of type arguments.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/Type.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Type.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Type.cpp:30,Integrability,interface,interface,30,// Terminate when we reach an interface type.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/Type.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Type.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Type.cpp:30,Integrability,interface,interface,30,// Terminate when we reach an interface type.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/Type.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Type.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Type.cpp:30,Integrability,interface,interface,30,// Terminate when we reach an interface type.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/Type.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Type.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Type.cpp:2,Integrability,protocol,protocols,2,/*protocols=*/,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/Type.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Type.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Type.cpp:20,Performance,perform,perform,20,/// Visitor used to perform a simple type transformation that does not change; /// the semantics of the type.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/Type.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Type.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Type.cpp:30,Usability,simpl,simple,30,/// Visitor used to perform a simple type transformation that does not change; /// the semantics of the type.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/Type.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Type.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Type.cpp:76,Integrability,depend,dependent,76,"// None of the clients of this transformation can occur where; // there are dependent types, so skip dependent types.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/Type.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Type.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Type.cpp:101,Integrability,depend,dependent,101,"// None of the clients of this transformation can occur where; // there are dependent types, so skip dependent types.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/Type.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Type.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Type.cpp:13,Modifiability,extend,extended,13,// Transform extended info.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/Type.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Type.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Type.cpp:9,Integrability,protocol,protocol,9,// Apply protocol lists if exists.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/Type.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Type.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Type.cpp:31,Deployability,update,update,31,"// If we have a function type, update the substitution context; // appropriately.; //Substitute result type.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/Type.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Type.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Type.cpp:13,Modifiability,extend,extended,13,// Transform extended info.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/Type.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Type.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Type.cpp:56,Availability,down,down,56,"// Rebuild the ""equivalent"" type, which pushes __kindof down into; // the object type.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/Type.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Type.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Type.cpp:79,Performance,perform,perform,79,"// If we are in neither a class nor a category, there's no; // substitution to perform.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/Type.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Type.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Type.cpp:88,Performance,perform,perform,88,"// If the superclass doesn't have type parameters, then there is no; // substitution to perform.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/Type.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Type.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Type.cpp:26,Modifiability,parameteriz,parameterized,26,"// If the subclass is not parameterized, there aren't any type; // parameters in the superclass reference to substitute.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/Type.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Type.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Type.cpp:68,Integrability,rout,routine,68,"/// Determine whether this type is an integral type.; ///; /// This routine determines whether the given type is an integral type per; /// C++ [basic.fundamental]p7. Although the C standard does not define the; /// term ""integral type"", it has a similar term ""integer type"", and in C++; /// the two terms are equivalent. However, C's ""integer type"" includes; /// enumeration types, while C++'s ""integer type"" does not. The \c ASTContext; /// parameter is used to determine whether we should be following the C or; /// C++ rules when determining whether this type is an integral/integer type.; ///; /// For cases where C permits ""an integer type"" and C++ permits ""an integral; /// type"", use this routine.; ///; /// For cases where C permits ""an integer type"" and C++ permits ""an integral; /// or enumeration type"", use \c isIntegralOrEnumerationType() instead.; ///; /// \param Ctx The context in which this type occurs.; ///; /// \returns true if the type is considered an integral type, false otherwise.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/Type.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Type.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Type.cpp:696,Integrability,rout,routine,696,"/// Determine whether this type is an integral type.; ///; /// This routine determines whether the given type is an integral type per; /// C++ [basic.fundamental]p7. Although the C standard does not define the; /// term ""integral type"", it has a similar term ""integer type"", and in C++; /// the two terms are equivalent. However, C's ""integer type"" includes; /// enumeration types, while C++'s ""integer type"" does not. The \c ASTContext; /// parameter is used to determine whether we should be following the C or; /// C++ rules when determining whether this type is an integral/integer type.; ///; /// For cases where C permits ""an integer type"" and C++ permits ""an integral; /// type"", use this routine.; ///; /// For cases where C permits ""an integer type"" and C++ permits ""an integral; /// or enumeration type"", use \c isIntegralOrEnumerationType() instead.; ///; /// \param Ctx The context in which this type occurs.; ///; /// \returns true if the type is considered an integral type, false otherwise.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/Type.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Type.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Type.cpp:176,Integrability,depend,dependent,176,"/// isConstantSizeType - Return true if this is not a variable sized type,; /// according to the rules of C99 6.7.5p3. It is not legal to call this on; /// incomplete types or dependent types.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/Type.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Type.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Type.cpp:54,Modifiability,variab,variable,54,"/// isConstantSizeType - Return true if this is not a variable sized type,; /// according to the rules of C99 6.7.5p3. It is not legal to call this on; /// incomplete types or dependent types.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/Type.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Type.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Type.cpp:105,Integrability,depend,dependent-sized,105,// An array is incomplete if its element type is incomplete; // (C++ [dcl.array]p1).; // We don't handle dependent-sized arrays (dependent types are never treated; // as incomplete).,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/Type.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Type.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Type.cpp:129,Integrability,depend,dependent,129,// An array is incomplete if its element type is incomplete; // (C++ [dcl.array]p1).; // We don't handle dependent-sized arrays (dependent types are never treated; // as incomplete).,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/Type.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Type.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Type.cpp:158,Modifiability,inherit,inheritance,158,// Member pointers in the MS ABI have special behavior in; // RequireCompleteType: they attach a MSInheritanceAttr to the CXXRecordDecl; // to indicate which inheritance model to use.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/Type.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Type.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Type.cpp:24,Integrability,depend,dependent,24,// Member pointers with dependent class types don't get special treatment.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/Type.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Type.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Type.cpp:7,Modifiability,inherit,inheritance,7,"// The inheritance attribute might only be present on the most recent; // CXXRecordDecl, use that one.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/Type.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Type.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Type.cpp:36,Modifiability,inherit,inheritance,36,// Nothing interesting to do if the inheritance attribute is already set.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/Type.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Type.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Type.cpp:8,Integrability,interface,interfaces,8,"// ObjC interfaces are incomplete if they are @class, not @interface.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/Type.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Type.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Type.cpp:59,Integrability,interface,interface,59,"// ObjC interfaces are incomplete if they are @class, not @interface.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/Type.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Type.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Type.cpp:104,Performance,scalab,scalable,104,// Represent predicates as i8 rather than i1 to avoid any layout issues.; // The type is bitcasted to a scalable predicate type when casting between; // scalable and fixed-length vectors.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/Type.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Type.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Type.cpp:153,Performance,scalab,scalable,153,// Represent predicates as i8 rather than i1 to avoid any layout issues.; // The type is bitcasted to a scalable predicate type when casting between; // scalable and fixed-length vectors.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/Type.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Type.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Type.cpp:48,Safety,avoid,avoid,48,// Represent predicates as i8 rather than i1 to avoid any layout issues.; // The type is bitcasted to a scalable predicate type when casting between; // scalable and fixed-length vectors.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/Type.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Type.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Type.cpp:121,Availability,redundant,redundant,121,// This is effectively the intersection of isTrivialType and; // isStandardLayoutType. We implement it directly to avoid redundant; // conversions from a type to a CXXRecordDecl.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/Type.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Type.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Type.cpp:115,Safety,avoid,avoid,115,// This is effectively the intersection of isTrivialType and; // isStandardLayoutType. We implement it directly to avoid redundant; // conversions from a type to a CXXRecordDecl.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/Type.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Type.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Type.cpp:121,Safety,redund,redundant,121,// This is effectively the intersection of isTrivialType and; // isStandardLayoutType. We implement it directly to avoid redundant; // conversions from a type to a CXXRecordDecl.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/Type.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Type.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Type.cpp:12,Integrability,wrap,wrap,12,// We never wrap type sugar around a PackExpansionType.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/Type.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Type.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Type.cpp:30,Integrability,depend,dependent,30,"// Note that, before C++17, a dependent exception specification does; // *not* make a type dependent; it's not even part of the C++ type; // system.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/Type.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Type.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Type.cpp:91,Integrability,depend,dependent,91,"// Note that, before C++17, a dependent exception specification does; // *not* make a type dependent; it's not even part of the C++ type; // system.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/Type.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Type.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Type.cpp:54,Integrability,depend,dependent,54,"// This exception specification doesn't make the type dependent, because; // it's not instantiated as part of instantiating the type.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/Type.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Type.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Type.cpp:67,Integrability,depend,dependent,67,"// If this is a canonical type, and its exception specification is dependent,; // then it's a dependent type. This only happens in C++17 onwards.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/Type.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Type.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Type.cpp:94,Integrability,depend,dependent,94,"// If this is a canonical type, and its exception specification is dependent,; // then it's a dependent type. This only happens in C++17 onwards.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/Type.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Type.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Type.cpp:66,Integrability,depend,dependent,66,// Ask our canonical type whether our exception specification was dependent.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/Type.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Type.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Type.cpp:31,Integrability,depend,dependent,31,"// A pack expansion with a non-dependent pattern is still dependent,; // because we don't know whether the pattern is in the exception spec; // or not (that depends on whether the pack has 0 expansions).",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/Type.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Type.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Type.cpp:58,Integrability,depend,dependent,58,"// A pack expansion with a non-dependent pattern is still dependent,; // because we don't know whether the pattern is in the exception spec; // or not (that depends on whether the pack has 0 expansions).",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/Type.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Type.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Type.cpp:157,Integrability,depend,depends,157,"// A pack expansion with a non-dependent pattern is still dependent,; // because we don't know whether the pattern is in the exception spec; // or not (that depends on whether the pack has 0 expansions).",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/Type.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Type.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Type.cpp:29,Performance,perform,performance,29,"// This method is relatively performance sensitive, so as a performance; // shortcut, use one AddInteger call instead of four for the next four; // fields.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/Type.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Type.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Type.cpp:60,Performance,perform,performance,60,"// This method is relatively performance sensitive, so as a performance; // shortcut, use one AddInteger call instead of four for the next four; // fields.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/Type.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Type.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Type.cpp:108,Integrability,depend,dependent,108,"// C++11 [temp.type]p2: ""If an expression e involves a template parameter,; // decltype(e) denotes a unique dependent type."" Hence a decltype type is; // type-dependent even if its expression is only instantiation-dependent.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/Type.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Type.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Type.cpp:159,Integrability,depend,dependent,159,"// C++11 [temp.type]p2: ""If an expression e involves a template parameter,; // decltype(e) denotes a unique dependent type."" Hence a decltype type is; // type-dependent even if its expression is only instantiation-dependent.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/Type.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Type.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Type.cpp:214,Integrability,depend,dependent,214,"// C++11 [temp.type]p2: ""If an expression e involves a template parameter,; // decltype(e) denotes a unique dependent type."" Hence a decltype type is; // type-dependent even if its expression is only instantiation-dependent.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/Type.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Type.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Type.cpp:108,Modifiability,variab,variable,108,"// These are type qualifiers in the traditional C sense: they annotate; // something about a specific value/variable of a type. (They aren't; // always part of the canonical type, though.)",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/Type.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Type.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Type.cpp:53,Modifiability,rewrite,rewrite,53,// All other type attributes aren't qualifiers; they rewrite the modified; // type to be a semantically different type.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/Type.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Type.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Type.cpp:58,Availability,error,error,58,"// Update instantiation-dependent, variably-modified, and error bits.; // If the canonical type exists and is non-dependent, the template; // specialization type can be non-dependent even if one of the type; // arguments is. Given:; // template<typename T> using U = int;; // U<T> is always non-dependent, irrespective of the type T.; // However, U<Ts> contains an unexpanded parameter pack, even though; // its expansion (and thus its desugared type) doesn't.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/Type.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Type.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Type.cpp:3,Deployability,Update,Update,3,"// Update instantiation-dependent, variably-modified, and error bits.; // If the canonical type exists and is non-dependent, the template; // specialization type can be non-dependent even if one of the type; // arguments is. Given:; // template<typename T> using U = int;; // U<T> is always non-dependent, irrespective of the type T.; // However, U<Ts> contains an unexpanded parameter pack, even though; // its expansion (and thus its desugared type) doesn't.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/Type.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Type.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Type.cpp:24,Integrability,depend,dependent,24,"// Update instantiation-dependent, variably-modified, and error bits.; // If the canonical type exists and is non-dependent, the template; // specialization type can be non-dependent even if one of the type; // arguments is. Given:; // template<typename T> using U = int;; // U<T> is always non-dependent, irrespective of the type T.; // However, U<Ts> contains an unexpanded parameter pack, even though; // its expansion (and thus its desugared type) doesn't.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/Type.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Type.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Type.cpp:114,Integrability,depend,dependent,114,"// Update instantiation-dependent, variably-modified, and error bits.; // If the canonical type exists and is non-dependent, the template; // specialization type can be non-dependent even if one of the type; // arguments is. Given:; // template<typename T> using U = int;; // U<T> is always non-dependent, irrespective of the type T.; // However, U<Ts> contains an unexpanded parameter pack, even though; // its expansion (and thus its desugared type) doesn't.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/Type.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Type.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Type.cpp:173,Integrability,depend,dependent,173,"// Update instantiation-dependent, variably-modified, and error bits.; // If the canonical type exists and is non-dependent, the template; // specialization type can be non-dependent even if one of the type; // arguments is. Given:; // template<typename T> using U = int;; // U<T> is always non-dependent, irrespective of the type T.; // However, U<Ts> contains an unexpanded parameter pack, even though; // its expansion (and thus its desugared type) doesn't.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/Type.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Type.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Type.cpp:295,Integrability,depend,dependent,295,"// Update instantiation-dependent, variably-modified, and error bits.; // If the canonical type exists and is non-dependent, the template; // specialization type can be non-dependent even if one of the type; // arguments is. Given:; // template<typename T> using U = int;; // U<T> is always non-dependent, irrespective of the type T.; // However, U<Ts> contains an unexpanded parameter pack, even though; // its expansion (and thus its desugared type) doesn't.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/Type.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Type.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Type.cpp:35,Modifiability,variab,variably-modified,35,"// Update instantiation-dependent, variably-modified, and error bits.; // If the canonical type exists and is non-dependent, the template; // specialization type can be non-dependent even if one of the type; // arguments is. Given:; // template<typename T> using U = int;; // U<T> is always non-dependent, irrespective of the type T.; // However, U<Ts> contains an unexpanded parameter pack, even though; // its expansion (and thus its desugared type) doesn't.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/Type.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Type.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Type.cpp:8,Performance,cache,cached,8,/// The cached properties of a type.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/Type.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Type.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Type.cpp:22,Performance,cache,cache,22,/// The type-property cache. This is templated so as to be; /// instantiated at an internal type to prevent unnecessary symbol; /// leakage.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/Type.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Type.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Type.cpp:10,Performance,cache,cache,10,"// If the cache is valid, we're okay.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/Type.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Type.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Type.cpp:15,Performance,cache,cached,15,// Compute the cached properties and then set the cache.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/Type.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Type.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Type.cpp:50,Performance,cache,cache,50,// Compute the cached properties and then set the cache.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/Type.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Type.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Type.cpp:23,Integrability,depend,dependent,23,// Treat instantiation-dependent types as external.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/Type.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Type.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Type.cpp:87,Availability,error,error,87,// Give non-deduced 'auto' types external linkage. We should only see them; // here in error recovery.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/Type.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Type.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Type.cpp:93,Availability,recover,recovery,93,// Give non-deduced 'auto' types external linkage. We should only see them; // here in error recovery.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/Type.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Type.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Type.cpp:93,Safety,recover,recovery,93,// Give non-deduced 'auto' types external linkage. We should only see them; // here in error recovery.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/Type.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Type.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Type.cpp:23,Integrability,depend,dependent,23,// Treat instantiation-dependent types as external.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/Type.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Type.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Type.cpp:3,Integrability,Depend,Dependent,3,// Dependent types that could instantiate to pointer types.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/Type.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Type.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Type.cpp:3,Integrability,Depend,Dependent,3,// Dependent template specializations can instantiate to pointer; // types unless they're known to be specializations of a class; // template.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/Type.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Type.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Type.cpp:3,Integrability,Depend,Dependent,3,// Dependent types that could instantiate to a pointer type.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/Type.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Type.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Type.cpp:9,Integrability,protocol,protocol,9,// Check protocol qualifiers.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/Type.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Type.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Type.cpp:8,Availability,down,down,8,// Walk down to the base type. We don't care about qualifiers for this.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/Type.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Type.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Type.cpp:19,Integrability,Protocol,Protocol,19,// Class and Class<Protocol> don't require retention.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/Type.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Type.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Type.cpp:45,Integrability,bridg,bridgable,45,"/// Determine whether the given type T is a ""bridgable"" Objective-C type,; /// which is either an Objective-C object pointer type or an",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/Type.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Type.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Type.cpp:45,Integrability,bridg,bridgeable,45,"/// Determine whether the given type T is a ""bridgeable"" C type.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/Type.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Type.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Type.cpp:25,Integrability,depend,depend,25,"// We only syntactically depend on the constraint arguments. They don't; // affect the deduced type, only its validity.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/Type.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Type.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/TypeLoc.cpp:38,Integrability,Wrap,Wrapper,38,"//===- TypeLoc.cpp - Type Source Info Wrapper -----------------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file defines the TypeLoc subclasses implementations.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/TypeLoc.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/TypeLoc.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/TypePrinter.cpp:332,Usability,simpl,simple,332,"// CanPrefixQualifiers - We prefer to print type qualifiers before the type,; // so that we get ""const int"" instead of ""int const"", but we can't do this if; // the type is complex. For example if the type is ""int*"", we *must* print; // ""int * const"", printing ""const int *"" is different. Only do this when the; // type expands to a simple string.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/TypePrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/TypePrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/TypePrinter.cpp:60,Integrability,depend,dependent,60,// FIXME:Is it useful to print out the expression for a non-dependent; // noexcept specification?,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/TypePrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/TypePrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/TypePrinter.cpp:37,Integrability,wrap,wrap,37,"// If needed for precedence reasons, wrap the inner part in grouping parens.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/TypePrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/TypePrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/TypePrinter.cpp:37,Integrability,wrap,wrap,37,"// If needed for precedence reasons, wrap the inner part in grouping parens.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/TypePrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/TypePrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/TypePrinter.cpp:33,Availability,avail,available,33,// Do nothing. These CCs are not available as attributes.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/TypePrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/TypePrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/TypePrinter.cpp:37,Integrability,wrap,wrap,37,"// If needed for precedence reasons, wrap the inner part in grouping parens.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/TypePrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/TypePrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/TypePrinter.cpp:37,Integrability,wrap,wrap,37,"// If needed for precedence reasons, wrap the inner part in grouping parens.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/TypePrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/TypePrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/TypePrinter.cpp:16,Availability,redundant,redundant,16,// Suppress the redundant tag keyword if we just printed one.; // We don't have to worry about ElaboratedTypes here because you can't; // refer to an anonymous type with one.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/TypePrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/TypePrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/TypePrinter.cpp:16,Safety,redund,redundant,16,// Suppress the redundant tag keyword if we just printed one.; // We don't have to worry about ElaboratedTypes here because you can't; // refer to an anonymous type with one.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/TypePrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/TypePrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/TypePrinter.cpp:38,Testability,test,test,38,// FIXME: Null TD never excercised in test suite.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/TypePrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/TypePrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/TypePrinter.cpp:10,Deployability,Update,Update,10,// FIXME: Update printAttributedBefore to print these once we generate; // AttributedType nodes for them.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/TypePrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/TypePrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/TypePrinter.cpp:56,Safety,avoid,avoid,56,"// FIXME: When Sema learns to form this AttributedType, avoid printing the; // attribute again in printFunctionProtoAfter.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/TypePrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/TypePrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/TypePrinter.cpp:20,Usability,learn,learns,20,"// FIXME: When Sema learns to form this AttributedType, avoid printing the; // attribute again in printFunctionProtoAfter.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/TypePrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/TypePrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/TypePrinter.cpp:24,Integrability,depend,dependent,24,// Can't evaluate value-dependent expressions so bail early,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/TypePrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/TypePrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/TypePrinter.cpp:136,Safety,avoid,avoid,136,"// If this is the first argument and its string representation; // begins with the global scope specifier ('::foo'), add a space; // to avoid printing the diagraph '<:'.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/TypePrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/TypePrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/TypePrinter.cpp:3,Integrability,Wrap,Wrap,3,// Wrap target address space into an attribute syntax,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/TypePrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/TypePrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/VTableBuilder.cpp:2,Safety,Detect,DetectVirtual,2,/*DetectVirtual=*/,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/VTableBuilder.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/VTableBuilder.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/VTableBuilder.cpp:114,Modifiability,inherit,inheritance,114,// Force the signatures to match. We can't rely on the overrides; // list here because there isn't necessarily an inheritance; // relationship between the two methods.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/VTableBuilder.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/VTableBuilder.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/VTableBuilder.cpp:413,Energy Efficiency,allocate,allocated,413,"/// IsOverriderUsed - Returns whether the overrider will ever be used in this; /// part of the vtable.; ///; /// Itanium C++ ABI 2.5.2:; ///; /// struct A { virtual void f(); };; /// struct B : virtual public A { int i; };; /// struct C : virtual public A { int j; };; /// struct D : public B, public C {};; ///; /// When B and C are declared, A is a primary base in each case, so although; /// vcall offsets are allocated in the A-in-B and A-in-C vtables, no this; /// adjustment is required and no thunk is generated. However, inside D; /// objects, A is no longer a primary base of C, so if we allowed calls to; /// C::f() to use the copy of A's vtable in the C subobject, we would need; /// to adjust this from C* to B::A*, which would require a third-party; /// thunk. Since we require that a call to C::f() first convert to A*,; /// C-in-D's copy of A's vtable is never referenced, so this is not; /// necessary.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/VTableBuilder.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/VTableBuilder.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/VTableBuilder.cpp:4,Usability,Clear,Clear,4,/// Clear the method info map.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/VTableBuilder.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/VTableBuilder.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/VTableBuilder.cpp:2,Safety,Detect,DetectVirtual,2,/*DetectVirtual=*/,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/VTableBuilder.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/VTableBuilder.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/VTableBuilder.cpp:81,Modifiability,inherit,inheritance,81,"// Itanium C++ ABI 2.5.2:; // Then come the virtual base virtual tables, also in inheritance graph; // order, and again excluding primary bases (which share virtual tables with; // the classes for which they are primary).",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/VTableBuilder.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/VTableBuilder.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/VTableBuilder.cpp:21,Testability,test,tests,21,// FIXME: write more tests that actually use the dumpLayout output to prevent; // ItaniumVTableBuilder regressions.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/VTableBuilder.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/VTableBuilder.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/VTableBuilder.cpp:1666,Availability,redundant,redundant,1666,"ifferences are:; // 1. Separate vftable and vbtable.; //; // 2. Each subobject with a vfptr gets its own vftable rather than an address; // point in a single vtable shared between all the subobjects.; // Each vftable is represented by a separate section and virtual calls; // must be done using the vftable which has a slot for the function to be; // called.; //; // 3. Virtual method definitions expect their 'this' parameter to point to the; // first vfptr whose table provides a compatible overridden method. In many; // cases, this permits the original vf-table entry to directly call; // the method instead of passing through a thunk.; // See example before VFTableBuilder::ComputeThisOffset below.; //; // A compatible overridden method is one which does not have a non-trivial; // covariant-return adjustment.; //; // The first vfptr is the one with the lowest offset in the complete-object; // layout of the defining class, and the method definition will subtract; // that constant offset from the parameter value to get the real 'this'; // value. Therefore, if the offset isn't really constant (e.g. if a virtual; // function defined in a virtual base is overridden in a more derived; // virtual base and these bases have a reverse order in the complete; // object), the vf-table may require a this-adjustment thunk.; //; // 4. vftables do not contain new entries for overrides that merely require; // this-adjustment. Together with #3, this keeps vf-tables smaller and; // eliminates the need for this-adjustment thunks in many cases, at the cost; // of often requiring redundant work to adjust the ""this"" pointer.; //; // 5. Instead of VTT and constructor vtables, vbtables and vtordisps are used.; // Vtordisps are emitted into the class layout if a class has; // a) a user-defined ctor/dtor; // and; // b) a method overriding a method in a virtual base.; //; // To get a better understanding of this code,; // you might want to see examples in test/CodeGenCXX/microsoft-abi-vtables-*.cpp",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/VTableBuilder.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/VTableBuilder.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/VTableBuilder.cpp:1666,Safety,redund,redundant,1666,"ifferences are:; // 1. Separate vftable and vbtable.; //; // 2. Each subobject with a vfptr gets its own vftable rather than an address; // point in a single vtable shared between all the subobjects.; // Each vftable is represented by a separate section and virtual calls; // must be done using the vftable which has a slot for the function to be; // called.; //; // 3. Virtual method definitions expect their 'this' parameter to point to the; // first vfptr whose table provides a compatible overridden method. In many; // cases, this permits the original vf-table entry to directly call; // the method instead of passing through a thunk.; // See example before VFTableBuilder::ComputeThisOffset below.; //; // A compatible overridden method is one which does not have a non-trivial; // covariant-return adjustment.; //; // The first vfptr is the one with the lowest offset in the complete-object; // layout of the defining class, and the method definition will subtract; // that constant offset from the parameter value to get the real 'this'; // value. Therefore, if the offset isn't really constant (e.g. if a virtual; // function defined in a virtual base is overridden in a more derived; // virtual base and these bases have a reverse order in the complete; // object), the vf-table may require a this-adjustment thunk.; //; // 4. vftables do not contain new entries for overrides that merely require; // this-adjustment. Together with #3, this keeps vf-tables smaller and; // eliminates the need for this-adjustment thunks in many cases, at the cost; // of often requiring redundant work to adjust the ""this"" pointer.; //; // 5. Instead of VTT and constructor vtables, vbtables and vtordisps are used.; // Vtordisps are emitted into the class layout if a class has; // a) a user-defined ctor/dtor; // and; // b) a method overriding a method in a virtual base.; //; // To get a better understanding of this code,; // you might want to see examples in test/CodeGenCXX/microsoft-abi-vtables-*.cpp",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/VTableBuilder.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/VTableBuilder.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/VTableBuilder.cpp:2043,Testability,test,test,2043,"ifferences are:; // 1. Separate vftable and vbtable.; //; // 2. Each subobject with a vfptr gets its own vftable rather than an address; // point in a single vtable shared between all the subobjects.; // Each vftable is represented by a separate section and virtual calls; // must be done using the vftable which has a slot for the function to be; // called.; //; // 3. Virtual method definitions expect their 'this' parameter to point to the; // first vfptr whose table provides a compatible overridden method. In many; // cases, this permits the original vf-table entry to directly call; // the method instead of passing through a thunk.; // See example before VFTableBuilder::ComputeThisOffset below.; //; // A compatible overridden method is one which does not have a non-trivial; // covariant-return adjustment.; //; // The first vfptr is the one with the lowest offset in the complete-object; // layout of the defining class, and the method definition will subtract; // that constant offset from the parameter value to get the real 'this'; // value. Therefore, if the offset isn't really constant (e.g. if a virtual; // function defined in a virtual base is overridden in a more derived; // virtual base and these bases have a reverse order in the complete; // object), the vf-table may require a this-adjustment thunk.; //; // 4. vftables do not contain new entries for overrides that merely require; // this-adjustment. Together with #3, this keeps vf-tables smaller and; // eliminates the need for this-adjustment thunks in many cases, at the cost; // of often requiring redundant work to adjust the ""this"" pointer.; //; // 5. Instead of VTT and constructor vtables, vbtables and vtordisps are used.; // Vtordisps are emitted into the class layout if a class has; // a) a user-defined ctor/dtor; // and; // b) a method overriding a method in a virtual base.; //; // To get a better understanding of this code,; // you might want to see examples in test/CodeGenCXX/microsoft-abi-vtables-*.cpp",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/VTableBuilder.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/VTableBuilder.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/VTableBuilder.cpp:82,Availability,avail,available,82,"// Provide the RTTI component if RTTIData is enabled. If the vftable would; // be available externally, we should not provide the RTTI componenent. It; // is currently impossible to get available externally vftables with either; // dllimport or extern template instantiations, but eventually we may add a; // flag to support additional devirtualization that needs this.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/VTableBuilder.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/VTableBuilder.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/VTableBuilder.cpp:186,Availability,avail,available,186,"// Provide the RTTI component if RTTIData is enabled. If the vftable would; // be available externally, we should not provide the RTTI componenent. It; // is currently impossible to get available externally vftables with either; // dllimport or extern template instantiations, but eventually we may add a; // flag to support additional devirtualization that needs this.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/VTableBuilder.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/VTableBuilder.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/VTableBuilder.cpp:728,Performance,perform,performed,728,"// end namespace; // Let's study one class hierarchy as an example:; // struct A {; // virtual void f();; // int x;; // };; //; // struct B : virtual A {; // virtual void f();; // };; //; // Record layouts:; // struct A:; // 0 | (A vftable pointer); // 4 | int x; //; // struct B:; // 0 | (B vbtable pointer); // 4 | struct A (virtual base); // 4 | (A vftable pointer); // 8 | int x; //; // Let's assume we have a pointer to the A part of an object of dynamic type B:; // B b;; // A *a = (A*)&b;; // a->f();; //; // In this hierarchy, f() belongs to the vftable of A, so B::f() expects; // ""this"" parameter to point at the A subobject, which is B+4.; // In the B::f() prologue, it adjusts ""this"" back to B by subtracting 4,; // performed as a *static* adjustment.; //; // Interesting thing happens when we alter the relative placement of A and B; // subobjects in a class:; // struct C : virtual B { };; //; // C c;; // A *a = (A*)&c;; // a->f();; //; // Respective record layout is:; // 0 | (C vbtable pointer); // 4 | struct A (virtual base); // 4 | (A vftable pointer); // 8 | int x; // 12 | struct B (virtual base); // 12 | (B vbtable pointer); //; // The final overrider of f() in class C is still B::f(), so B+4 should be; // passed as ""this"" to that code. However, ""a"" points at B-8, so the respective; // vftable entry should hold a thunk that adds 12 to the ""this"" argument before; // performing a tail call to B::f().; //; // With this example in mind, we can now calculate the 'this' argument offset; // for the given method, relative to the beginning of the MostDerivedClass.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/VTableBuilder.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/VTableBuilder.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/VTableBuilder.cpp:1394,Performance,perform,performing,1394,"// end namespace; // Let's study one class hierarchy as an example:; // struct A {; // virtual void f();; // int x;; // };; //; // struct B : virtual A {; // virtual void f();; // };; //; // Record layouts:; // struct A:; // 0 | (A vftable pointer); // 4 | int x; //; // struct B:; // 0 | (B vbtable pointer); // 4 | struct A (virtual base); // 4 | (A vftable pointer); // 8 | int x; //; // Let's assume we have a pointer to the A part of an object of dynamic type B:; // B b;; // A *a = (A*)&b;; // a->f();; //; // In this hierarchy, f() belongs to the vftable of A, so B::f() expects; // ""this"" parameter to point at the A subobject, which is B+4.; // In the B::f() prologue, it adjusts ""this"" back to B by subtracting 4,; // performed as a *static* adjustment.; //; // Interesting thing happens when we alter the relative placement of A and B; // subobjects in a class:; // struct C : virtual B { };; //; // C c;; // A *a = (A*)&c;; // a->f();; //; // Respective record layout is:; // 0 | (C vbtable pointer); // 4 | struct A (virtual base); // 4 | (A vftable pointer); // 8 | int x; // 12 | struct B (virtual base); // 12 | (B vbtable pointer); //; // The final overrider of f() in class C is still B::f(), so B+4 should be; // passed as ""this"" to that code. However, ""a"" points at B-8, so the respective; // vftable entry should hold a thunk that adds 12 to the ""this"" argument before; // performing a tail call to B::f().; //; // With this example in mind, we can now calculate the 'this' argument offset; // for the given method, relative to the beginning of the MostDerivedClass.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/VTableBuilder.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/VTableBuilder.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/VTableBuilder.cpp:182,Energy Efficiency,reduce,reduce,182,// This will hold the smallest this offset among overridees of MD.; // This implies that an offset of a non-virtual base will dominate an offset; // of a virtual base to potentially reduce the number of thunks required; // in the derived classes that inherit this method.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/VTableBuilder.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/VTableBuilder.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/VTableBuilder.cpp:251,Modifiability,inherit,inherit,251,// This will hold the smallest this offset among overridees of MD.; // This implies that an offset of a non-virtual base will dominate an offset; // of a virtual base to potentially reduce the number of thunks required; // in the derived classes that inherit this method.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/VTableBuilder.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/VTableBuilder.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/VTableBuilder.cpp:54,Modifiability,inherit,inheritance,54,"// The interesting things begin when you have virtual inheritance.; // The final overrider will use a static adjustment equal to the offset; // of the vbase in the final overrider class.; // For example, if the final overrider is in a vbase B of the most; // derived class and it overrides a method of the B's own vbase A,; // it uses A* as ""this"". In its prologue, it can cast A* to B* with; // a static offset. This offset is used regardless of the actual; // offset of A from B in the most derived class, requiring an; // this-adjusting thunk in the vftable if A and B are laid out; // differently in the most derived class.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/VTableBuilder.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/VTableBuilder.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/VTableBuilder.cpp:5,Usability,simpl,simple,5,// A simple vtordisp thunk will suffice if the final overrider is defined; // in either the most derived class or its non-virtual base.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/VTableBuilder.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/VTableBuilder.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/VTableBuilder.cpp:56,Deployability,update,update,56,"// If MD overrides anything in this vftable, we need to update the; // entries.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/VTableBuilder.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/VTableBuilder.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/VTableBuilder.cpp:457,Modifiability,inherit,inheritance,457,"/// Produces MSVC-compatible vbtable data. The symbols produced by this; /// algorithm match those produced by MSVC 2012 and newer, which is different; /// from MSVC 2010.; ///; /// MSVC 2012 appears to minimize the vbtable names using the following; /// algorithm. First, walk the class hierarchy in the usual order, depth first,; /// left to right, to find all of the subobjects which contain a vbptr field.; /// Visiting each class node yields a list of inheritance paths to vbptrs. Each; /// record with a vbptr creates an initially empty path.; ///; /// To combine paths from child nodes, the paths are compared to check for; /// ambiguity. Paths are ""ambiguous"" if multiple paths have the same set of; /// components in the same order. Each group of ambiguous paths is extended by; /// appending the class of the base from which it came. If the current class; /// node produced an ambiguous path, its path is extended with the current class.; /// After extending paths, MSVC again checks for ambiguity, and extends any; /// ambiguous path which wasn't already extended. Because each node yields an; /// unambiguous set of paths, MSVC doesn't need to extend any path more than once; /// to produce an unambiguous set of paths.; ///; /// TODO: Presumably vftables use the same algorithm.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/VTableBuilder.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/VTableBuilder.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/VTableBuilder.cpp:775,Modifiability,extend,extended,775,"/// Produces MSVC-compatible vbtable data. The symbols produced by this; /// algorithm match those produced by MSVC 2012 and newer, which is different; /// from MSVC 2010.; ///; /// MSVC 2012 appears to minimize the vbtable names using the following; /// algorithm. First, walk the class hierarchy in the usual order, depth first,; /// left to right, to find all of the subobjects which contain a vbptr field.; /// Visiting each class node yields a list of inheritance paths to vbptrs. Each; /// record with a vbptr creates an initially empty path.; ///; /// To combine paths from child nodes, the paths are compared to check for; /// ambiguity. Paths are ""ambiguous"" if multiple paths have the same set of; /// components in the same order. Each group of ambiguous paths is extended by; /// appending the class of the base from which it came. If the current class; /// node produced an ambiguous path, its path is extended with the current class.; /// After extending paths, MSVC again checks for ambiguity, and extends any; /// ambiguous path which wasn't already extended. Because each node yields an; /// unambiguous set of paths, MSVC doesn't need to extend any path more than once; /// to produce an unambiguous set of paths.; ///; /// TODO: Presumably vftables use the same algorithm.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/VTableBuilder.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/VTableBuilder.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/VTableBuilder.cpp:915,Modifiability,extend,extended,915,"/// Produces MSVC-compatible vbtable data. The symbols produced by this; /// algorithm match those produced by MSVC 2012 and newer, which is different; /// from MSVC 2010.; ///; /// MSVC 2012 appears to minimize the vbtable names using the following; /// algorithm. First, walk the class hierarchy in the usual order, depth first,; /// left to right, to find all of the subobjects which contain a vbptr field.; /// Visiting each class node yields a list of inheritance paths to vbptrs. Each; /// record with a vbptr creates an initially empty path.; ///; /// To combine paths from child nodes, the paths are compared to check for; /// ambiguity. Paths are ""ambiguous"" if multiple paths have the same set of; /// components in the same order. Each group of ambiguous paths is extended by; /// appending the class of the base from which it came. If the current class; /// node produced an ambiguous path, its path is extended with the current class.; /// After extending paths, MSVC again checks for ambiguity, and extends any; /// ambiguous path which wasn't already extended. Because each node yields an; /// unambiguous set of paths, MSVC doesn't need to extend any path more than once; /// to produce an unambiguous set of paths.; ///; /// TODO: Presumably vftables use the same algorithm.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/VTableBuilder.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/VTableBuilder.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/VTableBuilder.cpp:959,Modifiability,extend,extending,959,"/// Produces MSVC-compatible vbtable data. The symbols produced by this; /// algorithm match those produced by MSVC 2012 and newer, which is different; /// from MSVC 2010.; ///; /// MSVC 2012 appears to minimize the vbtable names using the following; /// algorithm. First, walk the class hierarchy in the usual order, depth first,; /// left to right, to find all of the subobjects which contain a vbptr field.; /// Visiting each class node yields a list of inheritance paths to vbptrs. Each; /// record with a vbptr creates an initially empty path.; ///; /// To combine paths from child nodes, the paths are compared to check for; /// ambiguity. Paths are ""ambiguous"" if multiple paths have the same set of; /// components in the same order. Each group of ambiguous paths is extended by; /// appending the class of the base from which it came. If the current class; /// node produced an ambiguous path, its path is extended with the current class.; /// After extending paths, MSVC again checks for ambiguity, and extends any; /// ambiguous path which wasn't already extended. Because each node yields an; /// unambiguous set of paths, MSVC doesn't need to extend any path more than once; /// to produce an unambiguous set of paths.; ///; /// TODO: Presumably vftables use the same algorithm.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/VTableBuilder.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/VTableBuilder.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/VTableBuilder.cpp:1013,Modifiability,extend,extends,1013,"/// Produces MSVC-compatible vbtable data. The symbols produced by this; /// algorithm match those produced by MSVC 2012 and newer, which is different; /// from MSVC 2010.; ///; /// MSVC 2012 appears to minimize the vbtable names using the following; /// algorithm. First, walk the class hierarchy in the usual order, depth first,; /// left to right, to find all of the subobjects which contain a vbptr field.; /// Visiting each class node yields a list of inheritance paths to vbptrs. Each; /// record with a vbptr creates an initially empty path.; ///; /// To combine paths from child nodes, the paths are compared to check for; /// ambiguity. Paths are ""ambiguous"" if multiple paths have the same set of; /// components in the same order. Each group of ambiguous paths is extended by; /// appending the class of the base from which it came. If the current class; /// node produced an ambiguous path, its path is extended with the current class.; /// After extending paths, MSVC again checks for ambiguity, and extends any; /// ambiguous path which wasn't already extended. Because each node yields an; /// unambiguous set of paths, MSVC doesn't need to extend any path more than once; /// to produce an unambiguous set of paths.; ///; /// TODO: Presumably vftables use the same algorithm.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/VTableBuilder.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/VTableBuilder.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/VTableBuilder.cpp:1066,Modifiability,extend,extended,1066,"/// Produces MSVC-compatible vbtable data. The symbols produced by this; /// algorithm match those produced by MSVC 2012 and newer, which is different; /// from MSVC 2010.; ///; /// MSVC 2012 appears to minimize the vbtable names using the following; /// algorithm. First, walk the class hierarchy in the usual order, depth first,; /// left to right, to find all of the subobjects which contain a vbptr field.; /// Visiting each class node yields a list of inheritance paths to vbptrs. Each; /// record with a vbptr creates an initially empty path.; ///; /// To combine paths from child nodes, the paths are compared to check for; /// ambiguity. Paths are ""ambiguous"" if multiple paths have the same set of; /// components in the same order. Each group of ambiguous paths is extended by; /// appending the class of the base from which it came. If the current class; /// node produced an ambiguous path, its path is extended with the current class.; /// After extending paths, MSVC again checks for ambiguity, and extends any; /// ambiguous path which wasn't already extended. Because each node yields an; /// unambiguous set of paths, MSVC doesn't need to extend any path more than once; /// to produce an unambiguous set of paths.; ///; /// TODO: Presumably vftables use the same algorithm.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/VTableBuilder.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/VTableBuilder.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/VTableBuilder.cpp:1156,Modifiability,extend,extend,1156,"/// Produces MSVC-compatible vbtable data. The symbols produced by this; /// algorithm match those produced by MSVC 2012 and newer, which is different; /// from MSVC 2010.; ///; /// MSVC 2012 appears to minimize the vbtable names using the following; /// algorithm. First, walk the class hierarchy in the usual order, depth first,; /// left to right, to find all of the subobjects which contain a vbptr field.; /// Visiting each class node yields a list of inheritance paths to vbptrs. Each; /// record with a vbptr creates an initially empty path.; ///; /// To combine paths from child nodes, the paths are compared to check for; /// ambiguity. Paths are ""ambiguous"" if multiple paths have the same set of; /// components in the same order. Each group of ambiguous paths is extended by; /// appending the class of the base from which it came. If the current class; /// node produced an ambiguous path, its path is extended with the current class.; /// After extending paths, MSVC again checks for ambiguity, and extends any; /// ambiguous path which wasn't already extended. Because each node yields an; /// unambiguous set of paths, MSVC doesn't need to extend any path more than once; /// to produce an unambiguous set of paths.; ///; /// TODO: Presumably vftables use the same algorithm.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/VTableBuilder.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/VTableBuilder.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/VTableBuilder.cpp:94,Modifiability,extend,extended,94,// We mangle Base into the path if the path would've been ambiguous and it; // wasn't already extended with Base.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/VTableBuilder.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/VTableBuilder.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/VTableBuilder.cpp:60,Modifiability,extend,extend,60,"// Keep track of which vtable the derived class is going to extend with; // new methods or bases. We append to either the vftable of our primary; // base, or the first non-virtual base that has a vbtable.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/VTableBuilder.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/VTableBuilder.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/VTableBuilder.cpp:3,Deployability,Update,Update,3,// Update the full offset in the MDC.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/VTableBuilder.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/VTableBuilder.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/VTableBuilder.cpp:66,Modifiability,extend,extend,66,"// Sort the paths into buckets, and if any of them are ambiguous, extend all; // paths in ambiguous buckets.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/VTableBuilder.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/VTableBuilder.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/VTableBuilder.cpp:31,Modifiability,extend,extended,31,// Prevent the path from being extended twice.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/VTableBuilder.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/VTableBuilder.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/VTableBuilder.cpp:126,Modifiability,extend,extended,126,"// What we're essentially doing here is bucketing together ambiguous paths.; // Any bucket with more than one path in it gets extended by NextBase, which; // is usually the direct base of the inherited the vbptr. This code uses a; // sorted vector to implement a multiset to form the buckets. Note that the; // ordering is based on pointers, but it doesn't change our output order. The; // current algorithm is designed to match MSVC 2012's names.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/VTableBuilder.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/VTableBuilder.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/VTableBuilder.cpp:192,Modifiability,inherit,inherited,192,"// What we're essentially doing here is bucketing together ambiguous paths.; // Any bucket with more than one path in it gets extended by NextBase, which; // is usually the direct base of the inherited the vbptr. This code uses a; // sorted vector to implement a multiset to form the buckets. Note that the; // ordering is based on pointers, but it doesn't change our output order. The; // current algorithm is designed to match MSVC 2012's names.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/VTableBuilder.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/VTableBuilder.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/VTableBuilder.cpp:38,Modifiability,extend,extend,38,"// If this bucket has multiple paths, extend them all.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/VTableBuilder.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/VTableBuilder.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Interp/Boolean.h:21,Integrability,Wrap,Wrapper,21,"//===--- Boolean.h - Wrapper for boolean types for the VM -------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/Interp/Boolean.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Interp/Boolean.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Interp/Boolean.h:4,Integrability,Wrap,Wrapper,4,/// Wrapper around boolean types.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/Interp/Boolean.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Interp/Boolean.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Interp/ByteCodeEmitter.cpp:3,Modifiability,Rewrite,Rewrite,3,// Rewrite the operand of all jumps to this label.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/Interp/ByteCodeEmitter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Interp/ByteCodeEmitter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Interp/ByteCodeEmitter.cpp:3,Security,Access,Access,3,// Access must be aligned!,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/Interp/ByteCodeEmitter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Interp/ByteCodeEmitter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Interp/ByteCodeEmitter.cpp:3,Security,Access,Access,3,// Access must be aligned!,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/Interp/ByteCodeEmitter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Interp/ByteCodeEmitter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Interp/ByteCodeEmitter.h:22,Availability,avail,available,22,/// Index of the next available label.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/Interp/ByteCodeEmitter.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Interp/ByteCodeEmitter.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Interp/ByteCodeEmitter.h:29,Modifiability,variab,variable,29,/// Offset of the next local variable.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/Interp/ByteCodeEmitter.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Interp/ByteCodeEmitter.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Interp/ByteCodeExprGen.cpp:49,Modifiability,variab,variable,49,/// Scope used to handle temporaries in toplevel variable declarations.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/Interp/ByteCodeExprGen.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Interp/ByteCodeExprGen.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Interp/ByteCodeExprGen.cpp:9,Performance,load,loaded,9,// Value loaded - nothing to do here.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/Interp/ByteCodeExprGen.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Interp/ByteCodeExprGen.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Interp/ByteCodeExprGen.cpp:58,Energy Efficiency,allocate,allocate,58,"// We're creating a complex value here, so we need to; // allocate storage for it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/Interp/ByteCodeExprGen.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Interp/ByteCodeExprGen.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Interp/ByteCodeExprGen.cpp:23,Modifiability,variab,variable,23,// We need a temporary variable holding our return value.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/Interp/ByteCodeExprGen.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Interp/ByteCodeExprGen.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Interp/ByteCodeExprGen.cpp:4,Performance,Perform,Perform,4,/// Perform addition/subtraction of a pointer and an integer or; /// subtraction of two pointers.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/Interp/ByteCodeExprGen.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Interp/ByteCodeExprGen.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Interp/ByteCodeExprGen.cpp:3,Testability,Log,Logical,3,// Logical OR. Visit LHS and only evaluate RHS if LHS was FALSE.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/Interp/ByteCodeExprGen.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Interp/ByteCodeExprGen.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Interp/ByteCodeExprGen.cpp:3,Testability,Log,Logical,3,// Logical AND.; // Visit LHS. Only visit RHS if LHS was TRUE.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/Interp/ByteCodeExprGen.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Interp/ByteCodeExprGen.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Interp/ByteCodeExprGen.cpp:54,Testability,log,logic,54,"// The kinds of expressions that we have special-case logic here for; // should be kept up to date with the special checks for those; // expressions in Sema.; // alignof decl is always accepted, even if it doesn't make sense: we; // default to 1 in those cases.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/Interp/ByteCodeExprGen.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Interp/ByteCodeExprGen.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Interp/ByteCodeExprGen.cpp:100,Performance,cache,cached,100,"// If the common expression is an opaque expression, we visit it; // here once so we have its value cached.; // FIXME: This might be necessary (or useful) for all expressions.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/Interp/ByteCodeExprGen.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Interp/ByteCodeExprGen.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Interp/ByteCodeExprGen.cpp:134,Modifiability,variab,variable,134,// At this point we either have the evaluated source expression or a pointer; // to an object on the stack. We want to create a local variable that stores; // this value.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/Interp/ByteCodeExprGen.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Interp/ByteCodeExprGen.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Interp/ByteCodeExprGen.cpp:18,Modifiability,variab,variable,18,"// Here the local variable is created but the value is removed from the stack,; // so we put it back, because the caller might need it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/Interp/ByteCodeExprGen.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Interp/ByteCodeExprGen.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Interp/ByteCodeExprGen.cpp:22,Performance,cache,cached,22,// FIXME: Ideally the cached value should be cleaned up later.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/Interp/ByteCodeExprGen.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Interp/ByteCodeExprGen.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Interp/ByteCodeExprGen.cpp:100,Modifiability,variab,variable,100,// C++17 onwards require that we evaluate the RHS first.; // Compute RHS and save it in a temporary variable so we can; // load it again later.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/Interp/ByteCodeExprGen.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Interp/ByteCodeExprGen.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Interp/ByteCodeExprGen.cpp:123,Performance,load,load,123,// C++17 onwards require that we evaluate the RHS first.; // Compute RHS and save it in a temporary variable so we can; // load it again later.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/Interp/ByteCodeExprGen.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Interp/ByteCodeExprGen.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Interp/ByteCodeExprGen.cpp:7,Performance,load,load,7,// Now load RHS.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/Interp/ByteCodeExprGen.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Interp/ByteCodeExprGen.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Interp/ByteCodeExprGen.cpp:100,Modifiability,variab,variable,100,"// C++17 onwards require that we evaluate the RHS first.; // Compute RHS and save it in a temporary variable so we can; // load it again later.; // FIXME: Compound assignments are unsequenced in C, so we might; // have to figure out how to reject them.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/Interp/ByteCodeExprGen.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Interp/ByteCodeExprGen.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Interp/ByteCodeExprGen.cpp:123,Performance,load,load,123,"// C++17 onwards require that we evaluate the RHS first.; // Compute RHS and save it in a temporary variable so we can; // load it again later.; // FIXME: Compound assignments are unsequenced in C, so we might; // have to figure out how to reject them.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/Interp/ByteCodeExprGen.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Interp/ByteCodeExprGen.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Interp/ByteCodeExprGen.cpp:20,Performance,load,load,20,"// Get LHS pointer, load its value and cast it to the; // computation type if necessary.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/Interp/ByteCodeExprGen.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Interp/ByteCodeExprGen.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Interp/ByteCodeExprGen.cpp:3,Performance,Perform,Perform,3,// Perform operation.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/Interp/ByteCodeExprGen.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Interp/ByteCodeExprGen.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Interp/ByteCodeExprGen.cpp:36,Modifiability,variab,variable,36,"// When we're initializing a global variable *or* the storage duration of; // the temporary is explicitly static, create a global variable.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/Interp/ByteCodeExprGen.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Interp/ByteCodeExprGen.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Interp/ByteCodeExprGen.cpp:130,Modifiability,variab,variable,130,"// When we're initializing a global variable *or* the storage duration of; // the temporary is explicitly static, create a global variable.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/Interp/ByteCodeExprGen.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Interp/ByteCodeExprGen.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Interp/ByteCodeExprGen.cpp:33,Modifiability,variab,variables,33,"// For everyhing else, use local variables.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/Interp/ByteCodeExprGen.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Interp/ByteCodeExprGen.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Interp/ByteCodeExprGen.cpp:26,Modifiability,variab,variable,26,"// Otherwise, use a local variable.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/Interp/ByteCodeExprGen.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Interp/ByteCodeExprGen.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Interp/ByteCodeExprGen.cpp:68,Energy Efficiency,allocate,allocate,68,"// If we're discarding a construct expression, we still need; // to allocate a variable and call the constructor and destructor.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/Interp/ByteCodeExprGen.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Interp/ByteCodeExprGen.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Interp/ByteCodeExprGen.cpp:79,Modifiability,variab,variable,79,"// If we're discarding a construct expression, we still need; // to allocate a variable and call the constructor and destructor.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/Interp/ByteCodeExprGen.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Interp/ByteCodeExprGen.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Interp/ByteCodeExprGen.cpp:16,Modifiability,variab,variable,16,// Create local variable to hold the return value.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/Interp/ByteCodeExprGen.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Interp/ByteCodeExprGen.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Interp/ByteCodeExprGen.cpp:136,Security,access,access,136,"// If the declaration is a constant value, emit it here even; // though the declaration was not evaluated in the current scope.; // The access mode can only be read in this case.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/Interp/ByteCodeExprGen.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Interp/ByteCodeExprGen.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Interp/ByteCodeExprGen.cpp:29,Modifiability,variab,variable,29,// Create and initialize the variable.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/Interp/ByteCodeExprGen.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Interp/ByteCodeExprGen.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Interp/ByteCodeExprGen.cpp:24,Modifiability,variab,variable,24,// Get a pointer to the variable,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/Interp/ByteCodeExprGen.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Interp/ByteCodeExprGen.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Interp/ByteCodeExprGen.cpp:247,Availability,fault,faulty,247,"// If the function is being compiled right now, this is a recursive call.; // In that case, the function can't be valid yet, even though it will be; // later.; // If the function is already fully compiled but not constexpr, it was; // found to be faulty earlier on, so bail out.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/Interp/ByteCodeExprGen.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Interp/ByteCodeExprGen.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Interp/ByteCodeExprGen.cpp:26,Modifiability,variab,variables,26,// Check for local/global variables and parameters.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/Interp/ByteCodeExprGen.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Interp/ByteCodeExprGen.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Interp/ByteCodeExprGen.h:117,Modifiability,variab,variable,117,"/// Evaluates an expression and places the result on the stack. If the; /// expression is of composite type, a local variable will be created; /// and a pointer to said variable will be placed on the stack.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/Interp/ByteCodeExprGen.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Interp/ByteCodeExprGen.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Interp/ByteCodeExprGen.h:169,Modifiability,variab,variable,169,"/// Evaluates an expression and places the result on the stack. If the; /// expression is of composite type, a local variable will be created; /// and a pointer to said variable will be placed on the stack.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/Interp/ByteCodeExprGen.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Interp/ByteCodeExprGen.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Interp/ByteCodeExprGen.h:82,Modifiability,variab,variable,82,/// Compiles an initializer. This is like visit() but it will never; /// create a variable and instead rely on a variable already having; /// been created. visitInitializer() then relies on a pointer to this; /// variable being on top of the stack.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/Interp/ByteCodeExprGen.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Interp/ByteCodeExprGen.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Interp/ByteCodeExprGen.h:113,Modifiability,variab,variable,113,/// Compiles an initializer. This is like visit() but it will never; /// create a variable and instead rely on a variable already having; /// been created. visitInitializer() then relies on a pointer to this; /// variable being on top of the stack.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/Interp/ByteCodeExprGen.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Interp/ByteCodeExprGen.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Interp/ByteCodeExprGen.h:213,Modifiability,variab,variable,213,/// Compiles an initializer. This is like visit() but it will never; /// create a variable and instead rely on a variable already having; /// been created. visitInitializer() then relies on a pointer to this; /// variable being on top of the stack.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/Interp/ByteCodeExprGen.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Interp/ByteCodeExprGen.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Interp/ByteCodeExprGen.h:30,Modifiability,variab,variable,30,/// Creates and initializes a variable from the given decl.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/Interp/ByteCodeExprGen.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Interp/ByteCodeExprGen.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Interp/ByteCodeExprGen.h:4,Energy Efficiency,Allocate,Allocates,4,/// Allocates a space storing a local given its type.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/Interp/ByteCodeExprGen.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Interp/ByteCodeExprGen.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Interp/ByteCodeExprGen.h:23,Performance,load,load,23,"/// Method to directly load a value. If the value can be fetched directly,; /// the direct handler is called. Otherwise, a pointer is left on the stack; /// and the indirect handler is expected to operate on that.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/Interp/ByteCodeExprGen.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Interp/ByteCodeExprGen.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Interp/ByteCodeExprGen.h:4,Modifiability,Variab,Variable,4,/// Variable to storage mapping.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/Interp/ByteCodeExprGen.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Interp/ByteCodeExprGen.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Interp/ByteCodeExprGen.h:67,Modifiability,variab,variable,67,/// Flag inidicating if we're initializing an already created; /// variable. This is set in visitInitializer().,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/Interp/ByteCodeExprGen.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Interp/ByteCodeExprGen.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Interp/ByteCodeExprGen.h:51,Modifiability,variab,variable,51,/// Flag indicating if we're initializing a global variable.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/Interp/ByteCodeExprGen.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Interp/ByteCodeExprGen.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Interp/ByteCodeExprGen.h:29,Modifiability,variab,variable,29,/// Scope chain managing the variable lifetimes.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/Interp/ByteCodeExprGen.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Interp/ByteCodeExprGen.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Interp/ByteCodeExprGen.h:28,Modifiability,variab,variables,28,/// Generic scope for local variables.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/Interp/ByteCodeExprGen.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Interp/ByteCodeExprGen.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Interp/ByteCodeExprGen.h:35,Modifiability,variab,variables,35,// Emit destructor calls for local variables of record; // type with a destructor.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/Interp/ByteCodeExprGen.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Interp/ByteCodeExprGen.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Interp/ByteCodeExprGen.h:33,Modifiability,variab,variables,33,"/// Emits the destructors of the variables of \param OtherScope; /// when this scope is destroyed. Does not create a Scope in the bytecode at; /// all, this is just a RAII object to emit destructors.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/Interp/ByteCodeExprGen.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Interp/ByteCodeExprGen.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Interp/ByteCodeExprGen.h:77,Modifiability,variab,variables,77,"/// Like a regular LocalScope, except that the destructors of all local; /// variables are automatically emitted when the AutoScope is destroyed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/Interp/ByteCodeExprGen.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Interp/ByteCodeExprGen.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Interp/ByteCodeExprGen.h:37,Modifiability,variab,variable,37,"// If we to this point, just add the variable as a normal local; // variable. It will be destroyed at the end of the block just; // like all others.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/Interp/ByteCodeExprGen.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Interp/ByteCodeExprGen.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Interp/ByteCodeExprGen.h:68,Modifiability,variab,variable,68,"// If we to this point, just add the variable as a normal local; // variable. It will be destroyed at the end of the block just; // like all others.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/Interp/ByteCodeExprGen.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Interp/ByteCodeExprGen.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Interp/ByteCodeExprGen.h:55,Modifiability,extend,extended,55,/// Expression scope which tracks potentially lifetime extended; /// temporaries which are hoisted to the parent scope on exit.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/Interp/ByteCodeExprGen.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Interp/ByteCodeExprGen.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Interp/ByteCodeGenError.cpp:51,Availability,error,error,51,"//===--- ByteCodeGenError.h - Byte code generation error --------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/Interp/ByteCodeGenError.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Interp/ByteCodeGenError.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Interp/ByteCodeGenError.h:51,Availability,error,error,51,"//===--- ByteCodeGenError.h - Byte code generation error ----------*- C -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/Interp/ByteCodeGenError.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Interp/ByteCodeGenError.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Interp/ByteCodeGenError.h:4,Availability,Error,Error,4,/// Error thrown by the compiler.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/Interp/ByteCodeGenError.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Interp/ByteCodeGenError.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Interp/ByteCodeGenError.h:31,Availability,error,error,31,// Range of the item where the error occurred.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/Interp/ByteCodeGenError.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Interp/ByteCodeGenError.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Interp/ByteCodeStmtGen.cpp:49,Modifiability,variab,variable,49,/// Visits the given statment without creating a variable; /// scope for it in case it is a compound statement.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/Interp/ByteCodeStmtGen.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Interp/ByteCodeStmtGen.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Interp/ByteCodeStmtGen.cpp:23,Usability,simpl,simply,23,// Primitive types are simply returned.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/Interp/ByteCodeStmtGen.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Interp/ByteCodeStmtGen.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Interp/ByteCodeStmtGen.cpp:41,Modifiability,variab,variable,41,// Now the condition as well as the loop variable assignment.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/Interp/ByteCodeStmtGen.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Interp/ByteCodeStmtGen.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Interp/ByteCodeStmtGen.cpp:24,Modifiability,variab,variable,24,// Initialize condition variable.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/Interp/ByteCodeStmtGen.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Interp/ByteCodeStmtGen.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Interp/Context.cpp:53,Availability,alive,alive,53,// Make sure we don't rely on some value being still alive in; // InterpStack memory.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/Interp/Context.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Interp/Context.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Interp/Context.cpp:53,Availability,alive,alive,53,// Make sure we don't rely on some value being still alive in; // InterpStack memory.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/Interp/Context.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Interp/Context.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Interp/Context.cpp:53,Availability,alive,alive,53,// Make sure we don't rely on some value being still alive in; // InterpStack memory.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/Interp/Context.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Interp/Context.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Interp/Context.cpp:17,Modifiability,variab,variables,17,// Ensure global variables are fully initialized.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/Interp/Context.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Interp/Context.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Interp/Context.cpp:11,Integrability,wrap,wrapper,11,/// Simple wrapper around getFloatTypeSemantics() to make code a; /// little shorter.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/Interp/Context.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Interp/Context.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Interp/Context.cpp:4,Usability,Simpl,Simple,4,/// Simple wrapper around getFloatTypeSemantics() to make code a; /// little shorter.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/Interp/Context.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Interp/Context.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Interp/Context.cpp:123,Security,access,access,123,"// State gets destroyed here, so the Stk.clear() below doesn't accidentally; // remove values the State's destructor might access.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/Interp/Context.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Interp/Context.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Interp/Context.cpp:41,Usability,clear,clear,41,"// State gets destroyed here, so the Stk.clear() below doesn't accidentally; // remove values the State's destructor might access.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/Interp/Context.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Interp/Context.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Interp/Context.h:559,Availability,error,errors,559,"//===--- Context.h - Context for the constexpr VM ---------------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // Defines the constexpr execution context.; //; // The execution context manages cached bytecode and the global context.; // It invokes the compiler and interpreter, propagating errors.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/Interp/Context.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Interp/Context.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Interp/Context.h:462,Performance,cache,cached,462,"//===--- Context.h - Context for the constexpr VM ---------------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // Defines the constexpr execution context.; //; // The execution context manages cached bytecode and the global context.; // It invokes the compiler and interpreter, propagating errors.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/Interp/Context.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Interp/Context.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Interp/Context.h:46,Modifiability,variab,variable,46,/// Returns whether we should create a global variable for the; /// given ValueDecl.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/Interp/Context.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Interp/Context.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Interp/Descriptor.cpp:107,Energy Efficiency,allocate,allocate,107,"// Floating types are special. They are primitives, but need their; // destructor called, since they might allocate memory.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/Interp/Descriptor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Interp/Descriptor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Interp/Descriptor.h:328,Energy Efficiency,allocate,allocated,328,"/// Inline descriptor embedded in structures and arrays.; ///; /// Such descriptors precede all composite array elements and structure fields.; /// If the base of a pointer is not zero, the base points to the end of this; /// structure. The offset field is used to traverse the pointer chain up; /// to the root structure which allocated the object.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/Interp/Descriptor.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Interp/Descriptor.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Interp/Descriptor.h:43,Availability,error,error,43,"/// Original declaration, used to emit the error message.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/Interp/Descriptor.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Interp/Descriptor.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Interp/Descriptor.h:49,Integrability,message,message,49,"/// Original declaration, used to emit the error message.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/Interp/Descriptor.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Interp/Descriptor.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Interp/Descriptor.h:4,Energy Efficiency,Allocate,Allocates,4,/// Allocates a descriptor for a primitive.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/Interp/Descriptor.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Interp/Descriptor.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Interp/Descriptor.h:4,Energy Efficiency,Allocate,Allocates,4,/// Allocates a descriptor for an array of primitives.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/Interp/Descriptor.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Interp/Descriptor.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Interp/Descriptor.h:4,Energy Efficiency,Allocate,Allocates,4,/// Allocates a descriptor for an array of primitives of unknown size.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/Interp/Descriptor.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Interp/Descriptor.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Interp/Descriptor.h:4,Energy Efficiency,Allocate,Allocates,4,/// Allocates a descriptor for an array of composites.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/Interp/Descriptor.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Interp/Descriptor.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Interp/Descriptor.h:4,Energy Efficiency,Allocate,Allocates,4,/// Allocates a descriptor for an array of composites of unknown size.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/Interp/Descriptor.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Interp/Descriptor.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Interp/Descriptor.h:4,Energy Efficiency,Allocate,Allocates,4,/// Allocates a descriptor for a record.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/Interp/Descriptor.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Interp/Descriptor.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Interp/Descriptor.h:16,Energy Efficiency,allocate,allocated,16,"/// Returns the allocated size, including metadata.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/Interp/Descriptor.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Interp/Descriptor.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Interp/EvalEmitter.cpp:3,Energy Efficiency,Allocate,Allocate,3,// Allocate memory for a local.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/Interp/EvalEmitter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Interp/EvalEmitter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Interp/EvalEmitter.cpp:20,Modifiability,variab,variable,20,// Initialize local variable inline descriptor.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/Interp/EvalEmitter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Interp/EvalEmitter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Interp/EvaluationResult.h:49,Availability,error,error,49,// Leave everything empty. Can be used as an; // error marker or for void return values.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/Interp/EvaluationResult.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Interp/EvaluationResult.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Interp/Function.h:505,Modifiability,variab,variables,505,"//===--- Function.h - Bytecode function for the VM --------------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // Defines the Function class which holds all bytecode function-specific data.; //; // The scope class which describes local variables is also defined here.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/Interp/Function.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Interp/Function.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Interp/Function.h:147,Modifiability,variab,variables,147,"/// Bytecode function.; ///; /// Contains links to the bytecode of the function, as well as metadata; /// describing all arguments and stack-local variables.; ///; /// # Calling Convention; ///; /// When calling a function, all argument values must be on the stack.; ///; /// If the function has a This pointer (i.e. hasThisPointer() returns true,; /// the argument values need to be preceeded by a Pointer for the This object.; ///; /// If the function uses Return Value Optimization, the arguments (and; /// potentially the This pointer) need to be preceeded by a Pointer pointing; /// to the location to construct the returned value.; ///; /// After the function has been called, it will remove all arguments,; /// including RVO and This pointer, from the stack.; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/Interp/Function.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Interp/Function.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Interp/Function.h:472,Performance,Optimiz,Optimization,472,"/// Bytecode function.; ///; /// Contains links to the bytecode of the function, as well as metadata; /// describing all arguments and stack-local variables.; ///; /// # Calling Convention; ///; /// When calling a function, all argument values must be on the stack.; ///; /// If the function has a This pointer (i.e. hasThisPointer() returns true,; /// the argument values need to be preceeded by a Pointer for the This object.; ///; /// If the function uses Return Value Optimization, the arguments (and; /// potentially the This pointer) need to be preceeded by a Pointer pointing; /// to the location to construct the returned value.; ///; /// After the function has been called, it will remove all arguments,; /// including RVO and This pointer, from the stack.; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/Interp/Function.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Interp/Function.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Interp/Function.h:43,Performance,Optimiz,Optimization,43,"/// Whether this function has Return Value Optimization, i.e.; /// the return value is constructed in the caller's stack frame.; /// This is done for functions that return non-primive values.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/Interp/Function.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Interp/Function.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Interp/Integral.h:22,Integrability,Wrap,Wrapper,22,"//===--- Integral.h - Wrapper for numeric types for the VM ------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // Defines the VM types and helpers operating on types.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/Interp/Integral.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Interp/Integral.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Interp/Integral.h:4,Integrability,Wrap,Wrapper,4,"/// Wrapper around numeric types.; ///; /// These wrappers are required to shared an interface between APSint and; /// builtin primitive numeral types, while optimising for storage and; /// allowing methods operating on primitive type to compile to fast code.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/Interp/Integral.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Interp/Integral.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Interp/Integral.h:50,Integrability,wrap,wrappers,50,"/// Wrapper around numeric types.; ///; /// These wrappers are required to shared an interface between APSint and; /// builtin primitive numeral types, while optimising for storage and; /// allowing methods operating on primitive type to compile to fast code.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/Interp/Integral.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Interp/Integral.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Interp/Integral.h:85,Integrability,interface,interface,85,"/// Wrapper around numeric types.; ///; /// These wrappers are required to shared an interface between APSint and; /// builtin primitive numeral types, while optimising for storage and; /// allowing methods operating on primitive type to compile to fast code.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/Interp/Integral.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Interp/Integral.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Interp/IntegralAP.h:22,Integrability,Wrap,Wrapper,22,"//===--- Integral.h - Wrapper for numeric types for the VM ------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // Defines the VM types and helpers operating on types.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/Interp/IntegralAP.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Interp/IntegralAP.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Interp/IntegralAP.h:38,Modifiability,variab,variables,38,/// Arbitrary value for uninitialized variables.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/Interp/IntegralAP.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Interp/IntegralAP.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Interp/Interp.cpp:54,Modifiability,inherit,inherited,54,"// If this function is not constexpr because it is an inherited; // non-constexpr constructor, diagnose that directly.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/Interp/Interp.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Interp/Interp.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Interp/Interp.cpp:82,Modifiability,inherit,inheriting,82,"// FIXME: If DiagDecl is an implicitly-declared special member function; // or an inheriting constructor, we should be much more explicit about why; // it's not constexpr.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/Interp/Interp.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Interp/Interp.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Interp/Interp.cpp:32,Integrability,depend,depends,32,"// Inexact result means that it depends on rounding mode. If the requested; // mode is dynamic, the evaluation cannot be made in compile time.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/Interp/Interp.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Interp/Interp.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Interp/Interp.h:18,Modifiability,variab,variable,18,/// Checks if the variable has externally defined storage.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/Interp/Interp.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Interp/Interp.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Interp/Interp.h:36,Security,access,accessible,36,/// Checks if a pointer is live and accessible.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/Interp/Interp.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Interp/Interp.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Interp/Interp.h:63,Modifiability,variab,variable,63,/// Checks if the Descriptor is of a constexpr or const global variable.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/Interp/Interp.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Interp/Interp.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Interp/Interp.h:29,Performance,load,loaded,29,/// Checks if a value can be loaded from a block.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/Interp/Interp.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Interp/Interp.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Interp/Interp.h:108,Modifiability,variab,variable,108,"// Make sure returned pointers are live. We might be trying to return a; // pointer or reference to a local variable.; // Just return false, since a diagnostic has already been emitted in Sema.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/Interp/Interp.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Interp/Interp.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Interp/Interp.h:45,Performance,Load,Load,45,/// 1) Pops a pointer from the stack; /// 2) Load the value from the pointer; /// 3) Writes the value increased by one back to the pointer; /// 4) Pushes the original (pre-inc) value on the stack.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/Interp/Interp.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Interp/Interp.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Interp/Interp.h:45,Performance,Load,Load,45,/// 1) Pops a pointer from the stack; /// 2) Load the value from the pointer; /// 3) Writes the value increased by one back to the pointer,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/Interp/Interp.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Interp/Interp.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Interp/Interp.h:45,Performance,Load,Load,45,/// 1) Pops a pointer from the stack; /// 2) Load the value from the pointer; /// 3) Writes the value decreased by one back to the pointer; /// 4) Pushes the original (pre-dec) value on the stack.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/Interp/Interp.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Interp/Interp.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Interp/Interp.h:45,Performance,Load,Load,45,/// 1) Pops a pointer from the stack; /// 2) Load the value from the pointer; /// 3) Writes the value decreased by one back to the pointer,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/Interp/Interp.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Interp/Interp.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Interp/Interp.h:95,Testability,Test,Test,95,"//===----------------------------------------------------------------------===//; // Dup, Pop, Test; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/Interp/Interp.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Interp/Interp.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Interp/Interp.h:76,Modifiability,variab,variable,76,/// 1) Pops the value from the stack.; /// 2) Writes the value to the local variable with the; /// given offset.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/Interp/Interp.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Interp/Interp.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Interp/Interp.h:85,Performance,Load,Load,85,"//===----------------------------------------------------------------------===//; // Load, Store, Init; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/Interp/Interp.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Interp/Interp.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Interp/Interp.h:23,Testability,assert,assert,23,// Note that we cannot assert(CallResult.hasValue()) here since; // Ret() above only sets the APValue if the curent frame doesn't; // have a caller set.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/Interp/Interp.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Interp/Interp.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Interp/Interp.h:38,Availability,DOWN,DOWN,38,"// If the function we call is further DOWN the hierarchy than the; // FieldDesc of our pointer, just get the DeclDesc instead, which; // is the furthest we might go up in the hierarchy.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/Interp/Interp.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Interp/Interp.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Interp/InterpBlock.cpp:21,Energy Efficiency,Allocate,Allocated,21,"//===--- Block.cpp - Allocated blocks for the interpreter -------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // Defines the classes describing allocated blocks.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/Interp/InterpBlock.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Interp/InterpBlock.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Interp/InterpBlock.cpp:414,Energy Efficiency,allocate,allocated,414,"//===--- Block.cpp - Allocated blocks for the interpreter -------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // Defines the classes describing allocated blocks.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/Interp/InterpBlock.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Interp/InterpBlock.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Interp/InterpBlock.h:24,Energy Efficiency,Allocate,Allocated,24,"//===-- InterpBlock.h - Allocated blocks for the interpreter -*- C++ ----*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // Defines the classes describing allocated blocks.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/Interp/InterpBlock.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Interp/InterpBlock.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Interp/InterpBlock.h:414,Energy Efficiency,allocate,allocated,414,"//===-- InterpBlock.h - Allocated blocks for the interpreter -*- C++ ----*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // Defines the classes describing allocated blocks.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/Interp/InterpBlock.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Interp/InterpBlock.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Interp/InterpBuiltin.cpp:44,Integrability,depend,dependent,44,"/// Pushes \p Val to the stack, as a target-dependent 'int'.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/Interp/InterpBuiltin.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Interp/InterpBuiltin.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Interp/InterpBuiltin.cpp:44,Integrability,depend,dependent,44,"/// Pushes \p Val to the stack, as a target-dependent 'long'.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/Interp/InterpBuiltin.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Interp/InterpBuiltin.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Interp/InterpBuiltin.cpp:23,Usability,simpl,simply,23,// The return value is simply the value of the first parameter.; // We ignore the probability.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/Interp/InterpBuiltin.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Interp/InterpBuiltin.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Interp/InterpFrame.cpp:3,Energy Efficiency,Allocate,Allocate,3,// Allocate memory to store the parameter and the block metadata.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/Interp/InterpFrame.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Interp/InterpFrame.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Interp/InterpFrame.h:24,Modifiability,variab,variables,24,/// Frame storing local variables.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/Interp/InterpFrame.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Interp/InterpFrame.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Interp/InterpFrame.h:33,Modifiability,variab,variable,33,/// Returns the value of a local variable.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/Interp/InterpFrame.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Interp/InterpFrame.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Interp/InterpFrame.h:20,Modifiability,variab,variable,20,/// Mutates a local variable.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/Interp/InterpFrame.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Interp/InterpFrame.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Interp/InterpFrame.h:33,Modifiability,variab,variables,33,/// Returns a pointer to a local variables.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/Interp/InterpFrame.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Interp/InterpFrame.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Interp/InterpFrame.h:43,Modifiability,variab,variables,43,"/// Fixed, initial storage for known local variables.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/Interp/InterpFrame.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Interp/InterpFrame.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Interp/InterpStack.h:4,Usability,Clear,Clears,4,/// Clears the stack without calling any destructors.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/Interp/InterpStack.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Interp/InterpStack.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Interp/InterpStack.h:4,Energy Efficiency,Allocate,Allocate,4,/// Allocate stack space in 1Mb chunks.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/Interp/InterpStack.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Interp/InterpStack.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Interp/InterpState.cpp:3,Energy Efficiency,Allocate,Allocate,3,"// Allocate a new block, transferring over pointers.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/Interp/InterpState.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Interp/InterpState.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Interp/InterpState.h:15,Security,access,accessors,15,// Stack frame accessors.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/Interp/InterpState.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Interp/InterpState.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Interp/InterpState.h:3,Security,Access,Access,3,// Access objects from the walker context.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/Interp/InterpState.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Interp/InterpState.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Interp/InterpState.h:29,Deployability,update,updates,29,// Forward status checks and updates to the walker.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/Interp/InterpState.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Interp/InterpState.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Interp/Pointer.h:76,Energy Efficiency,allocate,allocated,76,"/// A pointer to a memory block, live or dead.; ///; /// This object can be allocated into interpreter stack frames. If pointing to; /// a live block, it is a link in the chain of pointers pointing to the block.; ///; /// In the simplest form, a Pointer has a Block* (the pointee) and both Base; /// and Offset are 0, which means it will point to raw data.; ///; /// The Base field is used to access metadata about the data. For primitive; /// arrays, the Base is followed by an InitMap. In a variety of cases, the; /// Base is preceded by an InlineDescriptor, which is used to track the; /// initialization state, among other things.; ///; /// The Offset field is used to access the actual data. In other words, the; /// data the pointer decribes can be found at; /// Pointee->rawData() + Pointer.Offset.; ///; ///; /// Pointee Offset; /// │ │; /// │ │; /// ▼ ▼; /// ┌───────┬────────────┬─────────┬────────────────────────────┐; /// │ Block │ InlineDesc │ InitMap │ Actual Data │; /// └───────┴────────────┴─────────┴────────────────────────────┘; /// ▲; /// │; /// │; /// Base",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/Interp/Pointer.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Interp/Pointer.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Interp/Pointer.h:393,Security,access,access,393,"/// A pointer to a memory block, live or dead.; ///; /// This object can be allocated into interpreter stack frames. If pointing to; /// a live block, it is a link in the chain of pointers pointing to the block.; ///; /// In the simplest form, a Pointer has a Block* (the pointee) and both Base; /// and Offset are 0, which means it will point to raw data.; ///; /// The Base field is used to access metadata about the data. For primitive; /// arrays, the Base is followed by an InitMap. In a variety of cases, the; /// Base is preceded by an InlineDescriptor, which is used to track the; /// initialization state, among other things.; ///; /// The Offset field is used to access the actual data. In other words, the; /// data the pointer decribes can be found at; /// Pointee->rawData() + Pointer.Offset.; ///; ///; /// Pointee Offset; /// │ │; /// │ │; /// ▼ ▼; /// ┌───────┬────────────┬─────────┬────────────────────────────┐; /// │ Block │ InlineDesc │ InitMap │ Actual Data │; /// └───────┴────────────┴─────────┴────────────────────────────┘; /// ▲; /// │; /// │; /// Base",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/Interp/Pointer.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Interp/Pointer.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Interp/Pointer.h:673,Security,access,access,673,"/// A pointer to a memory block, live or dead.; ///; /// This object can be allocated into interpreter stack frames. If pointing to; /// a live block, it is a link in the chain of pointers pointing to the block.; ///; /// In the simplest form, a Pointer has a Block* (the pointee) and both Base; /// and Offset are 0, which means it will point to raw data.; ///; /// The Base field is used to access metadata about the data. For primitive; /// arrays, the Base is followed by an InitMap. In a variety of cases, the; /// Base is preceded by an InlineDescriptor, which is used to track the; /// initialization state, among other things.; ///; /// The Offset field is used to access the actual data. In other words, the; /// data the pointer decribes can be found at; /// Pointee->rawData() + Pointer.Offset.; ///; ///; /// Pointee Offset; /// │ │; /// │ │; /// ▼ ▼; /// ┌───────┬────────────┬─────────┬────────────────────────────┐; /// │ Block │ InlineDesc │ InitMap │ Actual Data │; /// └───────┴────────────┴─────────┴────────────────────────────┘; /// ▲; /// │; /// │; /// Base",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/Interp/Pointer.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Interp/Pointer.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Interp/Pointer.h:229,Usability,simpl,simplest,229,"/// A pointer to a memory block, live or dead.; ///; /// This object can be allocated into interpreter stack frames. If pointing to; /// a live block, it is a link in the chain of pointers pointing to the block.; ///; /// In the simplest form, a Pointer has a Block* (the pointee) and both Base; /// and Offset are 0, which means it will point to raw data.; ///; /// The Base field is used to access metadata about the data. For primitive; /// arrays, the Base is followed by an InitMap. In a variety of cases, the; /// Base is preceded by an InlineDescriptor, which is used to track the; /// initialization state, among other things.; ///; /// The Offset field is used to access the actual data. In other words, the; /// data the pointer decribes can be found at; /// Pointee->rawData() + Pointer.Offset.; ///; ///; /// Pointee Offset; /// │ │; /// │ │; /// ▼ ▼; /// ┌───────┬────────────┬─────────┬────────────────────────────┐; /// │ Block │ InlineDesc │ InitMap │ Actual Data │; /// └───────┴────────────┴─────────┴────────────────────────────┘; /// ▲; /// │; /// │; /// Base",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/Interp/Pointer.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Interp/Pointer.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Interp/Pointer.h:36,Testability,test,tests,36,/// Equality operators are just for tests.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/Interp/Pointer.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Interp/Pointer.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Interp/Pointer.h:37,Usability,usab,usable,37,/// Converts the pointer to a string usable in diagnostics.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/Interp/Pointer.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Interp/Pointer.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Interp/Pointer.h:47,Usability,undo,undoing,47,"/// Expands a pointer to the containing array, undoing narrowing.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/Interp/Pointer.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Interp/Pointer.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Interp/Pointer.h:4,Security,Access,Accessor,4,/// Accessor for information about the declaration site.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/Interp/Pointer.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Interp/Pointer.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Interp/Pointer.h:4,Security,Access,Accessors,4,/// Accessors for information about the innermost field.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/Interp/Pointer.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Interp/Pointer.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Interp/PrimType.h:90,Security,expose,exposes,90,// namespace clang; /// Helper macro to simplify type switches.; /// The macro implicitly exposes a type T in the scope of the inner block.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/Interp/PrimType.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Interp/PrimType.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Interp/PrimType.h:40,Usability,simpl,simplify,40,// namespace clang; /// Helper macro to simplify type switches.; /// The macro implicitly exposes a type T in the scope of the inner block.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/Interp/PrimType.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Interp/PrimType.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Interp/Program.cpp:3,Energy Efficiency,Allocate,Allocate,3,// Allocate storage for the string.; // The byte length does not include the null terminator.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/Interp/Program.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Interp/Program.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Interp/Program.cpp:3,Energy Efficiency,Allocate,Allocate,3,// Allocate a block for storage.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/Interp/Program.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Interp/Program.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Interp/Program.cpp:3,Energy Efficiency,Allocate,Allocate,3,// Allocate a block for storage.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/Interp/Program.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Interp/Program.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Interp/Program.cpp:39,Security,access,accessed,39,// Array of unknown bounds - cannot be accessed and pointer arithmetic; // is forbidden on pointers to such objects.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/Interp/Program.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Interp/Program.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Interp/Program.h:119,Energy Efficiency,allocate,allocated,119,"// Manually destroy all the blocks. They are almost all harmless,; // but primitive arrays might have an InitMap* heap allocated and; // that needs to be freed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/Interp/Program.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Interp/Program.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Interp/Program.h:26,Energy Efficiency,allocate,allocate,26,"// Records might actually allocate memory themselves, but they; // are allocated using a BumpPtrAllocator. Call their desctructors; // here manually so they are properly freeing their resources.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/Interp/Program.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Interp/Program.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Interp/Program.h:71,Energy Efficiency,allocate,allocated,71,"// Records might actually allocate memory themselves, but they; // are allocated using a BumpPtrAllocator. Call their desctructors; // here manually so they are properly freeing their resources.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/Interp/Program.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Interp/Program.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Interp/Program.h:37,Modifiability,extend,extended,37,/// Creates a global from a lifetime-extended temporary.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/Interp/Program.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Interp/Program.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Interp/Program.h:26,Performance,cache,cached,26,/// Mapping from decls to cached bytecode functions.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/Interp/Program.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Interp/Program.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Interp/Program.h:4,Performance,Cache,Cached,4,/// Cached native pointer indices.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/Interp/Program.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Interp/Program.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Interp/Program.h:4,Energy Efficiency,Allocate,Allocates,4,"/// Allocates the global in the pool, reserving storate for data.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/Interp/Program.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Interp/Program.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Interp/Program.h:4,Performance,Cache,Cached,4,/// Cached global indices.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/Interp/Program.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Interp/Program.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Interp/Source.h:4,Integrability,Interface,Interface,4,/// Interface for classes which map locations to sources.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/Interp/Source.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Interp/Source.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Interp/State.cpp:31,Modifiability,inherit,inheriting,31,"// Use a different note for an inheriting constructor, because from the; // user's perspective it's not really a function at all.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/Interp/State.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Interp/State.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Interp/State.h:27,Performance,perform,perform,27,"/// Kinds of access we can perform on an object, for diagnostics. Note that; /// we consider a member function call to be a kind of access, even though; /// it is not formally an access of the object, because it has (largely) the; /// same set of semantic restrictions.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/Interp/State.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Interp/State.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Interp/State.h:13,Security,access,access,13,"/// Kinds of access we can perform on an object, for diagnostics. Note that; /// we consider a member function call to be a kind of access, even though; /// it is not formally an access of the object, because it has (largely) the; /// same set of semantic restrictions.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/Interp/State.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Interp/State.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Interp/State.h:132,Security,access,access,132,"/// Kinds of access we can perform on an object, for diagnostics. Note that; /// we consider a member function call to be a kind of access, even though; /// it is not formally an access of the object, because it has (largely) the; /// same set of semantic restrictions.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/Interp/State.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Interp/State.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Interp/State.h:179,Security,access,access,179,"/// Kinds of access we can perform on an object, for diagnostics. Note that; /// we consider a member function call to be a kind of access, even though; /// it is not formally an access of the object, because it has (largely) the; /// same set of semantic restrictions.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/Interp/State.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Interp/State.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Interp/State.h:4,Integrability,Interface,Interface,4,/// Interface for the VM to interact with the AST walker's context.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/Interp/State.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Interp/State.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Interp/State.h:34,Integrability,message,message,34,/// Directly reports a diagnostic message.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/Interp/State.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Interp/State.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/ASTMatchers/ASTMatchersInternal.cpp:105,Energy Efficiency,reduce,reduce,105,"// We only ever need one instance of TrueMatcherImpl, so we create a static; // instance and reuse it to reduce the overhead of the matcher and increase; // the chance of cache hits.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/ASTMatchers/ASTMatchersInternal.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/ASTMatchers/ASTMatchersInternal.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/ASTMatchers/ASTMatchersInternal.cpp:171,Performance,cache,cache,171,"// We only ever need one instance of TrueMatcherImpl, so we create a static; // instance and reuse it to reduce the overhead of the matcher and increase; // the chance of cache hits.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/ASTMatchers/ASTMatchersInternal.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/ASTMatchers/ASTMatchersInternal.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/ASTMatchers/ASTMatchersInternal.cpp:369,Integrability,depend,depend,369,"// The 'unless' matcher will always discard the result:; // If the inner matcher doesn't match, unless returns true,; // but the inner matcher cannot have bound anything.; // If the inner matcher matches, the result is false, and; // any possible binding will be discarded.; // We still need to hand in all the bound nodes up to this; // point so the inner matcher can depend on bound nodes,; // and we need to actively discard the bound nodes, otherwise; // the inner matcher will reset the bound nodes if it doesn't; // match, but this would be inversed by 'unless'.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/ASTMatchers/ASTMatchersInternal.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/ASTMatchers/ASTMatchersInternal.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/ASTMatchers/ASTMatchersInternal.cpp:3,Usability,Simpl,Simple,3,// Simple name.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/ASTMatchers/ASTMatchersInternal.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/ASTMatchers/ASTMatchersInternal.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/ASTMatchers/ASTMatchersInternal.cpp:185,Availability,failure,failure,185,"// This function is copied and adapted from NamedDecl::printQualifiedName(); // By matching each part individually we optimize in a couple of ways:; // - We can exit early on the first failure.; // - We can skip inline/anonymous namespaces without another pass.; // - We print one name at a time, reducing the chance of overflowing the; // inlined space of the SmallString.; // First, match the name.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/ASTMatchers/ASTMatchersInternal.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/ASTMatchers/ASTMatchersInternal.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/ASTMatchers/ASTMatchersInternal.cpp:31,Energy Efficiency,adapt,adapted,31,"// This function is copied and adapted from NamedDecl::printQualifiedName(); // By matching each part individually we optimize in a couple of ways:; // - We can exit early on the first failure.; // - We can skip inline/anonymous namespaces without another pass.; // - We print one name at a time, reducing the chance of overflowing the; // inlined space of the SmallString.; // First, match the name.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/ASTMatchers/ASTMatchersInternal.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/ASTMatchers/ASTMatchersInternal.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/ASTMatchers/ASTMatchersInternal.cpp:31,Modifiability,adapt,adapted,31,"// This function is copied and adapted from NamedDecl::printQualifiedName(); // By matching each part individually we optimize in a couple of ways:; // - We can exit early on the first failure.; // - We can skip inline/anonymous namespaces without another pass.; // - We print one name at a time, reducing the chance of overflowing the; // inlined space of the SmallString.; // First, match the name.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/ASTMatchers/ASTMatchersInternal.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/ASTMatchers/ASTMatchersInternal.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/ASTMatchers/ASTMatchersInternal.cpp:118,Performance,optimiz,optimize,118,"// This function is copied and adapted from NamedDecl::printQualifiedName(); // By matching each part individually we optimize in a couple of ways:; // - We can exit early on the first failure.; // - We can skip inline/anonymous namespaces without another pass.; // - We print one name at a time, reducing the chance of overflowing the; // inlined space of the SmallString.; // First, match the name.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/ASTMatchers/ASTMatchersInternal.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/ASTMatchers/ASTMatchersInternal.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/ASTMatchers/ASTMatchersInternal.cpp:87,Safety,safe,safely,87,// Linkage Spec can just be ignored; // FIXME: Any other DeclContext kinds that can be safely disregarded,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/ASTMatchers/ASTMatchersInternal.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/ASTMatchers/ASTMatchersInternal.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/ASTMatchers/ASTMatchFinder.cpp:410,Energy Efficiency,efficient,efficiently,410,"//===--- ASTMatchFinder.cpp - Structural query framework ------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // Implements an algorithm to efficiently search for matches on AST nodes.; // Uses memoization to support recursive matches like HasDescendant.; //; // The general idea is to visit all AST nodes with a RecursiveASTVisitor,; // calling the Matches(...) method of each matcher we are running on each; // AST node. The matcher can recurse via the ASTMatchFinder interface.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/ASTMatchers/ASTMatchFinder.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/ASTMatchers/ASTMatchFinder.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/ASTMatchers/ASTMatchFinder.cpp:740,Integrability,interface,interface,740,"//===--- ASTMatchFinder.cpp - Structural query framework ------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // Implements an algorithm to efficiently search for matches on AST nodes.; // Uses memoization to support recursive matches like HasDescendant.; //; // The general idea is to visit all AST nodes with a RecursiveASTVisitor,; // calling the Matches(...) method of each matcher we are running on each; // AST node. The matcher can recurse via the ASTMatchFinder interface.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/ASTMatchers/ASTMatchFinder.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/ASTMatchers/ASTMatchFinder.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/ASTMatchers/ASTMatchFinder.cpp:148,Energy Efficiency,consumption,consumption,148,"// The maximum number of memoization entries to store.; // 10k has been experimentally found to give a good trade-off; // of performance vs. memory consumption by running matcher; // that match on every statement over a very large codebase.; //; // FIXME: Do some performance optimization in general and; // revisit this number; also, put up micro-benchmarks that we can; // optimize this on.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/ASTMatchers/ASTMatchFinder.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/ASTMatchers/ASTMatchFinder.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/ASTMatchers/ASTMatchFinder.cpp:125,Performance,perform,performance,125,"// The maximum number of memoization entries to store.; // 10k has been experimentally found to give a good trade-off; // of performance vs. memory consumption by running matcher; // that match on every statement over a very large codebase.; //; // FIXME: Do some performance optimization in general and; // revisit this number; also, put up micro-benchmarks that we can; // optimize this on.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/ASTMatchers/ASTMatchFinder.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/ASTMatchers/ASTMatchFinder.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/ASTMatchers/ASTMatchFinder.cpp:264,Performance,perform,performance,264,"// The maximum number of memoization entries to store.; // 10k has been experimentally found to give a good trade-off; // of performance vs. memory consumption by running matcher; // that match on every statement over a very large codebase.; //; // FIXME: Do some performance optimization in general and; // revisit this number; also, put up micro-benchmarks that we can; // optimize this on.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/ASTMatchers/ASTMatchFinder.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/ASTMatchers/ASTMatchFinder.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/ASTMatchers/ASTMatchFinder.cpp:276,Performance,optimiz,optimization,276,"// The maximum number of memoization entries to store.; // 10k has been experimentally found to give a good trade-off; // of performance vs. memory consumption by running matcher; // that match on every statement over a very large codebase.; //; // FIXME: Do some performance optimization in general and; // revisit this number; also, put up micro-benchmarks that we can; // optimize this on.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/ASTMatchers/ASTMatchFinder.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/ASTMatchers/ASTMatchFinder.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/ASTMatchers/ASTMatchFinder.cpp:375,Performance,optimiz,optimize,375,"// The maximum number of memoization entries to store.; // 10k has been experimentally found to give a good trade-off; // of performance vs. memory consumption by running matcher; // that match on every statement over a very large codebase.; //; // FIXME: Do some performance optimization in general and; // revisit this number; also, put up micro-benchmarks that we can; // optimize this on.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/ASTMatchers/ASTMatchFinder.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/ASTMatchers/ASTMatchFinder.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/ASTMatchers/ASTMatchFinder.cpp:348,Testability,benchmark,benchmarks,348,"// The maximum number of memoization entries to store.; // 10k has been experimentally found to give a good trade-off; // of performance vs. memory consumption by running matcher; // that match on every statement over a very large codebase.; //; // FIXME: Do some performance optimization in general and; // revisit this number; also, put up micro-benchmarks that we can; // optimize this on.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/ASTMatchers/ASTMatchFinder.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/ASTMatchers/ASTMatchFinder.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/ASTMatchers/ASTMatchFinder.cpp:25,Safety,avoid,avoid,25,"// We use memoization to avoid running the same matcher on the same; // AST node twice. This struct is the key for looking up match; // result. It consists of an ID of the MatcherInterface (for; // identifying the matcher), a pointer to the AST node and the; // bound nodes before the matcher was executed.; //; // We currently only memoize on nodes whose pointers identify the; // nodes (\c Stmt and \c Decl, but not \c QualType or \c TypeLoc).; // For \c QualType and \c TypeLoc it is possible to implement; // generation of keys for each type.; // FIXME: Benchmark whether memoization of non-pointer typed nodes; // provides enough benefit for the additional amount of code.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/ASTMatchers/ASTMatchFinder.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/ASTMatchers/ASTMatchFinder.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/ASTMatchers/ASTMatchFinder.cpp:558,Testability,Benchmark,Benchmark,558,"// We use memoization to avoid running the same matcher on the same; // AST node twice. This struct is the key for looking up match; // result. It consists of an ID of the MatcherInterface (for; // identifying the matcher), a pointer to the AST node and the; // bound nodes before the matcher was executed.; //; // We currently only memoize on nodes whose pointers identify the; // nodes (\c Stmt and \c Decl, but not \c QualType or \c TypeLoc).; // For \c QualType and \c TypeLoc it is possible to implement; // generation of keys for each type.; // FIXME: Benchmark whether memoization of non-pointer typed nodes; // provides enough benefit for the additional amount of code.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/ASTMatchers/ASTMatchFinder.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/ASTMatchers/ASTMatchFinder.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/ASTMatchers/ASTMatchFinder.cpp:44,Testability,test,tests,44,"// FIXME: Add other base types after adding tests.; // It's OK to always overwrite the bound nodes, as if there was; // no match in this recursive branch, the result set is empty; // anyway.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/ASTMatchers/ASTMatchFinder.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/ASTMatchers/ASTMatchFinder.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/ASTMatchers/ASTMatchFinder.cpp:51,Performance,perform,perform,51,"// If we need to keep track of the depth, we can't perform data recursion.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/ASTMatchers/ASTMatchFinder.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/ASTMatchers/ASTMatchFinder.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/ASTMatchers/ASTMatchFinder.cpp:3,Safety,Abort,Abort,3,// Abort as soon as a match is found.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/ASTMatchers/ASTMatchFinder.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/ASTMatchers/ASTMatchFinder.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/ASTMatchers/ASTMatchFinder.cpp:747,Usability,simpl,simply,747,"// When we see 'typedef A B', we add name 'B' to the set of names; // A's canonical type maps to. This is necessary for implementing; // isDerivedFrom(x) properly, where x can be the name of the base; // class or any of its aliases.; //; // In general, the is-alias-of (as defined by typedefs) relation; // is tree-shaped, as you can typedef a type more than once. For; // example,; //; // typedef A B;; // typedef A C;; // typedef C D;; // typedef C E;; //; // gives you; //; // A; // |- B; // `- C; // |- D; // `- E; //; // It is wrong to assume that the relation is a chain. A correct; // implementation of isDerivedFrom() needs to recognize that B and; // E are aliases, even though neither is a typedef of the other.; // Therefore, we cannot simply walk through one typedef chain to; // find out whether the type name matches.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/ASTMatchers/ASTMatchFinder.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/ASTMatchers/ASTMatchFinder.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/ASTMatchers/ASTMatchFinder.cpp:33,Modifiability,variab,variable,33,// Don't traverse under the loop variable,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/ASTMatchers/ASTMatchFinder.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/ASTMatchers/ASTMatchFinder.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/ASTMatchers/ASTMatchFinder.cpp:13,Performance,cache,cache,13,// Reset the cache outside of the recursive call to make sure we; // don't invalidate any iterators.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/ASTMatchers/ASTMatchFinder.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/ASTMatchers/ASTMatchFinder.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/ASTMatchers/ASTMatchFinder.cpp:652,Safety,avoid,avoid,652,"// Returns whether an ancestor of \p Node matches \p Matcher.; //; // The order of matching (which can lead to different nodes being bound in; // case there are multiple matches) is breadth first search.; //; // To allow memoization in the very common case of having deeply nested; // expressions inside a template function, we first walk up the AST, memoizing; // the result of the match along the way, as long as there is only a single; // parent.; //; // Once there are multiple parents, the breadth first search order does not; // allow simple memoization on the ancestors. Thus, we only memoize as long; // as there is a single parent.; //; // We avoid a recursive implementation to prevent excessive stack use on; // very deep ASTs (similarly to RecursiveASTVisitor's data recursion).",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/ASTMatchers/ASTMatchFinder.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/ASTMatchers/ASTMatchFinder.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/ASTMatchers/ASTMatchFinder.cpp:541,Usability,simpl,simple,541,"// Returns whether an ancestor of \p Node matches \p Matcher.; //; // The order of matching (which can lead to different nodes being bound in; // case there are multiple matches) is breadth first search.; //; // To allow memoization in the very common case of having deeply nested; // expressions inside a template function, we first walk up the AST, memoizing; // the result of the match along the way, as long as there is only a single; // parent.; //; // Once there are multiple parents, the breadth first search order does not; // allow simple memoization on the ancestors. Thus, we only memoize as long; // as there is a single parent.; //; // We avoid a recursive implementation to prevent excessive stack use on; // very deep ASTs (similarly to RecursiveASTVisitor's data recursion).",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/ASTMatchers/ASTMatchFinder.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/ASTMatchers/ASTMatchFinder.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/ASTMatchers/ASTMatchFinder.cpp:32,Deployability,update,updated,32,"// Memoization keys that can be updated with the result.; // These are the memoizable nodes in the chain of unique parents, which; // terminates when a node has multiple parents, or matches, or is the root.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/ASTMatchers/ASTMatchFinder.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/ASTMatchers/ASTMatchFinder.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/ASTMatchers/ASTMatchFinder.cpp:19,Deployability,update,update,19,"// When returning, update the memoization cache.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/ASTMatchers/ASTMatchFinder.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/ASTMatchers/ASTMatchFinder.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/ASTMatchers/ASTMatchFinder.cpp:42,Performance,cache,cache,42,"// When returning, update the memoization cache.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/ASTMatchers/ASTMatchFinder.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/ASTMatchers/ASTMatchFinder.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/ASTMatchers/ASTMatchFinder.cpp:5,Performance,cache,cache,5,// A cache key only makes sense if memoization is possible.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/ASTMatchers/ASTMatchFinder.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/ASTMatchers/ASTMatchFinder.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/ASTMatchers/ASTMatchFinder.cpp:13,Performance,cache,cache,13,// Check the cache.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/ASTMatchers/ASTMatchFinder.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/ASTMatchers/ASTMatchFinder.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/ASTMatchers/ASTMatchFinder.cpp:22,Performance,cache,cache,22,// Don't populate the cache for the matching node!,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/ASTMatchers/ASTMatchFinder.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/ASTMatchers/ASTMatchFinder.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/ASTMatchers/ASTMatchFinder.cpp:329,Testability,assert,asserting,329,"// Nodes may have no parents if:; // a) the node is the TranslationUnitDecl; // b) we have a limited traversal scope that excludes the parent edges; // c) there is a bug in the AST, and the node is not reachable; // Usually the traversal scope is the whole AST, which precludes b.; // Bugs are common enough that it's worthwhile asserting when we can.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/ASTMatchers/ASTMatchFinder.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/ASTMatchers/ASTMatchFinder.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/ASTMatchers/ASTMatchFinder.cpp:122,Deployability,update,update,122,// BFS starting from the parents not yet considered.; // Memoization of newly visited nodes is not possible (but we still update; // results for the elements in the chain we found above).,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/ASTMatchers/ASTMatchFinder.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/ASTMatchers/ASTMatchFinder.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/ASTMatchers/ASTMatchFinder.cpp:142,Availability,down,down,142,"// Make sure we do not visit the same node twice.; // Otherwise, we'll visit the common ancestors as often as there; // are splits on the way down.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/ASTMatchers/ASTMatchFinder.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/ASTMatchers/ASTMatchFinder.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/ASTMatchers/ASTMatchFinder.cpp:23,Integrability,interface,interface,23,// Maps an Objective-C interface to its ObjCCompatibleAliasDecls.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/ASTMatchers/ASTMatchFinder.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/ASTMatchers/ASTMatchFinder.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/ASTMatchers/ASTMatchFinder.cpp:29,Integrability,depend,dependent,29,"// If this is the name of a (dependent) template specialization, use the; // definition of the template, even though it might be specialized later.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/ASTMatchers/ASTMatchFinder.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/ASTMatchers/ASTMatchFinder.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/ASTMatchers/ASTMatchFinder.cpp:207,Integrability,interface,interface,207,"// FIXME: Going to the primary template here isn't really correct, but; // unfortunately we accept a Decl matcher for the base class not a Type; // matcher, so it's the best thing we can do with our current interface.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/ASTMatchers/ASTMatchFinder.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/ASTMatchers/ASTMatchFinder.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/ASTMatchers/GtestMatchers.cpp:818,Energy Efficiency,efficient,efficient,818,"//===- GtestMatchers.cpp - AST Matchers for Gtest ---------------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements several matchers for popular gtest macros. In general,; // AST matchers cannot match calls to macros. However, we can simulate such; // matches if the macro definition has identifiable elements that themselves can; // be matched. In that case, we can match on those elements and then check that; // the match occurs within an expansion of the desired macro. The more uncommon; // the identified elements, the more efficient this process will be.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/ASTMatchers/GtestMatchers.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/ASTMatchers/GtestMatchers.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/ASTMatchers/GtestMatchers.cpp:141,Testability,mock,mocker,141,"// Under the hood, ON_CALL is expanded to a call to `InternalDefaultActionSetAt`; // to set a default action spec to the underlying function mocker, while; // EXPECT_CALL is expanded to a call to `InternalExpectedAt` to set a new; // expectation spec.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/ASTMatchers/GtestMatchers.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/ASTMatchers/GtestMatchers.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/ASTMatchers/GtestMatchers.cpp:370,Energy Efficiency,efficient,efficient,370,"// In general, AST matchers cannot match calls to macros. However, we can; // simulate such matches if the macro definition has identifiable elements that; // themselves can be matched. In that case, we can match on those elements and; // then check that the match occurs within an expansion of the desired; // macro. The more uncommon the identified elements, the more efficient this; // process will be.; //; // We use this approach to implement the derived matchers gtestAssert and; // gtestExpect.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/ASTMatchers/GtestMatchers.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/ASTMatchers/GtestMatchers.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/ASTMatchers/GtestMatchers.cpp:74,Integrability,depend,depending,74,// A ON_CALL or EXPECT_CALL macro expands to different AST structures; // depending on whether the mock method has arguments or not.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/ASTMatchers/GtestMatchers.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/ASTMatchers/GtestMatchers.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/ASTMatchers/GtestMatchers.cpp:99,Testability,mock,mock,99,// A ON_CALL or EXPECT_CALL macro expands to different AST structures; // depending on whether the mock method has arguments or not.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/ASTMatchers/GtestMatchers.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/ASTMatchers/GtestMatchers.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/ASTMatchers/GtestMatchers.cpp:29,Testability,mock,mock,29,"// For example,; // `ON_CALL(mock, TwoParamMethod)` is expanded to; // `mock.gmock_TwoArgsMethod(WithoutMatchers(),; // nullptr).InternalDefaultActionSetAt(...)`.; // EXPECT_CALL is the same except; // that it calls `InternalExpectedAt` instead of `InternalDefaultActionSetAt`; // in the end.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/ASTMatchers/GtestMatchers.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/ASTMatchers/GtestMatchers.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/ASTMatchers/GtestMatchers.cpp:72,Testability,mock,mock,72,"// For example,; // `ON_CALL(mock, TwoParamMethod)` is expanded to; // `mock.gmock_TwoArgsMethod(WithoutMatchers(),; // nullptr).InternalDefaultActionSetAt(...)`.; // EXPECT_CALL is the same except; // that it calls `InternalExpectedAt` instead of `InternalDefaultActionSetAt`; // in the end.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/ASTMatchers/GtestMatchers.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/ASTMatchers/GtestMatchers.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/ASTMatchers/GtestMatchers.cpp:29,Testability,mock,mock,29,"// For example,; // `ON_CALL(mock, TwoParamMethod(m1, m2))` is expanded to; // `mock.gmock_TwoParamMethod(m1,m2)(WithoutMatchers(),; // nullptr).InternalDefaultActionSetAt(...)`.; // EXPECT_CALL is the same except that it calls `InternalExpectedAt` instead; // of `InternalDefaultActionSetAt` in the end.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/ASTMatchers/GtestMatchers.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/ASTMatchers/GtestMatchers.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/ASTMatchers/GtestMatchers.cpp:80,Testability,mock,mock,80,"// For example,; // `ON_CALL(mock, TwoParamMethod(m1, m2))` is expanded to; // `mock.gmock_TwoParamMethod(m1,m2)(WithoutMatchers(),; // nullptr).InternalDefaultActionSetAt(...)`.; // EXPECT_CALL is the same except that it calls `InternalExpectedAt` instead; // of `InternalDefaultActionSetAt` in the end.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/ASTMatchers/GtestMatchers.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/ASTMatchers/GtestMatchers.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/ASTMatchers/Dynamic/Diagnostics.cpp:44,Availability,error,error,44,"//===--- Diagnostics.cpp - Helper class for error diagnostics ---*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/ASTMatchers/Dynamic/Diagnostics.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/ASTMatchers/Dynamic/Diagnostics.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/ASTMatchers/Dynamic/Diagnostics.cpp:13,Availability,error,errors,13,// Merge all errors that happened while in this context.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/ASTMatchers/Dynamic/Diagnostics.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/ASTMatchers/Dynamic/Diagnostics.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/ASTMatchers/Dynamic/Diagnostics.cpp:14,Availability,error,errors,14,// Revert the errors.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/ASTMatchers/Dynamic/Diagnostics.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/ASTMatchers/Dynamic/Diagnostics.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/ASTMatchers/Dynamic/Diagnostics.cpp:42,Availability,error,error,42,// TODO: Add type info about the overload error.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/ASTMatchers/Dynamic/Diagnostics.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/ASTMatchers/Dynamic/Diagnostics.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/ASTMatchers/Dynamic/Marshallers.h:430,Integrability,wrap,wrap,430,"//===- Marshallers.h - Generic matcher function marshallers -----*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; /// \file; /// Functions templates and classes to wrap matcher construct functions.; ///; /// A collection of template function and classes that provide a generic; /// marshalling layer on top of matcher construct functions.; /// These are used by the registry to export all marshaller constructors with; /// the same generic interface.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/ASTMatchers/Dynamic/Marshallers.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/ASTMatchers/Dynamic/Marshallers.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/ASTMatchers/Dynamic/Marshallers.h:706,Integrability,interface,interface,706,"//===- Marshallers.h - Generic matcher function marshallers -----*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; /// \file; /// Functions templates and classes to wrap matcher construct functions.; ///; /// A collection of template function and classes that provide a generic; /// marshalling layer on top of matcher construct functions.; /// These are used by the registry to export all marshaller constructors with; /// the same generic interface.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/ASTMatchers/Dynamic/Marshallers.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/ASTMatchers/Dynamic/Marshallers.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/ASTMatchers/Dynamic/Marshallers.h:23,Integrability,interface,interface,23,"/// Matcher descriptor interface.; ///; /// Provides a \c create() method that constructs the matcher from the provided; /// arguments, and various other methods for type introspection.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/ASTMatchers/Dynamic/Marshallers.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/ASTMatchers/Dynamic/Marshallers.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/ASTMatchers/Dynamic/Marshallers.h:218,Energy Efficiency,charge,charge,218,"/// Simple callback implementation. Marshaller and function are provided.; ///; /// This class wraps a function of arbitrary signature and a marshaller; /// function into a MatcherDescriptor.; /// The marshaller is in charge of taking the VariantValue arguments, checking; /// their types, unpacking them and calling the underlying function.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/ASTMatchers/Dynamic/Marshallers.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/ASTMatchers/Dynamic/Marshallers.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/ASTMatchers/Dynamic/Marshallers.h:95,Integrability,wrap,wraps,95,"/// Simple callback implementation. Marshaller and function are provided.; ///; /// This class wraps a function of arbitrary signature and a marshaller; /// function into a MatcherDescriptor.; /// The marshaller is in charge of taking the VariantValue arguments, checking; /// their types, unpacking them and calling the underlying function.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/ASTMatchers/Dynamic/Marshallers.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/ASTMatchers/Dynamic/Marshallers.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/ASTMatchers/Dynamic/Marshallers.h:4,Usability,Simpl,Simple,4,"/// Simple callback implementation. Marshaller and function are provided.; ///; /// This class wraps a function of arbitrary signature and a marshaller; /// function into a MatcherDescriptor.; /// The marshaller is in charge of taking the VariantValue arguments, checking; /// their types, unpacking them and calling the underlying function.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/ASTMatchers/Dynamic/Marshallers.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/ASTMatchers/Dynamic/Marshallers.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/ASTMatchers/Dynamic/Marshallers.h:84,Modifiability,polymorphi,polymorphic,84,/// Helper methods to extract and merge all possible typed matchers; /// out of the polymorphic object.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/ASTMatchers/Dynamic/Marshallers.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/ASTMatchers/Dynamic/Marshallers.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/ASTMatchers/Dynamic/Marshallers.h:155,Modifiability,polymorphi,polymorphic,155,"/// Convert the return values of the functions into a VariantMatcher.; ///; /// There are 2 cases right now: The return value is a Matcher<T> or is a; /// polymorphic matcher. For the former, we just construct the VariantMatcher.; /// For the latter, we instantiate all the possible Matcher<T> of the poly; /// matcher.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/ASTMatchers/Dynamic/Marshallers.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/ASTMatchers/Dynamic/Marshallers.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/ASTMatchers/Dynamic/Marshallers.h:79,Availability,error,error,79,"// This isn't ideal, but it's better than reporting an empty string as; // the error in this case.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/ASTMatchers/Dynamic/Marshallers.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/ASTMatchers/Dynamic/Marshallers.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/ASTMatchers/Dynamic/Marshallers.h:75,Integrability,wrap,wraps,75,"/// Matcher descriptor for variadic functions.; ///; /// This class simply wraps a VariadicFunction with the right signature to export; /// it as a MatcherDescriptor.; /// This allows us to have one implementation of the interface for as many free; /// functions as we want, reducing the number of symbols and size of the; /// object file.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/ASTMatchers/Dynamic/Marshallers.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/ASTMatchers/Dynamic/Marshallers.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/ASTMatchers/Dynamic/Marshallers.h:221,Integrability,interface,interface,221,"/// Matcher descriptor for variadic functions.; ///; /// This class simply wraps a VariadicFunction with the right signature to export; /// it as a MatcherDescriptor.; /// This allows us to have one implementation of the interface for as many free; /// functions as we want, reducing the number of symbols and size of the; /// object file.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/ASTMatchers/Dynamic/Marshallers.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/ASTMatchers/Dynamic/Marshallers.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/ASTMatchers/Dynamic/Marshallers.h:68,Usability,simpl,simply,68,"/// Matcher descriptor for variadic functions.; ///; /// This class simply wraps a VariadicFunction with the right signature to export; /// it as a MatcherDescriptor.; /// This allows us to have one implementation of the interface for as many free; /// functions as we want, reducing the number of symbols and size of the; /// object file.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/ASTMatchers/Dynamic/Marshallers.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/ASTMatchers/Dynamic/Marshallers.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/ASTMatchers/Dynamic/Marshallers.h:80,Energy Efficiency,adapt,adaptative,80,/// Helper class used to collect all the possible overloads of an; /// argument adaptative matcher function.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/ASTMatchers/Dynamic/Marshallers.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/ASTMatchers/Dynamic/Marshallers.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/ASTMatchers/Dynamic/Marshallers.h:80,Modifiability,adapt,adaptative,80,/// Helper class used to collect all the possible overloads of an; /// argument adaptative matcher function.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/ASTMatchers/Dynamic/Marshallers.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/ASTMatchers/Dynamic/Marshallers.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/ASTMatchers/Dynamic/Marshallers.h:142,Availability,error,errors,142,"/// MatcherDescriptor that wraps multiple ""overloads"" of the same; /// matcher.; ///; /// It will try every overload and generate appropriate errors for when none or; /// more than one overloads match the arguments.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/ASTMatchers/Dynamic/Marshallers.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/ASTMatchers/Dynamic/Marshallers.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/ASTMatchers/Dynamic/Marshallers.h:27,Integrability,wrap,wraps,27,"/// MatcherDescriptor that wraps multiple ""overloads"" of the same; /// matcher.; ///; /// It will try every overload and generate appropriate errors for when none or; /// more than one overloads match the arguments.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/ASTMatchers/Dynamic/Marshallers.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/ASTMatchers/Dynamic/Marshallers.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/ASTMatchers/Dynamic/Marshallers.h:42,Availability,error,errors,42,// No overload matched.; // We ignore the errors if any matcher succeeded.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/ASTMatchers/Dynamic/Marshallers.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/ASTMatchers/Dynamic/Marshallers.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/ASTMatchers/Dynamic/Marshallers.h:79,Safety,detect,detect,79,"/// Helper functions to select the appropriate marshaller functions.; /// They detect the number of arguments, arguments types and return type.; /// 0-arg overload",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/ASTMatchers/Dynamic/Marshallers.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/ASTMatchers/Dynamic/Marshallers.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/ASTMatchers/Dynamic/Marshallers.h:13,Energy Efficiency,adapt,adaptative,13,/// Argument adaptative overload.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/ASTMatchers/Dynamic/Marshallers.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/ASTMatchers/Dynamic/Marshallers.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/ASTMatchers/Dynamic/Marshallers.h:13,Modifiability,adapt,adaptative,13,/// Argument adaptative overload.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/ASTMatchers/Dynamic/Marshallers.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/ASTMatchers/Dynamic/Marshallers.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/ASTMatchers/Dynamic/Parser.cpp:4,Usability,Simpl,Simple,4,/// Simple structure to hold information for one token from the parser.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/ASTMatchers/Dynamic/Parser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/ASTMatchers/Dynamic/Parser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/ASTMatchers/Dynamic/Parser.cpp:4,Usability,Simpl,Simple,4,/// Simple tokenizer for the parser.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/ASTMatchers/Dynamic/Parser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/ASTMatchers/Dynamic/Parser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/ASTMatchers/Dynamic/Parser.cpp:130,Availability,failure,failure,130,/// Parse expressions that start with an identifier.; ///; /// This function can parse named values and matchers.; /// In case of failure it will try to determine the user's intent to give; /// an appropriate error message.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/ASTMatchers/Dynamic/Parser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/ASTMatchers/Dynamic/Parser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/ASTMatchers/Dynamic/Parser.cpp:209,Availability,error,error,209,/// Parse expressions that start with an identifier.; ///; /// This function can parse named values and matchers.; /// In case of failure it will try to determine the user's intent to give; /// an appropriate error message.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/ASTMatchers/Dynamic/Parser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/ASTMatchers/Dynamic/Parser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/ASTMatchers/Dynamic/Parser.cpp:215,Integrability,message,message,215,/// Parse expressions that start with an identifier.; ///; /// This function can parse named values and matchers.; /// In case of failure it will try to determine the user's intent to give; /// an appropriate error message.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/ASTMatchers/Dynamic/Parser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/ASTMatchers/Dynamic/Parser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/ASTMatchers/Dynamic/Parser.cpp:32,Availability,error,error,32,// TODO: We could use different error codes for each/some to be more; // explicit about the syntax error.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/ASTMatchers/Dynamic/Parser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/ASTMatchers/Dynamic/Parser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/ASTMatchers/Dynamic/Parser.cpp:99,Availability,error,error,99,// TODO: We could use different error codes for each/some to be more; // explicit about the syntax error.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/ASTMatchers/Dynamic/Parser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/ASTMatchers/Dynamic/Parser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/ASTMatchers/Dynamic/Parser.cpp:181,Availability,error,error,181,"/// Parse and validate a matcher expression.; /// \return \c true on success, in which case \c Value has the matcher parsed.; /// If the input is malformed, or some argument has an error, it; /// returns \c false.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/ASTMatchers/Dynamic/Parser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/ASTMatchers/Dynamic/Parser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/ASTMatchers/Dynamic/Parser.cpp:14,Security,validat,validate,14,"/// Parse and validate a matcher expression.; /// \return \c true on success, in which case \c Value has the matcher parsed.; /// If the input is malformed, or some argument has an error, it; /// returns \c false.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/ASTMatchers/Dynamic/Parser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/ASTMatchers/Dynamic/Parser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/ASTMatchers/Dynamic/Parser.cpp:8,Availability,error,error,8,// This error was already reported by the tokenizer.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/ASTMatchers/Dynamic/Parser.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/ASTMatchers/Dynamic/Parser.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/ASTMatchers/Dynamic/Registry.cpp:78,Modifiability,Polymorphi,Polymorphic,78,"// TODO: Here is the list of the missing matchers, grouped by reason.; //; // Polymorphic + argument overload:; // findAll; //; // Other:; // equalsNode",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/ASTMatchers/Dynamic/Registry.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/ASTMatchers/Dynamic/Registry.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/ASTMatchers/Dynamic/VariantValue.cpp:28,Modifiability,Polymorphi,Polymorphic,28,"//===--- VariantValue.cpp - Polymorphic value type --------------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; ///; /// \file; /// Polymorphic value type.; ///; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/ASTMatchers/Dynamic/VariantValue.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/ASTMatchers/Dynamic/VariantValue.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/ASTMatchers/Dynamic/VariantValue.cpp:396,Modifiability,Polymorphi,Polymorphic,396,"//===--- VariantValue.cpp - Polymorphic value type --------------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; ///; /// \file; /// Polymorphic value type.; ///; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/ASTMatchers/Dynamic/VariantValue.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/ASTMatchers/Dynamic/VariantValue.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/ASTMatchers/Dynamic/VariantValue.cpp:3,Safety,Abort,Abort,3,// Abort if any of the inner matchers can't be converted to; // Matcher<T>.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/ASTMatchers/Dynamic/VariantValue.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/ASTMatchers/Dynamic/VariantValue.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/Attributes.cpp:428,Integrability,interface,interface,428,"//===--- Attributes.cpp ---------------------------------------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements the AttributeCommonInfo interface.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Basic/Attributes.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/Attributes.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/Attributes.cpp:16,Modifiability,plugin,plugin,16,// Check if any plugin provides this attribute.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Basic/Attributes.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/Attributes.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/Attributes.cpp:8,Modifiability,variab,variables,8,// Both variables will be used in tablegen generated; // attribute spell list index matching code.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Basic/Attributes.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/Attributes.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/Builtins.cpp:125,Modifiability,portab,portable,125,/// initializeBuiltins - Mark the identifiers for all the builtins with their; /// appropriate builtin ID # and mark any non-portable builtin identifiers as; /// such.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Basic/Builtins.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/Builtins.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/CLWarnings.cpp:426,Integrability,interface,interfaces,426,"//===--- CLWarnings.h - Maps some cl.exe warning ids -----------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements the Diagnostic-related interfaces.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Basic/CLWarnings.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/CLWarnings.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/Cuda.cpp:19,Integrability,depend,depend,19,// AMD GPUs do not depend on CUDA versions.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Basic/Cuda.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/Cuda.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/Cuda.cpp:19,Integrability,depend,depend,19,// AMD GPUs do not depend on CUDA versions.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Basic/Cuda.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/Cuda.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/DarwinSDKInfo.cpp:118,Safety,avoid,avoid,118,"// If no exact entry found, try just the major key version. Only do so when; // a minor version number is present, to avoid recursing indefinitely into; // the major-only check.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Basic/DarwinSDKInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/DarwinSDKInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/Diagnostic.cpp:427,Integrability,interface,interfaces,427,"//===- Diagnostic.cpp - C Language Family Diagnostic Handling -------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements the Diagnostic-related interfaces.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Basic/Diagnostic.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/Diagnostic.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/Diagnostic.cpp:68,Security,access,access,68,"// If we own the diagnostic client, destroy it first so that it can access the; // engine from its destructor.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Basic/Diagnostic.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/Diagnostic.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/Diagnostic.cpp:3,Usability,Clear,Clear,3,// Clear state related to #pragma diagnostic.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Basic/Diagnostic.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/Diagnostic.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/Diagnostic.cpp:358,Testability,assert,assert,358,"// Deal with a state change induce by recursive parsing. The first parsing is; // suspended and a (recursive) parsing is started between associated (in the upper/outer; // file) with a newer line (hence greater offset). After the end of the recursive; // parsing, we go back to the first parsing and any state change will done 'earlier'; // and trigger:; // assert(Last.Offset <= Offset && ""state transitions added out of order"");",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Basic/Diagnostic.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/Diagnostic.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/Diagnostic.cpp:50,Availability,error,error,50,// Don't allow a mapping to a warning override an error/fatal mapping.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Basic/Diagnostic.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/Diagnostic.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/Diagnostic.cpp:218,Deployability,update,update,218,"// FIXME: This is theoretically wrong: if the current state is shared with; // some other location (via push/pop) we will change the state for that; // other location as well. This cannot currently happen, as we can't update; // the diagnostic state at the same location at which we pop.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Basic/Diagnostic.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/Diagnostic.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/Diagnostic.cpp:83,Availability,error,errors,83,"// If we are enabling this feature, just set the diagnostic mappings to map to; // errors.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Basic/Diagnostic.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/Diagnostic.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/Diagnostic.cpp:91,Availability,down,downgrade,91,"// Otherwise, we want to set the diagnostic mapping's ""no Werror"" bit, and; // potentially downgrade anything already mapped to be a warning.; // Get the diagnostics in this group.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Basic/Diagnostic.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/Diagnostic.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/Diagnostic.cpp:3,Performance,Perform,Perform,3,// Perform the mapping change.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Basic/Diagnostic.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/Diagnostic.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/Diagnostic.cpp:89,Availability,error,errors,89,"// If we are enabling this feature, just set the diagnostic mappings to map to; // fatal errors.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Basic/Diagnostic.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/Diagnostic.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/Diagnostic.cpp:65,Availability,error,errors,65,"// Otherwise, we want to set the diagnostic mapping's ""no Wfatal-errors"" bit,; // and potentially downgrade anything already mapped to be a fatal error.; // Get the diagnostics in this group.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Basic/Diagnostic.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/Diagnostic.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/Diagnostic.cpp:98,Availability,down,downgrade,98,"// Otherwise, we want to set the diagnostic mapping's ""no Wfatal-errors"" bit,; // and potentially downgrade anything already mapped to be a fatal error.; // Get the diagnostics in this group.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Basic/Diagnostic.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/Diagnostic.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/Diagnostic.cpp:146,Availability,error,error,146,"// Otherwise, we want to set the diagnostic mapping's ""no Wfatal-errors"" bit,; // and potentially downgrade anything already mapped to be a fatal error.; // Get the diagnostics in this group.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Basic/Diagnostic.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/Diagnostic.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/Diagnostic.cpp:3,Performance,Perform,Perform,3,// Perform the mapping change.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Basic/Diagnostic.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/Diagnostic.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/Diagnostic.cpp:43,Integrability,message,message,43,// Figure out the diagnostic level of this message.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Basic/Diagnostic.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/Diagnostic.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/Diagnostic.cpp:3,Usability,Clear,Clear,3,// Clear out the current diagnostic object.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Basic/Diagnostic.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/Diagnostic.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/Diagnostic.cpp:4,Testability,Test,TestPluralRange,4,/// TestPluralRange - Test if Val is in the parsed range. Modifies Start.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Basic/Diagnostic.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/Diagnostic.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/Diagnostic.cpp:22,Testability,Test,Test,22,/// TestPluralRange - Test if Val is in the parsed range. Modifies Start.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Basic/Diagnostic.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/Diagnostic.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/Diagnostic.cpp:258,Testability,test,tested,258,"/// HandlePluralModifier - Handle the integer 'plural' modifier. This is used; /// for complex plural forms, or in languages where all plurals are complex.; /// The syntax is: %plural{cond1:form1|cond2:form2|:form3}, where condn are; /// conditions that are tested in order, the form corresponding to the first; /// that applies being emitted. The empty condition is always true, making the; /// last form a default case.; /// Conditions are simple boolean expressions, where n is the number argument.; /// Here are the rules.; /// condition := expression | empty; /// empty := -> always true; /// expression := numeric [',' expression] -> logical or; /// numeric := range -> true if n in range; /// | '%' number '=' range -> true if n % number in range; /// range := number; /// | '[' number ',' number ']' -> ranges are inclusive both ends; ///; /// Here are some examples from the GNU gettext manual written in this form:; /// English:; /// {1:form0|:form1}; /// Latvian:; /// {0:form2|%100=11,%10=0,%10=[2,9]:form1|:form0}; /// Gaeilge:; /// {1:form0|2:form1|:form2}; /// Romanian:; /// {1:form0|0,%100=[1,19]:form1|:form2}; /// Lithuanian:; /// {%10=0,%100=[10,19]:form2|%10=1:form0|:form1}; /// Russian (requires repeated form):; /// {%100=[11,14]:form2|%10=1:form0|%10=[2,4]:form1|:form2}; /// Slovak; /// {1:form0|[2,4]:form1|:form2}; /// Polish (requires repeated form):; /// {1:form0|%100=[10,20]:form2|%10=[2,4]:form1|:form2}",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Basic/Diagnostic.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/Diagnostic.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/Diagnostic.cpp:640,Testability,log,logical,640,"/// HandlePluralModifier - Handle the integer 'plural' modifier. This is used; /// for complex plural forms, or in languages where all plurals are complex.; /// The syntax is: %plural{cond1:form1|cond2:form2|:form3}, where condn are; /// conditions that are tested in order, the form corresponding to the first; /// that applies being emitted. The empty condition is always true, making the; /// last form a default case.; /// Conditions are simple boolean expressions, where n is the number argument.; /// Here are the rules.; /// condition := expression | empty; /// empty := -> always true; /// expression := numeric [',' expression] -> logical or; /// numeric := range -> true if n in range; /// | '%' number '=' range -> true if n % number in range; /// range := number; /// | '[' number ',' number ']' -> ranges are inclusive both ends; ///; /// Here are some examples from the GNU gettext manual written in this form:; /// English:; /// {1:form0|:form1}; /// Latvian:; /// {0:form2|%100=11,%10=0,%10=[2,9]:form1|:form0}; /// Gaeilge:; /// {1:form0|2:form1|:form2}; /// Romanian:; /// {1:form0|0,%100=[1,19]:form1|:form2}; /// Lithuanian:; /// {%10=0,%100=[10,19]:form2|%10=1:form0|:form1}; /// Russian (requires repeated form):; /// {%100=[11,14]:form2|%10=1:form0|%10=[2,4]:form1|:form2}; /// Slovak; /// {1:form0|[2,4]:form1|:form2}; /// Polish (requires repeated form):; /// {1:form0|%100=[10,20]:form2|%10=[2,4]:form1|:form2}",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Basic/Diagnostic.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/Diagnostic.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/Diagnostic.cpp:442,Usability,simpl,simple,442,"/// HandlePluralModifier - Handle the integer 'plural' modifier. This is used; /// for complex plural forms, or in languages where all plurals are complex.; /// The syntax is: %plural{cond1:form1|cond2:form2|:form3}, where condn are; /// conditions that are tested in order, the form corresponding to the first; /// that applies being emitted. The empty condition is always true, making the; /// last form a default case.; /// Conditions are simple boolean expressions, where n is the number argument.; /// Here are the rules.; /// condition := expression | empty; /// empty := -> always true; /// expression := numeric [',' expression] -> logical or; /// numeric := range -> true if n in range; /// | '%' number '=' range -> true if n % number in range; /// range := number; /// | '[' number ',' number ']' -> ranges are inclusive both ends; ///; /// Here are some examples from the GNU gettext manual written in this form:; /// English:; /// {1:form0|:form1}; /// Latvian:; /// {0:form2|%100=11,%10=0,%10=[2,9]:form1|:form0}; /// Gaeilge:; /// {1:form0|2:form1|:form2}; /// Romanian:; /// {1:form0|0,%100=[1,19]:form1|:form2}; /// Lithuanian:; /// {%10=0,%100=[10,19]:form2|%10=1:form0|:form1}; /// Russian (requires repeated form):; /// {%100=[11,14]:form2|%10=1:form0|%10=[2,4]:form1|:form2}; /// Slovak; /// {1:form0|[2,4]:form1|:form2}; /// Polish (requires repeated form):; /// {1:form0|%100=[10,20]:form2|%10=[2,4]:form1|:form2}",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Basic/Diagnostic.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/Diagnostic.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/Diagnostic.cpp:105,Integrability,message,messages,105,/// Returns the friendly description for a token kind that will appear; /// without quotes in diagnostic messages. These strings may be translatable in; /// future.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Basic/Diagnostic.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/Diagnostic.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/Diagnostic.cpp:187,Safety,avoid,avoid,187,"/// FormattedArgs - Keep track of all of the arguments formatted by; /// ConvertArgToString and pass them into subsequent calls to; /// ConvertArgToString, allowing the implementation to avoid redundancies in; /// obvious cases.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Basic/Diagnostic.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/Diagnostic.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/Diagnostic.cpp:193,Safety,redund,redundancies,193,"/// FormattedArgs - Keep track of all of the arguments formatted by; /// ConvertArgToString and pass them into subsequent calls to; /// ConvertArgToString, allowing the implementation to avoid redundancies in; /// obvious cases.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Basic/Diagnostic.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/Diagnostic.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/Diagnostic.cpp:9,Testability,assert,assert,9,"// Don't assert if we are in a CrashRecovery context, as this invariant may; // be invalidated during a crash.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Basic/Diagnostic.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/Diagnostic.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/DiagnosticIDs.cpp:431,Integrability,interface,interfaces,431,"//===--- DiagnosticIDs.cpp - Diagnostic IDs Handling ----------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements the Diagnostic IDs-related interfaces.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Basic/DiagnosticIDs.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/DiagnosticIDs.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/DiagnosticIDs.cpp:49,Safety,avoid,avoid,49,"// Store the descriptions in a separate table to avoid pointers that need to; // be relocated, and also decrease the amount of data needed on 64-bit; // platforms. See ""How To Write Shared Libraries"" by Ulrich Drepper.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Basic/DiagnosticIDs.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/DiagnosticIDs.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/DiagnosticIDs.cpp:3,Safety,Avoid,Avoid,3,// Avoid out of bounds reads.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Basic/DiagnosticIDs.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/DiagnosticIDs.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/DiagnosticIDs.cpp:59,Safety,abort,abort,59,"// If the diag id doesn't match we found a different diag, abort. This can; // happen when this function is called with an ID that points into a hole in; // the diagID space.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Basic/DiagnosticIDs.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/DiagnosticIDs.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/DiagnosticIDs.cpp:71,Integrability,message,message,71,"/// getCustomDiagID - Return an ID for a diagnostic with the specified message; /// and level. If this is the first request for this diagnostic, it is; /// registered and created, otherwise the existing ID is returned.; ///; /// \param FormatString A fixed diagnostic format string that will be hashed and; /// mapped to a unique DiagID.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Basic/DiagnosticIDs.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/DiagnosticIDs.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/DiagnosticIDs.cpp:295,Security,hash,hashed,295,"/// getCustomDiagID - Return an ID for a diagnostic with the specified message; /// and level. If this is the first request for this diagnostic, it is; /// registered and created, otherwise the existing ID is returned.; ///; /// \param FormatString A fixed diagnostic format string that will be hashed and; /// mapped to a unique DiagID.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Basic/DiagnosticIDs.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/DiagnosticIDs.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/DiagnosticIDs.cpp:296,Availability,error,error,296,"/// isBuiltinExtensionDiag - Determine whether the given built-in diagnostic; /// ID is for an extension of some sort. This also returns EnabledByDefault,; /// which is set to indicate whether the diagnostic is ignored by default (in; /// which case -pedantic enables it) or treated as a warning/error by default.; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Basic/DiagnosticIDs.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/DiagnosticIDs.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/DiagnosticIDs.cpp:53,Modifiability,config,configured,53,"/// getDiagnosticLevel - Based on the way the client configured the; /// DiagnosticsEngine object, classify the specified diagnostic ID into a Level,; /// by consumable the DiagnosticClient.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Basic/DiagnosticIDs.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/DiagnosticIDs.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/DiagnosticIDs.cpp:32,Modifiability,config,configured,32,"/// Based on the way the client configured the Diagnostic; /// object, classify the specified diagnostic ID into a Level, consumable by; /// the DiagnosticClient.; ///; /// \param Loc The source location we are interested in finding out the; /// diagnostic state. Can be null in order to query the latest state.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Basic/DiagnosticIDs.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/DiagnosticIDs.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/DiagnosticIDs.cpp:16,Availability,error,error,16,// Specific non-error diagnostics may be mapped to various levels from ignored; // to error. Errors can only be mapped to fatal.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Basic/DiagnosticIDs.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/DiagnosticIDs.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/DiagnosticIDs.cpp:86,Availability,error,error,86,// Specific non-error diagnostics may be mapped to various levels from ignored; // to error. Errors can only be mapped to fatal.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Basic/DiagnosticIDs.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/DiagnosticIDs.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/DiagnosticIDs.cpp:93,Availability,Error,Errors,93,// Specific non-error diagnostics may be mapped to various levels from ignored; // to error. Errors can only be mapped to fatal.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Basic/DiagnosticIDs.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/DiagnosticIDs.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/DiagnosticIDs.cpp:3,Deployability,Upgrade,Upgrade,3,// Upgrade ignored diagnostics if -Weverything is enabled.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Basic/DiagnosticIDs.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/DiagnosticIDs.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/DiagnosticIDs.cpp:89,Deployability,upgrade,upgrade,89,"// For extension diagnostics that haven't been explicitly mapped, check if we; // should upgrade the diagnostic.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Basic/DiagnosticIDs.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/DiagnosticIDs.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/DiagnosticIDs.cpp:26,Availability,error,errors,26,"// At this point, ignored errors can no longer be upgraded.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Basic/DiagnosticIDs.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/DiagnosticIDs.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/DiagnosticIDs.cpp:50,Deployability,upgrade,upgraded,50,"// At this point, ignored errors can no longer be upgraded.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Basic/DiagnosticIDs.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/DiagnosticIDs.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/DiagnosticIDs.cpp:54,Availability,Error,Error,54,"// Honor -w: this disables all messages which are not Error/Fatal by; // default (disregarding attempts to upgrade severity from Warning to Error),; // as well as disabling all messages which are currently mapped to Warning; // (whether by default or downgraded from Error via e.g. -Wno-error or #pragma; // diagnostic.)",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Basic/DiagnosticIDs.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/DiagnosticIDs.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/DiagnosticIDs.cpp:140,Availability,Error,Error,140,"// Honor -w: this disables all messages which are not Error/Fatal by; // default (disregarding attempts to upgrade severity from Warning to Error),; // as well as disabling all messages which are currently mapped to Warning; // (whether by default or downgraded from Error via e.g. -Wno-error or #pragma; // diagnostic.)",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Basic/DiagnosticIDs.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/DiagnosticIDs.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/DiagnosticIDs.cpp:251,Availability,down,downgraded,251,"// Honor -w: this disables all messages which are not Error/Fatal by; // default (disregarding attempts to upgrade severity from Warning to Error),; // as well as disabling all messages which are currently mapped to Warning; // (whether by default or downgraded from Error via e.g. -Wno-error or #pragma; // diagnostic.)",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Basic/DiagnosticIDs.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/DiagnosticIDs.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/DiagnosticIDs.cpp:267,Availability,Error,Error,267,"// Honor -w: this disables all messages which are not Error/Fatal by; // default (disregarding attempts to upgrade severity from Warning to Error),; // as well as disabling all messages which are currently mapped to Warning; // (whether by default or downgraded from Error via e.g. -Wno-error or #pragma; // diagnostic.)",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Basic/DiagnosticIDs.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/DiagnosticIDs.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/DiagnosticIDs.cpp:287,Availability,error,error,287,"// Honor -w: this disables all messages which are not Error/Fatal by; // default (disregarding attempts to upgrade severity from Warning to Error),; // as well as disabling all messages which are currently mapped to Warning; // (whether by default or downgraded from Error via e.g. -Wno-error or #pragma; // diagnostic.)",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Basic/DiagnosticIDs.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/DiagnosticIDs.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/DiagnosticIDs.cpp:107,Deployability,upgrade,upgrade,107,"// Honor -w: this disables all messages which are not Error/Fatal by; // default (disregarding attempts to upgrade severity from Warning to Error),; // as well as disabling all messages which are currently mapped to Warning; // (whether by default or downgraded from Error via e.g. -Wno-error or #pragma; // diagnostic.)",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Basic/DiagnosticIDs.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/DiagnosticIDs.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/DiagnosticIDs.cpp:31,Integrability,message,messages,31,"// Honor -w: this disables all messages which are not Error/Fatal by; // default (disregarding attempts to upgrade severity from Warning to Error),; // as well as disabling all messages which are currently mapped to Warning; // (whether by default or downgraded from Error via e.g. -Wno-error or #pragma; // diagnostic.)",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Basic/DiagnosticIDs.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/DiagnosticIDs.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/DiagnosticIDs.cpp:177,Integrability,message,messages,177,"// Honor -w: this disables all messages which are not Error/Fatal by; // default (disregarding attempts to upgrade severity from Warning to Error),; // as well as disabling all messages which are currently mapped to Warning; // (whether by default or downgraded from Error via e.g. -Wno-error or #pragma; // diagnostic.)",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Basic/DiagnosticIDs.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/DiagnosticIDs.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/DiagnosticIDs.cpp:42,Availability,error,errors,42,"// If -Werror is enabled, map warnings to errors unless explicitly disabled.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Basic/DiagnosticIDs.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/DiagnosticIDs.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/DiagnosticIDs.cpp:14,Availability,error,errors,14,"// If -Wfatal-errors is enabled, map errors to fatal unless explicitly; // disabled.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Basic/DiagnosticIDs.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/DiagnosticIDs.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/DiagnosticIDs.cpp:37,Availability,error,errors,37,"// If -Wfatal-errors is enabled, map errors to fatal unless explicitly; // disabled.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Basic/DiagnosticIDs.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/DiagnosticIDs.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/DiagnosticIDs.cpp:38,Availability,error,errors,38,"// If explicitly requested, map fatal errors to errors.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Basic/DiagnosticIDs.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/DiagnosticIDs.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/DiagnosticIDs.cpp:48,Availability,error,errors,48,"// If explicitly requested, map fatal errors to errors.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Basic/DiagnosticIDs.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/DiagnosticIDs.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/DiagnosticIDs.cpp:167,Availability,error,errors,167,"// If we are in a system header, we ignore it. We look at the diagnostic class; // because we also want to ignore extensions and warnings in -Werror and; // -pedantic-errors modes, which *map* warnings/extensions to errors.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Basic/DiagnosticIDs.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/DiagnosticIDs.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/DiagnosticIDs.cpp:216,Availability,error,errors,216,"// If we are in a system header, we ignore it. We look at the diagnostic class; // because we also want to ignore extensions and warnings in -Werror and; // -pedantic-errors modes, which *map* warnings/extensions to errors.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Basic/DiagnosticIDs.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/DiagnosticIDs.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/DiagnosticIDs.cpp:43,Integrability,message,message,43,// Figure out the diagnostic level of this message.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Basic/DiagnosticIDs.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/DiagnosticIDs.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/DiagnosticIDs.cpp:57,Availability,error,error,57,// Update counts for DiagnosticErrorTrap even if a fatal error occurred; // or diagnostics are suppressed.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Basic/DiagnosticIDs.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/DiagnosticIDs.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/DiagnosticIDs.cpp:3,Deployability,Update,Update,3,// Update counts for DiagnosticErrorTrap even if a fatal error occurred; // or diagnostics are suppressed.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Basic/DiagnosticIDs.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/DiagnosticIDs.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/DiagnosticIDs.cpp:23,Availability,error,error,23,"// Record that a fatal error occurred only when we see a second; // non-note diagnostic. This allows notes to be attached to the; // fatal error, but suppresses any diagnostics that follow those; // notes.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Basic/DiagnosticIDs.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/DiagnosticIDs.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/DiagnosticIDs.cpp:139,Availability,error,error,139,"// Record that a fatal error occurred only when we see a second; // non-note diagnostic. This allows notes to be attached to the; // fatal error, but suppresses any diagnostics that follow those; // notes.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Basic/DiagnosticIDs.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/DiagnosticIDs.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/DiagnosticIDs.cpp:14,Availability,error,error,14,"// If a fatal error has already been emitted, silence all subsequent; // diagnostics.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Basic/DiagnosticIDs.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/DiagnosticIDs.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/DiagnosticIDs.cpp:41,Integrability,message,message,41,"// If the client doesn't care about this message, don't issue it. If this is; // a note and the last real diagnostic was ignored, ignore it too.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Basic/DiagnosticIDs.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/DiagnosticIDs.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/DiagnosticIDs.cpp:40,Availability,error,errors,40,// Warnings which have been upgraded to errors do not prevent compilation.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Basic/DiagnosticIDs.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/DiagnosticIDs.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/DiagnosticIDs.cpp:28,Deployability,upgrade,upgraded,28,// Warnings which have been upgraded to errors do not prevent compilation.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Basic/DiagnosticIDs.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/DiagnosticIDs.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/DiagnosticIDs.cpp:29,Availability,error,errors,29,"// If we've emitted a lot of errors, emit a fatal error instead of it to; // stop a flood of bogus errors.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Basic/DiagnosticIDs.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/DiagnosticIDs.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/DiagnosticIDs.cpp:50,Availability,error,error,50,"// If we've emitted a lot of errors, emit a fatal error instead of it to; // stop a flood of bogus errors.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Basic/DiagnosticIDs.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/DiagnosticIDs.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/DiagnosticIDs.cpp:99,Availability,error,errors,99,"// If we've emitted a lot of errors, emit a fatal error instead of it to; // stop a flood of bogus errors.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Basic/DiagnosticIDs.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/DiagnosticIDs.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/DiagnosticIDs.cpp:8,Availability,error,errors,8,// Only errors may be unrecoverable.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Basic/DiagnosticIDs.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/DiagnosticIDs.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/DiagnosticIDs.cpp:33,Availability,error,errors,33,// Currently we consider all ARC errors as recoverable.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Basic/DiagnosticIDs.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/DiagnosticIDs.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/DiagnosticIDs.cpp:43,Availability,recover,recoverable,43,// Currently we consider all ARC errors as recoverable.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Basic/DiagnosticIDs.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/DiagnosticIDs.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/DiagnosticIDs.cpp:43,Safety,recover,recoverable,43,// Currently we consider all ARC errors as recoverable.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Basic/DiagnosticIDs.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/DiagnosticIDs.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/DiagnosticOptions.cpp:434,Integrability,interface,interfaces,434,"//===- DiagnosticOptions.cpp - C Language Family Diagnostic Handling ------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements the DiagnosticOptions related interfaces.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Basic/DiagnosticOptions.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/DiagnosticOptions.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/FileManager.cpp:420,Integrability,interface,interface,420,"//===--- FileManager.cpp - File System Probing and Caching ----------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements the FileManager interface.; //; //===----------------------------------------------------------------------===//; //; // TODO: This should index all interesting directories with dirent calls.; // getdirentries ?; // opendir/readdir_r/closedir ?; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Basic/FileManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/FileManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/FileManager.cpp:92,Testability,log,logic,92,//===----------------------------------------------------------------------===//; // Common logic.; //===----------------------------------------------------------------------===//,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Basic/FileManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/FileManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/FileManager.cpp:47,Performance,cache,cache,47,"// When caching a virtual directory, we always cache its ancestors; // at the same time. Therefore, if DirName is already in the cache,; // we don't need to recurse as its ancestors must also already be in; // the cache (or it's a known non-virtual directory).",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Basic/FileManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/FileManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/FileManager.cpp:129,Performance,cache,cache,129,"// When caching a virtual directory, we always cache its ancestors; // at the same time. Therefore, if DirName is already in the cache,; // we don't need to recurse as its ancestors must also already be in; // the cache (or it's a known non-virtual directory).",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Basic/FileManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/FileManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/FileManager.cpp:214,Performance,cache,cache,214,"// When caching a virtual directory, we always cache its ancestors; // at the same time. Therefore, if DirName is already in the cache,; // we don't need to recurse as its ancestors must also already be in; // the cache (or it's a known non-virtual directory).",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Basic/FileManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/FileManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/FileManager.cpp:36,Performance,cache,cache,36,// Add the virtual directory to the cache.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Basic/FileManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/FileManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/FileManager.cpp:34,Testability,test,test,34,"// Fixing a problem with ""clang C:test.c"" on Windows.; // Stat(""C:"") does not recognize ""C:"" as a valid directory",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Basic/FileManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/FileManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/FileManager.cpp:349,Availability,failure,failure,349,"// Look up the directory for the file. When looking up something like; // sys/foo.h we'll discover all of the search directories that have a 'sys'; // subdirectory. This will let us avoid having to waste time on known-to-fail; // searches when we go to find sys/bar.h, because all the search directories; // without a 'sys' subdir will get a cached failure result.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Basic/FileManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/FileManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/FileManager.cpp:342,Performance,cache,cached,342,"// Look up the directory for the file. When looking up something like; // sys/foo.h we'll discover all of the search directories that have a 'sys'; // subdirectory. This will let us avoid having to waste time on known-to-fail; // searches when we go to find sys/bar.h, because all the search directories; // without a 'sys' subdir will get a cached failure result.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Basic/FileManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/FileManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/FileManager.cpp:182,Safety,avoid,avoid,182,"// Look up the directory for the file. When looking up something like; // sys/foo.h we'll discover all of the search directories that have a 'sys'; // subdirectory. This will let us avoid having to waste time on known-to-fail; // searches when we go to find sys/bar.h, because all the search directories; // without a 'sys' subdir will get a cached failure result.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Basic/FileManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/FileManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/FileManager.cpp:100,Energy Efficiency,reduce,reduce,100,"// FIXME: Use the directory info to prune this, before doing the stat syscall.; // FIXME: This will reduce the # syscalls.; // Check to see if the file exists.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Basic/FileManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/FileManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/FileManager.cpp:1024,Availability,avail,available,1024,"// Name mismatch. We need a redirect. First grab the actual entry we want; // to return.; //; // This redirection logic intentionally leaks the external name of a; // redirected file that uses 'use-external-name' in \a; // vfs::RedirectionFileSystem. This allows clang to report the external; // name to users (in diagnostics) and to tools that don't have access to; // the VFS (in debug info and dependency '.d' files).; //; // FIXME: This is pretty complex and has some very complicated interactions; // with the rest of clang. It's also inconsistent with how ""real""; // filesystems behave and confuses parts of clang expect to see the; // name-as-accessed on the \a FileEntryRef.; //; // A potential plan to remove this is as follows -; // - Update callers such as `HeaderSearch::findUsableModuleForHeader()`; // to explicitly use the `getNameAsRequested()` rather than just using; // `getName()`.; // - Add a `FileManager::getExternalPath` API for explicitly getting the; // remapped external filename when there is one available. Adopt it in; // callers like diagnostics/deps reporting instead of calling; // `getName()` directly.; // - Switch the meaning of `FileEntryRef::getName()` to get the requested; // name, not the external name. Once that sticks, revert callers that; // want the requested name back to calling `getName()`.; // - Update the VFS to always return the requested name. This could also; // return the external name, or just have an API to request it; // lazily. The latter has the benefit of making accesses of the; // external path easily tracked, but may also require extra work than; // just returning up front.; // - (Optionally) Add an API to VFS to get the external filename lazily; // and update `FileManager::getExternalPath()` to use it instead. This; // has the benefit of making such accesses easily tracked, though isn't; // necessarily required (and could cause extra work than just adding to; // eg. `vfs::Status` up front).",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Basic/FileManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/FileManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/FileManager.cpp:745,Deployability,Update,Update,745,"// Name mismatch. We need a redirect. First grab the actual entry we want; // to return.; //; // This redirection logic intentionally leaks the external name of a; // redirected file that uses 'use-external-name' in \a; // vfs::RedirectionFileSystem. This allows clang to report the external; // name to users (in diagnostics) and to tools that don't have access to; // the VFS (in debug info and dependency '.d' files).; //; // FIXME: This is pretty complex and has some very complicated interactions; // with the rest of clang. It's also inconsistent with how ""real""; // filesystems behave and confuses parts of clang expect to see the; // name-as-accessed on the \a FileEntryRef.; //; // A potential plan to remove this is as follows -; // - Update callers such as `HeaderSearch::findUsableModuleForHeader()`; // to explicitly use the `getNameAsRequested()` rather than just using; // `getName()`.; // - Add a `FileManager::getExternalPath` API for explicitly getting the; // remapped external filename when there is one available. Adopt it in; // callers like diagnostics/deps reporting instead of calling; // `getName()` directly.; // - Switch the meaning of `FileEntryRef::getName()` to get the requested; // name, not the external name. Once that sticks, revert callers that; // want the requested name back to calling `getName()`.; // - Update the VFS to always return the requested name. This could also; // return the external name, or just have an API to request it; // lazily. The latter has the benefit of making accesses of the; // external path easily tracked, but may also require extra work than; // just returning up front.; // - (Optionally) Add an API to VFS to get the external filename lazily; // and update `FileManager::getExternalPath()` to use it instead. This; // has the benefit of making such accesses easily tracked, though isn't; // necessarily required (and could cause extra work than just adding to; // eg. `vfs::Status` up front).",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Basic/FileManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/FileManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/FileManager.cpp:1345,Deployability,Update,Update,1345,"// Name mismatch. We need a redirect. First grab the actual entry we want; // to return.; //; // This redirection logic intentionally leaks the external name of a; // redirected file that uses 'use-external-name' in \a; // vfs::RedirectionFileSystem. This allows clang to report the external; // name to users (in diagnostics) and to tools that don't have access to; // the VFS (in debug info and dependency '.d' files).; //; // FIXME: This is pretty complex and has some very complicated interactions; // with the rest of clang. It's also inconsistent with how ""real""; // filesystems behave and confuses parts of clang expect to see the; // name-as-accessed on the \a FileEntryRef.; //; // A potential plan to remove this is as follows -; // - Update callers such as `HeaderSearch::findUsableModuleForHeader()`; // to explicitly use the `getNameAsRequested()` rather than just using; // `getName()`.; // - Add a `FileManager::getExternalPath` API for explicitly getting the; // remapped external filename when there is one available. Adopt it in; // callers like diagnostics/deps reporting instead of calling; // `getName()` directly.; // - Switch the meaning of `FileEntryRef::getName()` to get the requested; // name, not the external name. Once that sticks, revert callers that; // want the requested name back to calling `getName()`.; // - Update the VFS to always return the requested name. This could also; // return the external name, or just have an API to request it; // lazily. The latter has the benefit of making accesses of the; // external path easily tracked, but may also require extra work than; // just returning up front.; // - (Optionally) Add an API to VFS to get the external filename lazily; // and update `FileManager::getExternalPath()` to use it instead. This; // has the benefit of making such accesses easily tracked, though isn't; // necessarily required (and could cause extra work than just adding to; // eg. `vfs::Status` up front).",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Basic/FileManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/FileManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/FileManager.cpp:1723,Deployability,update,update,1723,"// Name mismatch. We need a redirect. First grab the actual entry we want; // to return.; //; // This redirection logic intentionally leaks the external name of a; // redirected file that uses 'use-external-name' in \a; // vfs::RedirectionFileSystem. This allows clang to report the external; // name to users (in diagnostics) and to tools that don't have access to; // the VFS (in debug info and dependency '.d' files).; //; // FIXME: This is pretty complex and has some very complicated interactions; // with the rest of clang. It's also inconsistent with how ""real""; // filesystems behave and confuses parts of clang expect to see the; // name-as-accessed on the \a FileEntryRef.; //; // A potential plan to remove this is as follows -; // - Update callers such as `HeaderSearch::findUsableModuleForHeader()`; // to explicitly use the `getNameAsRequested()` rather than just using; // `getName()`.; // - Add a `FileManager::getExternalPath` API for explicitly getting the; // remapped external filename when there is one available. Adopt it in; // callers like diagnostics/deps reporting instead of calling; // `getName()` directly.; // - Switch the meaning of `FileEntryRef::getName()` to get the requested; // name, not the external name. Once that sticks, revert callers that; // want the requested name back to calling `getName()`.; // - Update the VFS to always return the requested name. This could also; // return the external name, or just have an API to request it; // lazily. The latter has the benefit of making accesses of the; // external path easily tracked, but may also require extra work than; // just returning up front.; // - (Optionally) Add an API to VFS to get the external filename lazily; // and update `FileManager::getExternalPath()` to use it instead. This; // has the benefit of making such accesses easily tracked, though isn't; // necessarily required (and could cause extra work than just adding to; // eg. `vfs::Status` up front).",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Basic/FileManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/FileManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/FileManager.cpp:397,Integrability,depend,dependency,397,"// Name mismatch. We need a redirect. First grab the actual entry we want; // to return.; //; // This redirection logic intentionally leaks the external name of a; // redirected file that uses 'use-external-name' in \a; // vfs::RedirectionFileSystem. This allows clang to report the external; // name to users (in diagnostics) and to tools that don't have access to; // the VFS (in debug info and dependency '.d' files).; //; // FIXME: This is pretty complex and has some very complicated interactions; // with the rest of clang. It's also inconsistent with how ""real""; // filesystems behave and confuses parts of clang expect to see the; // name-as-accessed on the \a FileEntryRef.; //; // A potential plan to remove this is as follows -; // - Update callers such as `HeaderSearch::findUsableModuleForHeader()`; // to explicitly use the `getNameAsRequested()` rather than just using; // `getName()`.; // - Add a `FileManager::getExternalPath` API for explicitly getting the; // remapped external filename when there is one available. Adopt it in; // callers like diagnostics/deps reporting instead of calling; // `getName()` directly.; // - Switch the meaning of `FileEntryRef::getName()` to get the requested; // name, not the external name. Once that sticks, revert callers that; // want the requested name back to calling `getName()`.; // - Update the VFS to always return the requested name. This could also; // return the external name, or just have an API to request it; // lazily. The latter has the benefit of making accesses of the; // external path easily tracked, but may also require extra work than; // just returning up front.; // - (Optionally) Add an API to VFS to get the external filename lazily; // and update `FileManager::getExternalPath()` to use it instead. This; // has the benefit of making such accesses easily tracked, though isn't; // necessarily required (and could cause extra work than just adding to; // eg. `vfs::Status` up front).",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Basic/FileManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/FileManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/FileManager.cpp:356,Security,access,access,356,"// Name mismatch. We need a redirect. First grab the actual entry we want; // to return.; //; // This redirection logic intentionally leaks the external name of a; // redirected file that uses 'use-external-name' in \a; // vfs::RedirectionFileSystem. This allows clang to report the external; // name to users (in diagnostics) and to tools that don't have access to; // the VFS (in debug info and dependency '.d' files).; //; // FIXME: This is pretty complex and has some very complicated interactions; // with the rest of clang. It's also inconsistent with how ""real""; // filesystems behave and confuses parts of clang expect to see the; // name-as-accessed on the \a FileEntryRef.; //; // A potential plan to remove this is as follows -; // - Update callers such as `HeaderSearch::findUsableModuleForHeader()`; // to explicitly use the `getNameAsRequested()` rather than just using; // `getName()`.; // - Add a `FileManager::getExternalPath` API for explicitly getting the; // remapped external filename when there is one available. Adopt it in; // callers like diagnostics/deps reporting instead of calling; // `getName()` directly.; // - Switch the meaning of `FileEntryRef::getName()` to get the requested; // name, not the external name. Once that sticks, revert callers that; // want the requested name back to calling `getName()`.; // - Update the VFS to always return the requested name. This could also; // return the external name, or just have an API to request it; // lazily. The latter has the benefit of making accesses of the; // external path easily tracked, but may also require extra work than; // just returning up front.; // - (Optionally) Add an API to VFS to get the external filename lazily; // and update `FileManager::getExternalPath()` to use it instead. This; // has the benefit of making such accesses easily tracked, though isn't; // necessarily required (and could cause extra work than just adding to; // eg. `vfs::Status` up front).",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Basic/FileManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/FileManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/FileManager.cpp:650,Security,access,accessed,650,"// Name mismatch. We need a redirect. First grab the actual entry we want; // to return.; //; // This redirection logic intentionally leaks the external name of a; // redirected file that uses 'use-external-name' in \a; // vfs::RedirectionFileSystem. This allows clang to report the external; // name to users (in diagnostics) and to tools that don't have access to; // the VFS (in debug info and dependency '.d' files).; //; // FIXME: This is pretty complex and has some very complicated interactions; // with the rest of clang. It's also inconsistent with how ""real""; // filesystems behave and confuses parts of clang expect to see the; // name-as-accessed on the \a FileEntryRef.; //; // A potential plan to remove this is as follows -; // - Update callers such as `HeaderSearch::findUsableModuleForHeader()`; // to explicitly use the `getNameAsRequested()` rather than just using; // `getName()`.; // - Add a `FileManager::getExternalPath` API for explicitly getting the; // remapped external filename when there is one available. Adopt it in; // callers like diagnostics/deps reporting instead of calling; // `getName()` directly.; // - Switch the meaning of `FileEntryRef::getName()` to get the requested; // name, not the external name. Once that sticks, revert callers that; // want the requested name back to calling `getName()`.; // - Update the VFS to always return the requested name. This could also; // return the external name, or just have an API to request it; // lazily. The latter has the benefit of making accesses of the; // external path easily tracked, but may also require extra work than; // just returning up front.; // - (Optionally) Add an API to VFS to get the external filename lazily; // and update `FileManager::getExternalPath()` to use it instead. This; // has the benefit of making such accesses easily tracked, though isn't; // necessarily required (and could cause extra work than just adding to; // eg. `vfs::Status` up front).",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Basic/FileManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/FileManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/FileManager.cpp:1526,Security,access,accesses,1526,"// Name mismatch. We need a redirect. First grab the actual entry we want; // to return.; //; // This redirection logic intentionally leaks the external name of a; // redirected file that uses 'use-external-name' in \a; // vfs::RedirectionFileSystem. This allows clang to report the external; // name to users (in diagnostics) and to tools that don't have access to; // the VFS (in debug info and dependency '.d' files).; //; // FIXME: This is pretty complex and has some very complicated interactions; // with the rest of clang. It's also inconsistent with how ""real""; // filesystems behave and confuses parts of clang expect to see the; // name-as-accessed on the \a FileEntryRef.; //; // A potential plan to remove this is as follows -; // - Update callers such as `HeaderSearch::findUsableModuleForHeader()`; // to explicitly use the `getNameAsRequested()` rather than just using; // `getName()`.; // - Add a `FileManager::getExternalPath` API for explicitly getting the; // remapped external filename when there is one available. Adopt it in; // callers like diagnostics/deps reporting instead of calling; // `getName()` directly.; // - Switch the meaning of `FileEntryRef::getName()` to get the requested; // name, not the external name. Once that sticks, revert callers that; // want the requested name back to calling `getName()`.; // - Update the VFS to always return the requested name. This could also; // return the external name, or just have an API to request it; // lazily. The latter has the benefit of making accesses of the; // external path easily tracked, but may also require extra work than; // just returning up front.; // - (Optionally) Add an API to VFS to get the external filename lazily; // and update `FileManager::getExternalPath()` to use it instead. This; // has the benefit of making such accesses easily tracked, though isn't; // necessarily required (and could cause extra work than just adding to; // eg. `vfs::Status` up front).",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Basic/FileManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/FileManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/FileManager.cpp:1822,Security,access,accesses,1822,"// Name mismatch. We need a redirect. First grab the actual entry we want; // to return.; //; // This redirection logic intentionally leaks the external name of a; // redirected file that uses 'use-external-name' in \a; // vfs::RedirectionFileSystem. This allows clang to report the external; // name to users (in diagnostics) and to tools that don't have access to; // the VFS (in debug info and dependency '.d' files).; //; // FIXME: This is pretty complex and has some very complicated interactions; // with the rest of clang. It's also inconsistent with how ""real""; // filesystems behave and confuses parts of clang expect to see the; // name-as-accessed on the \a FileEntryRef.; //; // A potential plan to remove this is as follows -; // - Update callers such as `HeaderSearch::findUsableModuleForHeader()`; // to explicitly use the `getNameAsRequested()` rather than just using; // `getName()`.; // - Add a `FileManager::getExternalPath` API for explicitly getting the; // remapped external filename when there is one available. Adopt it in; // callers like diagnostics/deps reporting instead of calling; // `getName()` directly.; // - Switch the meaning of `FileEntryRef::getName()` to get the requested; // name, not the external name. Once that sticks, revert callers that; // want the requested name back to calling `getName()`.; // - Update the VFS to always return the requested name. This could also; // return the external name, or just have an API to request it; // lazily. The latter has the benefit of making accesses of the; // external path easily tracked, but may also require extra work than; // just returning up front.; // - (Optionally) Add an API to VFS to get the external filename lazily; // and update `FileManager::getExternalPath()` to use it instead. This; // has the benefit of making such accesses easily tracked, though isn't; // necessarily required (and could cause extra work than just adding to; // eg. `vfs::Status` up front).",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Basic/FileManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/FileManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/FileManager.cpp:114,Testability,log,logic,114,"// Name mismatch. We need a redirect. First grab the actual entry we want; // to return.; //; // This redirection logic intentionally leaks the external name of a; // redirected file that uses 'use-external-name' in \a; // vfs::RedirectionFileSystem. This allows clang to report the external; // name to users (in diagnostics) and to tools that don't have access to; // the VFS (in debug info and dependency '.d' files).; //; // FIXME: This is pretty complex and has some very complicated interactions; // with the rest of clang. It's also inconsistent with how ""real""; // filesystems behave and confuses parts of clang expect to see the; // name-as-accessed on the \a FileEntryRef.; //; // A potential plan to remove this is as follows -; // - Update callers such as `HeaderSearch::findUsableModuleForHeader()`; // to explicitly use the `getNameAsRequested()` rather than just using; // `getName()`.; // - Add a `FileManager::getExternalPath` API for explicitly getting the; // remapped external filename when there is one available. Adopt it in; // callers like diagnostics/deps reporting instead of calling; // `getName()` directly.; // - Switch the meaning of `FileEntryRef::getName()` to get the requested; // name, not the external name. Once that sticks, revert callers that; // want the requested name back to calling `getName()`.; // - Update the VFS to always return the requested name. This could also; // return the external name, or just have an API to request it; // lazily. The latter has the benefit of making accesses of the; // external path easily tracked, but may also require extra work than; // just returning up front.; // - (Optionally) Add an API to VFS to get the external filename lazily; // and update `FileManager::getExternalPath()` to use it instead. This; // has the benefit of making such accesses easily tracked, though isn't; // necessarily required (and could cause extra work than just adding to; // eg. `vfs::Status` up front).",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Basic/FileManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/FileManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/FileManager.cpp:65,Availability,avail,available,65,"// Cache the redirection in the previously-inserted entry, still available; // in the tentative return value.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Basic/FileManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/FileManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/FileManager.cpp:3,Performance,Cache,Cache,3,"// Cache the redirection in the previously-inserted entry, still available; // in the tentative return value.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Basic/FileManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/FileManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/FileManager.cpp:474,Integrability,depend,depend,474,"// Already have an entry with this inode, return it.; // FIXME: This hack ensures that `getDir()` will use the path that was; // used to lookup this file, even if we found a file by different path; // first. This is required in order to find a module's structure when its; // headers/module map are mapped in the VFS.; //; // See above for how this will eventually be removed. `IsVFSMapped`; // *cannot* be narrowed to `ExposesExternalVFSPath` as crash reproducers; // also depend on this logic and they have `use-external-paths: false`.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Basic/FileManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/FileManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/FileManager.cpp:420,Security,Expose,ExposesExternalVFSPath,420,"// Already have an entry with this inode, return it.; // FIXME: This hack ensures that `getDir()` will use the path that was; // used to lookup this file, even if we found a file by different path; // first. This is required in order to find a module's structure when its; // headers/module map are mapped in the VFS.; //; // See above for how this will eventually be removed. `IsVFSMapped`; // *cannot* be narrowed to `ExposesExternalVFSPath` as crash reproducers; // also depend on this logic and they have `use-external-paths: false`.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Basic/FileManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/FileManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/FileManager.cpp:489,Testability,log,logic,489,"// Already have an entry with this inode, return it.; // FIXME: This hack ensures that `getDir()` will use the path that was; // used to lookup this file, even if we found a file by different path; // first. This is required in order to find a module's structure when its; // headers/module map are mapped in the VFS.; //; // See above for how this will eventually be removed. `IsVFSMapped`; // *cannot* be narrowed to `ExposesExternalVFSPath` as crash reproducers; // also depend on this logic and they have `use-external-paths: false`.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Basic/FileManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/FileManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/FileManager.cpp:10,Deployability,update,update,10,// Always update LastRef to the last name by which a file was accessed.; // FIXME: Neither this nor always using the first reference is correct; we; // want to switch towards a design where we return a FileName object that; // encapsulates both the name by which the file was accessed and the; // corresponding FileEntry.; // FIXME: LastRef should be removed from FileEntry once all clients adopt; // FileEntryRef.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Basic/FileManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/FileManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/FileManager.cpp:62,Security,access,accessed,62,// Always update LastRef to the last name by which a file was accessed.; // FIXME: Neither this nor always using the first reference is correct; we; // want to switch towards a design where we return a FileName object that; // encapsulates both the name by which the file was accessed and the; // corresponding FileEntry.; // FIXME: LastRef should be removed from FileEntry once all clients adopt; // FileEntryRef.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Basic/FileManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/FileManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/FileManager.cpp:276,Security,access,accessed,276,// Always update LastRef to the last name by which a file was accessed.; // FIXME: Neither this nor always using the first reference is correct; we; // want to switch towards a design where we return a FileName object that; // encapsulates both the name by which the file was accessed and the; // corresponding FileEntry.; // FIXME: LastRef should be removed from FileEntry once all clients adopt; // FileEntryRef.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Basic/FileManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/FileManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/FileManager.cpp:38,Deployability,update,update,38,// Find occurrences of old FileEntry; update with new one:,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Basic/FileManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/FileManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/FileManager.cpp:46,Performance,cache,cached,46,"// We've not seen this before, or the file is cached as non-existent.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Basic/FileManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/FileManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/FileManager.cpp:49,Performance,cache,cache,49,"// Now that all ancestors of Filename are in the cache, the; // following call is guaranteed to find the DirectoryEntry from the; // cache. A virtual file can also have an empty filename, that could come; // from a source location preprocessor directive with an empty filename as; // an example, so we need to pretend it has a name to ensure a valid directory; // entry can be returned.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Basic/FileManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/FileManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/FileManager.cpp:133,Performance,cache,cache,133,"// Now that all ancestors of Filename are in the cache, the; // following call is guaranteed to find the DirectoryEntry from the; // cache. A virtual file can also have an empty filename, that could come; // from a source location preprocessor directive with an empty filename as; // an example, so we need to pretend it has a name to ensure a valid directory; // entry can be returned.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Basic/FileManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/FileManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/FileManager.cpp:2,Performance,Cache,CacheFailure,2,/*CacheFailure=*/,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Basic/FileManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/FileManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/FileManager.cpp:239,Integrability,interface,interface,239,"// This is not the same as `VFS::getRealPath()`, which resolves symlinks; // but can be very expensive on real file systems.; // FIXME: the semantic of RealPathName is unclear, and the name might be; // misleading. We need to clean up the interface here.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Basic/FileManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/FileManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/FileManager.cpp:85,Performance,cache,cache,85,"/// getStatValue - Get the 'stat' information for the specified path,; /// using the cache to accelerate it if possible. This returns true; /// if the path points to a virtual file or does not exist, or returns; /// false if it's an existent real file. If FileDescriptor is NULL,; /// do directory look-up instead of file look-up.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Basic/FileManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/FileManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/FileManager.cpp:65,Safety,safe,safe,65,"// Name comes from FileEntry/DirectoryEntry::getName(), so it is safe to; // store it in the DenseMap below.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Basic/FileManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/FileManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/FileManager.cpp:112,Safety,avoid,avoid,112,"// For Windows paths, only use the real path if it doesn't resolve; // a substitute drive, as those are used to avoid MAX_PATH issues.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Basic/FileManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/FileManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/FileManager.cpp:44,Usability,Simpl,Simplifying,44,// Fallback to using the absolute path.; // Simplifying /../ is semantically valid on Windows even in the; // presence of symbolic links.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Basic/FileManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/FileManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/FileSystemStatCache.cpp:425,Integrability,interface,interface,425,"//===- FileSystemStatCache.cpp - Caching for 'stat' calls -----------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file defines the FileSystemStatCache interface.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Basic/FileSystemStatCache.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/FileSystemStatCache.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/FileSystemStatCache.cpp:97,Performance,cache,cache,97,"/// FileSystemStatCache::get - Get the 'stat' information for the specified; /// path, using the cache to accelerate it if possible. This returns true if; /// the path does not exist or false if it exists.; ///; /// If isFile is true, then this lookup should only return success for files; /// (not directories). If it is false this lookup should only return; /// success for directories (not files). On a successful file lookup, the; /// implementation can optionally fill in FileDescriptor with a valid; /// descriptor and the client guarantees that it will close it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Basic/FileSystemStatCache.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/FileSystemStatCache.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/FileSystemStatCache.cpp:16,Performance,cache,cache,16,"// If we have a cache, use it to resolve the stat query.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Basic/FileSystemStatCache.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/FileSystemStatCache.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/FileSystemStatCache.cpp:80,Performance,cache,cache,80,"// If this is a directory or a file descriptor is not needed and we have; // no cache, just go to the file system.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Basic/FileSystemStatCache.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/FileSystemStatCache.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/FileSystemStatCache.cpp:210,Energy Efficiency,efficient,efficient,210,"// Otherwise, we have to go to the filesystem. We can always just use; // 'stat' here, but (for files) the client is asking whether the file exists; // because it wants to turn around and *open* it. It is more efficient to; // do ""open+fstat"" on success than it is to do ""stat+open"".; //; // Because of this, check to see if the file exists with 'open'. If the; // open succeeds, use fstat to get the stat info.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Basic/FileSystemStatCache.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/FileSystemStatCache.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/FileSystemStatCache.cpp:37,Availability,failure,failure,37,"// If the path doesn't exist, return failure.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Basic/FileSystemStatCache.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/FileSystemStatCache.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/FileSystemStatCache.cpp:10,Performance,cache,cache,10,"// Do not cache failed stats, it is easy to construct common inconsistent; // situations if we do, and they are not important for PCH performance; // (which currently only needs the stats to construct the initial; // FileManager entries).",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Basic/FileSystemStatCache.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/FileSystemStatCache.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/FileSystemStatCache.cpp:134,Performance,perform,performance,134,"// Do not cache failed stats, it is easy to construct common inconsistent; // situations if we do, and they are not important for PCH performance; // (which currently only needs the stats to construct the initial; // FileManager entries).",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Basic/FileSystemStatCache.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/FileSystemStatCache.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/FileSystemStatCache.cpp:3,Performance,Cache,Cache,3,// Cache file 'stat' results and directories with absolutely paths.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Basic/FileSystemStatCache.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/FileSystemStatCache.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/IdentifierTable.cpp:467,Integrability,interface,interfaces,467,"//===- IdentifierTable.cpp - Hash table for identifier lookup -------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements the IdentifierInfo, IdentifierVisitor, and; // IdentifierTable interfaces.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Basic/IdentifierTable.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/IdentifierTable.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/IdentifierTable.cpp:29,Security,Hash,Hash,29,"//===- IdentifierTable.cpp - Hash table for identifier lookup -------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements the IdentifierInfo, IdentifierVisitor, and; // IdentifierTable interfaces.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Basic/IdentifierTable.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/IdentifierTable.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/IdentifierTable.cpp:6,Usability,simpl,simple,6,/// A simple identifier lookup iterator that represents an; /// empty sequence of identifiers.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Basic/IdentifierTable.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/IdentifierTable.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/IdentifierTable.cpp:12,Integrability,bridg,bridge,12,// We treat bridge casts as objective-C keywords so we can warn on them; // in non-arc mode.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Basic/IdentifierTable.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/IdentifierTable.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/IdentifierTable.cpp:13,Testability,test,tests,13,"// These are tests that need to 'always win', as they are special in that they; // disable based on certain conditions.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Basic/IdentifierTable.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/IdentifierTable.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/IdentifierTable.cpp:258,Integrability,depend,depends,258,"// We use a perfect hash function here involving the length of the keyword,; // the first and third character. For preprocessor ID's there are no; // collisions (if there were, the switch below would complain about duplicate; // case values). Note that this depends on 'if' being null terminated.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Basic/IdentifierTable.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/IdentifierTable.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/IdentifierTable.cpp:20,Security,hash,hash,20,"// We use a perfect hash function here involving the length of the keyword,; // the first and third character. For preprocessor ID's there are no; // collisions (if there were, the switch below would complain about duplicate; // case values). Note that this depends on 'if' being null terminated.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Basic/IdentifierTable.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/IdentifierTable.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/IdentifierTable.cpp:276,Security,hash,hashing,276,//===----------------------------------------------------------------------===//; // Stats Implementation; //===----------------------------------------------------------------------===//; /// PrintStats - Print statistics about how well the identifier table is doing; /// at hashing identifiers.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Basic/IdentifierTable.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/IdentifierTable.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/IdentifierTable.cpp:39,Energy Efficiency,allocate,allocated,39,// Compute statistics about the memory allocated for identifiers.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Basic/IdentifierTable.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/IdentifierTable.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/IdentifierTable.cpp:40,Energy Efficiency,allocate,allocated,40,// MultiKeywordSelector objects are not allocated with new because they have a; // variable size array (for parameter types) at the end of them.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Basic/IdentifierTable.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/IdentifierTable.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/IdentifierTable.cpp:83,Modifiability,variab,variable,83,// MultiKeywordSelector objects are not allocated with new because they have a; // variable size array (for parameter types) at the end of them.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Basic/IdentifierTable.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/IdentifierTable.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/LangOptions.cpp:116,Safety,avoid,avoids,116,"// Reset ""benign"" options with implied values (Options.td ImpliedBy relations); // rather than their defaults. This avoids unexpected combinations and; // invocations that cannot be round-tripped to arguments.; // FIXME: we should derive this automatically from ImpliedBy in tablegen.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Basic/LangOptions.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/LangOptions.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/LangOptions.cpp:29,Integrability,depend,depend,29,"// Set some properties which depend solely on the input kind; it would be nice; // to move these to the language standard, and have the driver resolve the; // input kind + language standard.; //; // FIXME: Perhaps a better model would be for a single source file to have; // multiple language standards (C / C++ std, ObjC std, OpenCL std, OpenMP std); // simultaneously active?",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Basic/LangOptions.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/LangOptions.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/LangOptions.cpp:128,Integrability,contract,contract,128,"// HIP toolchain does not support 'Fast' FPOpFusion in backends since it; // fuses multiplication/addition instructions without contract flag from; // device library functions in LLVM bitcode, which causes accuracy loss in; // certain math functions, e.g. tan(-1e20) becomes -0.933 instead of 0.8446.; // For device library functions in bitcode to work, 'Strict' or 'Standard'; // FPOpFusion options in backends is needed. Therefore 'fast-honor-pragmas'; // FP contract option is used to allow fuse across statements in frontend; // whereas respecting contract flag in backend.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Basic/LangOptions.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/LangOptions.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/LangOptions.cpp:461,Integrability,contract,contract,461,"// HIP toolchain does not support 'Fast' FPOpFusion in backends since it; // fuses multiplication/addition instructions without contract flag from; // device library functions in LLVM bitcode, which causes accuracy loss in; // certain math functions, e.g. tan(-1e20) becomes -0.933 instead of 0.8446.; // For device library functions in bitcode to work, 'Strict' or 'Standard'; // FPOpFusion options in backends is needed. Therefore 'fast-honor-pragmas'; // FP contract option is used to allow fuse across statements in frontend; // whereas respecting contract flag in backend.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Basic/LangOptions.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/LangOptions.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/LangOptions.cpp:552,Integrability,contract,contract,552,"// HIP toolchain does not support 'Fast' FPOpFusion in backends since it; // fuses multiplication/addition instructions without contract flag from; // device library functions in LLVM bitcode, which causes accuracy loss in; // certain math functions, e.g. tan(-1e20) becomes -0.933 instead of 0.8446.; // For device library functions in bitcode to work, 'Strict' or 'Standard'; // FPOpFusion options in backends is needed. Therefore 'fast-honor-pragmas'; // FP contract option is used to allow fuse across statements in frontend; // whereas respecting contract flag in backend.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Basic/LangOptions.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/LangOptions.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/Module.cpp:384,Deployability,install,installed,384,"// The -fmodule-name option tells the compiler to textually include headers in; // the specified module, meaning Clang won't build the specified module. This; // is useful in a number of situations, for instance, when building a library; // that vends a module map, one might want to avoid hitting intermediate build; // products containing the module map or avoid finding the system installed; // modulemap for that library.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Basic/Module.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/Module.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/Module.cpp:284,Safety,avoid,avoid,284,"// The -fmodule-name option tells the compiler to textually include headers in; // the specified module, meaning Clang won't build the specified module. This; // is useful in a number of situations, for instance, when building a library; // that vends a module map, one might want to avoid hitting intermediate build; // products containing the module map or avoid finding the system installed; // modulemap for that library.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Basic/Module.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/Module.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/Module.cpp:359,Safety,avoid,avoid,359,"// The -fmodule-name option tells the compiler to textually include headers in; // the specified module, meaning Clang won't build the specified module. This; // is useful in a number of situations, for instance, when building a library; // that vends a module map, one might want to avoid hitting intermediate build; // products containing the module map or avoid finding the system installed; // modulemap for that library.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Basic/Module.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/Module.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/Module.cpp:32,Availability,avail,available,32,"// If this feature is currently available, we're done.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Basic/Module.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/Module.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/NoSanitizeList.cpp:47,Security,sanitiz,sanitizers,47,"//===--- NoSanitizeList.cpp - Ignored list for sanitizers ----------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // User-provided ignore-list used to disable/alter instrumentation done in; // sanitizers.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Basic/NoSanitizeList.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/NoSanitizeList.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/NoSanitizeList.cpp:458,Security,sanitiz,sanitizers,458,"//===--- NoSanitizeList.cpp - Ignored list for sanitizers ----------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // User-provided ignore-list used to disable/alter instrumentation done in; // sanitizers.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Basic/NoSanitizeList.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/NoSanitizeList.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/OpenMPKinds.cpp:54,Integrability,depend,depending,54,// TODO: 'loop' may require different capture regions depending on the bind; // clause or the parent directive when there is no bind clause. Use; // OMPD_unknown for now.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Basic/OpenMPKinds.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/OpenMPKinds.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/ParsedAttrInfo.cpp:51,Modifiability,plugin,plugins,51,"//===- ParsedAttrInfo.cpp - Registry for attribute plugins ------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file contains the Registry of attributes added by plugins which; // derive the ParsedAttrInfo class.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Basic/ParsedAttrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/ParsedAttrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/ParsedAttrInfo.cpp:438,Modifiability,plugin,plugins,438,"//===- ParsedAttrInfo.cpp - Registry for attribute plugins ------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file contains the Registry of attributes added by plugins which; // derive the ParsedAttrInfo class.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Basic/ParsedAttrInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/ParsedAttrInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/Sanitizers.cpp:7,Security,Sanitiz,Sanitizers,7,"//===- Sanitizers.cpp - C Language Family Language Options ----------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file defines the classes from Sanitizers.h; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Basic/Sanitizers.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/Sanitizers.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/Sanitizers.cpp:418,Security,Sanitiz,Sanitizers,418,"//===- Sanitizers.cpp - C Language Family Language Options ----------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file defines the classes from Sanitizers.h; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Basic/Sanitizers.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/Sanitizers.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/Sanitizers.cpp:46,Modifiability,variab,variables,46,"// Once LLVM switches to C++17, the constexpr variables can be inline and we; // won't need this.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Basic/Sanitizers.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/Sanitizers.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/SanitizerSpecialCaseList.cpp:9,Security,Sanitiz,SanitizerSpecialCaseList,9,"//===--- SanitizerSpecialCaseList.cpp - SCL for sanitizers ----------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // An extension of SpecialCaseList to allowing querying sections by; // SanitizerMask.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Basic/SanitizerSpecialCaseList.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/SanitizerSpecialCaseList.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/SanitizerSpecialCaseList.cpp:48,Security,sanitiz,sanitizers,48,"//===--- SanitizerSpecialCaseList.cpp - SCL for sanitizers ----------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // An extension of SpecialCaseList to allowing querying sections by; // SanitizerMask.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Basic/SanitizerSpecialCaseList.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/SanitizerSpecialCaseList.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/SanitizerSpecialCaseList.cpp:452,Security,Sanitiz,SanitizerMask,452,"//===--- SanitizerSpecialCaseList.cpp - SCL for sanitizers ----------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // An extension of SpecialCaseList to allowing querying sections by; // SanitizerMask.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Basic/SanitizerSpecialCaseList.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/SanitizerSpecialCaseList.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/Sarif.cpp:105,Availability,down,downstream,105,"// If inserted, ensure the original iterator points to the newly inserted; // element, so it can be used downstream.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Basic/Sarif.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/Sarif.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/Sarif.cpp:3,Usability,Clear,Clear,3,"// Clear, reset temporaries before next run.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Basic/Sarif.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/Sarif.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/Sarif.cpp:3,Usability,Clear,Clear,3,// Clear resources associated with a previous run.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Basic/Sarif.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/Sarif.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/SourceLocation.cpp:401,Security,access,accessor,401,"//===- SourceLocation.cpp - Compact identifier for Source Files -----------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file defines accessor methods for the FullSourceLoc class.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Basic/SourceLocation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/SourceLocation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/SourceManager.cpp:422,Integrability,interface,interface,422,"//===- SourceManager.cpp - Track and cache source files -------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements the SourceManager interface.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Basic/SourceManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/SourceManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/SourceManager.cpp:37,Performance,cache,cache,37,"//===- SourceManager.cpp - Track and cache source files -------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements the SourceManager interface.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Basic/SourceManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/SourceManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/SourceManager.cpp:84,Performance,cache,cache,84,/// Returns the kind of memory used to back the memory buffer for; /// this content cache. This is used for performance analysis.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Basic/SourceManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/SourceManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/SourceManager.cpp:108,Performance,perform,performance,108,/// Returns the kind of memory used to back the memory buffer for; /// this content cache. This is used for performance analysis.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Basic/SourceManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/SourceManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/SourceManager.cpp:51,Integrability,wrap,wrap,51,"// Lazily create the Buffer for ContentCaches that wrap files. If we already; // computed it, just return what we have.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Basic/SourceManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/SourceManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/SourceManager.cpp:59,Usability,simpl,simplify,59,// Start with the assumption that the buffer is invalid to simplify early; // return paths.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Basic/SourceManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/SourceManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/SourceManager.cpp:102,Performance,cache,cache,102,"// If we were unable to open the file, then we are in an inconsistent; // situation where the content cache referenced a file which no longer; // exists. Most likely, we were using a stat cache with an invalid entry but; // the file could also have been removed during processing. Since we can't; // really deal with this situation, just create an empty buffer.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Basic/SourceManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/SourceManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/SourceManager.cpp:188,Performance,cache,cache,188,"// If we were unable to open the file, then we are in an inconsistent; // situation where the content cache referenced a file which no longer; // exists. Most likely, we were using a stat cache with an invalid entry but; // the file could also have been removed during processing. Since we can't; // really deal with this situation, just create an empty buffer.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Basic/SourceManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/SourceManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/SourceManager.cpp:174,Performance,cache,cache,174,"// Unless this is a named pipe (in which case we can handle a mismatch),; // check that the file's size is the same as in the file entry (which may; // have come from a stat cache).",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Basic/SourceManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/SourceManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/SourceManager.cpp:19,Security,validat,validated,19,// Buffer has been validated.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Basic/SourceManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/SourceManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/SourceManager.cpp:84,Availability,avail,available,84,"// An unspecified FilenameID means use the previous (or containing); // filename if available, or the main source file otherwise.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Basic/SourceManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/SourceManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/SourceManager.cpp:121,Energy Efficiency,allocate,allocated,121,"// Delete FileEntry objects corresponding to content caches. Since the actual; // content cache objects are bump pointer allocated, we just have to run the; // dtors, but we call the deallocate method for completeness.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Basic/SourceManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/SourceManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/SourceManager.cpp:53,Performance,cache,caches,53,"// Delete FileEntry objects corresponding to content caches. Since the actual; // content cache objects are bump pointer allocated, we just have to run the; // dtors, but we call the deallocate method for completeness.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Basic/SourceManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/SourceManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/SourceManager.cpp:90,Performance,cache,cache,90,"// Delete FileEntry objects corresponding to content caches. Since the actual; // content cache objects are bump pointer allocated, we just have to run the; // dtors, but we call the deallocate method for completeness.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Basic/SourceManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/SourceManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/SourceManager.cpp:30,Performance,load,loaded,30,// Ensure all SLocEntries are loaded from the external source.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Basic/SourceManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/SourceManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/SourceManager.cpp:3,Modifiability,Inherit,Inherit,3,// Inherit any content cache data from the old source manager.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Basic/SourceManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/SourceManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/SourceManager.cpp:23,Performance,cache,cache,23,// Inherit any content cache data from the old source manager.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Basic/SourceManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/SourceManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/SourceManager.cpp:22,Performance,Cache,Cache,22,"// Nope, create a new Cache entry.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Basic/SourceManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/SourceManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/SourceManager.cpp:60,Performance,load,loaded,60,// If the file of the SLocEntry changed we could still have loaded it.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Basic/SourceManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/SourceManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/SourceManager.cpp:10,Availability,recover,recover,10,// Try to recover; create a SLocEntry so the rest of clang can handle it.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Basic/SourceManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/SourceManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/SourceManager.cpp:10,Safety,recover,recover,10,// Try to recover; create a SLocEntry so the rest of clang can handle it.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Basic/SourceManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/SourceManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/SourceManager.cpp:15,Availability,recover,recovering,15,"/// As part of recovering from missing or changed content, produce a; /// fake, non-empty buffer.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Basic/SourceManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/SourceManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/SourceManager.cpp:15,Safety,recover,recovering,15,"/// As part of recovering from missing or changed content, produce a; /// fake, non-empty buffer.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Basic/SourceManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/SourceManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/SourceManager.cpp:15,Availability,recover,recovering,15,"/// As part of recovering from missing or changed content, produce a; /// fake content cache.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Basic/SourceManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/SourceManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/SourceManager.cpp:87,Performance,cache,cache,87,"/// As part of recovering from missing or changed content, produce a; /// fake content cache.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Basic/SourceManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/SourceManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/SourceManager.cpp:15,Safety,recover,recovering,15,"/// As part of recovering from missing or changed content, produce a; /// fake content cache.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Basic/SourceManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/SourceManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/SourceManager.cpp:40,Performance,load,load,40,"// If this is a named pipe, immediately load the buffer to ensure subsequent; // calls to ContentCache::getSize() are accurate.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Basic/SourceManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/SourceManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/SourceManager.cpp:127,Availability,error,error,127,"// FIXME: call `noteSLocAddressSpaceUsage` to report details to users and; // use a source location from `Info` to point at an error.; // Currently, both cause Clang to run indefinitely, this needs to be fixed.; // FIXME: return an error instead of crashing. Returning invalid source; // locations causes compiler to run indefinitely.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Basic/SourceManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/SourceManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/SourceManager.cpp:232,Availability,error,error,232,"// FIXME: call `noteSLocAddressSpaceUsage` to report details to users and; // use a source location from `Info` to point at an error.; // Currently, both cause Clang to run indefinitely, this needs to be fixed.; // FIXME: return an error instead of crashing. Returning invalid source; // locations causes compiler to run indefinitely.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Basic/SourceManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/SourceManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/SourceManager.cpp:271,Performance,cache,cache-miss,271,"//===----------------------------------------------------------------------===//; // SourceLocation manipulation methods.; //===----------------------------------------------------------------------===//; /// Return the FileID for a SourceLocation.; ///; /// This is the cache-miss path of getFileID. Not as hot as that function, but; /// still very important. It is responsible for finding the entry in the; /// SLocEntry tables that contains the specified location.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Basic/SourceManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/SourceManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/SourceManager.cpp:124,Performance,load,loaded,124,// Now it is time to search for the correct file. See where the SLocOffset; // sits in the global view and consult local or loaded buffers for it.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Basic/SourceManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/SourceManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/SourceManager.cpp:149,Performance,load,loaded,149,"/// Return the FileID for a SourceLocation with a low offset.; ///; /// This function knows that the SourceLocation is in a local buffer, not a; /// loaded one.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Basic/SourceManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/SourceManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/SourceManager.cpp:395,Energy Efficiency,efficient,efficient,395,"// After the first and second level caches, I see two common sorts of; // behavior: 1) a lot of searched FileID's are ""near"" the cached file; // location or are ""near"" the cached expansion location. 2) others are just; // completely random and may be a very long way away.; //; // To handle this, we do a linear search for up to 8 steps to catch #1 quickly; // then we fall back to a less cache efficient, but more scalable, binary; // search to find the location.; // See if this is near the file point - worst case we start scanning from the; // most newly created FileID.; // LessIndex - This is the lower bound of the range that we're searching.; // We know that the offset corresponding to the FileID is less than; // SLocOffset.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Basic/SourceManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/SourceManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/SourceManager.cpp:36,Performance,cache,caches,36,"// After the first and second level caches, I see two common sorts of; // behavior: 1) a lot of searched FileID's are ""near"" the cached file; // location or are ""near"" the cached expansion location. 2) others are just; // completely random and may be a very long way away.; //; // To handle this, we do a linear search for up to 8 steps to catch #1 quickly; // then we fall back to a less cache efficient, but more scalable, binary; // search to find the location.; // See if this is near the file point - worst case we start scanning from the; // most newly created FileID.; // LessIndex - This is the lower bound of the range that we're searching.; // We know that the offset corresponding to the FileID is less than; // SLocOffset.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Basic/SourceManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/SourceManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/SourceManager.cpp:129,Performance,cache,cached,129,"// After the first and second level caches, I see two common sorts of; // behavior: 1) a lot of searched FileID's are ""near"" the cached file; // location or are ""near"" the cached expansion location. 2) others are just; // completely random and may be a very long way away.; //; // To handle this, we do a linear search for up to 8 steps to catch #1 quickly; // then we fall back to a less cache efficient, but more scalable, binary; // search to find the location.; // See if this is near the file point - worst case we start scanning from the; // most newly created FileID.; // LessIndex - This is the lower bound of the range that we're searching.; // We know that the offset corresponding to the FileID is less than; // SLocOffset.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Basic/SourceManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/SourceManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/SourceManager.cpp:172,Performance,cache,cached,172,"// After the first and second level caches, I see two common sorts of; // behavior: 1) a lot of searched FileID's are ""near"" the cached file; // location or are ""near"" the cached expansion location. 2) others are just; // completely random and may be a very long way away.; //; // To handle this, we do a linear search for up to 8 steps to catch #1 quickly; // then we fall back to a less cache efficient, but more scalable, binary; // search to find the location.; // See if this is near the file point - worst case we start scanning from the; // most newly created FileID.; // LessIndex - This is the lower bound of the range that we're searching.; // We know that the offset corresponding to the FileID is less than; // SLocOffset.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Basic/SourceManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/SourceManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/SourceManager.cpp:389,Performance,cache,cache,389,"// After the first and second level caches, I see two common sorts of; // behavior: 1) a lot of searched FileID's are ""near"" the cached file; // location or are ""near"" the cached expansion location. 2) others are just; // completely random and may be a very long way away.; //; // To handle this, we do a linear search for up to 8 steps to catch #1 quickly; // then we fall back to a less cache efficient, but more scalable, binary; // search to find the location.; // See if this is near the file point - worst case we start scanning from the; // most newly created FileID.; // LessIndex - This is the lower bound of the range that we're searching.; // We know that the offset corresponding to the FileID is less than; // SLocOffset.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Basic/SourceManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/SourceManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/SourceManager.cpp:415,Performance,scalab,scalable,415,"// After the first and second level caches, I see two common sorts of; // behavior: 1) a lot of searched FileID's are ""near"" the cached file; // location or are ""near"" the cached expansion location. 2) others are just; // completely random and may be a very long way away.; //; // To handle this, we do a linear search for up to 8 steps to catch #1 quickly; // then we fall back to a less cache efficient, but more scalable, binary; // search to find the location.; // See if this is near the file point - worst case we start scanning from the; // most newly created FileID.; // LessIndex - This is the lower bound of the range that we're searching.; // We know that the offset corresponding to the FileID is less than; // SLocOffset.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Basic/SourceManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/SourceManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/SourceManager.cpp:125,Performance,load,loaded,125,"/// Return the FileID for a SourceLocation with a high offset.; ///; /// This function knows that the SourceLocation is in a loaded buffer, not a; /// local one.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Basic/SourceManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/SourceManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/SourceManager.cpp:141,Availability,down,down,141,"/// getImmediateSpellingLoc - Given a SourceLocation object, return the; /// spelling location referenced by the ID. This is the first level down; /// towards the place where the characters that make up the lexed token can be; /// found. This should not generally be used by clients.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Basic/SourceManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/SourceManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/SourceManager.cpp:18,Availability,Mask,Mask,18,"// At that point, Mask contains 0x80 set at each byte that holds a value; // in [\n, \r + 1 [; // Scan for the next newline - it's very likely there's one.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Basic/SourceManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/SourceManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/SourceManager.cpp:158,Performance,optimiz,optimized,158,"// FIXME: I would like to be convinced that this code is worth being as; // complicated as it is, binary search isn't that slow.; //; // If it is worth being optimized, then in my opinion it could be more; // performant, simpler, and more obviously correct by just ""galloping"" outward; // from the queried file position. In fact, this could be incorporated into a; // generic algorithm such as lower_bound_with_hint.; //; // If someone gives me a test case where this matters, and I will do it! - DWD; // If the previous query was to the same file, we know both the file pos from; // that query and the line number returned. This allows us to narrow the; // search space from the entire file to something near the match.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Basic/SourceManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/SourceManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/SourceManager.cpp:209,Performance,perform,performant,209,"// FIXME: I would like to be convinced that this code is worth being as; // complicated as it is, binary search isn't that slow.; //; // If it is worth being optimized, then in my opinion it could be more; // performant, simpler, and more obviously correct by just ""galloping"" outward; // from the queried file position. In fact, this could be incorporated into a; // generic algorithm such as lower_bound_with_hint.; //; // If someone gives me a test case where this matters, and I will do it! - DWD; // If the previous query was to the same file, we know both the file pos from; // that query and the line number returned. This allows us to narrow the; // search space from the entire file to something near the match.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Basic/SourceManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/SourceManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/SourceManager.cpp:447,Testability,test,test,447,"// FIXME: I would like to be convinced that this code is worth being as; // complicated as it is, binary search isn't that slow.; //; // If it is worth being optimized, then in my opinion it could be more; // performant, simpler, and more obviously correct by just ""galloping"" outward; // from the queried file position. In fact, this could be incorporated into a; // generic algorithm such as lower_bound_with_hint.; //; // If someone gives me a test case where this matters, and I will do it! - DWD; // If the previous query was to the same file, we know both the file pos from; // that query and the line number returned. This allows us to narrow the; // search space from the entire file to something near the match.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Basic/SourceManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/SourceManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/SourceManager.cpp:221,Usability,simpl,simpler,221,"// FIXME: I would like to be convinced that this code is worth being as; // complicated as it is, binary search isn't that slow.; //; // If it is worth being optimized, then in my opinion it could be more; // performant, simpler, and more obviously correct by just ""galloping"" outward; // from the queried file position. In fact, this could be incorporated into a; // generic algorithm such as lower_bound_with_hint.; //; // If someone gives me a test case where this matters, and I will do it! - DWD; // If the previous query was to the same file, we know both the file pos from; // that query and the line number returned. This allows us to narrow the; // search space from the entire file to something near the match.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Basic/SourceManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/SourceManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/SourceManager.cpp:109,Safety,avoid,avoid,109,"// To get the source name, first consult the FileEntry (if one exists); // before the MemBuffer as this will avoid unnecessarily paging in the; // MemBuffer.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Basic/SourceManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/SourceManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/SourceManager.cpp:45,Deployability,update,update,45,"// If we have #line directives in this file, update and overwrite the physical; // location info if appropriate.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Basic/SourceManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/SourceManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/SourceManager.cpp:94,Availability,down,down,94,// Use the line number specified by the LineEntry. This line number may; // be multiple lines down from the line entry. Add the difference in; // physical line numbers from the query point and the line marker to the; // total.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Basic/SourceManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/SourceManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/SourceManager.cpp:69,Testability,assert,assert,69,// Lines are used as a one-based index into a zero-based array. This assert; // checks for possible buffer underruns.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Basic/SourceManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/SourceManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/SourceManager.cpp:627,Deployability,update,update,627,"// Add a new chunk for this macro argument. A previous macro argument chunk; // may have been lexed again, so e.g. if the map is; // 0 -> SourceLocation(); // 100 -> Expanded loc #1; // 110 -> SourceLocation(); // and we found a new macro FileID that lexed from offset 105 with length 3,; // the new map will be:; // 0 -> SourceLocation(); // 100 -> Expanded loc #1; // 105 -> Expanded loc #2; // 108 -> Expanded loc #1; // 110 -> SourceLocation(); //; // Since re-lexed macro chunks will always be the same size or less of; // previous chunks, we only need to find where the ending of the new macro; // chunk is mapped to and update the map with new begin/end mappings.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Basic/SourceManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/SourceManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/SourceManager.cpp:35,Performance,cache,cache,35,// Uses IncludedLocMap to retrieve/cache the decomposed loc.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Basic/SourceManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/SourceManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/SourceManager.cpp:38,Performance,load,loaded,38,// If one is local while the other is loaded.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Basic/SourceManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/SourceManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/SourceManager.cpp:3,Performance,Load,Loaded,3,"// Loaded FileIDs are negative, we store the lowest FileID from each; // allocation, later allocations have lower FileIDs.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Basic/SourceManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/SourceManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/SourceManager.cpp:15,Performance,load,loaded,15,// If both are loaded from different AST files.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Basic/SourceManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/SourceManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/SourceManager.cpp:15,Performance,cache,cache,15,/// Return the cache entry for comparing the given file IDs; /// for isBeforeInTranslationUnit.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Basic/SourceManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/SourceManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/SourceManager.cpp:43,Performance,cache,cache,43,// This is a magic number for limiting the cache size. It was experimentally; // derived from a small Objective-C project (where the cache filled; // out to ~250 items). We can make it larger if necessary.; // FIXME: this is almost certainly full these days. Use an LRU cache?,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Basic/SourceManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/SourceManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/SourceManager.cpp:133,Performance,cache,cache,133,// This is a magic number for limiting the cache size. It was experimentally; // derived from a small Objective-C project (where the cache filled; // out to ~250 items). We can make it larger if necessary.; // FIXME: this is almost certainly full these days. Use an LRU cache?,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Basic/SourceManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/SourceManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/SourceManager.cpp:270,Performance,cache,cache,270,// This is a magic number for limiting the cache size. It was experimentally; // derived from a small Objective-C project (where the cache filled; // out to ~250 items). We can make it larger if necessary.; // FIXME: this is almost certainly full these days. Use an LRU cache?,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Basic/SourceManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/SourceManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/SourceManager.cpp:165,Deployability,update,update,165,"// If the cache size isn't too large, do a lookup and if necessary default; // construct an entry. We can then return it to the caller for direct; // use. When they update the value, the cache will get automatically; // updated as well.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Basic/SourceManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/SourceManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/SourceManager.cpp:220,Deployability,update,updated,220,"// If the cache size isn't too large, do a lookup and if necessary default; // construct an entry. We can then return it to the caller for direct; // use. When they update the value, the cache will get automatically; // updated as well.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Basic/SourceManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/SourceManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/SourceManager.cpp:10,Performance,cache,cache,10,"// If the cache size isn't too large, do a lookup and if necessary default; // construct an entry. We can then return it to the caller for direct; // use. When they update the value, the cache will get automatically; // updated as well.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Basic/SourceManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/SourceManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/SourceManager.cpp:187,Performance,cache,cache,187,"// If the cache size isn't too large, do a lookup and if necessary default; // construct an entry. We can then return it to the caller for direct; // use. When they update the value, the cache will get automatically; // updated as well.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Basic/SourceManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/SourceManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/SourceManager.cpp:148,Performance,load,loaded,148,"// getDecomposedLoc may have failed to return a valid FileID because, e.g. it; // is a serialized one referring to a file that was removed after we loaded; // the PCH.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Basic/SourceManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/SourceManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/SourceManager.cpp:26,Performance,cache,cache,26,"// Okay, we missed in the cache, we'll compute the answer and populate it.; // We need to find the common ancestor. The only way of doing this is to; // build the complete include chain for one and then walking up the chain; // of the other looking for a match.; // A location within a FileID on the path up from LOffs to the main file.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Basic/SourceManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/SourceManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/SourceManager.cpp:10,Availability,redundant,redundant,10,"// FileID redundant, but clearer.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Basic/SourceManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/SourceManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/SourceManager.cpp:10,Safety,redund,redundant,10,"// FileID redundant, but clearer.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Basic/SourceManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/SourceManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/SourceManager.cpp:25,Usability,clear,clearer,25,"// FileID redundant, but clearer.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Basic/SourceManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/SourceManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/SourceManager.cpp:52,Performance,cache,cache,52,// Compare the locations within the common file and cache them.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Basic/SourceManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/SourceManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/SourceManager.cpp:358,Performance,load,loaded,358,"// The relative order of LChild and RChild is a tiebreaker when; // - locs expand to the same location (occurs in macro arg expansion); // - one loc is a parent of the other (we consider the parent as ""first""); // For the parent entry to be first, its invalid child file ID must; // compare smaller to the valid child file ID of the other entry.; // However loaded FileIDs are <0, so we perform *unsigned* comparison!; // This changes the relative order of local vs loaded FileIDs, but it; // doesn't matter as these are never mixed in macro expansion.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Basic/SourceManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/SourceManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/SourceManager.cpp:387,Performance,perform,perform,387,"// The relative order of LChild and RChild is a tiebreaker when; // - locs expand to the same location (occurs in macro arg expansion); // - one loc is a parent of the other (we consider the parent as ""first""); // For the parent entry to be first, its invalid child file ID must; // compare smaller to the valid child file ID of the other entry.; // However loaded FileIDs are <0, so we perform *unsigned* comparison!; // This changes the relative order of local vs loaded FileIDs, but it; // doesn't matter as these are never mixed in macro expansion.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Basic/SourceManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/SourceManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/SourceManager.cpp:466,Performance,load,loaded,466,"// The relative order of LChild and RChild is a tiebreaker when; // - locs expand to the same location (occurs in macro arg expansion); // - one loc is a parent of the other (we consider the parent as ""first""); // For the parent entry to be first, its invalid child file ID must; // compare smaller to the valid child file ID of the other entry.; // However loaded FileIDs are <0, so we perform *unsigned* comparison!; // This changes the relative order of local vs loaded FileIDs, but it; // doesn't matter as these are never mixed in macro expansion.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Basic/SourceManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/SourceManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/SourceManager.cpp:8,Performance,load,loaded,8,// Dump loaded SLocEntries.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Basic/SourceManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/SourceManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/SourceManager.cpp:44,Availability,down,downwards,44,// Loaded SLocEntries have indexes counting downwards from -2.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Basic/SourceManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/SourceManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/SourceManager.cpp:3,Performance,Load,Loaded,3,// Loaded SLocEntries have indexes counting downwards from -2.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Basic/SourceManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/SourceManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/SourceManager.cpp:65,Availability,down,down,65,"/// Return the amount of memory used by memory buffers, breaking down; /// by heap-backed versus mmap'ed memory.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Basic/SourceManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/SourceManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/SourceManager.cpp:47,Deployability,release,released,47,// This is referenced by `FileMgr` and will be released by `FileMgr` when it; // is deleted.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Basic/SourceManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/SourceManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/SourceMgrAdapter.cpp:56,Energy Efficiency,Adapt,Adapter,56,"//=== SourceMgrAdapter.cpp - SourceMgr to SourceManager Adapter -----------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements the adapter that maps diagnostics from llvm::SourceMgr; // to Clang's SourceManager.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Basic/SourceMgrAdapter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/SourceMgrAdapter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/SourceMgrAdapter.cpp:408,Energy Efficiency,adapt,adapter,408,"//=== SourceMgrAdapter.cpp - SourceMgr to SourceManager Adapter -----------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements the adapter that maps diagnostics from llvm::SourceMgr; // to Clang's SourceManager.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Basic/SourceMgrAdapter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/SourceMgrAdapter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/SourceMgrAdapter.cpp:56,Integrability,Adapter,Adapter,56,"//=== SourceMgrAdapter.cpp - SourceMgr to SourceManager Adapter -----------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements the adapter that maps diagnostics from llvm::SourceMgr; // to Clang's SourceManager.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Basic/SourceMgrAdapter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/SourceMgrAdapter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/SourceMgrAdapter.cpp:408,Integrability,adapter,adapter,408,"//=== SourceMgrAdapter.cpp - SourceMgr to SourceManager Adapter -----------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements the adapter that maps diagnostics from llvm::SourceMgr; // to Clang's SourceManager.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Basic/SourceMgrAdapter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/SourceMgrAdapter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/SourceMgrAdapter.cpp:56,Modifiability,Adapt,Adapter,56,"//=== SourceMgrAdapter.cpp - SourceMgr to SourceManager Adapter -----------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements the adapter that maps diagnostics from llvm::SourceMgr; // to Clang's SourceManager.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Basic/SourceMgrAdapter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/SourceMgrAdapter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/SourceMgrAdapter.cpp:408,Modifiability,adapt,adapter,408,"//=== SourceMgrAdapter.cpp - SourceMgr to SourceManager Adapter -----------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements the adapter that maps diagnostics from llvm::SourceMgr; // to Clang's SourceManager.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Basic/SourceMgrAdapter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/SourceMgrAdapter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/SourceMgrAdapter.cpp:15,Integrability,message,message,15,// Extract the message.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Basic/SourceMgrAdapter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/SourceMgrAdapter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/Stack.cpp:59,Modifiability,variab,variable,59,"// The volatile store here is intended to escape the local variable, to; // prevent the compiler from optimizing CharOnStack into anything other; // than a char on the stack.; //; // Tested on: MSVC 2015 - 2019, GCC 4.9 - 9, Clang 3.2 - 9, ICC 13 - 19.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Basic/Stack.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/Stack.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/Stack.cpp:102,Performance,optimiz,optimizing,102,"// The volatile store here is intended to escape the local variable, to; // prevent the compiler from optimizing CharOnStack into anything other; // than a char on the stack.; //; // Tested on: MSVC 2015 - 2019, GCC 4.9 - 9, Clang 3.2 - 9, ICC 13 - 19.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Basic/Stack.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/Stack.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/Stack.cpp:183,Testability,Test,Tested,183,"// The volatile store here is intended to escape the local variable, to; // prevent the compiler from optimizing CharOnStack into anything other; // than a char on the stack.; //; // Tested on: MSVC 2015 - 2019, GCC 4.9 - 9, Clang 3.2 - 9, ICC 13 - 19.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Basic/Stack.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/Stack.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/Stack.cpp:118,Energy Efficiency,allocate,allocates,118,"// If the stack pointer has a surprising value, we do not understand this; // stack usage scheme. (Perhaps the target allocates new stack regions on; // demand for us.) Don't try to guess what's going on.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Basic/Stack.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/Stack.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/TargetInfo.cpp:419,Integrability,interface,interface,419,"//===--- TargetInfo.cpp - Information about Target machine ----------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements the TargetInfo interface.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Basic/TargetInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/TargetInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/TargetInfo.cpp:157,Deployability,configurat,configuration,157,/// adjust - Set forced language options.; /// Apply changes to the target information with respect to certain; /// language options which change the target configuration and adjust; /// the language based on the target options where applicable.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Basic/TargetInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/TargetInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/TargetInfo.cpp:157,Modifiability,config,configuration,157,/// adjust - Set forced language options.; /// Apply changes to the target information with respect to certain; /// language options which change the target configuration and adjust; /// the language based on the target options where applicable.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Basic/TargetInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/TargetInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/TargetInfo.cpp:379,Security,access,access,379,// OpenCL C v3.0 s6.7.5 - The generic address space requires support for; // OpenCL C 2.0 or OpenCL C 3.0 with the __opencl_c_generic_address_space; // feature; // OpenCL C v3.0 s6.2.1 - OpenCL pipes require support of OpenCL C 2.0; // or later and __opencl_c_pipes feature; // FIXME: These language options are also defined in setLangDefaults(); // for OpenCL C 2.0 but with no access to target capabilities. Target; // should be immutable once created and thus these language options need; // to be defined only once.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Basic/TargetInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/TargetInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/TargetInfo.cpp:51,Availability,error,erroring,51,// Go ahead and trim whitespace rather than either erroring or; // accepting it weirdly.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Basic/TargetInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/TargetInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/TargetInfo.cpp:15,Availability,error,error,15,"// FIXME: This error return is in place temporarily so we can; // add more constraints as we hit it. Eventually, an unknown; // constraint should just be treated as 'g'.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Basic/TargetInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/TargetInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/Targets.cpp:134,Availability,avail,available,134,"// Provide macros for all the calling convention keywords. Provide both; // single and double underscore prefixed variants. These are available on; // x64 as well as x86, even though they have no effect.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Basic/Targets.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/Targets.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/Targets.cpp:13,Performance,Tune,TuneCPU,13,// Check the TuneCPU name if specified.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Basic/Targets.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/Targets.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/Targets.cpp:104,Integrability,depend,dependencies,104,"// Compute the default target features, we need the target to handle this; // because features may have dependencies on one another.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Basic/Targets.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/Targets.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/Targets.cpp:45,Safety,predict,predictable,45,"// Sort here, so we handle the features in a predictable order. (This matters; // when we're dealing with features that overlap.)",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Basic/Targets.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/Targets.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/Targets.cpp:4,Security,validat,validateOpenCLTarget,4,/// validateOpenCLTarget - Check that OpenCL target has valid; /// options setting based on OpenCL version.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Basic/Targets.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/Targets.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/Targets.cpp:3,Security,Validat,Validate,3,// Validate that feature macros are set properly for OpenCL C 3.0.; // In other cases assume that target is always valid.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Basic/Targets.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/Targets.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/Warnings.cpp:731,Availability,error,errors,731,"//===--- Warnings.cpp - C-Language Front-end ------------------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // Command line warning options handler.; //; //===----------------------------------------------------------------------===//; //; // This file is responsible for handling all warning options. This includes; // a number of -Wfoo options and their variants, which are driven by TableGen-; // generated data, and the special cases -pedantic, -pedantic-errors, -w,; // -Werror and -Wfatal-errors.; //; // Each warning option controls any number of actual warnings.; // Given a warning option 'foo', the following are valid:; // -Wfoo, -Wno-foo, -Werror=foo, -Wfatal-errors=foo; //; // Remark options are also handled here, analogously, except that they are much; // simpler because a remark can't be promoted to an error.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Basic/Warnings.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/Warnings.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/Warnings.cpp:767,Availability,error,errors,767,"//===--- Warnings.cpp - C-Language Front-end ------------------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // Command line warning options handler.; //; //===----------------------------------------------------------------------===//; //; // This file is responsible for handling all warning options. This includes; // a number of -Wfoo options and their variants, which are driven by TableGen-; // generated data, and the special cases -pedantic, -pedantic-errors, -w,; // -Werror and -Wfatal-errors.; //; // Each warning option controls any number of actual warnings.; // Given a warning option 'foo', the following are valid:; // -Wfoo, -Wno-foo, -Werror=foo, -Wfatal-errors=foo; //; // Remark options are also handled here, analogously, except that they are much; // simpler because a remark can't be promoted to an error.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Basic/Warnings.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/Warnings.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/Warnings.cpp:944,Availability,error,errors,944,"//===--- Warnings.cpp - C-Language Front-end ------------------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // Command line warning options handler.; //; //===----------------------------------------------------------------------===//; //; // This file is responsible for handling all warning options. This includes; // a number of -Wfoo options and their variants, which are driven by TableGen-; // generated data, and the special cases -pedantic, -pedantic-errors, -w,; // -Werror and -Wfatal-errors.; //; // Each warning option controls any number of actual warnings.; // Given a warning option 'foo', the following are valid:; // -Wfoo, -Wno-foo, -Werror=foo, -Wfatal-errors=foo; //; // Remark options are also handled here, analogously, except that they are much; // simpler because a remark can't be promoted to an error.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Basic/Warnings.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/Warnings.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/Warnings.cpp:1093,Availability,error,error,1093,"//===--- Warnings.cpp - C-Language Front-end ------------------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // Command line warning options handler.; //; //===----------------------------------------------------------------------===//; //; // This file is responsible for handling all warning options. This includes; // a number of -Wfoo options and their variants, which are driven by TableGen-; // generated data, and the special cases -pedantic, -pedantic-errors, -w,; // -Werror and -Wfatal-errors.; //; // Each warning option controls any number of actual warnings.; // Given a warning option 'foo', the following are valid:; // -Wfoo, -Wno-foo, -Werror=foo, -Wfatal-errors=foo; //; // Remark options are also handled here, analogously, except that they are much; // simpler because a remark can't be promoted to an error.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Basic/Warnings.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/Warnings.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/Warnings.cpp:1044,Usability,simpl,simpler,1044,"//===--- Warnings.cpp - C-Language Front-end ------------------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // Command line warning options handler.; //; //===----------------------------------------------------------------------===//; //; // This file is responsible for handling all warning options. This includes; // a number of -Wfoo options and their variants, which are driven by TableGen-; // generated data, and the special cases -pedantic, -pedantic-errors, -w,; // -Werror and -Wfatal-errors.; //; // Each warning option controls any number of actual warnings.; // Given a warning option 'foo', the following are valid:; // -Wfoo, -Wno-foo, -Werror=foo, -Wfatal-errors=foo; //; // Remark options are also handled here, analogously, except that they are much; // simpler because a remark can't be promoted to an error.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Basic/Warnings.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/Warnings.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/Warnings.cpp:29,Availability,error,errors,29,"// If -pedantic or -pedantic-errors was specified, then we want to map all; // extension diagnostics onto WARNING or ERROR unless the user has futz'd; // around with them explicitly.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Basic/Warnings.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/Warnings.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/Warnings.cpp:117,Availability,ERROR,ERROR,117,"// If -pedantic or -pedantic-errors was specified, then we want to map all; // extension diagnostics onto WARNING or ERROR unless the user has futz'd; // around with them explicitly.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Basic/Warnings.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/Warnings.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/Warnings.cpp:120,Availability,error,errors,120,"// We parse the warning options twice. The first pass sets diagnostic state,; // while the second pass reports warnings/errors. This has the effect that; // we follow the more canonical ""last option wins"" paradigm when there are; // conflicting options.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Basic/Warnings.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/Warnings.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/Warnings.cpp:16,Availability,error,error,16,"// -Werror/-Wno-error is a special case, not controlled by the option; // table. It also has the ""specifier"" form of -Werror=foo. GCC supports; // the deprecated -Werror-implicit-function-declaration which is used by; // a few projects.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Basic/Warnings.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/Warnings.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/Warnings.cpp:22,Availability,error,error,22,// Set the warning as error flag for this specifier.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Basic/Warnings.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/Warnings.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/Warnings.cpp:11,Availability,error,errors,11,// -Wfatal-errors is yet another special case.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Basic/Warnings.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/Warnings.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/Warnings.cpp:11,Availability,error,error,11,// Set the error as fatal flag for this specifier.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Basic/Warnings.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/Warnings.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/Targets/AArch64.cpp:29,Availability,avail,available,29,// Make __builtin_ms_va_list available.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Basic/Targets/AArch64.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/Targets/AArch64.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/Targets/AArch64.cpp:22,Availability,avail,available,22,"// Make the SVE types available. Note that this deliberately doesn't; // depend on SveMode, since in principle it should be possible to turn; // SVE on and off within a translation unit. It should also be possible; // to compile the global declaration:; //; // __SVInt8_t *ptr;; //; // even without SVE.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Basic/Targets/AArch64.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/Targets/AArch64.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/Targets/AArch64.cpp:73,Integrability,depend,depend,73,"// Make the SVE types available. Note that this deliberately doesn't; // depend on SveMode, since in principle it should be possible to turn; // SVE on and off within a translation unit. It should also be possible; // to compile the global declaration:; //; // __SVInt8_t *ptr;; //; // even without SVE.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Basic/Targets/AArch64.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/Targets/AArch64.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/Targets/AArch64.cpp:9,Safety,detect,detection,9,// Allow detection of fast FMA support.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Basic/Targets/AArch64.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/Targets/AArch64.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/Targets/AArch64.cpp:110,Integrability,depend,dependant,110,"// If the feature is an architecture feature (like v8.2a), add all previous; // architecture versions and any dependant target features.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Basic/Targets/AArch64.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/Targets/AArch64.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/Targets/AArch64.cpp:98,Integrability,depend,dependent,98,"// Not an architecture, nothing more to do.; // Disabling an architecture feature does not affect dependent features",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Basic/Targets/AArch64.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/Targets/AArch64.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/Targets/AArch64.cpp:93,Deployability,Update,UpdatedFeaturesVec,93,"// Process target and dependent features. This is done in two loops collecting; // them into UpdatedFeaturesVec: first to add dependent '+'features, second to; // add target '+/-'features that can later disable some of features added on; // the first loop. Function Multi Versioning features begin with '?'.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Basic/Targets/AArch64.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/Targets/AArch64.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/Targets/AArch64.cpp:22,Integrability,depend,dependent,22,"// Process target and dependent features. This is done in two loops collecting; // them into UpdatedFeaturesVec: first to add dependent '+'features, second to; // add target '+/-'features that can later disable some of features added on; // the first loop. Function Multi Versioning features begin with '?'.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Basic/Targets/AArch64.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/Targets/AArch64.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/Targets/AArch64.cpp:126,Integrability,depend,dependent,126,"// Process target and dependent features. This is done in two loops collecting; // them into UpdatedFeaturesVec: first to add dependent '+'features, second to; // add target '+/-'features that can later disable some of features added on; // the first loop. Function Multi Versioning features begin with '?'.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Basic/Targets/AArch64.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/Targets/AArch64.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/Targets/AArch64.cpp:210,Performance,tune,tune,210,"// Parse AArch64 Target attributes, which are a comma separated list of:; // ""arch=<arch>"" - parsed to features as per -march=..; // ""cpu=<cpu>"" - parsed to features as per -mcpu=.., with CPU set to <cpu>; // ""tune=<cpu>"" - TuneCPU set to <cpu>; // ""feature"", ""no-feature"" - Add (or remove) feature.; // ""+feature"", ""+nofeature"" - Add (or remove) feature.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Basic/Targets/AArch64.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/Targets/AArch64.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/Targets/AArch64.cpp:224,Performance,Tune,TuneCPU,224,"// Parse AArch64 Target attributes, which are a comma separated list of:; // ""arch=<arch>"" - parsed to features as per -march=..; // ""cpu=<cpu>"" - parsed to features as per -mcpu=.., with CPU set to <cpu>; // ""tune=<cpu>"" - TuneCPU set to <cpu>; // ""feature"", ""no-feature"" - Add (or remove) feature.; // ""+feature"", ""+nofeature"" - Add (or remove) feature.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Basic/Targets/AArch64.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/Targets/AArch64.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/Targets/AArch64.cpp:54,Availability,error,error,54,// Pushing the original feature string to give a sema error later on; // when they get checked.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Basic/Targets/AArch64.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/Targets/AArch64.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/Targets/AArch64.cpp:43,Testability,log,logical,43,// Constant that can be used with a 32-bit logical instruction,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Basic/Targets/AArch64.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/Targets/AArch64.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/Targets/AArch64.cpp:43,Testability,log,logical,43,// Constant that can be used with a 64-bit logical instruction,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Basic/Targets/AArch64.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/Targets/AArch64.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/Targets/AArch64.cpp:267,Availability,error,error,267,"// Ump: A memory address suitable for ldp/stp in SI, DI, SF and DF modes.; // Utf: A memory address suitable for ldp/stp in TF mode.; // Usa: An absolute symbolic address.; // Ush: The high part (bits 32:12) of a pc-relative symbolic address.; // Better to return an error saying that it's an unrecognised constraint; // even if this is a valid constraint in gcc.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Basic/Targets/AArch64.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/Targets/AArch64.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/Targets/AMDGPU.cpp:54,Deployability,update,update,54,"// If you edit the description strings, make sure you update; // getPointerWidthV().",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Basic/Targets/AMDGPU.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/Targets/AMDGPU.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/Targets/AMDGPU.cpp:26,Testability,log,logic,26,// TODO: Should move this logic into TargetParser,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Basic/Targets/AMDGPU.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/Targets/AMDGPU.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/Targets/AMDGPU.cpp:20,Availability,avail,available,20,// __bf16 is always available as a load/store only type on AMDGCN.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Basic/Targets/AMDGPU.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/Targets/AMDGPU.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/Targets/AMDGPU.cpp:35,Performance,load,load,35,// __bf16 is always available as a load/store only type on AMDGCN.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Basic/Targets/AMDGPU.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/Targets/AMDGPU.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/Targets/AMDGPU.cpp:35,Modifiability,extend,extended,35,"// On x86_64 long double is 80-bit extended precision format, which is; // not supported by AMDGPU. 128-bit floating point format is also not; // supported by AMDGPU. Therefore keep its own format for these two types.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Basic/Targets/AMDGPU.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/Targets/AMDGPU.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/Targets/ARM.cpp:31,Modifiability,variab,variable,31,// FIXME: Enumerated types are variable width in straight AAPCS.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Basic/Targets/ARM.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/Targets/ARM.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/Targets/ARM.cpp:3,Performance,cache,cache,3,// cache TargetParser info,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Basic/Targets/ARM.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/Targets/ARM.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/Targets/ARM.cpp:3,Performance,cache,cache,3,// cache CPU related strings,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Basic/Targets/ARM.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/Targets/ARM.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/Targets/ARM.cpp:3,Performance,Cache,Cache,3,// Cache arch related info.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Basic/Targets/ARM.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/Targets/ARM.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/Targets/ARM.cpp:32,Availability,avail,available,32,// The __bf16 type is generally available so long as we have any fp registers.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Basic/Targets/ARM.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/Targets/ARM.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/Targets/ARM.cpp:24,Security,access,access,24,// ACLE 6.4.3 Unaligned access supported in hardware,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Basic/Targets/ARM.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/Targets/ARM.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/Targets/ARM.cpp:58,Availability,avail,available,58,"// This only gets set when Neon instructions are actually available, unlike; // the VFP define, hence the soft float and arch check. This is subtly; // different from gcc, we follow the intent which was that it should be set; // when Neon instructions are actually available.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Basic/Targets/ARM.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/Targets/ARM.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/Targets/ARM.cpp:265,Availability,avail,available,265,"// This only gets set when Neon instructions are actually available, unlike; // the VFP define, hence the soft float and arch check. This is subtly; // different from gcc, we follow the intent which was that it should be set; // when Neon instructions are actually available.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Basic/Targets/ARM.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/Targets/ARM.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/Targets/ARM.cpp:70,Availability,avail,available,70,// An immediate integer between 0 and 65535 (valid for MOVW); // only available in ARMv6T2 and above,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Basic/Targets/ARM.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/Targets/ARM.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/Targets/ARM.cpp:47,Energy Efficiency,power,power,47,// FIXME: should check if immediate value is a power of two or a integer; // between 0 and 32,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Basic/Targets/ARM.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/Targets/ARM.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/Targets/ARM.cpp:10,Performance,load,load,10,// ...VFP load/store (reg+constant offset),MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Basic/Targets/ARM.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/Targets/ARM.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/Targets/ARM.cpp:13,Performance,load,load,13,// ...iWMMXt load/store,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Basic/Targets/ARM.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/Targets/ARM.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/Targets/ARM.cpp:21,Performance,load,load,21,// address valid for load/store opaque types wider; // than 128-bits,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Basic/Targets/ARM.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/Targets/ARM.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/Targets/ARM.cpp:44,Performance,load,load,44,// valid address for Neon doubleword vector load/store,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Basic/Targets/ARM.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/Targets/ARM.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/Targets/ARM.cpp:48,Performance,load,load,48,// valid address for Neon element and structure load/store,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Basic/Targets/ARM.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/Targets/ARM.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/Targets/ARM.cpp:32,Performance,load,loads,32,// valid address for non-offset loads/stores of quad-word; // values in four ARM registers,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Basic/Targets/ARM.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/Targets/ARM.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/Targets/AVR.cpp:28,Integrability,synchroniz,synchronized,28,// NOTE: This list has been synchronized with gcc-avr 5.4.0 and avr-libc 2.0.0.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Basic/Targets/AVR.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/Targets/AVR.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/Targets/AVR.cpp:27,Integrability,depend,depends,27,"// ""%~"" represents for 'r' depends on the device has long jump/call.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Basic/Targets/AVR.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/Targets/AVR.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/Targets/AVR.cpp:27,Integrability,depend,depends,27,"// ""%!"" represents for 'e' depends on the PC register size.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Basic/Targets/AVR.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/Targets/AVR.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/Targets/AVR.h:3,Usability,Simpl,Simple,3,// Simple upper registers,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Basic/Targets/AVR.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/Targets/AVR.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/Targets/Lanai.h:81,Safety,safe,safely,81,// Temporary approach to make everything at least word-aligned and allow for; // safely casting between pointers with different alignment requirements.; // TODO: Remove this when there are no more cast align warnings on the; // firmware.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Basic/Targets/Lanai.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/Targets/Lanai.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/Targets/LoongArch.cpp:33,Availability,avail,available,33,// A floating-point register (if available).,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Basic/Targets/LoongArch.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/Targets/LoongArch.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/Targets/LoongArch.cpp:36,Testability,log,logic,36,// An unsigned 12-bit constant (for logic instructions).,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Basic/Targets/LoongArch.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/Targets/LoongArch.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/Targets/Mips.h:17,Performance,load,loadable,17,"// Constants not loadable via lui, addiu, or ori",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Basic/Targets/Mips.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/Targets/Mips.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/Targets/Mips.h:46,Performance,load,load,46,// An address that can be used in a non-macro load or store,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Basic/Targets/Mips.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/Targets/Mips.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/Targets/Mips.h:14,Usability,usab,usable,14,"// An address usable by ll, and sc.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Basic/Targets/Mips.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/Targets/Mips.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/Targets/Mips.h:817,Safety,avoid,avoid,817,"// In GCC, $1 is not widely used in generated code (it's used only in a few; // specific situations), so there is no real need for users to add it to; // the clobbers list if they want to use it in their inline assembly code.; //; // In LLVM, $1 is treated as a normal GPR and is always allocatable during; // code generation, so using it in inline assembly without adding it to the; // clobbers list can cause conflicts between the inline assembly code and; // the surrounding generated code.; //; // Another problem is that LLVM is allowed to choose $1 for inline assembly; // operands, which will conflict with the "".set at"" assembler option (which; // we use only for inline assembly, in order to maintain compatibility with; // GCC) and will also conflict with the user's usage of $1.; //; // The easiest way to avoid these conflicts and keep $1 as an allocatable; // register for generated code is to automatically clobber $1 for all inline; // assembly code.; //; // FIXME: We should automatically clobber $1 only for inline assembly code; // which actually uses it. This would allow LLVM to use $1 for inline; // assembly operands if the user's assembly code doesn't use it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Basic/Targets/Mips.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/Targets/Mips.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/Targets/NVPTX.cpp:20,Availability,avail,available,20,// __bf16 is always available as a load/store only type.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Basic/Targets/NVPTX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/Targets/NVPTX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/Targets/NVPTX.cpp:35,Performance,load,load,35,// __bf16 is always available as a load/store only type.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Basic/Targets/NVPTX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/Targets/NVPTX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/Targets/NVPTX.cpp:10,Availability,avail,available,10,// Define available target features; // These must be defined in sorted order!,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Basic/Targets/NVPTX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/Targets/NVPTX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/Targets/NVPTX.h:108,Integrability,interoperab,interoperability,108,/// The DWARF address class. Taken from; /// https://docs.nvidia.com/cuda/archive/10.0/ptx-writers-guide-to-interoperability/index.html#cuda-specific-dwarf,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Basic/Targets/NVPTX.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/Targets/NVPTX.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/Targets/NVPTX.h:99,Usability,guid,guide-to-interoperability,99,/// The DWARF address class. Taken from; /// https://docs.nvidia.com/cuda/archive/10.0/ptx-writers-guide-to-interoperability/index.html#cuda-specific-dwarf,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Basic/Targets/NVPTX.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/Targets/NVPTX.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/Targets/OSTargets.cpp:12,Integrability,contract,contract,12,"// ""The /fp:contract option allows the compiler to generate floating-point; // contractions [...]""",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Basic/Targets/OSTargets.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/Targets/OSTargets.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/Targets/OSTargets.cpp:79,Integrability,contract,contractions,79,"// ""The /fp:contract option allows the compiler to generate floating-point; // contractions [...]""",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Basic/Targets/OSTargets.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/Targets/OSTargets.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/Targets/OSTargets.cpp:110,Performance,optimiz,optimize,110,"// ""The /fp:fast option allows the compiler to reorder, combine, or simplify; // floating-point operations to optimize floating-point code for speed and; // space. The compiler may omit rounding at assignment statements,; // typecasts, or function calls. It may reorder operations or make algebraic; // transforms, for example, by use of associative and distributive laws. It; // may reorder code even if such transformations result in observably; // different rounding behavior.""; //; // ""Under /fp:precise and /fp:strict, the compiler doesn't do any mathematical; // transformation unless the transformation is guaranteed to produce a bitwise; // identical result.""",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Basic/Targets/OSTargets.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/Targets/OSTargets.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/Targets/OSTargets.cpp:68,Usability,simpl,simplify,68,"// ""The /fp:fast option allows the compiler to reorder, combine, or simplify; // floating-point operations to optimize floating-point code for speed and; // space. The compiler may omit rounding at assignment statements,; // typecasts, or function calls. It may reorder operations or make algebraic; // transforms, for example, by use of associative and distributive laws. It; // may reorder code even if such transformations result in observably; // different rounding behavior.""; //; // ""Under /fp:precise and /fp:strict, the compiler doesn't do any mathematical; // transformation unless the transformation is guaranteed to produce a bitwise; // identical result.""",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Basic/Targets/OSTargets.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/Targets/OSTargets.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/Targets/OSTargets.cpp:81,Safety,safe,safely,81,"// ""Under /fp:strict, the compiler generates code that allows the; // program to safely unmask floating-point exceptions, read or write; // floating-point status registers, or change rounding modes.""",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Basic/Targets/OSTargets.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/Targets/OSTargets.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/Targets/OSTargets.cpp:8,Deployability,update,update,8,// TODO update to the proper value.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Basic/Targets/OSTargets.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/Targets/OSTargets.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/Targets/OSTargets.h:294,Integrability,depend,dependent,294,"// On FreeBSD, wchar_t contains the number of the code point as; // used by the character set of the locale. These character sets are; // not necessarily a superset of ASCII.; //; // FIXME: This is wrong; the macro refers to the numerical values; // of wchar_t *literals*, which are not locale-dependent. However,; // FreeBSD systems apparently depend on us getting this wrong, and; // setting this to 1 is conforming even if all the basic source; // character literals have the same encoding as char and wchar_t.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Basic/Targets/OSTargets.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/Targets/OSTargets.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/Targets/OSTargets.h:345,Integrability,depend,depend,345,"// On FreeBSD, wchar_t contains the number of the code point as; // used by the character set of the locale. These character sets are; // not necessarily a superset of ASCII.; //; // FIXME: This is wrong; the macro refers to the numerical values; // of wchar_t *literals*, which are not locale-dependent. However,; // FreeBSD systems apparently depend on us getting this wrong, and; // setting this to 1 is conforming even if all the basic source; // character literals have the same encoding as char and wchar_t.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Basic/Targets/OSTargets.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/Targets/OSTargets.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/Targets/OSTargets.h:19,Modifiability,variab,variable,19,"// On PS4/PS5, TLS variable cannot be aligned to more than 32 bytes (256; // bits).",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Basic/Targets/OSTargets.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/Targets/OSTargets.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/Targets/OSTargets.h:46,Testability,log,logic,46,// Define AIX OS-Version Macros.; // Includes logic for legacy versions of AIX; no specific intent to support.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Basic/Targets/OSTargets.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/Targets/OSTargets.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/Targets/OSTargets.h:17,Modifiability,inherit,inherited,17,// RegParmMax is inherited from the underlying architecture.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Basic/Targets/OSTargets.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/Targets/OSTargets.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/Targets/PPC.cpp:73,Modifiability,config,configured,73,/// handleTargetFeatures - Perform initialization based on the user; /// configured set of features.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Basic/Targets/PPC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/Targets/PPC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/Targets/PPC.cpp:27,Performance,Perform,Perform,27,/// handleTargetFeatures - Perform initialization based on the user; /// configured set of features.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Basic/Targets/PPC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/Targets/PPC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/Targets/PPC.cpp:37,Testability,assert,assert,37,// TODO: Finish this list and add an assert that we've handled them; // all.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Basic/Targets/PPC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/Targets/PPC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/Targets/PPC.cpp:58,Energy Efficiency,Power,PowerPC-specific,58,/// PPCTargetInfo::getTargetDefines - Return a set of the PowerPC-specific; /// #defines that are not tied to a specific subtarget.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Basic/Targets/PPC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/Targets/PPC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/Targets/PPC.cpp:88,Availability,avail,available,88,// We define the XLC compatibility macros only on AIX and Linux since XLC; // was never available on any other platforms.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Basic/Targets/PPC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/Targets/PPC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/Targets/PPC.cpp:276,Availability,error,error,276,// Handle explicit options being passed to the compiler here: if we've; // explicitly turned off vsx and turned on any of:; // - power8-vector; // - direct-move; // - float128; // - power9-vector; // - paired-vector-memops; // - mma; // - power10-vector; // then go ahead and error since the customer has expressed an incompatible; // set of options.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Basic/Targets/PPC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/Targets/PPC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/Targets/PPC.cpp:52,Energy Efficiency,Power,Power,52,// Future CPU should include all of the features of Power 10 as well as any; // additional features (yet to be determined) specific to it.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Basic/Targets/PPC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/Targets/PPC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/Targets/PPC.cpp:26,Availability,avail,available,26,// MMA operations are not available pre-Power10.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Basic/Targets/PPC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/Targets/PPC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/Targets/PPC.cpp:36,Availability,avail,available,36,"// PC-Relative instructions are not available pre-Power10,; // and these instructions also require prefixed instructions support.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Basic/Targets/PPC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/Targets/PPC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/Targets/PPC.cpp:33,Availability,avail,available,33,// Prefixed instructions are not available pre-Power10.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Basic/Targets/PPC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/Targets/PPC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/Targets/PPC.cpp:32,Availability,avail,available,32,// Paired vector memops are not available pre-Power10.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Basic/Targets/PPC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/Targets/PPC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/Targets/PPC.cpp:33,Energy Efficiency,Power,Power,33,// We can turn on ROP Protect on Power 8 and above.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Basic/Targets/PPC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/Targets/PPC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/Targets/PPC.cpp:209,Energy Efficiency,power,powerpc,209,"// PPC ELFABIv2 DWARF Definition ""Table 2.26. Mappings of Common Registers"".; // vs0 ~ vs31 is mapping to 32 - 63,; // vs32 ~ vs63 is mapping to 77 - 108.; // And this mapping applies to all OSes which run on powerpc.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Basic/Targets/PPC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/Targets/PPC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/Targets/PPC.h:9,Energy Efficiency,power,power,9,// Exact power of 2,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Basic/Targets/PPC.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/Targets/PPC.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/Targets/PPC.h:39,Performance,load,loaded,39,// Floating point constant that can be loaded into a; // register with one instruction per word,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Basic/Targets/PPC.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/Targets/PPC.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/Targets/PPC.h:47,Performance,load,loaded,47,// Integer/Floating point constant that can be loaded; // into a register using three instructions,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Basic/Targets/PPC.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/Targets/PPC.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/Targets/PPC.h:82,Deployability,update,update,82,"// Memory operand. Note that on PowerPC targets, m can; // include addresses that update the base register. It; // is therefore only safe to use `m' in an asm statement; // if that asm statement accesses the operand exactly once.; // The asm statement must also use `%U<opno>' as a; // placeholder for the ""update"" flag in the corresponding; // load or store instruction. For example:; // asm (""st%U0 %1,%0"" : ""=m"" (mem) : ""r"" (val));; // is correct but:; // asm (""st %1,%0"" : ""=m"" (mem) : ""r"" (val));; // is not. Use es rather than m if you don't want the base; // register to be updated.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Basic/Targets/PPC.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/Targets/PPC.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/Targets/PPC.h:307,Deployability,update,update,307,"// Memory operand. Note that on PowerPC targets, m can; // include addresses that update the base register. It; // is therefore only safe to use `m' in an asm statement; // if that asm statement accesses the operand exactly once.; // The asm statement must also use `%U<opno>' as a; // placeholder for the ""update"" flag in the corresponding; // load or store instruction. For example:; // asm (""st%U0 %1,%0"" : ""=m"" (mem) : ""r"" (val));; // is correct but:; // asm (""st %1,%0"" : ""=m"" (mem) : ""r"" (val));; // is not. Use es rather than m if you don't want the base; // register to be updated.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Basic/Targets/PPC.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/Targets/PPC.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/Targets/PPC.h:581,Deployability,update,updated,581,"// Memory operand. Note that on PowerPC targets, m can; // include addresses that update the base register. It; // is therefore only safe to use `m' in an asm statement; // if that asm statement accesses the operand exactly once.; // The asm statement must also use `%U<opno>' as a; // placeholder for the ""update"" flag in the corresponding; // load or store instruction. For example:; // asm (""st%U0 %1,%0"" : ""=m"" (mem) : ""r"" (val));; // is correct but:; // asm (""st %1,%0"" : ""=m"" (mem) : ""r"" (val));; // is not. Use es rather than m if you don't want the base; // register to be updated.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Basic/Targets/PPC.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/Targets/PPC.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/Targets/PPC.h:32,Energy Efficiency,Power,PowerPC,32,"// Memory operand. Note that on PowerPC targets, m can; // include addresses that update the base register. It; // is therefore only safe to use `m' in an asm statement; // if that asm statement accesses the operand exactly once.; // The asm statement must also use `%U<opno>' as a; // placeholder for the ""update"" flag in the corresponding; // load or store instruction. For example:; // asm (""st%U0 %1,%0"" : ""=m"" (mem) : ""r"" (val));; // is correct but:; // asm (""st %1,%0"" : ""=m"" (mem) : ""r"" (val));; // is not. Use es rather than m if you don't want the base; // register to be updated.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Basic/Targets/PPC.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/Targets/PPC.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/Targets/PPC.h:345,Performance,load,load,345,"// Memory operand. Note that on PowerPC targets, m can; // include addresses that update the base register. It; // is therefore only safe to use `m' in an asm statement; // if that asm statement accesses the operand exactly once.; // The asm statement must also use `%U<opno>' as a; // placeholder for the ""update"" flag in the corresponding; // load or store instruction. For example:; // asm (""st%U0 %1,%0"" : ""=m"" (mem) : ""r"" (val));; // is correct but:; // asm (""st %1,%0"" : ""=m"" (mem) : ""r"" (val));; // is not. Use es rather than m if you don't want the base; // register to be updated.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Basic/Targets/PPC.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/Targets/PPC.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/Targets/PPC.h:133,Safety,safe,safe,133,"// Memory operand. Note that on PowerPC targets, m can; // include addresses that update the base register. It; // is therefore only safe to use `m' in an asm statement; // if that asm statement accesses the operand exactly once.; // The asm statement must also use `%U<opno>' as a; // placeholder for the ""update"" flag in the corresponding; // load or store instruction. For example:; // asm (""st%U0 %1,%0"" : ""=m"" (mem) : ""r"" (val));; // is correct but:; // asm (""st %1,%0"" : ""=m"" (mem) : ""r"" (val));; // is not. Use es rather than m if you don't want the base; // register to be updated.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Basic/Targets/PPC.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/Targets/PPC.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/Targets/PPC.h:195,Security,access,accesses,195,"// Memory operand. Note that on PowerPC targets, m can; // include addresses that update the base register. It; // is therefore only safe to use `m' in an asm statement; // if that asm statement accesses the operand exactly once.; // The asm statement must also use `%U<opno>' as a; // placeholder for the ""update"" flag in the corresponding; // load or store instruction. For example:; // asm (""st%U0 %1,%0"" : ""=m"" (mem) : ""r"" (val));; // is correct but:; // asm (""st %1,%0"" : ""=m"" (mem) : ""r"" (val));; // is not. Use es rather than m if you don't want the base; // register to be updated.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Basic/Targets/PPC.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/Targets/PPC.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/Targets/PPC.h:194,Security,access,access,194,"// es: A ""stable"" memory operand; that is, one which does not; // include any automodification of the base register. Unlike; // `m', this constraint can be used in asm statements that; // might access the operand several times, or that might not; // access it at all.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Basic/Targets/PPC.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/Targets/PPC.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/Targets/PPC.h:250,Security,access,access,250,"// es: A ""stable"" memory operand; that is, one which does not; // include any automodification of the base register. Unlike; // `m', this constraint can be used in asm statements that; // might access the operand several times, or that might not; // access it at all.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Basic/Targets/PPC.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/Targets/PPC.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/Targets/PPC.h:33,Availability,mask,mask,33,// Constant suitable as a 64-bit mask operand,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Basic/Targets/PPC.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/Targets/PPC.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/Targets/PPC.h:33,Availability,mask,mask,33,// Constant suitable as a 32-bit mask operand,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Basic/Targets/PPC.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/Targets/PPC.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/Targets/PPC.h:12,Deployability,Release,Release,12,// System V Release 4 small data area reference,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Basic/Targets/PPC.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/Targets/PPC.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/Targets/PPC.h:7,Availability,mask,masks,7,"// AND masks that can be performed by two rldic{l, r}; // instructions",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Basic/Targets/PPC.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/Targets/PPC.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/Targets/PPC.h:25,Performance,perform,performed,25,"// AND masks that can be performed by two rldic{l, r}; // instructions",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Basic/Targets/PPC.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/Targets/PPC.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/Targets/RISCV.cpp:38,Security,access,access,38,// A 5-bit unsigned immediate for CSR access instructions.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Basic/Targets/RISCV.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/Targets/RISCV.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/Targets/RISCV.cpp:45,Modifiability,config,configured,45,/// Perform initialization based on the user configured set of features.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Basic/Targets/RISCV.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/Targets/RISCV.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/Targets/RISCV.cpp:4,Performance,Perform,Perform,4,/// Perform initialization based on the user configured set of features.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Basic/Targets/RISCV.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/Targets/RISCV.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/Targets/RISCV.cpp:3,Deployability,Update,Update,3,// Update Features with CPU's features,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Basic/Targets/RISCV.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/Targets/RISCV.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/Targets/Sparc.h:40,Usability,clear,clear,40,// 32-bit constant with the low 12 bits clear,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Basic/Targets/Sparc.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/Targets/Sparc.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/Targets/SPIR.h:10,Availability,avail,available,10,// Define available target features; // These must be defined in sorted order!,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Basic/Targets/SPIR.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/Targets/SPIR.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/Targets/SystemZ.h:102,Availability,avail,available,102,"// All vector types are default aligned on an 8-byte boundary, even if the; // vector facility is not available. That is different from Linux.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Basic/Targets/SystemZ.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/Targets/SystemZ.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/Targets/TCE.h:343,Availability,avail,available,343,"// llvm and clang cannot be used directly to output native binaries for; // target, but is used to compile C code to llvm bitcode with correct; // type and alignment information.; //; // TCE uses the llvm bitcode as input and uses it for generating customized; // target processor and program binary. TCE co-design environment is; // publicly available in http://tce.cs.tut.fi",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Basic/Targets/TCE.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/Targets/TCE.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/Targets/X86.cpp:128,Integrability,depend,depend,128,// Can't do this earlier because we need to be able to explicitly enable; // or disable these features and the things that they depend upon.; // Enable popcnt if sse4.2 is enabled and popcnt is not explicitly disabled.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Basic/Targets/X86.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/Targets/X86.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/Targets/X86.cpp:73,Modifiability,config,configured,73,/// handleTargetFeatures - Perform initialization based on the user; /// configured set of features.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Basic/Targets/X86.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/Targets/X86.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/Targets/X86.cpp:27,Performance,Perform,Perform,27,/// handleTargetFeatures - Perform initialization based on the user; /// configured set of features.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Basic/Targets/X86.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/Targets/X86.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/Targets/X86.cpp:370,Availability,avail,available,370,"// X86 target has bfloat16 emulation support in the backend, where; // bfloat16 is treated as a 32-bit float, arithmetic operations are; // performed in 32-bit, and the result is converted back to bfloat16.; // Truncation and extension between bfloat16 and 32-bit float are supported; // by the compiler-rt library. However, native bfloat16 support is currently; // not available in the X86 target. Hence, HasFullBFloat16 will be false; // until native bfloat16 support is available. HasFullBFloat16 is used to; // determine whether to automatically use excess floating point precision; // for bfloat16 arithmetic operations in the front-end.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Basic/Targets/X86.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/Targets/X86.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/Targets/X86.cpp:473,Availability,avail,available,473,"// X86 target has bfloat16 emulation support in the backend, where; // bfloat16 is treated as a 32-bit float, arithmetic operations are; // performed in 32-bit, and the result is converted back to bfloat16.; // Truncation and extension between bfloat16 and 32-bit float are supported; // by the compiler-rt library. However, native bfloat16 support is currently; // not available in the X86 target. Hence, HasFullBFloat16 will be false; // until native bfloat16 support is available. HasFullBFloat16 is used to; // determine whether to automatically use excess floating point precision; // for bfloat16 arithmetic operations in the front-end.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Basic/Targets/X86.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/Targets/X86.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/Targets/X86.cpp:140,Performance,perform,performed,140,"// X86 target has bfloat16 emulation support in the backend, where; // bfloat16 is treated as a 32-bit float, arithmetic operations are; // performed in 32-bit, and the result is converted back to bfloat16.; // Truncation and extension between bfloat16 and 32-bit float are supported; // by the compiler-rt library. However, native bfloat16 support is currently; // not available in the X86 target. Hence, HasFullBFloat16 will be false; // until native bfloat16 support is available. HasFullBFloat16 is used to; // determine whether to automatically use excess floating point precision; // for bfloat16 arithmetic operations in the front-end.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Basic/Targets/X86.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/Targets/X86.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/Targets/X86.cpp:56,Performance,tune,tune,56,"// Subtarget options.; // FIXME: We are hard-coding the tune parameters based on the CPU, but they; // truly should be based on -mtune options.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Basic/Targets/X86.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/Targets/X86.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/Targets/X86.cpp:114,Security,expose,exposed,114,"// FIXME: Historically, we defined this legacy name, it would be nice to; // remove it at some point. We've never exposed fine-grained names for; // recent primary x86 CPUs, and we should keep it that way.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Basic/Targets/X86.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/Targets/X86.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/Targets/X86.cpp:26,Security,validat,validation,26,// We can't use a generic validation scheme for the features accepted here; // versus subtarget features accepted in the target attribute because the; // bitfield structure that's initialized in the runtime only supports the; // below currently rather than the full range of subtarget features. (See; // X86TargetInfo::hasFeature for a somewhat comprehensive list).,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Basic/Targets/X86.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/Targets/X86.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/Targets/X86.cpp:90,Testability,assert,asserts,90,"// Note, this function should only be used after ensuring the value is; // correct, so it asserts if the value is out of range.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Basic/Targets/X86.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/Targets/X86.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/Targets/X86.cpp:146,Modifiability,variab,variables,146,// We can't use a generic validation scheme for the cpus accepted here; // versus subtarget cpus accepted in the target attribute because the; // variables intitialized by the runtime only support the below currently; // rather than the full range of cpus.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Basic/Targets/X86.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/Targets/X86.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/Targets/X86.cpp:26,Security,validat,validation,26,// We can't use a generic validation scheme for the cpus accepted here; // versus subtarget cpus accepted in the target attribute because the; // variables intitialized by the runtime only support the below currently; // rather than the full range of cpus.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Basic/Targets/X86.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/Targets/X86.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/Targets/X86.cpp:52,Modifiability,extend,extending,52,// 32-bit signed integer constant for use with sign-extending x86_64; // instructions.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Basic/Targets/X86.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/Targets/X86.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/Targets/X86.cpp:54,Modifiability,extend,extending,54,// 32-bit unsigned integer constant for use with zero-extending; // x86_64 instructions.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Basic/Targets/X86.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/Targets/X86.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/Targets/X86.cpp:15,Availability,mask,mask,15,// AVX512 arch mask registers: k1-k7.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Basic/Targets/X86.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/Targets/X86.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/Targets/X86.cpp:16,Security,access,accessible,16,"// Any register accessible as [r]l: a, b, c, and d.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Basic/Targets/X86.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/Targets/X86.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/Targets/X86.cpp:42,Integrability,depend,dependent,42,"// Any {X,Y,Z}MM register (Arch & context dependent)",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Basic/Targets/X86.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/Targets/X86.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/Targets/X86.cpp:14,Availability,mask,mask,14,"// Any AVX512 mask register (same as Yk, additionally allows k0; // for intermideate k reg operations).",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Basic/Targets/X86.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/Targets/X86.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/Targets/X86.cpp:16,Security,access,accessible,16,"// Any register accessible as [r]h: a, b, c, and d.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Basic/Targets/X86.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/Targets/X86.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/Targets/X86.cpp:99,Security,access,access,99,"// ""Index"" registers: any general register that can be used as an; // index in a base+index memory access.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Basic/Targets/X86.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/Targets/X86.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/Targets/X86.cpp:927,Availability,down,download,927,"// Below is based on the following information:; // +------------------------------------+-------------------------+--------------------------------------------------------------------------------------------------------------------------------------------------------------+; // | Processor Name | Cache Line Size (Bytes) | Source |; // +------------------------------------+-------------------------+--------------------------------------------------------------------------------------------------------------------------------------------------------------+; // | i386 | 64 | https://www.intel.com/content/dam/www/public/us/en/documents/manuals/64-ia-32-architectures-optimization-manual.pdf |; // | i486 | 16 | ""four doublewords"" (doubleword = 32 bits, 4 bits * 32 bits = 16 bytes) https://en.wikichip.org/w/images/d/d3/i486_MICROPROCESSOR_HARDWARE_REFERENCE_MANUAL_%281990%29.pdf and http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.126.4216&rep=rep1&type=pdf (page 29) |; // | i586/Pentium MMX | 32 | https://www.7-cpu.com/cpu/P-MMX.html |; // | i686/Pentium | 32 | https://www.7-cpu.com/cpu/P6.html |; // | Netburst/Pentium4 | 64 | https://www.7-cpu.com/cpu/P4-180.html |; // | Atom | 64 | https://www.7-cpu.com/cpu/Atom.html |; // | Westmere | 64 | https://en.wikichip.org/wiki/intel/microarchitectures/sandy_bridge_(client) ""Cache Architecture"" |; // | Sandy Bridge | 64 | https://en.wikipedia.org/wiki/Sandy_Bridge and https://www.7-cpu.com/cpu/SandyBridge.html |; // | Ivy Bridge | 64 | https://blog.stuffedcow.net/2013/01/ivb-cache-replacement/ and https://www.7-cpu.com/cpu/IvyBridge.html |; // | Haswell | 64 | https://www.7-cpu.com/cpu/Haswell.html |; // | Broadwell | 64 | https://www.7-cpu.com/cpu/Broadwell.html |; // | Skylake (including skylake-avx512) | 64 | https://www.nas.nasa.gov/hecc/support/kb/skylake-processors_550.html ""Cache Hierarchy"" |; // | Cascade Lake | 64 | https://www.nas.nasa.gov/hecc/support/kb/cascade-lake-processors_579.html ""Cache Hierarchy"" |; //",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Basic/Targets/X86.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/Targets/X86.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/Targets/X86.cpp:1377,Integrability,Bridg,Bridge,1377,"-------------------------------+-------------------------+--------------------------------------------------------------------------------------------------------------------------------------------------------------+; // | i386 | 64 | https://www.intel.com/content/dam/www/public/us/en/documents/manuals/64-ia-32-architectures-optimization-manual.pdf |; // | i486 | 16 | ""four doublewords"" (doubleword = 32 bits, 4 bits * 32 bits = 16 bytes) https://en.wikichip.org/w/images/d/d3/i486_MICROPROCESSOR_HARDWARE_REFERENCE_MANUAL_%281990%29.pdf and http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.126.4216&rep=rep1&type=pdf (page 29) |; // | i586/Pentium MMX | 32 | https://www.7-cpu.com/cpu/P-MMX.html |; // | i686/Pentium | 32 | https://www.7-cpu.com/cpu/P6.html |; // | Netburst/Pentium4 | 64 | https://www.7-cpu.com/cpu/P4-180.html |; // | Atom | 64 | https://www.7-cpu.com/cpu/Atom.html |; // | Westmere | 64 | https://en.wikichip.org/wiki/intel/microarchitectures/sandy_bridge_(client) ""Cache Architecture"" |; // | Sandy Bridge | 64 | https://en.wikipedia.org/wiki/Sandy_Bridge and https://www.7-cpu.com/cpu/SandyBridge.html |; // | Ivy Bridge | 64 | https://blog.stuffedcow.net/2013/01/ivb-cache-replacement/ and https://www.7-cpu.com/cpu/IvyBridge.html |; // | Haswell | 64 | https://www.7-cpu.com/cpu/Haswell.html |; // | Broadwell | 64 | https://www.7-cpu.com/cpu/Broadwell.html |; // | Skylake (including skylake-avx512) | 64 | https://www.nas.nasa.gov/hecc/support/kb/skylake-processors_550.html ""Cache Hierarchy"" |; // | Cascade Lake | 64 | https://www.nas.nasa.gov/hecc/support/kb/cascade-lake-processors_579.html ""Cache Hierarchy"" |; // | Skylake | 64 | https://en.wikichip.org/wiki/intel/microarchitectures/kaby_lake ""Memory Hierarchy"" |; // | Ice Lake | 64 | https://www.7-cpu.com/cpu/Ice_Lake.html |; // | Knights Landing | 64 | https://software.intel.com/en-us/articles/intel-xeon-phi-processor-7200-family-memory-management-optimizations ""The Intel® Xeon Phi™ Processor Arch",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Basic/Targets/X86.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/Targets/X86.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/Targets/X86.cpp:1493,Integrability,Bridg,Bridge,1493,"--------------------------------------------------------------+; // | i386 | 64 | https://www.intel.com/content/dam/www/public/us/en/documents/manuals/64-ia-32-architectures-optimization-manual.pdf |; // | i486 | 16 | ""four doublewords"" (doubleword = 32 bits, 4 bits * 32 bits = 16 bytes) https://en.wikichip.org/w/images/d/d3/i486_MICROPROCESSOR_HARDWARE_REFERENCE_MANUAL_%281990%29.pdf and http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.126.4216&rep=rep1&type=pdf (page 29) |; // | i586/Pentium MMX | 32 | https://www.7-cpu.com/cpu/P-MMX.html |; // | i686/Pentium | 32 | https://www.7-cpu.com/cpu/P6.html |; // | Netburst/Pentium4 | 64 | https://www.7-cpu.com/cpu/P4-180.html |; // | Atom | 64 | https://www.7-cpu.com/cpu/Atom.html |; // | Westmere | 64 | https://en.wikichip.org/wiki/intel/microarchitectures/sandy_bridge_(client) ""Cache Architecture"" |; // | Sandy Bridge | 64 | https://en.wikipedia.org/wiki/Sandy_Bridge and https://www.7-cpu.com/cpu/SandyBridge.html |; // | Ivy Bridge | 64 | https://blog.stuffedcow.net/2013/01/ivb-cache-replacement/ and https://www.7-cpu.com/cpu/IvyBridge.html |; // | Haswell | 64 | https://www.7-cpu.com/cpu/Haswell.html |; // | Broadwell | 64 | https://www.7-cpu.com/cpu/Broadwell.html |; // | Skylake (including skylake-avx512) | 64 | https://www.nas.nasa.gov/hecc/support/kb/skylake-processors_550.html ""Cache Hierarchy"" |; // | Cascade Lake | 64 | https://www.nas.nasa.gov/hecc/support/kb/cascade-lake-processors_579.html ""Cache Hierarchy"" |; // | Skylake | 64 | https://en.wikichip.org/wiki/intel/microarchitectures/kaby_lake ""Memory Hierarchy"" |; // | Ice Lake | 64 | https://www.7-cpu.com/cpu/Ice_Lake.html |; // | Knights Landing | 64 | https://software.intel.com/en-us/articles/intel-xeon-phi-processor-7200-family-memory-management-optimizations ""The Intel® Xeon Phi™ Processor Architecture"" |; // | Knights Mill | 64 | https://software.intel.com/sites/default/files/managed/9e/bc/64-ia-32-architectures-optimization-manual.pdf?countryl",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Basic/Targets/X86.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/Targets/X86.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/Targets/X86.cpp:299,Performance,Cache,Cache,299,"// Below is based on the following information:; // +------------------------------------+-------------------------+--------------------------------------------------------------------------------------------------------------------------------------------------------------+; // | Processor Name | Cache Line Size (Bytes) | Source |; // +------------------------------------+-------------------------+--------------------------------------------------------------------------------------------------------------------------------------------------------------+; // | i386 | 64 | https://www.intel.com/content/dam/www/public/us/en/documents/manuals/64-ia-32-architectures-optimization-manual.pdf |; // | i486 | 16 | ""four doublewords"" (doubleword = 32 bits, 4 bits * 32 bits = 16 bytes) https://en.wikichip.org/w/images/d/d3/i486_MICROPROCESSOR_HARDWARE_REFERENCE_MANUAL_%281990%29.pdf and http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.126.4216&rep=rep1&type=pdf (page 29) |; // | i586/Pentium MMX | 32 | https://www.7-cpu.com/cpu/P-MMX.html |; // | i686/Pentium | 32 | https://www.7-cpu.com/cpu/P6.html |; // | Netburst/Pentium4 | 64 | https://www.7-cpu.com/cpu/P4-180.html |; // | Atom | 64 | https://www.7-cpu.com/cpu/Atom.html |; // | Westmere | 64 | https://en.wikichip.org/wiki/intel/microarchitectures/sandy_bridge_(client) ""Cache Architecture"" |; // | Sandy Bridge | 64 | https://en.wikipedia.org/wiki/Sandy_Bridge and https://www.7-cpu.com/cpu/SandyBridge.html |; // | Ivy Bridge | 64 | https://blog.stuffedcow.net/2013/01/ivb-cache-replacement/ and https://www.7-cpu.com/cpu/IvyBridge.html |; // | Haswell | 64 | https://www.7-cpu.com/cpu/Haswell.html |; // | Broadwell | 64 | https://www.7-cpu.com/cpu/Broadwell.html |; // | Skylake (including skylake-avx512) | 64 | https://www.nas.nasa.gov/hecc/support/kb/skylake-processors_550.html ""Cache Hierarchy"" |; // | Cascade Lake | 64 | https://www.nas.nasa.gov/hecc/support/kb/cascade-lake-processors_579.html ""Cache Hierarchy"" |; //",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Basic/Targets/X86.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/Targets/X86.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/Targets/X86.cpp:672,Performance,optimiz,optimization-manual,672,"// Below is based on the following information:; // +------------------------------------+-------------------------+--------------------------------------------------------------------------------------------------------------------------------------------------------------+; // | Processor Name | Cache Line Size (Bytes) | Source |; // +------------------------------------+-------------------------+--------------------------------------------------------------------------------------------------------------------------------------------------------------+; // | i386 | 64 | https://www.intel.com/content/dam/www/public/us/en/documents/manuals/64-ia-32-architectures-optimization-manual.pdf |; // | i486 | 16 | ""four doublewords"" (doubleword = 32 bits, 4 bits * 32 bits = 16 bytes) https://en.wikichip.org/w/images/d/d3/i486_MICROPROCESSOR_HARDWARE_REFERENCE_MANUAL_%281990%29.pdf and http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.126.4216&rep=rep1&type=pdf (page 29) |; // | i586/Pentium MMX | 32 | https://www.7-cpu.com/cpu/P-MMX.html |; // | i686/Pentium | 32 | https://www.7-cpu.com/cpu/P6.html |; // | Netburst/Pentium4 | 64 | https://www.7-cpu.com/cpu/P4-180.html |; // | Atom | 64 | https://www.7-cpu.com/cpu/Atom.html |; // | Westmere | 64 | https://en.wikichip.org/wiki/intel/microarchitectures/sandy_bridge_(client) ""Cache Architecture"" |; // | Sandy Bridge | 64 | https://en.wikipedia.org/wiki/Sandy_Bridge and https://www.7-cpu.com/cpu/SandyBridge.html |; // | Ivy Bridge | 64 | https://blog.stuffedcow.net/2013/01/ivb-cache-replacement/ and https://www.7-cpu.com/cpu/IvyBridge.html |; // | Haswell | 64 | https://www.7-cpu.com/cpu/Haswell.html |; // | Broadwell | 64 | https://www.7-cpu.com/cpu/Broadwell.html |; // | Skylake (including skylake-avx512) | 64 | https://www.nas.nasa.gov/hecc/support/kb/skylake-processors_550.html ""Cache Hierarchy"" |; // | Cascade Lake | 64 | https://www.nas.nasa.gov/hecc/support/kb/cascade-lake-processors_579.html ""Cache Hierarchy"" |; //",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Basic/Targets/X86.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/Targets/X86.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/Targets/X86.cpp:1343,Performance,Cache,Cache,1343,"-------------------------------+-------------------------+--------------------------------------------------------------------------------------------------------------------------------------------------------------+; // | i386 | 64 | https://www.intel.com/content/dam/www/public/us/en/documents/manuals/64-ia-32-architectures-optimization-manual.pdf |; // | i486 | 16 | ""four doublewords"" (doubleword = 32 bits, 4 bits * 32 bits = 16 bytes) https://en.wikichip.org/w/images/d/d3/i486_MICROPROCESSOR_HARDWARE_REFERENCE_MANUAL_%281990%29.pdf and http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.126.4216&rep=rep1&type=pdf (page 29) |; // | i586/Pentium MMX | 32 | https://www.7-cpu.com/cpu/P-MMX.html |; // | i686/Pentium | 32 | https://www.7-cpu.com/cpu/P6.html |; // | Netburst/Pentium4 | 64 | https://www.7-cpu.com/cpu/P4-180.html |; // | Atom | 64 | https://www.7-cpu.com/cpu/Atom.html |; // | Westmere | 64 | https://en.wikichip.org/wiki/intel/microarchitectures/sandy_bridge_(client) ""Cache Architecture"" |; // | Sandy Bridge | 64 | https://en.wikipedia.org/wiki/Sandy_Bridge and https://www.7-cpu.com/cpu/SandyBridge.html |; // | Ivy Bridge | 64 | https://blog.stuffedcow.net/2013/01/ivb-cache-replacement/ and https://www.7-cpu.com/cpu/IvyBridge.html |; // | Haswell | 64 | https://www.7-cpu.com/cpu/Haswell.html |; // | Broadwell | 64 | https://www.7-cpu.com/cpu/Broadwell.html |; // | Skylake (including skylake-avx512) | 64 | https://www.nas.nasa.gov/hecc/support/kb/skylake-processors_550.html ""Cache Hierarchy"" |; // | Cascade Lake | 64 | https://www.nas.nasa.gov/hecc/support/kb/cascade-lake-processors_579.html ""Cache Hierarchy"" |; // | Skylake | 64 | https://en.wikichip.org/wiki/intel/microarchitectures/kaby_lake ""Memory Hierarchy"" |; // | Ice Lake | 64 | https://www.7-cpu.com/cpu/Ice_Lake.html |; // | Knights Landing | 64 | https://software.intel.com/en-us/articles/intel-xeon-phi-processor-7200-family-memory-management-optimizations ""The Intel® Xeon Phi™ Processor Arch",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Basic/Targets/X86.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/Targets/X86.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/Targets/X86.cpp:1547,Performance,cache,cache-replacement,1547,"----+; // | i386 | 64 | https://www.intel.com/content/dam/www/public/us/en/documents/manuals/64-ia-32-architectures-optimization-manual.pdf |; // | i486 | 16 | ""four doublewords"" (doubleword = 32 bits, 4 bits * 32 bits = 16 bytes) https://en.wikichip.org/w/images/d/d3/i486_MICROPROCESSOR_HARDWARE_REFERENCE_MANUAL_%281990%29.pdf and http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.126.4216&rep=rep1&type=pdf (page 29) |; // | i586/Pentium MMX | 32 | https://www.7-cpu.com/cpu/P-MMX.html |; // | i686/Pentium | 32 | https://www.7-cpu.com/cpu/P6.html |; // | Netburst/Pentium4 | 64 | https://www.7-cpu.com/cpu/P4-180.html |; // | Atom | 64 | https://www.7-cpu.com/cpu/Atom.html |; // | Westmere | 64 | https://en.wikichip.org/wiki/intel/microarchitectures/sandy_bridge_(client) ""Cache Architecture"" |; // | Sandy Bridge | 64 | https://en.wikipedia.org/wiki/Sandy_Bridge and https://www.7-cpu.com/cpu/SandyBridge.html |; // | Ivy Bridge | 64 | https://blog.stuffedcow.net/2013/01/ivb-cache-replacement/ and https://www.7-cpu.com/cpu/IvyBridge.html |; // | Haswell | 64 | https://www.7-cpu.com/cpu/Haswell.html |; // | Broadwell | 64 | https://www.7-cpu.com/cpu/Broadwell.html |; // | Skylake (including skylake-avx512) | 64 | https://www.nas.nasa.gov/hecc/support/kb/skylake-processors_550.html ""Cache Hierarchy"" |; // | Cascade Lake | 64 | https://www.nas.nasa.gov/hecc/support/kb/cascade-lake-processors_579.html ""Cache Hierarchy"" |; // | Skylake | 64 | https://en.wikichip.org/wiki/intel/microarchitectures/kaby_lake ""Memory Hierarchy"" |; // | Ice Lake | 64 | https://www.7-cpu.com/cpu/Ice_Lake.html |; // | Knights Landing | 64 | https://software.intel.com/en-us/articles/intel-xeon-phi-processor-7200-family-memory-management-optimizations ""The Intel® Xeon Phi™ Processor Architecture"" |; // | Knights Mill | 64 | https://software.intel.com/sites/default/files/managed/9e/bc/64-ia-32-architectures-optimization-manual.pdf?countrylabel=Colombia ""2.5.5.2 L1 DCache "" |; // +-----------------",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Basic/Targets/X86.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/Targets/X86.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/Targets/X86.cpp:1859,Performance,Cache,Cache,1859,"ts * 32 bits = 16 bytes) https://en.wikichip.org/w/images/d/d3/i486_MICROPROCESSOR_HARDWARE_REFERENCE_MANUAL_%281990%29.pdf and http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.126.4216&rep=rep1&type=pdf (page 29) |; // | i586/Pentium MMX | 32 | https://www.7-cpu.com/cpu/P-MMX.html |; // | i686/Pentium | 32 | https://www.7-cpu.com/cpu/P6.html |; // | Netburst/Pentium4 | 64 | https://www.7-cpu.com/cpu/P4-180.html |; // | Atom | 64 | https://www.7-cpu.com/cpu/Atom.html |; // | Westmere | 64 | https://en.wikichip.org/wiki/intel/microarchitectures/sandy_bridge_(client) ""Cache Architecture"" |; // | Sandy Bridge | 64 | https://en.wikipedia.org/wiki/Sandy_Bridge and https://www.7-cpu.com/cpu/SandyBridge.html |; // | Ivy Bridge | 64 | https://blog.stuffedcow.net/2013/01/ivb-cache-replacement/ and https://www.7-cpu.com/cpu/IvyBridge.html |; // | Haswell | 64 | https://www.7-cpu.com/cpu/Haswell.html |; // | Broadwell | 64 | https://www.7-cpu.com/cpu/Broadwell.html |; // | Skylake (including skylake-avx512) | 64 | https://www.nas.nasa.gov/hecc/support/kb/skylake-processors_550.html ""Cache Hierarchy"" |; // | Cascade Lake | 64 | https://www.nas.nasa.gov/hecc/support/kb/cascade-lake-processors_579.html ""Cache Hierarchy"" |; // | Skylake | 64 | https://en.wikichip.org/wiki/intel/microarchitectures/kaby_lake ""Memory Hierarchy"" |; // | Ice Lake | 64 | https://www.7-cpu.com/cpu/Ice_Lake.html |; // | Knights Landing | 64 | https://software.intel.com/en-us/articles/intel-xeon-phi-processor-7200-family-memory-management-optimizations ""The Intel® Xeon Phi™ Processor Architecture"" |; // | Knights Mill | 64 | https://software.intel.com/sites/default/files/managed/9e/bc/64-ia-32-architectures-optimization-manual.pdf?countrylabel=Colombia ""2.5.5.2 L1 DCache "" |; // +------------------------------------+-------------------------+--------------------------------------------------------------------------------------------------------------------------------------------------------------+",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Basic/Targets/X86.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/Targets/X86.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/Targets/X86.cpp:1979,Performance,Cache,Cache,1979,"ts * 32 bits = 16 bytes) https://en.wikichip.org/w/images/d/d3/i486_MICROPROCESSOR_HARDWARE_REFERENCE_MANUAL_%281990%29.pdf and http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.126.4216&rep=rep1&type=pdf (page 29) |; // | i586/Pentium MMX | 32 | https://www.7-cpu.com/cpu/P-MMX.html |; // | i686/Pentium | 32 | https://www.7-cpu.com/cpu/P6.html |; // | Netburst/Pentium4 | 64 | https://www.7-cpu.com/cpu/P4-180.html |; // | Atom | 64 | https://www.7-cpu.com/cpu/Atom.html |; // | Westmere | 64 | https://en.wikichip.org/wiki/intel/microarchitectures/sandy_bridge_(client) ""Cache Architecture"" |; // | Sandy Bridge | 64 | https://en.wikipedia.org/wiki/Sandy_Bridge and https://www.7-cpu.com/cpu/SandyBridge.html |; // | Ivy Bridge | 64 | https://blog.stuffedcow.net/2013/01/ivb-cache-replacement/ and https://www.7-cpu.com/cpu/IvyBridge.html |; // | Haswell | 64 | https://www.7-cpu.com/cpu/Haswell.html |; // | Broadwell | 64 | https://www.7-cpu.com/cpu/Broadwell.html |; // | Skylake (including skylake-avx512) | 64 | https://www.nas.nasa.gov/hecc/support/kb/skylake-processors_550.html ""Cache Hierarchy"" |; // | Cascade Lake | 64 | https://www.nas.nasa.gov/hecc/support/kb/cascade-lake-processors_579.html ""Cache Hierarchy"" |; // | Skylake | 64 | https://en.wikichip.org/wiki/intel/microarchitectures/kaby_lake ""Memory Hierarchy"" |; // | Ice Lake | 64 | https://www.7-cpu.com/cpu/Ice_Lake.html |; // | Knights Landing | 64 | https://software.intel.com/en-us/articles/intel-xeon-phi-processor-7200-family-memory-management-optimizations ""The Intel® Xeon Phi™ Processor Architecture"" |; // | Knights Mill | 64 | https://software.intel.com/sites/default/files/managed/9e/bc/64-ia-32-architectures-optimization-manual.pdf?countrylabel=Colombia ""2.5.5.2 L1 DCache "" |; // +------------------------------------+-------------------------+--------------------------------------------------------------------------------------------------------------------------------------------------------------+",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Basic/Targets/X86.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/Targets/X86.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/Targets/X86.cpp:2294,Performance,optimiz,optimizations,2294,"ts * 32 bits = 16 bytes) https://en.wikichip.org/w/images/d/d3/i486_MICROPROCESSOR_HARDWARE_REFERENCE_MANUAL_%281990%29.pdf and http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.126.4216&rep=rep1&type=pdf (page 29) |; // | i586/Pentium MMX | 32 | https://www.7-cpu.com/cpu/P-MMX.html |; // | i686/Pentium | 32 | https://www.7-cpu.com/cpu/P6.html |; // | Netburst/Pentium4 | 64 | https://www.7-cpu.com/cpu/P4-180.html |; // | Atom | 64 | https://www.7-cpu.com/cpu/Atom.html |; // | Westmere | 64 | https://en.wikichip.org/wiki/intel/microarchitectures/sandy_bridge_(client) ""Cache Architecture"" |; // | Sandy Bridge | 64 | https://en.wikipedia.org/wiki/Sandy_Bridge and https://www.7-cpu.com/cpu/SandyBridge.html |; // | Ivy Bridge | 64 | https://blog.stuffedcow.net/2013/01/ivb-cache-replacement/ and https://www.7-cpu.com/cpu/IvyBridge.html |; // | Haswell | 64 | https://www.7-cpu.com/cpu/Haswell.html |; // | Broadwell | 64 | https://www.7-cpu.com/cpu/Broadwell.html |; // | Skylake (including skylake-avx512) | 64 | https://www.nas.nasa.gov/hecc/support/kb/skylake-processors_550.html ""Cache Hierarchy"" |; // | Cascade Lake | 64 | https://www.nas.nasa.gov/hecc/support/kb/cascade-lake-processors_579.html ""Cache Hierarchy"" |; // | Skylake | 64 | https://en.wikichip.org/wiki/intel/microarchitectures/kaby_lake ""Memory Hierarchy"" |; // | Ice Lake | 64 | https://www.7-cpu.com/cpu/Ice_Lake.html |; // | Knights Landing | 64 | https://software.intel.com/en-us/articles/intel-xeon-phi-processor-7200-family-memory-management-optimizations ""The Intel® Xeon Phi™ Processor Architecture"" |; // | Knights Mill | 64 | https://software.intel.com/sites/default/files/managed/9e/bc/64-ia-32-architectures-optimization-manual.pdf?countrylabel=Colombia ""2.5.5.2 L1 DCache "" |; // +------------------------------------+-------------------------+--------------------------------------------------------------------------------------------------------------------------------------------------------------+",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Basic/Targets/X86.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/Targets/X86.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/Targets/X86.cpp:2466,Performance,optimiz,optimization-manual,2466,"ts * 32 bits = 16 bytes) https://en.wikichip.org/w/images/d/d3/i486_MICROPROCESSOR_HARDWARE_REFERENCE_MANUAL_%281990%29.pdf and http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.126.4216&rep=rep1&type=pdf (page 29) |; // | i586/Pentium MMX | 32 | https://www.7-cpu.com/cpu/P-MMX.html |; // | i686/Pentium | 32 | https://www.7-cpu.com/cpu/P6.html |; // | Netburst/Pentium4 | 64 | https://www.7-cpu.com/cpu/P4-180.html |; // | Atom | 64 | https://www.7-cpu.com/cpu/Atom.html |; // | Westmere | 64 | https://en.wikichip.org/wiki/intel/microarchitectures/sandy_bridge_(client) ""Cache Architecture"" |; // | Sandy Bridge | 64 | https://en.wikipedia.org/wiki/Sandy_Bridge and https://www.7-cpu.com/cpu/SandyBridge.html |; // | Ivy Bridge | 64 | https://blog.stuffedcow.net/2013/01/ivb-cache-replacement/ and https://www.7-cpu.com/cpu/IvyBridge.html |; // | Haswell | 64 | https://www.7-cpu.com/cpu/Haswell.html |; // | Broadwell | 64 | https://www.7-cpu.com/cpu/Broadwell.html |; // | Skylake (including skylake-avx512) | 64 | https://www.nas.nasa.gov/hecc/support/kb/skylake-processors_550.html ""Cache Hierarchy"" |; // | Cascade Lake | 64 | https://www.nas.nasa.gov/hecc/support/kb/cascade-lake-processors_579.html ""Cache Hierarchy"" |; // | Skylake | 64 | https://en.wikichip.org/wiki/intel/microarchitectures/kaby_lake ""Memory Hierarchy"" |; // | Ice Lake | 64 | https://www.7-cpu.com/cpu/Ice_Lake.html |; // | Knights Landing | 64 | https://software.intel.com/en-us/articles/intel-xeon-phi-processor-7200-family-memory-management-optimizations ""The Intel® Xeon Phi™ Processor Architecture"" |; // | Knights Mill | 64 | https://software.intel.com/sites/default/files/managed/9e/bc/64-ia-32-architectures-optimization-manual.pdf?countrylabel=Colombia ""2.5.5.2 L1 DCache "" |; // +------------------------------------+-------------------------+--------------------------------------------------------------------------------------------------------------------------------------------------------------+",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Basic/Targets/X86.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/Targets/X86.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/Targets/X86.cpp:40,Performance,cache,cache,40,// The following currently have unknown cache line sizes (but they are probably all 64):; // Core,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Basic/Targets/X86.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/Targets/X86.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/Targets/X86.h:29,Availability,avail,available,29,// Make __builtin_ms_va_list available.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Basic/Targets/X86.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/Targets/X86.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/ABIInfo.cpp:17,Energy Efficiency,power,power-of-,17,"// If it's a non-power-of-2 vector, its size is already a power-of-2,; // so make sure to widen it explicitly.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/ABIInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/ABIInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/ABIInfo.cpp:58,Energy Efficiency,power,power-of-,58,"// If it's a non-power-of-2 vector, its size is already a power-of-2,; // so make sure to widen it explicitly.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/ABIInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/ABIInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/ABIInfo.h:39,Security,access,access,39,"//===----- ABIInfo.h - ABI information access & encapsulation ---*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/ABIInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/ABIInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/ABIInfo.h:57,Integrability,interface,interface,57,"// FIXME: All of this stuff should be part of the target interface; // somehow. It is currently here because it is not clear how to factor; // the targets to support this, since the Targets currently live in a; // layer below types n'stuff.; /// ABIInfo - Target specific hooks for defining how a type should be; /// passed or returned from functions.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/ABIInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/ABIInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/ABIInfo.h:119,Usability,clear,clear,119,"// FIXME: All of this stuff should be part of the target interface; // somehow. It is currently here because it is not clear how to factor; // the targets to support this, since the Targets currently live in a; // layer below types n'stuff.; /// ABIInfo - Target specific hooks for defining how a type should be; /// passed or returned from functions.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/ABIInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/ABIInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/ABIInfo.h:32,Integrability,depend,dependent,32,"/// EmitVAArg - Emit the target dependent code to load a value of; /// \arg Ty from the va_list pointed to by \arg VAListAddr.; // FIXME: This is a gaping layering violation if we wanted to drop; // the ABI information any lower than CodeGen. Of course, for; // VAArg handling it has to be at this level; there is no way to; // abstract this out.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/ABIInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/ABIInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/ABIInfo.h:50,Performance,load,load,50,"/// EmitVAArg - Emit the target dependent code to load a value of; /// \arg Ty from the va_list pointed to by \arg VAListAddr.; // FIXME: This is a gaping layering violation if we wanted to drop; // the ABI information any lower than CodeGen. Of course, for; // VAArg handling it has to be at this level; there is no way to; // abstract this out.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/ABIInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/ABIInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/ABIInfo.h:20,Integrability,depend,dependent,20,/// Emit the target dependent code to load a value of; /// \arg Ty from the \c __builtin_ms_va_list pointed to by \arg VAListAddr.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/ABIInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/ABIInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/ABIInfo.h:38,Performance,load,load,38,/// Emit the target dependent code to load a value of; /// \arg Ty from the \c __builtin_ms_va_list pointed to by \arg VAListAddr.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/ABIInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/ABIInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/ABIInfoImpl.h:311,Energy Efficiency,allocate,allocated,311,"/// Emit va_arg for a platform using the common void* representation,; /// where arguments are simply emitted in an array of slots on the stack.; ///; /// This version implements the core direct-value passing rules.; ///; /// \param SlotSize - The size and alignment of a stack slot.; /// Each argument will be allocated to a multiple of this number of; /// slots, and all the slots will be aligned to this value.; /// \param AllowHigherAlign - The slot alignment is not a cap;; /// an argument type with an alignment greater than the slot size; /// will be emitted on a higher-alignment address, potentially; /// leaving one or more empty slots behind as padding. If this; /// is false, the returned address might be less-aligned than; /// DirectAlign.; /// \param ForceRightAdjust - Default is false. On big-endian platform and; /// if the argument is smaller than a slot, set this flag will force; /// right-adjust the argument in its slot irrespective of the type.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/ABIInfoImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/ABIInfoImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/ABIInfoImpl.h:95,Usability,simpl,simply,95,"/// Emit va_arg for a platform using the common void* representation,; /// where arguments are simply emitted in an array of slots on the stack.; ///; /// This version implements the core direct-value passing rules.; ///; /// \param SlotSize - The size and alignment of a stack slot.; /// Each argument will be allocated to a multiple of this number of; /// slots, and all the slots will be aligned to this value.; /// \param AllowHigherAlign - The slot alignment is not a cap;; /// an argument type with an alignment greater than the slot size; /// will be emitted on a higher-alignment address, potentially; /// leaving one or more empty slots behind as padding. If this; /// is false, the returned address might be less-aligned than; /// DirectAlign.; /// \param ForceRightAdjust - Default is false. On big-endian platform and; /// if the argument is smaller than a slot, set this flag will force; /// right-adjust the argument in its slot irrespective of the type.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/ABIInfoImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/ABIInfoImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/ABIInfoImpl.h:448,Energy Efficiency,allocate,allocated,448,"/// Emit va_arg for a platform using the common void* representation,; /// where arguments are simply emitted in an array of slots on the stack.; ///; /// \param IsIndirect - Values of this type are passed indirectly.; /// \param ValueInfo - The size and alignment of this type, generally; /// computed with getContext().getTypeInfoInChars(ValueTy).; /// \param SlotSizeAndAlign - The size and alignment of a stack slot.; /// Each argument will be allocated to a multiple of this number of; /// slots, and all the slots will be aligned to this value.; /// \param AllowHigherAlign - The slot alignment is not a cap;; /// an argument type with an alignment greater than the slot size; /// will be emitted on a higher-alignment address, potentially; /// leaving one or more empty slots behind as padding.; /// \param ForceRightAdjust - Default is false. On big-endian platform and; /// if the argument is smaller than a slot, set this flag will force; /// right-adjust the argument in its slot irrespective of the type.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/ABIInfoImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/ABIInfoImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/ABIInfoImpl.h:95,Usability,simpl,simply,95,"/// Emit va_arg for a platform using the common void* representation,; /// where arguments are simply emitted in an array of slots on the stack.; ///; /// \param IsIndirect - Values of this type are passed indirectly.; /// \param ValueInfo - The size and alignment of this type, generally; /// computed with getContext().getTypeInfoInChars(ValueTy).; /// \param SlotSizeAndAlign - The size and alignment of a stack slot.; /// Each argument will be allocated to a multiple of this number of; /// slots, and all the slots will be aligned to this value.; /// \param AllowHigherAlign - The slot alignment is not a cap;; /// an argument type with an alignment greater than the slot size; /// will be emitted on a higher-alignment address, potentially; /// leaving one or more empty slots behind as padding.; /// \param ForceRightAdjust - Default is false. On big-endian platform and; /// if the argument is smaller than a slot, set this flag will force; /// right-adjust the argument in its slot irrespective of the type.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/ABIInfoImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/ABIInfoImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/ABIInfoImpl.h:110,Modifiability,flexible,flexible,110,"/// isEmptyRecord - Return true iff a structure contains only empty; /// fields. Note that a structure with a flexible array member is not; /// considered empty. If AsIfNoUniqueAddr is true, then C++ record fields are; /// considered empty if the [[no_unique_address]] attribute would have made; /// them empty.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/ABIInfoImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/ABIInfoImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/ABIInfoImpl.h:216,Modifiability,flexible,flexible,216,"/// isSingleElementStruct - Determine if a structure is a ""single; /// element struct"", i.e. it has exactly one non-empty field or; /// exactly one field which is itself a single element; /// struct. Structures with flexible array members are never; /// considered single element structs.; ///; /// \return The field declaration for the single non-empty field, if; /// it exists.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/ABIInfoImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/ABIInfoImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/Address.h:411,Integrability,wrap,wrapper,411,"//===-- Address.h - An aligned address -------------------------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This class provides a simple wrapper for a pair of a pointer and an; // alignment.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/Address.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/Address.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/Address.h:404,Usability,simpl,simple,404,"//===-- Address.h - An aligned address -------------------------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This class provides a simple wrapper for a pair of a pointer and an; // alignment.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/Address.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/Address.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/Address.h:39,Integrability,interface,interface,39,// Present a minimal LLVM-like casting interface.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/Address.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/Address.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/BackendConsumer.h:179,Modifiability,plugin,plugins,179,/// True if we've finished generating IR. This prevents us from generating; /// additional LLVM IR after emitting output in HandleTranslationUnit. This; /// can happen when Clang plugins trigger additional AST deserialization.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/BackendConsumer.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/BackendConsumer.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/BackendConsumer.h:463,Performance,optimiz,optimize,463,"// A map from mangled names to their function's source location, used for; // backend diagnostics as the Clang AST may be unavailable. We actually use; // the mangled name's hash as the key because mangled names can be very; // long and take up lots of space. Using a hash can cause name collision,; // but that is rare and the consequences are pointing to a wrong source; // location which is not severe. This is a vector instead of an actual map; // because we optimize for time building this map rather than time; // retrieving an entry, as backend diagnostics are uncommon.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/BackendConsumer.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/BackendConsumer.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/BackendConsumer.h:174,Security,hash,hash,174,"// A map from mangled names to their function's source location, used for; // backend diagnostics as the Clang AST may be unavailable. We actually use; // the mangled name's hash as the key because mangled names can be very; // long and take up lots of space. Using a hash can cause name collision,; // but that is rare and the consequences are pointing to a wrong source; // location which is not severe. This is a vector instead of an actual map; // because we optimize for time building this map rather than time; // retrieving an entry, as backend diagnostics are uncommon.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/BackendConsumer.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/BackendConsumer.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/BackendConsumer.h:268,Security,hash,hash,268,"// A map from mangled names to their function's source location, used for; // backend diagnostics as the Clang AST may be unavailable. We actually use; // the mangled name's hash as the key because mangled names can be very; // long and take up lots of space. Using a hash can cause name collision,; // but that is rare and the consequences are pointing to a wrong source; // location which is not severe. This is a vector instead of an actual map; // because we optimize for time building this map rather than time; // retrieving an entry, as backend diagnostics are uncommon.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/BackendConsumer.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/BackendConsumer.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/BackendConsumer.h:31,Deployability,install,installing,31,// This constructor is used in installing an empty BackendConsumer; // to use the clang diagnostic handler for IR input files. It avoids; // initializing the OS field.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/BackendConsumer.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/BackendConsumer.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/BackendConsumer.h:130,Safety,avoid,avoids,130,// This constructor is used in installing an empty BackendConsumer; // to use the clang diagnostic handler for IR input files. It avoids; // initializing the OS field.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/BackendConsumer.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/BackendConsumer.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/BackendConsumer.h:68,Availability,error,error,68,// Links each entry in LinkModules into our module. Returns true on error.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/BackendConsumer.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/BackendConsumer.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/BackendConsumer.h:29,Performance,optimiz,optimization,29,/// Specialized handlers for optimization remarks.; /// Note that these handlers only accept remarks and they always handle; /// them.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/BackendConsumer.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/BackendConsumer.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/BackendUtil.cpp:22,Security,sanitiz,sanitizers,22,// Experiment to move sanitizers earlier.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/BackendUtil.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/BackendUtil.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/BackendUtil.cpp:34,Performance,optimiz,optimization,34,// Re-link builtin bitcodes after optimization,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/BackendUtil.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/BackendUtil.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/BackendUtil.cpp:371,Availability,error,error,371,"/// Generates the TargetMachine.; /// Leaves TM unchanged if it is unable to create the target machine.; /// Some of our clang tests specify triples which are not built; /// into clang. This is okay because these tests check the generated; /// IR, and they require DataLayout which depends on the triple.; /// In this case, we allow this method to fail and not report an error.; /// When MustCreateTM is used, we print an error if we are unable to load; /// the requested target.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/BackendUtil.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/BackendUtil.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/BackendUtil.cpp:422,Availability,error,error,422,"/// Generates the TargetMachine.; /// Leaves TM unchanged if it is unable to create the target machine.; /// Some of our clang tests specify triples which are not built; /// into clang. This is okay because these tests check the generated; /// IR, and they require DataLayout which depends on the triple.; /// In this case, we allow this method to fail and not report an error.; /// When MustCreateTM is used, we print an error if we are unable to load; /// the requested target.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/BackendUtil.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/BackendUtil.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/BackendUtil.cpp:282,Integrability,depend,depends,282,"/// Generates the TargetMachine.; /// Leaves TM unchanged if it is unable to create the target machine.; /// Some of our clang tests specify triples which are not built; /// into clang. This is okay because these tests check the generated; /// IR, and they require DataLayout which depends on the triple.; /// In this case, we allow this method to fail and not report an error.; /// When MustCreateTM is used, we print an error if we are unable to load; /// the requested target.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/BackendUtil.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/BackendUtil.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/BackendUtil.cpp:448,Performance,load,load,448,"/// Generates the TargetMachine.; /// Leaves TM unchanged if it is unable to create the target machine.; /// Some of our clang tests specify triples which are not built; /// into clang. This is okay because these tests check the generated; /// IR, and they require DataLayout which depends on the triple.; /// In this case, we allow this method to fail and not report an error.; /// When MustCreateTM is used, we print an error if we are unable to load; /// the requested target.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/BackendUtil.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/BackendUtil.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/BackendUtil.cpp:127,Testability,test,tests,127,"/// Generates the TargetMachine.; /// Leaves TM unchanged if it is unable to create the target machine.; /// Some of our clang tests specify triples which are not built; /// into clang. This is okay because these tests check the generated; /// IR, and they require DataLayout which depends on the triple.; /// In this case, we allow this method to fail and not report an error.; /// When MustCreateTM is used, we print an error if we are unable to load; /// the requested target.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/BackendUtil.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/BackendUtil.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/BackendUtil.cpp:213,Testability,test,tests,213,"/// Generates the TargetMachine.; /// Leaves TM unchanged if it is unable to create the target machine.; /// Some of our clang tests specify triples which are not built; /// into clang. This is okay because these tests check the generated; /// IR, and they require DataLayout which depends on the triple.; /// In this case, we allow this method to fail and not report an error.; /// When MustCreateTM is used, we print an error if we are unable to load; /// the requested target.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/BackendUtil.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/BackendUtil.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/BackendUtil.cpp:63,Deployability,pipeline,pipeline,63,// Emit output using the new pass manager for the optimization pipeline.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/BackendUtil.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/BackendUtil.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/BackendUtil.cpp:50,Performance,optimiz,optimization,50,// Emit output using the new pass manager for the optimization pipeline.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/BackendUtil.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/BackendUtil.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/BackendUtil.cpp:267,Deployability,integrat,integrated-as,267,"// Check if ASan should use GC-friendly instrumentation for globals.; // First of all, there is no point if -fdata-sections is off (expect for MachO,; // where this is not a factor). Also, on ELF this feature requires an assembler; // extension that only works with -integrated-as at the moment.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/BackendUtil.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/BackendUtil.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/BackendUtil.cpp:267,Integrability,integrat,integrated-as,267,"// Check if ASan should use GC-friendly instrumentation for globals.; // First of all, there is no point if -fdata-sections is off (expect for MachO,; // where this is not a factor). Also, on ELF this feature requires an assembler; // extension that only works with -integrated-as at the moment.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/BackendUtil.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/BackendUtil.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/BackendUtil.cpp:16,Integrability,contract,contraction,16,// Preserve any contraction performed by the front-end. (Strict performs; // splitting of the muladd intrinsic in the backend.),MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/BackendUtil.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/BackendUtil.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/BackendUtil.cpp:28,Performance,perform,performed,28,// Preserve any contraction performed by the front-end. (Strict performs; // splitting of the muladd intrinsic in the backend.),MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/BackendUtil.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/BackendUtil.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/BackendUtil.cpp:64,Performance,perform,performs,64,// Preserve any contraction performed by the front-end. (Strict performs; // splitting of the muladd intrinsic in the backend.),MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/BackendUtil.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/BackendUtil.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/BackendUtil.cpp:52,Safety,avoid,avoid,52,// Not using 'GCOVOptions::getDefault' allows us to avoid exiting if; // LLVM's -default-gcov-version flag is set to something invalid.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/BackendUtil.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/BackendUtil.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/BackendUtil.cpp:135,Safety,avoid,avoid,135,"// Check for the default ""clang"" invocation that won't set any cl::opt values.; // Skip trying to parse the command line invocation to avoid the issues; // described below.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/BackendUtil.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/BackendUtil.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/BackendUtil.cpp:54,Safety,safe,safe,54,"// FIXME: The command line parser below is not thread-safe and shares a global; // state, so this call might crash or overwrite the options of another Clang; // instance in the same process.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/BackendUtil.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/BackendUtil.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/BackendUtil.cpp:113,Performance,optimiz,optimization,113,"// Normal mode, emit a .s or .o file by running the code generator. Note,; // this also adds codegenerator level optimization passes.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/BackendUtil.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/BackendUtil.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/BackendUtil.cpp:30,Performance,optimiz,optimizations,30,"// Add ObjC ARC final-cleanup optimizations. This is done as part of the; // ""codegen"" passes so that it isn't run multiple times when there is; // inlining happening.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/BackendUtil.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/BackendUtil.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/BackendUtil.cpp:8,Performance,optimiz,optimizations,8,"// When optimizations are requested, run KCIFPass after InstCombine to; // avoid unnecessary checks.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/BackendUtil.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/BackendUtil.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/BackendUtil.cpp:75,Safety,avoid,avoid,75,"// When optimizations are requested, run KCIFPass after InstCombine to; // avoid unnecessary checks.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/BackendUtil.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/BackendUtil.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/BackendUtil.cpp:196,Performance,optimiz,optimization,196,"// MemorySanitizer inserts complex instrumentation that mostly follows; // the logic of the original code, but operates on ""shadow"" values. It; // can benefit from re-running some general purpose optimization; // passes.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/BackendUtil.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/BackendUtil.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/BackendUtil.cpp:79,Testability,log,logic,79,"// MemorySanitizer inserts complex instrumentation that mostly follows; // the logic of the original code, but operates on ""shadow"" values. It; // can benefit from re-running some general purpose optimization; // passes.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/BackendUtil.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/BackendUtil.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/BackendUtil.cpp:3,Security,Sanitiz,Sanitizers,3,// Sanitizers can abandon<GlobalsAA>.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/BackendUtil.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/BackendUtil.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/BackendUtil.cpp:40,Deployability,integrat,integrated,40,"// Only enable CGProfilePass when using integrated assembler, since; // non-integrated assemblers don't recognize .cgprofile section.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/BackendUtil.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/BackendUtil.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/BackendUtil.cpp:76,Deployability,integrat,integrated,76,"// Only enable CGProfilePass when using integrated assembler, since; // non-integrated assemblers don't recognize .cgprofile section.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/BackendUtil.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/BackendUtil.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/BackendUtil.cpp:40,Integrability,integrat,integrated,40,"// Only enable CGProfilePass when using integrated assembler, since; // non-integrated assemblers don't recognize .cgprofile section.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/BackendUtil.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/BackendUtil.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/BackendUtil.cpp:76,Integrability,integrat,integrated,76,"// Only enable CGProfilePass when using integrated assembler, since; // non-integrated assemblers don't recognize .cgprofile section.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/BackendUtil.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/BackendUtil.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/BackendUtil.cpp:60,Performance,perform,performance,60,// Disable assignment tracking in LTO builds for now as the performance; // cost is too high. Disable for LLDB tuning due to llvm.org/PR43126.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/BackendUtil.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/BackendUtil.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/BackendUtil.cpp:24,Modifiability,plugin,plugins,24,// Attempt to load pass plugins and register their callbacks with PB.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/BackendUtil.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/BackendUtil.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/BackendUtil.cpp:14,Performance,load,load,14,// Attempt to load pass plugins and register their callbacks with PB.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/BackendUtil.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/BackendUtil.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/BackendUtil.cpp:89,Deployability,pipeline,pipeline,89,// Map our optimization levels into one of the distinct levels used to; // configure the pipeline.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/BackendUtil.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/BackendUtil.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/BackendUtil.cpp:75,Modifiability,config,configure,75,// Map our optimization levels into one of the distinct levels used to; // configure the pipeline.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/BackendUtil.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/BackendUtil.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/BackendUtil.cpp:11,Performance,optimiz,optimization,11,// Map our optimization levels into one of the distinct levels used to; // configure the pipeline.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/BackendUtil.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/BackendUtil.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/BackendUtil.cpp:105,Performance,perform,performing,105,"// If we reached here with a non-empty index file name, then the index; // file was empty and we are not performing ThinLTO backend compilation; // (used in testing in a distributed build environment).",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/BackendUtil.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/BackendUtil.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/BackendUtil.cpp:157,Testability,test,testing,157,"// If we reached here with a non-empty index file name, then the index; // file was empty and we are not performing ThinLTO backend compilation; // (used in testing in a distributed build environment).",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/BackendUtil.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/BackendUtil.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/BackendUtil.cpp:27,Testability,test,test,27,// If so drop any the type test assume sequences inserted for whole program; // vtables so that codegen doesn't complain.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/BackendUtil.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/BackendUtil.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/BackendUtil.cpp:86,Deployability,pipeline,pipeline,86,// Register callbacks to schedule sanitizer passes at the appropriate part; // of the pipeline.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/BackendUtil.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/BackendUtil.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/BackendUtil.cpp:25,Energy Efficiency,schedul,schedule,25,// Register callbacks to schedule sanitizer passes at the appropriate part; // of the pipeline.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/BackendUtil.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/BackendUtil.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/BackendUtil.cpp:34,Security,sanitiz,sanitizer,34,// Register callbacks to schedule sanitizer passes at the appropriate part; // of the pipeline.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/BackendUtil.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/BackendUtil.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/BackendUtil.cpp:13,Security,sanitiz,sanitizers,13,// Don't add sanitizers if we are here from ThinLTO PostLink. That already; // done on PreLink stage.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/BackendUtil.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/BackendUtil.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/BackendUtil.cpp:88,Performance,optimiz,optimizations,88,// Re-link against any bitcodes supplied via the -mlink-builtin-bitcode option; // Some optimizations may generate new function calls that would not have; // been linked pre-optimization (i.e. fused sincos calls generated by; // AMDGPULibCalls::fold_sincos.),MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/BackendUtil.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/BackendUtil.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/BackendUtil.cpp:174,Performance,optimiz,optimization,174,// Re-link against any bitcodes supplied via the -mlink-builtin-bitcode option; // Some optimizations may generate new function calls that would not have; // been linked pre-optimization (i.e. fused sincos calls generated by; // AMDGPULibCalls::fold_sincos.),MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/BackendUtil.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/BackendUtil.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/BackendUtil.cpp:178,Deployability,pipeline,pipeline,178,"// Add a verifier pass if requested. We don't have to do this if the action; // requires code generation because there will already be a verifier pass in; // the code-generation pipeline.; // Since we already added a verifier pass above, this; // might even not run the analysis, if previous passes caused no changes.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/BackendUtil.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/BackendUtil.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/BackendUtil.cpp:61,Deployability,pipeline,pipeline,61,"// Print a textual, '-passes=' compatible, representation of pipeline if; // requested.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/BackendUtil.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/BackendUtil.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/BackendUtil.cpp:49,Deployability,pipeline,pipeline,49,// We still use the legacy PM to run the codegen pipeline since the new PM; // does not work with the codegen pipeline.; // FIXME: make the new PM work with the codegen pipeline.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/BackendUtil.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/BackendUtil.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/BackendUtil.cpp:110,Deployability,pipeline,pipeline,110,// We still use the legacy PM to run the codegen pipeline since the new PM; // does not work with the codegen pipeline.; // FIXME: make the new PM work with the codegen pipeline.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/BackendUtil.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/BackendUtil.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/BackendUtil.cpp:169,Deployability,pipeline,pipeline,169,// We still use the legacy PM to run the codegen pipeline since the new PM; // does not work with the codegen pipeline.; // FIXME: make the new PM work with the codegen pipeline.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/BackendUtil.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/BackendUtil.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/BackendUtil.cpp:32,Availability,error,error,32,// FIXME: Should we handle this error differently?,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/BackendUtil.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/BackendUtil.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/BackendUtil.cpp:13,Deployability,pipeline,pipeline-passes,13,"// If -print-pipeline-passes is requested, don't run the legacy pass manager.; // FIXME: when codegen is switched to use the new pass manager, it should also; // emit pass names here.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/BackendUtil.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/BackendUtil.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/BackendUtil.cpp:10,Usability,simpl,simply,10,"// We can simply import the values mentioned in the combined index, since; // we should only invoke this using the individual indexes written out; // via a WriteIndexesThinBackend.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/BackendUtil.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/BackendUtil.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/BackendUtil.cpp:40,Deployability,integrat,integrated,40,"// Only enable CGProfilePass when using integrated assembler, since; // non-integrated assemblers don't recognize .cgprofile section.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/BackendUtil.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/BackendUtil.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/BackendUtil.cpp:76,Deployability,integrat,integrated,76,"// Only enable CGProfilePass when using integrated assembler, since; // non-integrated assemblers don't recognize .cgprofile section.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/BackendUtil.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/BackendUtil.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/BackendUtil.cpp:40,Integrability,integrat,integrated,40,"// Only enable CGProfilePass when using integrated assembler, since; // non-integrated assemblers don't recognize .cgprofile section.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/BackendUtil.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/BackendUtil.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/BackendUtil.cpp:76,Integrability,integrat,integrated,76,"// Only enable CGProfilePass when using integrated assembler, since; // non-integrated assemblers don't recognize .cgprofile section.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/BackendUtil.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/BackendUtil.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/BackendUtil.cpp:13,Performance,perform,performing,13,"// If we are performing a ThinLTO importing compile, load the function index; // into memory and pass it into runThinLTOBackend, which will run the; // function importer and invoke LTO passes.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/BackendUtil.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/BackendUtil.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/BackendUtil.cpp:53,Performance,load,load,53,"// If we are performing a ThinLTO importing compile, load the function index; // into memory and pass it into runThinLTOBackend, which will run the; // function importer and invoke LTO passes.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/BackendUtil.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/BackendUtil.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/BackendUtil.cpp:150,Availability,error,error,150,"// A null CombinedIndex means we should skip ThinLTO compilation; // (LLVM will optionally ignore empty index files, returning null instead; // of an error).",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/BackendUtil.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/BackendUtil.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/BackendUtil.cpp:24,Safety,detect,detected,24,"// Distributed indexing detected that nothing from the module is needed; // for the final linking. So we can skip the compilation. We sill need to; // output an empty object file to make sure that a linker does not fail; // trying to read it. Also for some features, like CFI, we must skip; // the compilation as CombinedIndex does not contain all required; // information.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/BackendUtil.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/BackendUtil.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGAtomic.cpp:23,Availability,down,down,23,/// Project an l-value down to the value field.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGAtomic.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGAtomic.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGAtomic.cpp:17,Performance,load,load,17,/// Emits atomic load.; /// \returns Loaded value.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGAtomic.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGAtomic.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGAtomic.cpp:37,Performance,Load,Loaded,37,/// Emits atomic load.; /// \returns Loaded value.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGAtomic.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGAtomic.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGAtomic.cpp:191,Availability,Failure,Failure,191,"/// Emits atomic compare-and-exchange sequence.; /// \param Expected Expected value.; /// \param Desired Desired value.; /// \param Success Atomic ordering for success operation.; /// \param Failure Atomic ordering for failed operation.; /// \param IsWeak true if atomic operation is weak, false otherwise.; /// \returns Pair of values: previous value from storage (value type) and; /// boolean flag (i1 type) with true if success and false otherwise.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGAtomic.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGAtomic.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGAtomic.cpp:17,Deployability,update,update,17,/// Emits atomic update.; /// \param AO Atomic ordering.; /// \param UpdateOp Update operation for the current lvalue.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGAtomic.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGAtomic.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGAtomic.cpp:69,Deployability,Update,UpdateOp,69,/// Emits atomic update.; /// \param AO Atomic ordering.; /// \param UpdateOp Update operation for the current lvalue.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGAtomic.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGAtomic.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGAtomic.cpp:78,Deployability,Update,Update,78,/// Emits atomic update.; /// \param AO Atomic ordering.; /// \param UpdateOp Update operation for the current lvalue.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGAtomic.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGAtomic.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGAtomic.cpp:17,Deployability,update,update,17,/// Emits atomic update.; /// \param AO Atomic ordering.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGAtomic.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGAtomic.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGAtomic.cpp:17,Performance,load,load,17,/// Emits atomic load as a libcall.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGAtomic.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGAtomic.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGAtomic.cpp:17,Performance,load,load,17,/// Emits atomic load as LLVM instruction.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGAtomic.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGAtomic.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGAtomic.cpp:16,Deployability,update,update,16,/// Emit atomic update as libcalls.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGAtomic.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGAtomic.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGAtomic.cpp:16,Deployability,update,update,16,/// Emit atomic update as LLVM instructions.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGAtomic.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGAtomic.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGAtomic.cpp:16,Deployability,update,update,16,/// Emit atomic update as libcalls.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGAtomic.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGAtomic.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGAtomic.cpp:16,Deployability,update,update,16,/// Emit atomic update as LLVM instructions.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGAtomic.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGAtomic.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGAtomic.cpp:50,Safety,avoid,avoid,50,"// Otherwise, do some simple heuristics to try to avoid it:",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGAtomic.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGAtomic.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGAtomic.cpp:22,Usability,simpl,simple,22,"// Otherwise, do some simple heuristics to try to avoid it:",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGAtomic.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGAtomic.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGAtomic.cpp:89,Availability,failure,failure,89,"// Cmp holds the result of the compare-exchange operation: true on success,; // false on failure.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGAtomic.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGAtomic.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGAtomic.cpp:3,Deployability,Update,Update,3,"// Update Expected if Expected isn't equal to Old, otherwise branch to the; // exit point.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGAtomic.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGAtomic.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGAtomic.cpp:3,Deployability,Update,Update,3,// Update the memory at Expected with Old's value.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGAtomic.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGAtomic.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGAtomic.cpp:3,Deployability,Update,Update,3,// Update the memory at Dest with Cmp's value.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGAtomic.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGAtomic.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGAtomic.cpp:156,Availability,Failure,FailureOrder,156,"/// Given an ordering required on success, emit all possible cmpxchg; /// instructions to cope with the provided (but possibly only dynamically known); /// FailureOrder.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGAtomic.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGAtomic.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGAtomic.cpp:19,Availability,failure,failure,19,"// 31.7.2.18: ""The failure argument shall not be memory_order_release; // nor memory_order_acq_rel"". Fallback to monotonic.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGAtomic.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGAtomic.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGAtomic.cpp:24,Availability,failure,failure,24,"// Prior to c++17, ""the failure argument shall be no stronger than the; // success argument"". This condition has been lifted and the only; // precondition is 31.7.2.18. Effectively treat this as a DR and skip; // language version checks.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGAtomic.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGAtomic.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGAtomic.cpp:36,Performance,perform,perform,36,"// For __atomic_*_fetch operations, perform the operation again to; // determine the value which was written.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGAtomic.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGAtomic.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGAtomic.cpp:3,Performance,Load,Load,3,// Load value and pass it to the function directly.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGAtomic.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGAtomic.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGAtomic.cpp:7,Performance,optimiz,optimized,7,// Non-optimized functions always take a reference.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGAtomic.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGAtomic.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGAtomic.cpp:63,Energy Efficiency,power,power,63,"// The inlined atomics only function on iN types, where N is a power of 2. We; // need to make sure (via temporaries if necessary) that all incoming values; // are compatible.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGAtomic.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGAtomic.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGAtomic.cpp:98,Performance,optimiz,optimized,98,// Use the generic version if we don't know that the operand will be; // suitably aligned for the optimized version.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGAtomic.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGAtomic.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGAtomic.cpp:12,Performance,optimiz,optimized,12,// Only use optimized library calls for sizes for which they exist.; // FIXME: Size == 16 optimized library functions exist too.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGAtomic.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGAtomic.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGAtomic.cpp:90,Performance,optimiz,optimized,90,// Only use optimized library calls for sizes for which they exist.; // FIXME: Size == 16 optimized library functions exist too.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGAtomic.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGAtomic.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGAtomic.cpp:11,Performance,optimiz,optimized,11,"// For non-optimized library calls, the size is the first parameter",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGAtomic.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGAtomic.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGAtomic.cpp:278,Availability,failure,failure,278,"// There is only one libcall for compare an exchange, because there is no; // optimisation benefit possible from a libcall version of a weak compare; // and exchange.; // bool __atomic_compare_exchange(size_t size, void *mem, void *expected,; // void *desired, int success, int failure); // bool __atomic_compare_exchange_N(T *mem, T *expected, T desired,; // int success, int failure)",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGAtomic.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGAtomic.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGAtomic.cpp:377,Availability,failure,failure,377,"// There is only one libcall for compare an exchange, because there is no; // optimisation benefit possible from a libcall version of a weak compare; // and exchange.; // bool __atomic_compare_exchange(size_t size, void *mem, void *expected,; // void *desired, int success, int failure); // bool __atomic_compare_exchange_N(T *mem, T *expected, T desired,; // int success, int failure)",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGAtomic.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGAtomic.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGAtomic.cpp:3,Performance,Optimiz,Optimized,3,// Optimized functions have the size in their name.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGAtomic.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGAtomic.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGAtomic.cpp:38,Performance,optimiz,optimized,38,// The value is returned directly for optimized libcalls but the expr; // provided an out-param.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGAtomic.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGAtomic.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGAtomic.cpp:3,Safety,Avoid,Avoid,3,// Avoid crashing on code with undefined behavior,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGAtomic.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGAtomic.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGAtomic.cpp:3,Safety,Avoid,Avoid,3,// Avoid crashing on code with undefined behavior,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGAtomic.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGAtomic.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGAtomic.cpp:3,Safety,Avoid,Avoid,3,// Avoid crashing on code with undefined behavior,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGAtomic.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGAtomic.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGAtomic.cpp:87,Integrability,rout,routine,87,"// Otherwise, just convert the temporary to an r-value using the; // normal conversion routine.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGAtomic.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGAtomic.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGAtomic.cpp:49,Usability,simpl,simple,49,// Get RValue from temp memory as atomic for non-simple lvalues,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGAtomic.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGAtomic.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGAtomic.cpp:44,Performance,load,loads,44,/// An LValue is a candidate for having its loads and stores be made atomic if; /// we are operating under /volatile:ms *and* the LValue itself is volatile and; /// performing such an operation can be performed without a libcall.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGAtomic.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGAtomic.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGAtomic.cpp:165,Performance,perform,performing,165,/// An LValue is a candidate for having its loads and stores be made atomic if; /// we are operating under /volatile:ms *and* the LValue itself is volatile and; /// performing such an operation can be performed without a libcall.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGAtomic.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGAtomic.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGAtomic.cpp:201,Performance,perform,performed,201,/// An LValue is a candidate for having its loads and stores be made atomic if; /// we are operating under /volatile:ms *and* the LValue itself is volatile and; /// performing such an operation can be performed without a libcall.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGAtomic.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGAtomic.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGAtomic.cpp:77,Usability,simpl,simple,77,"// Okay, turn that back into the original value or whole atomic (for; // non-simple lvalues) type.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGAtomic.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGAtomic.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGAtomic.cpp:67,Usability,simpl,simple,67,"// Okay, turn that back into the original value or atomic (for non-simple; // lvalues) type.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGAtomic.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGAtomic.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGAtomic.cpp:11,Performance,load,load,11,/// Emit a load from an l-value of atomic type. Note that the r-value; /// we produce is an r-value of the atomic *value* type.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGAtomic.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGAtomic.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGAtomic.cpp:57,Safety,avoid,avoid,57,"// If we've got a scalar value of the right size, try to avoid going; // through memory.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGAtomic.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGAtomic.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGAtomic.cpp:110,Availability,failure,failure,110,"// bool __atomic_compare_exchange(size_t size, void *obj, void *expected,; // void *desired, int success, int failure);",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGAtomic.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGAtomic.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGAtomic.cpp:57,Safety,avoid,avoid,57,"// If we've got a scalar value of the right size, try to avoid going; // through memory.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGAtomic.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGAtomic.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGAtomic.cpp:17,Performance,load,load,17,// Do the atomic load.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGAtomic.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGAtomic.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGAtomic.cpp:26,Performance,perform,perform,26,// For non-simple lvalues perform compare-and-swap procedure.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGAtomic.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGAtomic.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGAtomic.cpp:11,Usability,simpl,simple,11,// For non-simple lvalues perform compare-and-swap procedure.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGAtomic.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGAtomic.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGAtomic.cpp:17,Performance,load,load,17,// Do the atomic load.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGAtomic.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGAtomic.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGAtomic.cpp:26,Performance,perform,perform,26,// For non-simple lvalues perform compare-and-swap procedure.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGAtomic.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGAtomic.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGAtomic.cpp:11,Usability,simpl,simple,11,// For non-simple lvalues perform compare-and-swap procedure.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGAtomic.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGAtomic.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGAtomic.cpp:22,Deployability,update,update,22,// Emit simple atomic update operation.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGAtomic.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGAtomic.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGAtomic.cpp:8,Usability,simpl,simple,8,// Emit simple atomic update operation.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGAtomic.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGAtomic.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBlocks.cpp:686,Modifiability,variab,variables,686,/// buildBlockDescriptor - Build the block descriptor meta-data for a block.; /// buildBlockDescriptor is accessed from 5th field of the Block_literal; /// meta-data and contains stationary information about the block literal.; /// Its definition will have 4 (or optionally 6) words.; /// \code; /// struct Block_descriptor {; /// unsigned long reserved;; /// unsigned long size; // size of Block_literal metadata in bytes.; /// void *copy_func_helper_decl; // optional copy helper.; /// void *destroy_func_decl; // optional destructor helper.; /// void *block_method_encoding_address; // @encode for block literal signature.; /// void *block_layout_info; // encoding of captured block variables.; /// };; /// \endcode,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGBlocks.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBlocks.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBlocks.cpp:106,Security,access,accessed,106,/// buildBlockDescriptor - Build the block descriptor meta-data for a block.; /// buildBlockDescriptor is accessed from 5th field of the Block_literal; /// meta-data and contains stationary information about the block literal.; /// Its definition will have 4 (or optionally 6) words.; /// \code; /// struct Block_descriptor {; /// unsigned long reserved;; /// unsigned long size; // size of Block_literal metadata in bytes.; /// void *copy_func_helper_decl; // optional copy helper.; /// void *destroy_func_decl; // optional destructor helper.; /// void *block_method_encoding_address; // @encode for block literal signature.; /// void *block_layout_info; // encoding of captured block variables.; /// };; /// \endcode,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGBlocks.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBlocks.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBlocks.cpp:44,Modifiability,variab,variable,44,"// If an equivalent block descriptor global variable exists, return it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGBlocks.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBlocks.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBlocks.cpp:56,Modifiability,variab,variable,56,"// If there isn't an equivalent block descriptor global variable, create a new; // one.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGBlocks.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBlocks.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBlocks.cpp:978,Energy Efficiency,allocate,allocated,978,"/*; Purely notional variadic template describing the layout of a block. template <class _ResultType, class... _ParamTypes, class... _CaptureTypes>; struct Block_literal {; /// Initialized to one of:; /// extern void *_NSConcreteStackBlock[];; /// extern void *_NSConcreteGlobalBlock[];; ///; /// In theory, we could start one off malloc'ed by setting; /// BLOCK_NEEDS_FREE, giving it a refcount of 1, and using; /// this isa:; /// extern void *_NSConcreteMallocBlock[];; struct objc_class *isa;. /// These are the flags (with corresponding bit number) that the; /// compiler is actually supposed to know about.; /// 23. BLOCK_IS_NOESCAPE - indicates that the block is non-escaping; /// 25. BLOCK_HAS_COPY_DISPOSE - indicates that the block; /// descriptor provides copy and dispose helper functions; /// 26. BLOCK_HAS_CXX_OBJ - indicates that there's a captured; /// object with a nontrivial destructor or copy constructor; /// 28. BLOCK_IS_GLOBAL - indicates that the block is allocated; /// as global memory; /// 29. BLOCK_USE_STRET - indicates that the block function; /// uses stret, which objc_msgSend needs to know about; /// 30. BLOCK_HAS_SIGNATURE - indicates that the block has an; /// @encoded signature string; /// And we're not supposed to manipulate these:; /// 24. BLOCK_NEEDS_FREE - indicates that the block has been moved; /// to malloc'ed memory; /// 27. BLOCK_IS_GC - indicates that the block has been moved to; /// to GC-allocated memory; /// Additionally, the bottom 16 bits are a reference count which; /// should be zero on the stack.; int flags;. /// Reserved; should be zero-initialized.; int reserved;. /// Function pointer generated from block literal.; _ResultType (*invoke)(Block_literal *, _ParamTypes...);. /// Block description metadata generated from block literal.; struct Block_descriptor *block_descriptor;. /// Captured values follow.; _CapturesTypes captures...;; };; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGBlocks.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBlocks.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBlocks.cpp:1440,Energy Efficiency,allocate,allocated,1440,"/*; Purely notional variadic template describing the layout of a block. template <class _ResultType, class... _ParamTypes, class... _CaptureTypes>; struct Block_literal {; /// Initialized to one of:; /// extern void *_NSConcreteStackBlock[];; /// extern void *_NSConcreteGlobalBlock[];; ///; /// In theory, we could start one off malloc'ed by setting; /// BLOCK_NEEDS_FREE, giving it a refcount of 1, and using; /// this isa:; /// extern void *_NSConcreteMallocBlock[];; struct objc_class *isa;. /// These are the flags (with corresponding bit number) that the; /// compiler is actually supposed to know about.; /// 23. BLOCK_IS_NOESCAPE - indicates that the block is non-escaping; /// 25. BLOCK_HAS_COPY_DISPOSE - indicates that the block; /// descriptor provides copy and dispose helper functions; /// 26. BLOCK_HAS_CXX_OBJ - indicates that there's a captured; /// object with a nontrivial destructor or copy constructor; /// 28. BLOCK_IS_GLOBAL - indicates that the block is allocated; /// as global memory; /// 29. BLOCK_USE_STRET - indicates that the block function; /// uses stret, which objc_msgSend needs to know about; /// 30. BLOCK_HAS_SIGNATURE - indicates that the block has an; /// @encoded signature string; /// And we're not supposed to manipulate these:; /// 24. BLOCK_NEEDS_FREE - indicates that the block has been moved; /// to malloc'ed memory; /// 27. BLOCK_IS_GC - indicates that the block has been moved to; /// to GC-allocated memory; /// Additionally, the bottom 16 bits are a reference count which; /// should be zero on the stack.; int flags;. /// Reserved; should be zero-initialized.; int reserved;. /// Function pointer generated from block literal.; _ResultType (*invoke)(Block_literal *, _ParamTypes...);. /// Block description metadata generated from block literal.; struct Block_descriptor *block_descriptor;. /// Captured values follow.; _CapturesTypes captures...;; };; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGBlocks.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBlocks.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBlocks.cpp:36,Safety,safe,safe,36,/// Determines if the given type is safe for constant capture in C++.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGBlocks.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBlocks.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBlocks.cpp:23,Safety,unsafe,unsafe,23,// Only records can be unsafe.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGBlocks.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBlocks.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBlocks.cpp:354,Modifiability,variab,variables,354,"/// It is illegal to modify a const object after initialization.; /// Therefore, if a const object has a constant initializer, we don't; /// actually need to keep storage for it in the block; we'll just; /// rematerialize it at the start of the block function. This is; /// acceptable because we make no promises about address stability of; /// captured variables.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGBlocks.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBlocks.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBlocks.cpp:30,Modifiability,variab,variable,30,// We can only do this if the variable is const.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGBlocks.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBlocks.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBlocks.cpp:10,Modifiability,variab,variable,10,"// If the variable doesn't have any initializer (shouldn't this be; // invalid?), it's not clear what we should do. Maybe capture as; // zero?",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGBlocks.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBlocks.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBlocks.cpp:91,Usability,clear,clear,91,"// If the variable doesn't have any initializer (shouldn't this be; // invalid?), it's not clear what we should do. Maybe capture as; // zero?",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGBlocks.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBlocks.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBlocks.cpp:86,Testability,Assert,Assert,86,// The header is basically 'struct { int; int; generic void *;; // custom_fields; }'. Assert that struct is packed.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGBlocks.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBlocks.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBlocks.cpp:79,Testability,Assert,Assert,79,// The header is basically 'struct { void *; int; int; void *; void *; }'.; // Assert that the struct is packed.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGBlocks.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBlocks.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBlocks.cpp:10,Modifiability,variab,variable,10,"// If the variable is captured by an enclosing block or lambda expression,; // use the type of the capture field.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGBlocks.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBlocks.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBlocks.cpp:19,Modifiability,variab,variable,19,"// If the captured variable is a non-escaping __block variable, the field; // type is the reference type. If the variable is a __block variable that; // already has a reference type, the field type is the variable's type.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGBlocks.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBlocks.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBlocks.cpp:54,Modifiability,variab,variable,54,"// If the captured variable is a non-escaping __block variable, the field; // type is the reference type. If the variable is a __block variable that; // already has a reference type, the field type is the variable's type.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGBlocks.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBlocks.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBlocks.cpp:113,Modifiability,variab,variable,113,"// If the captured variable is a non-escaping __block variable, the field; // type is the reference type. If the variable is a __block variable that; // already has a reference type, the field type is the variable's type.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGBlocks.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBlocks.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBlocks.cpp:135,Modifiability,variab,variable,135,"// If the captured variable is a non-escaping __block variable, the field; // type is the reference type. If the variable is a __block variable that; // already has a reference type, the field type is the variable's type.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGBlocks.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBlocks.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBlocks.cpp:205,Modifiability,variab,variable,205,"// If the captured variable is a non-escaping __block variable, the field; // type is the reference type. If the variable is a __block variable that; // already has a reference type, the field type is the variable's type.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGBlocks.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBlocks.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBlocks.cpp:19,Modifiability,variab,variable,19,"// Since a __block variable cannot be captured by lambdas, its type and; // the capture field type should always match.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGBlocks.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBlocks.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBlocks.cpp:88,Modifiability,variab,variable,88,// size may not be multiple of alignment. This can only happen with; // an over-aligned variable. We will be adding a padding field to; // make the size be multiple of alignment.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGBlocks.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBlocks.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBlocks.cpp:44,Modifiability,variab,variable,44,"// The block literal is emitted as a global variable, and the block invoke; // function has to be extracted from its initializer.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGBlocks.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBlocks.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBlocks.cpp:18,Modifiability,variab,variables,18,"// Next, captured variables.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGBlocks.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBlocks.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBlocks.cpp:86,Usability,simpl,simply,86,// The lambda capture in a lambda's conversion-to-block-pointer is; // special; we'll simply emit it directly.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGBlocks.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBlocks.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBlocks.cpp:23,Modifiability,variab,variable,23,"// If it's a reference variable, copy the reference into the block field.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGBlocks.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBlocks.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBlocks.cpp:44,Modifiability,variab,variable,44,"// If this is an ARC __strong block-pointer variable, don't do a; // block copy.; //; // TODO: this can be generalized into the normal initialization logic:; // we should never need to do a block-copy when initializing a local; // variable, because the local variable's lifetime should be strictly; // contained within the stack block's.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGBlocks.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBlocks.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBlocks.cpp:231,Modifiability,variab,variable,231,"// If this is an ARC __strong block-pointer variable, don't do a; // block copy.; //; // TODO: this can be generalized into the normal initialization logic:; // we should never need to do a block-copy when initializing a local; // variable, because the local variable's lifetime should be strictly; // contained within the stack block's.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGBlocks.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBlocks.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBlocks.cpp:259,Modifiability,variab,variable,259,"// If this is an ARC __strong block-pointer variable, don't do a; // block copy.; //; // TODO: this can be generalized into the normal initialization logic:; // we should never need to do a block-copy when initializing a local; // variable, because the local variable's lifetime should be strictly; // contained within the stack block's.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGBlocks.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBlocks.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBlocks.cpp:150,Testability,log,logic,150,"// If this is an ARC __strong block-pointer variable, don't do a; // block copy.; //; // TODO: this can be generalized into the normal initialization logic:; // we should never need to do a block-copy when initializing a local; // variable, because the local variable's lifetime should be strictly; // contained within the stack block's.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGBlocks.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBlocks.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBlocks.cpp:3,Performance,Load,Load,3,// Load the block and do a simple retain.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGBlocks.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBlocks.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBlocks.cpp:27,Usability,simpl,simple,27,// Load the block and do a simple retain.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGBlocks.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBlocks.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBlocks.cpp:17,Modifiability,variab,variable,17,// Fake up a new variable so that EmitScalarInit doesn't think; // we're referring to the variable in its own initializer.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGBlocks.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBlocks.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBlocks.cpp:90,Modifiability,variab,variable,90,// Fake up a new variable so that EmitScalarInit doesn't think; // we're referring to the variable in its own initializer.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGBlocks.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBlocks.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBlocks.cpp:36,Integrability,depend,depending,36,// We use one of these or the other depending on whether the; // reference is nested.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGBlocks.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBlocks.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBlocks.cpp:233,Deployability,release,released,233,"// Block captures count as local values and have imprecise semantics.; // They also can't be arrays, so need to worry about that.; //; // For const-qualified captures, emit clang.arc.use to ensure the captured; // object doesn't get released while we are still depending on its validity; // within the block.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGBlocks.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBlocks.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBlocks.cpp:261,Integrability,depend,depending,261,"// Block captures count as local values and have imprecise semantics.; // They also can't be arrays, so need to worry about that.; //; // For const-qualified captures, emit clang.arc.use to ensure the captured; // object doesn't get released while we are still depending on its validity; // within the block.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGBlocks.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBlocks.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBlocks.cpp:3,Modifiability,Extend,Extend,3,"// Extend the lifetime of the capture to the end of the scope enclosing the; // block expression except when the block decl is in the list of RetExpr's; // cleanup objects, in which case its lifetime ends after the full; // expression.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGBlocks.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBlocks.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBlocks.cpp:3,Performance,Load,Load,3,// Load the function.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGBlocks.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBlocks.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBlocks.cpp:38,Performance,Load,Load,38,"// addr should be a void** right now. Load, then cast the result; // to byref*.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGBlocks.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBlocks.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBlocks.cpp:18,Safety,detect,detect,18,"// Callers should detect this case on their own: calling this function; // generally requires computing layout information, which is a waste of time; // if we've already emitted this block.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGBlocks.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBlocks.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBlocks.cpp:104,Modifiability,variab,variables,104,// Windows does not allow globals to be initialised to point to globals in; // different DLLs. Any such variables must run code to initialise them.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGBlocks.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBlocks.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBlocks.cpp:3,Energy Efficiency,Allocate,Allocate,3,// Allocate a stack slot like for any local variable to guarantee optimal; // debug info at -O0. The mem2reg pass will eliminate it when optimizing.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGBlocks.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBlocks.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBlocks.cpp:44,Modifiability,variab,variable,44,// Allocate a stack slot like for any local variable to guarantee optimal; // debug info at -O0. The mem2reg pass will eliminate it when optimizing.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGBlocks.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBlocks.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBlocks.cpp:137,Performance,optimiz,optimizing,137,// Allocate a stack slot like for any local variable to guarantee optimal; // debug info at -O0. The mem2reg pass will eliminate it when optimizing.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGBlocks.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBlocks.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBlocks.cpp:59,Modifiability,variab,variable,59,// For OpenCL passed block pointer can be private AS local variable or; // global AS program scope variable (for the case with and without captures).; // Generic AS is used therefore to be able to accommodate both private and; // generic AS in one implementation.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGBlocks.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBlocks.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBlocks.cpp:99,Modifiability,variab,variable,99,// For OpenCL passed block pointer can be private AS local variable or; // global AS program scope variable (for the case with and without captures).; // Generic AS is used therefore to be able to accommodate both private and; // generic AS in one implementation.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGBlocks.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBlocks.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBlocks.cpp:177,Modifiability,variab,variables,177,"// Okay. Undo some of what StartFunction did.; // At -O0 we generate an explicit alloca for the BlockPointer, so the RA; // won't delete the dbg.declare intrinsics for captured variables.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGBlocks.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBlocks.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBlocks.cpp:9,Usability,Undo,Undo,9,"// Okay. Undo some of what StartFunction did.; // At -O0 we generate an explicit alloca for the BlockPointer, so the RA; // won't delete the dbg.declare intrinsics for captured variables.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGBlocks.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBlocks.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBlocks.cpp:3,Energy Efficiency,Allocate,Allocate,3,"// Allocate a stack slot for it, so we can point the debugger to it",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGBlocks.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBlocks.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBlocks.cpp:3,Availability,Recover,Recover,3,// Recover location if it was changed in the above loop.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGBlocks.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBlocks.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBlocks.cpp:3,Safety,Recover,Recover,3,// Recover location if it was changed in the above loop.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGBlocks.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBlocks.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBlocks.cpp:7,Usability,resume,resume,7,// And resume where we left off.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGBlocks.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBlocks.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBlocks.cpp:238,Safety,avoid,avoid,238,"// We need to retain the copied value for __strong direct captures.; // If it's a block pointer, we have to copy the block and assign that to; // the destination pointer, so we might as well use _Block_object_assign.; // Otherwise we can avoid that.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGBlocks.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBlocks.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBlocks.cpp:4,Deployability,Release,Release,4,/// Release a __block variable.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGBlocks.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBlocks.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBlocks.cpp:22,Modifiability,variab,variable,22,/// Release a __block variable.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGBlocks.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBlocks.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBlocks.cpp:120,Modifiability,variab,variables,120,// Calls to _Block_object_dispose along the EH path in the copy helper; // function don't throw as newly-copied __block variables always have a; // reference count of 2.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGBlocks.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBlocks.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBlocks.cpp:2,Performance,Load,LoadBlockVarAddr,2,/*LoadBlockVarAddr*/,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGBlocks.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBlocks.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBlocks.cpp:411,Modifiability,variab,variable,411,"/// Generate the copy-helper function for a block closure object:; /// static void block_copy_helper(block_t *dst, block_t *src);; /// The runtime will have previously initialized 'dst' by doing a; /// bit-copy of 'src'.; ///; /// Note that this copies an entire block closure object to the heap;; /// it should not be confused with a 'byref copy helper', which moves; /// the contents of an individual __block variable to the heap.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGBlocks.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBlocks.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBlocks.cpp:91,Deployability,release,release,91,"// At -O0, store null into the destination field (so that the; // storeStrong doesn't over-release) and then call storeStrong.; // This is a workaround to not having an initStrong call.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGBlocks.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBlocks.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBlocks.cpp:8,Performance,optimiz,optimization,8,"// With optimization enabled, take advantage of the fact that; // the blocks runtime guarantees a memcpy of the block data, and; // just emit a retain of the src field.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGBlocks.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBlocks.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBlocks.cpp:116,Safety,avoid,avoid,116,"// Unless EH cleanup is required, we don't need this anymore, so kill; // it. It's not quite worth the annoyance to avoid creating it in the; // first place.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGBlocks.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBlocks.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBlocks.cpp:168,Energy Efficiency,allocate,allocated,168,"/// Generate the destroy-helper function for a block closure object:; /// static void block_destroy_helper(block_t *theBlock);; ///; /// Note that this destroys a heap-allocated block closure object;; /// it should not be confused with a 'byref destroy helper', which; /// destroys the heap-allocated contents of an individual __block; /// variable.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGBlocks.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBlocks.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBlocks.cpp:291,Energy Efficiency,allocate,allocated,291,"/// Generate the destroy-helper function for a block closure object:; /// static void block_destroy_helper(block_t *theBlock);; ///; /// Note that this destroys a heap-allocated block closure object;; /// it should not be confused with a 'byref destroy helper', which; /// destroys the heap-allocated contents of an individual __block; /// variable.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGBlocks.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBlocks.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBlocks.cpp:340,Modifiability,variab,variable,340,"/// Generate the destroy-helper function for a block closure object:; /// static void block_destroy_helper(block_t *theBlock);; ///; /// Note that this destroys a heap-allocated block closure object;; /// it should not be confused with a 'byref destroy helper', which; /// destroys the heap-allocated contents of an individual __block; /// variable.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGBlocks.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBlocks.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBlocks.cpp:61,Modifiability,variab,variable,61,/// Emits the copy/dispose helpers for an ARC __block __weak variable.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGBlocks.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBlocks.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBlocks.cpp:63,Modifiability,variab,variable,63,/// Emits the copy/dispose helpers for an ARC __block __strong variable; /// that's not of block-pointer type.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGBlocks.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBlocks.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBlocks.cpp:69,Modifiability,variab,variable,69,"// Do a ""move"" by copying the value and then zeroing out the old; // variable.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGBlocks.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBlocks.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBlocks.cpp:68,Modifiability,variab,variable,68,/// Emits the copy/dispose helpers for an ARC __block __strong; /// variable that's of block-pointer type.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGBlocks.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBlocks.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBlocks.cpp:49,Modifiability,variab,variable,49,/// Emits the copy/dispose helpers for a __block variable with a; /// nontrivial copy constructor or destructor.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGBlocks.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBlocks.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBlocks.cpp:49,Modifiability,variab,variable,49,/// Emits the copy/dispose helpers for a __block variable that is a non-trivial; /// C struct.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGBlocks.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBlocks.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBlocks.cpp:40,Modifiability,variab,variable,40,/// Build the copy helper for a __block variable.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGBlocks.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBlocks.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBlocks.cpp:32,Modifiability,variab,variable,32,/// Generate code for a __block variable's dispose helper.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGBlocks.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBlocks.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBlocks.cpp:43,Modifiability,variab,variable,43,/// Build the dispose helper for a __block variable.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGBlocks.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBlocks.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBlocks.cpp:60,Modifiability,variab,variable,60,/// Lazily build the copy and dispose helpers for a __block variable; /// with the given information.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGBlocks.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBlocks.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBlocks.cpp:61,Modifiability,variab,variable,61,/// Build the copy and dispose helpers for the given __block variable; /// emission. Places the helpers in the global cache. Returns null; /// if no helpers are required.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGBlocks.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBlocks.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBlocks.cpp:118,Performance,cache,cache,118,/// Build the copy and dispose helpers for the given __block variable; /// emission. Places the helpers in the global cache. Returns null; /// if no helpers are required.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGBlocks.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBlocks.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBlocks.cpp:69,Integrability,rout,routines,69,"// Tell the runtime that this is ARC __weak, called by the; // byref routines.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGBlocks.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBlocks.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBlocks.cpp:24,Modifiability,variab,variables,24,// ARC __strong __block variables need to be retained.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGBlocks.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBlocks.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBlocks.cpp:26,Integrability,rout,routine,26,/// BuildByrefInfo - This routine changes a __block variable declared as T x; /// into:; ///; /// struct {; /// void *__isa;; /// void *__forwarding;; /// int32_t __flags;; /// int32_t __size;; /// void *__copy_helper; // only if needed; /// void *__destroy_helper; // only if needed; /// void *__byref_variable_layout;// only if needed; /// char padding[X]; // only if needed; /// T x;; /// } x; ///,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGBlocks.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBlocks.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBlocks.cpp:52,Modifiability,variab,variable,52,/// BuildByrefInfo - This routine changes a __block variable declared as T x; /// into:; ///; /// struct {; /// void *__isa;; /// void *__forwarding;; /// int32_t __flags;; /// int32_t __size;; /// void *__copy_helper; // only if needed; /// void *__destroy_helper; // only if needed; /// void *__byref_variable_layout;// only if needed; /// char padding[X]; // only if needed; /// T x;; /// } x; ///,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGBlocks.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBlocks.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBlocks.cpp:43,Testability,log,logic,43,// Note that this must match *exactly* the logic in buildByrefHelpers.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGBlocks.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBlocks.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBlocks.cpp:54,Modifiability,variab,variable,54,"/// Initialize the structural components of a __block variable, i.e.; /// everything but the actual object.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGBlocks.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBlocks.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBlocks.cpp:28,Modifiability,variab,variable,28,// Store the address of the variable into its own forwarding pointer.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGBlocks.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBlocks.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBlocks.h:27,Modifiability,variab,variables,27,// Flags stored in __block variables.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGBlocks.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBlocks.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBlocks.h:11,Modifiability,variab,variable,11,/* a block variable */,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGBlocks.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBlocks.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBlocks.h:47,Modifiability,variab,variable,47,/* the on stack structure holding the __block; variable */,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGBlocks.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBlocks.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBlocks.h:53,Integrability,rout,routines,53,/* called from __block (byref) copy/dispose; support routines */,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGBlocks.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBlocks.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBlocks.h:46,Modifiability,variab,variable,46,/// Information about the layout of a __block variable.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGBlocks.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBlocks.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBlocks.h:63,Performance,perform,performed,63,/// Represents a type of copy/destroy operation that should be performed for an; /// entity that's captured by a block.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGBlocks.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBlocks.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBlocks.h:13,Deployability,release,release,13,// Assign or release,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGBlocks.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBlocks.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBlocks.h:59,Modifiability,variab,variables,59,/// HasCapturedVariableLayout : True if block has captured variables; /// and their layout meta-data has been generated.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGBlocks.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBlocks.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBlocks.h:17,Modifiability,variab,variables,17,/// Mapping from variables to pointers to captures in SortedCaptures.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGBlocks.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBlocks.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBuilder.h:36,Performance,cache,cache,36,"/// Storing a reference to the type cache here makes it a lot easier; /// to build natural-feeling, target-specific IR.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGBuilder.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBuilder.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBuilder.h:32,Modifiability,variab,variable,32,/// Emit a load from an i1 flag variable.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGBuilder.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBuilder.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBuilder.h:11,Performance,load,load,11,/// Emit a load from an i1 flag variable.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGBuilder.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBuilder.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBuilder.h:31,Modifiability,variab,variable,31,/// Emit a store to an i1 flag variable.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGBuilder.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBuilder.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBuilder.h:67,Energy Efficiency,reduce,reduced,67,/// Create GEP with single dynamic index. The address alignment is reduced; /// according to the element size.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGBuilder.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBuilder.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp:41,Modifiability,refactor,refactored,41,// TODO: This list should be expanded or refactored after all GCC-compatible; // std libcall builtins are implemented.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp:29,Availability,failure,failure,29,"// For Release ordering, the failure ordering should be Monotonic.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp:7,Deployability,Release,Release,7,"// For Release ordering, the failure ordering should be Monotonic.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp:104,Performance,optimiz,optimizations,104,"// The atomic instruction is marked volatile for consistency with MSVC. This; // blocks the few atomics optimizations that LLVM has. If we want to optimize; // _Interlocked* operations in the future, we will have to remove the volatile; // marker.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp:147,Performance,optimiz,optimize,147,"// The atomic instruction is marked volatile for consistency with MSVC. This; // blocks the few atomics optimizations that LLVM has. If we want to optimize; // _Interlocked* operations in the future, we will have to remove the volatile; // marker.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp:29,Availability,failure,failure,29,"// For Release ordering, the failure ordering should be Monotonic.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp:7,Deployability,Release,Release,7,"// For Release ordering, the failure ordering should be Monotonic.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp:3,Performance,Load,Load,3,// Load the comparand for the instruction.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp:104,Performance,optimiz,optimizations,104,"// The atomic instruction is marked volatile for consistency with MSVC. This; // blocks the few atomics optimizations that LLVM has. If we want to optimize; // _Interlocked* operations in the future, we will have to remove the volatile; // marker.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp:147,Performance,optimiz,optimize,147,"// The atomic instruction is marked volatile for consistency with MSVC. This; // blocks the few atomics optimizations that LLVM has. If we want to optimize; // _Interlocked* operations in the future, we will have to remove the volatile; // marker.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp:36,Modifiability,extend,extend,36,// Get the success boolean and zero extend it to i8.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp:26,Performance,load,load,26,// Build a plain volatile load.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp:105,Integrability,Depend,Depending,105,"// Emit a simple mangled intrinsic that has 1 argument and a return type; // matching the argument type. Depending on mode, this may be a constrained; // floating-point intrinsic.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp:10,Usability,simpl,simple,10,"// Emit a simple mangled intrinsic that has 1 argument and a return type; // matching the argument type. Depending on mode, this may be a constrained; // floating-point intrinsic.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp:77,Integrability,Depend,Depending,77,"// Emit an intrinsic that has 2 operands of the same type as its result.; // Depending on mode, this may be a constrained floating-point intrinsic.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp:77,Integrability,Depend,Depending,77,"// Emit an intrinsic that has 3 operands of the same type as its result.; // Depending on mode, this may be a constrained floating-point intrinsic.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp:80,Integrability,Depend,Depending,80,"// Emit an intrinsic where all operands are of the same type as the result.; // Depending on mode, this may be a constrained floating-point intrinsic.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp:10,Usability,simpl,simple,10,// Emit a simple mangled intrinsic that has 1 argument and a return type; // matching the argument type.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp:467,Availability,down,down,467,"// We want the sign bit of the higher-order double. The bitcast we just; // did works as if the double-double was stored to memory and then; // read as an i128. The ""store"" will put the higher-order double in the; // lower address in both little- and big-Endian modes, but the ""load""; // will treat those bits as a different part of the i128: the low bits in; // little-Endian, the high bits in big-Endian. Therefore, on big-Endian; // we need to shift the high bits down to the low before truncating.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp:278,Performance,load,load,278,"// We want the sign bit of the higher-order double. The bitcast we just; // did works as if the double-double was stored to memory and then; // read as an i128. The ""store"" will put the higher-order double in the; // lower address in both little- and big-Endian modes, but the ""load""; // will treat those bits as a different part of the i128: the low bits in; // little-Endian, the high bits in big-Endian. Therefore, on big-Endian; // we need to shift the high bits down to the low before truncating.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp:77,Integrability,depend,depending,77,"/// Emit a call to llvm.{sadd,uadd,ssub,usub,smul,umul}.with.overflow.*; /// depending on IntrinsicID.; ///; /// \arg CGF The current codegen function.; /// \arg IntrinsicID The ID for the Intrinsic we wish to generate.; /// \arg X The first argument to the llvm.*.with.overflow.*.; /// \arg Y The second argument to the llvm.*.with.overflow.*.; /// \arg Carry The carry returned by the llvm.*.with.overflow.*.; /// \returns The result (i.e. sum/product) returned by the intrinsic.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp:66,Modifiability,flexible,flexible,66,"// The code generated here calculates the size of a struct with a flexible; // array member that uses the counted_by attribute. There are two instances; // we handle:; //; // struct s {; // unsigned long flags;; // int count;; // int array[] __attribute__((counted_by(count)));; // }; //; // 1) bdos of the flexible array itself:; //; // __builtin_dynamic_object_size(p->array, 1) ==; // p->count * sizeof(*p->array); //; // 2) bdos of a pointer into the flexible array:; //; // __builtin_dynamic_object_size(&p->array[42], 1) ==; // (p->count - 42) * sizeof(*p->array); //; // 2) bdos of the whole struct, including the flexible array:; //; // __builtin_dynamic_object_size(p, 1) ==; // max(sizeof(struct s),; // offsetof(struct s, array) + p->count * sizeof(*p->array)); //",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp:307,Modifiability,flexible,flexible,307,"// The code generated here calculates the size of a struct with a flexible; // array member that uses the counted_by attribute. There are two instances; // we handle:; //; // struct s {; // unsigned long flags;; // int count;; // int array[] __attribute__((counted_by(count)));; // }; //; // 1) bdos of the flexible array itself:; //; // __builtin_dynamic_object_size(p->array, 1) ==; // p->count * sizeof(*p->array); //; // 2) bdos of a pointer into the flexible array:; //; // __builtin_dynamic_object_size(&p->array[42], 1) ==; // (p->count - 42) * sizeof(*p->array); //; // 2) bdos of the whole struct, including the flexible array:; //; // __builtin_dynamic_object_size(p, 1) ==; // max(sizeof(struct s),; // offsetof(struct s, array) + p->count * sizeof(*p->array)); //",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp:455,Modifiability,flexible,flexible,455,"// The code generated here calculates the size of a struct with a flexible; // array member that uses the counted_by attribute. There are two instances; // we handle:; //; // struct s {; // unsigned long flags;; // int count;; // int array[] __attribute__((counted_by(count)));; // }; //; // 1) bdos of the flexible array itself:; //; // __builtin_dynamic_object_size(p->array, 1) ==; // p->count * sizeof(*p->array); //; // 2) bdos of a pointer into the flexible array:; //; // __builtin_dynamic_object_size(&p->array[42], 1) ==; // (p->count - 42) * sizeof(*p->array); //; // 2) bdos of the whole struct, including the flexible array:; //; // __builtin_dynamic_object_size(p, 1) ==; // max(sizeof(struct s),; // offsetof(struct s, array) + p->count * sizeof(*p->array)); //",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp:621,Modifiability,flexible,flexible,621,"// The code generated here calculates the size of a struct with a flexible; // array member that uses the counted_by attribute. There are two instances; // we handle:; //; // struct s {; // unsigned long flags;; // int count;; // int array[] __attribute__((counted_by(count)));; // }; //; // 1) bdos of the flexible array itself:; //; // __builtin_dynamic_object_size(p->array, 1) ==; // p->count * sizeof(*p->array); //; // 2) bdos of a pointer into the flexible array:; //; // __builtin_dynamic_object_size(&p->array[42], 1) ==; // (p->count - 42) * sizeof(*p->array); //; // 2) bdos of the whole struct, including the flexible array:; //; // __builtin_dynamic_object_size(p, 1) ==; // max(sizeof(struct s),; // offsetof(struct s, array) + p->count * sizeof(*p->array)); //",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp:11,Modifiability,flexible,flexible,11,// Get the flexible array member Decl.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp:6,Modifiability,flexible,flexible,6,"// No flexible array member found or it doesn't have the ""counted_by""; // attribute.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp:11,Performance,load,load,11,// Build a load of the counted_by field.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp:11,Performance,load,load,11,// Build a load of the index and subtract it from the count.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp:27,Modifiability,flexible,flexible,27,// Calculate how large the flexible array member is in bytes.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp:91,Modifiability,flexible,flexible,91,"// A negative \p IdxInst or \p CountedByInst means that the index lands; // outside of the flexible array member. If that's the case, we want to; // return 0.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp:27,Modifiability,flexible,flexible,27,"// Emit special code for a flexible array member with the ""counted_by""; // attribute.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp:43,Testability,test,test,43,/// A struct to generically describe a bit test intrinsic.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp:8,Modifiability,portab,portable,8,// Main portable variants.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp:279,Performance,load,load,279,"/// Emit a _bittest* intrinsic. These intrinsics take a pointer to an array of; /// bits and a bit position and read and optionally modify the bit at that; /// position. The position index can be arbitrarily large, i.e. it can be larger; /// than 31 or 63, so we need an indexed load in the general case.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp:164,Availability,mask,mask,164,"// Otherwise, use generic code to load one byte and test the bit. Use all but; // the bottom three bits as the array index, and the bottom three bits to form; // a mask.; // Bit = BitBaseI8[BitPos >> 3] & (1 << (BitPos & 0x7)) != 0;",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp:34,Performance,load,load,34,"// Otherwise, use generic code to load one byte and test the bit. Use all but; // the bottom three bits as the array index, and the bottom three bits to form; // a mask.; // Bit = BitBaseI8[BitPos >> 3] & (1 << (BitPos & 0x7)) != 0;",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp:52,Testability,test,test,52,"// Otherwise, use generic code to load one byte and test the bit. Use all but; // the bottom three bits as the array index, and the bottom three bits to form; // a mask.; // Bit = BitBaseI8[BitPos >> 3] & (1 << (BitPos & 0x7)) != 0;",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp:41,Availability,mask,mask,41,// The updating instructions will need a mask.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp:40,Safety,interlock,interlocked,40,// Check the action and ordering of the interlocked intrinsics.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp:40,Security,interlock,interlocked,40,// Check the action and ordering of the interlocked intrinsics.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp:29,Performance,load,load,29,// Emit a combined atomicrmw load/store operation for the interlocked; // intrinsics.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp:58,Safety,interlock,interlocked,58,// Emit a combined atomicrmw load/store operation for the interlocked; // intrinsics.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp:58,Security,interlock,interlocked,58,// Emit a combined atomicrmw load/store operation for the interlocked; // intrinsics.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp:16,Performance,load,load,16,// Emit a plain load for the non-interlocked intrinsics.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp:33,Safety,interlock,interlocked,33,// Emit a plain load for the non-interlocked intrinsics.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp:33,Security,interlock,interlocked,33,// Emit a plain load for the non-interlocked intrinsics.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp:114,Availability,mask,mask,114,"// However we loaded the old byte, either by plain load or atomicrmw, shift; // the bit into the low position and mask it to 0 or 1.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp:14,Performance,load,loaded,14,"// However we loaded the old byte, either by plain load or atomicrmw, shift; // the bit into the low position and mask it to 0 or 1.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp:51,Performance,load,load,51,"// However we loaded the old byte, either by plain load or atomicrmw, shift; // the bit into the low position and mask it to 0 or 1.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp:57,Safety,avoid,avoid,57,"// Many of MSVC builtins are on x64, ARM and AArch64; to avoid repeating code,; // we handle them here.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp:108,Modifiability,extend,extended,108,"// If a temporary object that requires destruction after the full; // expression is passed, push a lifetime-extended cleanup to extend its; // lifetime to the end of the enclosing block scope.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp:128,Modifiability,extend,extend,128,"// If a temporary object that requires destruction after the full; // expression is passed, push a lifetime-extended cleanup to extend its; // lifetime to the end of the enclosing block scope.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp:62,Integrability,message,message,62,"// Extend lifetimes of objects returned by function calls and message; // sends.; // FIXME: We should do this in other cases in which temporaries are; // created including arguments of non-ARC types (e.g., C++; // temporaries).",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp:3,Modifiability,Extend,Extend,3,"// Extend lifetimes of objects returned by function calls and message; // sends.; // FIXME: We should do this in other cases in which temporaries are; // created including arguments of non-ARC types (e.g., C++; // temporaries).",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp:91,Availability,alive,alive,91,// Push a clang.arc.use call to ensure ARC optimizer knows that the; // argument has to be alive.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp:43,Performance,optimiz,optimizer,43,// Push a clang.arc.use call to ensure ARC optimizer knows that the; // argument has to be alive.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp:37,Modifiability,extend,extend,37,"// If ArgVal has type x86_fp80, zero-extend ArgVal.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp:27,Safety,detect,detect,27,"// The intrinsic call will detect overflow when the value is > UINT_MAX,; // however, since the original builtin had a signed result, we need to report; // an overflow when the result is greater than INT_MAX.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp:3,Performance,Perform,Perform,3,// Perform a checked unsigned multiplication.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp:84,Modifiability,Extend,Extend,84,"// See if we can constant fold this builtin. If so, don't emit it at all.; // TODO: Extend this handling to all builtin calls that we can constant-fold.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp:180,Safety,avoid,avoid,180,"// If the builtin has been declared explicitly with an assembler label,; // disable the specialized emitting below. Ideally we should communicate the; // rename in IR, or at least avoid generating the intrinsic calls that are; // likely to get lowered to the renamed library functions.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp:641,Performance,optimiz,optimization,641,"// ConstAttr is enabled in fast-math mode. In fast-math mode, math-errno is; // disabled.; // Math intrinsics are generated only when math-errno is disabled. Any pragmas; // or attributes that affect math-errno should prevent or allow math; // intrincs to be generated. Intrinsics are generated:; // 1- In fast math mode, unless math-errno is overriden; // via '#pragma float_control(precise, on)', or via an; // 'attribute__((optnone))'.; // 2- If math-errno was enabled on command line but overriden; // to false via '#pragma float_control(precise, off))' and; // 'attribute__((optnone))' hasn't been used.; // 3- If we are compiling with optimization and errno has been disabled; // via '#pragma float_control(precise, off)', and; // 'attribute__((optnone))' hasn't been used.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp:68,Availability,avail,available,68,// Only enabled preserved access index region when debuginfo; // is available as debuginfo is needed to preserve user-level; // access pattern.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp:26,Security,access,access,26,// Only enabled preserved access index region when debuginfo; // is available as debuginfo is needed to preserve user-level; // access pattern.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp:128,Security,access,access,128,// Only enabled preserved access index region when debuginfo; // is available as debuginfo is needed to preserve user-level; // access pattern.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp:33,Performance,optimiz,optimizer,33,// We pass this builtin onto the optimizer so that it can figure out the; // object size in more complex cases.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp:30,Integrability,depend,dependent,30,// Emit everything that isn't dependent on the first parameter type,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp:3,Modifiability,Extend,Extends,3,"// Extends a pointer to the size of an _Unwind_Word, which is; // uint64_t on all platforms. Generally this gets poked into a; // register and eventually used as an address, so if the; // addressing registers are wider than pointers and the platform; // doesn't implicitly ignore high-order bits when doing; // addressing, we need to make sure we zext / sext based on; // the platform's expectations.; //; // See: http://gcc.gnu.org/ml/gcc-bugs/2002-02/msg00237.html; // Cast the pointer to intptr_t.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp:397,Deployability,release,release,397,"// We assume this is supposed to correspond to a C++0x-style; // sequentially-consistent fence (i.e. this is only usable for; // synchronization, not device I/O or anything like that). This intrinsic; // is really badly designed in the sense that in theory, there isn't; // any way to safely use it... but in practice, it mostly works; // to use it with non-atomic loads and stores to get acquire/release; // semantics.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp:129,Integrability,synchroniz,synchronization,129,"// We assume this is supposed to correspond to a C++0x-style; // sequentially-consistent fence (i.e. this is only usable for; // synchronization, not device I/O or anything like that). This intrinsic; // is really badly designed in the sense that in theory, there isn't; // any way to safely use it... but in practice, it mostly works; // to use it with non-atomic loads and stores to get acquire/release; // semantics.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp:365,Performance,load,loads,365,"// We assume this is supposed to correspond to a C++0x-style; // sequentially-consistent fence (i.e. this is only usable for; // synchronization, not device I/O or anything like that). This intrinsic; // is really badly designed in the sense that in theory, there isn't; // any way to safely use it... but in practice, it mostly works; // to use it with non-atomic loads and stores to get acquire/release; // semantics.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp:285,Safety,safe,safely,285,"// We assume this is supposed to correspond to a C++0x-style; // sequentially-consistent fence (i.e. this is only usable for; // synchronization, not device I/O or anything like that). This intrinsic; // is really badly designed in the sense that in theory, there isn't; // any way to safely use it... but in practice, it mostly works; // to use it with non-atomic loads and stores to get acquire/release; // semantics.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp:114,Usability,usab,usable,114,"// We assume this is supposed to correspond to a C++0x-style; // sequentially-consistent fence (i.e. this is only usable for; // synchronization, not device I/O or anything like that). This intrinsic; // is really badly designed in the sense that in theory, there isn't; // any way to safely use it... but in practice, it mostly works; // to use it with non-atomic loads and stores to get acquire/release; // semantics.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp:141,Safety,safe,safe,141,"// Get the annotation string, go through casts. Sema requires this to be a; // non-wide string literal, potentially casted, so the cast<> is safe.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp:3,Modifiability,Extend,Extend,3,// Extend each operand to the encompassing type.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp:32,Modifiability,extend,extended,32,// Perform the operation on the extended values.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp:3,Performance,Perform,Perform,3,// Perform the operation on the extended values.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp:56,Modifiability,extend,extend,56,"// To see if the truncation caused an overflow, we will extend; // the result and then compare it to the original result.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp:49,Performance,load,loads,49,// These builtins exist to emit regular volatile loads and stores not; // affected by the -fms-volatile setting.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp:3,Testability,Test,Testing,3,// Testing which overloaded version we should generate the call for.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp:33,Availability,reliab,reliably,33,"// Lower this manually. We can't reliably determine whether or not any; // given va_copy() is for a Win64 va_list from the calling convention; // alone, because it's legal to do this from a System V ABI function.; // With opaque pointer types, we won't have enough information in LLVM; // IR to determine this from the argument types, either. Best to do it; // now, while we have enough information.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp:99,Availability,down,down,99,"// Check that a call to a target specific builtin has the correct target; // features.; // This is down here to avoid non-target specific builtins, however, if; // generic builtins start to require generic target features then we; // can move this up to the beginning of the function.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp:112,Safety,avoid,avoid,112,"// Check that a call to a target specific builtin has the correct target; // features.; // This is down here to avoid non-target specific builtins, however, if; // generic builtins start to require generic target features then we; // can move this up to the beginning of the function.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp:25,Performance,perform,perform,25,// NOTE we don't need to perform a compatibility flag check here since the; // intrinsics are declared in Builtins*.def via LANGBUILTIN which filter the; // MS builtins via ALL_MS_LANGUAGES and are filtered earlier.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp:139,Availability,error,error,139,"// When compiling in HipStdPar mode we have to be conservative in rejecting; // target specific features in the FE, and defer the possible error to the; // AcceleratorCodeSelection pass, wherein iff an unsupported target builtin is; // referenced by an accelerator executable function, we emit an error.; // Returning nullptr here leads to the builtin being handled in; // EmitStdParUnsupportedBuiltin.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp:297,Availability,error,error,297,"// When compiling in HipStdPar mode we have to be conservative in rejecting; // target specific features in the FE, and defer the possible error to the; // AcceleratorCodeSelection pass, wherein iff an unsupported target builtin is; // referenced by an accelerator executable function, we emit an error.; // Returning nullptr here leads to the builtin being handled in; // EmitStdParUnsupportedBuiltin.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp:3,Modifiability,Extend,Extend,3,// Extend 32 bit write value to 64 bit to pass to write.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp:96,Safety,avoid,avoid,96,// Handle 64-bit integer elements as a special case. Use shuffles of; // one-element vectors to avoid poor code for i64 in the backend.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp:3,Performance,Load,Load,3,// Load the value as a one-element vector.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp:103,Safety,avoid,avoid,103,// Handle 64-bit integer elements as a special case. Use a shuffle to get; // a one-element vector and avoid poor code for i64 in the backend.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp:80,Usability,simpl,simply,80,"// An unsigned shift of the full lane size always generates zero, so we can; // simply emit a zero vector. A signed shift of the full lane size does the; // same thing as shifting by one bit fewer.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp:312,Integrability,depend,depending,312,"// Convert one MVE vector type into another by reinterpreting its in-register; // format.; //; // Little-endian, this is identical to a bitcast (which reinterprets the; // memory format). But big-endian, they're not necessarily the same, because; // the register and memory formats map to each other differently depending on; // the lane size.; //; // We generate a bitcast whenever we can (if we're little-endian, or if the; // lane sizes are the same anyway). Otherwise we fall back to an IR intrinsic; // that performs the different kind of reinterpretation.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp:513,Performance,perform,performs,513,"// Convert one MVE vector type into another by reinterpreting its in-register; // format.; //; // Little-endian, this is identical to a bitcast (which reinterprets the; // memory format). But big-endian, they're not necessarily the same, because; // the register and memory formats map to each other differently depending on; // the lane size.; //; // We generate a bitcast whenever we can (if we're little-endian, or if the; // lane sizes are the same anyway). Otherwise we fall back to an IR intrinsic; // that performs the different kind of reinterpretation.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp:54,Usability,simpl,simple,54,// Code autogenerated by Tablegen will handle all the simple builtins.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp:78,Security,access,access,78,/// SVEBuiltinMemEltTy - Returns the memory element type for this memory; /// access builtin. Only required if it can't be inferred from the base pointer; /// operand.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp:169,Performance,load,loaded,169,"// At the ACLE level there's only one predicate type, svbool_t, which is; // mapped to <n x 16 x i1>. However, this might be incompatible with the; // actual type being loaded. For example, when loading doubles (i64) the; // predicate should be <n x 2 x i1> instead. At the IR level the type of; // the predicate and the data being loaded must match. Cast to the type; // expected by the intrinsic. The intrinsic itself should be defined in; // a way than enforces relations between parameter types.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp:195,Performance,load,loading,195,"// At the ACLE level there's only one predicate type, svbool_t, which is; // mapped to <n x 16 x i1>. However, this might be incompatible with the; // actual type being loaded. For example, when loading doubles (i64) the; // predicate should be <n x 2 x i1> instead. At the IR level the type of; // the predicate and the data being loaded must match. Cast to the type; // expected by the intrinsic. The intrinsic itself should be defined in; // a way than enforces relations between parameter types.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp:332,Performance,load,loaded,332,"// At the ACLE level there's only one predicate type, svbool_t, which is; // mapped to <n x 16 x i1>. However, this might be incompatible with the; // actual type being loaded. For example, when loading doubles (i64) the; // predicate should be <n x 2 x i1> instead. At the IR level the type of; // the predicate and the data being loaded must match. Cast to the type; // expected by the intrinsic. The intrinsic itself should be defined in; // a way than enforces relations between parameter types.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp:12,Performance,load,load,12,// Does the load have an offset?,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp:80,Performance,load,loaded,80,// The vector type that is returned may be different from the; // eventual type loaded from memory.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp:12,Performance,load,load,12,// Does the load have an offset?,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp:22,Performance,scalab,scalable,22,// Limit the usage of scalable llvm IR generated by the ACLE by using the; // sve dup.x intrinsic instead of IRBuilder::CreateVectorSplat.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp:63,Safety,safe,safely,63,// Immediates for SVE llvm intrinsics are always 32bit. We can safely; // truncate because the immediate has been range checked and no valid; // immediate requires more than a handful of bits.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp:3,Performance,Load,Load,3,"// Load from the address via an LLVM intrinsic, receiving a; // tuple of 8 i64 words, and store each one to ValPtr.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp:3,Performance,Load,Load,3,"// Load 8 i64 words from ValPtr, and store them to the address; // via an LLVM intrinsic.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp:3,Performance,Load,Load,3,// Load x18 + offset,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp:40,Security,access,access,40,// Now adjust things to handle the lane access.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp:22,Integrability,inject,injected,22,"// A sequence number, injected into IR builtin functions, to; // prevent CSE given the only difference of the function; // may just be the debuginfo metadata.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp:22,Security,inject,injected,22,"// A sequence number, injected into IR builtin functions, to; // prevent CSE given the only difference of the function; // may just be the debuginfo metadata.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp:15,Availability,mask,mask,15,// Convert the mask from an integer type to a vector of i1.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp:54,Availability,mask,mask,54,"// If we have less than 8 elements, then the starting mask was an i8 and; // we need to extract down to the right number of elements.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp:96,Availability,down,down,96,"// If we have less than 8 elements, then the starting mask was an i8 and; // we need to extract down to the right number of elements.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp:138,Energy Efficiency,power,power-of-,138,"// Amount may be scalar immediate, in which case create a splat vector.; // Funnel shifts amounts are treated as modulo and types are all power-of-2 so; // we only care about the lowest log2 bits anyway.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp:10,Availability,mask,mask,10,// If the mask is all ones just return first argument.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp:10,Availability,mask,mask,10,// If the mask is all ones just return first argument.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp:23,Availability,mask,masking,23,// Handle any required masking.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp:51,Availability,mask,masking,51,"// If we have more than 3 arguments, we need to do masking.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp:3,Usability,Clear,Clear,3,// Clear the upper bits.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp:10,Availability,mask,masked,10,// Emit a masked pternlog intrinsic. This only exists because the header has to; // use a macro and we aren't able to pass the input argument to a pternlog; // builtin and a select builtin without evaluating it twice.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp:67,Deployability,upgrade,upgrade,67,// If the SAE intrinsic doesn't use default rounding then we can't upgrade.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp:3,Performance,Perform,Perform,3,// Perform the fp-extension.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp:33,Security,access,access,33,// Calculate the index needed to access the correct field based on the; // range. Also adjust the expected value.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp:97,Safety,avoid,avoid,97,"// These exist so that the builtin that takes an immediate can be bounds; // checked by clang to avoid passing bad immediates to the backend. Since; // AVX has a larger immediate than SSE we would need separate builtins to; // do the different bounds checking. Rather than create a clang specific; // SSE only builtin, this implements eight separate builtins to match gcc; // implementation.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp:96,Performance,optimiz,optimizing,96,"// The x86 definition of ""undef"" is not the same as the LLVM definition; // (PR32176). We leave optimizing away an unnecessary zero constant to the; // IR optimizer and backend.; // TODO: If we had a ""freeze"" IR instruction to generate a fixed undef; // value, we should use that here instead of a zero.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp:155,Performance,optimiz,optimizer,155,"// The x86 definition of ""undef"" is not the same as the LLVM definition; // (PR32176). We leave optimizing away an unnecessary zero constant to the; // IR optimizer and backend.; // TODO: If we had a ""freeze"" IR instruction to generate a fixed undef; // value, we should use that here instead of a zero.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp:58,Integrability,wrap,wrap,58,// Splat the 8-bits of immediate 4 times to help the loop wrap around.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp:58,Integrability,wrap,wrap,58,// Splat the 8-bits of immediate 4 times to help the loop wrap around.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp:58,Integrability,wrap,wrap,58,// Splat the 8-bits of immediate 4 times to help the loop wrap around.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp:58,Integrability,wrap,wrap,58,// Splat the 8-bits of immediate 4 times to help the loop wrap around.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp:3,Availability,Mask,Mask,3,// Mask the shift amount to width of a vector.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp:21,Usability,simpl,simple,21,"// This takes a very simple approach since there are two lanes and a; // shuffle can have 2 inputs. So we reserve the first input for the first; // lane and the second input for the second lane. This may result in; // duplicate sources, but this can be dealt with in the backend.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp:64,Availability,mask,mask,64,"// Bitcast to vXi1 type and then back to integer. This gets the mask; // register type into the IR, but might be optimized out depending on; // what's around it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp:127,Integrability,depend,depending,127,"// Bitcast to vXi1 type and then back to integer. This gets the mask; // register type into the IR, but might be optimized out depending on; // what's around it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp:113,Performance,optimiz,optimized,113,"// Bitcast to vXi1 type and then back to integer. This gets the mask; // register type into the IR, but might be optimized out depending on; // what's around it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp:199,Availability,mask,mask,199,"// If the predicate is true or false and we're using constrained intrinsics,; // we don't have a compare intrinsic we can use. Just use the legacy X86; // specific intrinsic.; // If the intrinsic is mask enabled and we're using constrained intrinsics,; // use the legacy X86 specific intrinsic.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp:30,Modifiability,extend,extend,30,"// Flip low/high ops and zero-extend amount to matching type.; // shiftleft128(Low, High, Amt) -> fshl(High, Low, Amt); // shiftright128(Low, High, Amt) -> fshr(High, Low, Amt)",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp:134,Performance,optimiz,optimized,134,"// We treat __stosb as a volatile memset - it may not generate ""rep stosb""; // instruction, but it will create a memset that won't be optimized away.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp:43,Availability,failure,failure,43,// This syscall signals a driver assertion failure in x86 NT kernels.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp:33,Testability,assert,assertion,33,// This syscall signals a driver assertion failure in x86 NT kernels.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp:181,Testability,test,testing,181,"// Do not emit the builtin arguments in the arguments of a function call,; // because the evaluation order of function arguments is not specified in C++.; // This is important when testing to ensure the arguments are emitted in the; // same order every time. Eg:; // Instead of:; // return Builder.CreateFDiv(EmitScalarExpr(E->getArg(0)),; // EmitScalarExpr(E->getArg(1)), ""swdiv"");; // Use:; // Value *Op0 = EmitScalarExpr(E->getArg(0));; // Value *Op1 = EmitScalarExpr(E->getArg(1));; // return Builder.CreateFDiv(Op0, Op1, ""swdiv"")",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp:44,Energy Efficiency,Power,PowerPC-specific,44,// __builtin_ppc_get_timebase is GCC 4.8+'s PowerPC-specific name for what we; // call __builtin_readcyclecounter.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp:21,Availability,down,down,21,// Essentially boils down to performing an unaligned VMX load sequence so; // as to avoid crossing a page boundary and then shuffling the elements; // into the right side of the vector register.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp:29,Performance,perform,performing,29,// Essentially boils down to performing an unaligned VMX load sequence so; // as to avoid crossing a page boundary and then shuffling the elements; // into the right side of the vector register.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp:57,Performance,load,load,57,// Essentially boils down to performing an unaligned VMX load sequence so; // as to avoid crossing a page boundary and then shuffling the elements; // into the right side of the vector register.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp:84,Safety,avoid,avoid,84,// Essentially boils down to performing an unaligned VMX load sequence so; // as to avoid crossing a page boundary and then shuffling the elements; // into the right side of the vector register.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp:45,Performance,load,load,45,"// If the user wants the entire vector, just load the entire vector.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp:29,Usability,simpl,simply,29,"// Storing the whole vector, simply store it on BE and reverse bytes and; // store on LE.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp:41,Integrability,depend,dependent,41,// Valid value for the third argument is dependent on the input type and; // builtin called.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp:26,Availability,error,error,26,// Compose range checking error message.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp:32,Integrability,message,message,32,// Compose range checking error message.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp:9,Availability,error,error,9,// Issue error if third argument is not within the valid range.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp:27,Availability,mask,mask,27,"// Rotate and insert under mask operation.; // __rldimi(rs, is, shift, mask); // (rotl64(rs, shift) & mask) | (is & ~mask); // __rlwimi(rs, is, shift, mask); // (rotl(rs, shift) & mask) | (is & ~mask)",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp:71,Availability,mask,mask,71,"// Rotate and insert under mask operation.; // __rldimi(rs, is, shift, mask); // (rotl64(rs, shift) & mask) | (is & ~mask); // __rlwimi(rs, is, shift, mask); // (rotl(rs, shift) & mask) | (is & ~mask)",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp:102,Availability,mask,mask,102,"// Rotate and insert under mask operation.; // __rldimi(rs, is, shift, mask); // (rotl64(rs, shift) & mask) | (is & ~mask); // __rlwimi(rs, is, shift, mask); // (rotl(rs, shift) & mask) | (is & ~mask)",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp:117,Availability,mask,mask,117,"// Rotate and insert under mask operation.; // __rldimi(rs, is, shift, mask); // (rotl64(rs, shift) & mask) | (is & ~mask); // __rlwimi(rs, is, shift, mask); // (rotl(rs, shift) & mask) | (is & ~mask)",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp:151,Availability,mask,mask,151,"// Rotate and insert under mask operation.; // __rldimi(rs, is, shift, mask); // (rotl64(rs, shift) & mask) | (is & ~mask); // __rlwimi(rs, is, shift, mask); // (rotl(rs, shift) & mask) | (is & ~mask)",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp:180,Availability,mask,mask,180,"// Rotate and insert under mask operation.; // __rldimi(rs, is, shift, mask); // (rotl64(rs, shift) & mask) | (is & ~mask); // __rlwimi(rs, is, shift, mask); // (rotl(rs, shift) & mask) | (is & ~mask)",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp:195,Availability,mask,mask,195,"// Rotate and insert under mask operation.; // __rldimi(rs, is, shift, mask); // (rotl64(rs, shift) & mask) | (is & ~mask); // __rlwimi(rs, is, shift, mask); // (rotl(rs, shift) & mask) | (is & ~mask)",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp:27,Availability,mask,mask,27,"// Rotate and insert under mask operation.; // __rlwnm(rs, shift, mask); // rotl(rs, shift) & mask",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp:66,Availability,mask,mask,66,"// Rotate and insert under mask operation.; // __rlwnm(rs, shift, mask); // rotl(rs, shift) & mask",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp:94,Availability,mask,mask,94,"// Rotate and insert under mask operation.; // __rlwnm(rs, shift, mask); // rotl(rs, shift) & mask",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp:20,Availability,mask,mask,20,// Create a shuffle mask,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp:305,Performance,load,load,305,// The PPC MMA builtins take a pointer to a __vector_quad as an argument.; // Some of the MMA instructions accumulate their result into an existing; // accumulator whereas the others generate a new accumulator. So we need to; // use custom code generation to expand a builtin call with a pointer to a; // load (if the corresponding instruction accumulates its result) followed by; // the call to the intrinsic and a store of the result.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp:249,Modifiability,variab,variable,249,"// \p Index is 0, 1, and 2 for x, y, and z dimension, respectively.; /// Emit code based on Code Object ABI version.; /// COV_4 : Emit code to use dispatch ptr; /// COV_5 : Emit code to use implicitarg ptr; /// COV_NONE : Emit code to load a global variable ""__oclc_ABI_version""; /// and use its value for COV_4 or COV_5 approach. It is used for; /// compiling device libraries in an ABI-agnostic way.; ///; /// Note: ""__oclc_ABI_version"" is supposed to be emitted and intialized by; /// clang during compilation of user code.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp:235,Performance,load,load,235,"// \p Index is 0, 1, and 2 for x, y, and z dimension, respectively.; /// Emit code based on Code Object ABI version.; /// COV_4 : Emit code to use dispatch ptr; /// COV_5 : Emit code to use implicitarg ptr; /// COV_NONE : Emit code to load a global variable ""__oclc_ABI_version""; /// and use its value for COV_4 or COV_5 approach. It is used for; /// compiling device libraries in an ABI-agnostic way.; ///; /// Note: ""__oclc_ABI_version"" is supposed to be emitted and intialized by; /// clang during compilation of user code.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp:8,Performance,load,load,8,// This load will be eliminated by the IPSCCP because it is constant; // weak_odr without externally_initialized. Either changing it to weak or; // adding externally_initialized will keep the load.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp:192,Performance,load,load,192,// This load will be eliminated by the IPSCCP because it is constant; // weak_odr without externally_initialized. Either changing it to weak or; // adding externally_initialized will keep the load.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp:34,Availability,mask,mask,34,// FIXME-GFX10: How should 32 bit mask be handled?,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp:34,Availability,mask,mask,34,// FIXME-GFX10: How should 32 bit mask be handled?,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp:20,Performance,perform,perform,20,// These operations perform a matrix multiplication and accumulation of; // the form:; // D = A * B + C; // We need to specify one type for matrices AB and one for matrices CD.; // Sparse matrix operations can have different types for A and B as well as; // an additional type for sparsity index.; // Destination type should be put before types used for source operands.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp:102,Modifiability,variab,variable,102,"// On GFX12, the intrinsics with 16-bit accumulator use a packed layout.; // There is no need for the variable opsel argument, so always set it to; // ""false"".",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp:239,Performance,optimiz,optimizations,239,"// Vector builtins. Note that most vector builtins are mapped automatically; // to target-specific LLVM intrinsics. The ones handled specially here can; // be represented via standard LLVM IR, which is preferable to enable common; // LLVM optimizations.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp:31,Availability,mask,mask,31,// Constant-fold the M4 and M5 mask arguments.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp:24,Availability,mask,mask,24,// Constant-fold the M4 mask argument.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp:24,Availability,mask,mask,24,// Constant-fold the M4 mask argument.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp:25,Performance,load,load,25,// Number of elements to load/store; // Intrinsic IDs for row/col variants. 0 if particular layout is unsupported.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp:10,Performance,load,loads,10,// FP MMA loads,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp:15,Performance,load,loads,15,// Integer MMA loads,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp:66,Deployability,A/B,A/B,66,// Sub-integer MMA loads.; // Only row/col layout is supported by A/B fragments.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp:19,Performance,load,loads,19,// Sub-integer MMA loads.; // Only row/col layout is supported by A/B fragments.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp:14,Performance,load,loads,14,// Double MMA loads,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp:23,Performance,load,loads,23,// Alternate float MMA loads,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp:179,Performance,load,loads,179,"// NOTE: We need to follow inconsitent naming scheme used by NVCC. Unlike; // PTX and LLVM IR where stores always use fragment D, NVCC builtins always; // use fragment C for both loads and stores.; // FP MMA stores.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp:135,Performance,load,loads,135,"// Integer and sub-integer MMA stores.; // Another naming quirk. Unlike other MMA builtins that use PTX types in the; // name, integer loads/stores use LLVM's i32.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp:163,Usability,undo,undocumented,163,"// Variants are ordered by layout-A/layout-B/satf, where 'row' has priority; // over 'col' for layout. The index of non-satf variants is expected to match; // the undocumented layout constants used by CUDA's mma.hpp.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp:7,Integrability,Interoperab,Interoperability,7,"// PTX Interoperability section 2.2: ""For a vector with an even number of; // elements, its alignment is set to number of elements times the alignment; // of its member: n*alignof(t).""",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp:10,Performance,load,loads,10,// FP MMA loads,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp:15,Performance,load,loads,15,// Integer MMA loads.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp:19,Performance,load,loads,19,// Sub-integer MMA loads.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp:14,Performance,load,loads,14,// Double MMA loads.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp:23,Performance,load,loads,23,// Alternate float MMA loads.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp:3,Performance,Load,Load,3,// Load A,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp:3,Performance,Load,Load,3,// Load B,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp:3,Performance,Load,Load,3,// Load C,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp:35,Availability,down,down,35,/// Generate (x & ~(y-1)) to align down or ((x+(y-1)) & ~(y-1)) to align up.; /// Note: For pointer types we can avoid ptrtoint/inttoptr pairs by using the; /// llvm.ptrmask intrinsic (with a GEP before in the align_up case).,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp:113,Safety,avoid,avoid,113,/// Generate (x & ~(y-1)) to align down or ((x+(y-1)) & ~(y-1)) to align up.; /// Note: For pointer types we can avoid ptrtoint/inttoptr pairs by using the; /// llvm.ptrmask intrinsic (with a GEP before in the align_up case).,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp:45,Availability,mask,mask,45,"// When aligning up we have to first add the mask to ensure we go over the; // next alignment value and then align down to the next valid multiple.; // By adding the mask, we ensure that align_up on an already aligned; // value will not change the value.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp:115,Availability,down,down,115,"// When aligning up we have to first add the mask to ensure we go over the; // next alignment value and then align down to the next valid multiple.; // By adding the mask, we ensure that align_up on an already aligned; // value will not change the value.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp:166,Availability,mask,mask,166,"// When aligning up we have to first add the mask to ensure we go over the; // next alignment value and then align down to the next valid multiple.; // By adding the mask, we ensure that align_up on an already aligned; // value will not change the value.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp:14,Availability,mask,mask,14,// Invert the mask to only clear the lower bits.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp:27,Usability,clear,clear,27,// Invert the mask to only clear the lower bits.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp:60,Performance,load,loaded,60,"// The base pointer is passed by address, so it needs to be loaded.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp:25,Performance,load,loads,25,"// The treatment of both loads and stores is the same: the arguments for; // the builtin are the same as the arguments for the intrinsic.; // Load:; // builtin(Base, Inc, Mod, Start) -> intr(Base, Inc, Mod, Start); // builtin(Base, Mod, Start) -> intr(Base, Mod, Start); // Store:; // builtin(Base, Inc, Mod, Val, Start) -> intr(Base, Inc, Mod, Val, Start); // builtin(Base, Mod, Val, Start) -> intr(Base, Mod, Val, Start)",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp:142,Performance,Load,Load,142,"// The treatment of both loads and stores is the same: the arguments for; // the builtin are the same as the arguments for the intrinsic.; // Load:; // builtin(Base, Inc, Mod, Start) -> intr(Base, Inc, Mod, Start); // builtin(Base, Mod, Start) -> intr(Base, Mod, Start); // Store:; // builtin(Base, Inc, Mod, Val, Start) -> intr(Base, Inc, Mod, Val, Start); // builtin(Base, Mod, Val, Start) -> intr(Base, Mod, Val, Start)",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp:7,Performance,load,load,7,"// The load intrinsics generate two results (Value, NewBase), stores; // generate one (NewBase). The new base address needs to be stored.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp:40,Performance,load,load,40,// Handle the conversion of bit-reverse load intrinsics to bit code.; // The intrinsic call after this function only reads from memory and the; // write to memory is dealt by the store instruction.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp:131,Performance,load,load,131,"// The intrinsic generates one result, which is the new value for the base; // pointer. It needs to be returned. The result of the load instruction is; // passed to intrinsic by address, so the value needs to be stored.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp:39,Modifiability,variab,variable,39,// The value needs to be stored as the variable is passed by reference.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp:7,Deployability,update,updated,7,// The updated value of the base pointer is returned.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp:129,Deployability,update,update,129,"// These intrinsics return a tuple {Vector, VectorPred} in LLVM IR,; // and the corresponding C/C++ builtins use loads/stores to update; // the predicate.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp:113,Performance,load,loads,113,"// These intrinsics return a tuple {Vector, VectorPred} in LLVM IR,; // and the corresponding C/C++ builtins use loads/stores to update; // the predicate.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp:200,Performance,load,load,200,"// These are identical to the builtins above, except they don't consume; // input carry, only generate carry-out. Since they still produce two; // outputs, generate the store of the predicate, but no load.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp:64,Performance,load,load,64,"// Handle aggregate argument, namely RVV tuple types in segment load/store",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCall.cpp:397,Integrability,wrap,wrap,397,"//===--- CGCall.cpp - Encapsulate calling convention details --------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // These classes wrap the information about a call or function; // definition used to handle ABI compliancy.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGCall.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCall.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCall.cpp:87,Modifiability,inherit,inherited,87,// Parameters are unnecessary if we're constructing a base class subobject; // and the inherited constructor lives in a virtual base.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGCall.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCall.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCall.cpp:16,Modifiability,inherit,inheriting,16,// A base class inheriting constructor doesn't get forwarded arguments; // needed to construct a virtual base (or base class thereof).,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGCall.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCall.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCall.cpp:352,Integrability,message,message,352,"/// Arrange the argument and result information for the function type; /// through which to perform a send to the given Objective-C method,; /// using the given receiver type. The receiver type is not always; /// the 'self' type of the method or even an Objective-C pointer type.; /// This is *not* the right method for actually performing such a; /// message send, due to the possibility of optional arguments.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGCall.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCall.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCall.cpp:92,Performance,perform,perform,92,"/// Arrange the argument and result information for the function type; /// through which to perform a send to the given Objective-C method,; /// using the given receiver type. The receiver type is not always; /// the 'self' type of the method or even an Objective-C pointer type.; /// This is *not* the right method for actually performing such a; /// message send, due to the possibility of optional arguments.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGCall.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCall.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCall.cpp:329,Performance,perform,performing,329,"/// Arrange the argument and result information for the function type; /// through which to perform a send to the given Objective-C method,; /// using the given receiver type. The receiver type is not always; /// the 'self' type of the method or even an Objective-C pointer type.; /// This is *not* the right method for actually performing such a; /// message send, due to the possibility of optional arguments.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGCall.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCall.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCall.cpp:215,Integrability,depend,dependent,215,"/// Figure out the rules for calling a function with the given formal; /// type using the given arguments. The arguments are necessary; /// because the function might be unprototyped, in which case it's; /// target-dependent in crazy ways.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGCall.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCall.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCall.cpp:38,Energy Efficiency,allocate,allocate,38,// Construct the function info. We co-allocate the ArgInfos.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGCall.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCall.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCall.cpp:98,Modifiability,extend,extend,98,"// Loop over all of the computed argument and return value info. If any of; // them are direct or extend without a specified coerce type, specify the; // default now.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGCall.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCall.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCall.cpp:3,Performance,Perform,Perform,3,// Perform a single step derived-to-base conversion.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGCall.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCall.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCall.cpp:3,Performance,Perform,Perform,3,// Perform a single step derived-to-base conversion.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGCall.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCall.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCall.cpp:81,Security,access,accessing,81,"/// EnterStructPointerForCoercedAccess - Given a struct pointer that we are; /// accessing some number of bytes out of it, try to gep into the struct to get; /// at its inner goodness. Dive as deep as possible without entering an element; /// with an in-memory size smaller than DstSize.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGCall.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCall.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCall.cpp:282,Performance,load,load,282,"// If the first elt is at least as large as what we're looking for, or if the; // first element is the same size as the whole struct, we can enter it. The; // comparison must be made on the store size and not the alloca size. Using; // the alloca size may overstate the size of the load.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGCall.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCall.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCall.cpp:31,Safety,avoid,avoid,31,// If this is Pointer->Pointer avoid conversion to and from int.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGCall.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCall.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCall.cpp:33,Performance,load,load,33,"/// CreateCoercedLoad - Create a load from \arg SrcPtr interpreted as; /// a pointer to an object of type \arg Ty, known to be aligned to; /// \arg SrcAlign bytes.; ///; /// This safely handles the case when the src type is smaller than the; /// destination type; in this situation the values of bits which not; /// present in the src are undefined.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGCall.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCall.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCall.cpp:179,Safety,safe,safely,179,"/// CreateCoercedLoad - Create a load from \arg SrcPtr interpreted as; /// a pointer to an object of type \arg Ty, known to be aligned to; /// \arg SrcAlign bytes.; ///; /// This safely handles the case when the src type is smaller than the; /// destination type; in this situation the values of bits which not; /// present in the src are undefined.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGCall.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCall.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCall.cpp:43,Performance,load,load,43,"// If SrcTy and Ty are the same, just do a load.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGCall.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCall.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCall.cpp:6,Performance,load,load,6,"// If load is legal, just bitcast the src pointer.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGCall.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCall.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCall.cpp:297,Security,access,access,297,"// Generally SrcSize is never greater than DstSize, since this means we are; // losing bits. However, this can happen in cases where the structure has; // additional padding, for example due to a user specified alignment.; //; // FIXME: Assert that we aren't truncating non-padding bits when have access; // to that information.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGCall.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCall.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCall.cpp:237,Testability,Assert,Assert,237,"// Generally SrcSize is never greater than DstSize, since this means we are; // losing bits. However, this can happen in cases where the structure has; // additional padding, for example due to a user specified alignment.; //; // FIXME: Assert that we aren't truncating non-padding bits when have access; // to that information.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGCall.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCall.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCall.cpp:35,Performance,scalab,scalable,35,"// If coercing a fixed vector to a scalable vector for ABI compatibility, and; // the types match, use the llvm.vector.insert intrinsic to perform the; // conversion.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGCall.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCall.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCall.cpp:139,Performance,perform,perform,139,"// If coercing a fixed vector to a scalable vector for ABI compatibility, and; // the types match, use the llvm.vector.insert intrinsic to perform the; // conversion.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGCall.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCall.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCall.cpp:44,Performance,scalab,scalable,44,"// If we are casting a fixed i8 vector to a scalable 16 x i1 predicate; // vector, use a vector insert and bitcast the result.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGCall.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCall.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCall.cpp:61,Usability,simpl,simple,61,"// Otherwise do coercion through memory. This is stupid, but simple.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGCall.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCall.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCall.cpp:217,Safety,safe,safely,217,"/// CreateCoercedStore - Create a store to \arg DstPtr from \arg Src,; /// where the source and destination may have different types. The; /// destination is known to be aligned to \arg DstAlign bytes.; ///; /// This safely handles the case when the src type is larger than the; /// destination type; the upper bits of the src will be lost.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGCall.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCall.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCall.cpp:371,Security,access,access,371,"// Otherwise do coercion through memory. This is stupid, but; // simple.; // Generally SrcSize is never greater than DstSize, since this means we are; // losing bits. However, this can happen in cases where the structure has; // additional padding, for example due to a user specified alignment.; //; // FIXME: Assert that we aren't truncating non-padding bits when have access; // to that information.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGCall.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCall.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCall.cpp:311,Testability,Assert,Assert,311,"// Otherwise do coercion through memory. This is stupid, but; // simple.; // Generally SrcSize is never greater than DstSize, since this means we are; // losing bits. However, this can happen in cases where the structure has; // additional padding, for example due to a user specified alignment.; //; // FIXME: Assert that we aren't truncating non-padding bits when have access; // to that information.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGCall.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCall.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCall.cpp:65,Usability,simpl,simple,65,"// Otherwise do coercion through memory. This is stupid, but; // simple.; // Generally SrcSize is never greater than DstSize, since this means we are; // losing bits. However, this can happen in cases where the structure has; // additional padding, for example due to a user specified alignment.; //; // FIXME: Assert that we aren't truncating non-padding bits when have access; // to that information.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGCall.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCall.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCall.cpp:21,Performance,optimiz,optimizer,21,"// Fast-isel and the optimizer generally like scalar values better than; // FCAs, so we flatten them if this is safe to do for this argument.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGCall.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCall.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCall.cpp:112,Safety,safe,safe,112,"// Fast-isel and the optimizer generally like scalar values better than; // FCAs, so we flatten them if this is safe to do for this argument.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGCall.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCall.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCall.cpp:22,Availability,toler,tolerate,22,// As-is msan can not tolerate noundef mismatch between caller and; // implementation. Mismatch is possible for e.g. indirect calls from C-caller; // into C++. Such mismatches lead to confusing false reports. To avoid; // expensive workaround on msan we enforce initialization event in uncommon; // cases where it's allowed.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGCall.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCall.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCall.cpp:212,Safety,avoid,avoid,212,// As-is msan can not tolerate noundef mismatch between caller and; // implementation. Mismatch is possible for e.g. indirect calls from C-caller; // into C++. Such mismatches lead to confusing false reports. To avoid; // expensive workaround on msan we enforce initialization event in uncommon; // cases where it's allowed.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGCall.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCall.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCall.cpp:136,Security,sanitiz,sanitizer,136,"// We don't want to be too aggressive with the return checking, unless; // it's explicit in the code opts or we're using an appropriate sanitizer.; // Try to respect what the programmer intended.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGCall.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCall.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCall.cpp:118,Usability,simpl,simply,118,"/// Add default attributes to a function, which have merge semantics under; /// -mlink-builtin-bitcode and should not simply overwrite any existing; /// attributes in the linked library.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGCall.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCall.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCall.cpp:3,Performance,Optimiz,OptimizeNoneAttr,3,// OptimizeNoneAttr takes precedence over -Os or -Oz. No warning needed.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGCall.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCall.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCall.cpp:35,Safety,unsafe,unsafe,35,// TODO: Are these all needed?; // unsafe/inf/nan/nsz are handled by instruction-level FastMathFlags.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGCall.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCall.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCall.cpp:208,Performance,optimiz,optimizations,208,"// Conservatively, mark all functions and calls in CUDA and OpenCL as; // convergent (meaning, they may call an intrinsically convergent op, such; // as __syncthreads() / barrier(), and so can't have certain optimizations; // applied around them). LLVM will remove this attribute where it safely; // can.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGCall.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCall.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCall.cpp:289,Safety,safe,safely,289,"// Conservatively, mark all functions and calls in CUDA and OpenCL as; // convergent (meaning, they may call an intrinsically convergent op, such; // as __syncthreads() / barrier(), and so can't have certain optimizations; // applied around them). LLVM will remove this attribute where it safely; // can.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGCall.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCall.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCall.cpp:52,Integrability,depend,depends,52,"// TODO: Some member pointers are `noundef`, but it depends on the ABI. For; // now, never mark them.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGCall.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCall.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCall.cpp:4,Testability,Test,Test,4,/// Test if it's legal to apply nofpclass for the given parameter type and it's; /// lowered IR type.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGCall.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCall.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCall.cpp:25,Availability,mask,mask,25,/// Return the nofpclass mask that can be applied to floating-point parameters.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGCall.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCall.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCall.cpp:250,Deployability,configurat,configuration,250,"/// Construct the IR attribute list of a function or call.; ///; /// When adding an attribute, please consider where it should be handled:; ///; /// - getDefaultFunctionAttributes is for attributes that are essentially; /// part of the global target configuration (but perhaps can be; /// overridden on a per-function basis). Adding attributes there; /// will cause them to also be set in frontends that build on Clang's; /// target-configuration logic, as well as for code defined in library; /// modules such as CUDA's libdevice.; ///; /// - ConstructAttributeList builds on top of getDefaultFunctionAttributes; /// and adds declaration-specific, convention-specific, and; /// frontend-specific logic. The last is of particular importance:; /// attributes that restrict how the frontend generates code must be; /// added here rather than getDefaultFunctionAttributes.; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGCall.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCall.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCall.cpp:433,Deployability,configurat,configuration,433,"/// Construct the IR attribute list of a function or call.; ///; /// When adding an attribute, please consider where it should be handled:; ///; /// - getDefaultFunctionAttributes is for attributes that are essentially; /// part of the global target configuration (but perhaps can be; /// overridden on a per-function basis). Adding attributes there; /// will cause them to also be set in frontends that build on Clang's; /// target-configuration logic, as well as for code defined in library; /// modules such as CUDA's libdevice.; ///; /// - ConstructAttributeList builds on top of getDefaultFunctionAttributes; /// and adds declaration-specific, convention-specific, and; /// frontend-specific logic. The last is of particular importance:; /// attributes that restrict how the frontend generates code must be; /// added here rather than getDefaultFunctionAttributes.; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGCall.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCall.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCall.cpp:250,Modifiability,config,configuration,250,"/// Construct the IR attribute list of a function or call.; ///; /// When adding an attribute, please consider where it should be handled:; ///; /// - getDefaultFunctionAttributes is for attributes that are essentially; /// part of the global target configuration (but perhaps can be; /// overridden on a per-function basis). Adding attributes there; /// will cause them to also be set in frontends that build on Clang's; /// target-configuration logic, as well as for code defined in library; /// modules such as CUDA's libdevice.; ///; /// - ConstructAttributeList builds on top of getDefaultFunctionAttributes; /// and adds declaration-specific, convention-specific, and; /// frontend-specific logic. The last is of particular importance:; /// attributes that restrict how the frontend generates code must be; /// added here rather than getDefaultFunctionAttributes.; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGCall.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCall.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCall.cpp:433,Modifiability,config,configuration,433,"/// Construct the IR attribute list of a function or call.; ///; /// When adding an attribute, please consider where it should be handled:; ///; /// - getDefaultFunctionAttributes is for attributes that are essentially; /// part of the global target configuration (but perhaps can be; /// overridden on a per-function basis). Adding attributes there; /// will cause them to also be set in frontends that build on Clang's; /// target-configuration logic, as well as for code defined in library; /// modules such as CUDA's libdevice.; ///; /// - ConstructAttributeList builds on top of getDefaultFunctionAttributes; /// and adds declaration-specific, convention-specific, and; /// frontend-specific logic. The last is of particular importance:; /// attributes that restrict how the frontend generates code must be; /// added here rather than getDefaultFunctionAttributes.; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGCall.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCall.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCall.cpp:447,Testability,log,logic,447,"/// Construct the IR attribute list of a function or call.; ///; /// When adding an attribute, please consider where it should be handled:; ///; /// - getDefaultFunctionAttributes is for attributes that are essentially; /// part of the global target configuration (but perhaps can be; /// overridden on a per-function basis). Adding attributes there; /// will cause them to also be set in frontends that build on Clang's; /// target-configuration logic, as well as for code defined in library; /// modules such as CUDA's libdevice.; ///; /// - ConstructAttributeList builds on top of getDefaultFunctionAttributes; /// and adds declaration-specific, convention-specific, and; /// frontend-specific logic. The last is of particular importance:; /// attributes that restrict how the frontend generates code must be; /// added here rather than getDefaultFunctionAttributes.; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGCall.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCall.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCall.cpp:697,Testability,log,logic,697,"/// Construct the IR attribute list of a function or call.; ///; /// When adding an attribute, please consider where it should be handled:; ///; /// - getDefaultFunctionAttributes is for attributes that are essentially; /// part of the global target configuration (but perhaps can be; /// overridden on a per-function basis). Adding attributes there; /// will cause them to also be set in frontends that build on Clang's; /// target-configuration logic, as well as for code defined in library; /// modules such as CUDA's libdevice.; ///; /// - ConstructAttributeList builds on top of getDefaultFunctionAttributes; /// and adds declaration-specific, convention-specific, and; /// frontend-specific logic. The last is of particular importance:; /// attributes that restrict how the frontend generates code must be; /// added here rather than getDefaultFunctionAttributes.; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGCall.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCall.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCall.cpp:38,Security,access,accesses,38,// Some ABIs may result in additional accesses to arguments that may; // otherwise not be present.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGCall.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCall.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCall.cpp:118,Modifiability,inherit,inherited,118,"// Don't use [[noreturn]], _Noreturn or [[no_builtin]] for a call to a; // virtual function. These attributes are not inherited by overloads.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGCall.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCall.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCall.cpp:102,Modifiability,variab,variable,102,// 'restrict' -> 'noalias' is done in EmitFunctionProlog when we; // have the corresponding parameter variable. It doesn't make; // sense to do it here because parameters are so messed up.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGCall.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCall.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCall.cpp:95,Testability,test,testcases,95,"// TODO: We could add the byref attribute if not byval, but it would; // require updating many testcases.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGCall.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCall.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCall.cpp:95,Testability,test,test,95,"// For now, only add this when we have a byval argument.; // TODO: be less lazy about updating test cases.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGCall.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCall.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCall.cpp:76,Usability,simpl,simplify,76,// FIXME: We no longer need the types from FunctionArgList; lift up and; // simplify.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGCall.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCall.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCall.cpp:26,Modifiability,variab,variables,26,"// Aggregates and complex variables are accessed by reference. All we; // need to do is realign the value, if requested. Also, if the address; // may be aliased, copy it to ensure that the parameter variable is; // mutable and has a unique adress, as C requires.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGCall.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCall.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCall.cpp:199,Modifiability,variab,variable,199,"// Aggregates and complex variables are accessed by reference. All we; // need to do is realign the value, if requested. Also, if the address; // may be aliased, copy it to ensure that the parameter variable is; // mutable and has a unique adress, as C requires.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGCall.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCall.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCall.cpp:40,Security,access,accessed,40,"// Aggregates and complex variables are accessed by reference. All we; // need to do is realign the value, if requested. Also, if the address; // may be aliased, copy it to ensure that the parameter variable is; // mutable and has a unique adress, as C requires.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGCall.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCall.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCall.cpp:3,Performance,Load,Load,3,// Load scalar value from indirect argument.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGCall.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCall.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCall.cpp:27,Security,sanitiz,sanitizer,27,"// If alignment-assumption sanitizer is enabled, we do *not* add; // alignment attribute here, but emit normal alignment assumption,; // so the UBSAN check could function.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGCall.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCall.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCall.cpp:23,Performance,scalab,scalable,23,"// If we are casting a scalable 16 x i1 predicate vector to a fixed i8; // vector, bitcast the source and use a vector extract.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGCall.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCall.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCall.cpp:21,Performance,optimiz,optimizer,21,"// Fast-isel and the optimizer generally like scalar values better than; // FCAs, so we flatten them if this is safe to do for this argument.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGCall.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCall.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCall.cpp:112,Safety,safe,safe,112,"// Fast-isel and the optimizer generally like scalar values better than; // FCAs, so we flatten them if this is safe to do for this argument.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGCall.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCall.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCall.cpp:3,Usability,Simpl,Simple,3,"// Simple case, just do a coerced store of the argument into the alloca.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGCall.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCall.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCall.cpp:24,Modifiability,variab,variable,24,// Initialize the local variable appropriately.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGCall.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCall.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCall.cpp:12,Safety,safe,safe,12,"// This is ""safe"" because we would have used a ConstantExpr otherwise.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGCall.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCall.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCall.cpp:185,Performance,optimiz,optimization,185,"// If we emitted an assembly marker for this call (and the; // ARCEntrypoints field should have been set if so), go looking; // for that call. If we can't find it, we can't do this; // optimization. But it should always be the immediately previous; // instruction, unless we needed bitcasts around the call.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGCall.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCall.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCall.cpp:24,Performance,load,load,24,// Look for an ordinary load of 'self'.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGCall.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCall.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCall.cpp:21,Availability,down,down,21,"// Okay! Burn it all down. This relies for correctness on the; // assumption that the retain is emitted as part of the return and; // that thereafter everything is used ""linearly"".",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGCall.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCall.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCall.cpp:228,Safety,avoid,avoid,228,"// If we're returning 'self', kill the initial retain. This is a; // heuristic attempt to ""encourage correctness"" in the really unfortunate; // case where we have a return of self during a dealloc and we desperately; // need to avoid the possible autorelease.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGCall.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCall.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCall.cpp:279,Availability,mask,mask,279,"// Set the bits in `Bits`, which correspond to the value representations of; // the actual members of the record type `RTy`. Note that this function does; // not handle base classes, virtual tables, etc, since they cannot happen in; // CMSE function arguments or return. The bit mask corresponds to the target; // memory layout, i.e. it's endian dependent.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGCall.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCall.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCall.cpp:346,Integrability,depend,dependent,346,"// Set the bits in `Bits`, which correspond to the value representations of; // the actual members of the record type `RTy`. Note that this function does; // not handle base classes, virtual tables, etc, since they cannot happen in; // CMSE function arguments or return. The bit mask corresponds to the target; // memory layout, i.e. it's endian dependent.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGCall.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCall.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCall.cpp:16,Usability,clear,clear,16,"// Emit code to clear the bits in a record, which aren't a part of any user; // declared member, when the record is a function return.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGCall.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCall.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCall.cpp:16,Usability,clear,clear,16,"// Emit code to clear the bits in a record, which aren't a part of any user; // declared member, when the record is a function argument.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGCall.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCall.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCall.cpp:3,Usability,Clear,Clear,3,// Clear each element of the LLVM array.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGCall.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCall.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCall.cpp:94,Performance,load,load,94,"// The internal return value temp always will have pointer-to-return-type; // type, just do a load.; // If there is a dominating store to ReturnValue, we can elide; // the load, zap the store, and usually zap the alloca.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGCall.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCall.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCall.cpp:172,Performance,load,load,172,"// The internal return value temp always will have pointer-to-return-type; // type, just do a load.; // If there is a dominating store to ReturnValue, we can elide; // the load, zap the store, and usually zap the alloca.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGCall.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCall.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCall.cpp:37,Performance,load,load,37,"// Otherwise, we have to do a simple load.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGCall.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCall.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCall.cpp:30,Usability,simpl,simple,30,"// Otherwise, we have to do a simple load.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGCall.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCall.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCall.cpp:3,Performance,Load,Load,3,// Load all of the coerced elements out into results.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGCall.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCall.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCall.cpp:29,Usability,clear,clear,29,"// For certain return types, clear padding bits, as they may reveal; // sensitive information.; // Small struct/union types are passed as integers.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGCall.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCall.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCall.cpp:29,Availability,avail,available,29,// A current decl may not be available when emitting vtable thunks.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGCall.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCall.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCall.cpp:54,Deployability,release,release,54,"// In ARC, move out of consumed arguments so that the release cleanup; // entered by StartFunction doesn't cause an over-release. This isn't; // optimal -O0 code generation, but it should get cleaned up when; // optimization is enabled. This also assumes that delegate calls are; // performed exactly once for a set of arguments, but that should be safe.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGCall.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCall.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCall.cpp:121,Deployability,release,release,121,"// In ARC, move out of consumed arguments so that the release cleanup; // entered by StartFunction doesn't cause an over-release. This isn't; // optimal -O0 code generation, but it should get cleaned up when; // optimization is enabled. This also assumes that delegate calls are; // performed exactly once for a set of arguments, but that should be safe.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGCall.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCall.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCall.cpp:212,Performance,optimiz,optimization,212,"// In ARC, move out of consumed arguments so that the release cleanup; // entered by StartFunction doesn't cause an over-release. This isn't; // optimal -O0 code generation, but it should get cleaned up when; // optimization is enabled. This also assumes that delegate calls are; // performed exactly once for a set of arguments, but that should be safe.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGCall.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCall.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCall.cpp:283,Performance,perform,performed,283,"// In ARC, move out of consumed arguments so that the release cleanup; // entered by StartFunction doesn't cause an over-release. This isn't; // optimal -O0 code generation, but it should get cleaned up when; // optimization is enabled. This also assumes that delegate calls are; // performed exactly once for a set of arguments, but that should be safe.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGCall.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCall.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCall.cpp:349,Safety,safe,safe,349,"// In ARC, move out of consumed arguments so that the release cleanup; // entered by StartFunction doesn't cause an over-release. This isn't; // optimal -O0 code generation, but it should get cleaned up when; // optimization is enabled. This also assumes that delegate calls are; // performed exactly once for a set of arguments, but that should be safe.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGCall.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCall.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCall.cpp:38,Performance,load,load,38,"// For the most part, we just need to load the alloca, except that; // aggregate r-values are actually pointers to temporaries.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGCall.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCall.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCall.cpp:3,Performance,Load,Load,3,// Load the value to writeback.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGCall.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCall.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCall.cpp:169,Deployability,release,release,169,"// Perform the writeback.; // If we have a ""to use"" value, it's something we need to emit a use; // of. This has to be carefully threaded in: if it's done after the; // release it's potentially undefined behavior (and the optimizer; // will ignore it), and if it happens before the retain then the; // optimizer could move the release there.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGCall.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCall.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCall.cpp:327,Deployability,release,release,327,"// Perform the writeback.; // If we have a ""to use"" value, it's something we need to emit a use; // of. This has to be carefully threaded in: if it's done after the; // release it's potentially undefined behavior (and the optimizer; // will ignore it), and if it happens before the retain then the; // optimizer could move the release there.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGCall.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCall.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCall.cpp:3,Performance,Perform,Perform,3,"// Perform the writeback.; // If we have a ""to use"" value, it's something we need to emit a use; // of. This has to be carefully threaded in: if it's done after the; // release it's potentially undefined behavior (and the optimizer; // will ignore it), and if it happens before the retain then the; // optimizer could move the release there.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGCall.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCall.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCall.cpp:222,Performance,optimiz,optimizer,222,"// Perform the writeback.; // If we have a ""to use"" value, it's something we need to emit a use; // of. This has to be carefully threaded in: if it's done after the; // release it's potentially undefined behavior (and the optimizer; // will ignore it), and if it happens before the retain then the; // optimizer could move the release there.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGCall.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCall.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCall.cpp:302,Performance,optimiz,optimizer,302,"// Perform the writeback.; // If we have a ""to use"" value, it's something we need to emit a use; // of. This has to be carefully threaded in: if it's done after the; // release it's potentially undefined behavior (and the optimizer; // will ignore it), and if it happens before the retain then the; // optimizer could move the release there.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGCall.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCall.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCall.cpp:3,Performance,Load,Load,3,// Load the old value (primitively).,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGCall.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCall.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCall.cpp:3,Deployability,Release,Release,3,// Release the old value.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGCall.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCall.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCall.cpp:3,Performance,Load,Loading,3,"// Loading an l-value can introduce a cleanup if the l-value is __weak,; // and that cleanup will be conditional if we can't prove that the l-value; // isn't null, so we need to register a dominating point so that the cleanups; // system will make valid IR.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGCall.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCall.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCall.cpp:32,Performance,load,load,32,"// If we need to copy, then the load has to be conditional, which; // means we need control flow.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGCall.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCall.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCall.cpp:3,Performance,Perform,Perform,3,// Perform a copy if necessary.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGCall.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCall.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCall.cpp:144,Availability,alive,alive,144,"// If optimization is enabled, and the value was held in a; // __strong variable, we need to tell the optimizer that this; // value has to stay alive until we're doing the store back.; // This is because the temporary is effectively unretained,; // and so otherwise we can violate the high-level semantics.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGCall.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCall.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCall.cpp:72,Modifiability,variab,variable,72,"// If optimization is enabled, and the value was held in a; // __strong variable, we need to tell the optimizer that this; // value has to stay alive until we're doing the store back.; // This is because the temporary is effectively unretained,; // and so otherwise we can violate the high-level semantics.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGCall.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCall.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCall.cpp:6,Performance,optimiz,optimization,6,"// If optimization is enabled, and the value was held in a; // __strong variable, we need to tell the optimizer that this; // value has to stay alive until we're doing the store back.; // This is because the temporary is effectively unretained,; // and so otherwise we can violate the high-level semantics.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGCall.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCall.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCall.cpp:102,Performance,optimiz,optimizer,102,"// If optimization is enabled, and the value was held in a; // __strong variable, we need to tell the optimizer that this; // value has to stay alive until we're doing the store back.; // This is because the temporary is effectively unretained,; // and so otherwise we can violate the high-level semantics.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGCall.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCall.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCall.cpp:8,Modifiability,variab,variable,8,"// This variable only captures *explicitly* written conventions, not those; // applied by default via command line flags or target defaults, such as; // thiscall, aapcs, stdcall via -mrtd, etc. Computing that correctly would; // require knowing if this is a C++ instance method or being able to see; // unprototyped FunctionTypes.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGCall.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCall.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCall.cpp:136,Modifiability,parameteriz,parameterized,136,"// If *Arg is an ObjCIndirectCopyRestoreExpr, check that either the types of; // the argument and parameter match or the objc method is parameterized.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGCall.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCall.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCall.cpp:21,Integrability,depend,depend,21,"// In particular, we depend on it being the last arg in Args, and the; // objectsize bits depend on there only being one arg if !LeftToRight.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGCall.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCall.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCall.cpp:90,Integrability,depend,depend,90,"// In particular, we depend on it being the last arg in Args, and the; // objectsize bits depend on there only being one arg if !LeftToRight.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGCall.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCall.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCall.cpp:61,Safety,safe,safe,61,"// Since pointer argument are never emitted as LValue, it is safe to emit; // non-null argument check for r-value only.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGCall.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCall.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCall.cpp:106,Safety,safe,safely,106,"// @llvm.objectsize should never have side-effects and shouldn't need; // destruction/cleanups, so we can safely ""emit"" it after its arg,; // regardless of right-to-leftness",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGCall.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCall.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCall.cpp:72,Performance,optimiz,optimizer,72,"// In ObjC ARC mode with no ObjC ARC exception safety, tell the ARC; // optimizer it can aggressively ignore unwind edges.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGCall.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCall.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCall.cpp:47,Safety,safe,safety,47,"// In ObjC ARC mode with no ObjC ARC exception safety, tell the ARC; // optimizer it can aggressively ignore unwind edges.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGCall.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCall.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCall.cpp:12,Usability,simpl,simple,12,/// Emits a simple call (never an invoke) to the given no-arguments; /// runtime function.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGCall.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCall.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCall.cpp:12,Usability,simpl,simple,12,/// Emits a simple call (never an invoke) to the given runtime function.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGCall.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCall.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCall.cpp:62,Integrability,depend,depending,62,"/// Emits a call or invoke instruction to the given function, depending; /// on the current state of the EH stack.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGCall.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCall.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCall.cpp:72,Performance,optimiz,optimizer,72,"// In ObjC ARC mode with no ObjC ARC exception safety, tell the ARC; // optimizer it can aggressively ignore unwind edges.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGCall.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCall.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCall.cpp:47,Safety,safe,safety,47,"// In ObjC ARC mode with no ObjC ARC exception safety, tell the ARC; // optimizer it can aggressively ignore unwind edges.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGCall.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCall.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCall.cpp:32,Energy Efficiency,power,power-of-,32,"// We may legitimately have non-power-of-2 alignment here.; // If so, this is UB land, emit it via `@llvm.assume` instead.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGCall.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCall.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCall.cpp:131,Modifiability,variab,variable,131,"/// Emit alignment assumption.; /// This is a general fallback that we take if either there is an offset,; /// or the alignment is variable or we are sanitizing for alignment.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGCall.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCall.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCall.cpp:150,Security,sanitiz,sanitizing,150,"/// Emit alignment assumption.; /// This is a general fallback that we take if either there is an offset,; /// or the alignment is variable or we are sanitizing for alignment.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGCall.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCall.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCall.cpp:65,Usability,simpl,simplify,65,// FIXME: We no longer need the types from CallArgs; lift up and simplify.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGCall.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCall.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCall.cpp:14,Safety,avoid,avoid,14,"// We want to avoid creating an unnecessary temporary+copy here;; // however, we need one in three cases:; // 1. If the argument is not byval, and we are required to copy the; // source. (This case doesn't occur on any common architecture.); // 2. If the argument is byval, RV is not sufficiently aligned, and; // we cannot force it to be sufficiently aligned.; // 3. If the argument is byval, but RV is not located in default; // or alloca address space.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGCall.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCall.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCall.cpp:92,Performance,perform,perform,92,// For OpenCL even if RV is located in default or alloca address space; // we don't want to perform address space cast for it.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGCall.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCall.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCall.cpp:34,Performance,perform,perform,34,"// If the argument doesn't match, perform a bitcast to coerce it. This; // can happen due to trivial type mismatches.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGCall.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCall.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCall.cpp:10,Safety,Avoid,Avoid,10,// FIXME: Avoid the conversion through memory if possible.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGCall.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCall.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCall.cpp:21,Performance,optimiz,optimizer,21,"// Fast-isel and the optimizer generally like scalar values better than; // FCAs, so we flatten them if this is safe to do for this argument.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGCall.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCall.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCall.cpp:112,Safety,safe,safe,112,"// Fast-isel and the optimizer generally like scalar values better than; // FCAs, so we flatten them if this is safe to do for this argument.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGCall.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCall.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCall.cpp:174,Performance,load,loading,174,"// If the source type is smaller than the destination type of the; // coerce-to logic, copy the source value into a temp alloca the size; // of the destination type to allow loading all of it. The bits past; // the source value are left undef.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGCall.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCall.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCall.cpp:80,Testability,log,logic,80,"// If the source type is smaller than the destination type of the; // coerce-to logic, copy the source value into a temp alloca the size; // of the destination type to allow loading all of it. The bits past; // the source value are left undef.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGCall.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCall.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCall.cpp:45,Performance,load,loaded,45,"// In the simple case, just pass the coerced loaded value.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGCall.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCall.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCall.cpp:10,Usability,simpl,simple,10,"// In the simple case, just pass the coerced loaded value.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGCall.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCall.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCall.cpp:32,Usability,clear,clear,32,"// For certain parameter types, clear padding bits, as they may reveal; // sensitive information.; // Small struct/union types are passed as integer arrays.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGCall.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCall.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCall.cpp:6,Performance,Perform,Perform,6,// 3. Perform the actual call.; // Deactivate any cleanups that we're supposed to do immediately before; // the call.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGCall.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCall.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCall.cpp:3,Testability,Assert,Assert,3,"// Assert that the arguments we computed match up. The IR verifier; // will catch this, but this is a common enough source of problems; // during IRGen changes that it's way better for debugging to catch; // it ourselves here.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGCall.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCall.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCall.cpp:3,Deployability,Update,Update,3,// Update the largest vector width if any arguments have vector types.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGCall.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCall.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCall.cpp:87,Integrability,depend,depend,87,"// If we made a temporary, be sure to clean up after ourselves. Note that we; // can't depend on being inside of an ExprWithCleanups, so we need to manually; // pop this cleanup later on. Being eager about this is OK, since this; // temporary is 'invisible' outside of the callee.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGCall.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCall.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCall.cpp:3,Deployability,Update,Update,3,// Update largest vector width from the return type.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGCall.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCall.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCall.cpp:72,Performance,optimiz,optimizer,72,"// In ObjC ARC mode with no ObjC ARC exception safety, tell the ARC; // optimizer it can aggressively ignore unwind edges.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGCall.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCall.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCall.cpp:47,Safety,safe,safety,47,"// In ObjC ARC mode with no ObjC ARC exception safety, tell the ARC; // optimizer it can aggressively ignore unwind edges.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGCall.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCall.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCall.cpp:45,Availability,error,error,45,"// Add metadata if calling an __attribute__((error(""""))) or warning fn.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGCall.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCall.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCall.cpp:82,Usability,clear,clear,82,"// 4. Finish the call.; // If the call doesn't return, finish the basic block and clear the; // insertion point; this allows the rest of IRGen to discard; // unreachable code.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGCall.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCall.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCall.cpp:3,Safety,Avoid,Avoid,3,// Avoid incompatibility with ASan which relies on the `noreturn`; // attribute to insert handler calls.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGCall.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCall.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCall.cpp:3,Performance,Perform,Perform,3,// Perform the swifterror writeback.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGCall.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCall.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCall.cpp:34,Performance,perform,perform,34,"// If the argument doesn't match, perform a bitcast to coerce it. This; // can happen due to trivial type mismatches.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGCall.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCall.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCall.cpp:37,Performance,scalab,scalable,37,"// If coercing a fixed vector from a scalable vector for ABI; // compatibility, and the types match, use the llvm.vector.extract; // intrinsic to perform the conversion.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGCall.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCall.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCall.cpp:146,Performance,perform,perform,146,"// If coercing a fixed vector from a scalable vector for ABI; // compatibility, and the types match, use the llvm.vector.extract; // intrinsic to perform the conversion.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGCall.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCall.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCall.h:397,Integrability,wrap,wrap,397,"//===----- CGCall.h - Encapsulate calling convention details ----*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // These classes wrap the information about a call or function; // definition used to handle ABI compliancy.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGCall.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCall.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCall.h:8,Availability,avail,available,8,/// All available information about a concrete callee.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGCall.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCall.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCall.h:35,Performance,load,load,35,/// The argument is semantically a load from this l-value.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGCall.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCall.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCall.h:436,Safety,unsafe,unsafe-fp-math,436,"/// Adds attributes to \p F according to our \p CodeGenOpts and \p LangOpts, as; /// though we had emitted it ourselves. We remove any attributes on F that; /// conflict with the attributes we add here.; ///; /// This is useful for adding attrs to bitcode modules that you want to link; /// with but don't control, such as CUDA's libdevice. When linking with such; /// a bitcode library, you might want to set e.g. its functions'; /// ""unsafe-fp-math"" attribute to match the attr of the functions you're; /// codegen'ing. Otherwise, LLVM will interpret the bitcode module's lack of; /// unsafe-fp-math attrs as tantamount to unsafe-fp-math=false, and then LLVM; /// will propagate unsafe-fp-math=false up to every transitive caller of a; /// function in the bitcode library!; ///; /// With the exception of fast-math attrs, this will only make the attributes; /// on the function more conservative. But it's unsafe to call this on a; /// function which relies on particular fast-math attributes for correctness.; /// It's up to you to ensure that this is safe.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGCall.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCall.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCall.h:587,Safety,unsafe,unsafe-fp-math,587,"/// Adds attributes to \p F according to our \p CodeGenOpts and \p LangOpts, as; /// though we had emitted it ourselves. We remove any attributes on F that; /// conflict with the attributes we add here.; ///; /// This is useful for adding attrs to bitcode modules that you want to link; /// with but don't control, such as CUDA's libdevice. When linking with such; /// a bitcode library, you might want to set e.g. its functions'; /// ""unsafe-fp-math"" attribute to match the attr of the functions you're; /// codegen'ing. Otherwise, LLVM will interpret the bitcode module's lack of; /// unsafe-fp-math attrs as tantamount to unsafe-fp-math=false, and then LLVM; /// will propagate unsafe-fp-math=false up to every transitive caller of a; /// function in the bitcode library!; ///; /// With the exception of fast-math attrs, this will only make the attributes; /// on the function more conservative. But it's unsafe to call this on a; /// function which relies on particular fast-math attributes for correctness.; /// It's up to you to ensure that this is safe.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGCall.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCall.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCall.h:625,Safety,unsafe,unsafe-fp-math,625,"/// Adds attributes to \p F according to our \p CodeGenOpts and \p LangOpts, as; /// though we had emitted it ourselves. We remove any attributes on F that; /// conflict with the attributes we add here.; ///; /// This is useful for adding attrs to bitcode modules that you want to link; /// with but don't control, such as CUDA's libdevice. When linking with such; /// a bitcode library, you might want to set e.g. its functions'; /// ""unsafe-fp-math"" attribute to match the attr of the functions you're; /// codegen'ing. Otherwise, LLVM will interpret the bitcode module's lack of; /// unsafe-fp-math attrs as tantamount to unsafe-fp-math=false, and then LLVM; /// will propagate unsafe-fp-math=false up to every transitive caller of a; /// function in the bitcode library!; ///; /// With the exception of fast-math attrs, this will only make the attributes; /// on the function more conservative. But it's unsafe to call this on a; /// function which relies on particular fast-math attributes for correctness.; /// It's up to you to ensure that this is safe.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGCall.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCall.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCall.h:681,Safety,unsafe,unsafe-fp-math,681,"/// Adds attributes to \p F according to our \p CodeGenOpts and \p LangOpts, as; /// though we had emitted it ourselves. We remove any attributes on F that; /// conflict with the attributes we add here.; ///; /// This is useful for adding attrs to bitcode modules that you want to link; /// with but don't control, such as CUDA's libdevice. When linking with such; /// a bitcode library, you might want to set e.g. its functions'; /// ""unsafe-fp-math"" attribute to match the attr of the functions you're; /// codegen'ing. Otherwise, LLVM will interpret the bitcode module's lack of; /// unsafe-fp-math attrs as tantamount to unsafe-fp-math=false, and then LLVM; /// will propagate unsafe-fp-math=false up to every transitive caller of a; /// function in the bitcode library!; ///; /// With the exception of fast-math attrs, this will only make the attributes; /// on the function more conservative. But it's unsafe to call this on a; /// function which relies on particular fast-math attributes for correctness.; /// It's up to you to ensure that this is safe.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGCall.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCall.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCall.h:908,Safety,unsafe,unsafe,908,"/// Adds attributes to \p F according to our \p CodeGenOpts and \p LangOpts, as; /// though we had emitted it ourselves. We remove any attributes on F that; /// conflict with the attributes we add here.; ///; /// This is useful for adding attrs to bitcode modules that you want to link; /// with but don't control, such as CUDA's libdevice. When linking with such; /// a bitcode library, you might want to set e.g. its functions'; /// ""unsafe-fp-math"" attribute to match the attr of the functions you're; /// codegen'ing. Otherwise, LLVM will interpret the bitcode module's lack of; /// unsafe-fp-math attrs as tantamount to unsafe-fp-math=false, and then LLVM; /// will propagate unsafe-fp-math=false up to every transitive caller of a; /// function in the bitcode library!; ///; /// With the exception of fast-math attrs, this will only make the attributes; /// on the function more conservative. But it's unsafe to call this on a; /// function which relies on particular fast-math attributes for correctness.; /// It's up to you to ensure that this is safe.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGCall.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCall.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCall.h:1055,Safety,safe,safe,1055,"/// Adds attributes to \p F according to our \p CodeGenOpts and \p LangOpts, as; /// though we had emitted it ourselves. We remove any attributes on F that; /// conflict with the attributes we add here.; ///; /// This is useful for adding attrs to bitcode modules that you want to link; /// with but don't control, such as CUDA's libdevice. When linking with such; /// a bitcode library, you might want to set e.g. its functions'; /// ""unsafe-fp-math"" attribute to match the attr of the functions you're; /// codegen'ing. Otherwise, LLVM will interpret the bitcode module's lack of; /// unsafe-fp-math attrs as tantamount to unsafe-fp-math=false, and then LLVM; /// will propagate unsafe-fp-math=false up to every transitive caller of a; /// function in the bitcode library!; ///; /// With the exception of fast-math attrs, this will only make the attributes; /// on the function more conservative. But it's unsafe to call this on a; /// function which relies on particular fast-math attributes for correctness.; /// It's up to you to ensure that this is safe.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGCall.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCall.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGClass.cpp:65,Energy Efficiency,allocate,allocated,65,/// Return the smallest possible amount of storage that might be allocated; /// starting from the beginning of an object of a particular class.; ///; /// This may be smaller than sizeof(RD) if RD has virtual base classes.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGClass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGClass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGClass.cpp:589,Modifiability,variab,variables,589,"// If the class is properly aligned, assume the target offset is, too.; //; // This actually isn't necessarily the right thing to do --- if the; // class is a complete object, but it's only properly aligned for a; // base subobject, then the alignments of things relative to it are; // probably off as well. (Note that this requires the alignment of; // the target to be greater than the NV alignment of the derived; // class.); //; // However, our approach to this kind of under-alignment can only; // ever be best effort; after all, we're never going to propagate; // alignments through variables or parameters. Note, in particular,; // that constructing a polymorphic type in an address that's less; // than pointer-aligned will generally trap in the constructor,; // unless we someday add some sort of attribute to change the; // assumed alignment of 'this'. So our goal here is pretty much; // just to allow the user to explicitly say that a pointer is; // under-aligned and then safely access its fields and vtables.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGClass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGClass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGClass.cpp:659,Modifiability,polymorphi,polymorphic,659,"// If the class is properly aligned, assume the target offset is, too.; //; // This actually isn't necessarily the right thing to do --- if the; // class is a complete object, but it's only properly aligned for a; // base subobject, then the alignments of things relative to it are; // probably off as well. (Note that this requires the alignment of; // the target to be greater than the NV alignment of the derived; // class.); //; // However, our approach to this kind of under-alignment can only; // ever be best effort; after all, we're never going to propagate; // alignments through variables or parameters. Note, in particular,; // that constructing a polymorphic type in an address that's less; // than pointer-aligned will generally trap in the constructor,; // unless we someday add some sort of attribute to change the; // assumed alignment of 'this'. So our goal here is pretty much; // just to allow the user to explicitly say that a pointer is; // under-aligned and then safely access its fields and vtables.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGClass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGClass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGClass.cpp:985,Safety,safe,safely,985,"// If the class is properly aligned, assume the target offset is, too.; //; // This actually isn't necessarily the right thing to do --- if the; // class is a complete object, but it's only properly aligned for a; // base subobject, then the alignments of things relative to it are; // probably off as well. (Note that this requires the alignment of; // the target to be greater than the NV alignment of the derived; // class.); //; // However, our approach to this kind of under-alignment can only; // ever be best effort; after all, we're never going to propagate; // alignments through variables or parameters. Note, in particular,; // that constructing a polymorphic type in an address that's less; // than pointer-aligned will generally trap in the constructor,; // unless we someday add some sort of attribute to change the; // assumed alignment of 'this'. So our goal here is pretty much; // just to allow the user to explicitly say that a pointer is; // under-aligned and then safely access its fields and vtables.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGClass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGClass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGClass.cpp:992,Security,access,access,992,"// If the class is properly aligned, assume the target offset is, too.; //; // This actually isn't necessarily the right thing to do --- if the; // class is a complete object, but it's only properly aligned for a; // base subobject, then the alignments of things relative to it are; // probably off as well. (Note that this requires the alignment of; // the target to be greater than the NV alignment of the derived; // class.); //; // However, our approach to this kind of under-alignment can only; // ever be best effort; after all, we're never going to propagate; // alignments through variables or parameters. Note, in particular,; // that constructing a polymorphic type in an address that's less; // than pointer-aligned will generally trap in the constructor,; // unless we someday add some sort of attribute to change the; // assumed alignment of 'this'. So our goal here is pretty much; // just to allow the user to explicitly say that a pointer is; // under-aligned and then safely access its fields and vtables.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGClass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGClass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGClass.cpp:18,Availability,down,down,18,"// Shift and cast down to the base type.; // TODO: for complete types, this should be possible with a GEP.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGClass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGClass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGClass.cpp:3,Testability,Assert,Assert,3,// Assert that we have something to do.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGClass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGClass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGClass.cpp:156,Availability,down,down,156,"// Sema has done some convenient canonicalization here: if the; // access path involved any virtual steps, the conversion path will; // *start* with a step down to the correct virtual base subobject,; // and hence will not require any further steps.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGClass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGClass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGClass.cpp:67,Security,access,access,67,"// Sema has done some convenient canonicalization here: if the; // access path involved any virtual steps, the conversion path will; // *start* with a step down to the correct virtual base subobject,; // and hence will not require any further steps.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGClass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGClass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGClass.cpp:163,Security,access,accesses,163,"// If there's a virtual step, we can sometimes ""devirtualize"" it.; // For now, that's limited to when the derived type is final.; // TODO: ""devirtualize"" this for accesses to known-complete objects.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGClass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGClass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGClass.cpp:40,Performance,load,load,40,// Skip over the offset (and the vtable load) if we're supposed to; // null-check the pointer.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGClass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGClass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGClass.cpp:50,Performance,load,load,50,"// If this is a delegating constructor call, just load the VTT.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGClass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGClass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGClass.cpp:237,Security,access,access,237,"// Black-list all explicit and implicit references to 'this'.; //; // Do we need to worry about external references to 'this' derived; // from arbitrary code? If so, then anything which runs arbitrary; // external code might potentially access the vtable.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGClass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGClass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGClass.cpp:75,Security,access,accesses,75,"// If the initializer for the base (other than the constructor; // itself) accesses 'this' in any way, we need to initialize the; // vtables.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGClass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGClass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGClass.cpp:58,Availability,down,down,58,"// If we are initializing an anonymous union field, drill down to the field.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGClass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGClass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGClass.cpp:164,Performance,perform,perform,164,"// Special case: if we are in a copy or move constructor, and we are copying; // an array of PODs or classes with trivial copy constructors, ignore the; // AST and perform the copy we know is equivalent.; // FIXME: This is hacky at best... if we had a bit more explicit information; // in the AST, we could generalize it more easily.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGClass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGClass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGClass.cpp:113,Performance,optimiz,optimization,113,"/// Checks whether the given constructor is a valid subject for the; /// complete-to-base constructor delegation optimization, i.e.; /// emitting the complete constructor as a simple call to the base; /// constructor.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGClass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGClass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGClass.cpp:176,Usability,simpl,simple,176,"/// Checks whether the given constructor is a valid subject for the; /// complete-to-base constructor delegation optimization, i.e.; /// emitting the complete constructor as a simple call to the base; /// constructor.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGClass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGClass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGClass.cpp:115,Modifiability,variab,variables,115,"// Currently we disable the optimization for classes with virtual; // bases because (1) the addresses of parameter variables need to be; // consistent across all initializers but (2) the delegate function; // call necessarily creates a second copy of the parameter variable.; //; // The limiting example (purely theoretical AFAIK):; // struct A { A(int &c) { c++; } };; // struct B : virtual A {; // B(int count) : A(count) { printf(""%d\n"", count); }; // };; // ...although even this example could in principle be emitted as a; // delegation since the address of the parameter doesn't escape.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGClass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGClass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGClass.cpp:265,Modifiability,variab,variable,265,"// Currently we disable the optimization for classes with virtual; // bases because (1) the addresses of parameter variables need to be; // consistent across all initializers but (2) the delegate function; // call necessarily creates a second copy of the parameter variable.; //; // The limiting example (purely theoretical AFAIK):; // struct A { A(int &c) { c++; } };; // struct B : virtual A {; // B(int count) : A(count) { printf(""%d\n"", count); }; // };; // ...although even this example could in principle be emitted as a; // delegation since the address of the parameter doesn't escape.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGClass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGClass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGClass.cpp:28,Performance,optimiz,optimization,28,"// Currently we disable the optimization for classes with virtual; // bases because (1) the addresses of parameter variables need to be; // consistent across all initializers but (2) the delegate function; // call necessarily creates a second copy of the parameter variable.; //; // The limiting example (purely theoretical AFAIK):; // struct A { A(int &c) { c++; } };; // struct B : virtual A {; // B(int count) : A(count) { printf(""%d\n"", count); }; // };; // ...although even this example could in principle be emitted as a; // delegation since the address of the parameter doesn't escape.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGClass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGClass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGClass.cpp:469,Performance,optimiz,optimization,469,"// TODO: white-list trivial vbase initializers. This case wouldn't; // be subject to the restrictions below.; // TODO: white-list cases where:; // - there are no non-reference parameters to the constructor; // - the initializers don't access any non-reference parameters; // - the initializers don't take the address of non-reference; // parameters; // - etc.; // If we ever add any of the above cases, remember that:; // - function-try-blocks will always exclude this optimization; // - we need to perform the constructor prologue and cleanup in; // EmitConstructorBody.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGClass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGClass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGClass.cpp:499,Performance,perform,perform,499,"// TODO: white-list trivial vbase initializers. This case wouldn't; // be subject to the restrictions below.; // TODO: white-list cases where:; // - there are no non-reference parameters to the constructor; // - the initializers don't access any non-reference parameters; // - the initializers don't take the address of non-reference; // parameters; // - etc.; // If we ever add any of the above cases, remember that:; // - function-try-blocks will always exclude this optimization; // - we need to perform the constructor prologue and cleanup in; // EmitConstructorBody.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGClass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGClass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGClass.cpp:235,Security,access,access,235,"// TODO: white-list trivial vbase initializers. This case wouldn't; // be subject to the restrictions below.; // TODO: white-list cases where:; // - there are no non-reference parameters to the constructor; // - the initializers don't access any non-reference parameters; // - the initializers don't take the address of non-reference; // parameters; // - etc.; // If we ever add any of the above cases, remember that:; // - function-try-blocks will always exclude this optimization; // - we need to perform the constructor prologue and cleanup in; // EmitConstructorBody.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGClass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGClass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGClass.cpp:23,Performance,optimiz,optimization,23,"// We also disable the optimization for variadic functions because; // it's impossible to ""re-pass"" varargs.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGClass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGClass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGClass.cpp:79,Performance,optimiz,optimization,79,"// Before we go any further, try the complete->base constructor; // delegation optimization.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGClass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGClass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGClass.cpp:210,Performance,perform,performing,210,/// RAII object to indicate that codegen is copying the value representation; /// instead of the object representation. Useful when copying a struct or; /// class which has uninitialized members and we're only performing; /// lvalue-to-rvalue conversion on the object but not its members.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGClass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGClass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGClass.cpp:28,Integrability,rout,routine,28,/// EmitCtorPrologue - This routine generates necessary code to initialize; /// base classes and non-static data members belonging to this constructor.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGClass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGClass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGClass.cpp:138,Security,validat,validated,138,"// For an abstract class, non-base destructors are never used (and can't; // be emitted in general, because vbase dtors may not have been validated; // by Sema), but the Itanium ABI doesn't make them optional and Clang may; // in fact emit references to them from other compilations, so emit them; // as functions containing a trap instruction.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGClass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGClass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGClass.cpp:141,Performance,optimiz,optimization,141,"// If this is the complete variant, just invoke the base variant;; // the epilogue will destruct the virtual bases. But we can't do; // this optimization if the body is a function-try-block, because; // we'd introduce *two* handler blocks. In the Microsoft ABI, we; // always delegate because we might not have a definition in this TU.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGClass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGClass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGClass.cpp:39,Security,access,access,39,// Poison the vtable pointer such that access after the base; // and member destructors are invoked is invalid.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGClass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGClass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGClass.cpp:9,Security,Sanitiz,SanitizeMemoryUseAfterDtor,9,"// Under SanitizeMemoryUseAfterDtor, poison the trivial base class; // memory. For non-trival base classes the same is done in the class; // destructor.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGClass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGClass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGClass.cpp:61,Modifiability,inherit,inherits,61,"// Poison the vtable pointer if it has no virtual bases, but inherits; // virtual functions.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGClass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGClass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGClass.cpp:27,Security,access,access,27,"// Poison fields such that access after their destructors are; // invoked, and before the base class destructor runs, is invalid.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGClass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGClass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGClass.cpp:301,Usability,clear,clear,301,"// It's legal for numElements to be zero. This can happen both; // dynamically, because x can be zero in 'new A[x]', and statically,; // because of GCC extensions that permit zero-length arrays. There; // are probably legitimate places where we could assume that this; // doesn't happen, but it's not clear that it's worth it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGClass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGClass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGClass.cpp:3,Performance,Optimiz,Optimize,3,// Optimize for a constant count.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGClass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGClass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGClass.cpp:3,Deployability,Patch,Patch,3,// Patch the earlier check to skip over the loop.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGClass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGClass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGClass.cpp:50,Safety,safe,safe,50,"// If the parameters are callee-cleanup, it's not safe to forward.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGClass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGClass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGClass.cpp:668,Performance,load,loads,668,"// Generate vtable assumptions if we're constructing a complete object; // with a vtable. We don't do this for base subobjects for two reasons:; // first, it's incorrect for classes with virtual bases, and second, we're; // about to overwrite the vptrs anyway.; // We also have to make sure if we can refer to vtable:; // - Otherwise we can refer to vtable if it's safe to speculatively emit.; // FIXME: If vtable is used by ctor/dtor, or if vtable is external and we are; // sure that definition of vtable is not hidden,; // then we are always safe to refer to it.; // FIXME: It looks like InstCombine is very inefficient on dealing with; // assumes. Make assumption loads require -fstrict-vtable-pointers temporarily.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGClass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGClass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGClass.cpp:365,Safety,safe,safe,365,"// Generate vtable assumptions if we're constructing a complete object; // with a vtable. We don't do this for base subobjects for two reasons:; // first, it's incorrect for classes with virtual bases, and second, we're; // about to overwrite the vptrs anyway.; // We also have to make sure if we can refer to vtable:; // - Otherwise we can refer to vtable if it's safe to speculatively emit.; // FIXME: If vtable is used by ctor/dtor, or if vtable is external and we are; // sure that definition of vtable is not hidden,; // then we are always safe to refer to it.; // FIXME: It looks like InstCombine is very inefficient on dealing with; // assumes. Make assumption loads require -fstrict-vtable-pointers temporarily.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGClass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGClass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGClass.cpp:545,Safety,safe,safe,545,"// Generate vtable assumptions if we're constructing a complete object; // with a vtable. We don't do this for base subobjects for two reasons:; // first, it's incorrect for classes with virtual bases, and second, we're; // about to overwrite the vptrs anyway.; // We also have to make sure if we can refer to vtable:; // - Otherwise we can refer to vtable if it's safe to speculatively emit.; // FIXME: If vtable is used by ctor/dtor, or if vtable is external and we are; // sure that definition of vtable is not hidden,; // then we are always safe to refer to it.; // FIXME: It looks like InstCombine is very inefficient on dealing with; // assumes. Make assumption loads require -fstrict-vtable-pointers temporarily.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGClass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGClass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGClass.cpp:106,Modifiability,inherit,inherited,106,// Nothing to do; this construction is not responsible for constructing; // the base class containing the inherited constructor.; // FIXME: Can we just pass undef's for the remaining arguments if we don't; // have constructor variants?,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGClass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGClass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGClass.cpp:48,Integrability,inject,inject,48,// The inheriting constructor was inlined; just inject its arguments.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGClass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGClass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGClass.cpp:7,Modifiability,inherit,inheriting,7,// The inheriting constructor was inlined; just inject its arguments.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGClass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGClass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGClass.cpp:48,Security,inject,inject,48,// The inheriting constructor was inlined; just inject its arguments.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGClass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGClass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGClass.cpp:7,Modifiability,inherit,inheriting,7,// The inheriting constructor was not inlined. Emit delegating arguments.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGClass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGClass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGClass.cpp:42,Modifiability,inherit,inherited,42,// Save the arguments to be passed to the inherited constructor.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGClass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGClass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGClass.cpp:10,Usability,simpl,simplified,10,// Emit a simplified prolog. We only need to emit the implicit params.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGClass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGClass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGClass.cpp:89,Performance,optimiz,optimization,89,"// Finally, store the address point. Use the same LLVM types as the field to; // support optimization.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGClass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGClass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGClass.cpp:518,Security,secur,security,518,"// If a class has a single non-virtual base and does not introduce or override; // virtual member functions or fields, it will have the same layout as its base.; // This function returns the least derived such class.; //; // Casting an instance of a base class to such a derived class is technically; // undefined behavior, but it is a relatively common hack for introducing member; // functions on class instances with specific properties (e.g. llvm::Operator); // that works under most compilers and should not have security implications, so; // we allow it by default. It can be disabled with -fsanitize=cfi-cast-strict.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGClass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGClass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGClass.cpp:21,Testability,test,test,21,// Don't insert type test assumes if we are forcing public; // visibility.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGClass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGClass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGClass.cpp:83,Testability,test,test,83,"// If we already know that the call has hidden LTO visibility, emit; // @llvm.type.test(). Otherwise emit @llvm.public.type.test(), which WPD; // will convert to @llvm.type.test() if we assert at link time that we have; // whole program visibility.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGClass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGClass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGClass.cpp:124,Testability,test,test,124,"// If we already know that the call has hidden LTO visibility, emit; // @llvm.type.test(). Otherwise emit @llvm.public.type.test(), which WPD; // will convert to @llvm.type.test() if we assert at link time that we have; // whole program visibility.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGClass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGClass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGClass.cpp:173,Testability,test,test,173,"// If we already know that the call has hidden LTO visibility, emit; // @llvm.type.test(). Otherwise emit @llvm.public.type.test(), which WPD; // will convert to @llvm.type.test() if we assert at link time that we have; // whole program visibility.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGClass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGClass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGClass.cpp:186,Testability,assert,assert,186,"// If we already know that the call has hidden LTO visibility, emit; // @llvm.type.test(). Otherwise emit @llvm.public.type.test(), which WPD; // will convert to @llvm.type.test() if we assert at link time that we have; // whole program visibility.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGClass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGClass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCleanup.cpp:50,Performance,perform,perform,50,"/// Given a saved r-value produced by SaveRValue, perform the code; /// necessary to restore it to usability at the current insertion; /// point.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGCleanup.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCleanup.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCleanup.cpp:99,Usability,usab,usability,99,"/// Given a saved r-value produced by SaveRValue, perform the code; /// necessary to restore it to usability at the current insertion; /// point.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGCleanup.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCleanup.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCleanup.cpp:12,Modifiability,variab,variable,12,// Create a variable to decide whether the cleanup needs to be run.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGCleanup.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCleanup.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCleanup.cpp:115,Modifiability,variab,variable,115,"// Don't spill static allocas, they dominate all cleanups. These are created; // by binding a reference to a local variable or temporary.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGCleanup.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCleanup.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCleanup.cpp:130,Modifiability,extend,extended,130,"/// Pops cleanup blocks until the given savepoint is reached, then add the; /// cleanups from the given savepoint in the lifetime-extended cleanups stack.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGCleanup.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCleanup.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCleanup.cpp:16,Energy Efficiency,reduce,reduce,16,"/// Attempts to reduce a cleanup's entry block to a fallthrough. This; /// is basically llvm::MergeBlockIntoPredecessor, except; /// simplified/optimized for the tighter constraints on cleanup blocks.; ///; /// Returns the new block, whatever it is.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGCleanup.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCleanup.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCleanup.cpp:144,Performance,optimiz,optimized,144,"/// Attempts to reduce a cleanup's entry block to a fallthrough. This; /// is basically llvm::MergeBlockIntoPredecessor, except; /// simplified/optimized for the tighter constraints on cleanup blocks.; ///; /// Returns the new block, whatever it is.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGCleanup.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCleanup.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCleanup.cpp:133,Usability,simpl,simplified,133,"/// Attempts to reduce a cleanup's entry block to a fallthrough. This; /// is basically llvm::MergeBlockIntoPredecessor, except; /// simplified/optimized for the tighter constraints on cleanup blocks.; ///; /// Returns the new block, whatever it is.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGCleanup.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCleanup.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCleanup.cpp:30,Performance,load,load,30,"// If there's an active flag, load it and skip the cleanup if it's; // false.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGCleanup.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCleanup.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCleanup.cpp:27,Performance,load,load,27,// The switch operand is a load from the cleanup-dest alloca.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGCleanup.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCleanup.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCleanup.cpp:15,Performance,load,load,15,// Destroy the load.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGCleanup.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCleanup.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCleanup.cpp:77,Modifiability,rewrite,rewrite,77,"// If we have a prebranched fallthrough into an inactive normal; // cleanup, rewrite it so that it leads to the appropriate place.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGCleanup.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCleanup.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCleanup.cpp:174,Safety,avoid,avoids,174,"// Otherwise, we need to make a new block. If the normal cleanup; // isn't being used at all, we could actually reuse the normal; // entry block, but this is simpler, and it avoids conflicts with; // dead optimistic fixup branches.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGCleanup.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCleanup.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCleanup.cpp:158,Usability,simpl,simpler,158,"// Otherwise, we need to make a new block. If the normal cleanup; // isn't being used at all, we could actually reuse the normal; // entry block, but this is simpler, and it avoids conflicts with; // dead optimistic fixup branches.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGCleanup.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCleanup.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCleanup.cpp:3,Safety,safe,safe,3,// safe because there are no fixups,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGCleanup.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCleanup.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCleanup.cpp:94,Integrability,depend,depending,94,"// Copy the cleanup emission data out. This uses either a stack; // array or malloc'd memory, depending on the size, which is; // behavior that SmallVector would provide, if we could use it; // here. Unfortunately, if you ask for a SmallVector<char>, the; // alignment isn't sufficient.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGCleanup.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCleanup.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCleanup.cpp:23,Usability,clear,clear,23,"// Otherwise, save and clear the IP if we don't have fallthrough; // because the cleanup is inactive.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGCleanup.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCleanup.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCleanup.cpp:72,Integrability,rout,route,72,"// If there's exactly one branch-after and no other threads,; // we can route it without a switch.; // Skip for SEH, since ExitSwitch is used to generate code to indicate; // abnormal termination. (SEH: Except _leave and fall-through at; // the end, all other exits in a _try (return/goto/continue/break); // are considered as abnormal terminations, using NormalCleanupDestSlot; // to indicate abnormal termination)",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGCleanup.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCleanup.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCleanup.cpp:167,Usability,clear,cleared,167,"// Prebranched fallthrough was forwarded earlier.; // Non-prebranched fallthrough doesn't need to be forwarded.; // Either way, all we need to do is restore the IP we cleared before.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGCleanup.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCleanup.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCleanup.cpp:100,Deployability,patch,patch,100,"// If it did invalidate those pointers, and NormalEntry was the same; // as NormalExit, go back and patch up the fixups.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGCleanup.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCleanup.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCleanup.cpp:238,Usability,clear,clears,238,"/// Terminate the current block by emitting a branch which might leave; /// the current cleanup-protected scope. The target scope may not yet; /// be known, in which case this will require a fixup.; ///; /// As a side-effect, this method clears the insertion point.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGCleanup.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCleanup.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCleanup.cpp:58,Modifiability,Config,Configure,58,/// The given cleanup block is changing activation state. Configure a; /// cleanup variable if necessary.; ///; /// It would be good if we had some way of determining if there were; /// extra uses *after* the change-over point.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGCleanup.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCleanup.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCleanup.cpp:83,Modifiability,variab,variable,83,/// The given cleanup block is changing activation state. Configure a; /// cleanup variable if necessary.; ///; /// It would be good if we had some way of determining if there were; /// extra uses *after* the change-over point.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGCleanup.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCleanup.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCleanup.cpp:31,Integrability,depend,depending,31,// Initialize to true or false depending on whether it was; // active up to this point.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGCleanup.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCleanup.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCleanup.h:125,Integrability,wrap,wrapper,125,"/// The MS C++ ABI needs a pointer to RTTI data plus some flags to describe the; /// type of a catch handler, so we use this wrapper.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGCleanup.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCleanup.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCleanup.h:38,Testability,test,test,38,/// Whether the normal cleanup should test the activation flag.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGCleanup.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCleanup.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCleanup.h:34,Testability,test,test,34,/// Whether the EH cleanup should test the activation flag.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGCleanup.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCleanup.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCleanup.h:24,Modifiability,flexible,flexible,24,"// In effect, we have a flexible array member; // Handler Handlers[0];; // But that's only standard in C99, not C++, so we have to do; // annoying pointer arithmetic instead.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGCleanup.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCleanup.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCleanup.h:3,Usability,Clear,Clear,3,// Clear all handler blocks.; // FIXME: it's better to always call clearHandlerBlocks in DTOR and have a; // 'takeHandler' or some such function which removes ownership from the; // EHCatchScope object if the handlers should live longer than EHCatchScope.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGCleanup.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCleanup.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCleanup.h:67,Usability,clear,clearHandlerBlocks,67,// Clear all handler blocks.; // FIXME: it's better to always call clearHandlerBlocks in DTOR and have a; // 'takeHandler' or some such function which removes ownership from the; // EHCatchScope object if the handlers should live longer than EHCatchScope.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGCleanup.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCleanup.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCleanup.h:19,Modifiability,variab,variable,19,/// An optional i1 variable indicating whether this cleanup has been; /// activated yet.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGCleanup.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCleanup.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCleanup.h:106,Energy Efficiency,allocate,allocated,106,/// Extra information required for cleanups that have resolved; /// branches through them. This has to be allocated on the side; /// because everything on the cleanup stack has be trivially; /// movable.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGCleanup.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCleanup.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCleanup.h:96,Testability,assert,asserted,96,"// NOTE: there's a bunch of different data classes tacked on after an; // EHCleanupScope. It is asserted (in EHScopeStack::pushCleanup*) that; // they don't require greater alignment than ScopeStackAlignment. So,; // EHCleanupScope ought to have alignment equal to that -- not more; // (would be misaligned by the stack allocator), and not less (would; // break the appended classes).",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGCleanup.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCleanup.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCleanup.h:25,Modifiability,flexible,flexible,25,// Essentially ends in a flexible array member:; // llvm::Value *FilterTypes[0];,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGCleanup.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCleanup.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCoroutine.cpp:120,Modifiability,variab,variable,120,"// A temporary i1 alloca that stores whether 'await_resume' threw an; // exception. If it did, 'true' is stored in this variable, and the coroutine; // body must be skipped. If the promise type does not define an exception; // handler, this is null.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGCoroutine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCoroutine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCoroutine.cpp:86,Integrability,wrap,wrap,86,"// Stores the last emitted coro.free for the deallocate expressions, we use it; // to wrap dealloc code with if(auto mem = coro.free) dealloc(mem).",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGCoroutine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCoroutine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCoroutine.cpp:713,Usability,resume,resumed,713,"// Emit suspend expression which roughly looks like:; //; // auto && x = CommonExpr();; // if (!x.await_ready()) {; // llvm_coro_save();; // x.await_suspend(...); (*); // llvm_coro_suspend(); (**); // }; // x.await_resume();; //; // where the result of the entire expression is the result of x.await_resume(); //; // (*) If x.await_suspend return type is bool, it allows to veto a suspend:; // if (x.await_suspend(...)); // llvm_coro_suspend();; //; // (**) llvm_coro_suspend() encodes three possible continuations as; // a switch instruction:; //; // %where-to = call i8 @llvm.coro.suspend(...); // switch i8 %where-to, label %coro.ret [ ; jump to epilogue to suspend; // i8 0, label %yield.ready ; go here when resumed; // i8 1, label %yield.cleanup ; go here when destroyed; // ]; //; // See llvm's docs/Coroutines.rst for more details.; //",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGCoroutine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCoroutine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCoroutine.cpp:27,Testability,log,logic,27,"// Otherwise, emit suspend logic.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGCoroutine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCoroutine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCoroutine.cpp:109,Safety,avoid,avoid,109,"// Exception handling requires additional IR. If the 'await_resume' function; // is marked as 'noexcept', we avoid generating this additional IR.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGCoroutine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCoroutine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCoroutine.cpp:57,Usability,Resume,ResumeEHVar,57,// We don't use EmitCXXTryStmt here. We need to store to ResumeEHVar that; // doesn't exist in the body.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGCoroutine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCoroutine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCoroutine.cpp:54,Integrability,wrap,wrapping,54,// Is it possible for RE to be a CXXBindTemporaryExpr wrapping; // a MemberCallExpr?,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGCoroutine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCoroutine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCoroutine.cpp:128,Usability,resume,resumed,128,// We will insert coro.end to cut any of the destructors for objects that; // do not need to be destroyed once the coroutine is resumed.; // See llvm/docs/Coroutines.rst for more details about coro.end.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGCoroutine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCoroutine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCoroutine.cpp:122,Usability,resume,resume,122,"// Otherwise, (landingpad model), create a conditional branch that leads; // either to a cleanup block or a block with EH resume instruction.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGCoroutine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCoroutine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCoroutine.cpp:179,Safety,safe,safe,179,"// Emit ""if (coro.free(CoroId, CoroBegin)) Deallocate;""; // Note: That deallocation will be emitted twice: once for a normal exit and; // once for exceptional exit. This usage is safe because Deallocate does not; // contain any declarations. The SubStmtBuilder::makeNewAndDeleteExpr(); // builds a single call to a deallocation function which is safe to emit; // multiple times.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGCoroutine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCoroutine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCoroutine.cpp:346,Safety,safe,safe,346,"// Emit ""if (coro.free(CoroId, CoroBegin)) Deallocate;""; // Note: That deallocation will be emitted twice: once for a normal exit and; // once for exceptional exit. This usage is safe because Deallocate does not; // contain any declarations. The SubStmtBuilder::makeNewAndDeleteExpr(); // builds a single call to a deallocation function which is safe to emit; // multiple times.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGCoroutine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCoroutine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCoroutine.cpp:14,Performance,perform,performs,14,"// When true, performs RVO for the return object.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGCoroutine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCoroutine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCoroutine.cpp:240,Integrability,depend,depending,240,"// The call to get_­return_­object is sequenced before the call to; // initial_­suspend and is invoked at most once, but there are caveats; // regarding on whether the prvalue result object may be initialized; // directly/eager or delayed, depending on the types involved.; //; // More info at https://github.com/cplusplus/papers/issues/1414; //; // The general cases:; // 1. Same type of get_return_object and coroutine return type (direct; // emission):; // - Constructed in the return slot.; // 2. Different types (delayed emission):; // - Constructed temporary object prior to initial suspend initialized with; // a call to get_return_object(); // - When coroutine needs to to return to the caller and needs to construct; // return value for the coroutine it is initialized with expiring value of; // the temporary obtained above.; //; // Direct emission for void returning coroutines or GROs.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGCoroutine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCoroutine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCoroutine.cpp:281,Availability,avail,available,281,"// The gro variable has to outlive coroutine frame and coroutine promise, but,; // it can only be initialized after coroutine promise was created, thus, we; // split its emission in two parts. EmitGroAlloca emits an alloca and sets up; // cleanups. Later when coroutine promise is available we initialize the gro; // and sets the flag that the cleanup is now active.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGCoroutine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCoroutine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCoroutine.cpp:11,Modifiability,variab,variable,11,"// The gro variable has to outlive coroutine frame and coroutine promise, but,; // it can only be initialized after coroutine promise was created, thus, we; // split its emission in two parts. EmitGroAlloca emits an alloca and sets up; // cleanups. Later when coroutine promise is available we initialize the gro; // and sets the flag that the cleanup is now active.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGCoroutine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCoroutine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCoroutine.cpp:118,Energy Efficiency,reduce,reduce,118,// ReturnValue should be valid as long as the coroutine's return type; // is not void. The assertion could help us to reduce the check later.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGCoroutine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCoroutine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCoroutine.cpp:91,Testability,assert,assertion,91,// ReturnValue should be valid as long as the coroutine's return type; // is not void. The assertion could help us to reduce the check later.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGCoroutine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCoroutine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCoroutine.cpp:23,Energy Efficiency,allocate,allocated,23,// No Gro variable was allocated. Simply emit the call to; // get_return_object.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGCoroutine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCoroutine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCoroutine.cpp:10,Modifiability,variab,variable,10,// No Gro variable was allocated. Simply emit the call to; // get_return_object.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGCoroutine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCoroutine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCoroutine.cpp:34,Usability,Simpl,Simply,34,// No Gro variable was allocated. Simply emit the call to; // get_return_object.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGCoroutine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCoroutine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCoroutine.cpp:21,Availability,failure,failure,21,// Handle allocation failure if 'ReturnStmtOnAllocFailure' was provided.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGCoroutine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCoroutine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCoroutine.cpp:3,Deployability,Update,Update,3,// Update CoroId to refer to the promise. We could not do it earlier because; // promise local variable was not emitted yet.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGCoroutine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCoroutine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCoroutine.cpp:95,Modifiability,variab,variable,95,// Update CoroId to refer to the promise. We could not do it earlier because; // promise local variable was not emitted yet.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGCoroutine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCoroutine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCoroutine.cpp:77,Usability,resume,resume,77,"// Emit coro.end before getReturnStmt (and parameter destructors), since; // resume and destroy parts of the coroutine should not include them.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGCoroutine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCoroutine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCoroutine.cpp:32,Deployability,patch,patch,32,// Emit coroutine intrinsic and patch up arguments of the token type.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGCoroutine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCoroutine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCoroutine.cpp:174,Deployability,patch,patch,174,"// The following three intrinsics take a token parameter referring to a token; // returned by earlier call to @llvm.coro.id. Since we cannot represent it in; // builtins, we patch it up here.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGCoroutine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCoroutine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCoroutine.cpp:185,Deployability,update,update,185,"// Note: The following code is to enable to emit coro.id and coro.begin by; // hand to experiment with coroutines in C.; // If we see @llvm.coro.id remember it in the CoroData. We will update; // coro.alloc, coro.begin and coro.free intrinsics to refer to it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGCoroutine.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCoroutine.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCUDANV.cpp:26,Integrability,Interface,Interface,26,"//===----- CGCUDANV.cpp - Interface to NVIDIA CUDA Runtime ----------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This provides a class for CUDA code generation targeting the NVIDIA CUDA; // runtime library.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGCUDANV.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCUDANV.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCUDANV.cpp:33,Testability,stub,stubs,33,/// Keeps track of kernel launch stubs and handles emitted in this module,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGCUDANV.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCUDANV.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCUDANV.cpp:3,Testability,stub,stub,3,// stub function to help launch kernel,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGCUDANV.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCUDANV.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCUDANV.cpp:159,Testability,stub,stub,159,"// Map a kernel mangled name to a symbol for identifying kernel in host code; // For CUDA, the symbol for identifying the kernel is the same as the device; // stub function. For HIP, they are different.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGCUDANV.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCUDANV.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCUDANV.cpp:37,Testability,stub,stub,37,// Map a kernel handle to the kernel stub.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGCUDANV.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCUDANV.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCUDANV.cpp:19,Modifiability,variab,variable,19,/// Keeps track of variable containing handle of GPU binary. Populated by; /// ModuleCtorFunction() and used to create corresponding cleanup calls in; /// ModuleDtorFunction(),MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGCUDANV.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCUDANV.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCUDANV.cpp:46,Testability,stub,stubs,46,/// Creates a function to register all kernel stubs generated in this module.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGCUDANV.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCUDANV.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCUDANV.cpp:22,Modifiability,variab,variables,22,/// Transform managed variables for device compilation.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGCUDANV.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCUDANV.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCUDANV.cpp:35,Modifiability,variab,variable,35,// D could be either a kernel or a variable.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGCUDANV.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCUDANV.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCUDANV.cpp:54,Modifiability,variab,variable,54,// Make unique name for device side static file-scope variable for HIP.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGCUDANV.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCUDANV.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCUDANV.cpp:153,Energy Efficiency,allocate,allocate,153,"// Build the shadow stack entry at the very start of the function.; // Calculate amount of space we will need for all arguments. If we have no; // args, allocate a single pointer so we still have a valid pointer to the; // argument array that we can pass to runtime, even if it will be unused.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGCUDANV.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCUDANV.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCUDANV.cpp:48,Energy Efficiency,allocate,allocated,48,// Store pointers to the arguments in a locally allocated launch_args.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGCUDANV.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCUDANV.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCUDANV.cpp:87,Integrability,depend,depends,87,"// Lookup cudaLaunchKernel/hipLaunchKernel function.; // HIP kernel launching API name depends on -fgpu-default-stream option. For; // the default value 'legacy', it is hipLaunchKernel. For 'per-thread',; // it is hipLaunchKernel_spt.; // cudaError_t cudaLaunchKernel(const void *func, dim3 gridDim, dim3 blockDim,; // void **args, size_t sharedMem,; // cudaStream_t stream);; // hipError_t hipLaunchKernel[_spt](const void *func, dim3 gridDim,; // dim3 blockDim, void **args,; // size_t sharedMem, hipStream_t stream);",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGCUDANV.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCUDANV.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCUDANV.cpp:24,Modifiability,variab,variable,24,// Replace the original variable Var with the address loaded from variable; // ManagedVar populated by HIP runtime.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGCUDANV.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCUDANV.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCUDANV.cpp:66,Modifiability,variab,variable,66,// Replace the original variable Var with the address loaded from variable; // ManagedVar populated by HIP runtime.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGCUDANV.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCUDANV.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCUDANV.cpp:54,Performance,load,loaded,54,// Replace the original variable Var with the address loaded from variable; // ManagedVar populated by HIP runtime.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGCUDANV.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCUDANV.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCUDANV.cpp:77,Modifiability,variab,variable,77,// Replace constant expressions directly or indirectly using the managed; // variable with instructions.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGCUDANV.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCUDANV.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCUDANV.cpp:218,Modifiability,variab,variables,218,"/// Creates a function that sets up state on the host side for CUDA objects that; /// have a presence on both the host and device sides. Specifically, registers; /// the host side of kernel functions and device global variables with the CUDA; /// runtime.; /// \code; /// void __cuda_register_globals(void** GpuBinaryHandle) {; /// __cudaRegisterFunction(GpuBinaryHandle,Kernel0,...);; /// ...; /// __cudaRegisterFunction(GpuBinaryHandle,KernelM,...);; /// __cudaRegisterVar(GpuBinaryHandle, GlobalVar0, ...);; /// ...; /// __cudaRegisterVar(GpuBinaryHandle, GlobalVarN, ...);; /// }; /// \endcode",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGCUDANV.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCUDANV.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCUDANV.cpp:32,Modifiability,variab,variable,32,"// For HIP or CUDA 9.0+, device variable size is type of `size_t`.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGCUDANV.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCUDANV.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCUDANV.cpp:84,Modifiability,variab,variable,84,"// Register GPU binary with the CUDA runtime, store returned handle in a; // global variable and save a reference in GpuBinaryHandle to be cleaned up; // in destructor on exit. Then associate all known kernels with the GPU binary; // handle so CUDA runtime can figure out what to call on the GPU side.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGCUDANV.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCUDANV.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCUDANV.cpp:16,Availability,avail,available,16,"// If fatbin is available from early finalization, create a string; // literal containing the fat binary loaded from the given file.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGCUDANV.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCUDANV.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCUDANV.cpp:105,Performance,load,loaded,105,"// If fatbin is available from early finalization, create a string; // literal containing the fat binary loaded from the given file.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGCUDANV.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCUDANV.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCUDANV.cpp:20,Availability,avail,available,20,"// If fatbin is not available, create an external symbol; // __hip_fatbin in section .hip_fatbin. The external symbol is supposed; // to contain the fat binary but will be populated somewhere else,; // e.g. by lld through link script.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGCUDANV.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCUDANV.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCUDANV.cpp:63,Performance,load,loaded,63,"// For CUDA, create a string literal containing the fat binary loaded from; // the given file.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGCUDANV.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCUDANV.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCUDANV.cpp:22,Integrability,wrap,wrapper,22,// Create initialized wrapper structure that points to the loaded GPU binary,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGCUDANV.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCUDANV.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCUDANV.cpp:59,Performance,load,loaded,59,// Create initialized wrapper structure that points to the loaded GPU binary,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGCUDANV.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCUDANV.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCUDANV.cpp:10,Integrability,wrap,wrapper,10,// Fatbin wrapper magic.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGCUDANV.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCUDANV.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCUDANV.cpp:217,Performance,load,loader,217,"// There is only one HIP fat binary per linked module, however there are; // multiple constructor functions. Make sure the fat binary is registered; // only once. The constructor functions are executed by the dynamic loader; // before the program gains control. The dynamic loader cannot execute the; // constructor functions concurrently since doing that would not guarantee; // thread safety of the loaded program. Therefore we can assume sequential; // execution of constructor functions here.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGCUDANV.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCUDANV.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCUDANV.cpp:274,Performance,load,loader,274,"// There is only one HIP fat binary per linked module, however there are; // multiple constructor functions. Make sure the fat binary is registered; // only once. The constructor functions are executed by the dynamic loader; // before the program gains control. The dynamic loader cannot execute the; // constructor functions concurrently since doing that would not guarantee; // thread safety of the loaded program. Therefore we can assume sequential; // execution of constructor functions here.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGCUDANV.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCUDANV.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCUDANV.cpp:326,Performance,concurren,concurrently,326,"// There is only one HIP fat binary per linked module, however there are; // multiple constructor functions. Make sure the fat binary is registered; // only once. The constructor functions are executed by the dynamic loader; // before the program gains control. The dynamic loader cannot execute the; // constructor functions concurrently since doing that would not guarantee; // thread safety of the loaded program. Therefore we can assume sequential; // execution of constructor functions here.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGCUDANV.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCUDANV.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCUDANV.cpp:401,Performance,load,loaded,401,"// There is only one HIP fat binary per linked module, however there are; // multiple constructor functions. Make sure the fat binary is registered; // only once. The constructor functions are executed by the dynamic loader; // before the program gains control. The dynamic loader cannot execute the; // constructor functions concurrently since doing that would not guarantee; // thread safety of the loaded program. Therefore we can assume sequential; // execution of constructor functions here.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGCUDANV.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCUDANV.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCUDANV.cpp:387,Safety,safe,safety,387,"// There is only one HIP fat binary per linked module, however there are; // multiple constructor functions. Make sure the fat binary is registered; // only once. The constructor functions are executed by the dynamic loader; // before the program gains control. The dynamic loader cannot execute the; // constructor functions concurrently since doing that would not guarantee; // thread safety of the loaded program. Therefore we can assume sequential; // execution of constructor functions here.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGCUDANV.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCUDANV.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCUDANV.cpp:54,Modifiability,variab,variable,54,"// The name, size, and initialization pattern of this variable is part; // of HIP ABI.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGCUDANV.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCUDANV.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCUDANV.cpp:90,Modifiability,variab,variables,90,"// For -fno-gpu-rdc, host-side shadows of external declarations of device-side; // global variables become internal definitions. These have to be internal in; // order to prevent name conflicts with global host variables with the same; // name in a different TUs.; //; // For -fgpu-rdc, the shadow variables should not be internalized because; // they may be accessed by different TU.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGCUDANV.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCUDANV.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCUDANV.cpp:211,Modifiability,variab,variables,211,"// For -fno-gpu-rdc, host-side shadows of external declarations of device-side; // global variables become internal definitions. These have to be internal in; // order to prevent name conflicts with global host variables with the same; // name in a different TUs.; //; // For -fgpu-rdc, the shadow variables should not be internalized because; // they may be accessed by different TU.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGCUDANV.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCUDANV.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCUDANV.cpp:298,Modifiability,variab,variables,298,"// For -fno-gpu-rdc, host-side shadows of external declarations of device-side; // global variables become internal definitions. These have to be internal in; // order to prevent name conflicts with global host variables with the same; // name in a different TUs.; //; // For -fgpu-rdc, the shadow variables should not be internalized because; // they may be accessed by different TU.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGCUDANV.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCUDANV.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCUDANV.cpp:359,Security,access,accessed,359,"// For -fno-gpu-rdc, host-side shadows of external declarations of device-side; // global variables become internal definitions. These have to be internal in; // order to prevent name conflicts with global host variables with the same; // name in a different TUs.; //; // For -fgpu-rdc, the shadow variables should not be internalized because; // they may be accessed by different TU.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGCUDANV.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCUDANV.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCUDANV.cpp:14,Modifiability,variab,variables,14,"// __shared__ variables are odd. Shadows do get created, but; // they are not registered with the CUDA runtime, so they; // can't really be used to access their device-side; // counterparts. It's not clear yet whether it's nvcc's bug or; // a feature, but we've got to do the same for compatibility.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGCUDANV.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCUDANV.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCUDANV.cpp:148,Security,access,access,148,"// __shared__ variables are odd. Shadows do get created, but; // they are not registered with the CUDA runtime, so they; // can't really be used to access their device-side; // counterparts. It's not clear yet whether it's nvcc's bug or; // a feature, but we've got to do the same for compatibility.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGCUDANV.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCUDANV.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCUDANV.cpp:200,Usability,clear,clear,200,"// __shared__ variables are odd. Shadows do get created, but; // they are not registered with the CUDA runtime, so they; // can't really be used to access their device-side; // counterparts. It's not clear yet whether it's nvcc's bug or; // a feature, but we've got to do the same for compatibility.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGCUDANV.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCUDANV.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCUDANV.cpp:10,Modifiability,variab,variables,10,"// Shadow variables and their properties must be registered with CUDA; // runtime. Skip Extern global variables, which will be registered in; // the TU where they are defined.; //; // Don't register a C++17 inline variable. The local symbol can be; // discarded and referencing a discarded local symbol from outside the; // comdat (__cuda_register_globals) is disallowed by the ELF spec.; //; // HIP managed variables need to be always recorded in device and host; // compilations for transformation.; //; // HIP managed variables and variables in CUDADeviceVarODRUsedByHost are; // added to llvm.compiler-used, therefore they are safe to be registered.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGCUDANV.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCUDANV.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCUDANV.cpp:102,Modifiability,variab,variables,102,"// Shadow variables and their properties must be registered with CUDA; // runtime. Skip Extern global variables, which will be registered in; // the TU where they are defined.; //; // Don't register a C++17 inline variable. The local symbol can be; // discarded and referencing a discarded local symbol from outside the; // comdat (__cuda_register_globals) is disallowed by the ELF spec.; //; // HIP managed variables need to be always recorded in device and host; // compilations for transformation.; //; // HIP managed variables and variables in CUDADeviceVarODRUsedByHost are; // added to llvm.compiler-used, therefore they are safe to be registered.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGCUDANV.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCUDANV.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCUDANV.cpp:214,Modifiability,variab,variable,214,"// Shadow variables and their properties must be registered with CUDA; // runtime. Skip Extern global variables, which will be registered in; // the TU where they are defined.; //; // Don't register a C++17 inline variable. The local symbol can be; // discarded and referencing a discarded local symbol from outside the; // comdat (__cuda_register_globals) is disallowed by the ELF spec.; //; // HIP managed variables need to be always recorded in device and host; // compilations for transformation.; //; // HIP managed variables and variables in CUDADeviceVarODRUsedByHost are; // added to llvm.compiler-used, therefore they are safe to be registered.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGCUDANV.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCUDANV.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCUDANV.cpp:408,Modifiability,variab,variables,408,"// Shadow variables and their properties must be registered with CUDA; // runtime. Skip Extern global variables, which will be registered in; // the TU where they are defined.; //; // Don't register a C++17 inline variable. The local symbol can be; // discarded and referencing a discarded local symbol from outside the; // comdat (__cuda_register_globals) is disallowed by the ELF spec.; //; // HIP managed variables need to be always recorded in device and host; // compilations for transformation.; //; // HIP managed variables and variables in CUDADeviceVarODRUsedByHost are; // added to llvm.compiler-used, therefore they are safe to be registered.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGCUDANV.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCUDANV.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCUDANV.cpp:521,Modifiability,variab,variables,521,"// Shadow variables and their properties must be registered with CUDA; // runtime. Skip Extern global variables, which will be registered in; // the TU where they are defined.; //; // Don't register a C++17 inline variable. The local symbol can be; // discarded and referencing a discarded local symbol from outside the; // comdat (__cuda_register_globals) is disallowed by the ELF spec.; //; // HIP managed variables need to be always recorded in device and host; // compilations for transformation.; //; // HIP managed variables and variables in CUDADeviceVarODRUsedByHost are; // added to llvm.compiler-used, therefore they are safe to be registered.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGCUDANV.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCUDANV.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCUDANV.cpp:535,Modifiability,variab,variables,535,"// Shadow variables and their properties must be registered with CUDA; // runtime. Skip Extern global variables, which will be registered in; // the TU where they are defined.; //; // Don't register a C++17 inline variable. The local symbol can be; // discarded and referencing a discarded local symbol from outside the; // comdat (__cuda_register_globals) is disallowed by the ELF spec.; //; // HIP managed variables need to be always recorded in device and host; // compilations for transformation.; //; // HIP managed variables and variables in CUDADeviceVarODRUsedByHost are; // added to llvm.compiler-used, therefore they are safe to be registered.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGCUDANV.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCUDANV.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCUDANV.cpp:631,Safety,safe,safe,631,"// Shadow variables and their properties must be registered with CUDA; // runtime. Skip Extern global variables, which will be registered in; // the TU where they are defined.; //; // Don't register a C++17 inline variable. The local symbol can be; // discarded and referencing a discarded local symbol from outside the; // comdat (__cuda_register_globals) is disallowed by the ELF spec.; //; // HIP managed variables need to be always recorded in device and host; // compilations for transformation.; //; // HIP managed variables and variables in CUDADeviceVarODRUsedByHost are; // added to llvm.compiler-used, therefore they are safe to be registered.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGCUDANV.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCUDANV.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCUDANV.cpp:281,Energy Efficiency,allocate,allocated,281,// Transform managed variables to pointers to managed variables in device code.; // Each use of the original managed variable is replaced by a load from the; // transformed managed variable. The transformed managed variable contains; // the address of managed memory which will be allocated by the runtime.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGCUDANV.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCUDANV.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCUDANV.cpp:21,Modifiability,variab,variables,21,// Transform managed variables to pointers to managed variables in device code.; // Each use of the original managed variable is replaced by a load from the; // transformed managed variable. The transformed managed variable contains; // the address of managed memory which will be allocated by the runtime.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGCUDANV.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCUDANV.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCUDANV.cpp:54,Modifiability,variab,variables,54,// Transform managed variables to pointers to managed variables in device code.; // Each use of the original managed variable is replaced by a load from the; // transformed managed variable. The transformed managed variable contains; // the address of managed memory which will be allocated by the runtime.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGCUDANV.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCUDANV.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCUDANV.cpp:117,Modifiability,variab,variable,117,// Transform managed variables to pointers to managed variables in device code.; // Each use of the original managed variable is replaced by a load from the; // transformed managed variable. The transformed managed variable contains; // the address of managed memory which will be allocated by the runtime.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGCUDANV.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCUDANV.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCUDANV.cpp:181,Modifiability,variab,variable,181,// Transform managed variables to pointers to managed variables in device code.; // Each use of the original managed variable is replaced by a load from the; // transformed managed variable. The transformed managed variable contains; // the address of managed memory which will be allocated by the runtime.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGCUDANV.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCUDANV.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCUDANV.cpp:215,Modifiability,variab,variable,215,// Transform managed variables to pointers to managed variables in device code.; // Each use of the original managed variable is replaced by a load from the; // transformed managed variable. The transformed managed variable contains; // the address of managed memory which will be allocated by the runtime.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGCUDANV.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCUDANV.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCUDANV.cpp:143,Performance,load,load,143,// Transform managed variables to pointers to managed variables in device code.; // Each use of the original managed variable is replaced by a load from the; // transformed managed variable. The transformed managed variable contains; // the address of managed memory which will be allocated by the runtime.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGCUDANV.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCUDANV.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCUDANV.cpp:93,Energy Efficiency,allocate,allocated,93,// Keep managed variables even if they are not used in device code since; // they need to be allocated by the runtime.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGCUDANV.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCUDANV.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCUDANV.cpp:16,Modifiability,variab,variables,16,// Keep managed variables even if they are not used in device code since; // they need to be allocated by the runtime.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGCUDANV.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCUDANV.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCUDANV.cpp:24,Modifiability,variab,variables,24,"// Mark ODR-used device variables as compiler used to prevent it from being; // eliminated by optimization. This is necessary for device variables; // ODR-used by host functions. Sema correctly marks them as ODR-used no; // matter whether they are ODR-used by device or host functions.; //; // We do not need to do this if the variable has used attribute since it; // has already been added.; //; // Static device variables have been externalized at this point, therefore; // variables with LLVM private or internal linkage need not be added.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGCUDANV.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCUDANV.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCUDANV.cpp:137,Modifiability,variab,variables,137,"// Mark ODR-used device variables as compiler used to prevent it from being; // eliminated by optimization. This is necessary for device variables; // ODR-used by host functions. Sema correctly marks them as ODR-used no; // matter whether they are ODR-used by device or host functions.; //; // We do not need to do this if the variable has used attribute since it; // has already been added.; //; // Static device variables have been externalized at this point, therefore; // variables with LLVM private or internal linkage need not be added.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGCUDANV.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCUDANV.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCUDANV.cpp:327,Modifiability,variab,variable,327,"// Mark ODR-used device variables as compiler used to prevent it from being; // eliminated by optimization. This is necessary for device variables; // ODR-used by host functions. Sema correctly marks them as ODR-used no; // matter whether they are ODR-used by device or host functions.; //; // We do not need to do this if the variable has used attribute since it; // has already been added.; //; // Static device variables have been externalized at this point, therefore; // variables with LLVM private or internal linkage need not be added.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGCUDANV.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCUDANV.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCUDANV.cpp:414,Modifiability,variab,variables,414,"// Mark ODR-used device variables as compiler used to prevent it from being; // eliminated by optimization. This is necessary for device variables; // ODR-used by host functions. Sema correctly marks them as ODR-used no; // matter whether they are ODR-used by device or host functions.; //; // We do not need to do this if the variable has used attribute since it; // has already been added.; //; // Static device variables have been externalized at this point, therefore; // variables with LLVM private or internal linkage need not be added.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGCUDANV.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCUDANV.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCUDANV.cpp:476,Modifiability,variab,variables,476,"// Mark ODR-used device variables as compiler used to prevent it from being; // eliminated by optimization. This is necessary for device variables; // ODR-used by host functions. Sema correctly marks them as ODR-used no; // matter whether they are ODR-used by device or host functions.; //; // We do not need to do this if the variable has used attribute since it; // has already been added.; //; // Static device variables have been externalized at this point, therefore; // variables with LLVM private or internal linkage need not be added.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGCUDANV.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCUDANV.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCUDANV.cpp:94,Performance,optimiz,optimization,94,"// Mark ODR-used device variables as compiler used to prevent it from being; // eliminated by optimization. This is necessary for device variables; // ODR-used by host functions. Sema correctly marks them as ODR-used no; // matter whether they are ODR-used by device or host functions.; //; // We do not need to do this if the variable has used attribute since it; // has already been added.; //; // Static device variables have been externalized at this point, therefore; // variables with LLVM private or internal linkage need not be added.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGCUDANV.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCUDANV.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCUDANV.cpp:78,Deployability,update,update,78,"// We've found the function name, but F itself has changed, so we need to; // update the references.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGCUDANV.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCUDANV.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCUDANV.cpp:81,Deployability,update,update,81,"// For HIP compilation the handle itself does not change, so we only need; // to update the Stub value.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGCUDANV.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCUDANV.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCUDANV.cpp:92,Testability,Stub,Stub,92,"// For HIP compilation the handle itself does not change, so we only need; // to update the Stub value.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGCUDANV.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCUDANV.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCUDANV.cpp:42,Testability,Stub,Stub,42,"// For non-HIP compilation, erase the old Stub and fall-through to creating; // new entries.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGCUDANV.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCUDANV.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCUDARuntime.cpp:31,Integrability,Interface,Interface,31,"//===----- CGCUDARuntime.cpp - Interface to CUDA Runtimes -----------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This provides an abstract class for CUDA code generation. Concrete; // subclasses of this implement code generation for specific CUDA; // runtime libraries.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGCUDARuntime.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCUDARuntime.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCUDARuntime.h:29,Integrability,Interface,Interface,29,"//===----- CGCUDARuntime.h - Interface to CUDA Runtimes ---------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This provides an abstract class for CUDA code generation. Concrete; // subclasses of this implement code generation for specific CUDA; // runtime libraries.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGCUDARuntime.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCUDARuntime.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCUDARuntime.h:10,Modifiability,variab,variable,10,// Global variable properties that must be passed to CUDA runtime.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGCUDARuntime.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCUDARuntime.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCUDARuntime.h:3,Modifiability,Variab,Variable,3,// Variable,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGCUDARuntime.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCUDARuntime.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCUDARuntime.h:12,Modifiability,variab,variable,12,// Constant variable.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGCUDARuntime.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCUDARuntime.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCUDARuntime.h:11,Modifiability,variab,variable,11,// Managed variable.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGCUDARuntime.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCUDARuntime.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCUDARuntime.h:26,Testability,stub,stub,26,/// Emits a kernel launch stub.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGCUDARuntime.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCUDARuntime.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCUDARuntime.h:20,Modifiability,variab,variable,20,/// Check whether a variable is a device variable and register it if true.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGCUDARuntime.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCUDARuntime.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCUDARuntime.h:41,Modifiability,variab,variable,41,/// Check whether a variable is a device variable and register it if true.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGCUDARuntime.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCUDARuntime.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCUDARuntime.h:24,Modifiability,variab,variable,24,/// Returns function or variable name on device side even if the current; /// compilation is for host.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGCUDARuntime.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCUDARuntime.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCUDARuntime.h:25,Testability,stub,stub,25,/// Get kernel handle by stub function.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGCUDARuntime.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCUDARuntime.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCUDARuntime.h:15,Testability,stub,stub,15,/// Get kernel stub by kernel handle.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGCUDARuntime.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCUDARuntime.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCUDARuntime.h:29,Modifiability,variab,variables,29,/// Adjust linkage of shadow variables in host compilation.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGCUDARuntime.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCUDARuntime.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCXX.cpp:16,Performance,optimiz,optimization,16,"// Disable this optimization for ARM64EC. FIXME: This probably should work,; // but getting the symbol table correct is complicated.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCXX.cpp:6,Security,sanitiz,sanitizing,6,"// If sanitizing memory to check for use-after-dtor, do not emit as; // an alias, unless this class owns no members.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCXX.cpp:55,Safety,safe,safe,55,"// Extra Credit: passing extra parameters is perfectly safe; // in many calling conventions, so only bail out if the ctor's; // calling convention is nonstandard.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCXX.cpp:60,Deployability,update,update,60,"// Give up if the calling conventions don't match. We could update the call,; // but it is probably not worth it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCXX.cpp:83,Availability,Avail,AvailableExternally,83,"// FIXME: An extern template instantiation will create functions with; // linkage ""AvailableExternally"". In libc++, some classes also define; // members with attribute ""AlwaysInline"" and expect no reference to; // be generated. It is desirable to reenable this optimisation after; // corresponding LLVM changes.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCXX.cpp:128,Safety,avoid,avoid,128,"// If we have a weak, non-discardable alias (weak, weak_odr), like an extern; // template instantiation or a dllexported class, avoid forming it on COFF.; // A COFF weak external alias cannot satisfy a normal undefined symbol; // reference from another TU. The other TU must also mark the referenced; // symbol as weak, which we cannot rely on.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCXX.cpp:55,Safety,avoid,avoids,55,"// Don't create an alias to a linker weak symbol. This avoids producing; // different COMDATs in different TUs. Another option would be to; // output the alias both for weak_odr and linkonce_odr, but that; // requires explicit comdat support in the IL.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCXX.cpp:37,Integrability,rout,routine,37,/// BuildAppleKextVirtualCall - This routine is to support gcc's kext ABI making; /// indirect call to virtual functions. It makes the call through indexing; /// into the vtable.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCXX.cpp:28,Integrability,rout,routine,28,/// BuildVirtualCall - This routine makes indirect vtable call for; /// call to virtual destructors. It returns 0 if it could not do it.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCXXABI.cpp:26,Integrability,Interface,Interface,26,"//===----- CGCXXABI.cpp - Interface to C++ ABIs ---------------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This provides an abstract class for C++ code generation. Concrete subclasses; // of this implement code generation for specific C++ ABIs.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGCXXABI.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCXXABI.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCXXABI.cpp:71,Availability,down,down,71,"// Compute the presumed alignment of 'this', which basically comes; // down to whether we know it's a complete object or not.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGCXXABI.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCXXABI.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCXXABI.cpp:3,Safety,avoid,avoid,3,// avoid vcall in common case,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGCXXABI.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCXXABI.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCXXABI.cpp:10,Modifiability,variab,variable,10,"// If the variable has an incomplete class type (or array thereof), it; // might need destruction.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGCXXABI.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCXXABI.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCXXABI.cpp:61,Modifiability,variab,variable,61,"// All later checks examine the initializer specified on the variable. If; // the variable is weak, such examination would not be correct.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGCXXABI.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCXXABI.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCXXABI.cpp:82,Modifiability,variab,variable,82,"// All later checks examine the initializer specified on the variable. If; // the variable is weak, such examination would not be correct.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGCXXABI.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCXXABI.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCXXABI.cpp:58,Integrability,wrap,wrapper,58,"// If we have the only definition, we don't need a thread wrapper if we; // will emit the value as a constant.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGCXXABI.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCXXABI.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCXXABI.cpp:31,Integrability,wrap,wrapper,31,"// Otherwise, we need a thread wrapper unless we know that every; // translation unit will emit the value as a constant. We rely on the; // variable being constant-initialized in every translation unit if it's; // constant-initialized in any translation unit, which isn't actually; // guaranteed by the standard but is necessary for sanity.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGCXXABI.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCXXABI.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCXXABI.cpp:140,Modifiability,variab,variable,140,"// Otherwise, we need a thread wrapper unless we know that every; // translation unit will emit the value as a constant. We rely on the; // variable being constant-initialized in every translation unit if it's; // constant-initialized in any translation unit, which isn't actually; // guaranteed by the standard but is necessary for sanity.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGCXXABI.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCXXABI.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCXXABI.h:24,Integrability,Interface,Interface,24,"//===----- CGCXXABI.h - Interface to C++ ABIs -------------------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This provides an abstract class for C++ code generation. Concrete subclasses; // of this implement code generation for specific C++ ABIs.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGCXXABI.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCXXABI.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCXXABI.h:4,Performance,Load,Loads,4,/// Loads the incoming C++ this pointer as it was passed by the caller.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGCXXABI.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCXXABI.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCXXABI.h:244,Availability,avail,available,244,"/// Determine whether we will definitely emit this variable with a constant; /// initializer, either because the language semantics demand it or because; /// we know that the initializer is a constant.; // For weak definitions, any initializer available in the current translation; // is not necessarily reflective of the initializer used; such initializers; // are ignored unless if InspectInitForWeakDef is true.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGCXXABI.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCXXABI.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCXXABI.h:51,Modifiability,variab,variable,51,"/// Determine whether we will definitely emit this variable with a constant; /// initializer, either because the language semantics demand it or because; /// we know that the initializer is a constant.; // For weak definitions, any initializer available in the current translation; // is not necessarily reflective of the initializer used; such initializers; // are ignored unless if InspectInitForWeakDef is true.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGCXXABI.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCXXABI.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCXXABI.h:168,Testability,log,logic,168,/// Determine whether there's something special about the rules of; /// the ABI tell us that 'this' is a complete object within the; /// given function. Obvious common logic like being defined on a; /// final class will have been taken care of by the caller.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGCXXABI.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCXXABI.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCXXABI.h:282,Integrability,depend,depend,282,"/// Returns true if the target allows calling a function through a pointer; /// with a different signature than the actual function (or equivalently,; /// bitcasting a function or function pointer to a different function type).; /// In principle in the most general case this could depend on the target, the; /// calling convention, and the actual types of the arguments and return; /// value. Here it just means whether the signature mismatch could *ever* be; /// allowed; in other words, does the target do strict checking of signatures; /// for all calls.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGCXXABI.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCXXABI.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCXXABI.h:4,Performance,Load,Load,4,/// Load a member function from an object and a member function; /// pointer. Apply the this-adjustment and set 'This' to the; /// adjusted value.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGCXXABI.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCXXABI.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCXXABI.h:4,Performance,Perform,Perform,4,"/// Perform a derived-to-base, base-to-derived, or bitcast member; /// pointer conversion.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGCXXABI.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCXXABI.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCXXABI.h:4,Performance,Perform,Perform,4,"/// Perform a derived-to-base, base-to-derived, or bitcast member; /// pointer conversion on a constant value.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGCXXABI.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCXXABI.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCXXABI.h:79,Modifiability,inherit,inheritance,79,"/// Emit the code to initialize hidden members required; /// to handle virtual inheritance, if needed by the ABI.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGCXXABI.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCXXABI.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCXXABI.h:4,Performance,Perform,Perform,4,"/// Perform ABI-specific ""this"" argument adjustment required prior to; /// a call of a virtual function.; /// The ""VirtualCall"" argument is true iff the call itself is virtual.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGCXXABI.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCXXABI.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCXXABI.h:22,Modifiability,variab,variable,22,/// Build a parameter variable suitable for 'this'.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGCXXABI.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCXXABI.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCXXABI.h:48,Modifiability,inherit,inheritance,48,"/// Emit any tables needed to implement virtual inheritance. For Itanium,; /// this emits virtual table tables. For the MSVC++ ABI, this emits virtual; /// base tables.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGCXXABI.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCXXABI.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCXXABI.h:483,Energy Efficiency,allocate,allocated,483,"/**************************** Array cookies ******************************/; /// Returns the extra size required in order to store the array; /// cookie for the given new-expression. May return 0 to indicate that no; /// array cookie is required.; ///; /// Several cases are filtered out before this method is called:; /// - non-array allocations never need a cookie; /// - calls to \::operator new(size_t, void*) never need a cookie; ///; /// \param expr - the new-expression being allocated.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGCXXABI.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCXXABI.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCXXABI.h:356,Energy Efficiency,allocate,allocated,356,"/// Initialize the array cookie for the given allocation.; ///; /// \param NewPtr - a char* which is the presumed-non-null; /// return value of the allocation function; /// \param NumElements - the computed number of elements,; /// potentially collapsed from the multidimensional array case;; /// always a size_t; /// \param ElementType - the base element allocated type,; /// i.e. the allocated type after stripping all array types",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGCXXABI.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCXXABI.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCXXABI.h:386,Energy Efficiency,allocate,allocated,386,"/// Initialize the array cookie for the given allocation.; ///; /// \param NewPtr - a char* which is the presumed-non-null; /// return value of the allocation function; /// \param NumElements - the computed number of elements,; /// potentially collapsed from the multidimensional array case;; /// always a size_t; /// \param ElementType - the base element allocated type,; /// i.e. the allocated type after stripping all array types",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGCXXABI.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCXXABI.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCXXABI.h:324,Energy Efficiency,allocate,allocated,324,"/// Reads the array cookie associated with the given pointer,; /// if it has one.; ///; /// \param Ptr - a pointer to the first element in the array; /// \param ElementType - the base element type of elements of the array; /// \param NumElements - an out parameter which will be initialized; /// with the number of elements allocated, or zero if there is no; /// cookie; /// \param AllocPtr - an out parameter which will be initialized; /// with a char* pointing to the address returned by the allocation; /// function; /// \param CookieSize - an out parameter which will be initialized; /// with the size of the cookie, or zero if there is no cookie",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGCXXABI.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCXXABI.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCXXABI.h:154,Modifiability,variab,variable,154,"/*************************** Static local guards ****************************/; /// Emits the guarded initializer and destructor setup for the given; /// variable, given that it couldn't be emitted as a constant.; /// If \p PerformInit is false, the initialization has been folded to a; /// constant and should not be performed.; ///; /// The variable may be:; /// - a static local variable; /// - a static data member of a class template instantiation",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGCXXABI.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCXXABI.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCXXABI.h:343,Modifiability,variab,variable,343,"/*************************** Static local guards ****************************/; /// Emits the guarded initializer and destructor setup for the given; /// variable, given that it couldn't be emitted as a constant.; /// If \p PerformInit is false, the initialization has been folded to a; /// constant and should not be performed.; ///; /// The variable may be:; /// - a static local variable; /// - a static data member of a class template instantiation",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGCXXABI.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCXXABI.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCXXABI.h:382,Modifiability,variab,variable,382,"/*************************** Static local guards ****************************/; /// Emits the guarded initializer and destructor setup for the given; /// variable, given that it couldn't be emitted as a constant.; /// If \p PerformInit is false, the initialization has been folded to a; /// constant and should not be performed.; ///; /// The variable may be:; /// - a static local variable; /// - a static data member of a class template instantiation",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGCXXABI.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCXXABI.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCXXABI.h:224,Performance,Perform,PerformInit,224,"/*************************** Static local guards ****************************/; /// Emits the guarded initializer and destructor setup for the given; /// variable, given that it couldn't be emitted as a constant.; /// If \p PerformInit is false, the initialization has been folded to a; /// constant and should not be performed.; ///; /// The variable may be:; /// - a static local variable; /// - a static data member of a class template instantiation",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGCXXABI.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCXXABI.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCXXABI.h:318,Performance,perform,performed,318,"/*************************** Static local guards ****************************/; /// Emits the guarded initializer and destructor setup for the given; /// variable, given that it couldn't be emitted as a constant.; /// If \p PerformInit is false, the initialization has been folded to a; /// constant and should not be performed.; ///; /// The variable may be:; /// - a static local variable; /// - a static data member of a class template instantiation",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGCXXABI.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCXXABI.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCXXABI.h:155,Modifiability,variab,variables,155,"/*************************** thread_local initialization ********************/; /// Emits ABI-required functions necessary to initialize thread_local; /// variables in this translation unit.; ///; /// \param CXXThreadLocals - The thread_local declarations in this translation; /// unit.; /// \param CXXThreadLocalInits - If this translation unit contains any; /// non-constant initialization or non-trivial destruction for; /// thread_local variables, a list of functions to perform the; /// initialization.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGCXXABI.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCXXABI.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCXXABI.h:441,Modifiability,variab,variables,441,"/*************************** thread_local initialization ********************/; /// Emits ABI-required functions necessary to initialize thread_local; /// variables in this translation unit.; ///; /// \param CXXThreadLocals - The thread_local declarations in this translation; /// unit.; /// \param CXXThreadLocalInits - If this translation unit contains any; /// non-constant initialization or non-trivial destruction for; /// thread_local variables, a list of functions to perform the; /// initialization.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGCXXABI.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCXXABI.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCXXABI.h:475,Performance,perform,perform,475,"/*************************** thread_local initialization ********************/; /// Emits ABI-required functions necessary to initialize thread_local; /// variables in this translation unit.; ///; /// \param CXXThreadLocals - The thread_local declarations in this translation; /// unit.; /// \param CXXThreadLocalInits - If this translation unit contains any; /// non-constant initialization or non-trivial destruction for; /// thread_local variables, a list of functions to perform the; /// initialization.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGCXXABI.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCXXABI.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCXXABI.h:120,Integrability,wrap,wrapper,120,// Determine if references to thread_local global variables can be made; // directly or require access through a thread wrapper function.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGCXXABI.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCXXABI.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCXXABI.h:50,Modifiability,variab,variables,50,// Determine if references to thread_local global variables can be made; // directly or require access through a thread wrapper function.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGCXXABI.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCXXABI.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCXXABI.h:96,Security,access,access,96,// Determine if references to thread_local global variables can be made; // directly or require access through a thread wrapper function.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGCXXABI.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCXXABI.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCXXABI.h:49,Modifiability,variab,variable,49,/// Emit a reference to a non-local thread_local variable (including; /// triggering the initialization of all thread_local variables in its; /// translation unit).,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGCXXABI.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCXXABI.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCXXABI.h:124,Modifiability,variab,variables,124,/// Emit a reference to a non-local thread_local variable (including; /// triggering the initialization of all thread_local variables in its; /// translation unit).,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGCXXABI.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCXXABI.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCXXABI.h:42,Modifiability,polymorphi,polymorphic,42,"/// Load a vtable from This, an object of polymorphic type RD, or from one of; /// its virtual bases if it does not have its own vtable. Returns the vtable; /// and the class from which the vtable was loaded.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGCXXABI.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCXXABI.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCXXABI.h:4,Performance,Load,Load,4,"/// Load a vtable from This, an object of polymorphic type RD, or from one of; /// its virtual bases if it does not have its own vtable. Returns the vtable; /// and the class from which the vtable was loaded.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGCXXABI.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCXXABI.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCXXABI.h:201,Performance,load,loaded,201,"/// Load a vtable from This, an object of polymorphic type RD, or from one of; /// its virtual bases if it does not have its own vtable. Returns the vtable; /// and the class from which the vtable was loaded.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGCXXABI.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCXXABI.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDebugInfo.cpp:61,Deployability,update,updates,61,// Query CGF so the location isn't overwritten when location updates are; // temporarily disabled (for C++ default function arguments),MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGDebugInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDebugInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDebugInfo.cpp:84,Availability,reliab,reliably,84,// quick optimization to avoid having to intern strings that are already; // stored reliably elsewhere,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGDebugInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDebugInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDebugInfo.cpp:9,Performance,optimiz,optimization,9,// quick optimization to avoid having to intern strings that are already; // stored reliably elsewhere,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGDebugInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDebugInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDebugInfo.cpp:25,Safety,avoid,avoid,25,// quick optimization to avoid having to intern strings that are already; // stored reliably elsewhere,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGDebugInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDebugInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDebugInfo.cpp:3,Performance,Cache,Cache,3,// Cache the results.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGDebugInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDebugInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDebugInfo.cpp:7,Security,Checksum,Checksum,7,// Put Checksum at a scope where it will persist past the createFile call.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGDebugInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDebugInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDebugInfo.cpp:123,Energy Efficiency,efficient,efficient,123,"// Strip the common prefix (if it is more than just ""/"" or ""C:\"") from; // current directory and FileName for a more space-efficient encoding.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGDebugInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDebugInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDebugInfo.cpp:332,Security,checksum,checksum,332,"// If the main file name provided is identical to the input file name, and; // if the input file is a preprocessed source, use the module name for; // debug info. The module name comes from the name specified in the first; // linemarker if the input is a preprocessed source. In this case we don't; // know the content to compute a checksum.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGDebugInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDebugInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDebugInfo.cpp:227,Testability,assert,assert,227,"// A single vector of bytes may not suffice as the representation of; // svcount_t tuples because of the gap between the active 16bits of; // successive tuple members. Currently no such tuples are defined for; // svcount_t, so assert that NumVectors is 1.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGDebugInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDebugInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDebugInfo.cpp:135,Availability,error,error,135,// It doesn't make sense to generate debug info for PowerPC MMA vector types.; // So we return a safe type here to avoid generating an error.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGDebugInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDebugInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDebugInfo.cpp:52,Energy Efficiency,Power,PowerPC,52,// It doesn't make sense to generate debug info for PowerPC MMA vector types.; // So we return a safe type here to avoid generating an error.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGDebugInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDebugInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDebugInfo.cpp:97,Safety,safe,safe,97,// It doesn't make sense to generate debug info for PowerPC MMA vector types.; // So we return a safe type here to avoid generating an error.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGDebugInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDebugInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDebugInfo.cpp:115,Safety,avoid,avoid,115,// It doesn't make sense to generate debug info for PowerPC MMA vector types.; // So we return a safe type here to avoid generating an error.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGDebugInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDebugInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDebugInfo.cpp:3,Availability,Mask,Mask,3,// Mask type only occupies one vector register.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGDebugInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDebugInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDebugInfo.cpp:10,Performance,scalab,scalable,10,"// In RVV scalable vector types, we encode 64 bits in the fixed part.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGDebugInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDebugInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDebugInfo.cpp:254,Deployability,update,updated,254,"// FIXME: For targets where long double, __ibm128 and __float128 have the; // same size, they are currently indistinguishable in the debugger without; // some special treatment. However, there is currently no consensus on; // encoding and this should be updated once a DWARF encoding exists for; // distinct floating point types of the same size.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGDebugInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDebugInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDebugInfo.cpp:79,Integrability,protocol,protocol,79,"// The frontend treats 'id' as a typedef to an ObjCObjectType,; // whereas 'id<protocol>' is treated as an ObjCPointerType. For the; // debug info, we want to emit 'id' in both cases.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGDebugInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDebugInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDebugInfo.cpp:638,Usability,simpl,simpler,638,"// Determines if the debug info for this tag declaration needs a type; // identifier. The purpose of the unique identifier is to deduplicate type; // information for identical types across TUs. Because of the C++ one definition; // rule (ODR), it is valid to assume that the type is defined the same way in; // every TU and its debug info is equivalent.; //; // C does not have the ODR, and it is common for codebases to contain multiple; // different definitions of a struct with the same name in different TUs.; // Therefore, if the type doesn't have a C++ mangling, don't give it an; // identifer. Type information in C is smaller and simpler than C++ type; // information, so the increase in debug info size is negligible.; //; // If the type is not externally visible, it should be unique to the current TU,; // and should not need an identifier to participate in type deduplication.; // However, when emitting CodeView, the format internally uses these; // unique type name identifers for references between debug info. For example,; // the method of a class in an anonymous namespace uses the identifer to refer; // to its parent class. The Microsoft C++ ABI attempts to provide unique names; // for such types, so when emitting CodeView, always use identifiers for C++; // types. This may create problems when attempting to emit CodeView when the MS; // C++ ABI is not in use.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGDebugInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDebugInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDebugInfo.cpp:79,Availability,redundant,redundant,79,// Blocks in OpenCL have unique constraints which make the standard fields; // redundant while requiring size and align fields for enqueue_kernel. See; // initializeForBlockHeader in CGBlocks.cpp,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGDebugInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDebugInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDebugInfo.cpp:79,Safety,redund,redundant,79,// Blocks in OpenCL have unique constraints which make the standard fields; // redundant while requiring size and align fields for enqueue_kernel. See; // initializeForBlockHeader in CGBlocks.cpp,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGDebugInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDebugInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDebugInfo.cpp:78,Performance,optimiz,optimization,78,"/// Convert an AccessSpecifier into the corresponding DINode flag.; /// As an optimization, return 0 if the access specifier equals the; /// default for the containing type.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGDebugInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDebugInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDebugInfo.cpp:15,Security,Access,AccessSpecifier,15,"/// Convert an AccessSpecifier into the corresponding DINode flag.; /// As an optimization, return 0 if the access specifier equals the; /// default for the containing type.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGDebugInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDebugInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDebugInfo.cpp:108,Security,access,access,108,"/// Convert an AccessSpecifier into the corresponding DINode flag.; /// As an optimization, return 0 if the access specifier equals the; /// default for the containing type.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGDebugInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDebugInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDebugInfo.cpp:3,Safety,Avoid,Avoid,3,// Avoid emitting DW_AT_calling_convention if the C convention was used.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGDebugInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDebugInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDebugInfo.cpp:25,Deployability,Update,Update,25,// [FIXME: swiftasynccc] Update to SwiftAsync once LLVM support lands.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGDebugInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDebugInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDebugInfo.cpp:117,Modifiability,variab,variable,117,"// For C++11 Lambdas a Field will be the same as a Capture, but the Capture; // has the name and the location of the variable so we should iterate over; // both concurrently.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGDebugInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDebugInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDebugInfo.cpp:161,Performance,concurren,concurrently,161,"// For C++11 Lambdas a Field will be the same as a Capture, but the Capture; // has the name and the location of the variable so we should iterate over; // both concurrently.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGDebugInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDebugInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDebugInfo.cpp:40,Modifiability,variab,variable,40,"// Create the descriptor for the static variable, with or without; // constant initializers.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGDebugInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDebugInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDebugInfo.cpp:13,Safety,avoid,avoid,13,// FIXME: to avoid complications with type merging we should; // emit the constant on the definition instead of the declaration.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGDebugInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDebugInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDebugInfo.cpp:3,Integrability,Inject,Injected,3,// Injected class names are not considered nested records.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGDebugInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDebugInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDebugInfo.cpp:3,Security,Inject,Injected,3,// Injected class names are not considered nested records.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGDebugInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDebugInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDebugInfo.cpp:8,Modifiability,variab,variable,8,// Skip variable template specializations when emitting CodeView. MSVC; // doesn't emit them.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGDebugInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDebugInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDebugInfo.cpp:357,Integrability,wrap,wrapper,357,"// Keep the removed qualifiers in sync with; // CreateQualifiedType(const FunctionPrototype*, DIFile *Unit); // On a 'real' member function type, these qualifiers are carried on the type; // of the first parameter, not as separate DW_TAG_const_type (etc) decorator; // tags around them. (But, in the raw function types with qualifiers, they have; // to use wrapper types.); // Add ""this"" pointer.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGDebugInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDebugInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDebugInfo.cpp:282,Modifiability,inherit,inherits,282,"// CodeView only records the vftable offset in the class that introduces; // the virtual method. This is possible because, unlike Itanium, the MS; // C++ ABI does not include all virtual methods from non-primary bases in; // the vtable for the most derived class. For example, if C inherits from; // A and B, C's primary vftable will not include B's virtual methods.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGDebugInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDebugInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDebugInfo.cpp:68,Safety,avoid,avoids,68,"// If the member is implicit, don't add it to the member list. This avoids; // the member being added to type units by LLVM, while still allowing it; // to be emitted into the type declaration/reference inside the compile; // unit.; // Ditto 'nodebug' methods, for consistency with CodeGenFunction.cpp.; // FIXME: Handle Using(Shadow?)Decls here to create; // DW_TAG_imported_declarations inside the class for base decls brought into; // derived classes. GDB doesn't seem to notice/leverage these when I tried; // it, so I'm not rushing to fix this. (GCC seems to produce them, if; // referenced)",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGDebugInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDebugInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDebugInfo.cpp:108,Availability,avail,available,108,"// Skip retrieve the value if that template parameter has cuda device; // attribute, i.e. that value is not available at the host side.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGDebugInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDebugInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDebugInfo.cpp:3,Modifiability,Variab,Variable,3,// Variable pointer template parameters have a value that is the address; // of the variable.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGDebugInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDebugInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDebugInfo.cpp:84,Modifiability,variab,variable,84,// Variable pointer template parameters have a value that is the address; // of the variable.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGDebugInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDebugInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDebugInfo.cpp:100,Modifiability,refactor,refactored,100,// These five lines (& possibly the above member function pointer; // handling) might be able to be refactored to use similar code in; // CodeGenModule::getMemberPointerConstant,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGDebugInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDebugInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDebugInfo.cpp:41,Usability,simpl,simple,41,// But treat member function pointers as simple zero integers because; // it's easier than having a special case in LLVM's CodeGen. If LLVM; // CodeGen grows handling for values of non-null member function; // pointers then perhaps we could remove this special case and rely on; // EmitNullMemberPointer for member function pointers.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGDebugInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDebugInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDebugInfo.cpp:43,Modifiability,variab,variable,43,"// Print the normal qualified name for the variable, then break off the last; // NNS, and add the appropriate other text. Clang always prints the global; // variable name without template arguments, so we can use rsplit(""::"") and; // then recombine the pieces.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGDebugInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDebugInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDebugInfo.cpp:157,Modifiability,variab,variable,157,"// Print the normal qualified name for the variable, then break off the last; // NNS, and add the appropriate other text. Clang always prints the global; // variable name without template arguments, so we can use rsplit(""::"") and; // then recombine the pieces.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGDebugInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDebugInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDebugInfo.cpp:78,Modifiability,extend,extendable,78,"// Don't emit any vtable shape or vptr info if this class doesn't have an; // extendable vfptr. This can happen if the class doesn't have virtual; // methods, or in the MS ABI if those virtual methods only come from virtually; // inherited bases.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGDebugInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDebugInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDebugInfo.cpp:230,Modifiability,inherit,inherited,230,"// Don't emit any vtable shape or vptr info if this class doesn't have an; // extendable vfptr. This can happen if the class doesn't have virtual; // methods, or in the MS ABI if those virtual methods only come from virtually; // inherited bases.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGDebugInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDebugInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDebugInfo.cpp:336,Performance,optimiz,optimization,336,"// Constructor homing can be used for classes that cannnot be constructed; // without emitting code for one of their constructors. This is classes that; // don't have trivial or constexpr constructors, or can be created from; // aggregate initialization. Also skip lambda objects because they don't call; // constructors.; // Skip this optimization if the class or any of its methods are marked; // dllimport.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGDebugInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDebugInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDebugInfo.cpp:185,Performance,optimiz,optimization,185,"// Only emit complete debug info for a dynamic class when its vtable is; // emitted. However, Microsoft debuggers don't resolve type information; // across DLL boundaries, so skip this optimization if the class or any of its; // methods are marked dllimport. This isn't a complete solution, since objects; // without any dllimport methods can be used in one DLL and constructed in; // another, but it is the current behavior of LimitedDebugInfo.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGDebugInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDebugInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDebugInfo.cpp:115,Integrability,depend,depend,115,"// what about nested types?; // Note: The split of CXXDecl information here is intentional, the; // gdb tests will depend on a certain ordering at printout. The debug; // information offsets are still correct if we merge them all together; // though.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGDebugInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDebugInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDebugInfo.cpp:104,Testability,test,tests,104,"// what about nested types?; // Note: The split of CXXDecl information here is intentional, the; // gdb tests will depend on a certain ordering at printout. The debug; // information offsets are still correct if we merge them all together; // though.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGDebugInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDebugInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDebugInfo.cpp:41,Modifiability,variab,variables,41,// Collect data fields (including static variables and any initializers).,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGDebugInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDebugInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDebugInfo.cpp:10,Integrability,protocol,protocols,10,// Ignore protocols.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGDebugInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDebugInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDebugInfo.cpp:10,Integrability,protocol,protocols,10,// Ignore protocols.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGDebugInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDebugInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDebugInfo.cpp:46,Performance,cache,cache,46,"// Use the Module pointer as the key into the cache. This is a; // nullptr if the ""Module"" is a PCH, which is safe because we don't; // support chained PCH debug info, so there can only be a single PCH.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGDebugInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDebugInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDebugInfo.cpp:110,Safety,safe,safe,110,"// Use the Module pointer as the key into the cache. This is a; // nullptr if the ""Module"" is a PCH, which is safe because we don't; // support chained PCH debug info, so there can only be a single PCH.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGDebugInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDebugInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDebugInfo.cpp:77,Safety,detect,detects,77,"// PCH files don't have a signature field in the control block,; // but LLVM detects skeleton CUs by looking for a non-zero DWO id.; // We use the lower 64 bits for debug info.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGDebugInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDebugInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDebugInfo.cpp:359,Availability,mask,mask,359,"// Boolean ext_vector_type(N) are special because their real element type; // (bits of bit size) is not their Clang element type (_Bool of size byte).; // For now, we pretend the boolean vector were actually a vector of bytes; // (where each byte represents 8 bits of the actual vector).; // FIXME Debug info should actually represent this proper as a vector mask; // type.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGDebugInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDebugInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDebugInfo.cpp:14,Modifiability,inherit,inheritance,14,// Set the MS inheritance model. There is no flag for the unspecified model.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGDebugInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDebugInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDebugInfo.cpp:7,Deployability,update,update,7,// And update the type cache.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGDebugInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDebugInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDebugInfo.cpp:23,Performance,cache,cache,23,// And update the type cache.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGDebugInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDebugInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDebugInfo.cpp:15,Performance,cache,cached,15,// We may have cached a forward decl when we could have created; // a non-forward decl. Go ahead and create a non-forward decl; // now.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGDebugInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDebugInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDebugInfo.cpp:7,Deployability,update,update,7,// And update the type cache.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGDebugInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDebugInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDebugInfo.cpp:23,Performance,cache,cache,23,// And update the type cache.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGDebugInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDebugInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDebugInfo.cpp:116,Energy Efficiency,efficient,efficient,116,"// Elements of composite types usually have back to the type, creating; // uniquing cycles. Distinct nodes are more efficient.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGDebugInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDebugInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDebugInfo.cpp:259,Modifiability,variab,variables,259,"// Since we emit declarations (DW_AT_members) for static members, place the; // definition of those static members in the namespace they were declared in; // in the source code (the lexical decl context).; // FIXME: Generalize this for even non-member global variables where the; // declaration and definition may have different lexical decl contexts, once; // we have support for emitting declarations of (non-member) global variables.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGDebugInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDebugInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDebugInfo.cpp:426,Modifiability,variab,variables,426,"// Since we emit declarations (DW_AT_members) for static members, place the; // definition of those static members in the namespace they were declared in; // in the source code (the lexical decl context).; // FIXME: Generalize this for even non-member global variables where the; // declaration and definition may have different lexical decl contexts, once; // we have support for emitting declarations of (non-member) global variables.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGDebugInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDebugInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDebugInfo.cpp:3,Testability,Stub,Stub,3,/* Stub = */,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGDebugInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDebugInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDebugInfo.cpp:3,Testability,Stub,Stub,3,/* Stub = */,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGDebugInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDebugInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDebugInfo.cpp:227,Availability,avail,available,227,"// We only need a declaration (not a definition) of the type - so use whatever; // we would otherwise do to get a type for a pointee. (forward declarations in; // limited debug info, full definitions (if the type definition is available); // in unlimited debug info)",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGDebugInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDebugInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDebugInfo.cpp:31,Performance,cache,cache,31,// Search imported declaration cache if it is already defined; // as imported declaration.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGDebugInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDebugInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDebugInfo.cpp:81,Integrability,interface,interface,81,// Starting with DWARF V5 method declarations are emitted as children of; // the interface type.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGDebugInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDebugInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDebugInfo.cpp:46,Availability,avail,available,46,// If there is a subprogram for this function available then use it.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGDebugInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDebugInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDebugInfo.cpp:66,Modifiability,variab,variable,66,// This is a global initializer or atexit destructor for a global variable.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGDebugInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDebugInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDebugInfo.cpp:193,Performance,cache,cache,193,// We might get here with a VarDecl in the case we're generating; // code for the initialization of globals. Do not record these decls; // as they will overwrite the actual VarDecl Decl in the cache.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGDebugInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDebugInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDebugInfo.cpp:48,Availability,avail,available,48,// If there is a DISubprogram for this function available then use it.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGDebugInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDebugInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDebugInfo.cpp:46,Availability,avail,available,46,// If there is a subprogram for this function available then use it.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGDebugInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDebugInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDebugInfo.cpp:3,Deployability,Update,Update,3,// Update our current location,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGDebugInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDebugInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDebugInfo.cpp:84,Modifiability,variab,variable,84,// If there is no debug info for this type then do not emit debug info; // for this variable.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGDebugInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDebugInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDebugInfo.cpp:33,Modifiability,variab,variables,33,"// GDB has trouble finding local variables in anonymous unions, so we emit; // artificial local variables for each of the members.; //; // FIXME: Remove this code as soon as GDB supports this.; // The debug info verifier in LLVM operates based on the assumption that a; // variable has the same size as its storage and we had to disable the; // check for artificial variables.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGDebugInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDebugInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDebugInfo.cpp:96,Modifiability,variab,variables,96,"// GDB has trouble finding local variables in anonymous unions, so we emit; // artificial local variables for each of the members.; //; // FIXME: Remove this code as soon as GDB supports this.; // The debug info verifier in LLVM operates based on the assumption that a; // variable has the same size as its storage and we had to disable the; // check for artificial variables.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGDebugInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDebugInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDebugInfo.cpp:273,Modifiability,variab,variable,273,"// GDB has trouble finding local variables in anonymous unions, so we emit; // artificial local variables for each of the members.; //; // FIXME: Remove this code as soon as GDB supports this.; // The debug info verifier in LLVM operates based on the assumption that a; // variable has the same size as its storage and we had to disable the; // check for artificial variables.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGDebugInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDebugInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDebugInfo.cpp:366,Modifiability,variab,variables,366,"// GDB has trouble finding local variables in anonymous unions, so we emit; // artificial local variables for each of the members.; //; // FIXME: Remove this code as soon as GDB supports this.; // The debug info verifier in LLVM operates based on the assumption that a; // variable has the same size as its storage and we had to disable the; // check for artificial variables.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGDebugInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDebugInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDebugInfo.cpp:176,Modifiability,variab,variable,176,// Clang stores the sret pointer provided by the caller in a static alloca.; // Use DW_OP_deref to tell the debugger to load the pointer and treat it as; // the address of the variable.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGDebugInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDebugInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDebugInfo.cpp:120,Performance,load,load,120,// Clang stores the sret pointer provided by the caller in a static alloca.; // Use DW_OP_deref to tell the debugger to load the pointer and treat it as; // the address of the variable.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGDebugInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDebugInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDebugInfo.cpp:33,Modifiability,variab,variable,33,// Create the descriptor for the variable.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGDebugInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDebugInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDebugInfo.cpp:20,Modifiability,variab,variable,20,"// For normal local variable, we will try to find out whether 'VD' is the; // copy parameter of coroutine.; // If yes, we are going to use DIVariable of the origin parameter instead; // of creating the new one.; // If no, it might be a normal alloc, we just create a new one for it.; // Check whether the VD is move parameters.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGDebugInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDebugInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDebugInfo.cpp:252,Testability,log,logic,252,"// Find an integer type with the same bitwidth as the bitfield size. If; // no suitable type is present in the target, give up on producing debug; // information as it would be wrong. It is certainly possible to produce; // correct debug info, but the logic isn't currently implemented.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGDebugInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDebugInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDebugInfo.cpp:84,Modifiability,variab,variable,84,// If there is no debug info for this type then do not emit debug info; // for this variable.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGDebugInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDebugInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDebugInfo.cpp:176,Modifiability,variab,variable,176,// Clang stores the sret pointer provided by the caller in a static alloca.; // Use DW_OP_deref to tell the debugger to load the pointer and treat it as; // the address of the variable.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGDebugInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDebugInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDebugInfo.cpp:120,Performance,load,load,120,// Clang stores the sret pointer provided by the caller in a static alloca.; // Use DW_OP_deref to tell the debugger to load the pointer and treat it as; // the address of the variable.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGDebugInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDebugInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDebugInfo.cpp:33,Modifiability,variab,variable,33,// Create the descriptor for the variable.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGDebugInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDebugInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDebugInfo.cpp:99,Modifiability,variab,variable,99,// Don't emit an llvm.dbg.declare for the composite storage as it doesn't; // correspond to a user variable.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGDebugInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDebugInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDebugInfo.cpp:47,Modifiability,variab,variable,47,// Self is passed along as an implicit non-arg variable in a; // block. Mark it as the object pointer.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGDebugInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDebugInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDebugInfo.cpp:33,Modifiability,variab,variable,33,// Create the descriptor for the variable.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGDebugInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDebugInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDebugInfo.cpp:79,Availability,redundant,redundant,79,// Blocks in OpenCL have unique constraints which make the standard fields; // redundant while requiring size and align fields for enqueue_kernel. See; // initializeForBlockHeader in CGBlocks.cpp,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGDebugInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDebugInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDebugInfo.cpp:79,Safety,redund,redundant,79,// Blocks in OpenCL have unique constraints which make the standard fields; // redundant while requiring size and align fields for enqueue_kernel. See; // initializeForBlockHeader in CGBlocks.cpp,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGDebugInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDebugInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDebugInfo.cpp:3,Modifiability,Variab,Variable,3,// Variable captures.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGDebugInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDebugInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDebugInfo.cpp:37,Performance,cache,cache,37,"// If the member wasn't found in the cache, lazily construct and add it to the; // type (used when a limited form of the type is emitted).",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGDebugInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDebugInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDebugInfo.cpp:27,Testability,Test,Test,27,// anonymous namespace; // Test whether a type name could be rebuilt from emitted debug info.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGDebugInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDebugInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDebugInfo.cpp:67,Modifiability,variab,variables,67,"// Reference and pointer non-type template parameters point to; // variables, functions, etc and their value is, at best (for; // variables) represented as an address - not a reference to the; // DWARF describing the variable/function/etc. This makes it hard,; // possibly impossible to rebuild the original name - looking up the; // address in the executable file's symbol table would be needed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGDebugInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDebugInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDebugInfo.cpp:130,Modifiability,variab,variables,130,"// Reference and pointer non-type template parameters point to; // variables, functions, etc and their value is, at best (for; // variables) represented as an address - not a reference to the; // DWARF describing the variable/function/etc. This makes it hard,; // possibly impossible to rebuild the original name - looking up the; // address in the executable file's symbol table would be needed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGDebugInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDebugInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDebugInfo.cpp:217,Modifiability,variab,variable,217,"// Reference and pointer non-type template parameters point to; // variables, functions, etc and their value is, at best (for; // variables) represented as an address - not a reference to the; // DWARF describing the variable/function/etc. This makes it hard,; // possibly impossible to rebuild the original name - looking up the; // address in the executable file's symbol table would be needed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGDebugInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDebugInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDebugInfo.cpp:1202,Safety,detect,detecting,1202,"// A conversion operator presents complications/ambiguity if there's a; // conversion to class template that is itself a template, eg:; // template<typename T>; // operator ns::t1<T, int>();; // This should be named, eg: ""operator ns::t1<float, int><float>""; // (ignoring clang bug that means this is currently ""operator t1<float>""); // but if the arguments were stripped, the consumer couldn't differentiate; // whether the template argument list for the conversion type was the; // function's argument list (& no reconstitution was needed) or not.; // This could be handled if reconstitutable names had a separate attribute; // annotating them as such - this would remove the ambiguity.; //; // Alternatively the template argument list could be parsed enough to check; // whether there's one list or two, then compare that with the DWARF; // description of the return type and the template argument lists to determine; // how many lists there should be and if one is missing it could be assumed(?); // to be the function's template argument list & then be rebuilt.; //; // Other operator overloads that aren't conversion operators could be; // reconstituted but would require a bit more nuance about detecting the; // difference between these different operators during that rebuilding.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGDebugInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDebugInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDebugInfo.cpp:17,Modifiability,variab,variable,17,// Create global variable debug descriptor.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGDebugInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDebugInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDebugInfo.cpp:31,Modifiability,variab,variable,31,// Attempt to store one global variable for the declaration - even if we; // emit a lot of fields.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGDebugInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDebugInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDebugInfo.cpp:70,Modifiability,variab,variable,70,// If this is an anonymous union then we'll want to emit a global; // variable for each member of the anonymous union so that it's possible; // to find the name of any field in the union.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGDebugInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDebugInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDebugInfo.cpp:33,Modifiability,variab,variable,33,// Create the descriptor for the variable.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGDebugInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDebugInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDebugInfo.cpp:37,Modifiability,variab,variables,37,"// If CodeView, emit enums as global variables, unless they are defined; // inside a class. We do this because MSVC doesn't emit S_CONSTANTs for; // enums in classes, and because it is difficult to attach this scope; // information to the global variable.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGDebugInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDebugInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDebugInfo.cpp:246,Modifiability,variab,variable,246,"// If CodeView, emit enums as global variables, unless they are defined; // inside a class. We do this because MSVC doesn't emit S_CONSTANTs for; // enums in classes, and because it is difficult to attach this scope; // information to the global variable.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGDebugInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDebugInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDebugInfo.cpp:26,Performance,cache,cache,26,// Record this DIE in the cache for nested declaration reference.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGDebugInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDebugInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDebugInfo.cpp:51,Safety,detect,detect,51,// Emitting one decl is sufficient - debuggers can detect that this is an; // overloaded name & provide lookup for all the overloads.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGDebugInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDebugInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDebugInfo.cpp:14,Performance,cache,cache,14,// This could cache & dedup here rather than relying on metadata deduping.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGDebugInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDebugInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDebugInfo.cpp:109,Performance,cache,cache,109,"// Creating types might create further types - invalidating the current; // element and the size(), so don't cache/reference them.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGDebugInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDebugInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDebugInfo.cpp:18,Integrability,interface,interface,18,// Add methods to interface.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGDebugInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDebugInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDebugInfo.cpp:165,Safety,avoid,avoiding,165,"// If there has been no definition for the declaration, call RAUW; // with ourselves, that will destroy the temporary MDNode and; // replace it with a standard one, avoiding leaking memory.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGDebugInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDebugInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDebugInfo.cpp:101,Performance,cache,cache,101,"// We keep our own list of retained types, because we need to look; // up the final type in the type cache.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGDebugInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDebugInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDebugInfo.cpp:51,Performance,optimiz,optimized,51,"// Call site-related attributes are only useful in optimized programs, and; // when there's a possibility of debugging backtraces.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGDebugInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDebugInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDebugInfo.cpp:36,Availability,avail,available,36,"// Call site-related attributes are available in DWARF v5. Some debuggers,; // while not fully DWARF v5-compliant, may accept these attributes as if they; // were part of DWARF v4.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGDebugInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDebugInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDebugInfo.h:4,Performance,Cache,Cache,4,/// Cache of previously constructed Types.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGDebugInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDebugInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDebugInfo.h:4,Performance,Cache,Cache,4,"/// Cache that maps VLA types to size expressions for that type,; /// represented by instantiated Metadata nodes.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGDebugInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDebugInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDebugInfo.h:36,Integrability,interface,interfaces,36,/// Cache of previously constructed interfaces which may change.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGDebugInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDebugInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDebugInfo.h:4,Performance,Cache,Cache,4,/// Cache of previously constructed interfaces which may change.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGDebugInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDebugInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDebugInfo.h:63,Integrability,interface,interface,63,"/// Cache of forward declarations for methods belonging to the interface.; /// The extra bit on the DISubprogram specifies whether a method is; /// ""objc_direct"".",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGDebugInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDebugInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDebugInfo.h:4,Performance,Cache,Cache,4,"/// Cache of forward declarations for methods belonging to the interface.; /// The extra bit on the DISubprogram specifies whether a method is; /// ""objc_direct"".",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGDebugInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDebugInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDebugInfo.h:4,Performance,Cache,Cache,4,/// Cache of references to clang modules and precompiled headers.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGDebugInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDebugInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDebugInfo.h:12,Integrability,interface,interfaces,12,/// List of interfaces we want to keep even if orphaned.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGDebugInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDebugInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDebugInfo.h:4,Performance,Cache,Cache,4,/// Cache of forward declared types to RAUW at the end of compilation.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGDebugInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDebugInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDebugInfo.h:66,Modifiability,variab,variables,66,/// Cache of replaceable forward declarations (functions and; /// variables) to RAUW at the end of compilation.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGDebugInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDebugInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDebugInfo.h:4,Performance,Cache,Cache,4,/// Cache of replaceable forward declarations (functions and; /// variables) to RAUW at the end of compilation.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGDebugInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDebugInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDebugInfo.h:110,Modifiability,variab,variables,110,/// Cache declarations relevant to DW_TAG_imported_declarations (C++; /// using declarations and global alias variables) that aren't covered; /// by other more specific caches.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGDebugInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDebugInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDebugInfo.h:4,Performance,Cache,Cache,4,/// Cache declarations relevant to DW_TAG_imported_declarations (C++; /// using declarations and global alias variables) that aren't covered; /// by other more specific caches.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGDebugInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDebugInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDebugInfo.h:169,Performance,cache,caches,169,/// Cache declarations relevant to DW_TAG_imported_declarations (C++; /// using declarations and global alias variables) that aren't covered; /// by other more specific caches.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGDebugInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDebugInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDebugInfo.h:84,Integrability,interface,interface,84,/// Helper functions for getOrCreateType.; /// @{; /// Currently the checksum of an interface includes the number of; /// ivars and property accessors.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGDebugInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDebugInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDebugInfo.h:69,Security,checksum,checksum,69,/// Helper functions for getOrCreateType.; /// @{; /// Currently the checksum of an interface includes the number of; /// ivars and property accessors.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGDebugInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDebugInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDebugInfo.h:141,Security,access,accessors,141,/// Helper functions for getOrCreateType.; /// @{; /// Currently the checksum of an interface includes the number of; /// ivars and property accessors.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGDebugInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDebugInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDebugInfo.h:20,Integrability,interface,interface,20,/// Get Objective-C interface type.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGDebugInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDebugInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDebugInfo.h:330,Integrability,interface,interface,330,"/// Look up the completed type for a self pointer in the TypeCache and; /// create a copy of it with the ObjectPointer and Artificial flags; /// set. If the type is not cached, a new one is created. This should; /// never happen though, since creating a type for the implicit self; /// argument implies that we already parsed the interface definition; /// and the ivar declarations in the implementation.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGDebugInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDebugInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDebugInfo.h:169,Performance,cache,cached,169,"/// Look up the completed type for a self pointer in the TypeCache and; /// create a copy of it with the ObjectPointer and Artificial flags; /// set. If the type is not cached, a new one is created. This should; /// never happen though, since creating a type for the implicit self; /// argument implies that we already parsed the interface definition; /// and the ivar declarations in the implementation.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGDebugInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDebugInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDebugInfo.h:34,Performance,cache,cache,34,/// @}; /// Get the type from the cache or return null type if it doesn't; /// exist.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGDebugInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDebugInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDebugInfo.h:119,Deployability,update,updated,119,/// Return the debug type for a C++ method.; /// \arg CXXMethodDecl is of FunctionType. This function type is; /// not updated to include implicit \c this pointer. Use this routine; /// to get a method type which includes \c this pointer.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGDebugInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDebugInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDebugInfo.h:173,Integrability,rout,routine,173,/// Return the debug type for a C++ method.; /// \arg CXXMethodDecl is of FunctionType. This function type is; /// not updated to include implicit \c this pointer. Use this routine; /// to get a method type which includes \c this pointer.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGDebugInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDebugInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDebugInfo.h:111,Modifiability,extend,extended,111,"/// If target-specific LLVM \p AddressSpace directly maps to target-specific; /// DWARF address space, appends extended dereferencing mechanism to complex; /// expression \p Expr. Otherwise, does nothing.; ///; /// Extended dereferencing mechanism is has the following format:; /// DW_OP_constu <DWARF Address Space> DW_OP_swap DW_OP_xderef",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGDebugInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDebugInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDebugInfo.h:215,Modifiability,Extend,Extended,215,"/// If target-specific LLVM \p AddressSpace directly maps to target-specific; /// DWARF address space, appends extended dereferencing mechanism to complex; /// expression \p Expr. Otherwise, does nothing.; ///; /// Extended dereferencing mechanism is has the following format:; /// DW_OP_constu <DWARF Address Space> DW_OP_swap DW_OP_xderef",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGDebugInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDebugInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDebugInfo.h:114,Availability,avail,available,114,/// A helper function to collect debug info for the default elements of a; /// block.; ///; /// \returns The next available field offset after the default elements.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGDebugInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDebugInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDebugInfo.h:12,Deployability,Update,Update,12,/// @}; /// Update the current source location. If \arg loc is invalid it is; /// ignored.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGDebugInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDebugInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDebugInfo.h:4,Deployability,Update,Update,4,/// Update the current inline scope. All subsequent calls to \p EmitLocation; /// will create a location with this inlinedAt field.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGDebugInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDebugInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDebugInfo.h:54,Modifiability,variab,variable,54,"/// Emit call to \c llvm.dbg.declare for an automatic variable; /// declaration.; /// Returns a pointer to the DILocalVariable associated with the; /// llvm.dbg.declare, or nullptr otherwise.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGDebugInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDebugInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDebugInfo.h:53,Modifiability,variab,variable,53,/// Emit call to \c llvm.dbg.declare for an imported variable; /// declaration in a block.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGDebugInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDebugInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDebugInfo.h:53,Modifiability,variab,variable,53,/// Emit call to \c llvm.dbg.declare for an argument variable; /// declaration.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGDebugInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDebugInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDebugInfo.h:36,Modifiability,variab,variable,36,/// Emit information about a global variable.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGDebugInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDebugInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDebugInfo.h:27,Modifiability,variab,variable,27,/// Emit a constant global variable's debug info.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGDebugInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDebugInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDebugInfo.h:39,Modifiability,variab,variable,39,/// Emit information about an external variable.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGDebugInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDebugInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDebugInfo.h:34,Modifiability,variab,variable,34,/// Emit information about global variable alias.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGDebugInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDebugInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDebugInfo.h:256,Security,sanitiz,sanitizers,256,"/// DebugInfo isn't attached to string literals by default. While certain; /// aspects of debuginfo aren't useful for string literals (like a name), it's; /// nice to be able to symbolize the line and column information. This is; /// especially useful for sanitizers, as it allows symbolization of; /// heap-buffer-overflows on constant strings.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGDebugInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDebugInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDebugInfo.h:24,Integrability,interface,interface,24,/// Emit an Objective-C interface type standalone debug info.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGDebugInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDebugInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDebugInfo.h:40,Modifiability,variab,variable,40,"/// Emit call to llvm.dbg.declare for a variable declaration.; /// Returns a pointer to the DILocalVariable associated with the; /// llvm.dbg.declare, or nullptr otherwise.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGDebugInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDebugInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDebugInfo.h:8,Integrability,wrap,wrapper,8,/// The wrapper struct used inside the __block_literal struct.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGDebugInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDebugInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDebugInfo.h:21,Security,checksum,checksum,21,/// Compute the file checksum debug info for input file ID.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGDebugInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDebugInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDebugInfo.h:26,Performance,cache,cache,26,/// Get the type from the cache or create a new type if necessary.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGDebugInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDebugInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDebugInfo.h:26,Performance,cache,cache,26,/// Get the type from the cache or create a new partial type if; /// necessary.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGDebugInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDebugInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDebugInfo.h:58,Testability,stub,stub,58,/// Helper that either creates a forward declaration or a stub.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGDebugInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDebugInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDebugInfo.h:102,Integrability,wrap,wrapped,102,/// Create a subprogram describing the forward declaration; /// represented in the given FunctionDecl wrapped in a GlobalDecl.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGDebugInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDebugInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDebugInfo.h:93,Integrability,wrap,wrapped,93,/// Create a DISubprogram describing the function; /// represented in the given FunctionDecl wrapped in a GlobalDecl.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGDebugInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDebugInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDebugInfo.h:20,Modifiability,variab,variable,20,/// Create a global variable describing the forward declaration; /// represented in the given VarDecl.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGDebugInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDebugInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDebugInfo.h:20,Modifiability,variab,variable,20,/// Return a global variable that represents one of the collection of global; /// variables created for an anonmyous union.; ///; /// Recursively collect all of the member fields of a global; /// anonymous decl and create static variables for them. The first; /// time this is called it needs to be on a union and then from; /// there we can have additional unnamed fields.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGDebugInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDebugInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDebugInfo.h:82,Modifiability,variab,variables,82,/// Return a global variable that represents one of the collection of global; /// variables created for an anonmyous union.; ///; /// Recursively collect all of the member fields of a global; /// anonymous decl and create static variables for them. The first; /// time this is called it needs to be on a union and then from; /// there we can have additional unnamed fields.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGDebugInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDebugInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDebugInfo.h:229,Modifiability,variab,variables,229,/// Return a global variable that represents one of the collection of global; /// variables created for an anonmyous union.; ///; /// Recursively collect all of the member fields of a global; /// anonymous decl and create static variables for them. The first; /// time this is called it needs to be on a union and then from; /// there we can have additional unnamed fields.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGDebugInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDebugInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDebugInfo.h:83,Testability,stub,stub,83,/// Get the name to use in the debug info for a dynamic initializer or atexit; /// stub function.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGDebugInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDebugInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDebugInfo.h:114,Availability,failure,failure,114,/// Create a DIExpression representing the constant corresponding; /// to the specified 'Val'. Returns nullptr on failure.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGDebugInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDebugInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDebugInfo.h:4,Energy Efficiency,Allocate,Allocate,4,/// Allocate a copy of \p A using the DebugInfoNames allocator; /// and return a reference to it. If multiple arguments are given the strings; /// are concatenated.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGDebugInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDebugInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDecl.cpp:54,Modifiability,variab,variable,54,"/// EmitVarDecl - This method handles emission of any variable declaration; /// inside a function, including static vars etc.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDecl.cpp:23,Modifiability,variab,variable,23,"// Some function-scope variable does not have static storage but still; // needs to be emitted like a static variable, e.g. a function-scope; // variable in constant address space in OpenCL.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDecl.cpp:109,Modifiability,variab,variable,109,"// Some function-scope variable does not have static storage but still; // needs to be emitted like a static variable, e.g. a function-scope; // variable in constant address space in OpenCL.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDecl.cpp:145,Modifiability,variab,variable,145,"// Some function-scope variable does not have static storage but still; // needs to be emitted like a static variable, e.g. a function-scope; // variable in constant address space in OpenCL.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDecl.cpp:18,Modifiability,variab,variables,18,// Static sampler variables translated to function calls.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDecl.cpp:55,Modifiability,variab,variable,55,// FIXME: We need to force the emission/use of a guard variable for; // some variables even if we can constant-evaluate them because; // we can't guarantee every translation unit will constant-evaluate them.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDecl.cpp:77,Modifiability,variab,variables,77,// FIXME: We need to force the emission/use of a guard variable for; // some variables even if we can constant-evaluate them because; // we can't guarantee every translation unit will constant-evaluate them.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDecl.cpp:24,Modifiability,variab,variable,24,// Use the label if the variable is renamed with the asm-label extension.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDecl.cpp:10,Modifiability,variab,variables,10,// OpenCL variables in local address space and CUDA shared; // variables cannot have an initializer.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDecl.cpp:63,Modifiability,variab,variables,63,// OpenCL variables in local address space and CUDA shared; // variables cannot have an initializer.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDecl.cpp:83,Modifiability,variab,variable,83,"/// AddInitializerToStaticVarDecl - Add the initializer for 'D' to the; /// global variable that has already been created for it. If the initializer; /// has a different type than GV does, this may free GV and return a different; /// one. Otherwise it just returns GV.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDecl.cpp:51,Modifiability,variab,variable,51,"// Since we have a static initializer, this global variable can't; // be constant.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDecl.cpp:2,Performance,Perform,PerformInit,2,/*PerformInit*/,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDecl.cpp:55,Modifiability,Rewrite,Rewrite,55,"// The initializer may differ in type from the global. Rewrite; // the global to match the initializer. (We have to do this; // because some types, like unions, can't be completely represented; // in the LLVM type system.)",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDecl.cpp:85,Performance,perform,perform,85,"// We have a constant initializer, but a nontrivial destructor. We still; // need to perform a guarded ""initialization"" in order to register the; // destructor.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDecl.cpp:2,Performance,Perform,PerformInit,2,/*PerformInit*/,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDecl.cpp:44,Modifiability,variab,variable,44,"// Check to see if we already have a global variable for this; // declaration. This can happen when double-emitting function; // bodies, e.g. with complete and base constructors.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDecl.cpp:44,Modifiability,variab,variables,44,// CUDA's local and local static __shared__ variables should not; // have any non-empty initializers. This is ensured by Sema.; // Whatever initializer such variable may have when it gets here is; // a no-op and should not be emitted.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDecl.cpp:157,Modifiability,variab,variable,157,// CUDA's local and local static __shared__ variables should not; // have any non-empty initializers. This is ensured by Sema.; // Whatever initializer such variable may have when it gets here is; // a no-op and should not be emitted.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDecl.cpp:15,Modifiability,variab,variable,15,// Emit global variable debug descriptor for static vars.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDecl.cpp:36,Modifiability,variab,variable,36,"// Compute the address of the local variable, in case it's a; // byref or something.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDecl.cpp:36,Modifiability,variab,variable,36,"// Compute the address of the local variable, in case it's a byref; // or something.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDecl.cpp:104,Modifiability,variab,variable,104,// end anonymous namespace; /// EmitAutoVarWithLifetime - Does the setup required for an automatic; /// variable with lifetime.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDecl.cpp:55,Modifiability,variab,variable,55,"// If we find an l-value to r-value cast from a __weak variable,; // emit this operation as a copy or move.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDecl.cpp:34,Safety,avoid,avoid,34,// Handle a formal type change to avoid asserting.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDecl.cpp:40,Testability,assert,asserting,40,// Handle a formal type change to avoid asserting.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDecl.cpp:7,Testability,Log,LogAlignment,7,// The LogAlignment info is unused.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDecl.cpp:45,Modifiability,variab,variable,45,"// We have to maintain the illusion that the variable is; // zero-initialized. If the variable might be accessed in its; // initializer, zero-initialize before running the initializer, then; // actually perform the initialization with an assign.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDecl.cpp:86,Modifiability,variab,variable,86,"// We have to maintain the illusion that the variable is; // zero-initialized. If the variable might be accessed in its; // initializer, zero-initialize before running the initializer, then; // actually perform the initialization with an assign.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDecl.cpp:203,Performance,perform,perform,203,"// We have to maintain the illusion that the variable is; // zero-initialized. If the variable might be accessed in its; // initializer, zero-initialize before running the initializer, then; // actually perform the initialization with an assign.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDecl.cpp:104,Security,access,accessed,104,"// We have to maintain the illusion that the variable is; // zero-initialized. If the variable might be accessed in its; // initializer, zero-initialize before running the initializer, then; // actually perform the initialization with an assign.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDecl.cpp:9,Availability,down,down,9,// Drill down to the __block object if necessary.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDecl.cpp:16,Usability,simpl,simple,16,// We can use a simple GEP for this because it can't have been; // moved yet.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDecl.cpp:23,Usability,simpl,simple,23,// Otherwise just do a simple store.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDecl.cpp:170,Deployability,release,released,170,"// If D is pseudo-strong, treat it like __unsafe_unretained here. This means; // that we omit the retain, and causes non-autoreleased return values to be; // immediately released.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDecl.cpp:15,Security,access,accessed,15,"// If it's not accessed by the initializer, try to emit the; // initialization with a copy or move.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDecl.cpp:13,Performance,optimiz,optimize,13,"// No way to optimize a producing initializer into this. It's not; // worth optimizing for, because the value will immediately; // disappear in the common case.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDecl.cpp:76,Performance,optimiz,optimizing,76,"// No way to optimize a producing initializer into this. It's not; // worth optimizing for, because the value will immediately; // disappear in the common case.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDecl.cpp:10,Modifiability,variab,variable,10,"// If the variable might have been accessed by its initializer, we; // might have to initialize with a barrier. We have to do this for; // both __weak and __strong, but __weak got filtered out above.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDecl.cpp:35,Security,access,accessed,35,"// If the variable might have been accessed by its initializer, we; // might have to initialize with a barrier. We have to do this for; // both __weak and __strong, but __weak got filtered out above.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDecl.cpp:83,Modifiability,variab,variable,83,"/// Decide whether we should use bzero plus some stores to initialize a local; /// variable instead of using a memcpy from a constant global. It is beneficial; /// to use bzero if the global is all zeros, or mostly zeros and large.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDecl.cpp:156,Integrability,depend,depends,156,"// If a non-zero global is <= 32 bytes, always use a memcpy. If it is large,; // do it if it will require 6 or fewer scalar stores.; // TODO: Should budget depends on the size? Avoiding a large global warrants; // plopping in more stores.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDecl.cpp:177,Safety,Avoid,Avoiding,177,"// If a non-zero global is <= 32 bytes, always use a memcpy. If it is large,; // do it if it will require 6 or fewer scalar stores.; // TODO: Should budget depends on the size? Avoiding a large global warrants; // plopping in more stores.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDecl.cpp:62,Modifiability,variab,variable,62,"/// Decide whether we should use memset to initialize a local variable instead; /// of using a memcpy from a constant global. Assumes we've already decided to; /// not user bzero.; /// FIXME We could be more clever, as we are for bzero above, and generate; /// memset followed by stores. It's unclear that's worth the effort.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDecl.cpp:199,Performance,optimiz,optimizations,199,"/// Decide whether we want to split a constant structure or array store into a; /// sequence of its fields' stores. This may cost us code size and compilation; /// speed, but plays better with store optimizations.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDecl.cpp:48,Performance,cache,cacheline,48,// Don't break things that occupy more than one cacheline.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDecl.cpp:165,Energy Efficiency,allocate,allocated,165,"// FIXME: Add handling for tail padding in vectors. Vectors don't; // have padding between or inside elements, but the total amount of; // data can be less than the allocated size.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDecl.cpp:21,Modifiability,variab,variable,21,// Form a simple per-variable cache of these values in case we find we; // want to reuse them.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDecl.cpp:30,Performance,cache,cache,30,// Form a simple per-variable cache of these values in case we find we; // want to reuse them.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDecl.cpp:10,Usability,simpl,simple,10,// Form a simple per-variable cache of these values in case we find we; // want to reuse them.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDecl.cpp:211,Integrability,depend,depending,211,"/// EmitAutoVarDecl - Emit code and set up an entry in LocalDeclMap for a; /// variable declaration with auto, register, or no storage class specifier.; /// These turn into simple stack objects, or GlobalValues depending on target.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDecl.cpp:79,Modifiability,variab,variable,79,"/// EmitAutoVarDecl - Emit code and set up an entry in LocalDeclMap for a; /// variable declaration with auto, register, or no storage class specifier.; /// These turn into simple stack objects, or GlobalValues depending on target.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDecl.cpp:173,Usability,simpl,simple,173,"/// EmitAutoVarDecl - Emit code and set up an entry in LocalDeclMap for a; /// variable declaration with auto, register, or no storage class specifier.; /// These turn into simple stack objects, or GlobalValues depending on target.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDecl.cpp:9,Availability,down,down,9,// Break down the array into individual dimensions.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDecl.cpp:79,Modifiability,variab,variable,79,/// EmitAutoVarAlloca - Emit the alloca and debug information for a; /// local variable. Does not emit initialization or destruction.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDecl.cpp:18,Modifiability,variab,variably-modified,18,"// If the type is variably-modified, emit all the VLA sizes for it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDecl.cpp:196,Modifiability,variab,variable,196,"// If this value is an array or struct with a statically determinable; // constant initializer, there are optimizations we can do.; //; // TODO: We should constant-evaluate the initializer of any variable,; // as long as it is initialized by a constant expression. Currently,; // isConstantInitializer produces wrong answers for structs with; // reference or bitfield members, and a few other cases, and checking; // for POD-ness protects us from some of these.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDecl.cpp:106,Performance,optimiz,optimizations,106,"// If this value is an array or struct with a statically determinable; // constant initializer, there are optimizations we can do.; //; // TODO: We should constant-evaluate the initializer of any variable,; // as long as it is initialized by a constant expression. Currently,; // isConstantInitializer produces wrong answers for structs with; // reference or bitfield members, and a few other cases, and checking; // for POD-ness protects us from some of these.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDecl.cpp:10,Modifiability,variab,variable,10,"// If the variable's a const type, and it's neither an NRVO; // candidate nor a __block variable and has no mutable members,; // emit it as a global instead.; // Exception is if a variable is located in non-constant address space; // in OpenCL.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDecl.cpp:88,Modifiability,variab,variable,88,"// If the variable's a const type, and it's neither an NRVO; // candidate nor a __block variable and has no mutable members,; // emit it as a global instead.; // Exception is if a variable is located in non-constant address space; // in OpenCL.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDecl.cpp:180,Modifiability,variab,variable,180,"// If the variable's a const type, and it's neither an NRVO; // candidate nor a __block variable and has no mutable members,; // emit it as a global instead.; // Exception is if a variable is located in non-constant address space; // in OpenCL.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDecl.cpp:24,Modifiability,variab,variable,24,"// A normal fixed sized variable becomes an alloca in the entry block,; // unless:; // - it's an NRVO variable.; // - we are compiling OpenMP and it's an OpenMP local variable.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDecl.cpp:102,Modifiability,variab,variable,102,"// A normal fixed sized variable becomes an alloca in the entry block,; // unless:; // - it's an NRVO variable.; // - we are compiling OpenMP and it's an OpenMP local variable.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDecl.cpp:167,Modifiability,variab,variable,167,"// A normal fixed sized variable becomes an alloca in the entry block,; // unless:; // - it's an NRVO variable.; // - we are compiling OpenMP and it's an OpenMP local variable.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDecl.cpp:40,Energy Efficiency,allocate,allocate,40,"// The named return value optimization: allocate this variable in the; // return slot, so that we can elide the copy when returning this; // variable (C++0x [class.copy]p34).",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDecl.cpp:54,Modifiability,variab,variable,54,"// The named return value optimization: allocate this variable in the; // return slot, so that we can elide the copy when returning this; // variable (C++0x [class.copy]p34).",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDecl.cpp:141,Modifiability,variab,variable,141,"// The named return value optimization: allocate this variable in the; // return slot, so that we can elide the copy when returning this; // variable (C++0x [class.copy]p34).",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDecl.cpp:26,Performance,optimiz,optimization,26,"// The named return value optimization: allocate this variable in the; // return slot, so that we can elide the copy when returning this; // variable (C++0x [class.copy]p34).",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDecl.cpp:80,Modifiability,variab,variable,80,// Create a flag that is used to indicate when the NRVO was applied; // to this variable. Set it to zero to indicate that NRVO was not; // applied.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDecl.cpp:33,Modifiability,variab,variable,33,// Record the NRVO flag for this variable.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDecl.cpp:123,Testability,assert,asserts,123,// Create the alloca. Note that we set the name separately from; // building the instruction so that it's there even in no-asserts; // builds.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDecl.cpp:47,Modifiability,variab,variable,47,"// If there's a jump into the lifetime of this variable, its lifetime; // gets broken up into several regions in IR, which requires more work; // to handle correctly. For now, just omit the intrinsics; this is a; // rare case, and it's better to just be conservatively correct.; // PR28267.; //; // We have to do this in all language modes if there's a jump past the; // declaration. We also have to do it in C if there's a jump to an; // earlier point in the current block because non-VLA lifetimes begin as; // soon as the containing block is entered, not when its variables; // actually come into scope; suppressing the lifetime annotations; // completely in this case is unnecessarily pessimistic, but again, this; // is rare.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDecl.cpp:567,Modifiability,variab,variables,567,"// If there's a jump into the lifetime of this variable, its lifetime; // gets broken up into several regions in IR, which requires more work; // to handle correctly. For now, just omit the intrinsics; this is a; // rare case, and it's better to just be conservatively correct.; // PR28267.; //; // We have to do this in all language modes if there's a jump past the; // declaration. We also have to do it in C if there's a jump to an; // earlier point in the current block because non-VLA lifetimes begin as; // soon as the containing block is entered, not when its variables; // actually come into scope; suppressing the lifetime annotations; // completely in this case is unnecessarily pessimistic, but again, this; // is rare.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDecl.cpp:29,Modifiability,variab,variable,29,"// Delayed globalization for variable length declarations. This ensures that; // the expression representing the length has been emitted and can be used; // by the definition of the VLA. Since this is an escaped declaration, in; // OpenMP we have to use a call to __kmpc_alloc_shared(). The matching; // deallocation call to __kmpc_free_shared() is emitted later.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDecl.cpp:20,Energy Efficiency,allocate,allocated,20,// Mark variable as allocated:,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDecl.cpp:8,Modifiability,variab,variable,8,// Mark variable as allocated:,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDecl.cpp:3,Energy Efficiency,Allocate,Allocate,3,// Allocate memory for the array.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDecl.cpp:41,Modifiability,variab,variable,41,/// Determines whether the given __block variable is potentially; /// captured by the given statement.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDecl.cpp:41,Modifiability,variab,variable,41,/// Determines whether the given __block variable is potentially; /// captured by the given expression.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDecl.cpp:15,Safety,safe,safe,15,"// FIXME. Make safe assumption assuming arbitrary statements cause capturing.; // Later, provide code to poke into statements for capture analysis.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDecl.cpp:21,Modifiability,variab,variables,21,"// We skip auto-init variables by their alloc size. Take this as an example:; // ""struct Foo {int x; char buff[1024];}"" Assume the max-size flag is 1023.; // All Foo type variables will be skipped. Ideally, we only skip the buff; // array and still auto-init X in this example.; // TODO: Improve the size filtering to by member size.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDecl.cpp:171,Modifiability,variab,variables,171,"// We skip auto-init variables by their alloc size. Take this as an example:; // ""struct Foo {int x; char buff[1024];}"" Assume the max-size flag is 1023.; // All Foo type variables will be skipped. Ideally, we only skip the buff; // array and still auto-init X in this example.; // TODO: Improve the size filtering to by member size.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDecl.cpp:41,Modifiability,variab,variable,41,// Initialize the structure of a __block variable.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDecl.cpp:18,Modifiability,variab,variable,18,// Initialize the variable here if it doesn't have a initializer and it is a; // C struct that is non-trivial to initialize or an array containing such a; // struct.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDecl.cpp:33,Modifiability,variab,variable,33,"// Check whether this is a byref variable that's potentially; // captured and moved by its own initializer. If so, we'll need to; // emit the initializer first, then copy into the variable.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDecl.cpp:180,Modifiability,variab,variable,180,"// Check whether this is a byref variable that's potentially; // captured and moved by its own initializer. If so, we'll need to; // emit the initializer first, then copy into the variable.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDecl.cpp:7,Usability,simpl,simple,7,"// For simple scalar/complex initialization, store the value directly.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDecl.cpp:56,Modifiability,variab,variable,56,"/// Emit an expression as an initializer for an object (variable, field, etc.); /// at the given location. The expression is not necessarily the normal; /// initializer for the object, and the address is not necessarily; /// its normal location.; ///; /// \param init the initializing expression; /// \param D the object to act as if we're initializing; /// \param lvalue the lvalue to initialize; /// \param capturedByInit true if \p D is a __block variable; /// whose address is potentially changed by the initializer",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDecl.cpp:450,Modifiability,variab,variable,450,"/// Emit an expression as an initializer for an object (variable, field, etc.); /// at the given location. The expression is not necessarily the normal; /// initializer for the object, and the address is not necessarily; /// its normal location.; ///; /// \param init the initializing expression; /// \param D the object to act as if we're initializing; /// \param lvalue the lvalue to initialize; /// \param capturedByInit true if \p D is a __block variable; /// whose address is potentially changed by the initializer",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDecl.cpp:48,Modifiability,variab,variable,48,/// Enter a destroy cleanup for the given local variable.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDecl.cpp:25,Modifiability,variab,variables,25,"// Note that for __block variables, we want to destroy the; // original stack object, not the possibly forwarded object.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDecl.cpp:39,Modifiability,variab,variables,39,// Suppress cleanups for pseudo-strong variables.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDecl.cpp:22,Modifiability,variab,variable,22,"// If this is a block variable, call _Block_object_destroy; // (on the unforwarded address). Don't enter this cleanup if we're in pure-GC; // mode.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDecl.cpp:2,Performance,Load,LoadBlockVarAddr,2,/*LoadBlockVarAddr*/,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDecl.cpp:30,Performance,perform,perform,30,"/// emitDestroy - Immediately perform the destruction of the given; /// object.; ///; /// \param addr - the address of the object; a type*; /// \param type - the type of the object; if an array type, all; /// objects are destroyed in reverse order; /// \param destroyer - the function to call to destroy individual; /// elements; /// \param useEHCleanupForArray - whether an EH cleanup should be; /// used when destroying array elements, in case one of the; /// destructions throws an exception",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDecl.cpp:3,Performance,Perform,Perform,3,// Perform the actual destruction there.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDecl.cpp:4,Performance,Perform,Perform,4,"/// Perform partial array destruction as if in an EH cleanup. Unlike; /// emitArrayDestroy, the element type here may still be an array type.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDecl.cpp:49,Availability,down,down,49,"// If the element type is itself an array, drill down.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDecl.cpp:49,Performance,perform,performs,49,/// RegularPartialArrayDestroy - a cleanup which performs a partial; /// array destroy where the end pointer is regularly determined and; /// does not need to be loaded from a local.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDecl.cpp:162,Performance,load,loaded,162,/// RegularPartialArrayDestroy - a cleanup which performs a partial; /// array destroy where the end pointer is regularly determined and; /// does not need to be loaded from a local.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDecl.cpp:51,Performance,perform,performs,51,/// IrregularPartialArrayDestroy - a cleanup which performs a; /// partial array destroy where the end pointer is irregularly; /// determined and must be loaded from a local.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDecl.cpp:154,Performance,load,loaded,154,/// IrregularPartialArrayDestroy - a cleanup which performs a; /// partial array destroy where the end pointer is irregularly; /// determined and must be loaded from a local.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDecl.cpp:27,Deployability,release,release,27,/// A cleanup to perform a release of an object at the end of a; /// function. This is used to balance out the incoming +1 of a; /// ns_consumed argument when we can't reasonably do that just by; /// not doing the initial retain for a __block argument.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDecl.cpp:17,Performance,perform,perform,17,/// A cleanup to perform a release of an object at the end of a; /// function. This is used to balance out the incoming +1 of a; /// ns_consumed argument when we can't reasonably do that just by; /// not doing the initial retain for a __block argument.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDecl.cpp:63,Integrability,depend,depending,63,// end anonymous namespace; /// Emit an alloca (or GlobalValue depending on target); /// for the specified parameter and set up LocalDeclMap.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDecl.cpp:95,Modifiability,variab,variables,95,"// Suppressing debug info for ThreadPrivateVar parameters, else it hides; // debug info of TLS variables.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDecl.cpp:222,Deployability,release,release,222,"// We honor __attribute__((ns_consumed)) for types with lifetime.; // For __strong, it's handled by just skipping the initial retain;; // otherwise we have to balance out the initial +1 with an extra; // cleanup to do the release at the end of the function.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDecl.cpp:3,Performance,Load,Load,3,// Load objects passed indirectly.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDecl.cpp:145,Deployability,release,release,145,"// use objc_storeStrong(&dest, value) for retaining the; // object. But first, store a null into 'dest' because; // objc_storeStrong attempts to release its old value.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGDecl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDecl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDeclCXX.cpp:52,Modifiability,variab,variable,52,/// Emit code to cause the destruction of the given variable with; /// static storage duration.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDeclCXX.cpp:27,Testability,log,logic,27,"// Otherwise, the standard logic requires a helper function.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDeclCXX.cpp:27,Modifiability,variab,variable,27,/// Emit code to cause the variable at the given address to be considered as; /// constant from this point onwards.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDeclCXX.cpp:42,Performance,optimiz,optimizing,42,// Do not emit the intrinsic if we're not optimizing.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDeclCXX.cpp:39,Modifiability,variab,variable,39,"// The address space of a static local variable (DeclPtr) may be different; // from the address space of the ""this"" argument of the constructor. In that; // case, we need an addrspacecast before calling the constructor.; //; // struct StructWithCtor {; // __device__ StructWithCtor() {...}; // };; // __device__ void foo() {; // __shared__ StructWithCtor s;; // ...; // }; //; // For example, in the above CUDA code, the static local variable s has a; // ""shared"" address space qualifier, but the constructor of StructWithCtor; // expects ""this"" in the ""generic"" address space.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDeclCXX.cpp:434,Modifiability,variab,variable,434,"// The address space of a static local variable (DeclPtr) may be different; // from the address space of the ""this"" argument of the constructor. In that; // case, we need an addrspacecast before calling the constructor.; //; // struct StructWithCtor {; // __device__ StructWithCtor() {...}; // };; // __device__ void foo() {; // __shared__ StructWithCtor s;; // ...; // }; //; // For example, in the above CUDA code, the static local variable s has a; // ""shared"" address space qualifier, but the constructor of StructWithCtor; // expects ""this"" in the ""generic"" address space.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDeclCXX.cpp:13,Testability,stub,stub,13,"/// Create a stub function, suitable for being passed to atexit,; /// which passes the given address to the given destructor function.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDeclCXX.cpp:13,Testability,stub,stub,13,"/// Create a stub function, suitable for being passed to __pt_atexit_np,; /// which passes the given address to the given destructor function.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDeclCXX.cpp:11,Testability,stub,stub,11,"// Get the stub function type, int(*)(int,...).",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDeclCXX.cpp:58,Availability,error,error,58,"// If we've been asked to forbid guard variables, emit an error now.; // This diagnostic is hard-coded for Darwin's use case; we can find; // better phrasing if someone else needs it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDeclCXX.cpp:39,Modifiability,variab,variables,39,"// If we've been asked to forbid guard variables, emit an error now.; // This diagnostic is hard-coded for Darwin's use case; we can find; // better phrasing if someone else needs it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDeclCXX.cpp:81,Integrability,depend,depending,81,"// A guess at how many times we will enter the initialization of a; // variable, depending on the kind of variable.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDeclCXX.cpp:71,Modifiability,variab,variable,71,"// A guess at how many times we will enter the initialization of a; // variable, depending on the kind of variable.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDeclCXX.cpp:106,Modifiability,variab,variable,106,"// A guess at how many times we will enter the initialization of a; // variable, depending on the kind of variable.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDeclCXX.cpp:17,Modifiability,variab,variables,17,"// For non-local variables, don't apply any weighting for now. Due to our; // use of COMDATs, we expect there to be at most one initialization of the; // variable per DSO, but we have no way to know how many DSOs will try to; // initialize the variable.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDeclCXX.cpp:154,Modifiability,variab,variable,154,"// For non-local variables, don't apply any weighting for now. Due to our; // use of COMDATs, we expect there to be at most one initialization of the; // variable per DSO, but we have no way to know how many DSOs will try to; // initialize the variable.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDeclCXX.cpp:244,Modifiability,variab,variable,244,"// For non-local variables, don't apply any weighting for now. Due to our; // use of COMDATs, we expect there to be at most one initialization of the; // variable per DSO, but we have no way to know how many DSOs will try to; // initialize the variable.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDeclCXX.cpp:113,Modifiability,variab,variable,113,// The probability of us entering the initializer is; // 1 / (total number of times we attempt to initialize the variable).,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDeclCXX.cpp:77,Modifiability,variab,variable,77,/// Create a global pointer to a function that will initialize a global; /// variable. The user has requested that this pointer be emitted in a specific; /// section.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDeclCXX.cpp:99,Modifiability,variab,variables,99,"// According to E.2.3.1 in CUDA-7.5 Programming guide: __device__,; // __constant__ and __shared__ variables defined in namespace scope,; // that are of class type, cannot have a non-empty constructor. All; // the checks have been done in Sema by now. Whatever initializers; // are allowed are empty and we just need to ignore them here.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDeclCXX.cpp:48,Usability,guid,guide,48,"// According to E.2.3.1 in CUDA-7.5 Programming guide: __device__,; // __constant__ and __shared__ variables defined in namespace scope,; // that are of class type, cannot have a non-empty constructor. All; // the checks have been done in Sema by now. Whatever initializers; // are allowed are empty and we just need to ignore them here.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDeclCXX.cpp:12,Modifiability,variab,variable,12,// Create a variable initialization function.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDeclCXX.cpp:3,Integrability,Contract,Contract,3,"// Contract with backend that ""init_seg(compiler)"" corresponds to priority; // 200 and ""init_seg(lib)"" corresponds to priority 400.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDeclCXX.cpp:595,Modifiability,variab,variables,595,"// C++ [basic.start.init]p2:; // Definitions of explicitly specialized class template static data; // members have ordered initialization. Other class template static data; // members (i.e., implicitly or explicitly instantiated specializations); // have unordered initialization.; //; // As a consequence, we can put them into their own llvm.global_ctors entry.; //; // If the global is externally visible, put the initializer into a COMDAT; // group with the global being initialized. On most platforms, this is a; // minor startup time optimization. In the MS C++ ABI, there are no guard; // variables, so this COMDAT key is required for correctness.; //; // SelectAny globals will be comdat-folded. Put the initializer into a; // COMDAT group associated with the global, so the initializers get folded; // too.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDeclCXX.cpp:539,Performance,optimiz,optimization,539,"// C++ [basic.start.init]p2:; // Definitions of explicitly specialized class template static data; // members have ordered initialization. Other class template static data; // members (i.e., implicitly or explicitly instantiated specializations); // have unordered initialization.; //; // As a consequence, we can put them into their own llvm.global_ctors entry.; //; // If the global is externally visible, put the initializer into a COMDAT; // group with the global being initialized. On most platforms, this is a; // minor startup time optimization. In the MS C++ ABI, there are no guard; // variables, so this COMDAT key is required for correctness.; //; // SelectAny globals will be comdat-folded. Put the initializer into a; // COMDAT group associated with the global, so the initializers get folded; // too.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDeclCXX.cpp:30,Security,hash,hash,30,// Re-do lookup in case of re-hash.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDeclCXX.cpp:356,Availability,avail,available,356,"/* Build the initializer for a C++20 module:; This is arranged to be run only once regardless of how many times the module; might be included transitively. This arranged by using a guard variable. If there are no initializers at all (and also no imported modules) we reduce; this to an empty function (since the Itanium ABI requires that this function; be available to a caller, which might be produced by a different; implementation). First we call any initializers for imported modules.; We then call initializers for the Global Module Fragment (if present); We then call initializers for the current module.; We then call initializers for the Private Module Fragment (if present); */",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDeclCXX.cpp:267,Energy Efficiency,reduce,reduce,267,"/* Build the initializer for a C++20 module:; This is arranged to be run only once regardless of how many times the module; might be included transitively. This arranged by using a guard variable. If there are no initializers at all (and also no imported modules) we reduce; this to an empty function (since the Itanium ABI requires that this function; be available to a caller, which might be produced by a different; implementation). First we call any initializers for imported modules.; We then call initializers for the Global Module Fragment (if present); We then call initializers for the current module.; We then call initializers for the Private Module Fragment (if present); */",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDeclCXX.cpp:187,Modifiability,variab,variable,187,"/* Build the initializer for a C++20 module:; This is arranged to be run only once regardless of how many times the module; might be included transitively. This arranged by using a guard variable. If there are no initializers at all (and also no imported modules) we reduce; this to an empty function (since the Itanium ABI requires that this function; be available to a caller, which might be produced by a different; implementation). First we call any initializers for imported modules.; We then call initializers for the Global Module Fragment (if present); We then call initializers for the current module.; We then call initializers for the Private Module Fragment (if present); */",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDeclCXX.cpp:89,Modifiability,variab,variable,89,// If we have a completely empty initializer then we do not want to create; // the guard variable.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDeclCXX.cpp:247,Integrability,interface,interface,247,// We allow for the case that a module object is added to a linked binary; // without a specific call to the the initializer. This also ensures that; // implementation partition initializers are called when the partition; // is not imported as an interface.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDeclCXX.cpp:540,Deployability,release,released,540,// In OpenCL global init functions must be converted to kernels in order to; // be able to launch them from the host.; // FIXME: Some more work might be needed to handle destructors correctly.; // Current initialization function makes use of function pointers callbacks.; // We can't support function pointers especially between host and device.; // However it seems global destruction has little meaning without any; // dynamic resource allocation on the device and program scope variables are; // destroyed by the runtime when program is released.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDeclCXX.cpp:481,Modifiability,variab,variables,481,// In OpenCL global init functions must be converted to kernels in order to; // be able to launch them from the host.; // FIXME: Some more work might be needed to handle destructors correctly.; // Current initialization function makes use of function pointers callbacks.; // We can't support function pointers especially between host and device.; // However it seems global destruction has little meaning without any; // dynamic resource allocation on the device and program scope variables are; // destroyed by the runtime when program is released.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDeclCXX.cpp:59,Modifiability,variab,variable,59,/// Emit the code necessary to initialize the given global variable.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDeclCXX.cpp:43,Modifiability,variab,variable,43,// Check if we need to emit debug info for variable initializer.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDeclCXX.cpp:44,Modifiability,variab,variable,44,"// Use guarded initialization if the global variable is weak. This; // occurs for, e.g., instantiated static data members and; // definitions explicitly marked weak.; //; // Also use guarded initialization for a variable with dynamic TLS and; // unordered initialization. (If the initialization is ordered, the ABI; // layer will guard the whole-TU initialization for us.)",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDeclCXX.cpp:212,Modifiability,variab,variable,212,"// Use guarded initialization if the global variable is weak. This; // occurs for, e.g., instantiated static data members and; // definitions explicitly marked weak.; //; // Also use guarded initialization for a variable with dynamic TLS and; // unordered initialization. (If the initialization is ordered, the ABI; // layer will guard the whole-TU initialization for us.)",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDeclCXX.cpp:22,Modifiability,variab,variable,22,"// If we have a guard variable, check whether we've already performed; // these initializations. This happens for TLS initialization functions.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDeclCXX.cpp:60,Performance,perform,performed,60,"// If we have a guard variable, check whether we've already performed; // these initializations. This happens for TLS initialization functions.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDeclCXX.cpp:13,Modifiability,variab,variable,13,// The guard variable can't ever change again.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGDeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGException.cpp:116,Safety,avoid,avoid,116,// The GCC runtime's personality function inherently doesn't support; // mixed EH. Use the ObjC personality just to avoid returning null.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGException.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGException.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGException.cpp:46,Modifiability,variab,variables,46,// ObjC EH selector entries are always global variables with; // names starting like this.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGException.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGException.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGException.cpp:46,Modifiability,variab,variables,46,// ObjC EH selector entries are always global variables with; // names starting like this.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGException.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGException.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGException.cpp:58,Testability,log,logic,58,// Both the problem this endeavors to fix and the way the logic; // above works is specific to the NeXT runtime.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGException.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGException.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGException.cpp:16,Performance,optimiz,optimization,16,// Can't do the optimization if it has non-C++ uses.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGException.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGException.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGException.cpp:25,Integrability,inject,inject,25,/// Returns the value to inject into a selector to indicate the; /// presence of a catch-all.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGException.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGException.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGException.cpp:25,Security,inject,inject,25,/// Returns the value to inject into a selector to indicate the; /// presence of a catch-all.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGException.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGException.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGException.cpp:173,Safety,abort,abort,173,"// If the exception is being emitted in an OpenMP target region,; // and the target is a GPU, we do not support exception handling.; // Therefore, we emit a trap which will abort the program, and; // prompt a warning indicating that a trap will be emitted.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGException.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGException.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGException.cpp:201,Integrability,message,message,201,// Currently Emscripten EH only handles 'throw()' but not 'throw' with; // types. 'throw()' handling will be done in JS glue code so we don't need; // to do anything in that case. Just print a warning message in case of; // throw with types.; // TODO Correctly handle exception specification in Emscripten EH,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGException.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGException.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGException.cpp:26,Usability,simpl,simple,26,// noexcept functions are simple terminate scopes.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGException.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGException.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGException.cpp:3,Performance,Load,Load,3,// Load the selector value.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGException.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGException.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGException.cpp:261,Integrability,rout,routine,261,"// FIXME: Dropping the reference type on the type into makes it; // impossible to correctly implement catch-by-reference; // semantics for pointers. Unfortunately, this is what all; // existing compilers do, and it's not clear that the standard; // personality routine is capable of doing this right. See C++ DR 388:; // http://www.open-std.org/jtc1/sc22/wg21/docs/cwg_active.html#388",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGException.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGException.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGException.cpp:221,Usability,clear,clear,221,"// FIXME: Dropping the reference type on the type into makes it; // impossible to correctly implement catch-by-reference; // semantics for pointers. Unfortunately, this is what all; // existing compilers do, and it's not clear that the standard; // personality routine is capable of doing this right. See C++ DR 388:; // http://www.open-std.org/jtc1/sc22/wg21/docs/cwg_active.html#388",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGException.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGException.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGException.cpp:78,Usability,resume,resumes,78,// The dispatch block for the end of the scope chain is a block that; // just resumes unwinding.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGException.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGException.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGException.cpp:35,Performance,cache,cached,35,"// Check the innermost scope for a cached landing pad. If this is; // a non-EH cleanup, we'll check enclosing scopes in EmitLandingPad.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGException.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGException.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGException.cpp:3,Performance,Cache,Cache,3,"// Cache the landing pad on the innermost scope. If this is a; // non-EH scope, cache the landing pad on the enclosing scope, too.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGException.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGException.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGException.cpp:80,Performance,cache,cache,80,"// Cache the landing pad on the innermost scope. If this is a; // non-EH scope, cache the landing pad on the enclosing scope, too.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGException.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGException.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGException.cpp:14,Modifiability,config,configure,14,// Create and configure the landing pad.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGException.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGException.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGException.cpp:36,Safety,safe,safe,36,// Save the exception pointer. It's safe to use a single exception; // pointer per function because EH cleanups can never have nested; // try/catches.; // Build the landingpad instruction.; // Accumulate all the handlers in scope.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGException.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGException.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGException.cpp:45,Safety,abort,abort,45,"// If this is a catch-all, register that and abort.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGException.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGException.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGException.cpp:109,Integrability,rout,routine,109,// Create a filter expression: a constant array indicating which filter; // types there are. The personality routine only lands here if the filter; // doesn't match.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGException.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGException.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGException.cpp:3,Testability,Test,Test,3,// Test against each of the exception types we claim to catch.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGException.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGException.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGException.cpp:3,Testability,Test,Test,3,// Test against each of the exception types we claim to catch.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGException.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGException.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGException.cpp:3,Performance,Load,Load,3,// Load the selector value.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGException.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGException.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGException.cpp:3,Testability,Test,Test,3,// Test against each of the exception types we claim to catch.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGException.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGException.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGException.cpp:46,Modifiability,variab,variable,46,"// Enter a cleanup scope, including the catch variable and the; // end-catch.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGException.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGException.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGException.cpp:24,Modifiability,variab,variable,24,// Initialize the catch variable and set up the cleanups.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGException.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGException.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGException.cpp:3,Performance,Perform,Perform,3,// Perform the body of the catch.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGException.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGException.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGException.cpp:134,Testability,test,test,134,"// Because in wasm we merge all catch clauses into one big catchpad, in case; // none of the types in catch handlers matches after we test against each of; // them, we should unwind to the next EH enclosing scope. We generate a call; // to rethrow function here to do that.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGException.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGException.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGException.cpp:38,Performance,optimiz,optimization,38,"// Leave the end-catch cleanup. As an optimization, pretend that; // the fallthrough path was inaccessible; we've dynamically proven; // that we're not in the EH case along that path.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGException.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGException.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGException.cpp:738,Performance,perform,performing,738,"// A finally block is a statement which must be executed on any edge; // out of a given scope. Unlike a cleanup, the finally block may; // contain arbitrary control flow leading out of itself. In; // addition, finally blocks should always be executed, even if there; // are no catch handlers higher on the stack. Therefore, we; // surround the protected scope with a combination of a normal; // cleanup (to catch attempts to break out of the block via normal; // control flow) and an EH catch-all (semantically ""outside"" any try; // statement to which the finally block might have been attached).; // The finally block itself is generated in the context of a cleanup; // which conditionally leaves the catch-all.; // Jump destination for performing the finally block on an exception; // edge. We'll never actually reach this block, so unreachable is; // fine.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGException.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGException.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGException.cpp:37,Performance,perform,perform,37,// Enter a normal cleanup which will perform the @finally block.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGException.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGException.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGException.cpp:51,Usability,resume,resume,51,// Recreate the landingpad's return value for the 'resume' instruction.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGException.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGException.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGException.cpp:19,Modifiability,variab,variable,19,/// Find all local variable captures in the statement.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGException.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGException.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGException.cpp:122,Availability,recover,recover,122,// This is the simple case where we are the outermost finally. All we; // have to do here is make sure we escape this and recover it in the; // outlined handler.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGException.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGException.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGException.cpp:122,Safety,recover,recover,122,// This is the simple case where we are the outermost finally. All we; // have to do here is make sure we escape this and recover it in the; // outlined handler.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGException.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGException.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGException.cpp:15,Usability,simpl,simple,15,// This is the simple case where we are the outermost finally. All we; // have to do here is make sure we escape this and recover it in the; // outlined handler.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGException.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGException.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGException.cpp:12,Modifiability,variab,variable,12,// Mark the variable escaped if nobody else referenced it and compute the; // localescape index.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGException.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGException.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGException.cpp:15,Modifiability,variab,variable,15,"// Bitcast the variable, rename it, and insert it in the local decl map.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGException.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGException.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGException.cpp:50,Availability,recover,recovery,50,// 32-bit SEH filters need to be careful about FP recovery. The end of the; // EH registration is passed in as the EBP physical register. We can; // recover that with llvm.frameaddress(1).,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGException.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGException.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGException.cpp:149,Availability,recover,recover,149,// 32-bit SEH filters need to be careful about FP recovery. The end of the; // EH registration is passed in as the EBP physical register. We can; // recover that with llvm.frameaddress(1).,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGException.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGException.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGException.cpp:50,Safety,recover,recovery,50,// 32-bit SEH filters need to be careful about FP recovery. The end of the; // EH registration is passed in as the EBP physical register. We can; // recover that with llvm.frameaddress(1).,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGException.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGException.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGException.cpp:149,Safety,recover,recover,149,// 32-bit SEH filters need to be careful about FP recovery. The end of the; // EH registration is passed in as the EBP physical register. We can; // recover that with llvm.frameaddress(1).,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGException.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGException.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGException.cpp:57,Availability,recover,recover,57,"// Given whatever FP the runtime provided us in EntryFP, recover the true; // frame pointer of the parent function. We only need to do this in filters,; // since finally funclets recover the parent FP for us.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGException.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGException.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGException.cpp:179,Availability,recover,recover,179,"// Given whatever FP the runtime provided us in EntryFP, recover the true; // frame pointer of the parent function. We only need to do this in filters,; // since finally funclets recover the parent FP for us.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGException.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGException.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGException.cpp:57,Safety,recover,recover,57,"// Given whatever FP the runtime provided us in EntryFP, recover the true; // frame pointer of the parent function. We only need to do this in filters,; // since finally funclets recover the parent FP for us.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGException.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGException.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGException.cpp:179,Safety,recover,recover,179,"// Given whatever FP the runtime provided us in EntryFP, recover the true; // frame pointer of the parent function. We only need to do this in filters,; // since finally funclets recover the parent FP for us.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGException.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGException.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGException.cpp:350,Performance,optimiz,optimized,350,"// if the parent is a _finally, the passed-in ParentFP is the FP; // of parent _finally, not Establisher's FP (FP of outermost function).; // Establkisher FP is 2nd paramenter passed into parent _finally.; // Fortunately, it's always saved in parent's frame. The following; // code retrieves it, and escapes it so that spill instruction won't be; // optimized away.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGException.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGException.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGException.cpp:60,Integrability,Depend,Depending,60,"// Locate and escape Parent's frame_pointer.addr alloca; // Depending on target, should be 1st/2nd one in LocalDeclMap.; // Let's just scan for ImplicitParamDecl with VoidPtrTy.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGException.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGException.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGException.cpp:64,Availability,recover,recoverfp,64,"// an example of a filter's prolog::; // %0 = call ptr @llvm.eh.recoverfp(@""?fin$0@0@main@@"",..); // %1 = call ptr @llvm.localrecover(@""?fin$0@0@main@@"",..); // %2 = load ptr, ptr %1, align 8; // ==> %2 is the frame-pointer of outermost host function",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGException.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGException.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGException.cpp:166,Performance,load,load,166,"// an example of a filter's prolog::; // %0 = call ptr @llvm.eh.recoverfp(@""?fin$0@0@main@@"",..); // %1 = call ptr @llvm.localrecover(@""?fin$0@0@main@@"",..); // %2 = load ptr, ptr %1, align 8; // ==> %2 is the frame-pointer of outermost host function",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGException.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGException.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGException.cpp:64,Safety,recover,recoverfp,64,"// an example of a filter's prolog::; // %0 = call ptr @llvm.eh.recoverfp(@""?fin$0@0@main@@"",..); // %1 = call ptr @llvm.localrecover(@""?fin$0@0@main@@"",..); // %2 = load ptr, ptr %1, align 8; // ==> %2 is the frame-pointer of outermost host function",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGException.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGException.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGException.cpp:91,Performance,load,loaded,91,"// We are in a lambda function where ""this"" is captured so the; // CXXThisValue need to be loaded from the lambda capture",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGException.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGException.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGException.cpp:13,Testability,stub,stub,13,/// Create a stub filter function that will ultimately hold the code of the; /// filter expression. The EH preparation passes in LLVM will outline the code; /// from the main function body into this stub.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGException.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGException.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGException.cpp:199,Testability,stub,stub,199,/// Create a stub filter function that will ultimately hold the code of the; /// filter expression. The EH preparation passes in LLVM will outline the code; /// from the main function body into this stub.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGException.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGException.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGException.cpp:223,Performance,load,load,223,"// On Win32, the EBP on entry to the filter points to the end of an; // exception registration object. It contains 6 32-bit fields, and the info; // pointer is stored in the second field. So, GEP 20 bytes backwards and; // load the pointer.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGException.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGException.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGException.cpp:68,Security,access,access,68,// Save the exception code in the exception slot to unify exception access in; // the filter function and the landing pad.; // struct EXCEPTION_POINTERS {; // EXCEPTION_RECORD *ExceptionRecord;; // CONTEXT *ContextRecord;; // };; // int exceptioncode = exception_pointers->ExceptionRecord->ExceptionCode;,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGException.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGException.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGException.cpp:140,Usability,simpl,simple,140,"// If this code is reachable then emit a stop point (if generating; // debug info). We have to do this ourselves because we are on the; // ""simple"" statement path.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGException.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGException.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGExpr.cpp:22,Security,sanitiz,sanitizers,22,// Experiment to make sanitizers easier to debug,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGExpr.cpp:159,Modifiability,variab,variables,159,"// Alloca always returns a pointer in alloca address space, which may; // be different from the type defined by the language. For example,; // in C++ the auto variables are in the default address space. Therefore; // cast alloca to the default address space when necessary.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGExpr.cpp:25,Performance,Perform,Perform,25,"/// EvaluateExprAsBool - Perform the usual unary conversions on the specified; /// expression and compare the result against zero, returning an Int1Ty value.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGExpr.cpp:90,Security,access,accessible,90,"/// EmitAnyExprToTemp - Similar to EmitAnyExpr(), however, the result will; /// always be accessible even if no aggregate location is provided.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGExpr.cpp:121,Deployability,release,release,121,"// Objective-C++ ARC:; // If we are binding a reference to a temporary that has ownership, we; // need to perform retain/release operations on the temporary.; //; // FIXME: This should be looking at E, not M.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGExpr.cpp:106,Performance,perform,perform,106,"// Objective-C++ ARC:; // If we are binding a reference to a temporary that has ownership, we; // need to perform retain/release operations on the temporary.; //; // FIXME: This should be looking at E, not M.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGExpr.cpp:55,Deployability,release,release,55,// Note: we intentionally do not register a cleanup to release; // the object on program termination.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGExpr.cpp:185,Performance,optimiz,optimizer,185,// If we have a constant temporary array or record try to promote it into a; // constant global under the same rules a normal constant would've been; // promoted. This is easier on the optimizer and generally emits fewer; // instructions.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGExpr.cpp:3,Safety,Avoid,Avoid,3,"// Avoid creating a conditional cleanup just to hold an llvm.lifetime.end; // marker. Instead, start the lifetime of a conditional temporary earlier; // so that it's unconditional. Don't do this with sanitizers which need; // more precise lifetime marks. However when inside an ""await.suspend""; // block, we should always avoid conditional cleanup because it creates; // boolean marker that lives across await_suspend, which can destroy coro; // frame.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGExpr.cpp:322,Safety,avoid,avoid,322,"// Avoid creating a conditional cleanup just to hold an llvm.lifetime.end; // marker. Instead, start the lifetime of a conditional temporary earlier; // so that it's unconditional. Don't do this with sanitizers which need; // more precise lifetime marks. However when inside an ""await.suspend""; // block, we should always avoid conditional cleanup because it creates; // boolean marker that lives across await_suspend, which can destroy coro; // frame.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGExpr.cpp:200,Security,sanitiz,sanitizers,200,"// Avoid creating a conditional cleanup just to hold an llvm.lifetime.end; // marker. Instead, start the lifetime of a conditional temporary earlier; // so that it's unconditional. Don't do this with sanitizers which need; // more precise lifetime marks. However when inside an ""await.suspend""; // block, we should always avoid conditional cleanup because it creates; // boolean marker that lives across await_suspend, which can destroy coro; // frame.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGExpr.cpp:136,Modifiability,extend,extended,136,"// Perform derived-to-base casts and/or field accesses, to get from the; // temporary object we created (and, potentially, for which we extended; // the lifetime) to the subobject we're binding the reference to.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGExpr.cpp:3,Performance,Perform,Perform,3,"// Perform derived-to-base casts and/or field accesses, to get from the; // temporary object we created (and, potentially, for which we extended; // the lifetime) to the subobject we're binding the reference to.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGExpr.cpp:46,Security,access,accesses,46,"// Perform derived-to-base casts and/or field accesses, to get from the; // temporary object we created (and, potentially, for which we extended; // the lifetime) to the subobject we're binding the reference to.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGExpr.cpp:110,Security,access,accessed,110,"/// getAccessedFieldNo - Given an encoded value and a result number, return the; /// input field number being accessed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGExpr.cpp:58,Security,Hash,Hashing,58,/// Emit the hash_16_bytes function from include/llvm/ADT/Hashing.h.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGExpr.cpp:160,Energy Efficiency,reduce,reduce,160,"// Quickly determine whether we have a pointer to an alloca. It's possible; // to skip null checks, and some alignment checks, for these pointers. This; // can reduce compile-time significantly.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGExpr.cpp:8,Performance,perform,performing,8,"// When performing pointer casts, it's OK if the value is null.; // Skip the remaining checks in that case.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGExpr.cpp:82,Security,Sanitiz,Sanitizer,82,"// The glvalue must refer to a large enough storage region.; // FIXME: If Address Sanitizer is enabled, insert dynamic instrumentation; // to check this.; // FIXME: Get object address space",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGExpr.cpp:312,Security,access,access,312,"// If possible, check that the vptr indicates that there is a subobject of; // type Ty at offset zero within this object.; //; // C++11 [basic.life]p5,6:; // [For storage which does not refer to an object within its lifetime]; // The program has undefined behavior if:; // -- the [pointer or glvalue] is used to access a non-static data member; // or call a non-static member function",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGExpr.cpp:46,Performance,load,loading,46,"// Ensure that the pointer is non-null before loading it. If there is no; // compile-time guarantee, reuse the run-time null check or emit a new one.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGExpr.cpp:13,Security,hash,hash,13,// Compute a hash of the mangled name of the type.; //; // FIXME: This is not guaranteed to be deterministic! Move to a; // fingerprinting mechanism once LLVM provides one. For the time; // being the implementation happens to be deterministic.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGExpr.cpp:3,Performance,Load,Load,3,"// Load the vptr, and compute hash_16_bytes(TypeHash, vptr).",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGExpr.cpp:27,Performance,cache,cache,27,// Look the hash up in our cache.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGExpr.cpp:12,Security,hash,hash,12,// Look the hash up in our cache.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGExpr.cpp:28,Performance,cache,cache,28,"// If the hash isn't in the cache, call a runtime handler to perform the; // hard work of checking whether the vptr is for an object of the right; // type. This will either fill in the cache and return, or produce a; // diagnostic.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGExpr.cpp:61,Performance,perform,perform,61,"// If the hash isn't in the cache, call a runtime handler to perform the; // hard work of checking whether the vptr is for an object of the right; // type. This will either fill in the cache and return, or produce a; // diagnostic.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGExpr.cpp:185,Performance,cache,cache,185,"// If the hash isn't in the cache, call a runtime handler to perform the; // hard work of checking whether the vptr is for an object of the right; // type. This will either fill in the cache and return, or produce a; // diagnostic.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGExpr.cpp:10,Security,hash,hash,10,"// If the hash isn't in the cache, call a runtime handler to perform the; // hard work of checking whether the vptr is for an object of the right; // type. This will either fill in the cache and return, or produce a; // diagnostic.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGExpr.cpp:9,Performance,load,load,9,// Don't load the size if it's a lower bound.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGExpr.cpp:60,Security,access,access,60,"/// \p StructAccessBase returns the base \p Expr of a field access. It returns; /// either a \p DeclRefExpr, representing the base pointer to the struct, i.e.:; ///; /// p in p-> a.b.c; ///; /// or a \p MemberExpr, if the \p MemberExpr has the \p RecordDecl we're; /// looking for:; ///; /// struct s {; /// struct s *ptr;; /// int count;; /// char array[] __attribute__((counted_by(count)));; /// };; ///; /// If we have an expression like \p p->ptr->array[index], we want the; /// \p MemberExpr for \p p->ptr instead of \p p.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGExpr.cpp:546,Modifiability,flexible,flexible,546,"// These are the types we expect to return (in order of most to least; // likely):; //; // 1. DeclRefExpr - This is the expression for the base of the structure.; // It's exactly what we want to build an access to the \p counted_by; // field.; // 2. MemberExpr - This is the expression that has the same \p RecordDecl; // as the flexble array member's lexical enclosing \p RecordDecl. This; // allows us to catch things like: ""p->p->array""; // 3. CompoundLiteralExpr - This is for people who create something; // heretical like (struct foo has a flexible array member):; //; // (struct foo){ 1, 2 }.blah[idx];",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGExpr.cpp:204,Security,access,access,204,"// These are the types we expect to return (in order of most to least; // likely):; //; // 1. DeclRefExpr - This is the expression for the base of the structure.; // It's exactly what we want to build an access to the \p counted_by; // field.; // 2. MemberExpr - This is the expression that has the same \p RecordDecl; // as the flexble array member's lexical enclosing \p RecordDecl. This; // allows us to catch things like: ""p->p->array""; // 3. CompoundLiteralExpr - This is for people who create something; // heretical like (struct foo has a flexible array member):; //; // (struct foo){ 1, 2 }.blah[idx];",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGExpr.cpp:305,Modifiability,flexible,flexible,305,"/// This method is typically called in contexts where we can't generate; /// side-effects, like in __builtin_dynamic_object_size. When finding; /// expressions, only choose those that have either already been emitted or can; /// be loaded without side-effects.; ///; /// - \p FAMDecl: the \p Decl for the flexible array member. It may not be; /// within the top-level struct.; /// - \p CountDecl: must be within the same non-anonymous struct as \p FAMDecl.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGExpr.cpp:232,Performance,load,loaded,232,"/// This method is typically called in contexts where we can't generate; /// side-effects, like in __builtin_dynamic_object_size. When finding; /// expressions, only choose those that have either already been emitted or can; /// be loaded without side-effects.; ///; /// - \p FAMDecl: the \p Decl for the flexible array member. It may not be; /// within the top-level struct.; /// - \p CountDecl: must be within the same non-anonymous struct as \p FAMDecl.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGExpr.cpp:13,Deployability,update,updated,13,// Store the updated result through the lvalue.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGExpr.cpp:82,Deployability,update,updated,82,"// If this is a postinc, return the value read from memory, otherwise use the; // updated value.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGExpr.cpp:17,Security,access,accesses,17,"// TODO: Support accesses to members of base classes in TBAA. For now, we; // conservatively pretend that the complete object is of the base class; // type.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGExpr.cpp:2,Security,Access,Accessed,2,/*Accessed*/,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGExpr.cpp:698,Modifiability,variab,variable,698,"/// EmitLValue - Emit code to compute a designator that specifies the location; /// of the expression.; ///; /// This can return one of two things: a simple address or a bitfield reference.; /// In either case, the LLVM Value* in the LValue structure is guaranteed to be; /// an LLVM pointer type.; ///; /// If this returns a bitfield reference, nothing about the pointee type of the; /// LLVM value is known: For example, it may not be a pointer to an integer.; ///; /// If this returns a normal address, and if the lvalue's C type is fixed size,; /// this method guarantees that the returned pointer type will point to an LLVM; /// type of the same size of the lvalue's type. If the lvalue has a variable; /// length type, this is not possible.; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGExpr.cpp:150,Usability,simpl,simple,150,"/// EmitLValue - Emit code to compute a designator that specifies the location; /// of the expression.; ///; /// This can return one of two things: a simple address or a bitfield reference.; /// In either case, the LLVM Value* in the LValue structure is guaranteed to be; /// an LLVM pointer type.; ///; /// If this returns a bitfield reference, nothing about the pointee type of the; /// LLVM value is known: For example, it may not be a pointer to an integer.; ///; /// If this returns a normal address, and if the lvalue's C type is fixed size,; /// this method guarantees that the returned pointer type will point to an LLVM; /// type of the same size of the lvalue's type. If the lvalue has a variable; /// length type, this is not possible.; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGExpr.cpp:109,Usability,simpl,simple,109,// FIXME: Is it possible to create an ExprWithCleanups that produces a; // bitfield lvalue or some other non-simple lvalue?,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGExpr.cpp:56,Safety,safe,safely,56,"/// Given an object of the given canonical type, can we safely copy a; /// value out of it based on its initializer?",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGExpr.cpp:52,Modifiability,variab,variable,52,"/// Can we constant-emit a load of a reference to a variable of the; /// given type? This is different from predicates like; /// Decl::mightBeUsableInConstantExpressions because we do want it to apply; /// in situations that don't necessarily satisfy the language's rules; /// for this (e.g. C++'s ODR-use rules). For example, we want to able; /// to do this with const float variables even if those variables; /// aren't marked 'constexpr'.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGExpr.cpp:376,Modifiability,variab,variables,376,"/// Can we constant-emit a load of a reference to a variable of the; /// given type? This is different from predicates like; /// Decl::mightBeUsableInConstantExpressions because we do want it to apply; /// in situations that don't necessarily satisfy the language's rules; /// for this (e.g. C++'s ODR-use rules). For example, we want to able; /// to do this with const float variables even if those variables; /// aren't marked 'constexpr'.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGExpr.cpp:400,Modifiability,variab,variables,400,"/// Can we constant-emit a load of a reference to a variable of the; /// given type? This is different from predicates like; /// Decl::mightBeUsableInConstantExpressions because we do want it to apply; /// in situations that don't necessarily satisfy the language's rules; /// for this (e.g. C++'s ODR-use rules). For example, we want to able; /// to do this with const float variables even if those variables; /// aren't marked 'constexpr'.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGExpr.cpp:27,Performance,load,load,27,"/// Can we constant-emit a load of a reference to a variable of the; /// given type? This is different from predicates like; /// Decl::mightBeUsableInConstantExpressions because we do want it to apply; /// in situations that don't necessarily satisfy the language's rules; /// for this (e.g. C++'s ODR-use rules). For example, we want to able; /// to do this with const float variables even if those variables; /// aren't marked 'constexpr'.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGExpr.cpp:173,Modifiability,variab,variables,173,"/// Try to emit a reference to the given value without producing it as; /// an l-value. This is just an optimization, but it avoids us needing; /// to emit global copies of variables if they're named without triggering; /// a formal use in a context where we can't emit a direct reference to them,; /// for instance if a block or lambda or a member of a local class uses a; /// const int variable or constexpr variable from an enclosing function.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGExpr.cpp:388,Modifiability,variab,variable,388,"/// Try to emit a reference to the given value without producing it as; /// an l-value. This is just an optimization, but it avoids us needing; /// to emit global copies of variables if they're named without triggering; /// a formal use in a context where we can't emit a direct reference to them,; /// for instance if a block or lambda or a member of a local class uses a; /// const int variable or constexpr variable from an enclosing function.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGExpr.cpp:410,Modifiability,variab,variable,410,"/// Try to emit a reference to the given value without producing it as; /// an l-value. This is just an optimization, but it avoids us needing; /// to emit global copies of variables if they're named without triggering; /// a formal use in a context where we can't emit a direct reference to them,; /// for instance if a block or lambda or a member of a local class uses a; /// const int variable or constexpr variable from an enclosing function.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGExpr.cpp:104,Performance,optimiz,optimization,104,"/// Try to emit a reference to the given value without producing it as; /// an l-value. This is just an optimization, but it avoids us needing; /// to emit global copies of variables if they're named without triggering; /// a formal use in a context where we can't emit a direct reference to them,; /// for instance if a block or lambda or a member of a local class uses a; /// const int variable or constexpr variable from an enclosing function.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGExpr.cpp:125,Safety,avoid,avoids,125,"/// Try to emit a reference to the given value without producing it as; /// an l-value. This is just an optimization, but it avoids us needing; /// to emit global copies of variables if they're named without triggering; /// a formal use in a context where we can't emit a direct reference to them,; /// for instance if a block or lambda or a member of a local class uses a; /// const int variable or constexpr variable from an enclosing function.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGExpr.cpp:56,Modifiability,variab,variable,56,// The value needs to be an enum constant or a constant variable.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGExpr.cpp:3,Availability,Failure,Failure,3,// Failure.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGExpr.cpp:68,Modifiability,variab,variable,68,"// In CUDA/HIP device compilation, a lambda may capture a reference variable; // referencing a global host variable by copy. In this case the lambda should; // make a copy of the value of the global host variable. The DRE of the; // captured reference variable cannot be emitted as load from the host; // global variable as compile time constant, since the host variable is not; // accessible on device. The DRE of the captured reference variable has to be; // loaded from captures.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGExpr.cpp:107,Modifiability,variab,variable,107,"// In CUDA/HIP device compilation, a lambda may capture a reference variable; // referencing a global host variable by copy. In this case the lambda should; // make a copy of the value of the global host variable. The DRE of the; // captured reference variable cannot be emitted as load from the host; // global variable as compile time constant, since the host variable is not; // accessible on device. The DRE of the captured reference variable has to be; // loaded from captures.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGExpr.cpp:204,Modifiability,variab,variable,204,"// In CUDA/HIP device compilation, a lambda may capture a reference variable; // referencing a global host variable by copy. In this case the lambda should; // make a copy of the value of the global host variable. The DRE of the; // captured reference variable cannot be emitted as load from the host; // global variable as compile time constant, since the host variable is not; // accessible on device. The DRE of the captured reference variable has to be; // loaded from captures.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGExpr.cpp:252,Modifiability,variab,variable,252,"// In CUDA/HIP device compilation, a lambda may capture a reference variable; // referencing a global host variable by copy. In this case the lambda should; // make a copy of the value of the global host variable. The DRE of the; // captured reference variable cannot be emitted as load from the host; // global variable as compile time constant, since the host variable is not; // accessible on device. The DRE of the captured reference variable has to be; // loaded from captures.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGExpr.cpp:312,Modifiability,variab,variable,312,"// In CUDA/HIP device compilation, a lambda may capture a reference variable; // referencing a global host variable by copy. In this case the lambda should; // make a copy of the value of the global host variable. The DRE of the; // captured reference variable cannot be emitted as load from the host; // global variable as compile time constant, since the host variable is not; // accessible on device. The DRE of the captured reference variable has to be; // loaded from captures.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGExpr.cpp:362,Modifiability,variab,variable,362,"// In CUDA/HIP device compilation, a lambda may capture a reference variable; // referencing a global host variable by copy. In this case the lambda should; // make a copy of the value of the global host variable. The DRE of the; // captured reference variable cannot be emitted as load from the host; // global variable as compile time constant, since the host variable is not; // accessible on device. The DRE of the captured reference variable has to be; // loaded from captures.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGExpr.cpp:438,Modifiability,variab,variable,438,"// In CUDA/HIP device compilation, a lambda may capture a reference variable; // referencing a global host variable by copy. In this case the lambda should; // make a copy of the value of the global host variable. The DRE of the; // captured reference variable cannot be emitted as load from the host; // global variable as compile time constant, since the host variable is not; // accessible on device. The DRE of the captured reference variable has to be; // loaded from captures.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGExpr.cpp:282,Performance,load,load,282,"// In CUDA/HIP device compilation, a lambda may capture a reference variable; // referencing a global host variable by copy. In this case the lambda should; // make a copy of the value of the global host variable. The DRE of the; // captured reference variable cannot be emitted as load from the host; // global variable as compile time constant, since the host variable is not; // accessible on device. The DRE of the captured reference variable has to be; // loaded from captures.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGExpr.cpp:461,Performance,load,loaded,461,"// In CUDA/HIP device compilation, a lambda may capture a reference variable; // referencing a global host variable by copy. In this case the lambda should; // make a copy of the value of the global host variable. The DRE of the; // captured reference variable cannot be emitted as load from the host; // global variable as compile time constant, since the host variable is not; // accessible on device. The DRE of the captured reference variable has to be; // loaded from captures.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGExpr.cpp:382,Security,access,accessible,382,"// In CUDA/HIP device compilation, a lambda may capture a reference variable; // referencing a global host variable by copy. In this case the lambda should; // make a copy of the value of the global host variable. The DRE of the; // captured reference variable cannot be emitted as load from the host; // global variable as compile time constant, since the host variable is not; // accessible on device. The DRE of the captured reference variable has to be; // loaded from captures.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGExpr.cpp:53,Modifiability,variab,variable,53,// Make sure we emit a debug reference to the global variable.; // This should probably fire even for,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGExpr.cpp:22,Modifiability,variab,variable,22,// Try to emit static variable member expressions as DREs.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGExpr.cpp:70,Safety,avoid,avoid,70,// Single-bit booleans don't need to be checked. Special-case this to avoid; // a bit width mismatch when handling bitfield values. This is handled by; // EmitFromMemory for the non-bitfield case.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGExpr.cpp:3,Performance,Load,Load,3,// Load the `iP` storage object (P is the padded vector size).,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGExpr.cpp:51,Performance,perform,performance,51,// Handle vectors of size 3 like size 4 for better performance.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGExpr.cpp:7,Performance,load,load,7,// Now load value.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGExpr.cpp:27,Performance,optimiz,optimizer,27,"// In order to prevent the optimizer from throwing away the check, don't; // attach range metadata to the load.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGExpr.cpp:106,Performance,load,load,106,"// In order to prevent the optimizer from throwing away the check, don't; // attach range metadata to the load.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGExpr.cpp:115,Availability,down,down,115,"// This should really always be an i1, but sometimes it's already; // an i8, and it's awkward to track those cases down.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGExpr.cpp:10,Performance,load,load,10,// Emit a load of a LValue of matrix type. This may require casting the pointer; // to memory address (ArrayType) to a pointer to the value type (VectorType).,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGExpr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGExpr.cpp:130,Performance,load,loads,130,"/// EmitLoadOfLValue - Given an expression that represents a value lvalue, this; /// method emits the address of the lvalue, then loads the result as an rvalue,; /// returning the rvalue.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/CodeGen/CGExpr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGExpr.cpp
