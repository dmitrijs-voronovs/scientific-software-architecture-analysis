id,quality_attribute,keyword,matched_word,match_idx,sentence,source,author,repo,version,wiki,url
https://github.com/qutip/qutip/pull/1499#issuecomment-832138853:427,Integrability,message,messages,427,"> Don't put a link on a word if it doesn't specifically refer to the object you're linking to. Yeah, I was worried if linking words like ket, bra were needed or not. I'll remove them. . > The ""Raises"" section should only be for very non-obvious errors; > Don't put the error message in the description of a ""Raises"" section. No problem. I will remove errors created due to incorrect parameters and other obvious errors + error messages. I will add a parameters section if needed to clarify over ValueError. . > I saw a few places where changes in the formatting accidentally deleted a word, or hid some extra meaning. I think the accidental deletes might have been due to getting caught in some cut/copy/paste flow. . > Do you have the docs building correctly?. Yes, I do. I was a bit confused about how to try to format to functions not in API doc. So, I still tried to link a `ref` to them so that they are formatted similar to hyperlinks. I think a couple of these appear as italics.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1499#issuecomment-832138853
https://github.com/qutip/qutip/issues/1502#issuecomment-823238444:70,Integrability,mediat,mediated,70,"Hi, just to clarify: the intention here is to have the two behaviours mediated by a `settings` flag or just an in-place version check?",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1502#issuecomment-823238444
https://github.com/qutip/qutip/issues/1504#issuecomment-823455134:433,Testability,test,tests,433,"Whoops, you're right. That `prod` should say `np.prod` instead and there's a similar bug in `rand_ket_haar`. Thanks for reporting it!. I also wouldn't be averse if someone wants to change the signature of `rand_ket` to; ```python; def rand_ket(N=None, dims=None, ...):; ...; ```; so that it becomes possible to do `rand_ket(dims=[[2], [1]])` without needing to specify the first argument. Obviously there'll need to be a couple more tests in the function to ensure that at least one of `N` and `dims` was passed.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1504#issuecomment-823455134
https://github.com/qutip/qutip/pull/1505#issuecomment-824433411:106,Testability,test,test,106,"Haha, it's no problem - I didn't spot it was a problem in that PR either. I'm marginally worried that the test suite was even able to generate 68,000 warnings - it seems like the code was hit an excessive number of times. I'm fairly sure that `correlation.py` hasn't been meaningfully touched in years (there are 8-year-old deprecation warnings in it...), but it might be time for one of us to review it.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1505#issuecomment-824433411
https://github.com/qutip/qutip/pull/1506#issuecomment-824507509:52,Availability,failure,failure,52,"Not a huge amount to be done about that CodeClimate failure to be honest - I'm not going to go through and change that function into something more sensible, because the whole type is _completely_ rewritten in 5.0 anyway. If I remember correctly, that whole class is copied from SciPy too, with some small adjustments to the initialisation to speed it up. The failure isn't anything new, it's just being flagged because my diff hit a return statement in a function with about 25 returns.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1506#issuecomment-824507509
https://github.com/qutip/qutip/pull/1506#issuecomment-824507509:360,Availability,failure,failure,360,"Not a huge amount to be done about that CodeClimate failure to be honest - I'm not going to go through and change that function into something more sensible, because the whole type is _completely_ rewritten in 5.0 anyway. If I remember correctly, that whole class is copied from SciPy too, with some small adjustments to the initialisation to speed it up. The failure isn't anything new, it's just being flagged because my diff hit a return statement in a function with about 25 returns.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1506#issuecomment-824507509
https://github.com/qutip/qutip/pull/1506#issuecomment-824625785:54,Availability,failure,failure,54,> Not a huge amount to be done about that CodeClimate failure to be honest. These complexity checking tools were all written with business software application logic in mind and don't cater well to cases where a single conceptual unit can be quite complex. Perhaps when we move to GitHub actions we can run our own linting tools directly there and get rid of CodeClimate.,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1506#issuecomment-824625785
https://github.com/qutip/qutip/pull/1506#issuecomment-824625785:160,Testability,log,logic,160,> Not a huge amount to be done about that CodeClimate failure to be honest. These complexity checking tools were all written with business software application logic in mind and don't cater well to cases where a single conceptual unit can be quite complex. Perhaps when we move to GitHub actions we can run our own linting tools directly there and get rid of CodeClimate.,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1506#issuecomment-824625785
https://github.com/qutip/qutip/pull/1506#issuecomment-826074305:1105,Availability,error,errors,1105,"I'm a fan of the CodeClimate complexity tests, but I wouldn't be averse to removing its complaints about ""TODO"" comments - I'm not sure what we really gain from that in this sort of open-source development. In a business where people are working full-time then I imagine it can be worth preventing a merge to finalise some details, but in our very decentralised development, really in some cases (especially in the next major release), we do need to merge in parts of code we know to be imperfect. That said, we probably should make an effort to clear out some of the TODOs and FIXMEs that are in the codebase already. Pushed fix-up changes since last review:; - wrapped the steadystate SciPy linalg functions so they're simplified at the point of call, and unknown keywords in old SciPy versions are just silently ""eaten"" (this is the same behaviour that the file used to have, just formalised a little more).; - added `TODO` in a comment in `qutip.cy.pyxbuilder`; - changed the static class attributes in `test_superoper.py` into a `setup_method` function. *edit*: oh yeah, forgot that there were still errors in some old SciPy bits in the control module as well. I'll push a fix to that before this needs reviewing.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1506#issuecomment-826074305
https://github.com/qutip/qutip/pull/1506#issuecomment-826074305:426,Deployability,release,release,426,"I'm a fan of the CodeClimate complexity tests, but I wouldn't be averse to removing its complaints about ""TODO"" comments - I'm not sure what we really gain from that in this sort of open-source development. In a business where people are working full-time then I imagine it can be worth preventing a merge to finalise some details, but in our very decentralised development, really in some cases (especially in the next major release), we do need to merge in parts of code we know to be imperfect. That said, we probably should make an effort to clear out some of the TODOs and FIXMEs that are in the codebase already. Pushed fix-up changes since last review:; - wrapped the steadystate SciPy linalg functions so they're simplified at the point of call, and unknown keywords in old SciPy versions are just silently ""eaten"" (this is the same behaviour that the file used to have, just formalised a little more).; - added `TODO` in a comment in `qutip.cy.pyxbuilder`; - changed the static class attributes in `test_superoper.py` into a `setup_method` function. *edit*: oh yeah, forgot that there were still errors in some old SciPy bits in the control module as well. I'll push a fix to that before this needs reviewing.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1506#issuecomment-826074305
https://github.com/qutip/qutip/pull/1506#issuecomment-826074305:663,Integrability,wrap,wrapped,663,"I'm a fan of the CodeClimate complexity tests, but I wouldn't be averse to removing its complaints about ""TODO"" comments - I'm not sure what we really gain from that in this sort of open-source development. In a business where people are working full-time then I imagine it can be worth preventing a merge to finalise some details, but in our very decentralised development, really in some cases (especially in the next major release), we do need to merge in parts of code we know to be imperfect. That said, we probably should make an effort to clear out some of the TODOs and FIXMEs that are in the codebase already. Pushed fix-up changes since last review:; - wrapped the steadystate SciPy linalg functions so they're simplified at the point of call, and unknown keywords in old SciPy versions are just silently ""eaten"" (this is the same behaviour that the file used to have, just formalised a little more).; - added `TODO` in a comment in `qutip.cy.pyxbuilder`; - changed the static class attributes in `test_superoper.py` into a `setup_method` function. *edit*: oh yeah, forgot that there were still errors in some old SciPy bits in the control module as well. I'll push a fix to that before this needs reviewing.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1506#issuecomment-826074305
https://github.com/qutip/qutip/pull/1506#issuecomment-826074305:40,Testability,test,tests,40,"I'm a fan of the CodeClimate complexity tests, but I wouldn't be averse to removing its complaints about ""TODO"" comments - I'm not sure what we really gain from that in this sort of open-source development. In a business where people are working full-time then I imagine it can be worth preventing a merge to finalise some details, but in our very decentralised development, really in some cases (especially in the next major release), we do need to merge in parts of code we know to be imperfect. That said, we probably should make an effort to clear out some of the TODOs and FIXMEs that are in the codebase already. Pushed fix-up changes since last review:; - wrapped the steadystate SciPy linalg functions so they're simplified at the point of call, and unknown keywords in old SciPy versions are just silently ""eaten"" (this is the same behaviour that the file used to have, just formalised a little more).; - added `TODO` in a comment in `qutip.cy.pyxbuilder`; - changed the static class attributes in `test_superoper.py` into a `setup_method` function. *edit*: oh yeah, forgot that there were still errors in some old SciPy bits in the control module as well. I'll push a fix to that before this needs reviewing.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1506#issuecomment-826074305
https://github.com/qutip/qutip/pull/1506#issuecomment-826074305:546,Usability,clear,clear,546,"I'm a fan of the CodeClimate complexity tests, but I wouldn't be averse to removing its complaints about ""TODO"" comments - I'm not sure what we really gain from that in this sort of open-source development. In a business where people are working full-time then I imagine it can be worth preventing a merge to finalise some details, but in our very decentralised development, really in some cases (especially in the next major release), we do need to merge in parts of code we know to be imperfect. That said, we probably should make an effort to clear out some of the TODOs and FIXMEs that are in the codebase already. Pushed fix-up changes since last review:; - wrapped the steadystate SciPy linalg functions so they're simplified at the point of call, and unknown keywords in old SciPy versions are just silently ""eaten"" (this is the same behaviour that the file used to have, just formalised a little more).; - added `TODO` in a comment in `qutip.cy.pyxbuilder`; - changed the static class attributes in `test_superoper.py` into a `setup_method` function. *edit*: oh yeah, forgot that there were still errors in some old SciPy bits in the control module as well. I'll push a fix to that before this needs reviewing.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1506#issuecomment-826074305
https://github.com/qutip/qutip/pull/1506#issuecomment-826074305:721,Usability,simpl,simplified,721,"I'm a fan of the CodeClimate complexity tests, but I wouldn't be averse to removing its complaints about ""TODO"" comments - I'm not sure what we really gain from that in this sort of open-source development. In a business where people are working full-time then I imagine it can be worth preventing a merge to finalise some details, but in our very decentralised development, really in some cases (especially in the next major release), we do need to merge in parts of code we know to be imperfect. That said, we probably should make an effort to clear out some of the TODOs and FIXMEs that are in the codebase already. Pushed fix-up changes since last review:; - wrapped the steadystate SciPy linalg functions so they're simplified at the point of call, and unknown keywords in old SciPy versions are just silently ""eaten"" (this is the same behaviour that the file used to have, just formalised a little more).; - added `TODO` in a comment in `qutip.cy.pyxbuilder`; - changed the static class attributes in `test_superoper.py` into a `setup_method` function. *edit*: oh yeah, forgot that there were still errors in some old SciPy bits in the control module as well. I'll push a fix to that before this needs reviewing.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1506#issuecomment-826074305
https://github.com/qutip/qutip/pull/1506#issuecomment-826084831:218,Testability,test,test-warnings,218,[![Coverage Status](https://coveralls.io/builds/39127235/badge)](https://coveralls.io/builds/39127235). Coverage increased (+0.06%) to 64.305% when pulling **c2c1cd647263331acf82d40f38a8c17e730f406f on jakelishman:fix-test-warnings** into **624405e7c49f7c25d0623451cff5a5a5d0544559 on qutip:master**.,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1506#issuecomment-826084831
https://github.com/qutip/qutip/pull/1506#issuecomment-826657390:83,Availability,error,error,83,"Why though? It _is_ a badly written function and it should be changed. It's a true error, and I wouldn't be confident that there isn't an edge-case bug in it, because it's got so many branches I can't separate them easily in my head when reading it. There's loads of ways to write the same functionality where it's decomposed into smaller bits that are all much easier to check for correctness individually (`mul_dense`, `mul_scalar`, `mul_sparse`, etc) - way easier to verify the top-level dispatching logic into those bits, and then way easier to verify each individual component within them. Also, as long as we have the ""TODO"" error filter turned on, it would be wrong to silence the error that comes from adding a new one, right? If we wanted to skip it, we should turn it off globally (which I'm not against for the TODO thing). If it's in, this way at least lets us use codeclimate properly to see when certain errors were introduced, or when issues in funny-looking functions might have been affected. At any rate, the many-return function is completely removed in `dev.major` since we completely rewrote the backing types.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1506#issuecomment-826657390
https://github.com/qutip/qutip/pull/1506#issuecomment-826657390:631,Availability,error,error,631,"Why though? It _is_ a badly written function and it should be changed. It's a true error, and I wouldn't be confident that there isn't an edge-case bug in it, because it's got so many branches I can't separate them easily in my head when reading it. There's loads of ways to write the same functionality where it's decomposed into smaller bits that are all much easier to check for correctness individually (`mul_dense`, `mul_scalar`, `mul_sparse`, etc) - way easier to verify the top-level dispatching logic into those bits, and then way easier to verify each individual component within them. Also, as long as we have the ""TODO"" error filter turned on, it would be wrong to silence the error that comes from adding a new one, right? If we wanted to skip it, we should turn it off globally (which I'm not against for the TODO thing). If it's in, this way at least lets us use codeclimate properly to see when certain errors were introduced, or when issues in funny-looking functions might have been affected. At any rate, the many-return function is completely removed in `dev.major` since we completely rewrote the backing types.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1506#issuecomment-826657390
https://github.com/qutip/qutip/pull/1506#issuecomment-826657390:688,Availability,error,error,688,"Why though? It _is_ a badly written function and it should be changed. It's a true error, and I wouldn't be confident that there isn't an edge-case bug in it, because it's got so many branches I can't separate them easily in my head when reading it. There's loads of ways to write the same functionality where it's decomposed into smaller bits that are all much easier to check for correctness individually (`mul_dense`, `mul_scalar`, `mul_sparse`, etc) - way easier to verify the top-level dispatching logic into those bits, and then way easier to verify each individual component within them. Also, as long as we have the ""TODO"" error filter turned on, it would be wrong to silence the error that comes from adding a new one, right? If we wanted to skip it, we should turn it off globally (which I'm not against for the TODO thing). If it's in, this way at least lets us use codeclimate properly to see when certain errors were introduced, or when issues in funny-looking functions might have been affected. At any rate, the many-return function is completely removed in `dev.major` since we completely rewrote the backing types.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1506#issuecomment-826657390
https://github.com/qutip/qutip/pull/1506#issuecomment-826657390:918,Availability,error,errors,918,"Why though? It _is_ a badly written function and it should be changed. It's a true error, and I wouldn't be confident that there isn't an edge-case bug in it, because it's got so many branches I can't separate them easily in my head when reading it. There's loads of ways to write the same functionality where it's decomposed into smaller bits that are all much easier to check for correctness individually (`mul_dense`, `mul_scalar`, `mul_sparse`, etc) - way easier to verify the top-level dispatching logic into those bits, and then way easier to verify each individual component within them. Also, as long as we have the ""TODO"" error filter turned on, it would be wrong to silence the error that comes from adding a new one, right? If we wanted to skip it, we should turn it off globally (which I'm not against for the TODO thing). If it's in, this way at least lets us use codeclimate properly to see when certain errors were introduced, or when issues in funny-looking functions might have been affected. At any rate, the many-return function is completely removed in `dev.major` since we completely rewrote the backing types.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1506#issuecomment-826657390
https://github.com/qutip/qutip/pull/1506#issuecomment-826657390:258,Performance,load,loads,258,"Why though? It _is_ a badly written function and it should be changed. It's a true error, and I wouldn't be confident that there isn't an edge-case bug in it, because it's got so many branches I can't separate them easily in my head when reading it. There's loads of ways to write the same functionality where it's decomposed into smaller bits that are all much easier to check for correctness individually (`mul_dense`, `mul_scalar`, `mul_sparse`, etc) - way easier to verify the top-level dispatching logic into those bits, and then way easier to verify each individual component within them. Also, as long as we have the ""TODO"" error filter turned on, it would be wrong to silence the error that comes from adding a new one, right? If we wanted to skip it, we should turn it off globally (which I'm not against for the TODO thing). If it's in, this way at least lets us use codeclimate properly to see when certain errors were introduced, or when issues in funny-looking functions might have been affected. At any rate, the many-return function is completely removed in `dev.major` since we completely rewrote the backing types.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1506#issuecomment-826657390
https://github.com/qutip/qutip/pull/1506#issuecomment-826657390:503,Testability,log,logic,503,"Why though? It _is_ a badly written function and it should be changed. It's a true error, and I wouldn't be confident that there isn't an edge-case bug in it, because it's got so many branches I can't separate them easily in my head when reading it. There's loads of ways to write the same functionality where it's decomposed into smaller bits that are all much easier to check for correctness individually (`mul_dense`, `mul_scalar`, `mul_sparse`, etc) - way easier to verify the top-level dispatching logic into those bits, and then way easier to verify each individual component within them. Also, as long as we have the ""TODO"" error filter turned on, it would be wrong to silence the error that comes from adding a new one, right? If we wanted to skip it, we should turn it off globally (which I'm not against for the TODO thing). If it's in, this way at least lets us use codeclimate properly to see when certain errors were introduced, or when issues in funny-looking functions might have been affected. At any rate, the many-return function is completely removed in `dev.major` since we completely rewrote the backing types.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1506#issuecomment-826657390
https://github.com/qutip/qutip/pull/1506#issuecomment-826663656:178,Availability,failure,failures,178,"@jakelishman Sorry -- I forgot we added the TODO. I was speaking from a bigger picture perspective -- having CodeClimate fail all the time means that we might not notice if more failures are added accidentally, which would reduce the value of running CodeClimate in CI.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1506#issuecomment-826663656
https://github.com/qutip/qutip/pull/1506#issuecomment-826663656:223,Energy Efficiency,reduce,reduce,223,"@jakelishman Sorry -- I forgot we added the TODO. I was speaking from a bigger picture perspective -- having CodeClimate fail all the time means that we might not notice if more failures are added accidentally, which would reduce the value of running CodeClimate in CI.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1506#issuecomment-826663656
https://github.com/qutip/qutip/pull/1506#issuecomment-826673175:158,Availability,error,errors,158,"Oh yeah, I totally agree with that perspective - it's in part why I've gone on my little crusade over the past couple of weeks to remove all the warnings and errors from all the build processes. What do you think a sensible strategy is for handling bug fixes that touches code that issues complaints? CodeClimate will typically restate its complaint if you change a line that contributes to it (e.g. here I changed a ""return"" statement in a function that has too many). I guess there's either ""maintainers state whether any particular PR is acceptable with a failing warning""; ""write a [skip ci] commit message"" (or whatever it's called); or ""any PR that touches complained-about code must fix the error"". Without any experience, to my mind it seems like points 1 and 2 are basically the same, but point 1 gives the power to override to maintainers, and point 2 to contributors - seems like version 2 works well in a business where ""everyone"" is trusted to modify the code, but in the distribued opensource world, maybe not? Point 3 seems ideal in principle, but it seems like it would make it very hard to have first-time contributors do anything with older parts of the library - there'd be a huge onus to completely overhaul functionality, even just to fix small stuff. I really don't know what recommended practices are here - I was roughly working under the assumption that we'd have maintainers be allowed to override complexity failures on occasion, but we've never really discussed it as far as I know, and I do recognise the problems with it.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1506#issuecomment-826673175
https://github.com/qutip/qutip/pull/1506#issuecomment-826673175:698,Availability,error,error,698,"Oh yeah, I totally agree with that perspective - it's in part why I've gone on my little crusade over the past couple of weeks to remove all the warnings and errors from all the build processes. What do you think a sensible strategy is for handling bug fixes that touches code that issues complaints? CodeClimate will typically restate its complaint if you change a line that contributes to it (e.g. here I changed a ""return"" statement in a function that has too many). I guess there's either ""maintainers state whether any particular PR is acceptable with a failing warning""; ""write a [skip ci] commit message"" (or whatever it's called); or ""any PR that touches complained-about code must fix the error"". Without any experience, to my mind it seems like points 1 and 2 are basically the same, but point 1 gives the power to override to maintainers, and point 2 to contributors - seems like version 2 works well in a business where ""everyone"" is trusted to modify the code, but in the distribued opensource world, maybe not? Point 3 seems ideal in principle, but it seems like it would make it very hard to have first-time contributors do anything with older parts of the library - there'd be a huge onus to completely overhaul functionality, even just to fix small stuff. I really don't know what recommended practices are here - I was roughly working under the assumption that we'd have maintainers be allowed to override complexity failures on occasion, but we've never really discussed it as far as I know, and I do recognise the problems with it.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1506#issuecomment-826673175
https://github.com/qutip/qutip/pull/1506#issuecomment-826673175:1435,Availability,failure,failures,1435,"Oh yeah, I totally agree with that perspective - it's in part why I've gone on my little crusade over the past couple of weeks to remove all the warnings and errors from all the build processes. What do you think a sensible strategy is for handling bug fixes that touches code that issues complaints? CodeClimate will typically restate its complaint if you change a line that contributes to it (e.g. here I changed a ""return"" statement in a function that has too many). I guess there's either ""maintainers state whether any particular PR is acceptable with a failing warning""; ""write a [skip ci] commit message"" (or whatever it's called); or ""any PR that touches complained-about code must fix the error"". Without any experience, to my mind it seems like points 1 and 2 are basically the same, but point 1 gives the power to override to maintainers, and point 2 to contributors - seems like version 2 works well in a business where ""everyone"" is trusted to modify the code, but in the distribued opensource world, maybe not? Point 3 seems ideal in principle, but it seems like it would make it very hard to have first-time contributors do anything with older parts of the library - there'd be a huge onus to completely overhaul functionality, even just to fix small stuff. I really don't know what recommended practices are here - I was roughly working under the assumption that we'd have maintainers be allowed to override complexity failures on occasion, but we've never really discussed it as far as I know, and I do recognise the problems with it.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1506#issuecomment-826673175
https://github.com/qutip/qutip/pull/1506#issuecomment-826673175:816,Energy Efficiency,power,power,816,"Oh yeah, I totally agree with that perspective - it's in part why I've gone on my little crusade over the past couple of weeks to remove all the warnings and errors from all the build processes. What do you think a sensible strategy is for handling bug fixes that touches code that issues complaints? CodeClimate will typically restate its complaint if you change a line that contributes to it (e.g. here I changed a ""return"" statement in a function that has too many). I guess there's either ""maintainers state whether any particular PR is acceptable with a failing warning""; ""write a [skip ci] commit message"" (or whatever it's called); or ""any PR that touches complained-about code must fix the error"". Without any experience, to my mind it seems like points 1 and 2 are basically the same, but point 1 gives the power to override to maintainers, and point 2 to contributors - seems like version 2 works well in a business where ""everyone"" is trusted to modify the code, but in the distribued opensource world, maybe not? Point 3 seems ideal in principle, but it seems like it would make it very hard to have first-time contributors do anything with older parts of the library - there'd be a huge onus to completely overhaul functionality, even just to fix small stuff. I really don't know what recommended practices are here - I was roughly working under the assumption that we'd have maintainers be allowed to override complexity failures on occasion, but we've never really discussed it as far as I know, and I do recognise the problems with it.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1506#issuecomment-826673175
https://github.com/qutip/qutip/pull/1506#issuecomment-826673175:603,Integrability,message,message,603,"Oh yeah, I totally agree with that perspective - it's in part why I've gone on my little crusade over the past couple of weeks to remove all the warnings and errors from all the build processes. What do you think a sensible strategy is for handling bug fixes that touches code that issues complaints? CodeClimate will typically restate its complaint if you change a line that contributes to it (e.g. here I changed a ""return"" statement in a function that has too many). I guess there's either ""maintainers state whether any particular PR is acceptable with a failing warning""; ""write a [skip ci] commit message"" (or whatever it's called); or ""any PR that touches complained-about code must fix the error"". Without any experience, to my mind it seems like points 1 and 2 are basically the same, but point 1 gives the power to override to maintainers, and point 2 to contributors - seems like version 2 works well in a business where ""everyone"" is trusted to modify the code, but in the distribued opensource world, maybe not? Point 3 seems ideal in principle, but it seems like it would make it very hard to have first-time contributors do anything with older parts of the library - there'd be a huge onus to completely overhaul functionality, even just to fix small stuff. I really don't know what recommended practices are here - I was roughly working under the assumption that we'd have maintainers be allowed to override complexity failures on occasion, but we've never really discussed it as far as I know, and I do recognise the problems with it.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1506#issuecomment-826673175
https://github.com/qutip/qutip/pull/1506#issuecomment-826814927:205,Modifiability,config,configure,205,"Also: I don't think CodeClimate actually supports skipping the tests when we call it as an action like this. We'd have to set it up to run on CI runner under our control (e.g. on GitHub Actions), and then configure a method of skipping tests within that.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1506#issuecomment-826814927
https://github.com/qutip/qutip/pull/1506#issuecomment-826814927:63,Testability,test,tests,63,"Also: I don't think CodeClimate actually supports skipping the tests when we call it as an action like this. We'd have to set it up to run on CI runner under our control (e.g. on GitHub Actions), and then configure a method of skipping tests within that.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1506#issuecomment-826814927
https://github.com/qutip/qutip/pull/1506#issuecomment-826814927:236,Testability,test,tests,236,"Also: I don't think CodeClimate actually supports skipping the tests when we call it as an action like this. We'd have to set it up to run on CI runner under our control (e.g. on GitHub Actions), and then configure a method of skipping tests within that.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1506#issuecomment-826814927
https://github.com/qutip/qutip/pull/1506#issuecomment-827164375:206,Availability,error,errors,206,"I'll merge this now (it's going to have a couple of merge conflicts with other PRs currently in preparation), but I think there's a bit of discussion that's worth having about our processes for CodeClimate errors.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1506#issuecomment-827164375
https://github.com/qutip/qutip/pull/1507#issuecomment-856760085:0,Deployability,Update,Update,0,"Update from Google Meet discussion:. @jakelishman @Ericgig and I had a quick video call and decided that `.replace(...)` should be renamed something like `.replace_arguments(...)` and accept either a dictionary of arguments (as a positional only argument) or keyword arguments (with the new values for the arguments). In either case, the given argument keys should be update to their new values and any other keys should retain their previous values. For the other attributes `.replace(...)` was supporting replace:. * the shift value can just be updated by wrapping the coefficient with `ShiftCoefficient` or updating the `t0` of an existing shift coefficient.; * the `tlist` value really doesn't make that much sense to update without also updating the associated function values and there are many ways this can go wrong (e.g. sub-expressions with different tlists, supplying a new tlist with the incorrect length).",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1507#issuecomment-856760085
https://github.com/qutip/qutip/pull/1507#issuecomment-856760085:368,Deployability,update,update,368,"Update from Google Meet discussion:. @jakelishman @Ericgig and I had a quick video call and decided that `.replace(...)` should be renamed something like `.replace_arguments(...)` and accept either a dictionary of arguments (as a positional only argument) or keyword arguments (with the new values for the arguments). In either case, the given argument keys should be update to their new values and any other keys should retain their previous values. For the other attributes `.replace(...)` was supporting replace:. * the shift value can just be updated by wrapping the coefficient with `ShiftCoefficient` or updating the `t0` of an existing shift coefficient.; * the `tlist` value really doesn't make that much sense to update without also updating the associated function values and there are many ways this can go wrong (e.g. sub-expressions with different tlists, supplying a new tlist with the incorrect length).",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1507#issuecomment-856760085
https://github.com/qutip/qutip/pull/1507#issuecomment-856760085:547,Deployability,update,updated,547,"Update from Google Meet discussion:. @jakelishman @Ericgig and I had a quick video call and decided that `.replace(...)` should be renamed something like `.replace_arguments(...)` and accept either a dictionary of arguments (as a positional only argument) or keyword arguments (with the new values for the arguments). In either case, the given argument keys should be update to their new values and any other keys should retain their previous values. For the other attributes `.replace(...)` was supporting replace:. * the shift value can just be updated by wrapping the coefficient with `ShiftCoefficient` or updating the `t0` of an existing shift coefficient.; * the `tlist` value really doesn't make that much sense to update without also updating the associated function values and there are many ways this can go wrong (e.g. sub-expressions with different tlists, supplying a new tlist with the incorrect length).",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1507#issuecomment-856760085
https://github.com/qutip/qutip/pull/1507#issuecomment-856760085:722,Deployability,update,update,722,"Update from Google Meet discussion:. @jakelishman @Ericgig and I had a quick video call and decided that `.replace(...)` should be renamed something like `.replace_arguments(...)` and accept either a dictionary of arguments (as a positional only argument) or keyword arguments (with the new values for the arguments). In either case, the given argument keys should be update to their new values and any other keys should retain their previous values. For the other attributes `.replace(...)` was supporting replace:. * the shift value can just be updated by wrapping the coefficient with `ShiftCoefficient` or updating the `t0` of an existing shift coefficient.; * the `tlist` value really doesn't make that much sense to update without also updating the associated function values and there are many ways this can go wrong (e.g. sub-expressions with different tlists, supplying a new tlist with the incorrect length).",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1507#issuecomment-856760085
https://github.com/qutip/qutip/pull/1507#issuecomment-856760085:558,Integrability,wrap,wrapping,558,"Update from Google Meet discussion:. @jakelishman @Ericgig and I had a quick video call and decided that `.replace(...)` should be renamed something like `.replace_arguments(...)` and accept either a dictionary of arguments (as a positional only argument) or keyword arguments (with the new values for the arguments). In either case, the given argument keys should be update to their new values and any other keys should retain their previous values. For the other attributes `.replace(...)` was supporting replace:. * the shift value can just be updated by wrapping the coefficient with `ShiftCoefficient` or updating the `t0` of an existing shift coefficient.; * the `tlist` value really doesn't make that much sense to update without also updating the associated function values and there are many ways this can go wrong (e.g. sub-expressions with different tlists, supplying a new tlist with the incorrect length).",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1507#issuecomment-856760085
https://github.com/qutip/qutip/issues/1508#issuecomment-825608507:749,Availability,down,down,749,"_**edit to put the positivity up top!**_: This is a very exciting prospect to me, and I'm always happy when other libraries want to interact with QuTiP! In the interests of inciting more discussion, I've got thrown in some more discussion points below - I'm 100% sure they're all solvable, but it also seems like there isn't one way that's unambiguously correct to do them, so they're worth discussing. ---. In principle I'm happy to implement this, though I don't really agree with your assertion that `othertype.toqobj()` is bad style! It might be so in Julia, but Python doesn't have all the same multiple-dispatch niceties that Julia has, so at the end of the day, we have to add in a method with a ""magic"" name somewhere, and it all just comes down to choosing the name of the method. The downside to having a magic name is that it means we have to eschew proper namespacing; what if another library one day wants to call their interface the same thing? Then it's completely impossible for a downstream library to interoperate with both. Having conversions be a non-special method of the downstream class, and leaving our constructor unaware of them alleviates that issue. Numpy can get away with squatting the `__array__` name because they're _huge_, but I would argue that if we do it, we could actually _harm_ the quantum software ecosystem in the long-run - what happens when a package better than QuTiP comes along that wants to call its objects `Qobj` as well? Let's face it - it's a pretty straightforward name!. All that said, I am very aware that not everyone agrees with me on this, and I _am_ a big fan of interfaces. Python doesn't give us the tools to do it properly, but we can emulate it, like you suggest. I have a few more considerations to add to a discussion:. 1. we can't have _proper_ namespacing, but let's at least make the magic name `__qutip_qobj__` so we realistically prevent any chance of a clash - by nature of a centralised package manager, we can be sure that no ot",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1508#issuecomment-825608507
https://github.com/qutip/qutip/issues/1508#issuecomment-825608507:794,Availability,down,downside,794,"_**edit to put the positivity up top!**_: This is a very exciting prospect to me, and I'm always happy when other libraries want to interact with QuTiP! In the interests of inciting more discussion, I've got thrown in some more discussion points below - I'm 100% sure they're all solvable, but it also seems like there isn't one way that's unambiguously correct to do them, so they're worth discussing. ---. In principle I'm happy to implement this, though I don't really agree with your assertion that `othertype.toqobj()` is bad style! It might be so in Julia, but Python doesn't have all the same multiple-dispatch niceties that Julia has, so at the end of the day, we have to add in a method with a ""magic"" name somewhere, and it all just comes down to choosing the name of the method. The downside to having a magic name is that it means we have to eschew proper namespacing; what if another library one day wants to call their interface the same thing? Then it's completely impossible for a downstream library to interoperate with both. Having conversions be a non-special method of the downstream class, and leaving our constructor unaware of them alleviates that issue. Numpy can get away with squatting the `__array__` name because they're _huge_, but I would argue that if we do it, we could actually _harm_ the quantum software ecosystem in the long-run - what happens when a package better than QuTiP comes along that wants to call its objects `Qobj` as well? Let's face it - it's a pretty straightforward name!. All that said, I am very aware that not everyone agrees with me on this, and I _am_ a big fan of interfaces. Python doesn't give us the tools to do it properly, but we can emulate it, like you suggest. I have a few more considerations to add to a discussion:. 1. we can't have _proper_ namespacing, but let's at least make the magic name `__qutip_qobj__` so we realistically prevent any chance of a clash - by nature of a centralised package manager, we can be sure that no ot",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1508#issuecomment-825608507
https://github.com/qutip/qutip/issues/1508#issuecomment-825608507:997,Availability,down,downstream,997,"_**edit to put the positivity up top!**_: This is a very exciting prospect to me, and I'm always happy when other libraries want to interact with QuTiP! In the interests of inciting more discussion, I've got thrown in some more discussion points below - I'm 100% sure they're all solvable, but it also seems like there isn't one way that's unambiguously correct to do them, so they're worth discussing. ---. In principle I'm happy to implement this, though I don't really agree with your assertion that `othertype.toqobj()` is bad style! It might be so in Julia, but Python doesn't have all the same multiple-dispatch niceties that Julia has, so at the end of the day, we have to add in a method with a ""magic"" name somewhere, and it all just comes down to choosing the name of the method. The downside to having a magic name is that it means we have to eschew proper namespacing; what if another library one day wants to call their interface the same thing? Then it's completely impossible for a downstream library to interoperate with both. Having conversions be a non-special method of the downstream class, and leaving our constructor unaware of them alleviates that issue. Numpy can get away with squatting the `__array__` name because they're _huge_, but I would argue that if we do it, we could actually _harm_ the quantum software ecosystem in the long-run - what happens when a package better than QuTiP comes along that wants to call its objects `Qobj` as well? Let's face it - it's a pretty straightforward name!. All that said, I am very aware that not everyone agrees with me on this, and I _am_ a big fan of interfaces. Python doesn't give us the tools to do it properly, but we can emulate it, like you suggest. I have a few more considerations to add to a discussion:. 1. we can't have _proper_ namespacing, but let's at least make the magic name `__qutip_qobj__` so we realistically prevent any chance of a clash - by nature of a centralised package manager, we can be sure that no ot",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1508#issuecomment-825608507
https://github.com/qutip/qutip/issues/1508#issuecomment-825608507:1093,Availability,down,downstream,1093,"ther libraries want to interact with QuTiP! In the interests of inciting more discussion, I've got thrown in some more discussion points below - I'm 100% sure they're all solvable, but it also seems like there isn't one way that's unambiguously correct to do them, so they're worth discussing. ---. In principle I'm happy to implement this, though I don't really agree with your assertion that `othertype.toqobj()` is bad style! It might be so in Julia, but Python doesn't have all the same multiple-dispatch niceties that Julia has, so at the end of the day, we have to add in a method with a ""magic"" name somewhere, and it all just comes down to choosing the name of the method. The downside to having a magic name is that it means we have to eschew proper namespacing; what if another library one day wants to call their interface the same thing? Then it's completely impossible for a downstream library to interoperate with both. Having conversions be a non-special method of the downstream class, and leaving our constructor unaware of them alleviates that issue. Numpy can get away with squatting the `__array__` name because they're _huge_, but I would argue that if we do it, we could actually _harm_ the quantum software ecosystem in the long-run - what happens when a package better than QuTiP comes along that wants to call its objects `Qobj` as well? Let's face it - it's a pretty straightforward name!. All that said, I am very aware that not everyone agrees with me on this, and I _am_ a big fan of interfaces. Python doesn't give us the tools to do it properly, but we can emulate it, like you suggest. I have a few more considerations to add to a discussion:. 1. we can't have _proper_ namespacing, but let's at least make the magic name `__qutip_qobj__` so we realistically prevent any chance of a clash - by nature of a centralised package manager, we can be sure that no other package will ever be called QuTiP. If it's a hidden name, it doesn't matter how ""pretty"" it is.; 2. havin",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1508#issuecomment-825608507
https://github.com/qutip/qutip/issues/1508#issuecomment-825608507:2667,Availability,down,downstream,2667,"m_ a big fan of interfaces. Python doesn't give us the tools to do it properly, but we can emulate it, like you suggest. I have a few more considerations to add to a discussion:. 1. we can't have _proper_ namespacing, but let's at least make the magic name `__qutip_qobj__` so we realistically prevent any chance of a clash - by nature of a centralised package manager, we can be sure that no other package will ever be called QuTiP. If it's a hidden name, it doesn't matter how ""pretty"" it is.; 2. having the check in `__init__` might not be correct - it feels like it belongs in `__new__` to me. `__init__` modifies an object that's already been created in Python-space, whereas `__new__` allows you to replace the object creation entirely.; 3. we need to take care to do this in a way that still allows QuTiP to iterate and improve `Qobj.__init__` between major versions. If _we_ define a public interface like this rather than having external libraries provide their own implementations, it puts the burden of maintain compatability on us, and takes it off downstream packages, who are able to define version requirements. For example, calling `otherlib.obj.toqobj()` and having it fail with QuTiP next.0 makes it clear that `otherlib` isn't compatible with QuTiP next, whereas `Qobj(otherlib.obj)` failing would (rightly) be taken as QuTiP being at fault, which stymies our development a little because we're forced to be more conservative than we otherwise would be with our constructor. This is going to be a particular problem with handling `dims`, since we're talking about completely changing the structure for how that's managed internally to help us in other parts of our library.; 4. what will happen with all the other keyword arguments passed to the `Qobj` constructor? We have probably three choices:; - pass all keywords on (which is a big problem in conjunction with the point above);; - pass none of them on, call `__qutip_qobj__` within `Qobj.__new__`, and then pass through `Qobj",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1508#issuecomment-825608507
https://github.com/qutip/qutip/issues/1508#issuecomment-825608507:2960,Availability,fault,fault,2960,"her package will ever be called QuTiP. If it's a hidden name, it doesn't matter how ""pretty"" it is.; 2. having the check in `__init__` might not be correct - it feels like it belongs in `__new__` to me. `__init__` modifies an object that's already been created in Python-space, whereas `__new__` allows you to replace the object creation entirely.; 3. we need to take care to do this in a way that still allows QuTiP to iterate and improve `Qobj.__init__` between major versions. If _we_ define a public interface like this rather than having external libraries provide their own implementations, it puts the burden of maintain compatability on us, and takes it off downstream packages, who are able to define version requirements. For example, calling `otherlib.obj.toqobj()` and having it fail with QuTiP next.0 makes it clear that `otherlib` isn't compatible with QuTiP next, whereas `Qobj(otherlib.obj)` failing would (rightly) be taken as QuTiP being at fault, which stymies our development a little because we're forced to be more conservative than we otherwise would be with our constructor. This is going to be a particular problem with handling `dims`, since we're talking about completely changing the structure for how that's managed internally to help us in other parts of our library.; 4. what will happen with all the other keyword arguments passed to the `Qobj` constructor? We have probably three choices:; - pass all keywords on (which is a big problem in conjunction with the point above);; - pass none of them on, call `__qutip_qobj__` within `Qobj.__new__`, and then pass through `Qobj.__init__` like normal, but now with our new `Qobj` instance as the argument. This would have a slightly nontrivial interaction with the `copy` keyword, I imagine, but not an unsolvable one.; - error if you pass something that defines `__qutip_qobj__` in addition to keywords. This isn't ideal because it gives `Qobj` special treatment - additional kwargs can override `Qobj` settings if they're",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1508#issuecomment-825608507
https://github.com/qutip/qutip/issues/1508#issuecomment-825608507:3800,Availability,error,error,3800,"erlib` isn't compatible with QuTiP next, whereas `Qobj(otherlib.obj)` failing would (rightly) be taken as QuTiP being at fault, which stymies our development a little because we're forced to be more conservative than we otherwise would be with our constructor. This is going to be a particular problem with handling `dims`, since we're talking about completely changing the structure for how that's managed internally to help us in other parts of our library.; 4. what will happen with all the other keyword arguments passed to the `Qobj` constructor? We have probably three choices:; - pass all keywords on (which is a big problem in conjunction with the point above);; - pass none of them on, call `__qutip_qobj__` within `Qobj.__new__`, and then pass through `Qobj.__init__` like normal, but now with our new `Qobj` instance as the argument. This would have a slightly nontrivial interaction with the `copy` keyword, I imagine, but not an unsolvable one.; - error if you pass something that defines `__qutip_qobj__` in addition to keywords. This isn't ideal because it gives `Qobj` special treatment - additional kwargs can override `Qobj` settings if they're compatible. ---. Just in the interest of completeness, let me also just bring up some of the sweeping changes we'll bringing in in QuTiP 5.0 as well, which massively overhaul how `Qobj` is constructed, and how its data is stored. These aren't _directly_ applicable to the current discussion, but they're worth keeping in mind since they're a huge overhaul of how things will be handled, and may have some implications for how implementors of this interface might behave. The new `Qobj` will no longer have the same `fast_csr_matrix` type as its `data` attribute, but instead will have an extensible data type. The two that will be distributed with the library will be `Dense` and `CSR` (which simply do what they say on the tin), and all linear algebra operations between multiple `Qobj` are handled by a custom multiple-dispatch system ",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1508#issuecomment-825608507
https://github.com/qutip/qutip/issues/1508#issuecomment-825608507:7704,Availability,down,downstream,7704,"le for all known types automatically; when it's asked to do say `kron` on two types it doesn't have a specialisation for, it'll cast the inputs through a path of least weight into a specialisation it _does_ know, and then use that. The desired casting rules and preferred output types can be altered dynamically at run-time as well. While I put a lot of effort into making this as fast as possible (and naturally a constant-time operation with respect to the number of known types and specialisations), of course the penalty we pay is a small run-time cost of type look-ups and dispatch (<1µs, but that's dwarfed by the cost of the operations themselves). We will have a hook for creating ""data-layer types"" out of arbitrary inputs, but we weren't heavily focussing on this at all; it seems rather too special a case to have _another_ magic interface for, and we can basically just reuse `__array__` for it - ""data-layer types"" are essentially just ""matrix-like"" objects. It also isn't appropriate for the situation you're describing here, because your own objects have additional ""quantum-specific"" attributes associated with them, similar to the extra stuff that `Qobj` contains. If you want to see more of this, it's in the `dev.major` branch. ---. Defining an interoperable new public interface I think is quite a big task, since it's inherently got to be future-proof. I'm definitely +1 on us having one, and having some discussion about it before a 5.0 release. I'm most concerned with how we can do it in a manner that's useful without stymieing our own ability to iterate and improve. It's harder for downstream packages to support multiple versions of a magic interface than it is for them to changing call QuTiP library functions; with deprecation warnings we can have multiple valid methods for doing the same thing alive in the library at once, but we can't detect what version of an interface a downstream package requires (not keen on the idea of a `__qutip_qobj_api_version__` flag!!).",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1508#issuecomment-825608507
https://github.com/qutip/qutip/issues/1508#issuecomment-825608507:7922,Availability,alive,alive,7922,"le for all known types automatically; when it's asked to do say `kron` on two types it doesn't have a specialisation for, it'll cast the inputs through a path of least weight into a specialisation it _does_ know, and then use that. The desired casting rules and preferred output types can be altered dynamically at run-time as well. While I put a lot of effort into making this as fast as possible (and naturally a constant-time operation with respect to the number of known types and specialisations), of course the penalty we pay is a small run-time cost of type look-ups and dispatch (<1µs, but that's dwarfed by the cost of the operations themselves). We will have a hook for creating ""data-layer types"" out of arbitrary inputs, but we weren't heavily focussing on this at all; it seems rather too special a case to have _another_ magic interface for, and we can basically just reuse `__array__` for it - ""data-layer types"" are essentially just ""matrix-like"" objects. It also isn't appropriate for the situation you're describing here, because your own objects have additional ""quantum-specific"" attributes associated with them, similar to the extra stuff that `Qobj` contains. If you want to see more of this, it's in the `dev.major` branch. ---. Defining an interoperable new public interface I think is quite a big task, since it's inherently got to be future-proof. I'm definitely +1 on us having one, and having some discussion about it before a 5.0 release. I'm most concerned with how we can do it in a manner that's useful without stymieing our own ability to iterate and improve. It's harder for downstream packages to support multiple versions of a magic interface than it is for them to changing call QuTiP library functions; with deprecation warnings we can have multiple valid methods for doing the same thing alive in the library at once, but we can't detect what version of an interface a downstream package requires (not keen on the idea of a `__qutip_qobj_api_version__` flag!!).",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1508#issuecomment-825608507
https://github.com/qutip/qutip/issues/1508#issuecomment-825608507:8003,Availability,down,downstream,8003,"le for all known types automatically; when it's asked to do say `kron` on two types it doesn't have a specialisation for, it'll cast the inputs through a path of least weight into a specialisation it _does_ know, and then use that. The desired casting rules and preferred output types can be altered dynamically at run-time as well. While I put a lot of effort into making this as fast as possible (and naturally a constant-time operation with respect to the number of known types and specialisations), of course the penalty we pay is a small run-time cost of type look-ups and dispatch (<1µs, but that's dwarfed by the cost of the operations themselves). We will have a hook for creating ""data-layer types"" out of arbitrary inputs, but we weren't heavily focussing on this at all; it seems rather too special a case to have _another_ magic interface for, and we can basically just reuse `__array__` for it - ""data-layer types"" are essentially just ""matrix-like"" objects. It also isn't appropriate for the situation you're describing here, because your own objects have additional ""quantum-specific"" attributes associated with them, similar to the extra stuff that `Qobj` contains. If you want to see more of this, it's in the `dev.major` branch. ---. Defining an interoperable new public interface I think is quite a big task, since it's inherently got to be future-proof. I'm definitely +1 on us having one, and having some discussion about it before a 5.0 release. I'm most concerned with how we can do it in a manner that's useful without stymieing our own ability to iterate and improve. It's harder for downstream packages to support multiple versions of a magic interface than it is for them to changing call QuTiP library functions; with deprecation warnings we can have multiple valid methods for doing the same thing alive in the library at once, but we can't detect what version of an interface a downstream package requires (not keen on the idea of a `__qutip_qobj_api_version__` flag!!).",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1508#issuecomment-825608507
https://github.com/qutip/qutip/issues/1508#issuecomment-825608507:7554,Deployability,release,release,7554,"le for all known types automatically; when it's asked to do say `kron` on two types it doesn't have a specialisation for, it'll cast the inputs through a path of least weight into a specialisation it _does_ know, and then use that. The desired casting rules and preferred output types can be altered dynamically at run-time as well. While I put a lot of effort into making this as fast as possible (and naturally a constant-time operation with respect to the number of known types and specialisations), of course the penalty we pay is a small run-time cost of type look-ups and dispatch (<1µs, but that's dwarfed by the cost of the operations themselves). We will have a hook for creating ""data-layer types"" out of arbitrary inputs, but we weren't heavily focussing on this at all; it seems rather too special a case to have _another_ magic interface for, and we can basically just reuse `__array__` for it - ""data-layer types"" are essentially just ""matrix-like"" objects. It also isn't appropriate for the situation you're describing here, because your own objects have additional ""quantum-specific"" attributes associated with them, similar to the extra stuff that `Qobj` contains. If you want to see more of this, it's in the `dev.major` branch. ---. Defining an interoperable new public interface I think is quite a big task, since it's inherently got to be future-proof. I'm definitely +1 on us having one, and having some discussion about it before a 5.0 release. I'm most concerned with how we can do it in a manner that's useful without stymieing our own ability to iterate and improve. It's harder for downstream packages to support multiple versions of a magic interface than it is for them to changing call QuTiP library functions; with deprecation warnings we can have multiple valid methods for doing the same thing alive in the library at once, but we can't detect what version of an interface a downstream package requires (not keen on the idea of a `__qutip_qobj_api_version__` flag!!).",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1508#issuecomment-825608507
https://github.com/qutip/qutip/issues/1508#issuecomment-825608507:5103,Energy Efficiency,efficient,efficient,5103,"--. Just in the interest of completeness, let me also just bring up some of the sweeping changes we'll bringing in in QuTiP 5.0 as well, which massively overhaul how `Qobj` is constructed, and how its data is stored. These aren't _directly_ applicable to the current discussion, but they're worth keeping in mind since they're a huge overhaul of how things will be handled, and may have some implications for how implementors of this interface might behave. The new `Qobj` will no longer have the same `fast_csr_matrix` type as its `data` attribute, but instead will have an extensible data type. The two that will be distributed with the library will be `Dense` and `CSR` (which simply do what they say on the tin), and all linear algebra operations between multiple `Qobj` are handled by a custom multiple-dispatch system that allows additional specialisations to be added in a similar way to Julia. Say you want to define `matmul` between `Dense` on the left and `CSR` on the right to produce a `CSR` output (a specialisation that we likely won't ship with because it's unlikely to be efficient). You'd write your function; ```python; def matmul_dense_csr_csr(left, right):; ...; return out; ```; and then because unlike Julia it's not built-in, you just manually add it to the dispatch table for `matmul`:; ```python; qutip.data.matmul.add_specialisations(matmul_dense_csr_csr, (Dense, CSR), CSR); ```; QuTiP then knows about it, so it'll get used when appropriate. You can also add entirely new types to the dispatch table by adding them to the ""cast"" table `qutip.data.to`, giving at least one method to convert the new type into an already-known one, and at least one method to convert an already-known type into the new type. QuTiP will then be able to use the entirely new type as `Qobj.data` for every single operation within the library (though it won't be super efficient until you add the linear algebra specialisations you use most). This actually goes a bit beyond what Julia does (at ",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1508#issuecomment-825608507
https://github.com/qutip/qutip/issues/1508#issuecomment-825608507:5889,Energy Efficiency,efficient,efficient,5889,"ded in a similar way to Julia. Say you want to define `matmul` between `Dense` on the left and `CSR` on the right to produce a `CSR` output (a specialisation that we likely won't ship with because it's unlikely to be efficient). You'd write your function; ```python; def matmul_dense_csr_csr(left, right):; ...; return out; ```; and then because unlike Julia it's not built-in, you just manually add it to the dispatch table for `matmul`:; ```python; qutip.data.matmul.add_specialisations(matmul_dense_csr_csr, (Dense, CSR), CSR); ```; QuTiP then knows about it, so it'll get used when appropriate. You can also add entirely new types to the dispatch table by adding them to the ""cast"" table `qutip.data.to`, giving at least one method to convert the new type into an already-known one, and at least one method to convert an already-known type into the new type. QuTiP will then be able to use the entirely new type as `Qobj.data` for every single operation within the library (though it won't be super efficient until you add the linear algebra specialisations you use most). This actually goes a bit beyond what Julia does (at least as far as I know), because QuTiP's new system ""completes"" the dispatch table for all known types automatically; when it's asked to do say `kron` on two types it doesn't have a specialisation for, it'll cast the inputs through a path of least weight into a specialisation it _does_ know, and then use that. The desired casting rules and preferred output types can be altered dynamically at run-time as well. While I put a lot of effort into making this as fast as possible (and naturally a constant-time operation with respect to the number of known types and specialisations), of course the penalty we pay is a small run-time cost of type look-ups and dispatch (<1µs, but that's dwarfed by the cost of the operations themselves). We will have a hook for creating ""data-layer types"" out of arbitrary inputs, but we weren't heavily focussing on this at all; it seems r",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1508#issuecomment-825608507
https://github.com/qutip/qutip/issues/1508#issuecomment-825608507:933,Integrability,interface,interface,933,"_**edit to put the positivity up top!**_: This is a very exciting prospect to me, and I'm always happy when other libraries want to interact with QuTiP! In the interests of inciting more discussion, I've got thrown in some more discussion points below - I'm 100% sure they're all solvable, but it also seems like there isn't one way that's unambiguously correct to do them, so they're worth discussing. ---. In principle I'm happy to implement this, though I don't really agree with your assertion that `othertype.toqobj()` is bad style! It might be so in Julia, but Python doesn't have all the same multiple-dispatch niceties that Julia has, so at the end of the day, we have to add in a method with a ""magic"" name somewhere, and it all just comes down to choosing the name of the method. The downside to having a magic name is that it means we have to eschew proper namespacing; what if another library one day wants to call their interface the same thing? Then it's completely impossible for a downstream library to interoperate with both. Having conversions be a non-special method of the downstream class, and leaving our constructor unaware of them alleviates that issue. Numpy can get away with squatting the `__array__` name because they're _huge_, but I would argue that if we do it, we could actually _harm_ the quantum software ecosystem in the long-run - what happens when a package better than QuTiP comes along that wants to call its objects `Qobj` as well? Let's face it - it's a pretty straightforward name!. All that said, I am very aware that not everyone agrees with me on this, and I _am_ a big fan of interfaces. Python doesn't give us the tools to do it properly, but we can emulate it, like you suggest. I have a few more considerations to add to a discussion:. 1. we can't have _proper_ namespacing, but let's at least make the magic name `__qutip_qobj__` so we realistically prevent any chance of a clash - by nature of a centralised package manager, we can be sure that no ot",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1508#issuecomment-825608507
https://github.com/qutip/qutip/issues/1508#issuecomment-825608507:1622,Integrability,interface,interfaces,1622,"n't have all the same multiple-dispatch niceties that Julia has, so at the end of the day, we have to add in a method with a ""magic"" name somewhere, and it all just comes down to choosing the name of the method. The downside to having a magic name is that it means we have to eschew proper namespacing; what if another library one day wants to call their interface the same thing? Then it's completely impossible for a downstream library to interoperate with both. Having conversions be a non-special method of the downstream class, and leaving our constructor unaware of them alleviates that issue. Numpy can get away with squatting the `__array__` name because they're _huge_, but I would argue that if we do it, we could actually _harm_ the quantum software ecosystem in the long-run - what happens when a package better than QuTiP comes along that wants to call its objects `Qobj` as well? Let's face it - it's a pretty straightforward name!. All that said, I am very aware that not everyone agrees with me on this, and I _am_ a big fan of interfaces. Python doesn't give us the tools to do it properly, but we can emulate it, like you suggest. I have a few more considerations to add to a discussion:. 1. we can't have _proper_ namespacing, but let's at least make the magic name `__qutip_qobj__` so we realistically prevent any chance of a clash - by nature of a centralised package manager, we can be sure that no other package will ever be called QuTiP. If it's a hidden name, it doesn't matter how ""pretty"" it is.; 2. having the check in `__init__` might not be correct - it feels like it belongs in `__new__` to me. `__init__` modifies an object that's already been created in Python-space, whereas `__new__` allows you to replace the object creation entirely.; 3. we need to take care to do this in a way that still allows QuTiP to iterate and improve `Qobj.__init__` between major versions. If _we_ define a public interface like this rather than having external libraries provide their ow",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1508#issuecomment-825608507
https://github.com/qutip/qutip/issues/1508#issuecomment-825608507:2505,Integrability,interface,interface,2505,"m_ a big fan of interfaces. Python doesn't give us the tools to do it properly, but we can emulate it, like you suggest. I have a few more considerations to add to a discussion:. 1. we can't have _proper_ namespacing, but let's at least make the magic name `__qutip_qobj__` so we realistically prevent any chance of a clash - by nature of a centralised package manager, we can be sure that no other package will ever be called QuTiP. If it's a hidden name, it doesn't matter how ""pretty"" it is.; 2. having the check in `__init__` might not be correct - it feels like it belongs in `__new__` to me. `__init__` modifies an object that's already been created in Python-space, whereas `__new__` allows you to replace the object creation entirely.; 3. we need to take care to do this in a way that still allows QuTiP to iterate and improve `Qobj.__init__` between major versions. If _we_ define a public interface like this rather than having external libraries provide their own implementations, it puts the burden of maintain compatability on us, and takes it off downstream packages, who are able to define version requirements. For example, calling `otherlib.obj.toqobj()` and having it fail with QuTiP next.0 makes it clear that `otherlib` isn't compatible with QuTiP next, whereas `Qobj(otherlib.obj)` failing would (rightly) be taken as QuTiP being at fault, which stymies our development a little because we're forced to be more conservative than we otherwise would be with our constructor. This is going to be a particular problem with handling `dims`, since we're talking about completely changing the structure for how that's managed internally to help us in other parts of our library.; 4. what will happen with all the other keyword arguments passed to the `Qobj` constructor? We have probably three choices:; - pass all keywords on (which is a big problem in conjunction with the point above);; - pass none of them on, call `__qutip_qobj__` within `Qobj.__new__`, and then pass through `Qobj",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1508#issuecomment-825608507
https://github.com/qutip/qutip/issues/1508#issuecomment-825608507:4449,Integrability,interface,interface,4449,"ments passed to the `Qobj` constructor? We have probably three choices:; - pass all keywords on (which is a big problem in conjunction with the point above);; - pass none of them on, call `__qutip_qobj__` within `Qobj.__new__`, and then pass through `Qobj.__init__` like normal, but now with our new `Qobj` instance as the argument. This would have a slightly nontrivial interaction with the `copy` keyword, I imagine, but not an unsolvable one.; - error if you pass something that defines `__qutip_qobj__` in addition to keywords. This isn't ideal because it gives `Qobj` special treatment - additional kwargs can override `Qobj` settings if they're compatible. ---. Just in the interest of completeness, let me also just bring up some of the sweeping changes we'll bringing in in QuTiP 5.0 as well, which massively overhaul how `Qobj` is constructed, and how its data is stored. These aren't _directly_ applicable to the current discussion, but they're worth keeping in mind since they're a huge overhaul of how things will be handled, and may have some implications for how implementors of this interface might behave. The new `Qobj` will no longer have the same `fast_csr_matrix` type as its `data` attribute, but instead will have an extensible data type. The two that will be distributed with the library will be `Dense` and `CSR` (which simply do what they say on the tin), and all linear algebra operations between multiple `Qobj` are handled by a custom multiple-dispatch system that allows additional specialisations to be added in a similar way to Julia. Say you want to define `matmul` between `Dense` on the left and `CSR` on the right to produce a `CSR` output (a specialisation that we likely won't ship with because it's unlikely to be efficient). You'd write your function; ```python; def matmul_dense_csr_csr(left, right):; ...; return out; ```; and then because unlike Julia it's not built-in, you just manually add it to the dispatch table for `matmul`:; ```python; qutip.data.matm",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1508#issuecomment-825608507
https://github.com/qutip/qutip/issues/1508#issuecomment-825608507:6936,Integrability,interface,interface,6936," add the linear algebra specialisations you use most). This actually goes a bit beyond what Julia does (at least as far as I know), because QuTiP's new system ""completes"" the dispatch table for all known types automatically; when it's asked to do say `kron` on two types it doesn't have a specialisation for, it'll cast the inputs through a path of least weight into a specialisation it _does_ know, and then use that. The desired casting rules and preferred output types can be altered dynamically at run-time as well. While I put a lot of effort into making this as fast as possible (and naturally a constant-time operation with respect to the number of known types and specialisations), of course the penalty we pay is a small run-time cost of type look-ups and dispatch (<1µs, but that's dwarfed by the cost of the operations themselves). We will have a hook for creating ""data-layer types"" out of arbitrary inputs, but we weren't heavily focussing on this at all; it seems rather too special a case to have _another_ magic interface for, and we can basically just reuse `__array__` for it - ""data-layer types"" are essentially just ""matrix-like"" objects. It also isn't appropriate for the situation you're describing here, because your own objects have additional ""quantum-specific"" attributes associated with them, similar to the extra stuff that `Qobj` contains. If you want to see more of this, it's in the `dev.major` branch. ---. Defining an interoperable new public interface I think is quite a big task, since it's inherently got to be future-proof. I'm definitely +1 on us having one, and having some discussion about it before a 5.0 release. I'm most concerned with how we can do it in a manner that's useful without stymieing our own ability to iterate and improve. It's harder for downstream packages to support multiple versions of a magic interface than it is for them to changing call QuTiP library functions; with deprecation warnings we can have multiple valid methods for doing t",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1508#issuecomment-825608507
https://github.com/qutip/qutip/issues/1508#issuecomment-825608507:7359,Integrability,interoperab,interoperable,7359,"le for all known types automatically; when it's asked to do say `kron` on two types it doesn't have a specialisation for, it'll cast the inputs through a path of least weight into a specialisation it _does_ know, and then use that. The desired casting rules and preferred output types can be altered dynamically at run-time as well. While I put a lot of effort into making this as fast as possible (and naturally a constant-time operation with respect to the number of known types and specialisations), of course the penalty we pay is a small run-time cost of type look-ups and dispatch (<1µs, but that's dwarfed by the cost of the operations themselves). We will have a hook for creating ""data-layer types"" out of arbitrary inputs, but we weren't heavily focussing on this at all; it seems rather too special a case to have _another_ magic interface for, and we can basically just reuse `__array__` for it - ""data-layer types"" are essentially just ""matrix-like"" objects. It also isn't appropriate for the situation you're describing here, because your own objects have additional ""quantum-specific"" attributes associated with them, similar to the extra stuff that `Qobj` contains. If you want to see more of this, it's in the `dev.major` branch. ---. Defining an interoperable new public interface I think is quite a big task, since it's inherently got to be future-proof. I'm definitely +1 on us having one, and having some discussion about it before a 5.0 release. I'm most concerned with how we can do it in a manner that's useful without stymieing our own ability to iterate and improve. It's harder for downstream packages to support multiple versions of a magic interface than it is for them to changing call QuTiP library functions; with deprecation warnings we can have multiple valid methods for doing the same thing alive in the library at once, but we can't detect what version of an interface a downstream package requires (not keen on the idea of a `__qutip_qobj_api_version__` flag!!).",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1508#issuecomment-825608507
https://github.com/qutip/qutip/issues/1508#issuecomment-825608507:7384,Integrability,interface,interface,7384,"le for all known types automatically; when it's asked to do say `kron` on two types it doesn't have a specialisation for, it'll cast the inputs through a path of least weight into a specialisation it _does_ know, and then use that. The desired casting rules and preferred output types can be altered dynamically at run-time as well. While I put a lot of effort into making this as fast as possible (and naturally a constant-time operation with respect to the number of known types and specialisations), of course the penalty we pay is a small run-time cost of type look-ups and dispatch (<1µs, but that's dwarfed by the cost of the operations themselves). We will have a hook for creating ""data-layer types"" out of arbitrary inputs, but we weren't heavily focussing on this at all; it seems rather too special a case to have _another_ magic interface for, and we can basically just reuse `__array__` for it - ""data-layer types"" are essentially just ""matrix-like"" objects. It also isn't appropriate for the situation you're describing here, because your own objects have additional ""quantum-specific"" attributes associated with them, similar to the extra stuff that `Qobj` contains. If you want to see more of this, it's in the `dev.major` branch. ---. Defining an interoperable new public interface I think is quite a big task, since it's inherently got to be future-proof. I'm definitely +1 on us having one, and having some discussion about it before a 5.0 release. I'm most concerned with how we can do it in a manner that's useful without stymieing our own ability to iterate and improve. It's harder for downstream packages to support multiple versions of a magic interface than it is for them to changing call QuTiP library functions; with deprecation warnings we can have multiple valid methods for doing the same thing alive in the library at once, but we can't detect what version of an interface a downstream package requires (not keen on the idea of a `__qutip_qobj_api_version__` flag!!).",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1508#issuecomment-825608507
https://github.com/qutip/qutip/issues/1508#issuecomment-825608507:7764,Integrability,interface,interface,7764,"le for all known types automatically; when it's asked to do say `kron` on two types it doesn't have a specialisation for, it'll cast the inputs through a path of least weight into a specialisation it _does_ know, and then use that. The desired casting rules and preferred output types can be altered dynamically at run-time as well. While I put a lot of effort into making this as fast as possible (and naturally a constant-time operation with respect to the number of known types and specialisations), of course the penalty we pay is a small run-time cost of type look-ups and dispatch (<1µs, but that's dwarfed by the cost of the operations themselves). We will have a hook for creating ""data-layer types"" out of arbitrary inputs, but we weren't heavily focussing on this at all; it seems rather too special a case to have _another_ magic interface for, and we can basically just reuse `__array__` for it - ""data-layer types"" are essentially just ""matrix-like"" objects. It also isn't appropriate for the situation you're describing here, because your own objects have additional ""quantum-specific"" attributes associated with them, similar to the extra stuff that `Qobj` contains. If you want to see more of this, it's in the `dev.major` branch. ---. Defining an interoperable new public interface I think is quite a big task, since it's inherently got to be future-proof. I'm definitely +1 on us having one, and having some discussion about it before a 5.0 release. I'm most concerned with how we can do it in a manner that's useful without stymieing our own ability to iterate and improve. It's harder for downstream packages to support multiple versions of a magic interface than it is for them to changing call QuTiP library functions; with deprecation warnings we can have multiple valid methods for doing the same thing alive in the library at once, but we can't detect what version of an interface a downstream package requires (not keen on the idea of a `__qutip_qobj_api_version__` flag!!).",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1508#issuecomment-825608507
https://github.com/qutip/qutip/issues/1508#issuecomment-825608507:7991,Integrability,interface,interface,7991,"le for all known types automatically; when it's asked to do say `kron` on two types it doesn't have a specialisation for, it'll cast the inputs through a path of least weight into a specialisation it _does_ know, and then use that. The desired casting rules and preferred output types can be altered dynamically at run-time as well. While I put a lot of effort into making this as fast as possible (and naturally a constant-time operation with respect to the number of known types and specialisations), of course the penalty we pay is a small run-time cost of type look-ups and dispatch (<1µs, but that's dwarfed by the cost of the operations themselves). We will have a hook for creating ""data-layer types"" out of arbitrary inputs, but we weren't heavily focussing on this at all; it seems rather too special a case to have _another_ magic interface for, and we can basically just reuse `__array__` for it - ""data-layer types"" are essentially just ""matrix-like"" objects. It also isn't appropriate for the situation you're describing here, because your own objects have additional ""quantum-specific"" attributes associated with them, similar to the extra stuff that `Qobj` contains. If you want to see more of this, it's in the `dev.major` branch. ---. Defining an interoperable new public interface I think is quite a big task, since it's inherently got to be future-proof. I'm definitely +1 on us having one, and having some discussion about it before a 5.0 release. I'm most concerned with how we can do it in a manner that's useful without stymieing our own ability to iterate and improve. It's harder for downstream packages to support multiple versions of a magic interface than it is for them to changing call QuTiP library functions; with deprecation warnings we can have multiple valid methods for doing the same thing alive in the library at once, but we can't detect what version of an interface a downstream package requires (not keen on the idea of a `__qutip_qobj_api_version__` flag!!).",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1508#issuecomment-825608507
https://github.com/qutip/qutip/issues/1508#issuecomment-825608507:7965,Safety,detect,detect,7965,"le for all known types automatically; when it's asked to do say `kron` on two types it doesn't have a specialisation for, it'll cast the inputs through a path of least weight into a specialisation it _does_ know, and then use that. The desired casting rules and preferred output types can be altered dynamically at run-time as well. While I put a lot of effort into making this as fast as possible (and naturally a constant-time operation with respect to the number of known types and specialisations), of course the penalty we pay is a small run-time cost of type look-ups and dispatch (<1µs, but that's dwarfed by the cost of the operations themselves). We will have a hook for creating ""data-layer types"" out of arbitrary inputs, but we weren't heavily focussing on this at all; it seems rather too special a case to have _another_ magic interface for, and we can basically just reuse `__array__` for it - ""data-layer types"" are essentially just ""matrix-like"" objects. It also isn't appropriate for the situation you're describing here, because your own objects have additional ""quantum-specific"" attributes associated with them, similar to the extra stuff that `Qobj` contains. If you want to see more of this, it's in the `dev.major` branch. ---. Defining an interoperable new public interface I think is quite a big task, since it's inherently got to be future-proof. I'm definitely +1 on us having one, and having some discussion about it before a 5.0 release. I'm most concerned with how we can do it in a manner that's useful without stymieing our own ability to iterate and improve. It's harder for downstream packages to support multiple versions of a magic interface than it is for them to changing call QuTiP library functions; with deprecation warnings we can have multiple valid methods for doing the same thing alive in the library at once, but we can't detect what version of an interface a downstream package requires (not keen on the idea of a `__qutip_qobj_api_version__` flag!!).",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1508#issuecomment-825608507
https://github.com/qutip/qutip/issues/1508#issuecomment-825608507:488,Testability,assert,assertion,488,"_**edit to put the positivity up top!**_: This is a very exciting prospect to me, and I'm always happy when other libraries want to interact with QuTiP! In the interests of inciting more discussion, I've got thrown in some more discussion points below - I'm 100% sure they're all solvable, but it also seems like there isn't one way that's unambiguously correct to do them, so they're worth discussing. ---. In principle I'm happy to implement this, though I don't really agree with your assertion that `othertype.toqobj()` is bad style! It might be so in Julia, but Python doesn't have all the same multiple-dispatch niceties that Julia has, so at the end of the day, we have to add in a method with a ""magic"" name somewhere, and it all just comes down to choosing the name of the method. The downside to having a magic name is that it means we have to eschew proper namespacing; what if another library one day wants to call their interface the same thing? Then it's completely impossible for a downstream library to interoperate with both. Having conversions be a non-special method of the downstream class, and leaving our constructor unaware of them alleviates that issue. Numpy can get away with squatting the `__array__` name because they're _huge_, but I would argue that if we do it, we could actually _harm_ the quantum software ecosystem in the long-run - what happens when a package better than QuTiP comes along that wants to call its objects `Qobj` as well? Let's face it - it's a pretty straightforward name!. All that said, I am very aware that not everyone agrees with me on this, and I _am_ a big fan of interfaces. Python doesn't give us the tools to do it properly, but we can emulate it, like you suggest. I have a few more considerations to add to a discussion:. 1. we can't have _proper_ namespacing, but let's at least make the magic name `__qutip_qobj__` so we realistically prevent any chance of a clash - by nature of a centralised package manager, we can be sure that no ot",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1508#issuecomment-825608507
https://github.com/qutip/qutip/issues/1508#issuecomment-825608507:2824,Usability,clear,clear,2824,"name `__qutip_qobj__` so we realistically prevent any chance of a clash - by nature of a centralised package manager, we can be sure that no other package will ever be called QuTiP. If it's a hidden name, it doesn't matter how ""pretty"" it is.; 2. having the check in `__init__` might not be correct - it feels like it belongs in `__new__` to me. `__init__` modifies an object that's already been created in Python-space, whereas `__new__` allows you to replace the object creation entirely.; 3. we need to take care to do this in a way that still allows QuTiP to iterate and improve `Qobj.__init__` between major versions. If _we_ define a public interface like this rather than having external libraries provide their own implementations, it puts the burden of maintain compatability on us, and takes it off downstream packages, who are able to define version requirements. For example, calling `otherlib.obj.toqobj()` and having it fail with QuTiP next.0 makes it clear that `otherlib` isn't compatible with QuTiP next, whereas `Qobj(otherlib.obj)` failing would (rightly) be taken as QuTiP being at fault, which stymies our development a little because we're forced to be more conservative than we otherwise would be with our constructor. This is going to be a particular problem with handling `dims`, since we're talking about completely changing the structure for how that's managed internally to help us in other parts of our library.; 4. what will happen with all the other keyword arguments passed to the `Qobj` constructor? We have probably three choices:; - pass all keywords on (which is a big problem in conjunction with the point above);; - pass none of them on, call `__qutip_qobj__` within `Qobj.__new__`, and then pass through `Qobj.__init__` like normal, but now with our new `Qobj` instance as the argument. This would have a slightly nontrivial interaction with the `copy` keyword, I imagine, but not an unsolvable one.; - error if you pass something that defines `__qutip_qobj__` ",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1508#issuecomment-825608507
https://github.com/qutip/qutip/issues/1508#issuecomment-825608507:4695,Usability,simpl,simply,4695,"agine, but not an unsolvable one.; - error if you pass something that defines `__qutip_qobj__` in addition to keywords. This isn't ideal because it gives `Qobj` special treatment - additional kwargs can override `Qobj` settings if they're compatible. ---. Just in the interest of completeness, let me also just bring up some of the sweeping changes we'll bringing in in QuTiP 5.0 as well, which massively overhaul how `Qobj` is constructed, and how its data is stored. These aren't _directly_ applicable to the current discussion, but they're worth keeping in mind since they're a huge overhaul of how things will be handled, and may have some implications for how implementors of this interface might behave. The new `Qobj` will no longer have the same `fast_csr_matrix` type as its `data` attribute, but instead will have an extensible data type. The two that will be distributed with the library will be `Dense` and `CSR` (which simply do what they say on the tin), and all linear algebra operations between multiple `Qobj` are handled by a custom multiple-dispatch system that allows additional specialisations to be added in a similar way to Julia. Say you want to define `matmul` between `Dense` on the left and `CSR` on the right to produce a `CSR` output (a specialisation that we likely won't ship with because it's unlikely to be efficient). You'd write your function; ```python; def matmul_dense_csr_csr(left, right):; ...; return out; ```; and then because unlike Julia it's not built-in, you just manually add it to the dispatch table for `matmul`:; ```python; qutip.data.matmul.add_specialisations(matmul_dense_csr_csr, (Dense, CSR), CSR); ```; QuTiP then knows about it, so it'll get used when appropriate. You can also add entirely new types to the dispatch table by adding them to the ""cast"" table `qutip.data.to`, giving at least one method to convert the new type into an already-known one, and at least one method to convert an already-known type into the new type. QuTiP will then",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1508#issuecomment-825608507
https://github.com/qutip/qutip/issues/1508#issuecomment-825646108:63,Integrability,interface,interface,63,"Oh, one thing that I'd like to suggest we _don't_ do: use this interface to _implicitly_ create `Qobj` inside our functions. `__array__` was also originally meant as a method for allowing Numpy's ufuncs to act on other types. This actually caused us rather annoying problems in QuTiP when they decided to change up its semantics a little bit in version 1.20, which is in part is why I'm very cautious around this topic. Since we weren't super careful when we introduced `Qobj.__array__`, we allowed things like `np.sin(qutip.sigmax())` which we shouldn't have, and then the Numpy 1.20 changes completely altered how `ndarray(dtype=object)` arrays behaved when containing objects that all implemented `__array__`. To get around _some_ of these problems, they've introduced `__array_function__` and `__array_ufunc__`, though to me at best these are bandages. Those two concerns aren't immediately applicable in QuTiP, but they're sort of indicative of potential problems when using a `__qutip_qobj__` method implicitly in functions like `Qobj.__add__`. These are where it becomes very evident that Julia-style programming doesn't apply in the same way in Python. Python is only a single-dispatch language, so `a + b` will dispatch using the table of `a` predominantly, whereas `b + a` will dispatch on `b`. In a proper multiple-dispatch library the rules are separate to the classes, so neither class is called preferentially, there's just one rule and either library can define it. My point with this is that if `Qobj.__add__` has a case where it handles Qobj-like types, then we prevent the other library from overriding the method. Multi-methods like this simply don't work the same in Python as they do in Julia, so even if `Qobj` implements interfaces from a variety of other libraries, we'd never get good consistent behaviour with functions like this. Operations that ought to be commutative like `+` would become dependent on operand order. To some degree, implementing the interface would be a ",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1508#issuecomment-825646108
https://github.com/qutip/qutip/issues/1508#issuecomment-825646108:1744,Integrability,interface,interfaces,1744,"ndarray(dtype=object)` arrays behaved when containing objects that all implemented `__array__`. To get around _some_ of these problems, they've introduced `__array_function__` and `__array_ufunc__`, though to me at best these are bandages. Those two concerns aren't immediately applicable in QuTiP, but they're sort of indicative of potential problems when using a `__qutip_qobj__` method implicitly in functions like `Qobj.__add__`. These are where it becomes very evident that Julia-style programming doesn't apply in the same way in Python. Python is only a single-dispatch language, so `a + b` will dispatch using the table of `a` predominantly, whereas `b + a` will dispatch on `b`. In a proper multiple-dispatch library the rules are separate to the classes, so neither class is called preferentially, there's just one rule and either library can define it. My point with this is that if `Qobj.__add__` has a case where it handles Qobj-like types, then we prevent the other library from overriding the method. Multi-methods like this simply don't work the same in Python as they do in Julia, so even if `Qobj` implements interfaces from a variety of other libraries, we'd never get good consistent behaviour with functions like this. Operations that ought to be commutative like `+` would become dependent on operand order. To some degree, implementing the interface would be a guarantee that an object would always be able to follow QuTiP's semantics, otherwise it would just be annoying to users - _sometimes_ an object would be able to be used implicitly, sometimes not. I know the ""Python way"" is supposedly ""try it and see"", but if you're doing any serious development, that quickly becomes unreasonable if a type works some times, but not others. The other part of the Python way is ""explicit is better than implicit"", and here having an explicit type conversion to me is just being explicit about which library's semantics you want to follow, which is easier to read and easier to debug.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1508#issuecomment-825646108
https://github.com/qutip/qutip/issues/1508#issuecomment-825646108:1919,Integrability,depend,dependent,1919,"ndarray(dtype=object)` arrays behaved when containing objects that all implemented `__array__`. To get around _some_ of these problems, they've introduced `__array_function__` and `__array_ufunc__`, though to me at best these are bandages. Those two concerns aren't immediately applicable in QuTiP, but they're sort of indicative of potential problems when using a `__qutip_qobj__` method implicitly in functions like `Qobj.__add__`. These are where it becomes very evident that Julia-style programming doesn't apply in the same way in Python. Python is only a single-dispatch language, so `a + b` will dispatch using the table of `a` predominantly, whereas `b + a` will dispatch on `b`. In a proper multiple-dispatch library the rules are separate to the classes, so neither class is called preferentially, there's just one rule and either library can define it. My point with this is that if `Qobj.__add__` has a case where it handles Qobj-like types, then we prevent the other library from overriding the method. Multi-methods like this simply don't work the same in Python as they do in Julia, so even if `Qobj` implements interfaces from a variety of other libraries, we'd never get good consistent behaviour with functions like this. Operations that ought to be commutative like `+` would become dependent on operand order. To some degree, implementing the interface would be a guarantee that an object would always be able to follow QuTiP's semantics, otherwise it would just be annoying to users - _sometimes_ an object would be able to be used implicitly, sometimes not. I know the ""Python way"" is supposedly ""try it and see"", but if you're doing any serious development, that quickly becomes unreasonable if a type works some times, but not others. The other part of the Python way is ""explicit is better than implicit"", and here having an explicit type conversion to me is just being explicit about which library's semantics you want to follow, which is easier to read and easier to debug.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1508#issuecomment-825646108
https://github.com/qutip/qutip/issues/1508#issuecomment-825646108:1980,Integrability,interface,interface,1980,"ndarray(dtype=object)` arrays behaved when containing objects that all implemented `__array__`. To get around _some_ of these problems, they've introduced `__array_function__` and `__array_ufunc__`, though to me at best these are bandages. Those two concerns aren't immediately applicable in QuTiP, but they're sort of indicative of potential problems when using a `__qutip_qobj__` method implicitly in functions like `Qobj.__add__`. These are where it becomes very evident that Julia-style programming doesn't apply in the same way in Python. Python is only a single-dispatch language, so `a + b` will dispatch using the table of `a` predominantly, whereas `b + a` will dispatch on `b`. In a proper multiple-dispatch library the rules are separate to the classes, so neither class is called preferentially, there's just one rule and either library can define it. My point with this is that if `Qobj.__add__` has a case where it handles Qobj-like types, then we prevent the other library from overriding the method. Multi-methods like this simply don't work the same in Python as they do in Julia, so even if `Qobj` implements interfaces from a variety of other libraries, we'd never get good consistent behaviour with functions like this. Operations that ought to be commutative like `+` would become dependent on operand order. To some degree, implementing the interface would be a guarantee that an object would always be able to follow QuTiP's semantics, otherwise it would just be annoying to users - _sometimes_ an object would be able to be used implicitly, sometimes not. I know the ""Python way"" is supposedly ""try it and see"", but if you're doing any serious development, that quickly becomes unreasonable if a type works some times, but not others. The other part of the Python way is ""explicit is better than implicit"", and here having an explicit type conversion to me is just being explicit about which library's semantics you want to follow, which is easier to read and easier to debug.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1508#issuecomment-825646108
https://github.com/qutip/qutip/issues/1508#issuecomment-825646108:1657,Usability,simpl,simply,1657,"ndarray(dtype=object)` arrays behaved when containing objects that all implemented `__array__`. To get around _some_ of these problems, they've introduced `__array_function__` and `__array_ufunc__`, though to me at best these are bandages. Those two concerns aren't immediately applicable in QuTiP, but they're sort of indicative of potential problems when using a `__qutip_qobj__` method implicitly in functions like `Qobj.__add__`. These are where it becomes very evident that Julia-style programming doesn't apply in the same way in Python. Python is only a single-dispatch language, so `a + b` will dispatch using the table of `a` predominantly, whereas `b + a` will dispatch on `b`. In a proper multiple-dispatch library the rules are separate to the classes, so neither class is called preferentially, there's just one rule and either library can define it. My point with this is that if `Qobj.__add__` has a case where it handles Qobj-like types, then we prevent the other library from overriding the method. Multi-methods like this simply don't work the same in Python as they do in Julia, so even if `Qobj` implements interfaces from a variety of other libraries, we'd never get good consistent behaviour with functions like this. Operations that ought to be commutative like `+` would become dependent on operand order. To some degree, implementing the interface would be a guarantee that an object would always be able to follow QuTiP's semantics, otherwise it would just be annoying to users - _sometimes_ an object would be able to be used implicitly, sometimes not. I know the ""Python way"" is supposedly ""try it and see"", but if you're doing any serious development, that quickly becomes unreasonable if a type works some times, but not others. The other part of the Python way is ""explicit is better than implicit"", and here having an explicit type conversion to me is just being explicit about which library's semantics you want to follow, which is easier to read and easier to debug.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1508#issuecomment-825646108
https://github.com/qutip/qutip/issues/1508#issuecomment-825710810:1248,Availability,error,error,1248,"fine the `__jax_array__` interface). While I think that Qobj is a very qutip-like principle, I see no problems in namespacing. > 2- having the check in __init__ . Again, I think that your observation is right. I thought about it only after I submitted the post above. The way numpy does it is that `__array__(self, dtype)` takes only one argument, but I think we can do better and better respect the API set by qutip. ; That is why I was suggesting that `object.__qutip_qobj__` should not return a Qobj directly, but rather the data needed by QuTiP to construct a Qobj, and qutip should be free to re-organize it afterwards as he likes. . > 3 - we need to take care to do this in a way that still allows QuTiP to iterate and improve Qobj.__init__ between major versions. You could for example require that `__qutip_qobj__(self, version, *kwargs)` takes in a version of the API? I believe that is what numpy does in `__array_interface__`. And it's on implementers of the interface the burden of checking the api version and throwing an error if it's not supported. Or the inverse, where implementers return whatever data they return and a version of the API they are using, and qutip can throw an error if that is an older version. The latter would make it harder to support multiple versions of qutip in the implementers, but I would not worry too much about it. You can throw an error saying that this other package is not supported and you should either nag it's developers or downgrade qutip. I'm not particularly worried about the blame: even if the error is thrown from qutip, if the message is clear enough it will be clear that the fault is in the downstream implementors of the API. -- ; About keyword handling: copy-pasting the list of kwargs of `Qobj`...; ```python; inpt : array_like = Data for vector/matrix representation of the quantum object.; dims : list = Dimensions of object used for tensor products.; shape : list = Shape of underlying data structure (matrix shape).; copy : bool ",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1508#issuecomment-825710810
https://github.com/qutip/qutip/issues/1508#issuecomment-825710810:1409,Availability,error,error,1409,"ck in __init__ . Again, I think that your observation is right. I thought about it only after I submitted the post above. The way numpy does it is that `__array__(self, dtype)` takes only one argument, but I think we can do better and better respect the API set by qutip. ; That is why I was suggesting that `object.__qutip_qobj__` should not return a Qobj directly, but rather the data needed by QuTiP to construct a Qobj, and qutip should be free to re-organize it afterwards as he likes. . > 3 - we need to take care to do this in a way that still allows QuTiP to iterate and improve Qobj.__init__ between major versions. You could for example require that `__qutip_qobj__(self, version, *kwargs)` takes in a version of the API? I believe that is what numpy does in `__array_interface__`. And it's on implementers of the interface the burden of checking the api version and throwing an error if it's not supported. Or the inverse, where implementers return whatever data they return and a version of the API they are using, and qutip can throw an error if that is an older version. The latter would make it harder to support multiple versions of qutip in the implementers, but I would not worry too much about it. You can throw an error saying that this other package is not supported and you should either nag it's developers or downgrade qutip. I'm not particularly worried about the blame: even if the error is thrown from qutip, if the message is clear enough it will be clear that the fault is in the downstream implementors of the API. -- ; About keyword handling: copy-pasting the list of kwargs of `Qobj`...; ```python; inpt : array_like = Data for vector/matrix representation of the quantum object.; dims : list = Dimensions of object used for tensor products.; shape : list = Shape of underlying data structure (matrix shape).; copy : bool = Flag specifying whether Qobj should get a copy of the input data, or use the original.; fast : bool = Flag for fast qobj creation when running od",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1508#issuecomment-825710810
https://github.com/qutip/qutip/issues/1508#issuecomment-825710810:1593,Availability,error,error,1593,"why I was suggesting that `object.__qutip_qobj__` should not return a Qobj directly, but rather the data needed by QuTiP to construct a Qobj, and qutip should be free to re-organize it afterwards as he likes. . > 3 - we need to take care to do this in a way that still allows QuTiP to iterate and improve Qobj.__init__ between major versions. You could for example require that `__qutip_qobj__(self, version, *kwargs)` takes in a version of the API? I believe that is what numpy does in `__array_interface__`. And it's on implementers of the interface the burden of checking the api version and throwing an error if it's not supported. Or the inverse, where implementers return whatever data they return and a version of the API they are using, and qutip can throw an error if that is an older version. The latter would make it harder to support multiple versions of qutip in the implementers, but I would not worry too much about it. You can throw an error saying that this other package is not supported and you should either nag it's developers or downgrade qutip. I'm not particularly worried about the blame: even if the error is thrown from qutip, if the message is clear enough it will be clear that the fault is in the downstream implementors of the API. -- ; About keyword handling: copy-pasting the list of kwargs of `Qobj`...; ```python; inpt : array_like = Data for vector/matrix representation of the quantum object.; dims : list = Dimensions of object used for tensor products.; shape : list = Shape of underlying data structure (matrix shape).; copy : bool = Flag specifying whether Qobj should get a copy of the input data, or use the original.; fast : bool = Flag for fast qobj creation when running ode solvers.; ```. For the case of the usage that netket would have, our objects already define the Hilbert space they are acting on (so `dims` and `shape`). `copy` doesn't really make sense for us, because we would be building the representation . The way I see it, `Qobj(other_pkg_o",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1508#issuecomment-825710810
https://github.com/qutip/qutip/issues/1508#issuecomment-825710810:1692,Availability,down,downgrade,1692,"why I was suggesting that `object.__qutip_qobj__` should not return a Qobj directly, but rather the data needed by QuTiP to construct a Qobj, and qutip should be free to re-organize it afterwards as he likes. . > 3 - we need to take care to do this in a way that still allows QuTiP to iterate and improve Qobj.__init__ between major versions. You could for example require that `__qutip_qobj__(self, version, *kwargs)` takes in a version of the API? I believe that is what numpy does in `__array_interface__`. And it's on implementers of the interface the burden of checking the api version and throwing an error if it's not supported. Or the inverse, where implementers return whatever data they return and a version of the API they are using, and qutip can throw an error if that is an older version. The latter would make it harder to support multiple versions of qutip in the implementers, but I would not worry too much about it. You can throw an error saying that this other package is not supported and you should either nag it's developers or downgrade qutip. I'm not particularly worried about the blame: even if the error is thrown from qutip, if the message is clear enough it will be clear that the fault is in the downstream implementors of the API. -- ; About keyword handling: copy-pasting the list of kwargs of `Qobj`...; ```python; inpt : array_like = Data for vector/matrix representation of the quantum object.; dims : list = Dimensions of object used for tensor products.; shape : list = Shape of underlying data structure (matrix shape).; copy : bool = Flag specifying whether Qobj should get a copy of the input data, or use the original.; fast : bool = Flag for fast qobj creation when running ode solvers.; ```. For the case of the usage that netket would have, our objects already define the Hilbert space they are acting on (so `dims` and `shape`). `copy` doesn't really make sense for us, because we would be building the representation . The way I see it, `Qobj(other_pkg_o",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1508#issuecomment-825710810
https://github.com/qutip/qutip/issues/1508#issuecomment-825710810:1767,Availability,error,error,1767,"ee to re-organize it afterwards as he likes. . > 3 - we need to take care to do this in a way that still allows QuTiP to iterate and improve Qobj.__init__ between major versions. You could for example require that `__qutip_qobj__(self, version, *kwargs)` takes in a version of the API? I believe that is what numpy does in `__array_interface__`. And it's on implementers of the interface the burden of checking the api version and throwing an error if it's not supported. Or the inverse, where implementers return whatever data they return and a version of the API they are using, and qutip can throw an error if that is an older version. The latter would make it harder to support multiple versions of qutip in the implementers, but I would not worry too much about it. You can throw an error saying that this other package is not supported and you should either nag it's developers or downgrade qutip. I'm not particularly worried about the blame: even if the error is thrown from qutip, if the message is clear enough it will be clear that the fault is in the downstream implementors of the API. -- ; About keyword handling: copy-pasting the list of kwargs of `Qobj`...; ```python; inpt : array_like = Data for vector/matrix representation of the quantum object.; dims : list = Dimensions of object used for tensor products.; shape : list = Shape of underlying data structure (matrix shape).; copy : bool = Flag specifying whether Qobj should get a copy of the input data, or use the original.; fast : bool = Flag for fast qobj creation when running ode solvers.; ```. For the case of the usage that netket would have, our objects already define the Hilbert space they are acting on (so `dims` and `shape`). `copy` doesn't really make sense for us, because we would be building the representation . The way I see it, `Qobj(other_pkg_obj,**kwargs)` should behave like `Qobj(qutip_obj, **kwargs)`, so `__qutip_qobj__` should return the matrix data, shape and dims if possible, and qutip will handle i",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1508#issuecomment-825710810
https://github.com/qutip/qutip/issues/1508#issuecomment-825710810:1852,Availability,fault,fault,1852,"ee to re-organize it afterwards as he likes. . > 3 - we need to take care to do this in a way that still allows QuTiP to iterate and improve Qobj.__init__ between major versions. You could for example require that `__qutip_qobj__(self, version, *kwargs)` takes in a version of the API? I believe that is what numpy does in `__array_interface__`. And it's on implementers of the interface the burden of checking the api version and throwing an error if it's not supported. Or the inverse, where implementers return whatever data they return and a version of the API they are using, and qutip can throw an error if that is an older version. The latter would make it harder to support multiple versions of qutip in the implementers, but I would not worry too much about it. You can throw an error saying that this other package is not supported and you should either nag it's developers or downgrade qutip. I'm not particularly worried about the blame: even if the error is thrown from qutip, if the message is clear enough it will be clear that the fault is in the downstream implementors of the API. -- ; About keyword handling: copy-pasting the list of kwargs of `Qobj`...; ```python; inpt : array_like = Data for vector/matrix representation of the quantum object.; dims : list = Dimensions of object used for tensor products.; shape : list = Shape of underlying data structure (matrix shape).; copy : bool = Flag specifying whether Qobj should get a copy of the input data, or use the original.; fast : bool = Flag for fast qobj creation when running ode solvers.; ```. For the case of the usage that netket would have, our objects already define the Hilbert space they are acting on (so `dims` and `shape`). `copy` doesn't really make sense for us, because we would be building the representation . The way I see it, `Qobj(other_pkg_obj,**kwargs)` should behave like `Qobj(qutip_obj, **kwargs)`, so `__qutip_qobj__` should return the matrix data, shape and dims if possible, and qutip will handle i",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1508#issuecomment-825710810
https://github.com/qutip/qutip/issues/1508#issuecomment-825710810:1868,Availability,down,downstream,1868,"ee to re-organize it afterwards as he likes. . > 3 - we need to take care to do this in a way that still allows QuTiP to iterate and improve Qobj.__init__ between major versions. You could for example require that `__qutip_qobj__(self, version, *kwargs)` takes in a version of the API? I believe that is what numpy does in `__array_interface__`. And it's on implementers of the interface the burden of checking the api version and throwing an error if it's not supported. Or the inverse, where implementers return whatever data they return and a version of the API they are using, and qutip can throw an error if that is an older version. The latter would make it harder to support multiple versions of qutip in the implementers, but I would not worry too much about it. You can throw an error saying that this other package is not supported and you should either nag it's developers or downgrade qutip. I'm not particularly worried about the blame: even if the error is thrown from qutip, if the message is clear enough it will be clear that the fault is in the downstream implementors of the API. -- ; About keyword handling: copy-pasting the list of kwargs of `Qobj`...; ```python; inpt : array_like = Data for vector/matrix representation of the quantum object.; dims : list = Dimensions of object used for tensor products.; shape : list = Shape of underlying data structure (matrix shape).; copy : bool = Flag specifying whether Qobj should get a copy of the input data, or use the original.; fast : bool = Flag for fast qobj creation when running ode solvers.; ```. For the case of the usage that netket would have, our objects already define the Hilbert space they are acting on (so `dims` and `shape`). `copy` doesn't really make sense for us, because we would be building the representation . The way I see it, `Qobj(other_pkg_obj,**kwargs)` should behave like `Qobj(qutip_obj, **kwargs)`, so `__qutip_qobj__` should return the matrix data, shape and dims if possible, and qutip will handle i",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1508#issuecomment-825710810
https://github.com/qutip/qutip/issues/1508#issuecomment-825710810:238,Integrability,interface,interface,238,"> 1 - we can't have proper namespacing, but let's at least make the magic name __qutip_qobj__ so we realistically prevent any chance of a clash. I think this is a good idea. Indeed jax uses the same trick (they define the `__jax_array__` interface). While I think that Qobj is a very qutip-like principle, I see no problems in namespacing. > 2- having the check in __init__ . Again, I think that your observation is right. I thought about it only after I submitted the post above. The way numpy does it is that `__array__(self, dtype)` takes only one argument, but I think we can do better and better respect the API set by qutip. ; That is why I was suggesting that `object.__qutip_qobj__` should not return a Qobj directly, but rather the data needed by QuTiP to construct a Qobj, and qutip should be free to re-organize it afterwards as he likes. . > 3 - we need to take care to do this in a way that still allows QuTiP to iterate and improve Qobj.__init__ between major versions. You could for example require that `__qutip_qobj__(self, version, *kwargs)` takes in a version of the API? I believe that is what numpy does in `__array_interface__`. And it's on implementers of the interface the burden of checking the api version and throwing an error if it's not supported. Or the inverse, where implementers return whatever data they return and a version of the API they are using, and qutip can throw an error if that is an older version. The latter would make it harder to support multiple versions of qutip in the implementers, but I would not worry too much about it. You can throw an error saying that this other package is not supported and you should either nag it's developers or downgrade qutip. I'm not particularly worried about the blame: even if the error is thrown from qutip, if the message is clear enough it will be clear that the fault is in the downstream implementors of the API. -- ; About keyword handling: copy-pasting the list of kwargs of `Qobj`...; ```python; inpt : arra",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1508#issuecomment-825710810
https://github.com/qutip/qutip/issues/1508#issuecomment-825710810:1183,Integrability,interface,interface,1183,"fine the `__jax_array__` interface). While I think that Qobj is a very qutip-like principle, I see no problems in namespacing. > 2- having the check in __init__ . Again, I think that your observation is right. I thought about it only after I submitted the post above. The way numpy does it is that `__array__(self, dtype)` takes only one argument, but I think we can do better and better respect the API set by qutip. ; That is why I was suggesting that `object.__qutip_qobj__` should not return a Qobj directly, but rather the data needed by QuTiP to construct a Qobj, and qutip should be free to re-organize it afterwards as he likes. . > 3 - we need to take care to do this in a way that still allows QuTiP to iterate and improve Qobj.__init__ between major versions. You could for example require that `__qutip_qobj__(self, version, *kwargs)` takes in a version of the API? I believe that is what numpy does in `__array_interface__`. And it's on implementers of the interface the burden of checking the api version and throwing an error if it's not supported. Or the inverse, where implementers return whatever data they return and a version of the API they are using, and qutip can throw an error if that is an older version. The latter would make it harder to support multiple versions of qutip in the implementers, but I would not worry too much about it. You can throw an error saying that this other package is not supported and you should either nag it's developers or downgrade qutip. I'm not particularly worried about the blame: even if the error is thrown from qutip, if the message is clear enough it will be clear that the fault is in the downstream implementors of the API. -- ; About keyword handling: copy-pasting the list of kwargs of `Qobj`...; ```python; inpt : array_like = Data for vector/matrix representation of the quantum object.; dims : list = Dimensions of object used for tensor products.; shape : list = Shape of underlying data structure (matrix shape).; copy : bool ",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1508#issuecomment-825710810
https://github.com/qutip/qutip/issues/1508#issuecomment-825710810:1802,Integrability,message,message,1802,"ee to re-organize it afterwards as he likes. . > 3 - we need to take care to do this in a way that still allows QuTiP to iterate and improve Qobj.__init__ between major versions. You could for example require that `__qutip_qobj__(self, version, *kwargs)` takes in a version of the API? I believe that is what numpy does in `__array_interface__`. And it's on implementers of the interface the burden of checking the api version and throwing an error if it's not supported. Or the inverse, where implementers return whatever data they return and a version of the API they are using, and qutip can throw an error if that is an older version. The latter would make it harder to support multiple versions of qutip in the implementers, but I would not worry too much about it. You can throw an error saying that this other package is not supported and you should either nag it's developers or downgrade qutip. I'm not particularly worried about the blame: even if the error is thrown from qutip, if the message is clear enough it will be clear that the fault is in the downstream implementors of the API. -- ; About keyword handling: copy-pasting the list of kwargs of `Qobj`...; ```python; inpt : array_like = Data for vector/matrix representation of the quantum object.; dims : list = Dimensions of object used for tensor products.; shape : list = Shape of underlying data structure (matrix shape).; copy : bool = Flag specifying whether Qobj should get a copy of the input data, or use the original.; fast : bool = Flag for fast qobj creation when running ode solvers.; ```. For the case of the usage that netket would have, our objects already define the Hilbert space they are acting on (so `dims` and `shape`). `copy` doesn't really make sense for us, because we would be building the representation . The way I see it, `Qobj(other_pkg_obj,**kwargs)` should behave like `Qobj(qutip_obj, **kwargs)`, so `__qutip_qobj__` should return the matrix data, shape and dims if possible, and qutip will handle i",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1508#issuecomment-825710810
https://github.com/qutip/qutip/issues/1508#issuecomment-825710810:1813,Usability,clear,clear,1813,"ee to re-organize it afterwards as he likes. . > 3 - we need to take care to do this in a way that still allows QuTiP to iterate and improve Qobj.__init__ between major versions. You could for example require that `__qutip_qobj__(self, version, *kwargs)` takes in a version of the API? I believe that is what numpy does in `__array_interface__`. And it's on implementers of the interface the burden of checking the api version and throwing an error if it's not supported. Or the inverse, where implementers return whatever data they return and a version of the API they are using, and qutip can throw an error if that is an older version. The latter would make it harder to support multiple versions of qutip in the implementers, but I would not worry too much about it. You can throw an error saying that this other package is not supported and you should either nag it's developers or downgrade qutip. I'm not particularly worried about the blame: even if the error is thrown from qutip, if the message is clear enough it will be clear that the fault is in the downstream implementors of the API. -- ; About keyword handling: copy-pasting the list of kwargs of `Qobj`...; ```python; inpt : array_like = Data for vector/matrix representation of the quantum object.; dims : list = Dimensions of object used for tensor products.; shape : list = Shape of underlying data structure (matrix shape).; copy : bool = Flag specifying whether Qobj should get a copy of the input data, or use the original.; fast : bool = Flag for fast qobj creation when running ode solvers.; ```. For the case of the usage that netket would have, our objects already define the Hilbert space they are acting on (so `dims` and `shape`). `copy` doesn't really make sense for us, because we would be building the representation . The way I see it, `Qobj(other_pkg_obj,**kwargs)` should behave like `Qobj(qutip_obj, **kwargs)`, so `__qutip_qobj__` should return the matrix data, shape and dims if possible, and qutip will handle i",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1508#issuecomment-825710810
https://github.com/qutip/qutip/issues/1508#issuecomment-825710810:1837,Usability,clear,clear,1837,"ee to re-organize it afterwards as he likes. . > 3 - we need to take care to do this in a way that still allows QuTiP to iterate and improve Qobj.__init__ between major versions. You could for example require that `__qutip_qobj__(self, version, *kwargs)` takes in a version of the API? I believe that is what numpy does in `__array_interface__`. And it's on implementers of the interface the burden of checking the api version and throwing an error if it's not supported. Or the inverse, where implementers return whatever data they return and a version of the API they are using, and qutip can throw an error if that is an older version. The latter would make it harder to support multiple versions of qutip in the implementers, but I would not worry too much about it. You can throw an error saying that this other package is not supported and you should either nag it's developers or downgrade qutip. I'm not particularly worried about the blame: even if the error is thrown from qutip, if the message is clear enough it will be clear that the fault is in the downstream implementors of the API. -- ; About keyword handling: copy-pasting the list of kwargs of `Qobj`...; ```python; inpt : array_like = Data for vector/matrix representation of the quantum object.; dims : list = Dimensions of object used for tensor products.; shape : list = Shape of underlying data structure (matrix shape).; copy : bool = Flag specifying whether Qobj should get a copy of the input data, or use the original.; fast : bool = Flag for fast qobj creation when running ode solvers.; ```. For the case of the usage that netket would have, our objects already define the Hilbert space they are acting on (so `dims` and `shape`). `copy` doesn't really make sense for us, because we would be building the representation . The way I see it, `Qobj(other_pkg_obj,**kwargs)` should behave like `Qobj(qutip_obj, **kwargs)`, so `__qutip_qobj__` should return the matrix data, shape and dims if possible, and qutip will handle i",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1508#issuecomment-825710810
https://github.com/qutip/qutip/issues/1508#issuecomment-825714680:230,Integrability,interface,interface,230,"About your future 'dispatch like' system:; I personally like dispatch because it makes everything more easily extensible (and/or hackable) if package authors agree on a common denominator and they are careful to rely only on that interface and on nothing else. As all our operators are lazy, we already implement lazy operator*dense and operator*sparse multiplication. ; It might be interesting for us, in the future, to define dispatch rules for our operators, so that we don't even need to convert them to Qobj. But for now I'd focus on having an easy and extensible way to convert our objects to qutip format. . (Ideally, it would be nice if we could give qutip solvers our operators, which are not Qobj, provided they define the right dispatch rules, but I imagine that this would be complex and require significant effort on your part).",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1508#issuecomment-825714680
https://github.com/qutip/qutip/issues/1508#issuecomment-827902600:48,Integrability,depend,dependent,48,"Hi Fillipo,. Are any of netket's operators time-dependent? I.e. is there a need to; support something similar for QobjEvo?. Yours sincerely,; Simon Cross",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1508#issuecomment-827902600
https://github.com/qutip/qutip/issues/1508#issuecomment-828576313:34,Integrability,depend,dependent,34,"Hi Simon,. No we do not have time-dependent operators at the moment and focus on ground state/steady-state/dynamics of fixed hamiltonians or liouvillians. Actually nobody has (yet) studied with neural networks time-dependent systems as far as i know. However, our foundations do not prevent us to work with time-dependent objects. ; We simply will need to write the relevant class.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1508#issuecomment-828576313
https://github.com/qutip/qutip/issues/1508#issuecomment-828576313:215,Integrability,depend,dependent,215,"Hi Simon,. No we do not have time-dependent operators at the moment and focus on ground state/steady-state/dynamics of fixed hamiltonians or liouvillians. Actually nobody has (yet) studied with neural networks time-dependent systems as far as i know. However, our foundations do not prevent us to work with time-dependent objects. ; We simply will need to write the relevant class.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1508#issuecomment-828576313
https://github.com/qutip/qutip/issues/1508#issuecomment-828576313:312,Integrability,depend,dependent,312,"Hi Simon,. No we do not have time-dependent operators at the moment and focus on ground state/steady-state/dynamics of fixed hamiltonians or liouvillians. Actually nobody has (yet) studied with neural networks time-dependent systems as far as i know. However, our foundations do not prevent us to work with time-dependent objects. ; We simply will need to write the relevant class.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1508#issuecomment-828576313
https://github.com/qutip/qutip/issues/1508#issuecomment-828576313:336,Usability,simpl,simply,336,"Hi Simon,. No we do not have time-dependent operators at the moment and focus on ground state/steady-state/dynamics of fixed hamiltonians or liouvillians. Actually nobody has (yet) studied with neural networks time-dependent systems as far as i know. However, our foundations do not prevent us to work with time-dependent objects. ; We simply will need to write the relevant class.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1508#issuecomment-828576313
https://github.com/qutip/qutip/issues/1508#issuecomment-828711218:148,Integrability,depend,dependent,148,"Hi Filippo,. On Wed, Apr 28, 2021 at 6:03 PM Filippo Vicentini ***@***.***>; wrote:. > However, our foundations do not prevent us to work with time-dependent; > objects.; >; > We simply will need to write the relevant class.; >; Perhaps slightly off-topic: How similar will this class look to QobjEvo? Or; do you not know yet?",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1508#issuecomment-828711218
https://github.com/qutip/qutip/issues/1508#issuecomment-828711218:179,Usability,simpl,simply,179,"Hi Filippo,. On Wed, Apr 28, 2021 at 6:03 PM Filippo Vicentini ***@***.***>; wrote:. > However, our foundations do not prevent us to work with time-dependent; > objects.; >; > We simply will need to write the relevant class.; >; Perhaps slightly off-topic: How similar will this class look to QobjEvo? Or; do you not know yet?",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1508#issuecomment-828711218
https://github.com/qutip/qutip/issues/1508#issuecomment-828730210:151,Integrability,depend,dependent,151,"It's really too early to know, and I know little of the structure of QobjEvo.; From the little i know you keep a sum of standard operators with a time dependent prefactor, right?. We will probably go for something similar. Since we are storing the single operators in an hamiltonian (like \sigma_x*\sigma_y) and their domains, we can easily insert a time dependence in front of every operator for a negligible cost.; However this representation is very different from the dense/sparse representation in QuTiP, as we need to support hilbert spaces with order of 100s spins and have a very different usage of the matrix elements during the computations.; ; But again, this is very premature... I doubt we'll get to time-dependent objects before an year or so. ; Higher on our priority is representing circuits.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1508#issuecomment-828730210
https://github.com/qutip/qutip/issues/1508#issuecomment-828730210:355,Integrability,depend,dependence,355,"It's really too early to know, and I know little of the structure of QobjEvo.; From the little i know you keep a sum of standard operators with a time dependent prefactor, right?. We will probably go for something similar. Since we are storing the single operators in an hamiltonian (like \sigma_x*\sigma_y) and their domains, we can easily insert a time dependence in front of every operator for a negligible cost.; However this representation is very different from the dense/sparse representation in QuTiP, as we need to support hilbert spaces with order of 100s spins and have a very different usage of the matrix elements during the computations.; ; But again, this is very premature... I doubt we'll get to time-dependent objects before an year or so. ; Higher on our priority is representing circuits.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1508#issuecomment-828730210
https://github.com/qutip/qutip/issues/1508#issuecomment-828730210:718,Integrability,depend,dependent,718,"It's really too early to know, and I know little of the structure of QobjEvo.; From the little i know you keep a sum of standard operators with a time dependent prefactor, right?. We will probably go for something similar. Since we are storing the single operators in an hamiltonian (like \sigma_x*\sigma_y) and their domains, we can easily insert a time dependence in front of every operator for a negligible cost.; However this representation is very different from the dense/sparse representation in QuTiP, as we need to support hilbert spaces with order of 100s spins and have a very different usage of the matrix elements during the computations.; ; But again, this is very premature... I doubt we'll get to time-dependent objects before an year or so. ; Higher on our priority is representing circuits.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1508#issuecomment-828730210
https://github.com/qutip/qutip/issues/1508#issuecomment-829966601:498,Availability,down,downstream,498,"I had a quick stab at this by adding a Metaclass to Qobj (I tried doing this within `__new__` but could not get it to work. If it's possible I accept suggestions). ; I am also unsure if your constructor `Qobj` is supposed to be called with positional, kwargs or a combination of both. If it was only kwargs the implementation could be more terse. I assumed that the `copy` argument gets passed as part of `__qutip_qobj_interface__`, as in the conversion it might be necessary to copy anyway so the downstream implementor is responsible for taking care of the copy if requested. ```python; class QobjMetaclass(type):; def __call__(cls, inpt=None, dims=None, shape=None,; type=None, isherm=None, copy=True,; fast=False, superrep=None, isunitary=None):. if isinstance(inpt, Qobj):; pass; elif hasattr(inpt, ""__qutip_qobj_interface__""):; inpt_data = inpt.__qutip_qobj_interface__(copy=copy). inpt = inpt_data['matrix']; dims = inpt_data['dims']; copy = False. obj = cls.__new__(cls, inpt, dims, shape, type, isherm, copy, fast,; superrep, isunitary); obj.__init__(inpt, dims, shape, type, isherm, copy, fast,; superrep, isunitary); return obj. class Qobj(object, metaclass=QobjMetaclass):; ...; ```; I'm quite sure this implementation can be improved, however. On the NetKet side, the implementation is very simple. At the moment we only support operators from H->H.; ```python; class AbstractOperator:; ... ; def __qutip_qobj_interface__(self, dims, copy=True):; return {'matrix': stacked_rows_to_stacked_cols(self.hilbert, self.to_sparse()),; 'dims': [list(self.hilbert.shape), list(self.hilbert.shape)]}; ```. This already is quite nice and allows for quick and simple interoperability. Some comments/questions:; - Qutip uses stacked columns (column major) ordering for the tensor products, as opposed to NumPy `kron` ordering that is stacked rows, right? ; - To signal that an object is a super-operator (Liouvillian) is it sufficient to pass a correctly constructed `dims` or I should also provide `s",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1508#issuecomment-829966601
https://github.com/qutip/qutip/issues/1508#issuecomment-829966601:1668,Integrability,interoperab,interoperability,1668," of `__qutip_qobj_interface__`, as in the conversion it might be necessary to copy anyway so the downstream implementor is responsible for taking care of the copy if requested. ```python; class QobjMetaclass(type):; def __call__(cls, inpt=None, dims=None, shape=None,; type=None, isherm=None, copy=True,; fast=False, superrep=None, isunitary=None):. if isinstance(inpt, Qobj):; pass; elif hasattr(inpt, ""__qutip_qobj_interface__""):; inpt_data = inpt.__qutip_qobj_interface__(copy=copy). inpt = inpt_data['matrix']; dims = inpt_data['dims']; copy = False. obj = cls.__new__(cls, inpt, dims, shape, type, isherm, copy, fast,; superrep, isunitary); obj.__init__(inpt, dims, shape, type, isherm, copy, fast,; superrep, isunitary); return obj. class Qobj(object, metaclass=QobjMetaclass):; ...; ```; I'm quite sure this implementation can be improved, however. On the NetKet side, the implementation is very simple. At the moment we only support operators from H->H.; ```python; class AbstractOperator:; ... ; def __qutip_qobj_interface__(self, dims, copy=True):; return {'matrix': stacked_rows_to_stacked_cols(self.hilbert, self.to_sparse()),; 'dims': [list(self.hilbert.shape), list(self.hilbert.shape)]}; ```. This already is quite nice and allows for quick and simple interoperability. Some comments/questions:; - Qutip uses stacked columns (column major) ordering for the tensor products, as opposed to NumPy `kron` ordering that is stacked rows, right? ; - To signal that an object is a super-operator (Liouvillian) is it sufficient to pass a correctly constructed `dims` or I should also provide `superrep`?; - Is there a reason you don't accept tuples as inputs to `basis(dims, x)` and other similar functions, but only lists? ; - I played around with auto-converting input hamiltonians and jump operators in `qutip.sesolve` and `mesolve` to `Qobj` if they are not Qobj but support the interface. That is even nicer because we would get to use all of qutip solvers out of the box with our objects.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1508#issuecomment-829966601
https://github.com/qutip/qutip/issues/1508#issuecomment-829966601:2290,Integrability,interface,interface,2290," of `__qutip_qobj_interface__`, as in the conversion it might be necessary to copy anyway so the downstream implementor is responsible for taking care of the copy if requested. ```python; class QobjMetaclass(type):; def __call__(cls, inpt=None, dims=None, shape=None,; type=None, isherm=None, copy=True,; fast=False, superrep=None, isunitary=None):. if isinstance(inpt, Qobj):; pass; elif hasattr(inpt, ""__qutip_qobj_interface__""):; inpt_data = inpt.__qutip_qobj_interface__(copy=copy). inpt = inpt_data['matrix']; dims = inpt_data['dims']; copy = False. obj = cls.__new__(cls, inpt, dims, shape, type, isherm, copy, fast,; superrep, isunitary); obj.__init__(inpt, dims, shape, type, isherm, copy, fast,; superrep, isunitary); return obj. class Qobj(object, metaclass=QobjMetaclass):; ...; ```; I'm quite sure this implementation can be improved, however. On the NetKet side, the implementation is very simple. At the moment we only support operators from H->H.; ```python; class AbstractOperator:; ... ; def __qutip_qobj_interface__(self, dims, copy=True):; return {'matrix': stacked_rows_to_stacked_cols(self.hilbert, self.to_sparse()),; 'dims': [list(self.hilbert.shape), list(self.hilbert.shape)]}; ```. This already is quite nice and allows for quick and simple interoperability. Some comments/questions:; - Qutip uses stacked columns (column major) ordering for the tensor products, as opposed to NumPy `kron` ordering that is stacked rows, right? ; - To signal that an object is a super-operator (Liouvillian) is it sufficient to pass a correctly constructed `dims` or I should also provide `superrep`?; - Is there a reason you don't accept tuples as inputs to `basis(dims, x)` and other similar functions, but only lists? ; - I played around with auto-converting input hamiltonians and jump operators in `qutip.sesolve` and `mesolve` to `Qobj` if they are not Qobj but support the interface. That is even nicer because we would get to use all of qutip solvers out of the box with our objects.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1508#issuecomment-829966601
https://github.com/qutip/qutip/issues/1508#issuecomment-829966601:1304,Usability,simpl,simple,1304,". If it was only kwargs the implementation could be more terse. I assumed that the `copy` argument gets passed as part of `__qutip_qobj_interface__`, as in the conversion it might be necessary to copy anyway so the downstream implementor is responsible for taking care of the copy if requested. ```python; class QobjMetaclass(type):; def __call__(cls, inpt=None, dims=None, shape=None,; type=None, isherm=None, copy=True,; fast=False, superrep=None, isunitary=None):. if isinstance(inpt, Qobj):; pass; elif hasattr(inpt, ""__qutip_qobj_interface__""):; inpt_data = inpt.__qutip_qobj_interface__(copy=copy). inpt = inpt_data['matrix']; dims = inpt_data['dims']; copy = False. obj = cls.__new__(cls, inpt, dims, shape, type, isherm, copy, fast,; superrep, isunitary); obj.__init__(inpt, dims, shape, type, isherm, copy, fast,; superrep, isunitary); return obj. class Qobj(object, metaclass=QobjMetaclass):; ...; ```; I'm quite sure this implementation can be improved, however. On the NetKet side, the implementation is very simple. At the moment we only support operators from H->H.; ```python; class AbstractOperator:; ... ; def __qutip_qobj_interface__(self, dims, copy=True):; return {'matrix': stacked_rows_to_stacked_cols(self.hilbert, self.to_sparse()),; 'dims': [list(self.hilbert.shape), list(self.hilbert.shape)]}; ```. This already is quite nice and allows for quick and simple interoperability. Some comments/questions:; - Qutip uses stacked columns (column major) ordering for the tensor products, as opposed to NumPy `kron` ordering that is stacked rows, right? ; - To signal that an object is a super-operator (Liouvillian) is it sufficient to pass a correctly constructed `dims` or I should also provide `superrep`?; - Is there a reason you don't accept tuples as inputs to `basis(dims, x)` and other similar functions, but only lists? ; - I played around with auto-converting input hamiltonians and jump operators in `qutip.sesolve` and `mesolve` to `Qobj` if they are not Qobj but suppor",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1508#issuecomment-829966601
https://github.com/qutip/qutip/issues/1508#issuecomment-829966601:1661,Usability,simpl,simple,1661," of `__qutip_qobj_interface__`, as in the conversion it might be necessary to copy anyway so the downstream implementor is responsible for taking care of the copy if requested. ```python; class QobjMetaclass(type):; def __call__(cls, inpt=None, dims=None, shape=None,; type=None, isherm=None, copy=True,; fast=False, superrep=None, isunitary=None):. if isinstance(inpt, Qobj):; pass; elif hasattr(inpt, ""__qutip_qobj_interface__""):; inpt_data = inpt.__qutip_qobj_interface__(copy=copy). inpt = inpt_data['matrix']; dims = inpt_data['dims']; copy = False. obj = cls.__new__(cls, inpt, dims, shape, type, isherm, copy, fast,; superrep, isunitary); obj.__init__(inpt, dims, shape, type, isherm, copy, fast,; superrep, isunitary); return obj. class Qobj(object, metaclass=QobjMetaclass):; ...; ```; I'm quite sure this implementation can be improved, however. On the NetKet side, the implementation is very simple. At the moment we only support operators from H->H.; ```python; class AbstractOperator:; ... ; def __qutip_qobj_interface__(self, dims, copy=True):; return {'matrix': stacked_rows_to_stacked_cols(self.hilbert, self.to_sparse()),; 'dims': [list(self.hilbert.shape), list(self.hilbert.shape)]}; ```. This already is quite nice and allows for quick and simple interoperability. Some comments/questions:; - Qutip uses stacked columns (column major) ordering for the tensor products, as opposed to NumPy `kron` ordering that is stacked rows, right? ; - To signal that an object is a super-operator (Liouvillian) is it sufficient to pass a correctly constructed `dims` or I should also provide `superrep`?; - Is there a reason you don't accept tuples as inputs to `basis(dims, x)` and other similar functions, but only lists? ; - I played around with auto-converting input hamiltonians and jump operators in `qutip.sesolve` and `mesolve` to `Qobj` if they are not Qobj but support the interface. That is even nicer because we would get to use all of qutip solvers out of the box with our objects.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1508#issuecomment-829966601
https://github.com/qutip/qutip/issues/1508#issuecomment-830003691:3706,Availability,error,error,3706,"lose-minded to alternate views here, but given the problems Numpy had (whose team I have no doubt are much smarter than I am), I'm really not enthusiastic about any implicit conversions. I really do appreciate the interest, and I _am_ keen to let us have better compatibility with the rest of the community, but there are a lot of design concerns that we're going to want to work on our side first - I just want to caution you in case you're trying to work towards a PR, because I'm not close to being happy to accept one, yet. If we're going to do this (and we haven't decided if we will yet), we're going to need to get a lot of wide-ranging input from many different libraries, and we'll want to write out a proper design document and get approval of it before we get deep into the implementation. > The latter would make it harder to support multiple versions of qutip in the implementers, but I would not worry too much about it. You can throw an error saying that this other package is not supported and you should either nag it's developers or downgrade qutip.; >; > I'm not particularly worried about the blame: even if the error is thrown from qutip, if the message is clear enough it will be clear that the fault is in the downstream implementors of the API. I'm concerned from a user's perspective. QuTiP has a wide user base, and we're beyond the stage where ""iterate fast and break things"" is ok for us (though of course it's fine and even good for pre-stable libraries, to avoid getting weighed down). We've got to be concerned with backwards and forwards compatibility; what if a user wants to install and use QuTiP and a different library in the same environment _without_ using them together, but can't even have them coexist because of version incompatibilities in optional conversion features? That's frustrating for users, even though it's not really anybody's fault. Bugging developers is fine when people want to use packages that are still maintained, but I'm sure we've all com",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1508#issuecomment-830003691
https://github.com/qutip/qutip/issues/1508#issuecomment-830003691:3805,Availability,down,downgrade,3805,"lose-minded to alternate views here, but given the problems Numpy had (whose team I have no doubt are much smarter than I am), I'm really not enthusiastic about any implicit conversions. I really do appreciate the interest, and I _am_ keen to let us have better compatibility with the rest of the community, but there are a lot of design concerns that we're going to want to work on our side first - I just want to caution you in case you're trying to work towards a PR, because I'm not close to being happy to accept one, yet. If we're going to do this (and we haven't decided if we will yet), we're going to need to get a lot of wide-ranging input from many different libraries, and we'll want to write out a proper design document and get approval of it before we get deep into the implementation. > The latter would make it harder to support multiple versions of qutip in the implementers, but I would not worry too much about it. You can throw an error saying that this other package is not supported and you should either nag it's developers or downgrade qutip.; >; > I'm not particularly worried about the blame: even if the error is thrown from qutip, if the message is clear enough it will be clear that the fault is in the downstream implementors of the API. I'm concerned from a user's perspective. QuTiP has a wide user base, and we're beyond the stage where ""iterate fast and break things"" is ok for us (though of course it's fine and even good for pre-stable libraries, to avoid getting weighed down). We've got to be concerned with backwards and forwards compatibility; what if a user wants to install and use QuTiP and a different library in the same environment _without_ using them together, but can't even have them coexist because of version incompatibilities in optional conversion features? That's frustrating for users, even though it's not really anybody's fault. Bugging developers is fine when people want to use packages that are still maintained, but I'm sure we've all com",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1508#issuecomment-830003691
https://github.com/qutip/qutip/issues/1508#issuecomment-830003691:3886,Availability,error,error,3886,"plicit conversions. I really do appreciate the interest, and I _am_ keen to let us have better compatibility with the rest of the community, but there are a lot of design concerns that we're going to want to work on our side first - I just want to caution you in case you're trying to work towards a PR, because I'm not close to being happy to accept one, yet. If we're going to do this (and we haven't decided if we will yet), we're going to need to get a lot of wide-ranging input from many different libraries, and we'll want to write out a proper design document and get approval of it before we get deep into the implementation. > The latter would make it harder to support multiple versions of qutip in the implementers, but I would not worry too much about it. You can throw an error saying that this other package is not supported and you should either nag it's developers or downgrade qutip.; >; > I'm not particularly worried about the blame: even if the error is thrown from qutip, if the message is clear enough it will be clear that the fault is in the downstream implementors of the API. I'm concerned from a user's perspective. QuTiP has a wide user base, and we're beyond the stage where ""iterate fast and break things"" is ok for us (though of course it's fine and even good for pre-stable libraries, to avoid getting weighed down). We've got to be concerned with backwards and forwards compatibility; what if a user wants to install and use QuTiP and a different library in the same environment _without_ using them together, but can't even have them coexist because of version incompatibilities in optional conversion features? That's frustrating for users, even though it's not really anybody's fault. Bugging developers is fine when people want to use packages that are still maintained, but I'm sure we've all come up against times in research when you get to trying out a package to do one specific thing that's been abandoned for a while. Again, this certainly isn't an unsolvab",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1508#issuecomment-830003691
https://github.com/qutip/qutip/issues/1508#issuecomment-830003691:3971,Availability,fault,fault,3971,"plicit conversions. I really do appreciate the interest, and I _am_ keen to let us have better compatibility with the rest of the community, but there are a lot of design concerns that we're going to want to work on our side first - I just want to caution you in case you're trying to work towards a PR, because I'm not close to being happy to accept one, yet. If we're going to do this (and we haven't decided if we will yet), we're going to need to get a lot of wide-ranging input from many different libraries, and we'll want to write out a proper design document and get approval of it before we get deep into the implementation. > The latter would make it harder to support multiple versions of qutip in the implementers, but I would not worry too much about it. You can throw an error saying that this other package is not supported and you should either nag it's developers or downgrade qutip.; >; > I'm not particularly worried about the blame: even if the error is thrown from qutip, if the message is clear enough it will be clear that the fault is in the downstream implementors of the API. I'm concerned from a user's perspective. QuTiP has a wide user base, and we're beyond the stage where ""iterate fast and break things"" is ok for us (though of course it's fine and even good for pre-stable libraries, to avoid getting weighed down). We've got to be concerned with backwards and forwards compatibility; what if a user wants to install and use QuTiP and a different library in the same environment _without_ using them together, but can't even have them coexist because of version incompatibilities in optional conversion features? That's frustrating for users, even though it's not really anybody's fault. Bugging developers is fine when people want to use packages that are still maintained, but I'm sure we've all come up against times in research when you get to trying out a package to do one specific thing that's been abandoned for a while. Again, this certainly isn't an unsolvab",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1508#issuecomment-830003691
https://github.com/qutip/qutip/issues/1508#issuecomment-830003691:3987,Availability,down,downstream,3987,"plicit conversions. I really do appreciate the interest, and I _am_ keen to let us have better compatibility with the rest of the community, but there are a lot of design concerns that we're going to want to work on our side first - I just want to caution you in case you're trying to work towards a PR, because I'm not close to being happy to accept one, yet. If we're going to do this (and we haven't decided if we will yet), we're going to need to get a lot of wide-ranging input from many different libraries, and we'll want to write out a proper design document and get approval of it before we get deep into the implementation. > The latter would make it harder to support multiple versions of qutip in the implementers, but I would not worry too much about it. You can throw an error saying that this other package is not supported and you should either nag it's developers or downgrade qutip.; >; > I'm not particularly worried about the blame: even if the error is thrown from qutip, if the message is clear enough it will be clear that the fault is in the downstream implementors of the API. I'm concerned from a user's perspective. QuTiP has a wide user base, and we're beyond the stage where ""iterate fast and break things"" is ok for us (though of course it's fine and even good for pre-stable libraries, to avoid getting weighed down). We've got to be concerned with backwards and forwards compatibility; what if a user wants to install and use QuTiP and a different library in the same environment _without_ using them together, but can't even have them coexist because of version incompatibilities in optional conversion features? That's frustrating for users, even though it's not really anybody's fault. Bugging developers is fine when people want to use packages that are still maintained, but I'm sure we've all come up against times in research when you get to trying out a package to do one specific thing that's been abandoned for a while. Again, this certainly isn't an unsolvab",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1508#issuecomment-830003691
https://github.com/qutip/qutip/issues/1508#issuecomment-830003691:4263,Availability,down,down,4263,"to caution you in case you're trying to work towards a PR, because I'm not close to being happy to accept one, yet. If we're going to do this (and we haven't decided if we will yet), we're going to need to get a lot of wide-ranging input from many different libraries, and we'll want to write out a proper design document and get approval of it before we get deep into the implementation. > The latter would make it harder to support multiple versions of qutip in the implementers, but I would not worry too much about it. You can throw an error saying that this other package is not supported and you should either nag it's developers or downgrade qutip.; >; > I'm not particularly worried about the blame: even if the error is thrown from qutip, if the message is clear enough it will be clear that the fault is in the downstream implementors of the API. I'm concerned from a user's perspective. QuTiP has a wide user base, and we're beyond the stage where ""iterate fast and break things"" is ok for us (though of course it's fine and even good for pre-stable libraries, to avoid getting weighed down). We've got to be concerned with backwards and forwards compatibility; what if a user wants to install and use QuTiP and a different library in the same environment _without_ using them together, but can't even have them coexist because of version incompatibilities in optional conversion features? That's frustrating for users, even though it's not really anybody's fault. Bugging developers is fine when people want to use packages that are still maintained, but I'm sure we've all come up against times in research when you get to trying out a package to do one specific thing that's been abandoned for a while. Again, this certainly isn't an unsolvable problem: having versioning in the interface API is one solution to some of these problems. ---. For greater discussion, here's an alternate approach: instead of objects defining `__qutip_qobj__`, instead we expose an entry-point `qutip.Qobj.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1508#issuecomment-830003691
https://github.com/qutip/qutip/issues/1508#issuecomment-830003691:4635,Availability,fault,fault,4635,"ite out a proper design document and get approval of it before we get deep into the implementation. > The latter would make it harder to support multiple versions of qutip in the implementers, but I would not worry too much about it. You can throw an error saying that this other package is not supported and you should either nag it's developers or downgrade qutip.; >; > I'm not particularly worried about the blame: even if the error is thrown from qutip, if the message is clear enough it will be clear that the fault is in the downstream implementors of the API. I'm concerned from a user's perspective. QuTiP has a wide user base, and we're beyond the stage where ""iterate fast and break things"" is ok for us (though of course it's fine and even good for pre-stable libraries, to avoid getting weighed down). We've got to be concerned with backwards and forwards compatibility; what if a user wants to install and use QuTiP and a different library in the same environment _without_ using them together, but can't even have them coexist because of version incompatibilities in optional conversion features? That's frustrating for users, even though it's not really anybody's fault. Bugging developers is fine when people want to use packages that are still maintained, but I'm sure we've all come up against times in research when you get to trying out a package to do one specific thing that's been abandoned for a while. Again, this certainly isn't an unsolvable problem: having versioning in the interface API is one solution to some of these problems. ---. For greater discussion, here's an alternate approach: instead of objects defining `__qutip_qobj__`, instead we expose an entry-point `qutip.Qobj.register_conversion_function(converter, type, priority, version=None)`, and downstream libraries register functions rather than defining methods on their classes. The logic inside the `Qobj` constructor remains approximately the same as what you suggest. I think TensorFlow does something ",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1508#issuecomment-830003691
https://github.com/qutip/qutip/issues/1508#issuecomment-830003691:5242,Availability,down,downstream,5242,"getting weighed down). We've got to be concerned with backwards and forwards compatibility; what if a user wants to install and use QuTiP and a different library in the same environment _without_ using them together, but can't even have them coexist because of version incompatibilities in optional conversion features? That's frustrating for users, even though it's not really anybody's fault. Bugging developers is fine when people want to use packages that are still maintained, but I'm sure we've all come up against times in research when you get to trying out a package to do one specific thing that's been abandoned for a while. Again, this certainly isn't an unsolvable problem: having versioning in the interface API is one solution to some of these problems. ---. For greater discussion, here's an alternate approach: instead of objects defining `__qutip_qobj__`, instead we expose an entry-point `qutip.Qobj.register_conversion_function(converter, type, priority, version=None)`, and downstream libraries register functions rather than defining methods on their classes. The logic inside the `Qobj` constructor remains approximately the same as what you suggest. I think TensorFlow does something a little more similar to this? (I'm not very familiar with it at all.). Advantages of this over a `__qutip_qobj__` magic method:; - Users aren't limited to what libraries define for them, but can add their own conversions or override library ones if they don't like them. I actually see this as being closer to Julia's dispatch, or Rust's `impl for`.; - It doesn't involve weird namespacing, or anything like that, and doesn't require downstream classes to carry around additional slots. It's less an issue for classes that define `__slots__` since those are frozen methods, but extra methods adds a minor amount vtable weight for most libraries, and makes their class definitions more complex.; - Control between different versions is perhaps a little easier (though a minor point): this _fe",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1508#issuecomment-830003691
https://github.com/qutip/qutip/issues/1508#issuecomment-830003691:5890,Availability,down,downstream,5890," a while. Again, this certainly isn't an unsolvable problem: having versioning in the interface API is one solution to some of these problems. ---. For greater discussion, here's an alternate approach: instead of objects defining `__qutip_qobj__`, instead we expose an entry-point `qutip.Qobj.register_conversion_function(converter, type, priority, version=None)`, and downstream libraries register functions rather than defining methods on their classes. The logic inside the `Qobj` constructor remains approximately the same as what you suggest. I think TensorFlow does something a little more similar to this? (I'm not very familiar with it at all.). Advantages of this over a `__qutip_qobj__` magic method:; - Users aren't limited to what libraries define for them, but can add their own conversions or override library ones if they don't like them. I actually see this as being closer to Julia's dispatch, or Rust's `impl for`.; - It doesn't involve weird namespacing, or anything like that, and doesn't require downstream classes to carry around additional slots. It's less an issue for classes that define `__slots__` since those are frozen methods, but extra methods adds a minor amount vtable weight for most libraries, and makes their class definitions more complex.; - Control between different versions is perhaps a little easier (though a minor point): this _feels_ easier to separate out different versions, and detect what to register as the conversion function with QuTiP. This is a particular advantage for Python classes compiled as C-extensions (like from C or Cython), which typically don't allow assigning methods dynamically.; - A library could even register multiple versions of the conversion function with us, and let QuTiP handle API versioning centrally, rather than requiring downstream libraries to roll their own checks.; - We're basically already set up to do this in `dev.major` already. We'd have to modify our procedures a little bit (we're mostly concerned with cons",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1508#issuecomment-830003691
https://github.com/qutip/qutip/issues/1508#issuecomment-830003691:6677,Availability,down,downstream,6677,"ries define for them, but can add their own conversions or override library ones if they don't like them. I actually see this as being closer to Julia's dispatch, or Rust's `impl for`.; - It doesn't involve weird namespacing, or anything like that, and doesn't require downstream classes to carry around additional slots. It's less an issue for classes that define `__slots__` since those are frozen methods, but extra methods adds a minor amount vtable weight for most libraries, and makes their class definitions more complex.; - Control between different versions is perhaps a little easier (though a minor point): this _feels_ easier to separate out different versions, and detect what to register as the conversion function with QuTiP. This is a particular advantage for Python classes compiled as C-extensions (like from C or Cython), which typically don't allow assigning methods dynamically.; - A library could even register multiple versions of the conversion function with us, and let QuTiP handle API versioning centrally, rather than requiring downstream libraries to roll their own checks.; - We're basically already set up to do this in `dev.major` already. We'd have to modify our procedures a little bit (we're mostly concerned with constructing the underlying matrices at the moment), but it's a smaller change in behaviour. Disadvantages that I can think of:; - It's got linear scaling with the number of conversions registered, so it's in theory possible to register ""too many"" and cause a slow down. In reality, this will be a very small effect (`Qobj` construction time will be dominated by copying data into new formats), and I think the benefits of a priority queue of allowed converters outweighs it in convenience for users.; - It involves some global state of the `qutip` library, which _may_ cause problems for multiprocessing if somebody tries to register a `lambda` converter (can't pass through `pickle`, though I'm not 100% on whether module-level stuff needs to), and o",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1508#issuecomment-830003691
https://github.com/qutip/qutip/issues/1508#issuecomment-830003691:7135,Availability,down,down,7135,"s a minor amount vtable weight for most libraries, and makes their class definitions more complex.; - Control between different versions is perhaps a little easier (though a minor point): this _feels_ easier to separate out different versions, and detect what to register as the conversion function with QuTiP. This is a particular advantage for Python classes compiled as C-extensions (like from C or Cython), which typically don't allow assigning methods dynamically.; - A library could even register multiple versions of the conversion function with us, and let QuTiP handle API versioning centrally, rather than requiring downstream libraries to roll their own checks.; - We're basically already set up to do this in `dev.major` already. We'd have to modify our procedures a little bit (we're mostly concerned with constructing the underlying matrices at the moment), but it's a smaller change in behaviour. Disadvantages that I can think of:; - It's got linear scaling with the number of conversions registered, so it's in theory possible to register ""too many"" and cause a slow down. In reality, this will be a very small effect (`Qobj` construction time will be dominated by copying data into new formats), and I think the benefits of a priority queue of allowed converters outweighs it in convenience for users.; - It involves some global state of the `qutip` library, which _may_ cause problems for multiprocessing if somebody tries to register a `lambda` converter (can't pass through `pickle`, though I'm not 100% on whether module-level stuff needs to), and of course there's the query of what happens when converters are registered in separate processes. We already have this ""problem"" in 5.0 though, because that's how the entire underlying dispatch mechanism is handled; we can just require that converters must be pickle-able.; - If a downstream package wants to lazily `import qutip` (we're a pretty heavy import right now), it's harder in this method; you'd basically have to ask a ",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1508#issuecomment-830003691
https://github.com/qutip/qutip/issues/1508#issuecomment-830003691:7902,Availability,down,downstream,7902,"lready. We'd have to modify our procedures a little bit (we're mostly concerned with constructing the underlying matrices at the moment), but it's a smaller change in behaviour. Disadvantages that I can think of:; - It's got linear scaling with the number of conversions registered, so it's in theory possible to register ""too many"" and cause a slow down. In reality, this will be a very small effect (`Qobj` construction time will be dominated by copying data into new formats), and I think the benefits of a priority queue of allowed converters outweighs it in convenience for users.; - It involves some global state of the `qutip` library, which _may_ cause problems for multiprocessing if somebody tries to register a `lambda` converter (can't pass through `pickle`, though I'm not 100% on whether module-level stuff needs to), and of course there's the query of what happens when converters are registered in separate processes. We already have this ""problem"" in 5.0 though, because that's how the entire underlying dispatch mechanism is handled; we can just require that converters must be pickle-able.; - If a downstream package wants to lazily `import qutip` (we're a pretty heavy import right now), it's harder in this method; you'd basically have to ask a user to call `otherlibrary.register_qutip()`. For one, I'm going to put some effort into making `import qutip` take much less time for 5.0 (the main problem right now is we essentially eagerly import all of scipy and IPython if it's around), so that'll make it a bit easier. For two, a single initialisation statement isn't _necessarily_ a terrible thing; users can decide for themselves if they want to install the implicit integrations, but this is definitely an inconvenience relative to the magic method. ---. Apologies that I'm not responding super quickly to everything - I'm not the only main QuTiP dev (and I can only work on QuTiP occasionally anyway), so I'm giving others time to read and think about the proposals as well.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1508#issuecomment-830003691
https://github.com/qutip/qutip/issues/1508#issuecomment-830003691:4363,Deployability,install,install,4363,"ite out a proper design document and get approval of it before we get deep into the implementation. > The latter would make it harder to support multiple versions of qutip in the implementers, but I would not worry too much about it. You can throw an error saying that this other package is not supported and you should either nag it's developers or downgrade qutip.; >; > I'm not particularly worried about the blame: even if the error is thrown from qutip, if the message is clear enough it will be clear that the fault is in the downstream implementors of the API. I'm concerned from a user's perspective. QuTiP has a wide user base, and we're beyond the stage where ""iterate fast and break things"" is ok for us (though of course it's fine and even good for pre-stable libraries, to avoid getting weighed down). We've got to be concerned with backwards and forwards compatibility; what if a user wants to install and use QuTiP and a different library in the same environment _without_ using them together, but can't even have them coexist because of version incompatibilities in optional conversion features? That's frustrating for users, even though it's not really anybody's fault. Bugging developers is fine when people want to use packages that are still maintained, but I'm sure we've all come up against times in research when you get to trying out a package to do one specific thing that's been abandoned for a while. Again, this certainly isn't an unsolvable problem: having versioning in the interface API is one solution to some of these problems. ---. For greater discussion, here's an alternate approach: instead of objects defining `__qutip_qobj__`, instead we expose an entry-point `qutip.Qobj.register_conversion_function(converter, type, priority, version=None)`, and downstream libraries register functions rather than defining methods on their classes. The logic inside the `Qobj` constructor remains approximately the same as what you suggest. I think TensorFlow does something ",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1508#issuecomment-830003691
https://github.com/qutip/qutip/issues/1508#issuecomment-830003691:8455,Deployability,install,install,8455,"lready. We'd have to modify our procedures a little bit (we're mostly concerned with constructing the underlying matrices at the moment), but it's a smaller change in behaviour. Disadvantages that I can think of:; - It's got linear scaling with the number of conversions registered, so it's in theory possible to register ""too many"" and cause a slow down. In reality, this will be a very small effect (`Qobj` construction time will be dominated by copying data into new formats), and I think the benefits of a priority queue of allowed converters outweighs it in convenience for users.; - It involves some global state of the `qutip` library, which _may_ cause problems for multiprocessing if somebody tries to register a `lambda` converter (can't pass through `pickle`, though I'm not 100% on whether module-level stuff needs to), and of course there's the query of what happens when converters are registered in separate processes. We already have this ""problem"" in 5.0 though, because that's how the entire underlying dispatch mechanism is handled; we can just require that converters must be pickle-able.; - If a downstream package wants to lazily `import qutip` (we're a pretty heavy import right now), it's harder in this method; you'd basically have to ask a user to call `otherlibrary.register_qutip()`. For one, I'm going to put some effort into making `import qutip` take much less time for 5.0 (the main problem right now is we essentially eagerly import all of scipy and IPython if it's around), so that'll make it a bit easier. For two, a single initialisation statement isn't _necessarily_ a terrible thing; users can decide for themselves if they want to install the implicit integrations, but this is definitely an inconvenience relative to the magic method. ---. Apologies that I'm not responding super quickly to everything - I'm not the only main QuTiP dev (and I can only work on QuTiP occasionally anyway), so I'm giving others time to read and think about the proposals as well.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1508#issuecomment-830003691
https://github.com/qutip/qutip/issues/1508#issuecomment-830003691:8476,Deployability,integrat,integrations,8476,"lready. We'd have to modify our procedures a little bit (we're mostly concerned with constructing the underlying matrices at the moment), but it's a smaller change in behaviour. Disadvantages that I can think of:; - It's got linear scaling with the number of conversions registered, so it's in theory possible to register ""too many"" and cause a slow down. In reality, this will be a very small effect (`Qobj` construction time will be dominated by copying data into new formats), and I think the benefits of a priority queue of allowed converters outweighs it in convenience for users.; - It involves some global state of the `qutip` library, which _may_ cause problems for multiprocessing if somebody tries to register a `lambda` converter (can't pass through `pickle`, though I'm not 100% on whether module-level stuff needs to), and of course there's the query of what happens when converters are registered in separate processes. We already have this ""problem"" in 5.0 though, because that's how the entire underlying dispatch mechanism is handled; we can just require that converters must be pickle-able.; - If a downstream package wants to lazily `import qutip` (we're a pretty heavy import right now), it's harder in this method; you'd basically have to ask a user to call `otherlibrary.register_qutip()`. For one, I'm going to put some effort into making `import qutip` take much less time for 5.0 (the main problem right now is we essentially eagerly import all of scipy and IPython if it's around), so that'll make it a bit easier. For two, a single initialisation statement isn't _necessarily_ a terrible thing; users can decide for themselves if they want to install the implicit integrations, but this is definitely an inconvenience relative to the magic method. ---. Apologies that I'm not responding super quickly to everything - I'm not the only main QuTiP dev (and I can only work on QuTiP occasionally anyway), so I'm giving others time to read and think about the proposals as well.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1508#issuecomment-830003691
https://github.com/qutip/qutip/issues/1508#issuecomment-830003691:1734,Integrability,interface,interface,1734,"is about the conversion of operators into operator-kets when moving to the superoperator formalism.; - In theory it should recognise a suitable `dims`, but right now construction will be faster if you provide `type='super'` as well. Construction speed is hugely improved in `dev.major`. You only need to define `superrep` if you're giving us a Choi (`superrep='choi'`) or chi (`superrep='chi'`) matrix instead.; - No, it should really be any indexable quantity (requiring list is a historical artifact, not a conscious choice). The entire parsing structure of dimensions objects are going to change in 5.0 (though the list structure will still work). This should even give you more freedom, if you need it - I've got some plans for vastly improved handling of restricted-entry Hilbert spaces (basically spaces that are small embeddings into a larger space that's all 0).; - I am very strongly against accepting this (like I said above):. > Oh, one thing that I'd like to suggest we _don't_ do: use this interface to _implicitly_ create `Qobj` inside our functions.; ; To me, this is absolutely one of the mistakes that Numpy made in their implementation, and we shouldn't be copying it. You can see that it didn't work as intended, because they've had to add `__array_function__` and other additional methods on top to start to make it work, and it's still not perfect - even `scipy.sparse` have/had problems implementing them. While it might work in your particular case, making sure that nothing funny happens in the abstract across _all_ possible implementors of the interface while still having it do something useful is a very tricky problem, as evidenced by Numpy. Any conversion is going to be lossy for some people (perhaps not you, but it will be for others), and that means the behaviour for users will be surprising in some cases. In my opinion, if we're going to have a `__qutip_qobj__` interface, the interface should be defined for one operation only, and should never be called implicit",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1508#issuecomment-830003691
https://github.com/qutip/qutip/issues/1508#issuecomment-830003691:2301,Integrability,interface,interface,2301,"tructure of dimensions objects are going to change in 5.0 (though the list structure will still work). This should even give you more freedom, if you need it - I've got some plans for vastly improved handling of restricted-entry Hilbert spaces (basically spaces that are small embeddings into a larger space that's all 0).; - I am very strongly against accepting this (like I said above):. > Oh, one thing that I'd like to suggest we _don't_ do: use this interface to _implicitly_ create `Qobj` inside our functions.; ; To me, this is absolutely one of the mistakes that Numpy made in their implementation, and we shouldn't be copying it. You can see that it didn't work as intended, because they've had to add `__array_function__` and other additional methods on top to start to make it work, and it's still not perfect - even `scipy.sparse` have/had problems implementing them. While it might work in your particular case, making sure that nothing funny happens in the abstract across _all_ possible implementors of the interface while still having it do something useful is a very tricky problem, as evidenced by Numpy. Any conversion is going to be lossy for some people (perhaps not you, but it will be for others), and that means the behaviour for users will be surprising in some cases. In my opinion, if we're going to have a `__qutip_qobj__` interface, the interface should be defined for one operation only, and should never be called implicitly. I'm not entirely close-minded to alternate views here, but given the problems Numpy had (whose team I have no doubt are much smarter than I am), I'm really not enthusiastic about any implicit conversions. I really do appreciate the interest, and I _am_ keen to let us have better compatibility with the rest of the community, but there are a lot of design concerns that we're going to want to work on our side first - I just want to caution you in case you're trying to work towards a PR, because I'm not close to being happy to accept one, yet",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1508#issuecomment-830003691
https://github.com/qutip/qutip/issues/1508#issuecomment-830003691:2630,Integrability,interface,interface,2630,"I said above):. > Oh, one thing that I'd like to suggest we _don't_ do: use this interface to _implicitly_ create `Qobj` inside our functions.; ; To me, this is absolutely one of the mistakes that Numpy made in their implementation, and we shouldn't be copying it. You can see that it didn't work as intended, because they've had to add `__array_function__` and other additional methods on top to start to make it work, and it's still not perfect - even `scipy.sparse` have/had problems implementing them. While it might work in your particular case, making sure that nothing funny happens in the abstract across _all_ possible implementors of the interface while still having it do something useful is a very tricky problem, as evidenced by Numpy. Any conversion is going to be lossy for some people (perhaps not you, but it will be for others), and that means the behaviour for users will be surprising in some cases. In my opinion, if we're going to have a `__qutip_qobj__` interface, the interface should be defined for one operation only, and should never be called implicitly. I'm not entirely close-minded to alternate views here, but given the problems Numpy had (whose team I have no doubt are much smarter than I am), I'm really not enthusiastic about any implicit conversions. I really do appreciate the interest, and I _am_ keen to let us have better compatibility with the rest of the community, but there are a lot of design concerns that we're going to want to work on our side first - I just want to caution you in case you're trying to work towards a PR, because I'm not close to being happy to accept one, yet. If we're going to do this (and we haven't decided if we will yet), we're going to need to get a lot of wide-ranging input from many different libraries, and we'll want to write out a proper design document and get approval of it before we get deep into the implementation. > The latter would make it harder to support multiple versions of qutip in the implementers, but I ",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1508#issuecomment-830003691
https://github.com/qutip/qutip/issues/1508#issuecomment-830003691:2645,Integrability,interface,interface,2645,"I said above):. > Oh, one thing that I'd like to suggest we _don't_ do: use this interface to _implicitly_ create `Qobj` inside our functions.; ; To me, this is absolutely one of the mistakes that Numpy made in their implementation, and we shouldn't be copying it. You can see that it didn't work as intended, because they've had to add `__array_function__` and other additional methods on top to start to make it work, and it's still not perfect - even `scipy.sparse` have/had problems implementing them. While it might work in your particular case, making sure that nothing funny happens in the abstract across _all_ possible implementors of the interface while still having it do something useful is a very tricky problem, as evidenced by Numpy. Any conversion is going to be lossy for some people (perhaps not you, but it will be for others), and that means the behaviour for users will be surprising in some cases. In my opinion, if we're going to have a `__qutip_qobj__` interface, the interface should be defined for one operation only, and should never be called implicitly. I'm not entirely close-minded to alternate views here, but given the problems Numpy had (whose team I have no doubt are much smarter than I am), I'm really not enthusiastic about any implicit conversions. I really do appreciate the interest, and I _am_ keen to let us have better compatibility with the rest of the community, but there are a lot of design concerns that we're going to want to work on our side first - I just want to caution you in case you're trying to work towards a PR, because I'm not close to being happy to accept one, yet. If we're going to do this (and we haven't decided if we will yet), we're going to need to get a lot of wide-ranging input from many different libraries, and we'll want to write out a proper design document and get approval of it before we get deep into the implementation. > The latter would make it harder to support multiple versions of qutip in the implementers, but I ",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1508#issuecomment-830003691
https://github.com/qutip/qutip/issues/1508#issuecomment-830003691:3921,Integrability,message,message,3921,"plicit conversions. I really do appreciate the interest, and I _am_ keen to let us have better compatibility with the rest of the community, but there are a lot of design concerns that we're going to want to work on our side first - I just want to caution you in case you're trying to work towards a PR, because I'm not close to being happy to accept one, yet. If we're going to do this (and we haven't decided if we will yet), we're going to need to get a lot of wide-ranging input from many different libraries, and we'll want to write out a proper design document and get approval of it before we get deep into the implementation. > The latter would make it harder to support multiple versions of qutip in the implementers, but I would not worry too much about it. You can throw an error saying that this other package is not supported and you should either nag it's developers or downgrade qutip.; >; > I'm not particularly worried about the blame: even if the error is thrown from qutip, if the message is clear enough it will be clear that the fault is in the downstream implementors of the API. I'm concerned from a user's perspective. QuTiP has a wide user base, and we're beyond the stage where ""iterate fast and break things"" is ok for us (though of course it's fine and even good for pre-stable libraries, to avoid getting weighed down). We've got to be concerned with backwards and forwards compatibility; what if a user wants to install and use QuTiP and a different library in the same environment _without_ using them together, but can't even have them coexist because of version incompatibilities in optional conversion features? That's frustrating for users, even though it's not really anybody's fault. Bugging developers is fine when people want to use packages that are still maintained, but I'm sure we've all come up against times in research when you get to trying out a package to do one specific thing that's been abandoned for a while. Again, this certainly isn't an unsolvab",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1508#issuecomment-830003691
https://github.com/qutip/qutip/issues/1508#issuecomment-830003691:4959,Integrability,interface,interface,4959,"will be clear that the fault is in the downstream implementors of the API. I'm concerned from a user's perspective. QuTiP has a wide user base, and we're beyond the stage where ""iterate fast and break things"" is ok for us (though of course it's fine and even good for pre-stable libraries, to avoid getting weighed down). We've got to be concerned with backwards and forwards compatibility; what if a user wants to install and use QuTiP and a different library in the same environment _without_ using them together, but can't even have them coexist because of version incompatibilities in optional conversion features? That's frustrating for users, even though it's not really anybody's fault. Bugging developers is fine when people want to use packages that are still maintained, but I'm sure we've all come up against times in research when you get to trying out a package to do one specific thing that's been abandoned for a while. Again, this certainly isn't an unsolvable problem: having versioning in the interface API is one solution to some of these problems. ---. For greater discussion, here's an alternate approach: instead of objects defining `__qutip_qobj__`, instead we expose an entry-point `qutip.Qobj.register_conversion_function(converter, type, priority, version=None)`, and downstream libraries register functions rather than defining methods on their classes. The logic inside the `Qobj` constructor remains approximately the same as what you suggest. I think TensorFlow does something a little more similar to this? (I'm not very familiar with it at all.). Advantages of this over a `__qutip_qobj__` magic method:; - Users aren't limited to what libraries define for them, but can add their own conversions or override library ones if they don't like them. I actually see this as being closer to Julia's dispatch, or Rust's `impl for`.; - It doesn't involve weird namespacing, or anything like that, and doesn't require downstream classes to carry around additional slots. It's l",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1508#issuecomment-830003691
https://github.com/qutip/qutip/issues/1508#issuecomment-830003691:8476,Integrability,integrat,integrations,8476,"lready. We'd have to modify our procedures a little bit (we're mostly concerned with constructing the underlying matrices at the moment), but it's a smaller change in behaviour. Disadvantages that I can think of:; - It's got linear scaling with the number of conversions registered, so it's in theory possible to register ""too many"" and cause a slow down. In reality, this will be a very small effect (`Qobj` construction time will be dominated by copying data into new formats), and I think the benefits of a priority queue of allowed converters outweighs it in convenience for users.; - It involves some global state of the `qutip` library, which _may_ cause problems for multiprocessing if somebody tries to register a `lambda` converter (can't pass through `pickle`, though I'm not 100% on whether module-level stuff needs to), and of course there's the query of what happens when converters are registered in separate processes. We already have this ""problem"" in 5.0 though, because that's how the entire underlying dispatch mechanism is handled; we can just require that converters must be pickle-able.; - If a downstream package wants to lazily `import qutip` (we're a pretty heavy import right now), it's harder in this method; you'd basically have to ask a user to call `otherlibrary.register_qutip()`. For one, I'm going to put some effort into making `import qutip` take much less time for 5.0 (the main problem right now is we essentially eagerly import all of scipy and IPython if it's around), so that'll make it a bit easier. For two, a single initialisation statement isn't _necessarily_ a terrible thing; users can decide for themselves if they want to install the implicit integrations, but this is definitely an inconvenience relative to the magic method. ---. Apologies that I'm not responding super quickly to everything - I'm not the only main QuTiP dev (and I can only work on QuTiP occasionally anyway), so I'm giving others time to read and think about the proposals as well.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1508#issuecomment-830003691
https://github.com/qutip/qutip/issues/1508#issuecomment-830003691:7304,Performance,queue,queue,7304,"ier to separate out different versions, and detect what to register as the conversion function with QuTiP. This is a particular advantage for Python classes compiled as C-extensions (like from C or Cython), which typically don't allow assigning methods dynamically.; - A library could even register multiple versions of the conversion function with us, and let QuTiP handle API versioning centrally, rather than requiring downstream libraries to roll their own checks.; - We're basically already set up to do this in `dev.major` already. We'd have to modify our procedures a little bit (we're mostly concerned with constructing the underlying matrices at the moment), but it's a smaller change in behaviour. Disadvantages that I can think of:; - It's got linear scaling with the number of conversions registered, so it's in theory possible to register ""too many"" and cause a slow down. In reality, this will be a very small effect (`Qobj` construction time will be dominated by copying data into new formats), and I think the benefits of a priority queue of allowed converters outweighs it in convenience for users.; - It involves some global state of the `qutip` library, which _may_ cause problems for multiprocessing if somebody tries to register a `lambda` converter (can't pass through `pickle`, though I'm not 100% on whether module-level stuff needs to), and of course there's the query of what happens when converters are registered in separate processes. We already have this ""problem"" in 5.0 though, because that's how the entire underlying dispatch mechanism is handled; we can just require that converters must be pickle-able.; - If a downstream package wants to lazily `import qutip` (we're a pretty heavy import right now), it's harder in this method; you'd basically have to ask a user to call `otherlibrary.register_qutip()`. For one, I'm going to put some effort into making `import qutip` take much less time for 5.0 (the main problem right now is we essentially eagerly import all ",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1508#issuecomment-830003691
https://github.com/qutip/qutip/issues/1508#issuecomment-830003691:4241,Safety,avoid,avoid,4241,"to caution you in case you're trying to work towards a PR, because I'm not close to being happy to accept one, yet. If we're going to do this (and we haven't decided if we will yet), we're going to need to get a lot of wide-ranging input from many different libraries, and we'll want to write out a proper design document and get approval of it before we get deep into the implementation. > The latter would make it harder to support multiple versions of qutip in the implementers, but I would not worry too much about it. You can throw an error saying that this other package is not supported and you should either nag it's developers or downgrade qutip.; >; > I'm not particularly worried about the blame: even if the error is thrown from qutip, if the message is clear enough it will be clear that the fault is in the downstream implementors of the API. I'm concerned from a user's perspective. QuTiP has a wide user base, and we're beyond the stage where ""iterate fast and break things"" is ok for us (though of course it's fine and even good for pre-stable libraries, to avoid getting weighed down). We've got to be concerned with backwards and forwards compatibility; what if a user wants to install and use QuTiP and a different library in the same environment _without_ using them together, but can't even have them coexist because of version incompatibilities in optional conversion features? That's frustrating for users, even though it's not really anybody's fault. Bugging developers is fine when people want to use packages that are still maintained, but I'm sure we've all come up against times in research when you get to trying out a package to do one specific thing that's been abandoned for a while. Again, this certainly isn't an unsolvable problem: having versioning in the interface API is one solution to some of these problems. ---. For greater discussion, here's an alternate approach: instead of objects defining `__qutip_qobj__`, instead we expose an entry-point `qutip.Qobj.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1508#issuecomment-830003691
https://github.com/qutip/qutip/issues/1508#issuecomment-830003691:6299,Safety,detect,detect,6299,"braries register functions rather than defining methods on their classes. The logic inside the `Qobj` constructor remains approximately the same as what you suggest. I think TensorFlow does something a little more similar to this? (I'm not very familiar with it at all.). Advantages of this over a `__qutip_qobj__` magic method:; - Users aren't limited to what libraries define for them, but can add their own conversions or override library ones if they don't like them. I actually see this as being closer to Julia's dispatch, or Rust's `impl for`.; - It doesn't involve weird namespacing, or anything like that, and doesn't require downstream classes to carry around additional slots. It's less an issue for classes that define `__slots__` since those are frozen methods, but extra methods adds a minor amount vtable weight for most libraries, and makes their class definitions more complex.; - Control between different versions is perhaps a little easier (though a minor point): this _feels_ easier to separate out different versions, and detect what to register as the conversion function with QuTiP. This is a particular advantage for Python classes compiled as C-extensions (like from C or Cython), which typically don't allow assigning methods dynamically.; - A library could even register multiple versions of the conversion function with us, and let QuTiP handle API versioning centrally, rather than requiring downstream libraries to roll their own checks.; - We're basically already set up to do this in `dev.major` already. We'd have to modify our procedures a little bit (we're mostly concerned with constructing the underlying matrices at the moment), but it's a smaller change in behaviour. Disadvantages that I can think of:; - It's got linear scaling with the number of conversions registered, so it's in theory possible to register ""too many"" and cause a slow down. In reality, this will be a very small effect (`Qobj` construction time will be dominated by copying data into new ",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1508#issuecomment-830003691
https://github.com/qutip/qutip/issues/1508#issuecomment-830003691:5132,Security,expose,expose,5132,", and we're beyond the stage where ""iterate fast and break things"" is ok for us (though of course it's fine and even good for pre-stable libraries, to avoid getting weighed down). We've got to be concerned with backwards and forwards compatibility; what if a user wants to install and use QuTiP and a different library in the same environment _without_ using them together, but can't even have them coexist because of version incompatibilities in optional conversion features? That's frustrating for users, even though it's not really anybody's fault. Bugging developers is fine when people want to use packages that are still maintained, but I'm sure we've all come up against times in research when you get to trying out a package to do one specific thing that's been abandoned for a while. Again, this certainly isn't an unsolvable problem: having versioning in the interface API is one solution to some of these problems. ---. For greater discussion, here's an alternate approach: instead of objects defining `__qutip_qobj__`, instead we expose an entry-point `qutip.Qobj.register_conversion_function(converter, type, priority, version=None)`, and downstream libraries register functions rather than defining methods on their classes. The logic inside the `Qobj` constructor remains approximately the same as what you suggest. I think TensorFlow does something a little more similar to this? (I'm not very familiar with it at all.). Advantages of this over a `__qutip_qobj__` magic method:; - Users aren't limited to what libraries define for them, but can add their own conversions or override library ones if they don't like them. I actually see this as being closer to Julia's dispatch, or Rust's `impl for`.; - It doesn't involve weird namespacing, or anything like that, and doesn't require downstream classes to carry around additional slots. It's less an issue for classes that define `__slots__` since those are frozen methods, but extra methods adds a minor amount vtable weight for most ",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1508#issuecomment-830003691
https://github.com/qutip/qutip/issues/1508#issuecomment-830003691:5333,Testability,log,logic,5333," use QuTiP and a different library in the same environment _without_ using them together, but can't even have them coexist because of version incompatibilities in optional conversion features? That's frustrating for users, even though it's not really anybody's fault. Bugging developers is fine when people want to use packages that are still maintained, but I'm sure we've all come up against times in research when you get to trying out a package to do one specific thing that's been abandoned for a while. Again, this certainly isn't an unsolvable problem: having versioning in the interface API is one solution to some of these problems. ---. For greater discussion, here's an alternate approach: instead of objects defining `__qutip_qobj__`, instead we expose an entry-point `qutip.Qobj.register_conversion_function(converter, type, priority, version=None)`, and downstream libraries register functions rather than defining methods on their classes. The logic inside the `Qobj` constructor remains approximately the same as what you suggest. I think TensorFlow does something a little more similar to this? (I'm not very familiar with it at all.). Advantages of this over a `__qutip_qobj__` magic method:; - Users aren't limited to what libraries define for them, but can add their own conversions or override library ones if they don't like them. I actually see this as being closer to Julia's dispatch, or Rust's `impl for`.; - It doesn't involve weird namespacing, or anything like that, and doesn't require downstream classes to carry around additional slots. It's less an issue for classes that define `__slots__` since those are frozen methods, but extra methods adds a minor amount vtable weight for most libraries, and makes their class definitions more complex.; - Control between different versions is perhaps a little easier (though a minor point): this _feels_ easier to separate out different versions, and detect what to register as the conversion function with QuTiP. This is a pa",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1508#issuecomment-830003691
https://github.com/qutip/qutip/issues/1508#issuecomment-830003691:87,Usability,simpl,simpler,87,"Anything we do will be made on the `dev.major` branch, where the constructor is _much_ simpler and easier to work with, which hopefully should make things rather easier for you. The dimensions objects will probably change a lot before then as well (they should in principle accept any type, it's just historical that they only accept `list`). The `Qobj` constructor is intended to allow the first argument to be passed positionally, but all others are _expected_ to be keyword-only. We'll probably start enforcing those semantics from 5.0 onwards (we need to issue deprecation warnings before we change behaviour). Answers to questions:; - For tensor products, we use the same ordering as `np.kron`. The column-stacking convention is about the conversion of operators into operator-kets when moving to the superoperator formalism.; - In theory it should recognise a suitable `dims`, but right now construction will be faster if you provide `type='super'` as well. Construction speed is hugely improved in `dev.major`. You only need to define `superrep` if you're giving us a Choi (`superrep='choi'`) or chi (`superrep='chi'`) matrix instead.; - No, it should really be any indexable quantity (requiring list is a historical artifact, not a conscious choice). The entire parsing structure of dimensions objects are going to change in 5.0 (though the list structure will still work). This should even give you more freedom, if you need it - I've got some plans for vastly improved handling of restricted-entry Hilbert spaces (basically spaces that are small embeddings into a larger space that's all 0).; - I am very strongly against accepting this (like I said above):. > Oh, one thing that I'd like to suggest we _don't_ do: use this interface to _implicitly_ create `Qobj` inside our functions.; ; To me, this is absolutely one of the mistakes that Numpy made in their implementation, and we shouldn't be copying it. You can see that it didn't work as intended, because they've had to add `__array_fu",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1508#issuecomment-830003691
https://github.com/qutip/qutip/issues/1508#issuecomment-830003691:3932,Usability,clear,clear,3932,"plicit conversions. I really do appreciate the interest, and I _am_ keen to let us have better compatibility with the rest of the community, but there are a lot of design concerns that we're going to want to work on our side first - I just want to caution you in case you're trying to work towards a PR, because I'm not close to being happy to accept one, yet. If we're going to do this (and we haven't decided if we will yet), we're going to need to get a lot of wide-ranging input from many different libraries, and we'll want to write out a proper design document and get approval of it before we get deep into the implementation. > The latter would make it harder to support multiple versions of qutip in the implementers, but I would not worry too much about it. You can throw an error saying that this other package is not supported and you should either nag it's developers or downgrade qutip.; >; > I'm not particularly worried about the blame: even if the error is thrown from qutip, if the message is clear enough it will be clear that the fault is in the downstream implementors of the API. I'm concerned from a user's perspective. QuTiP has a wide user base, and we're beyond the stage where ""iterate fast and break things"" is ok for us (though of course it's fine and even good for pre-stable libraries, to avoid getting weighed down). We've got to be concerned with backwards and forwards compatibility; what if a user wants to install and use QuTiP and a different library in the same environment _without_ using them together, but can't even have them coexist because of version incompatibilities in optional conversion features? That's frustrating for users, even though it's not really anybody's fault. Bugging developers is fine when people want to use packages that are still maintained, but I'm sure we've all come up against times in research when you get to trying out a package to do one specific thing that's been abandoned for a while. Again, this certainly isn't an unsolvab",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1508#issuecomment-830003691
https://github.com/qutip/qutip/issues/1508#issuecomment-830003691:3956,Usability,clear,clear,3956,"plicit conversions. I really do appreciate the interest, and I _am_ keen to let us have better compatibility with the rest of the community, but there are a lot of design concerns that we're going to want to work on our side first - I just want to caution you in case you're trying to work towards a PR, because I'm not close to being happy to accept one, yet. If we're going to do this (and we haven't decided if we will yet), we're going to need to get a lot of wide-ranging input from many different libraries, and we'll want to write out a proper design document and get approval of it before we get deep into the implementation. > The latter would make it harder to support multiple versions of qutip in the implementers, but I would not worry too much about it. You can throw an error saying that this other package is not supported and you should either nag it's developers or downgrade qutip.; >; > I'm not particularly worried about the blame: even if the error is thrown from qutip, if the message is clear enough it will be clear that the fault is in the downstream implementors of the API. I'm concerned from a user's perspective. QuTiP has a wide user base, and we're beyond the stage where ""iterate fast and break things"" is ok for us (though of course it's fine and even good for pre-stable libraries, to avoid getting weighed down). We've got to be concerned with backwards and forwards compatibility; what if a user wants to install and use QuTiP and a different library in the same environment _without_ using them together, but can't even have them coexist because of version incompatibilities in optional conversion features? That's frustrating for users, even though it's not really anybody's fault. Bugging developers is fine when people want to use packages that are still maintained, but I'm sure we've all come up against times in research when you get to trying out a package to do one specific thing that's been abandoned for a while. Again, this certainly isn't an unsolvab",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1508#issuecomment-830003691
https://github.com/qutip/qutip/issues/1508#issuecomment-830021551:49,Deployability,release,release,49,"By the way, if you're organising your next major release right now, I wouldn't wait for us before you release it - we certainly won't define any interface until at least QuTiP 5.0, and we don't expect to even be in the first alpha until around September.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1508#issuecomment-830021551
https://github.com/qutip/qutip/issues/1508#issuecomment-830021551:102,Deployability,release,release,102,"By the way, if you're organising your next major release right now, I wouldn't wait for us before you release it - we certainly won't define any interface until at least QuTiP 5.0, and we don't expect to even be in the first alpha until around September.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1508#issuecomment-830021551
https://github.com/qutip/qutip/issues/1508#issuecomment-830021551:145,Integrability,interface,interface,145,"By the way, if you're organising your next major release right now, I wouldn't wait for us before you release it - we certainly won't define any interface until at least QuTiP 5.0, and we don't expect to even be in the first alpha until around September.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1508#issuecomment-830021551
https://github.com/qutip/qutip/issues/1508#issuecomment-830113742:366,Availability,down,down,366,"—; Let me begin by saying that I completely understand your concerns. I am not trying to enforce a view on the QuTiP project, but rather as I see; I would like the various frameworks in the vast ‘quantum’ ecosystem to ; coexist in such a way that makes easy for users to jump from one tool to the other easily. I personally envisage an ecosystem where one can write down an hamiltonian in the tool of choice, obtain the exact time evolution with qutip, and maybe have a look at it’s semiclassical trajectory. Jump into netket and check if a variational representation can properly capture the correlations. Trotterize the hamiltonian and get a circuit, without worrying about how to convert from one framework to the other. . I want to start the discussion on this topic eagerly because I am aware that it will take a fairly long time. If there is anything I can do to make your future internal discussions easier, do let me know. > I just want to caution you in case you're trying to work towards a PR. Indeed. I was just trying to play around with this. . > If we're going to do this (and we haven't decided if we will yet), we're going to need to get a lot of wide-ranging input from many different libraries. I completely agree with your approach. I’m simply trying to push for this to be something that will come out in a reasonable timeframe and not be something forgotten. > We've got to be concerned with backwards and forwards compatibility; what if a user wants to install and use QuTiP and a different library in the same environment without using them together, but can't even have them coexist because of version incompatibilities in optional conversion features?. I do understand your point, and I see how you want to be backward and forward compatible, however I don’t think that my proposal would break different tools in the same environment. What I propose would simply prevent `qutip.Qobj(otherlibraryobject)` from working (with an explicative error message) if `otherlibrary` does ",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1508#issuecomment-830113742
https://github.com/qutip/qutip/issues/1508#issuecomment-830113742:1963,Availability,error,error,1963," trying to work towards a PR. Indeed. I was just trying to play around with this. . > If we're going to do this (and we haven't decided if we will yet), we're going to need to get a lot of wide-ranging input from many different libraries. I completely agree with your approach. I’m simply trying to push for this to be something that will come out in a reasonable timeframe and not be something forgotten. > We've got to be concerned with backwards and forwards compatibility; what if a user wants to install and use QuTiP and a different library in the same environment without using them together, but can't even have them coexist because of version incompatibilities in optional conversion features?. I do understand your point, and I see how you want to be backward and forward compatible, however I don’t think that my proposal would break different tools in the same environment. What I propose would simply prevent `qutip.Qobj(otherlibraryobject)` from working (with an explicative error message) if `otherlibrary` does not support the same qobj interface version. Everything else would work the same. You can still import and use the two libraries independently without issues. It’s indeed possible to design around this and supporting at the same time different versions of the interface, however, and there’s value in doing so. > To me, this is absolutely one of the mistakes that Numpy made in their implementation, and we shouldn't be copying it. I don't know enough of the history behind numpy current api, but I see your point. however I'd like to reiterate that this is not what I am proposing. ; I think there is considerable difference between supporting arbitrary operations `new_obj = Qobj + netket_operator*5` (though if you are going to export dispatch hooks in `5.0`, this would be possible in a consistent way, I think) and `qutip.mesolve(netket_operator, ...)`. ; In the first, I do agree with your point that the nature python's `__add__/__radd__` is not commutative, leading",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1508#issuecomment-830113742
https://github.com/qutip/qutip/issues/1508#issuecomment-830113742:3628,Availability,down,downstream,3628,"ame time different versions of the interface, however, and there’s value in doing so. > To me, this is absolutely one of the mistakes that Numpy made in their implementation, and we shouldn't be copying it. I don't know enough of the history behind numpy current api, but I see your point. however I'd like to reiterate that this is not what I am proposing. ; I think there is considerable difference between supporting arbitrary operations `new_obj = Qobj + netket_operator*5` (though if you are going to export dispatch hooks in `5.0`, this would be possible in a consistent way, I think) and `qutip.mesolve(netket_operator, ...)`. ; In the first, I do agree with your point that the nature python's `__add__/__radd__` is not commutative, leading to surprising behavior. From my point of view, no package really owns `+` so any conversion would be implicit.; But `qutip.groundstate(netket_operator)` is in itself an explicit cast. I am explicitly asking to qutip `please give me the ground state of this object`. I do expect to get a Qobj out, and qutip to make an effort converting this object to whatever format he internally wants to work with. Same goes with time evolution. . > For greater discussion, here's an alternate approach: instead of objects defining __qutip_qobj__, instead we expose an entry-point qutip.Qobj.register_conversion_function(converter, type, priority, version=None), and downstream libraries register functions rather than defining methods on their classes. I do prefer such an approach. I just did not think that was an option in QuTiP.; In fact we have redesigned NetKet to allow for something similar using multiple dispatch. (I’m not familiar with Tensorflow either.). I do agree with all your points, especially the first. As for your last point, about downstream packages having to import qutip: This is indeed a potential issue. I’ll try to investigate this: maybe there is a solution whereby a callback executed on package load can be registered with importlib?",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1508#issuecomment-830113742
https://github.com/qutip/qutip/issues/1508#issuecomment-830113742:4015,Availability,down,downstream,4015,"ame time different versions of the interface, however, and there’s value in doing so. > To me, this is absolutely one of the mistakes that Numpy made in their implementation, and we shouldn't be copying it. I don't know enough of the history behind numpy current api, but I see your point. however I'd like to reiterate that this is not what I am proposing. ; I think there is considerable difference between supporting arbitrary operations `new_obj = Qobj + netket_operator*5` (though if you are going to export dispatch hooks in `5.0`, this would be possible in a consistent way, I think) and `qutip.mesolve(netket_operator, ...)`. ; In the first, I do agree with your point that the nature python's `__add__/__radd__` is not commutative, leading to surprising behavior. From my point of view, no package really owns `+` so any conversion would be implicit.; But `qutip.groundstate(netket_operator)` is in itself an explicit cast. I am explicitly asking to qutip `please give me the ground state of this object`. I do expect to get a Qobj out, and qutip to make an effort converting this object to whatever format he internally wants to work with. Same goes with time evolution. . > For greater discussion, here's an alternate approach: instead of objects defining __qutip_qobj__, instead we expose an entry-point qutip.Qobj.register_conversion_function(converter, type, priority, version=None), and downstream libraries register functions rather than defining methods on their classes. I do prefer such an approach. I just did not think that was an option in QuTiP.; In fact we have redesigned NetKet to allow for something similar using multiple dispatch. (I’m not familiar with Tensorflow either.). I do agree with all your points, especially the first. As for your last point, about downstream packages having to import qutip: This is indeed a potential issue. I’ll try to investigate this: maybe there is a solution whereby a callback executed on package load can be registered with importlib?",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1508#issuecomment-830113742
https://github.com/qutip/qutip/issues/1508#issuecomment-830113742:1475,Deployability,install,install,1475,"d check if a variational representation can properly capture the correlations. Trotterize the hamiltonian and get a circuit, without worrying about how to convert from one framework to the other. . I want to start the discussion on this topic eagerly because I am aware that it will take a fairly long time. If there is anything I can do to make your future internal discussions easier, do let me know. > I just want to caution you in case you're trying to work towards a PR. Indeed. I was just trying to play around with this. . > If we're going to do this (and we haven't decided if we will yet), we're going to need to get a lot of wide-ranging input from many different libraries. I completely agree with your approach. I’m simply trying to push for this to be something that will come out in a reasonable timeframe and not be something forgotten. > We've got to be concerned with backwards and forwards compatibility; what if a user wants to install and use QuTiP and a different library in the same environment without using them together, but can't even have them coexist because of version incompatibilities in optional conversion features?. I do understand your point, and I see how you want to be backward and forward compatible, however I don’t think that my proposal would break different tools in the same environment. What I propose would simply prevent `qutip.Qobj(otherlibraryobject)` from working (with an explicative error message) if `otherlibrary` does not support the same qobj interface version. Everything else would work the same. You can still import and use the two libraries independently without issues. It’s indeed possible to design around this and supporting at the same time different versions of the interface, however, and there’s value in doing so. > To me, this is absolutely one of the mistakes that Numpy made in their implementation, and we shouldn't be copying it. I don't know enough of the history behind numpy current api, but I see your point. however I'd ",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1508#issuecomment-830113742
https://github.com/qutip/qutip/issues/1508#issuecomment-830113742:1969,Integrability,message,message,1969," trying to work towards a PR. Indeed. I was just trying to play around with this. . > If we're going to do this (and we haven't decided if we will yet), we're going to need to get a lot of wide-ranging input from many different libraries. I completely agree with your approach. I’m simply trying to push for this to be something that will come out in a reasonable timeframe and not be something forgotten. > We've got to be concerned with backwards and forwards compatibility; what if a user wants to install and use QuTiP and a different library in the same environment without using them together, but can't even have them coexist because of version incompatibilities in optional conversion features?. I do understand your point, and I see how you want to be backward and forward compatible, however I don’t think that my proposal would break different tools in the same environment. What I propose would simply prevent `qutip.Qobj(otherlibraryobject)` from working (with an explicative error message) if `otherlibrary` does not support the same qobj interface version. Everything else would work the same. You can still import and use the two libraries independently without issues. It’s indeed possible to design around this and supporting at the same time different versions of the interface, however, and there’s value in doing so. > To me, this is absolutely one of the mistakes that Numpy made in their implementation, and we shouldn't be copying it. I don't know enough of the history behind numpy current api, but I see your point. however I'd like to reiterate that this is not what I am proposing. ; I think there is considerable difference between supporting arbitrary operations `new_obj = Qobj + netket_operator*5` (though if you are going to export dispatch hooks in `5.0`, this would be possible in a consistent way, I think) and `qutip.mesolve(netket_operator, ...)`. ; In the first, I do agree with your point that the nature python's `__add__/__radd__` is not commutative, leading",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1508#issuecomment-830113742
https://github.com/qutip/qutip/issues/1508#issuecomment-830113742:2027,Integrability,interface,interface,2027," trying to work towards a PR. Indeed. I was just trying to play around with this. . > If we're going to do this (and we haven't decided if we will yet), we're going to need to get a lot of wide-ranging input from many different libraries. I completely agree with your approach. I’m simply trying to push for this to be something that will come out in a reasonable timeframe and not be something forgotten. > We've got to be concerned with backwards and forwards compatibility; what if a user wants to install and use QuTiP and a different library in the same environment without using them together, but can't even have them coexist because of version incompatibilities in optional conversion features?. I do understand your point, and I see how you want to be backward and forward compatible, however I don’t think that my proposal would break different tools in the same environment. What I propose would simply prevent `qutip.Qobj(otherlibraryobject)` from working (with an explicative error message) if `otherlibrary` does not support the same qobj interface version. Everything else would work the same. You can still import and use the two libraries independently without issues. It’s indeed possible to design around this and supporting at the same time different versions of the interface, however, and there’s value in doing so. > To me, this is absolutely one of the mistakes that Numpy made in their implementation, and we shouldn't be copying it. I don't know enough of the history behind numpy current api, but I see your point. however I'd like to reiterate that this is not what I am proposing. ; I think there is considerable difference between supporting arbitrary operations `new_obj = Qobj + netket_operator*5` (though if you are going to export dispatch hooks in `5.0`, this would be possible in a consistent way, I think) and `qutip.mesolve(netket_operator, ...)`. ; In the first, I do agree with your point that the nature python's `__add__/__radd__` is not commutative, leading",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1508#issuecomment-830113742
https://github.com/qutip/qutip/issues/1508#issuecomment-830113742:2261,Integrability,interface,interface,2261,"h your approach. I’m simply trying to push for this to be something that will come out in a reasonable timeframe and not be something forgotten. > We've got to be concerned with backwards and forwards compatibility; what if a user wants to install and use QuTiP and a different library in the same environment without using them together, but can't even have them coexist because of version incompatibilities in optional conversion features?. I do understand your point, and I see how you want to be backward and forward compatible, however I don’t think that my proposal would break different tools in the same environment. What I propose would simply prevent `qutip.Qobj(otherlibraryobject)` from working (with an explicative error message) if `otherlibrary` does not support the same qobj interface version. Everything else would work the same. You can still import and use the two libraries independently without issues. It’s indeed possible to design around this and supporting at the same time different versions of the interface, however, and there’s value in doing so. > To me, this is absolutely one of the mistakes that Numpy made in their implementation, and we shouldn't be copying it. I don't know enough of the history behind numpy current api, but I see your point. however I'd like to reiterate that this is not what I am proposing. ; I think there is considerable difference between supporting arbitrary operations `new_obj = Qobj + netket_operator*5` (though if you are going to export dispatch hooks in `5.0`, this would be possible in a consistent way, I think) and `qutip.mesolve(netket_operator, ...)`. ; In the first, I do agree with your point that the nature python's `__add__/__radd__` is not commutative, leading to surprising behavior. From my point of view, no package really owns `+` so any conversion would be implicit.; But `qutip.groundstate(netket_operator)` is in itself an explicit cast. I am explicitly asking to qutip `please give me the ground state of this obj",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1508#issuecomment-830113742
https://github.com/qutip/qutip/issues/1508#issuecomment-830113742:4188,Performance,load,load,4188,"ame time different versions of the interface, however, and there’s value in doing so. > To me, this is absolutely one of the mistakes that Numpy made in their implementation, and we shouldn't be copying it. I don't know enough of the history behind numpy current api, but I see your point. however I'd like to reiterate that this is not what I am proposing. ; I think there is considerable difference between supporting arbitrary operations `new_obj = Qobj + netket_operator*5` (though if you are going to export dispatch hooks in `5.0`, this would be possible in a consistent way, I think) and `qutip.mesolve(netket_operator, ...)`. ; In the first, I do agree with your point that the nature python's `__add__/__radd__` is not commutative, leading to surprising behavior. From my point of view, no package really owns `+` so any conversion would be implicit.; But `qutip.groundstate(netket_operator)` is in itself an explicit cast. I am explicitly asking to qutip `please give me the ground state of this object`. I do expect to get a Qobj out, and qutip to make an effort converting this object to whatever format he internally wants to work with. Same goes with time evolution. . > For greater discussion, here's an alternate approach: instead of objects defining __qutip_qobj__, instead we expose an entry-point qutip.Qobj.register_conversion_function(converter, type, priority, version=None), and downstream libraries register functions rather than defining methods on their classes. I do prefer such an approach. I just did not think that was an option in QuTiP.; In fact we have redesigned NetKet to allow for something similar using multiple dispatch. (I’m not familiar with Tensorflow either.). I do agree with all your points, especially the first. As for your last point, about downstream packages having to import qutip: This is indeed a potential issue. I’ll try to investigate this: maybe there is a solution whereby a callback executed on package load can be registered with importlib?",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1508#issuecomment-830113742
https://github.com/qutip/qutip/issues/1508#issuecomment-830113742:3520,Security,expose,expose,3520,"ame time different versions of the interface, however, and there’s value in doing so. > To me, this is absolutely one of the mistakes that Numpy made in their implementation, and we shouldn't be copying it. I don't know enough of the history behind numpy current api, but I see your point. however I'd like to reiterate that this is not what I am proposing. ; I think there is considerable difference between supporting arbitrary operations `new_obj = Qobj + netket_operator*5` (though if you are going to export dispatch hooks in `5.0`, this would be possible in a consistent way, I think) and `qutip.mesolve(netket_operator, ...)`. ; In the first, I do agree with your point that the nature python's `__add__/__radd__` is not commutative, leading to surprising behavior. From my point of view, no package really owns `+` so any conversion would be implicit.; But `qutip.groundstate(netket_operator)` is in itself an explicit cast. I am explicitly asking to qutip `please give me the ground state of this object`. I do expect to get a Qobj out, and qutip to make an effort converting this object to whatever format he internally wants to work with. Same goes with time evolution. . > For greater discussion, here's an alternate approach: instead of objects defining __qutip_qobj__, instead we expose an entry-point qutip.Qobj.register_conversion_function(converter, type, priority, version=None), and downstream libraries register functions rather than defining methods on their classes. I do prefer such an approach. I just did not think that was an option in QuTiP.; In fact we have redesigned NetKet to allow for something similar using multiple dispatch. (I’m not familiar with Tensorflow either.). I do agree with all your points, especially the first. As for your last point, about downstream packages having to import qutip: This is indeed a potential issue. I’ll try to investigate this: maybe there is a solution whereby a callback executed on package load can be registered with importlib?",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1508#issuecomment-830113742
https://github.com/qutip/qutip/issues/1508#issuecomment-830113742:1256,Usability,simpl,simply,1256,"rsonally envisage an ecosystem where one can write down an hamiltonian in the tool of choice, obtain the exact time evolution with qutip, and maybe have a look at it’s semiclassical trajectory. Jump into netket and check if a variational representation can properly capture the correlations. Trotterize the hamiltonian and get a circuit, without worrying about how to convert from one framework to the other. . I want to start the discussion on this topic eagerly because I am aware that it will take a fairly long time. If there is anything I can do to make your future internal discussions easier, do let me know. > I just want to caution you in case you're trying to work towards a PR. Indeed. I was just trying to play around with this. . > If we're going to do this (and we haven't decided if we will yet), we're going to need to get a lot of wide-ranging input from many different libraries. I completely agree with your approach. I’m simply trying to push for this to be something that will come out in a reasonable timeframe and not be something forgotten. > We've got to be concerned with backwards and forwards compatibility; what if a user wants to install and use QuTiP and a different library in the same environment without using them together, but can't even have them coexist because of version incompatibilities in optional conversion features?. I do understand your point, and I see how you want to be backward and forward compatible, however I don’t think that my proposal would break different tools in the same environment. What I propose would simply prevent `qutip.Qobj(otherlibraryobject)` from working (with an explicative error message) if `otherlibrary` does not support the same qobj interface version. Everything else would work the same. You can still import and use the two libraries independently without issues. It’s indeed possible to design around this and supporting at the same time different versions of the interface, however, and there’s value in doing so. > T",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1508#issuecomment-830113742
https://github.com/qutip/qutip/issues/1508#issuecomment-830113742:1881,Usability,simpl,simply,1881,"ture internal discussions easier, do let me know. > I just want to caution you in case you're trying to work towards a PR. Indeed. I was just trying to play around with this. . > If we're going to do this (and we haven't decided if we will yet), we're going to need to get a lot of wide-ranging input from many different libraries. I completely agree with your approach. I’m simply trying to push for this to be something that will come out in a reasonable timeframe and not be something forgotten. > We've got to be concerned with backwards and forwards compatibility; what if a user wants to install and use QuTiP and a different library in the same environment without using them together, but can't even have them coexist because of version incompatibilities in optional conversion features?. I do understand your point, and I see how you want to be backward and forward compatible, however I don’t think that my proposal would break different tools in the same environment. What I propose would simply prevent `qutip.Qobj(otherlibraryobject)` from working (with an explicative error message) if `otherlibrary` does not support the same qobj interface version. Everything else would work the same. You can still import and use the two libraries independently without issues. It’s indeed possible to design around this and supporting at the same time different versions of the interface, however, and there’s value in doing so. > To me, this is absolutely one of the mistakes that Numpy made in their implementation, and we shouldn't be copying it. I don't know enough of the history behind numpy current api, but I see your point. however I'd like to reiterate that this is not what I am proposing. ; I think there is considerable difference between supporting arbitrary operations `new_obj = Qobj + netket_operator*5` (though if you are going to export dispatch hooks in `5.0`, this would be possible in a consistent way, I think) and `qutip.mesolve(netket_operator, ...)`. ; In the first, I do ",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1508#issuecomment-830113742
https://github.com/qutip/qutip/issues/1508#issuecomment-908328150:204,Usability,clear,clearly,204,"@PhilipVinc Hello! Apologies for the long wait -- I think this got lost in people's holidays and other goings on. I realized a few things while re-reading the long issue discussion:. 1. We need to define clearly what we want to propose. E.g. Initially the request was just for the constructor to work, i.e. `Qobj(netket_operator)`, and later in the discussion it expanded to include all operations and methods, e.g. `qutip.groundstate(netket_operator)`, `qobj * netket_operator`, ... . These are proposals of quite different scope. 2. There clearly isn't a huge advantage either way to having `Qobj(netket_operator)` vs `netket_operator.to_qobj()` except perhaps that people don't need to remember to what kind of thing `netket_operator` is exactly if they are swapping between libraries. 3. It is already *almost* possible to implement `Qobj(netket_operator)` on top of QuTiP v5 (i.e. the dev.major branch) without any changes to QuTiP itself and it might be beneficial to close that slight gap for multiple reasons. Posting example implementation in next comment.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1508#issuecomment-908328150
https://github.com/qutip/qutip/issues/1508#issuecomment-908328150:541,Usability,clear,clearly,541,"@PhilipVinc Hello! Apologies for the long wait -- I think this got lost in people's holidays and other goings on. I realized a few things while re-reading the long issue discussion:. 1. We need to define clearly what we want to propose. E.g. Initially the request was just for the constructor to work, i.e. `Qobj(netket_operator)`, and later in the discussion it expanded to include all operations and methods, e.g. `qutip.groundstate(netket_operator)`, `qobj * netket_operator`, ... . These are proposals of quite different scope. 2. There clearly isn't a huge advantage either way to having `Qobj(netket_operator)` vs `netket_operator.to_qobj()` except perhaps that people don't need to remember to what kind of thing `netket_operator` is exactly if they are swapping between libraries. 3. It is already *almost* possible to implement `Qobj(netket_operator)` on top of QuTiP v5 (i.e. the dev.major branch) without any changes to QuTiP itself and it might be beneficial to close that slight gap for multiple reasons. Posting example implementation in next comment.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1508#issuecomment-908328150
https://github.com/qutip/qutip/issues/1508#issuecomment-908336732:1798,Modifiability,flexible,flexible,1798,"Example implementation of `Qobj(thing)` with caveat noted below:; ```python; # qq.py; """""" A quick experiment with a Qobj creation API. """""". import qutip; import qutip.core.data. class NetketThing:; """""" An object with a __qutip_qobj__ method. """"""; def __init__(self, stuff):; self._stuff = stuff. def __qutip_qobj__(self, copy=True):; return qutip.Qobj(self._stuff, copy=copy). def _has_qutip_qobj_method(arg):; return getattr(arg, ""__qutip_qobj__"", None) is not None. def _call_qutip_qobj(arg, shape, copy=True):; # Note 1: shape argument intentionally ignored here -- arg should already; # know its dims and shape (possible a sanity check would be good); # Note 2: unfortunately, the .data object does not know the dims of; # of the Qobj, so the dims are lost. :/; return arg.__qutip_qobj__(copy=True).data. qutip.core.data.create.add_creators([; (_has_qutip_qobj_method, _call_qutip_qobj, 10),; ]); ```; Example usage:; ```python; # try_qq.py; """""" Trying out the experiment. """""". import qutip; import qq. nk = qq.NetketThing([0, 2]); q = qutip.Qobj(nk); qn = q.norm(); print(q); print(qn); ```; Explanation:; * `qutip.core.data.create` is the new Qobj data layer creation dispatcher. It's already called by `Qobj.__init__` after a few hardwired cases.; * We register a creator (i.e. a pair of functions) with priority 10. The first function checks whether `__qutip_qobj__` exists and the second function calls it if it does. Caveat:; * The creator provides no way to retrieve the `dims` from `arg` if the `arg` already knows what the `dims` should be. I can see a lot of uses for this so I propose we fix this part now regardless. Bonus:; * Adding this as a default creator gives us a good way to keep the creator list short while still supporting simple conversion of many objects to Qobjs in a flexible way. Thoughts?",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1508#issuecomment-908336732
https://github.com/qutip/qutip/issues/1508#issuecomment-908336732:627,Safety,sanity check,sanity check,627,"Example implementation of `Qobj(thing)` with caveat noted below:; ```python; # qq.py; """""" A quick experiment with a Qobj creation API. """""". import qutip; import qutip.core.data. class NetketThing:; """""" An object with a __qutip_qobj__ method. """"""; def __init__(self, stuff):; self._stuff = stuff. def __qutip_qobj__(self, copy=True):; return qutip.Qobj(self._stuff, copy=copy). def _has_qutip_qobj_method(arg):; return getattr(arg, ""__qutip_qobj__"", None) is not None. def _call_qutip_qobj(arg, shape, copy=True):; # Note 1: shape argument intentionally ignored here -- arg should already; # know its dims and shape (possible a sanity check would be good); # Note 2: unfortunately, the .data object does not know the dims of; # of the Qobj, so the dims are lost. :/; return arg.__qutip_qobj__(copy=True).data. qutip.core.data.create.add_creators([; (_has_qutip_qobj_method, _call_qutip_qobj, 10),; ]); ```; Example usage:; ```python; # try_qq.py; """""" Trying out the experiment. """""". import qutip; import qq. nk = qq.NetketThing([0, 2]); q = qutip.Qobj(nk); qn = q.norm(); print(q); print(qn); ```; Explanation:; * `qutip.core.data.create` is the new Qobj data layer creation dispatcher. It's already called by `Qobj.__init__` after a few hardwired cases.; * We register a creator (i.e. a pair of functions) with priority 10. The first function checks whether `__qutip_qobj__` exists and the second function calls it if it does. Caveat:; * The creator provides no way to retrieve the `dims` from `arg` if the `arg` already knows what the `dims` should be. I can see a lot of uses for this so I propose we fix this part now regardless. Bonus:; * Adding this as a default creator gives us a good way to keep the creator list short while still supporting simple conversion of many objects to Qobjs in a flexible way. Thoughts?",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1508#issuecomment-908336732
https://github.com/qutip/qutip/issues/1508#issuecomment-908336732:1750,Usability,simpl,simple,1750,"Example implementation of `Qobj(thing)` with caveat noted below:; ```python; # qq.py; """""" A quick experiment with a Qobj creation API. """""". import qutip; import qutip.core.data. class NetketThing:; """""" An object with a __qutip_qobj__ method. """"""; def __init__(self, stuff):; self._stuff = stuff. def __qutip_qobj__(self, copy=True):; return qutip.Qobj(self._stuff, copy=copy). def _has_qutip_qobj_method(arg):; return getattr(arg, ""__qutip_qobj__"", None) is not None. def _call_qutip_qobj(arg, shape, copy=True):; # Note 1: shape argument intentionally ignored here -- arg should already; # know its dims and shape (possible a sanity check would be good); # Note 2: unfortunately, the .data object does not know the dims of; # of the Qobj, so the dims are lost. :/; return arg.__qutip_qobj__(copy=True).data. qutip.core.data.create.add_creators([; (_has_qutip_qobj_method, _call_qutip_qobj, 10),; ]); ```; Example usage:; ```python; # try_qq.py; """""" Trying out the experiment. """""". import qutip; import qq. nk = qq.NetketThing([0, 2]); q = qutip.Qobj(nk); qn = q.norm(); print(q); print(qn); ```; Explanation:; * `qutip.core.data.create` is the new Qobj data layer creation dispatcher. It's already called by `Qobj.__init__` after a few hardwired cases.; * We register a creator (i.e. a pair of functions) with priority 10. The first function checks whether `__qutip_qobj__` exists and the second function calls it if it does. Caveat:; * The creator provides no way to retrieve the `dims` from `arg` if the `arg` already knows what the `dims` should be. I can see a lot of uses for this so I propose we fix this part now regardless. Bonus:; * Adding this as a default creator gives us a good way to keep the creator list short while still supporting simple conversion of many objects to Qobjs in a flexible way. Thoughts?",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1508#issuecomment-908336732
https://github.com/qutip/qutip/issues/1508#issuecomment-908360109:453,Integrability,protocol,protocol,453,"> Hi @hodgestar, thanks for chiming in!; > ; > What you posted here looks exactly like what I initially asked, so I am very much in favour of it.; > ; > I'm just slightly confused about what `_call_qutip_qobj` should return: in your example I assume `.data` is just a numpy/scipy matrix, so the `dims` data` is completely lost?. `_call_qutip_qobj` should return an instance of `qutip.core.data.Data` (i.e. an object that implements QuTiP 5's data layer protocol). > QuTiP's `dims` attribute is our `hilbert.shape` attribute, but of course the matrix representation has a different shape.; > If I am not mistaken in your example above this would result in the hilbert shape information being lost?. Correct.; ; > Is there no way we can preserve this information in some way?. My proposal is we should allow this information to be preserved. Some possible options I can see:. 1. Allow returning `dims` in addition to the `Data` object from the create function (bit ugly, only solves this one issue).; 2. Give the `Data` object a `dims` attribute that is usually `None` (probably not feasible because what should the dims of the result of `matmul(data_with_dims_none, data_with_dims_set)` be).; 3. Allow the creator function to return either `Data` or a full `Qobj` (requires some checking on all the places a `Qobj` is used).; 4. Add another creator (e.g. `create_qobj`) that only returns `Qobj`.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1508#issuecomment-908360109
https://github.com/qutip/qutip/issues/1508#issuecomment-908380301:227,Availability,down,downstream,227,"I'm sorry I don't have a huge amount of time at the moment, but just to add an extra point (that it looks like I didn't think about before): if we _do_ add this, then any method that requires an unconditional `import qutip` in downstream packages probably isn't a suitable solution - `import qutip` already takes far too long (though a lot of this is importing various parts of `scipy`, which another library might do on our behalf), and it means that they'd have to do their own import checking to handle optional dependencies. In that sense, (ab)using Python's duck-typing with a magic method might be the best way to break the dependency/import problem. I'm definitely still against implicit conversion to `Qobj` in pretty much any situation - I can imagine we could define a safe, fairly forward-compatible interface for letting people do `qutip.Qobj(x)`, but as it stands, that's the limit that I'd want the interface to be used for. I particularly am really against the idea of implicit conversion. I don't see an advantage to allowing QuTiP functions to act implicitly on other objects; it means our own functions are slower (because we have to explicitly test inputs on _everything_), and it restricts us more from improving `Qobj`'s internals, because we have to maintain compatibility with the interface. We'd never really be able to output anything _other_ than a `Qobj` without this, so there's no reason not to just have the user convert the inputs to `Qobj` explicitly themselves - that isolates the efficiency penalty so you only pay it if you need it, and it'll likely be clearer in the end anyway, because explicit is better for following the logic than implicit.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1508#issuecomment-908380301
https://github.com/qutip/qutip/issues/1508#issuecomment-908380301:515,Integrability,depend,dependencies,515,"I'm sorry I don't have a huge amount of time at the moment, but just to add an extra point (that it looks like I didn't think about before): if we _do_ add this, then any method that requires an unconditional `import qutip` in downstream packages probably isn't a suitable solution - `import qutip` already takes far too long (though a lot of this is importing various parts of `scipy`, which another library might do on our behalf), and it means that they'd have to do their own import checking to handle optional dependencies. In that sense, (ab)using Python's duck-typing with a magic method might be the best way to break the dependency/import problem. I'm definitely still against implicit conversion to `Qobj` in pretty much any situation - I can imagine we could define a safe, fairly forward-compatible interface for letting people do `qutip.Qobj(x)`, but as it stands, that's the limit that I'd want the interface to be used for. I particularly am really against the idea of implicit conversion. I don't see an advantage to allowing QuTiP functions to act implicitly on other objects; it means our own functions are slower (because we have to explicitly test inputs on _everything_), and it restricts us more from improving `Qobj`'s internals, because we have to maintain compatibility with the interface. We'd never really be able to output anything _other_ than a `Qobj` without this, so there's no reason not to just have the user convert the inputs to `Qobj` explicitly themselves - that isolates the efficiency penalty so you only pay it if you need it, and it'll likely be clearer in the end anyway, because explicit is better for following the logic than implicit.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1508#issuecomment-908380301
https://github.com/qutip/qutip/issues/1508#issuecomment-908380301:630,Integrability,depend,dependency,630,"I'm sorry I don't have a huge amount of time at the moment, but just to add an extra point (that it looks like I didn't think about before): if we _do_ add this, then any method that requires an unconditional `import qutip` in downstream packages probably isn't a suitable solution - `import qutip` already takes far too long (though a lot of this is importing various parts of `scipy`, which another library might do on our behalf), and it means that they'd have to do their own import checking to handle optional dependencies. In that sense, (ab)using Python's duck-typing with a magic method might be the best way to break the dependency/import problem. I'm definitely still against implicit conversion to `Qobj` in pretty much any situation - I can imagine we could define a safe, fairly forward-compatible interface for letting people do `qutip.Qobj(x)`, but as it stands, that's the limit that I'd want the interface to be used for. I particularly am really against the idea of implicit conversion. I don't see an advantage to allowing QuTiP functions to act implicitly on other objects; it means our own functions are slower (because we have to explicitly test inputs on _everything_), and it restricts us more from improving `Qobj`'s internals, because we have to maintain compatibility with the interface. We'd never really be able to output anything _other_ than a `Qobj` without this, so there's no reason not to just have the user convert the inputs to `Qobj` explicitly themselves - that isolates the efficiency penalty so you only pay it if you need it, and it'll likely be clearer in the end anyway, because explicit is better for following the logic than implicit.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1508#issuecomment-908380301
https://github.com/qutip/qutip/issues/1508#issuecomment-908380301:811,Integrability,interface,interface,811,"I'm sorry I don't have a huge amount of time at the moment, but just to add an extra point (that it looks like I didn't think about before): if we _do_ add this, then any method that requires an unconditional `import qutip` in downstream packages probably isn't a suitable solution - `import qutip` already takes far too long (though a lot of this is importing various parts of `scipy`, which another library might do on our behalf), and it means that they'd have to do their own import checking to handle optional dependencies. In that sense, (ab)using Python's duck-typing with a magic method might be the best way to break the dependency/import problem. I'm definitely still against implicit conversion to `Qobj` in pretty much any situation - I can imagine we could define a safe, fairly forward-compatible interface for letting people do `qutip.Qobj(x)`, but as it stands, that's the limit that I'd want the interface to be used for. I particularly am really against the idea of implicit conversion. I don't see an advantage to allowing QuTiP functions to act implicitly on other objects; it means our own functions are slower (because we have to explicitly test inputs on _everything_), and it restricts us more from improving `Qobj`'s internals, because we have to maintain compatibility with the interface. We'd never really be able to output anything _other_ than a `Qobj` without this, so there's no reason not to just have the user convert the inputs to `Qobj` explicitly themselves - that isolates the efficiency penalty so you only pay it if you need it, and it'll likely be clearer in the end anyway, because explicit is better for following the logic than implicit.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1508#issuecomment-908380301
https://github.com/qutip/qutip/issues/1508#issuecomment-908380301:913,Integrability,interface,interface,913,"I'm sorry I don't have a huge amount of time at the moment, but just to add an extra point (that it looks like I didn't think about before): if we _do_ add this, then any method that requires an unconditional `import qutip` in downstream packages probably isn't a suitable solution - `import qutip` already takes far too long (though a lot of this is importing various parts of `scipy`, which another library might do on our behalf), and it means that they'd have to do their own import checking to handle optional dependencies. In that sense, (ab)using Python's duck-typing with a magic method might be the best way to break the dependency/import problem. I'm definitely still against implicit conversion to `Qobj` in pretty much any situation - I can imagine we could define a safe, fairly forward-compatible interface for letting people do `qutip.Qobj(x)`, but as it stands, that's the limit that I'd want the interface to be used for. I particularly am really against the idea of implicit conversion. I don't see an advantage to allowing QuTiP functions to act implicitly on other objects; it means our own functions are slower (because we have to explicitly test inputs on _everything_), and it restricts us more from improving `Qobj`'s internals, because we have to maintain compatibility with the interface. We'd never really be able to output anything _other_ than a `Qobj` without this, so there's no reason not to just have the user convert the inputs to `Qobj` explicitly themselves - that isolates the efficiency penalty so you only pay it if you need it, and it'll likely be clearer in the end anyway, because explicit is better for following the logic than implicit.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1508#issuecomment-908380301
https://github.com/qutip/qutip/issues/1508#issuecomment-908380301:1304,Integrability,interface,interface,1304,"I'm sorry I don't have a huge amount of time at the moment, but just to add an extra point (that it looks like I didn't think about before): if we _do_ add this, then any method that requires an unconditional `import qutip` in downstream packages probably isn't a suitable solution - `import qutip` already takes far too long (though a lot of this is importing various parts of `scipy`, which another library might do on our behalf), and it means that they'd have to do their own import checking to handle optional dependencies. In that sense, (ab)using Python's duck-typing with a magic method might be the best way to break the dependency/import problem. I'm definitely still against implicit conversion to `Qobj` in pretty much any situation - I can imagine we could define a safe, fairly forward-compatible interface for letting people do `qutip.Qobj(x)`, but as it stands, that's the limit that I'd want the interface to be used for. I particularly am really against the idea of implicit conversion. I don't see an advantage to allowing QuTiP functions to act implicitly on other objects; it means our own functions are slower (because we have to explicitly test inputs on _everything_), and it restricts us more from improving `Qobj`'s internals, because we have to maintain compatibility with the interface. We'd never really be able to output anything _other_ than a `Qobj` without this, so there's no reason not to just have the user convert the inputs to `Qobj` explicitly themselves - that isolates the efficiency penalty so you only pay it if you need it, and it'll likely be clearer in the end anyway, because explicit is better for following the logic than implicit.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1508#issuecomment-908380301
https://github.com/qutip/qutip/issues/1508#issuecomment-908380301:779,Safety,safe,safe,779,"I'm sorry I don't have a huge amount of time at the moment, but just to add an extra point (that it looks like I didn't think about before): if we _do_ add this, then any method that requires an unconditional `import qutip` in downstream packages probably isn't a suitable solution - `import qutip` already takes far too long (though a lot of this is importing various parts of `scipy`, which another library might do on our behalf), and it means that they'd have to do their own import checking to handle optional dependencies. In that sense, (ab)using Python's duck-typing with a magic method might be the best way to break the dependency/import problem. I'm definitely still against implicit conversion to `Qobj` in pretty much any situation - I can imagine we could define a safe, fairly forward-compatible interface for letting people do `qutip.Qobj(x)`, but as it stands, that's the limit that I'd want the interface to be used for. I particularly am really against the idea of implicit conversion. I don't see an advantage to allowing QuTiP functions to act implicitly on other objects; it means our own functions are slower (because we have to explicitly test inputs on _everything_), and it restricts us more from improving `Qobj`'s internals, because we have to maintain compatibility with the interface. We'd never really be able to output anything _other_ than a `Qobj` without this, so there's no reason not to just have the user convert the inputs to `Qobj` explicitly themselves - that isolates the efficiency penalty so you only pay it if you need it, and it'll likely be clearer in the end anyway, because explicit is better for following the logic than implicit.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1508#issuecomment-908380301
https://github.com/qutip/qutip/issues/1508#issuecomment-908380301:1163,Testability,test,test,1163,"I'm sorry I don't have a huge amount of time at the moment, but just to add an extra point (that it looks like I didn't think about before): if we _do_ add this, then any method that requires an unconditional `import qutip` in downstream packages probably isn't a suitable solution - `import qutip` already takes far too long (though a lot of this is importing various parts of `scipy`, which another library might do on our behalf), and it means that they'd have to do their own import checking to handle optional dependencies. In that sense, (ab)using Python's duck-typing with a magic method might be the best way to break the dependency/import problem. I'm definitely still against implicit conversion to `Qobj` in pretty much any situation - I can imagine we could define a safe, fairly forward-compatible interface for letting people do `qutip.Qobj(x)`, but as it stands, that's the limit that I'd want the interface to be used for. I particularly am really against the idea of implicit conversion. I don't see an advantage to allowing QuTiP functions to act implicitly on other objects; it means our own functions are slower (because we have to explicitly test inputs on _everything_), and it restricts us more from improving `Qobj`'s internals, because we have to maintain compatibility with the interface. We'd never really be able to output anything _other_ than a `Qobj` without this, so there's no reason not to just have the user convert the inputs to `Qobj` explicitly themselves - that isolates the efficiency penalty so you only pay it if you need it, and it'll likely be clearer in the end anyway, because explicit is better for following the logic than implicit.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1508#issuecomment-908380301
https://github.com/qutip/qutip/issues/1508#issuecomment-908380301:1660,Testability,log,logic,1660,"I'm sorry I don't have a huge amount of time at the moment, but just to add an extra point (that it looks like I didn't think about before): if we _do_ add this, then any method that requires an unconditional `import qutip` in downstream packages probably isn't a suitable solution - `import qutip` already takes far too long (though a lot of this is importing various parts of `scipy`, which another library might do on our behalf), and it means that they'd have to do their own import checking to handle optional dependencies. In that sense, (ab)using Python's duck-typing with a magic method might be the best way to break the dependency/import problem. I'm definitely still against implicit conversion to `Qobj` in pretty much any situation - I can imagine we could define a safe, fairly forward-compatible interface for letting people do `qutip.Qobj(x)`, but as it stands, that's the limit that I'd want the interface to be used for. I particularly am really against the idea of implicit conversion. I don't see an advantage to allowing QuTiP functions to act implicitly on other objects; it means our own functions are slower (because we have to explicitly test inputs on _everything_), and it restricts us more from improving `Qobj`'s internals, because we have to maintain compatibility with the interface. We'd never really be able to output anything _other_ than a `Qobj` without this, so there's no reason not to just have the user convert the inputs to `Qobj` explicitly themselves - that isolates the efficiency penalty so you only pay it if you need it, and it'll likely be clearer in the end anyway, because explicit is better for following the logic than implicit.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1508#issuecomment-908380301
https://github.com/qutip/qutip/issues/1508#issuecomment-908380301:1588,Usability,clear,clearer,1588,"I'm sorry I don't have a huge amount of time at the moment, but just to add an extra point (that it looks like I didn't think about before): if we _do_ add this, then any method that requires an unconditional `import qutip` in downstream packages probably isn't a suitable solution - `import qutip` already takes far too long (though a lot of this is importing various parts of `scipy`, which another library might do on our behalf), and it means that they'd have to do their own import checking to handle optional dependencies. In that sense, (ab)using Python's duck-typing with a magic method might be the best way to break the dependency/import problem. I'm definitely still against implicit conversion to `Qobj` in pretty much any situation - I can imagine we could define a safe, fairly forward-compatible interface for letting people do `qutip.Qobj(x)`, but as it stands, that's the limit that I'd want the interface to be used for. I particularly am really against the idea of implicit conversion. I don't see an advantage to allowing QuTiP functions to act implicitly on other objects; it means our own functions are slower (because we have to explicitly test inputs on _everything_), and it restricts us more from improving `Qobj`'s internals, because we have to maintain compatibility with the interface. We'd never really be able to output anything _other_ than a `Qobj` without this, so there's no reason not to just have the user convert the inputs to `Qobj` explicitly themselves - that isolates the efficiency penalty so you only pay it if you need it, and it'll likely be clearer in the end anyway, because explicit is better for following the logic than implicit.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1508#issuecomment-908380301
https://github.com/qutip/qutip/issues/1508#issuecomment-913661687:149,Availability,down,downstream,149,"@jakelishman, about the two issues you raised:. 1. Import time related to `import qutip`; I agree with you that in order to make it frictionless for downstream libraries to implement qutip's interface you'd want not to increase their loading times. That would easily be achieved by defining the `__qutip_qobj__` as the entry point of this API. A drawback of this implementation is that it requires the conversion method to be defined on the object itself.; The dispatch-like solution, as was proposed by @hodgestar, is easier to play with, can be defined in a separate file, can be added to a separate package like `netket_qutip_interop` or even using setuptools entry points, though that would add complexity. Again, I'm personally not biased. I would go with option 1 because it's simpler, but I do like the organisational beauty of option 2 (that is used throughout the jax ecosystem). 2. About implicit conversion; - Assume we can distinguish two level of APIs exposed by qutip, similar in spirit to the distinction there is between BLAS and LAPACK. ; - There are low level (BLAS-like) operations on Qobjs such as addition, kron, sum, ecc that are performed repeatedly, can be efficiently implemented only among objects whose data structure is well know. Everything is built on top of those, so they need to be fast with a low overhead. ; - There are higher-level (LAPACK-like) operations on Qobjs, such as `.eigenvalues()` or `eigenstates()`, or `sesolve/mesolve` which are built by combining several low level operations. Their runtime is much higher, and they perform a fair bit of setup/input handling, which comes at the price of some overhead, but which is negligible compared to the runtime cost for most meaningfully large systems. I'd then like to state that; - *I have never suggested to insert a mechanism to insert implicit conversion in the low-level operations.* ; - In this RFC in no way have I proposed to implement implicit conversion anywhere else then were is already done in qu",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1508#issuecomment-913661687
https://github.com/qutip/qutip/issues/1508#issuecomment-913661687:2749,Availability,avail,available,2749,"t handling, which comes at the price of some overhead, but which is negligible compared to the runtime cost for most meaningfully large systems. I'd then like to state that; - *I have never suggested to insert a mechanism to insert implicit conversion in the low-level operations.* ; - In this RFC in no way have I proposed to implement implicit conversion anywhere else then were is already done in qutip itself. All I stated was that `I played around with auto-converting input hamiltonians and jump operators in qutip.sesolve and mesolve to Qobj if they are not Qobj but support the interface. That is even nicer because we would get to use all of qutip solvers out of the box with our objects.`. ; - So implicitly I do have stated that I'd like to see implicit conversion being performed on high-level methods. I do see benefits for the whole ecosystem if we can start integrating more: qutip already has very advanced and feature-complete solvers, there are large benefits for other packages to exploit them without having to wrap them or ask users to write more complicated code. It means that all benefits and bug-fixes to qutip are instantly available to users of other packages too that rely on it. And I think that calling a conversion method at the beginning, which most of the time will do nothing will just be a tiny drop in the bucket of the overhead of those `large` functions. However, I don't want to argue that right now. All my proposal was about was having a way to play well with your `Qobj` constructor.; It seems to me you were eventually favourable to this, so I propose we focus the discussion only on this point, and leave aside implicit or explicit conversion discussions. . I'll gladly open another issue to discuss implicit conversion, if you want, or we could organise a small round table among a bunch of developers to talk about this on skype, but for now, all i'm asking, is to agree on the design of an interface to allow easy conversion of objects to qutip objects.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1508#issuecomment-913661687
https://github.com/qutip/qutip/issues/1508#issuecomment-913661687:2472,Deployability,integrat,integrating,2472,"h higher, and they perform a fair bit of setup/input handling, which comes at the price of some overhead, but which is negligible compared to the runtime cost for most meaningfully large systems. I'd then like to state that; - *I have never suggested to insert a mechanism to insert implicit conversion in the low-level operations.* ; - In this RFC in no way have I proposed to implement implicit conversion anywhere else then were is already done in qutip itself. All I stated was that `I played around with auto-converting input hamiltonians and jump operators in qutip.sesolve and mesolve to Qobj if they are not Qobj but support the interface. That is even nicer because we would get to use all of qutip solvers out of the box with our objects.`. ; - So implicitly I do have stated that I'd like to see implicit conversion being performed on high-level methods. I do see benefits for the whole ecosystem if we can start integrating more: qutip already has very advanced and feature-complete solvers, there are large benefits for other packages to exploit them without having to wrap them or ask users to write more complicated code. It means that all benefits and bug-fixes to qutip are instantly available to users of other packages too that rely on it. And I think that calling a conversion method at the beginning, which most of the time will do nothing will just be a tiny drop in the bucket of the overhead of those `large` functions. However, I don't want to argue that right now. All my proposal was about was having a way to play well with your `Qobj` constructor.; It seems to me you were eventually favourable to this, so I propose we focus the discussion only on this point, and leave aside implicit or explicit conversion discussions. . I'll gladly open another issue to discuss implicit conversion, if you want, or we could organise a small round table among a bunch of developers to talk about this on skype, but for now, all i'm asking, is to agree on the design of an interface to ",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1508#issuecomment-913661687
https://github.com/qutip/qutip/issues/1508#issuecomment-913661687:1181,Energy Efficiency,efficient,efficiently,1181,"ream libraries to implement qutip's interface you'd want not to increase their loading times. That would easily be achieved by defining the `__qutip_qobj__` as the entry point of this API. A drawback of this implementation is that it requires the conversion method to be defined on the object itself.; The dispatch-like solution, as was proposed by @hodgestar, is easier to play with, can be defined in a separate file, can be added to a separate package like `netket_qutip_interop` or even using setuptools entry points, though that would add complexity. Again, I'm personally not biased. I would go with option 1 because it's simpler, but I do like the organisational beauty of option 2 (that is used throughout the jax ecosystem). 2. About implicit conversion; - Assume we can distinguish two level of APIs exposed by qutip, similar in spirit to the distinction there is between BLAS and LAPACK. ; - There are low level (BLAS-like) operations on Qobjs such as addition, kron, sum, ecc that are performed repeatedly, can be efficiently implemented only among objects whose data structure is well know. Everything is built on top of those, so they need to be fast with a low overhead. ; - There are higher-level (LAPACK-like) operations on Qobjs, such as `.eigenvalues()` or `eigenstates()`, or `sesolve/mesolve` which are built by combining several low level operations. Their runtime is much higher, and they perform a fair bit of setup/input handling, which comes at the price of some overhead, but which is negligible compared to the runtime cost for most meaningfully large systems. I'd then like to state that; - *I have never suggested to insert a mechanism to insert implicit conversion in the low-level operations.* ; - In this RFC in no way have I proposed to implement implicit conversion anywhere else then were is already done in qutip itself. All I stated was that `I played around with auto-converting input hamiltonians and jump operators in qutip.sesolve and mesolve to Qobj if they ",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1508#issuecomment-913661687
https://github.com/qutip/qutip/issues/1508#issuecomment-913661687:191,Integrability,interface,interface,191,"@jakelishman, about the two issues you raised:. 1. Import time related to `import qutip`; I agree with you that in order to make it frictionless for downstream libraries to implement qutip's interface you'd want not to increase their loading times. That would easily be achieved by defining the `__qutip_qobj__` as the entry point of this API. A drawback of this implementation is that it requires the conversion method to be defined on the object itself.; The dispatch-like solution, as was proposed by @hodgestar, is easier to play with, can be defined in a separate file, can be added to a separate package like `netket_qutip_interop` or even using setuptools entry points, though that would add complexity. Again, I'm personally not biased. I would go with option 1 because it's simpler, but I do like the organisational beauty of option 2 (that is used throughout the jax ecosystem). 2. About implicit conversion; - Assume we can distinguish two level of APIs exposed by qutip, similar in spirit to the distinction there is between BLAS and LAPACK. ; - There are low level (BLAS-like) operations on Qobjs such as addition, kron, sum, ecc that are performed repeatedly, can be efficiently implemented only among objects whose data structure is well know. Everything is built on top of those, so they need to be fast with a low overhead. ; - There are higher-level (LAPACK-like) operations on Qobjs, such as `.eigenvalues()` or `eigenstates()`, or `sesolve/mesolve` which are built by combining several low level operations. Their runtime is much higher, and they perform a fair bit of setup/input handling, which comes at the price of some overhead, but which is negligible compared to the runtime cost for most meaningfully large systems. I'd then like to state that; - *I have never suggested to insert a mechanism to insert implicit conversion in the low-level operations.* ; - In this RFC in no way have I proposed to implement implicit conversion anywhere else then were is already done in qu",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1508#issuecomment-913661687
https://github.com/qutip/qutip/issues/1508#issuecomment-913661687:2185,Integrability,interface,interface,2185,"rmed repeatedly, can be efficiently implemented only among objects whose data structure is well know. Everything is built on top of those, so they need to be fast with a low overhead. ; - There are higher-level (LAPACK-like) operations on Qobjs, such as `.eigenvalues()` or `eigenstates()`, or `sesolve/mesolve` which are built by combining several low level operations. Their runtime is much higher, and they perform a fair bit of setup/input handling, which comes at the price of some overhead, but which is negligible compared to the runtime cost for most meaningfully large systems. I'd then like to state that; - *I have never suggested to insert a mechanism to insert implicit conversion in the low-level operations.* ; - In this RFC in no way have I proposed to implement implicit conversion anywhere else then were is already done in qutip itself. All I stated was that `I played around with auto-converting input hamiltonians and jump operators in qutip.sesolve and mesolve to Qobj if they are not Qobj but support the interface. That is even nicer because we would get to use all of qutip solvers out of the box with our objects.`. ; - So implicitly I do have stated that I'd like to see implicit conversion being performed on high-level methods. I do see benefits for the whole ecosystem if we can start integrating more: qutip already has very advanced and feature-complete solvers, there are large benefits for other packages to exploit them without having to wrap them or ask users to write more complicated code. It means that all benefits and bug-fixes to qutip are instantly available to users of other packages too that rely on it. And I think that calling a conversion method at the beginning, which most of the time will do nothing will just be a tiny drop in the bucket of the overhead of those `large` functions. However, I don't want to argue that right now. All my proposal was about was having a way to play well with your `Qobj` constructor.; It seems to me you were eventual",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1508#issuecomment-913661687
https://github.com/qutip/qutip/issues/1508#issuecomment-913661687:2472,Integrability,integrat,integrating,2472,"h higher, and they perform a fair bit of setup/input handling, which comes at the price of some overhead, but which is negligible compared to the runtime cost for most meaningfully large systems. I'd then like to state that; - *I have never suggested to insert a mechanism to insert implicit conversion in the low-level operations.* ; - In this RFC in no way have I proposed to implement implicit conversion anywhere else then were is already done in qutip itself. All I stated was that `I played around with auto-converting input hamiltonians and jump operators in qutip.sesolve and mesolve to Qobj if they are not Qobj but support the interface. That is even nicer because we would get to use all of qutip solvers out of the box with our objects.`. ; - So implicitly I do have stated that I'd like to see implicit conversion being performed on high-level methods. I do see benefits for the whole ecosystem if we can start integrating more: qutip already has very advanced and feature-complete solvers, there are large benefits for other packages to exploit them without having to wrap them or ask users to write more complicated code. It means that all benefits and bug-fixes to qutip are instantly available to users of other packages too that rely on it. And I think that calling a conversion method at the beginning, which most of the time will do nothing will just be a tiny drop in the bucket of the overhead of those `large` functions. However, I don't want to argue that right now. All my proposal was about was having a way to play well with your `Qobj` constructor.; It seems to me you were eventually favourable to this, so I propose we focus the discussion only on this point, and leave aside implicit or explicit conversion discussions. . I'll gladly open another issue to discuss implicit conversion, if you want, or we could organise a small round table among a bunch of developers to talk about this on skype, but for now, all i'm asking, is to agree on the design of an interface to ",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1508#issuecomment-913661687
https://github.com/qutip/qutip/issues/1508#issuecomment-913661687:2630,Integrability,wrap,wrap,2630,"h higher, and they perform a fair bit of setup/input handling, which comes at the price of some overhead, but which is negligible compared to the runtime cost for most meaningfully large systems. I'd then like to state that; - *I have never suggested to insert a mechanism to insert implicit conversion in the low-level operations.* ; - In this RFC in no way have I proposed to implement implicit conversion anywhere else then were is already done in qutip itself. All I stated was that `I played around with auto-converting input hamiltonians and jump operators in qutip.sesolve and mesolve to Qobj if they are not Qobj but support the interface. That is even nicer because we would get to use all of qutip solvers out of the box with our objects.`. ; - So implicitly I do have stated that I'd like to see implicit conversion being performed on high-level methods. I do see benefits for the whole ecosystem if we can start integrating more: qutip already has very advanced and feature-complete solvers, there are large benefits for other packages to exploit them without having to wrap them or ask users to write more complicated code. It means that all benefits and bug-fixes to qutip are instantly available to users of other packages too that rely on it. And I think that calling a conversion method at the beginning, which most of the time will do nothing will just be a tiny drop in the bucket of the overhead of those `large` functions. However, I don't want to argue that right now. All my proposal was about was having a way to play well with your `Qobj` constructor.; It seems to me you were eventually favourable to this, so I propose we focus the discussion only on this point, and leave aside implicit or explicit conversion discussions. . I'll gladly open another issue to discuss implicit conversion, if you want, or we could organise a small round table among a bunch of developers to talk about this on skype, but for now, all i'm asking, is to agree on the design of an interface to ",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1508#issuecomment-913661687
https://github.com/qutip/qutip/issues/1508#issuecomment-913661687:3536,Integrability,interface,interface,3536,"t handling, which comes at the price of some overhead, but which is negligible compared to the runtime cost for most meaningfully large systems. I'd then like to state that; - *I have never suggested to insert a mechanism to insert implicit conversion in the low-level operations.* ; - In this RFC in no way have I proposed to implement implicit conversion anywhere else then were is already done in qutip itself. All I stated was that `I played around with auto-converting input hamiltonians and jump operators in qutip.sesolve and mesolve to Qobj if they are not Qobj but support the interface. That is even nicer because we would get to use all of qutip solvers out of the box with our objects.`. ; - So implicitly I do have stated that I'd like to see implicit conversion being performed on high-level methods. I do see benefits for the whole ecosystem if we can start integrating more: qutip already has very advanced and feature-complete solvers, there are large benefits for other packages to exploit them without having to wrap them or ask users to write more complicated code. It means that all benefits and bug-fixes to qutip are instantly available to users of other packages too that rely on it. And I think that calling a conversion method at the beginning, which most of the time will do nothing will just be a tiny drop in the bucket of the overhead of those `large` functions. However, I don't want to argue that right now. All my proposal was about was having a way to play well with your `Qobj` constructor.; It seems to me you were eventually favourable to this, so I propose we focus the discussion only on this point, and leave aside implicit or explicit conversion discussions. . I'll gladly open another issue to discuss implicit conversion, if you want, or we could organise a small round table among a bunch of developers to talk about this on skype, but for now, all i'm asking, is to agree on the design of an interface to allow easy conversion of objects to qutip objects.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1508#issuecomment-913661687
https://github.com/qutip/qutip/issues/1508#issuecomment-913661687:234,Performance,load,loading,234,"@jakelishman, about the two issues you raised:. 1. Import time related to `import qutip`; I agree with you that in order to make it frictionless for downstream libraries to implement qutip's interface you'd want not to increase their loading times. That would easily be achieved by defining the `__qutip_qobj__` as the entry point of this API. A drawback of this implementation is that it requires the conversion method to be defined on the object itself.; The dispatch-like solution, as was proposed by @hodgestar, is easier to play with, can be defined in a separate file, can be added to a separate package like `netket_qutip_interop` or even using setuptools entry points, though that would add complexity. Again, I'm personally not biased. I would go with option 1 because it's simpler, but I do like the organisational beauty of option 2 (that is used throughout the jax ecosystem). 2. About implicit conversion; - Assume we can distinguish two level of APIs exposed by qutip, similar in spirit to the distinction there is between BLAS and LAPACK. ; - There are low level (BLAS-like) operations on Qobjs such as addition, kron, sum, ecc that are performed repeatedly, can be efficiently implemented only among objects whose data structure is well know. Everything is built on top of those, so they need to be fast with a low overhead. ; - There are higher-level (LAPACK-like) operations on Qobjs, such as `.eigenvalues()` or `eigenstates()`, or `sesolve/mesolve` which are built by combining several low level operations. Their runtime is much higher, and they perform a fair bit of setup/input handling, which comes at the price of some overhead, but which is negligible compared to the runtime cost for most meaningfully large systems. I'd then like to state that; - *I have never suggested to insert a mechanism to insert implicit conversion in the low-level operations.* ; - In this RFC in no way have I proposed to implement implicit conversion anywhere else then were is already done in qu",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1508#issuecomment-913661687
https://github.com/qutip/qutip/issues/1508#issuecomment-913661687:1152,Performance,perform,performed,1152,"ream libraries to implement qutip's interface you'd want not to increase their loading times. That would easily be achieved by defining the `__qutip_qobj__` as the entry point of this API. A drawback of this implementation is that it requires the conversion method to be defined on the object itself.; The dispatch-like solution, as was proposed by @hodgestar, is easier to play with, can be defined in a separate file, can be added to a separate package like `netket_qutip_interop` or even using setuptools entry points, though that would add complexity. Again, I'm personally not biased. I would go with option 1 because it's simpler, but I do like the organisational beauty of option 2 (that is used throughout the jax ecosystem). 2. About implicit conversion; - Assume we can distinguish two level of APIs exposed by qutip, similar in spirit to the distinction there is between BLAS and LAPACK. ; - There are low level (BLAS-like) operations on Qobjs such as addition, kron, sum, ecc that are performed repeatedly, can be efficiently implemented only among objects whose data structure is well know. Everything is built on top of those, so they need to be fast with a low overhead. ; - There are higher-level (LAPACK-like) operations on Qobjs, such as `.eigenvalues()` or `eigenstates()`, or `sesolve/mesolve` which are built by combining several low level operations. Their runtime is much higher, and they perform a fair bit of setup/input handling, which comes at the price of some overhead, but which is negligible compared to the runtime cost for most meaningfully large systems. I'd then like to state that; - *I have never suggested to insert a mechanism to insert implicit conversion in the low-level operations.* ; - In this RFC in no way have I proposed to implement implicit conversion anywhere else then were is already done in qutip itself. All I stated was that `I played around with auto-converting input hamiltonians and jump operators in qutip.sesolve and mesolve to Qobj if they ",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1508#issuecomment-913661687
https://github.com/qutip/qutip/issues/1508#issuecomment-913661687:1567,Performance,perform,perform,1567,"p` or even using setuptools entry points, though that would add complexity. Again, I'm personally not biased. I would go with option 1 because it's simpler, but I do like the organisational beauty of option 2 (that is used throughout the jax ecosystem). 2. About implicit conversion; - Assume we can distinguish two level of APIs exposed by qutip, similar in spirit to the distinction there is between BLAS and LAPACK. ; - There are low level (BLAS-like) operations on Qobjs such as addition, kron, sum, ecc that are performed repeatedly, can be efficiently implemented only among objects whose data structure is well know. Everything is built on top of those, so they need to be fast with a low overhead. ; - There are higher-level (LAPACK-like) operations on Qobjs, such as `.eigenvalues()` or `eigenstates()`, or `sesolve/mesolve` which are built by combining several low level operations. Their runtime is much higher, and they perform a fair bit of setup/input handling, which comes at the price of some overhead, but which is negligible compared to the runtime cost for most meaningfully large systems. I'd then like to state that; - *I have never suggested to insert a mechanism to insert implicit conversion in the low-level operations.* ; - In this RFC in no way have I proposed to implement implicit conversion anywhere else then were is already done in qutip itself. All I stated was that `I played around with auto-converting input hamiltonians and jump operators in qutip.sesolve and mesolve to Qobj if they are not Qobj but support the interface. That is even nicer because we would get to use all of qutip solvers out of the box with our objects.`. ; - So implicitly I do have stated that I'd like to see implicit conversion being performed on high-level methods. I do see benefits for the whole ecosystem if we can start integrating more: qutip already has very advanced and feature-complete solvers, there are large benefits for other packages to exploit them without having to wrap ",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1508#issuecomment-913661687
https://github.com/qutip/qutip/issues/1508#issuecomment-913661687:2381,Performance,perform,performed,2381,"higher-level (LAPACK-like) operations on Qobjs, such as `.eigenvalues()` or `eigenstates()`, or `sesolve/mesolve` which are built by combining several low level operations. Their runtime is much higher, and they perform a fair bit of setup/input handling, which comes at the price of some overhead, but which is negligible compared to the runtime cost for most meaningfully large systems. I'd then like to state that; - *I have never suggested to insert a mechanism to insert implicit conversion in the low-level operations.* ; - In this RFC in no way have I proposed to implement implicit conversion anywhere else then were is already done in qutip itself. All I stated was that `I played around with auto-converting input hamiltonians and jump operators in qutip.sesolve and mesolve to Qobj if they are not Qobj but support the interface. That is even nicer because we would get to use all of qutip solvers out of the box with our objects.`. ; - So implicitly I do have stated that I'd like to see implicit conversion being performed on high-level methods. I do see benefits for the whole ecosystem if we can start integrating more: qutip already has very advanced and feature-complete solvers, there are large benefits for other packages to exploit them without having to wrap them or ask users to write more complicated code. It means that all benefits and bug-fixes to qutip are instantly available to users of other packages too that rely on it. And I think that calling a conversion method at the beginning, which most of the time will do nothing will just be a tiny drop in the bucket of the overhead of those `large` functions. However, I don't want to argue that right now. All my proposal was about was having a way to play well with your `Qobj` constructor.; It seems to me you were eventually favourable to this, so I propose we focus the discussion only on this point, and leave aside implicit or explicit conversion discussions. . I'll gladly open another issue to discuss implicit conv",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1508#issuecomment-913661687
https://github.com/qutip/qutip/issues/1508#issuecomment-913661687:965,Security,expose,exposed,965,"@jakelishman, about the two issues you raised:. 1. Import time related to `import qutip`; I agree with you that in order to make it frictionless for downstream libraries to implement qutip's interface you'd want not to increase their loading times. That would easily be achieved by defining the `__qutip_qobj__` as the entry point of this API. A drawback of this implementation is that it requires the conversion method to be defined on the object itself.; The dispatch-like solution, as was proposed by @hodgestar, is easier to play with, can be defined in a separate file, can be added to a separate package like `netket_qutip_interop` or even using setuptools entry points, though that would add complexity. Again, I'm personally not biased. I would go with option 1 because it's simpler, but I do like the organisational beauty of option 2 (that is used throughout the jax ecosystem). 2. About implicit conversion; - Assume we can distinguish two level of APIs exposed by qutip, similar in spirit to the distinction there is between BLAS and LAPACK. ; - There are low level (BLAS-like) operations on Qobjs such as addition, kron, sum, ecc that are performed repeatedly, can be efficiently implemented only among objects whose data structure is well know. Everything is built on top of those, so they need to be fast with a low overhead. ; - There are higher-level (LAPACK-like) operations on Qobjs, such as `.eigenvalues()` or `eigenstates()`, or `sesolve/mesolve` which are built by combining several low level operations. Their runtime is much higher, and they perform a fair bit of setup/input handling, which comes at the price of some overhead, but which is negligible compared to the runtime cost for most meaningfully large systems. I'd then like to state that; - *I have never suggested to insert a mechanism to insert implicit conversion in the low-level operations.* ; - In this RFC in no way have I proposed to implement implicit conversion anywhere else then were is already done in qu",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1508#issuecomment-913661687
https://github.com/qutip/qutip/issues/1508#issuecomment-913661687:783,Usability,simpl,simpler,783,"@jakelishman, about the two issues you raised:. 1. Import time related to `import qutip`; I agree with you that in order to make it frictionless for downstream libraries to implement qutip's interface you'd want not to increase their loading times. That would easily be achieved by defining the `__qutip_qobj__` as the entry point of this API. A drawback of this implementation is that it requires the conversion method to be defined on the object itself.; The dispatch-like solution, as was proposed by @hodgestar, is easier to play with, can be defined in a separate file, can be added to a separate package like `netket_qutip_interop` or even using setuptools entry points, though that would add complexity. Again, I'm personally not biased. I would go with option 1 because it's simpler, but I do like the organisational beauty of option 2 (that is used throughout the jax ecosystem). 2. About implicit conversion; - Assume we can distinguish two level of APIs exposed by qutip, similar in spirit to the distinction there is between BLAS and LAPACK. ; - There are low level (BLAS-like) operations on Qobjs such as addition, kron, sum, ecc that are performed repeatedly, can be efficiently implemented only among objects whose data structure is well know. Everything is built on top of those, so they need to be fast with a low overhead. ; - There are higher-level (LAPACK-like) operations on Qobjs, such as `.eigenvalues()` or `eigenstates()`, or `sesolve/mesolve` which are built by combining several low level operations. Their runtime is much higher, and they perform a fair bit of setup/input handling, which comes at the price of some overhead, but which is negligible compared to the runtime cost for most meaningfully large systems. I'd then like to state that; - *I have never suggested to insert a mechanism to insert implicit conversion in the low-level operations.* ; - In this RFC in no way have I proposed to implement implicit conversion anywhere else then were is already done in qu",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1508#issuecomment-913661687
https://github.com/qutip/qutip/issues/1508#issuecomment-951087841:131,Integrability,interface,interface,131,"Apologies for another long delay. I'd be happy to hop on a video call sometime to discuss the design. I think the `__qutip_qobj__` interface is likely to remain fairly simple and be just:; ```python; def __qutip_qobj__(self, copy=True):; """""" Return a Qobj representation of this object. Parameters; ---------------; copy : {True, False}, default True; If True, a new independent Qobj should be returned. If False, a reference to an existing Qobj; may be returned. Returns; ----------; Qobj; The Qobj representation of this object.; """""" ; return qutip.Qobj(self._stuff, copy=copy); ```; and we can figure out how to make that work on our side. How that looks under the hood depends quite a bit on whether the `Data` object will grow `dims` support or not. We have another use case for `dims` on the data layer (a tensor network data backend that we're starting work on) but it is a bit of a philosophical shift in what the `Data` layer is, so we'll need to think carefully (e.g. all `Data` operations would have to keep track of `dims` which is a big change; and it's also a bit strange because the operations themselves are just 2D matrix operations, where dims are meaningless). @PhilipVinc I'm not sure if we discussed this before, but do you have some short code snippets showing how you see this Qobj support being used in user code? Apologies if I missed such examples elsewhere in the discussion already.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1508#issuecomment-951087841
https://github.com/qutip/qutip/issues/1508#issuecomment-951087841:673,Integrability,depend,depends,673,"Apologies for another long delay. I'd be happy to hop on a video call sometime to discuss the design. I think the `__qutip_qobj__` interface is likely to remain fairly simple and be just:; ```python; def __qutip_qobj__(self, copy=True):; """""" Return a Qobj representation of this object. Parameters; ---------------; copy : {True, False}, default True; If True, a new independent Qobj should be returned. If False, a reference to an existing Qobj; may be returned. Returns; ----------; Qobj; The Qobj representation of this object.; """""" ; return qutip.Qobj(self._stuff, copy=copy); ```; and we can figure out how to make that work on our side. How that looks under the hood depends quite a bit on whether the `Data` object will grow `dims` support or not. We have another use case for `dims` on the data layer (a tensor network data backend that we're starting work on) but it is a bit of a philosophical shift in what the `Data` layer is, so we'll need to think carefully (e.g. all `Data` operations would have to keep track of `dims` which is a big change; and it's also a bit strange because the operations themselves are just 2D matrix operations, where dims are meaningless). @PhilipVinc I'm not sure if we discussed this before, but do you have some short code snippets showing how you see this Qobj support being used in user code? Apologies if I missed such examples elsewhere in the discussion already.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1508#issuecomment-951087841
https://github.com/qutip/qutip/issues/1508#issuecomment-951087841:168,Usability,simpl,simple,168,"Apologies for another long delay. I'd be happy to hop on a video call sometime to discuss the design. I think the `__qutip_qobj__` interface is likely to remain fairly simple and be just:; ```python; def __qutip_qobj__(self, copy=True):; """""" Return a Qobj representation of this object. Parameters; ---------------; copy : {True, False}, default True; If True, a new independent Qobj should be returned. If False, a reference to an existing Qobj; may be returned. Returns; ----------; Qobj; The Qobj representation of this object.; """""" ; return qutip.Qobj(self._stuff, copy=copy); ```; and we can figure out how to make that work on our side. How that looks under the hood depends quite a bit on whether the `Data` object will grow `dims` support or not. We have another use case for `dims` on the data layer (a tensor network data backend that we're starting work on) but it is a bit of a philosophical shift in what the `Data` layer is, so we'll need to think carefully (e.g. all `Data` operations would have to keep track of `dims` which is a big change; and it's also a bit strange because the operations themselves are just 2D matrix operations, where dims are meaningless). @PhilipVinc I'm not sure if we discussed this before, but do you have some short code snippets showing how you see this Qobj support being used in user code? Apologies if I missed such examples elsewhere in the discussion already.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1508#issuecomment-951087841
https://github.com/qutip/qutip/pull/1509#issuecomment-826262854:46,Testability,test,test,46,Made a change to `test_mesolve.py ` because a test was failing.,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1509#issuecomment-826262854
https://github.com/qutip/qutip/pull/1509#issuecomment-831499015:30,Testability,test,test,30,"> can you add some cases that test N is calculated correctly including implicit tensor structure in dims, because that's what this is meant to be most useful for, right?. @jakelishman I have added 2 more functions to test N and tensor shape. I was a bit confused about how to check for tensor structure in dims. So, I check if the shape of output matches to what it is supposed to be. . Would you prefer these functions be combined into one ?",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1509#issuecomment-831499015
https://github.com/qutip/qutip/pull/1509#issuecomment-831499015:217,Testability,test,test,217,"> can you add some cases that test N is calculated correctly including implicit tensor structure in dims, because that's what this is meant to be most useful for, right?. @jakelishman I have added 2 more functions to test N and tensor shape. I was a bit confused about how to check for tensor structure in dims. So, I check if the shape of output matches to what it is supposed to be. . Would you prefer these functions be combined into one ?",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1509#issuecomment-831499015
https://github.com/qutip/qutip/pull/1509#issuecomment-832161733:113,Availability,fault,fault,113,"I've just pushed a little change to correct some minor points of style in `random_objects.py` (that weren't your fault - they were there before), and to correct the docstring to say that only `N=None` triggers the deduction, not `N=0`. (I also just finished the conversion of the tests into a parametrised pytest style - I'm trying to keep get these gradually updated as we look at the files, but I didn't want to ask you to do a _whole_ bunch more work, when you've already done a lot to get this ready, thanks!)",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1509#issuecomment-832161733
https://github.com/qutip/qutip/pull/1509#issuecomment-832161733:360,Deployability,update,updated,360,"I've just pushed a little change to correct some minor points of style in `random_objects.py` (that weren't your fault - they were there before), and to correct the docstring to say that only `N=None` triggers the deduction, not `N=0`. (I also just finished the conversion of the tests into a parametrised pytest style - I'm trying to keep get these gradually updated as we look at the files, but I didn't want to ask you to do a _whole_ bunch more work, when you've already done a lot to get this ready, thanks!)",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1509#issuecomment-832161733
https://github.com/qutip/qutip/pull/1509#issuecomment-832161733:280,Testability,test,tests,280,"I've just pushed a little change to correct some minor points of style in `random_objects.py` (that weren't your fault - they were there before), and to correct the docstring to say that only `N=None` triggers the deduction, not `N=0`. (I also just finished the conversion of the tests into a parametrised pytest style - I'm trying to keep get these gradually updated as we look at the files, but I didn't want to ask you to do a _whole_ bunch more work, when you've already done a lot to get this ready, thanks!)",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1509#issuecomment-832161733
https://github.com/qutip/qutip/pull/1511#issuecomment-828397393:215,Deployability,update,update-readme,215,[![Coverage Status](https://coveralls.io/builds/39186985/badge)](https://coveralls.io/builds/39186985). Coverage decreased (-0.004%) to 64.305% when pulling **1a7ff5023a7363df5b4c62ef2c9ac8eb55f37d5b on jakelishman:update-readme** into **87f61257f65b35756305405daf82aafdc39e1b41 on qutip:master**.,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1511#issuecomment-828397393
https://github.com/qutip/qutip/pull/1511#issuecomment-828516404:10,Deployability,deploy,deploy,10,"I need to deploy a new version of the 4.6 docs before I can merge this, otherwise there'll be a dead link on the main repository page. I'm just doing that now.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1511#issuecomment-828516404
https://github.com/qutip/qutip/pull/1511#issuecomment-829095859:11,Deployability,update,updated,11,"Website is updated, so all the links are now live. Merging.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1511#issuecomment-829095859
https://github.com/qutip/qutip/issues/1512#issuecomment-829102786:595,Safety,safe,safer,595,"Thanks for reporting this. This appears to have _always_ been an inconsistency between the documentation and the code. These lines were added in one commit in #166, with no reference to any changes. I note at the moment that calling `max` on an array of complex (like this) finds the number with the maximal _real_ part, and then takes the absolute value of that. I suspect that the `max` call got added in after everything else was written - if you remove that call, you would retrieve the documented behaviour, though I don't know enough about the numerical strategies to know which method is safer; I don't know whether we should change the documentationi or the behaviour. @nwlambert might be better placed to answer that.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1512#issuecomment-829102786
https://github.com/qutip/qutip/issues/1512#issuecomment-829882889:361,Testability,test,testing,361,"I think a fix for this was proposed in this PR https://github.com/qutip/qutip/pull/1275 but that fix seems to still take the max over absolute values, so maybe is still inconsistent with documentation?. I also don't know if there is a reason to choose one over the other, I am not super familiar with the iterative solvers. Could just be a typo or some unfixed testing, particularly since it makes taking the mean completely pointless. David's logic for the iterative solvers sounds like a good reason to revert it to the documented case. If there is still some uncertainty we could ask paul (if he remembers!).",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1512#issuecomment-829882889
https://github.com/qutip/qutip/issues/1512#issuecomment-829882889:444,Testability,log,logic,444,"I think a fix for this was proposed in this PR https://github.com/qutip/qutip/pull/1275 but that fix seems to still take the max over absolute values, so maybe is still inconsistent with documentation?. I also don't know if there is a reason to choose one over the other, I am not super familiar with the iterative solvers. Could just be a typo or some unfixed testing, particularly since it makes taking the mean completely pointless. David's logic for the iterative solvers sounds like a good reason to revert it to the documented case. If there is still some uncertainty we could ask paul (if he remembers!).",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1512#issuecomment-829882889
https://github.com/qutip/qutip/pull/1513#issuecomment-829621066:50,Integrability,message,messages,50,"Oh, a thought: perhaps I should modify the commit messages of PRs in the old qutip-doc to make them link correctly. For example, instigate a rewrite rule of #xxx goes to qutip/qutip-doc#xxx?",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1513#issuecomment-829621066
https://github.com/qutip/qutip/pull/1513#issuecomment-829621066:141,Modifiability,rewrite,rewrite,141,"Oh, a thought: perhaps I should modify the commit messages of PRs in the old qutip-doc to make them link correctly. For example, instigate a rewrite rule of #xxx goes to qutip/qutip-doc#xxx?",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1513#issuecomment-829621066
https://github.com/qutip/qutip/pull/1513#issuecomment-829623558:52,Integrability,message,messages,52,"> Oh, a thought: perhaps I should modify the commit messages of PRs in the old qutip-doc to make them link correctly. For example, instigate a rewrite rule of #xxx goes to qutip/qutip-doc#xxx?. That sounds great, but I don't think it's required if it turns into a rabbit hole.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1513#issuecomment-829623558
https://github.com/qutip/qutip/pull/1513#issuecomment-829623558:143,Modifiability,rewrite,rewrite,143,"> Oh, a thought: perhaps I should modify the commit messages of PRs in the old qutip-doc to make them link correctly. For example, instigate a rewrite rule of #xxx goes to qutip/qutip-doc#xxx?. That sounds great, but I don't think it's required if it turns into a rabbit hole.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1513#issuecomment-829623558
https://github.com/qutip/qutip/pull/1513#issuecomment-829953403:9,Deployability,update,updated,9,"Ok, I've updated all PR links. It was no harder than basically running `sed s_#_qutip/qutip-doc#_g` on the commit messages - I checked that nothing untoward got changed as well. I've also updated the PR template - thanks Eric, I never would have thought of that (not sure how I missed it while using `grep` though!).",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1513#issuecomment-829953403
https://github.com/qutip/qutip/pull/1513#issuecomment-829953403:188,Deployability,update,updated,188,"Ok, I've updated all PR links. It was no harder than basically running `sed s_#_qutip/qutip-doc#_g` on the commit messages - I checked that nothing untoward got changed as well. I've also updated the PR template - thanks Eric, I never would have thought of that (not sure how I missed it while using `grep` though!).",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1513#issuecomment-829953403
https://github.com/qutip/qutip/pull/1513#issuecomment-829953403:114,Integrability,message,messages,114,"Ok, I've updated all PR links. It was no harder than basically running `sed s_#_qutip/qutip-doc#_g` on the commit messages - I checked that nothing untoward got changed as well. I've also updated the PR template - thanks Eric, I never would have thought of that (not sure how I missed it while using `grep` though!).",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1513#issuecomment-829953403
https://github.com/qutip/qutip/pull/1513#issuecomment-830096853:234,Availability,reliab,reliably,234,"Shahnawaz - I think you had some thoughts about merging in the documentation? It'd be good to know what you think about this strategy as well. I haven't attempted to change any structure of the documentation in this PR; it's building reliably (evidenced by the GH Action), and we can make further overhauls no matter which repo it's based in.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1513#issuecomment-830096853
https://github.com/qutip/qutip/pull/1513#issuecomment-830106458:1210,Availability,avail,available,1210,"Yeah, this is a ""true"" merge of the qutip-doc repository with this one. Technically all the commits have been rewritten (you'll find that the hashes won't match between the repositories), but they'll all be credited to the same authors on GitHub. Everyone will actually get the credit ""twice"" - once for the archived qutip/qutip-doc repo, and once for the new commit object in here. If anybody was in the habit of signing their commits with a private key, that will have been lost, but the only people that's likely to have affected are me and the GitHub merge bot. It doesn't mean anything in the greater scheme of things, because I've signed the merge commit. (signing is mostly just a way of verifying that the author really was who it says it was). *edit:* I checked, the only two types of signed commits in qutip/qutip-doc are those from me and those from the GitHub bot. Answers:; - I'll migrate all open issues on qutip-doc into the qutip/qutip repository, and tag them with a ""docs"" tag. GitHub has a built-in mechanism to migrate issues.; - We'll archive it, posting a message on the front page of it (or the README if GitHub doesn't have a separate mechanism). We need to leave the repository up and available on the web, because old documentation refers to it in links.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1513#issuecomment-830106458
https://github.com/qutip/qutip/pull/1513#issuecomment-830106458:1078,Integrability,message,message,1078,"Yeah, this is a ""true"" merge of the qutip-doc repository with this one. Technically all the commits have been rewritten (you'll find that the hashes won't match between the repositories), but they'll all be credited to the same authors on GitHub. Everyone will actually get the credit ""twice"" - once for the archived qutip/qutip-doc repo, and once for the new commit object in here. If anybody was in the habit of signing their commits with a private key, that will have been lost, but the only people that's likely to have affected are me and the GitHub merge bot. It doesn't mean anything in the greater scheme of things, because I've signed the merge commit. (signing is mostly just a way of verifying that the author really was who it says it was). *edit:* I checked, the only two types of signed commits in qutip/qutip-doc are those from me and those from the GitHub bot. Answers:; - I'll migrate all open issues on qutip-doc into the qutip/qutip repository, and tag them with a ""docs"" tag. GitHub has a built-in mechanism to migrate issues.; - We'll archive it, posting a message on the front page of it (or the README if GitHub doesn't have a separate mechanism). We need to leave the repository up and available on the web, because old documentation refers to it in links.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1513#issuecomment-830106458
https://github.com/qutip/qutip/pull/1513#issuecomment-830106458:142,Security,hash,hashes,142,"Yeah, this is a ""true"" merge of the qutip-doc repository with this one. Technically all the commits have been rewritten (you'll find that the hashes won't match between the repositories), but they'll all be credited to the same authors on GitHub. Everyone will actually get the credit ""twice"" - once for the archived qutip/qutip-doc repo, and once for the new commit object in here. If anybody was in the habit of signing their commits with a private key, that will have been lost, but the only people that's likely to have affected are me and the GitHub merge bot. It doesn't mean anything in the greater scheme of things, because I've signed the merge commit. (signing is mostly just a way of verifying that the author really was who it says it was). *edit:* I checked, the only two types of signed commits in qutip/qutip-doc are those from me and those from the GitHub bot. Answers:; - I'll migrate all open issues on qutip-doc into the qutip/qutip repository, and tag them with a ""docs"" tag. GitHub has a built-in mechanism to migrate issues.; - We'll archive it, posting a message on the front page of it (or the README if GitHub doesn't have a separate mechanism). We need to leave the repository up and available on the web, because old documentation refers to it in links.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1513#issuecomment-830106458
https://github.com/qutip/qutip/issues/1514#issuecomment-829931042:241,Availability,error,error,241,"Ah, this is the confluence of two bugs, unfortunately. As an immediate workaround, you should be able to set the environment variable `CI_QUTIP_RELEASE=1` before running `pip` (assuming it propagates the env), and it should build without an error. The two bugs:; 1. building in ""release mode"" isn't the default; on CI to build the wheels we set a release-mode flag, but the sdist can't tell. That's what the environment variable above does. I'll have to think a little about how we'll do versioning. This bug slipped in in #1465, where the primary concern was getting wheels built, and I didn't notice that the sdist wouldn't build in release mode.; 2. `git` isn't meant to be required - in dev mode, it should just get to the string ""nogit"". That error is actually within a `try/except` block, except it only catches `subprocess.SubprocessError`, when it should catch both `subprocess.SubprocessError` and `OSError`. Thanks for the report.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1514#issuecomment-829931042
https://github.com/qutip/qutip/issues/1514#issuecomment-829931042:748,Availability,error,error,748,"Ah, this is the confluence of two bugs, unfortunately. As an immediate workaround, you should be able to set the environment variable `CI_QUTIP_RELEASE=1` before running `pip` (assuming it propagates the env), and it should build without an error. The two bugs:; 1. building in ""release mode"" isn't the default; on CI to build the wheels we set a release-mode flag, but the sdist can't tell. That's what the environment variable above does. I'll have to think a little about how we'll do versioning. This bug slipped in in #1465, where the primary concern was getting wheels built, and I didn't notice that the sdist wouldn't build in release mode.; 2. `git` isn't meant to be required - in dev mode, it should just get to the string ""nogit"". That error is actually within a `try/except` block, except it only catches `subprocess.SubprocessError`, when it should catch both `subprocess.SubprocessError` and `OSError`. Thanks for the report.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1514#issuecomment-829931042
https://github.com/qutip/qutip/issues/1514#issuecomment-829931042:279,Deployability,release,release,279,"Ah, this is the confluence of two bugs, unfortunately. As an immediate workaround, you should be able to set the environment variable `CI_QUTIP_RELEASE=1` before running `pip` (assuming it propagates the env), and it should build without an error. The two bugs:; 1. building in ""release mode"" isn't the default; on CI to build the wheels we set a release-mode flag, but the sdist can't tell. That's what the environment variable above does. I'll have to think a little about how we'll do versioning. This bug slipped in in #1465, where the primary concern was getting wheels built, and I didn't notice that the sdist wouldn't build in release mode.; 2. `git` isn't meant to be required - in dev mode, it should just get to the string ""nogit"". That error is actually within a `try/except` block, except it only catches `subprocess.SubprocessError`, when it should catch both `subprocess.SubprocessError` and `OSError`. Thanks for the report.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1514#issuecomment-829931042
https://github.com/qutip/qutip/issues/1514#issuecomment-829931042:347,Deployability,release,release-mode,347,"Ah, this is the confluence of two bugs, unfortunately. As an immediate workaround, you should be able to set the environment variable `CI_QUTIP_RELEASE=1` before running `pip` (assuming it propagates the env), and it should build without an error. The two bugs:; 1. building in ""release mode"" isn't the default; on CI to build the wheels we set a release-mode flag, but the sdist can't tell. That's what the environment variable above does. I'll have to think a little about how we'll do versioning. This bug slipped in in #1465, where the primary concern was getting wheels built, and I didn't notice that the sdist wouldn't build in release mode.; 2. `git` isn't meant to be required - in dev mode, it should just get to the string ""nogit"". That error is actually within a `try/except` block, except it only catches `subprocess.SubprocessError`, when it should catch both `subprocess.SubprocessError` and `OSError`. Thanks for the report.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1514#issuecomment-829931042
https://github.com/qutip/qutip/issues/1514#issuecomment-829931042:635,Deployability,release,release,635,"Ah, this is the confluence of two bugs, unfortunately. As an immediate workaround, you should be able to set the environment variable `CI_QUTIP_RELEASE=1` before running `pip` (assuming it propagates the env), and it should build without an error. The two bugs:; 1. building in ""release mode"" isn't the default; on CI to build the wheels we set a release-mode flag, but the sdist can't tell. That's what the environment variable above does. I'll have to think a little about how we'll do versioning. This bug slipped in in #1465, where the primary concern was getting wheels built, and I didn't notice that the sdist wouldn't build in release mode.; 2. `git` isn't meant to be required - in dev mode, it should just get to the string ""nogit"". That error is actually within a `try/except` block, except it only catches `subprocess.SubprocessError`, when it should catch both `subprocess.SubprocessError` and `OSError`. Thanks for the report.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1514#issuecomment-829931042
https://github.com/qutip/qutip/issues/1514#issuecomment-829931042:125,Modifiability,variab,variable,125,"Ah, this is the confluence of two bugs, unfortunately. As an immediate workaround, you should be able to set the environment variable `CI_QUTIP_RELEASE=1` before running `pip` (assuming it propagates the env), and it should build without an error. The two bugs:; 1. building in ""release mode"" isn't the default; on CI to build the wheels we set a release-mode flag, but the sdist can't tell. That's what the environment variable above does. I'll have to think a little about how we'll do versioning. This bug slipped in in #1465, where the primary concern was getting wheels built, and I didn't notice that the sdist wouldn't build in release mode.; 2. `git` isn't meant to be required - in dev mode, it should just get to the string ""nogit"". That error is actually within a `try/except` block, except it only catches `subprocess.SubprocessError`, when it should catch both `subprocess.SubprocessError` and `OSError`. Thanks for the report.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1514#issuecomment-829931042
https://github.com/qutip/qutip/issues/1514#issuecomment-829931042:420,Modifiability,variab,variable,420,"Ah, this is the confluence of two bugs, unfortunately. As an immediate workaround, you should be able to set the environment variable `CI_QUTIP_RELEASE=1` before running `pip` (assuming it propagates the env), and it should build without an error. The two bugs:; 1. building in ""release mode"" isn't the default; on CI to build the wheels we set a release-mode flag, but the sdist can't tell. That's what the environment variable above does. I'll have to think a little about how we'll do versioning. This bug slipped in in #1465, where the primary concern was getting wheels built, and I didn't notice that the sdist wouldn't build in release mode.; 2. `git` isn't meant to be required - in dev mode, it should just get to the string ""nogit"". That error is actually within a `try/except` block, except it only catches `subprocess.SubprocessError`, when it should catch both `subprocess.SubprocessError` and `OSError`. Thanks for the report.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1514#issuecomment-829931042
https://github.com/qutip/qutip/pull/1541#issuecomment-830806647:217,Deployability,release,release-versioning,217,[![Coverage Status](https://coveralls.io/builds/39289486/badge)](https://coveralls.io/builds/39289486). Coverage remained the same at 64.305% when pulling **7edb262b7554e07e6a58233dcf8fe45a23315c44 on jakelishman:fix-release-versioning** into **963c1bb56dbd30f6bf39cd6211bab4603ac88f13 on qutip:master**.,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1541#issuecomment-830806647
https://github.com/qutip/qutip/pull/1541#issuecomment-831237284:26,Deployability,patch,patch,26,"Shall we schedule a 4.6.1 patch release for later this week? Perhaps I should email the others and set up a video call so I can demonstrate the release procedures. I can think of a few little patches that can be backported to 4.6.0, and then hopefully we can make 4.6.2 with new patches we get from Unitary Hack. The Floquet changes (currently on my desk - we've swapped to dealing by email a bit more) and the changes in Wigner will likely be part of the 4.7 release, of stuff I know right now.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1541#issuecomment-831237284
https://github.com/qutip/qutip/pull/1541#issuecomment-831237284:32,Deployability,release,release,32,"Shall we schedule a 4.6.1 patch release for later this week? Perhaps I should email the others and set up a video call so I can demonstrate the release procedures. I can think of a few little patches that can be backported to 4.6.0, and then hopefully we can make 4.6.2 with new patches we get from Unitary Hack. The Floquet changes (currently on my desk - we've swapped to dealing by email a bit more) and the changes in Wigner will likely be part of the 4.7 release, of stuff I know right now.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1541#issuecomment-831237284
https://github.com/qutip/qutip/pull/1541#issuecomment-831237284:144,Deployability,release,release,144,"Shall we schedule a 4.6.1 patch release for later this week? Perhaps I should email the others and set up a video call so I can demonstrate the release procedures. I can think of a few little patches that can be backported to 4.6.0, and then hopefully we can make 4.6.2 with new patches we get from Unitary Hack. The Floquet changes (currently on my desk - we've swapped to dealing by email a bit more) and the changes in Wigner will likely be part of the 4.7 release, of stuff I know right now.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1541#issuecomment-831237284
https://github.com/qutip/qutip/pull/1541#issuecomment-831237284:192,Deployability,patch,patches,192,"Shall we schedule a 4.6.1 patch release for later this week? Perhaps I should email the others and set up a video call so I can demonstrate the release procedures. I can think of a few little patches that can be backported to 4.6.0, and then hopefully we can make 4.6.2 with new patches we get from Unitary Hack. The Floquet changes (currently on my desk - we've swapped to dealing by email a bit more) and the changes in Wigner will likely be part of the 4.7 release, of stuff I know right now.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1541#issuecomment-831237284
https://github.com/qutip/qutip/pull/1541#issuecomment-831237284:279,Deployability,patch,patches,279,"Shall we schedule a 4.6.1 patch release for later this week? Perhaps I should email the others and set up a video call so I can demonstrate the release procedures. I can think of a few little patches that can be backported to 4.6.0, and then hopefully we can make 4.6.2 with new patches we get from Unitary Hack. The Floquet changes (currently on my desk - we've swapped to dealing by email a bit more) and the changes in Wigner will likely be part of the 4.7 release, of stuff I know right now.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1541#issuecomment-831237284
https://github.com/qutip/qutip/pull/1541#issuecomment-831237284:460,Deployability,release,release,460,"Shall we schedule a 4.6.1 patch release for later this week? Perhaps I should email the others and set up a video call so I can demonstrate the release procedures. I can think of a few little patches that can be backported to 4.6.0, and then hopefully we can make 4.6.2 with new patches we get from Unitary Hack. The Floquet changes (currently on my desk - we've swapped to dealing by email a bit more) and the changes in Wigner will likely be part of the 4.7 release, of stuff I know right now.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1541#issuecomment-831237284
https://github.com/qutip/qutip/pull/1541#issuecomment-831237284:9,Energy Efficiency,schedul,schedule,9,"Shall we schedule a 4.6.1 patch release for later this week? Perhaps I should email the others and set up a video call so I can demonstrate the release procedures. I can think of a few little patches that can be backported to 4.6.0, and then hopefully we can make 4.6.2 with new patches we get from Unitary Hack. The Floquet changes (currently on my desk - we've swapped to dealing by email a bit more) and the changes in Wigner will likely be part of the 4.7 release, of stuff I know right now.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1541#issuecomment-831237284
https://github.com/qutip/qutip/pull/1541#issuecomment-831239812:23,Deployability,deploy,deploy,23,@jakelishman I think a deploy of 4.6.1 on a call is an excellent idea. I'm will to drive the process in the call -- then at least someone other than you will have done it.,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1541#issuecomment-831239812
https://github.com/qutip/qutip/pull/1543#issuecomment-832021362:217,Deployability,release,release-preparation,217,[![Coverage Status](https://coveralls.io/builds/39351308/badge)](https://coveralls.io/builds/39351308). Coverage increased (+0.2%) to 64.312% when pulling **52c3db5926158598708118e9420d4dbd58c0ee1e on hodgestar:4.6.1-release-preparation** into **d6f5838cf859d0f58d0119b22e71a266743b50cf on qutip:qutip-4.6.X**.,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1543#issuecomment-832021362
https://github.com/qutip/qutip/pull/1544#issuecomment-832675360:215,Deployability,update,update-release-docs,215,[![Coverage Status](https://coveralls.io/builds/39416644/badge)](https://coveralls.io/builds/39416644). Coverage increased (+0.004%) to 64.333% when pulling **a5519d1043410cf158fe3c14e61d80ca6af9f32d on jakelishman:update-release-docs** into **4a9da224b72165dbad66ba0ba449d9429cd510c8 on qutip:master**.,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1544#issuecomment-832675360
https://github.com/qutip/qutip/issues/1545#issuecomment-832803880:766,Testability,benchmark,benchmarking,766,"The eigenvalues can be found with the typical functions present in qutip, such as `eigenenergies()` and `qutip.eigenstates()`. However, there can be some spurious eigenvalues, as detailed in this issue, #993. Only the steadystate, with eigenvalue 0, is assured to be correct. If you are just interested in the Liouvillian gap only, that should be fine. . Another faster and more stable technique that can be used in the case that only local dissipation processes are present (while the Hamiltonian is long range), is that of calculating the ""antigap"": since an additional weak PT symmetry is present, the symmetry of the Liouvillian spectrum in the complex plane can be exploited by just calculating the two largest eigenvalues. More details about this method, also benchmarking the validity of the Liouvillian gap calculated from a PIQS object, can be found here https://arxiv.org/abs/1912.07570. . For a tutorial detailing the differences between the different symmetric approached, but allowing the calculation also of nonlinear functions on initial states and their evolution, see the notebook entitled ""Von Neumann entropy and purity"" at http://qutip.org/tutorials#piqs.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1545#issuecomment-832803880
https://github.com/qutip/qutip/pull/1550#issuecomment-838309169:60,Testability,log,log,60,I think we do not have very large numbers as output and the log degeneracy formula should work for us. Thanks for the neat suggestion and the benchmark. Let me see how much improvement we get in the construction with this faster degeneracy computation. I am going to merge this and discuss the change in a new PR.,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1550#issuecomment-838309169
https://github.com/qutip/qutip/pull/1550#issuecomment-838309169:142,Testability,benchmark,benchmark,142,I think we do not have very large numbers as output and the log degeneracy formula should work for us. Thanks for the neat suggestion and the benchmark. Let me see how much improvement we get in the construction with this faster degeneracy computation. I am going to merge this and discuss the change in a new PR.,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1550#issuecomment-838309169
https://github.com/qutip/qutip/pull/1551#issuecomment-838497323:218,Testability,test,tests-to-github-actions,218,[![Coverage Status](https://coveralls.io/builds/39576138/badge)](https://coveralls.io/builds/39576138). Coverage increased (+0.5%) to 64.822% when pulling **51dcddba2aff9b5f6e43edd691609f0e0fb7fdb9 on jakelishman:move-tests-to-github-actions** into **6845908363c53c4c56b42be385f8f0b22ba8278b on qutip:master**.,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1551#issuecomment-838497323
https://github.com/qutip/qutip/pull/1551#issuecomment-839686694:333,Availability,error,errors,333,"@hodgestar shall we attempt to sort out the caching now, or get things moved over ahead of Unitary Hack and sort it out later? I don't think it's particularly a blocking issue - the tests still all run fine, after all. There's an argument against using `pip wheel` caching for us - we've historically used our tests to try and catch errors when using new versions of packages, which we'd lose if we start pinning versions to one particular thing. I'm not sure which is more desirable for us - overall I think the time loss from installing `cvxpy` isn't _that_ high, and we'd get more improvement from redoing some of our older tests. (Not to mention the _effective_ wait time for tests to pass is now ~35 minutes, whereas it could be >2hours on Travis since you had to wait from Mac machines for a long time.)",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1551#issuecomment-839686694
https://github.com/qutip/qutip/pull/1551#issuecomment-839686694:528,Deployability,install,installing,528,"@hodgestar shall we attempt to sort out the caching now, or get things moved over ahead of Unitary Hack and sort it out later? I don't think it's particularly a blocking issue - the tests still all run fine, after all. There's an argument against using `pip wheel` caching for us - we've historically used our tests to try and catch errors when using new versions of packages, which we'd lose if we start pinning versions to one particular thing. I'm not sure which is more desirable for us - overall I think the time loss from installing `cvxpy` isn't _that_ high, and we'd get more improvement from redoing some of our older tests. (Not to mention the _effective_ wait time for tests to pass is now ~35 minutes, whereas it could be >2hours on Travis since you had to wait from Mac machines for a long time.)",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1551#issuecomment-839686694
https://github.com/qutip/qutip/pull/1551#issuecomment-839686694:182,Testability,test,tests,182,"@hodgestar shall we attempt to sort out the caching now, or get things moved over ahead of Unitary Hack and sort it out later? I don't think it's particularly a blocking issue - the tests still all run fine, after all. There's an argument against using `pip wheel` caching for us - we've historically used our tests to try and catch errors when using new versions of packages, which we'd lose if we start pinning versions to one particular thing. I'm not sure which is more desirable for us - overall I think the time loss from installing `cvxpy` isn't _that_ high, and we'd get more improvement from redoing some of our older tests. (Not to mention the _effective_ wait time for tests to pass is now ~35 minutes, whereas it could be >2hours on Travis since you had to wait from Mac machines for a long time.)",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1551#issuecomment-839686694
https://github.com/qutip/qutip/pull/1551#issuecomment-839686694:310,Testability,test,tests,310,"@hodgestar shall we attempt to sort out the caching now, or get things moved over ahead of Unitary Hack and sort it out later? I don't think it's particularly a blocking issue - the tests still all run fine, after all. There's an argument against using `pip wheel` caching for us - we've historically used our tests to try and catch errors when using new versions of packages, which we'd lose if we start pinning versions to one particular thing. I'm not sure which is more desirable for us - overall I think the time loss from installing `cvxpy` isn't _that_ high, and we'd get more improvement from redoing some of our older tests. (Not to mention the _effective_ wait time for tests to pass is now ~35 minutes, whereas it could be >2hours on Travis since you had to wait from Mac machines for a long time.)",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1551#issuecomment-839686694
https://github.com/qutip/qutip/pull/1551#issuecomment-839686694:627,Testability,test,tests,627,"@hodgestar shall we attempt to sort out the caching now, or get things moved over ahead of Unitary Hack and sort it out later? I don't think it's particularly a blocking issue - the tests still all run fine, after all. There's an argument against using `pip wheel` caching for us - we've historically used our tests to try and catch errors when using new versions of packages, which we'd lose if we start pinning versions to one particular thing. I'm not sure which is more desirable for us - overall I think the time loss from installing `cvxpy` isn't _that_ high, and we'd get more improvement from redoing some of our older tests. (Not to mention the _effective_ wait time for tests to pass is now ~35 minutes, whereas it could be >2hours on Travis since you had to wait from Mac machines for a long time.)",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1551#issuecomment-839686694
https://github.com/qutip/qutip/pull/1551#issuecomment-839686694:680,Testability,test,tests,680,"@hodgestar shall we attempt to sort out the caching now, or get things moved over ahead of Unitary Hack and sort it out later? I don't think it's particularly a blocking issue - the tests still all run fine, after all. There's an argument against using `pip wheel` caching for us - we've historically used our tests to try and catch errors when using new versions of packages, which we'd lose if we start pinning versions to one particular thing. I'm not sure which is more desirable for us - overall I think the time loss from installing `cvxpy` isn't _that_ high, and we'd get more improvement from redoing some of our older tests. (Not to mention the _effective_ wait time for tests to pass is now ~35 minutes, whereas it could be >2hours on Travis since you had to wait from Mac machines for a long time.)",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1551#issuecomment-839686694
https://github.com/qutip/qutip/pull/1551#issuecomment-839773306:365,Availability,error,errors,365,"> @hodgestar shall we attempt to sort out the caching now, or get things moved over ahead of Unitary Hack and sort it out later? I don't think it's particularly a blocking issue - the tests still all run fine, after all. Definitely leave for later. > There's an argument against using `pip wheel` caching for us - we've historically used our tests to try and catch errors when using new versions of packages, which we'd lose if we start pinning versions to one particular thing. I don't think we need to pin to a particular version to benefit from the pip caching, but let's see later.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1551#issuecomment-839773306
https://github.com/qutip/qutip/pull/1551#issuecomment-839773306:184,Testability,test,tests,184,"> @hodgestar shall we attempt to sort out the caching now, or get things moved over ahead of Unitary Hack and sort it out later? I don't think it's particularly a blocking issue - the tests still all run fine, after all. Definitely leave for later. > There's an argument against using `pip wheel` caching for us - we've historically used our tests to try and catch errors when using new versions of packages, which we'd lose if we start pinning versions to one particular thing. I don't think we need to pin to a particular version to benefit from the pip caching, but let's see later.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1551#issuecomment-839773306
https://github.com/qutip/qutip/pull/1551#issuecomment-839773306:342,Testability,test,tests,342,"> @hodgestar shall we attempt to sort out the caching now, or get things moved over ahead of Unitary Hack and sort it out later? I don't think it's particularly a blocking issue - the tests still all run fine, after all. Definitely leave for later. > There's an argument against using `pip wheel` caching for us - we've historically used our tests to try and catch errors when using new versions of packages, which we'd lose if we start pinning versions to one particular thing. I don't think we need to pin to a particular version to benefit from the pip caching, but let's see later.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1551#issuecomment-839773306
https://github.com/qutip/qutip/pull/1553#issuecomment-840354389:27,Testability,test,test,27,"The intermittently failing test seems unrelated and is `test_usage_in_solvers[mesolve-complex-spline,string]`.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1553#issuecomment-840354389
https://github.com/qutip/qutip/pull/1555#issuecomment-840558024:23,Deployability,update,update,23,"Yeah, Google will just update itself over time, I think - the http links aren't dead, they just redirect through to the https ones (or at least they will when I force https access from tomorrow). There's a similar PR on the website (qutip/qutip.github.io#145) to fix links there as well.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1555#issuecomment-840558024
https://github.com/qutip/qutip/pull/1555#issuecomment-840558024:173,Security,access,access,173,"Yeah, Google will just update itself over time, I think - the http links aren't dead, they just redirect through to the https ones (or at least they will when I force https access from tomorrow). There's a similar PR on the website (qutip/qutip.github.io#145) to fix links there as well.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1555#issuecomment-840558024
https://github.com/qutip/qutip/pull/1556#issuecomment-841228166:219,Testability,test,tests-matplotlib,219,[![Coverage Status](https://coveralls.io/builds/39739382/badge)](https://coveralls.io/builds/39739382). Coverage decreased (-0.006%) to 64.896% when pulling **8466e01691f98cfc8d743be7f5b9b3370a4ee967 on Yash-10:Version-tests-matplotlib** into **c1a3b9df16be09e9895385f3274a2a39e50695d2 on qutip:master**.,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1556#issuecomment-841228166
https://github.com/qutip/qutip/pull/1556#issuecomment-841477865:369,Usability,guid,guide,369,"Thank you @jakelishman and @hodgestar for your suggestions throughout the PR!. At this stage, the following things are added:. - Getting rid of the previously implemented `matplotlib_version_gte` method. Instead following @jakelishman 's advice to factor version checking once at the top and use it throughout the module. This prevents any version checking in the user guide since the `axes3D_` method can be directly imported.; - Since `axes.M` seems to work even for `matplotlib==3.0`, converted all instances of `renderer.M` to `axes.M` to keep version checking at the minimum. Thanks!!",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1556#issuecomment-841477865
https://github.com/qutip/qutip/pull/1557#issuecomment-849787790:221,Availability,error,error,221,[![Coverage Status](https://coveralls.io/builds/40090550/badge)](https://coveralls.io/builds/40090550). Coverage increased (+0.01%) to 64.915% when pulling **d32953c7780c3108198787e3b61953c5e11ad0cd on Yash-10:Fix-ffmpeg-error** into **9c422c8e30ff96ac835e852efb0d8656eb01ddab on qutip:master**.,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1557#issuecomment-849787790
https://github.com/qutip/qutip/pull/1558#issuecomment-841148767:211,Deployability,patch,patch-,211,[![Coverage Status](https://coveralls.io/builds/39690016/badge)](https://coveralls.io/builds/39690016). Coverage decreased (-0.04%) to 64.893% when pulling **65a695d39530ebcba83d84dae823d47b73b436de on WingCode:patch-1** into **fe91fdda6b14c4408efe427fad0f5ebdcbabfa4a on qutip:master**.,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1558#issuecomment-841148767
https://github.com/qutip/qutip/pull/1558#issuecomment-842039776:39,Availability,error,error,39,"@rohan999chaudhary Could you share the error traceback? . From the documentation, the default value for `blit` is False. Perhaps, you could remove the `blit` argument and try again?",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1558#issuecomment-842039776
https://github.com/qutip/qutip/pull/1558#issuecomment-842086433:106,Availability,error,error,106,"[pristine_from_docs.zip](https://github.com/qutip/qutip/files/6491982/pristine_from_docs.zip). I get this error for dir_gen_anim2.py. I have just attached the relevant part here. . ```python; fig = pyplot.figure(); ax = Axes3D(fig, azim=-40, elev=30); sphere = Bloch(axes=ax). def animate(i):; sphere.clear(); sphere.add_vectors([np_sin(theta), 0, np_cos(theta)]); sphere.add_points([sx[:i+1], sy[:i+1], sz[:i+1]]); sphere.make_sphere(); return ax. def init():; sphere.vector_color = ['r']; return ax. ani = FuncAnimation(fig, animate, arange(len(sx)),; init_func=init, blit=False, repeat=False). ani.save('bloch_sphere.mp4', fps=20). Exception ignored in: <function TimerQT.__del__ at 0x7fbf6c561b80>; Traceback (most recent call last):; File ""/home/rohan/anaconda3/envs/nbdev/lib/python3.8/site-packages/matplotlib/backends/backend_qt5.py"", line 189, in __del__; TypeError: 'NoneType' object is not callable; ```",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1558#issuecomment-842086433
https://github.com/qutip/qutip/pull/1558#issuecomment-842086433:301,Usability,clear,clear,301,"[pristine_from_docs.zip](https://github.com/qutip/qutip/files/6491982/pristine_from_docs.zip). I get this error for dir_gen_anim2.py. I have just attached the relevant part here. . ```python; fig = pyplot.figure(); ax = Axes3D(fig, azim=-40, elev=30); sphere = Bloch(axes=ax). def animate(i):; sphere.clear(); sphere.add_vectors([np_sin(theta), 0, np_cos(theta)]); sphere.add_points([sx[:i+1], sy[:i+1], sz[:i+1]]); sphere.make_sphere(); return ax. def init():; sphere.vector_color = ['r']; return ax. ani = FuncAnimation(fig, animate, arange(len(sx)),; init_func=init, blit=False, repeat=False). ani.save('bloch_sphere.mp4', fps=20). Exception ignored in: <function TimerQT.__del__ at 0x7fbf6c561b80>; Traceback (most recent call last):; File ""/home/rohan/anaconda3/envs/nbdev/lib/python3.8/site-packages/matplotlib/backends/backend_qt5.py"", line 189, in __del__; TypeError: 'NoneType' object is not callable; ```",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1558#issuecomment-842086433
https://github.com/qutip/qutip/pull/1558#issuecomment-842087604:142,Usability,clear,clear,142,"and this in dir_gen_anim.py; ```python; fig = figure(); ax = Axes3D(fig, azim=-40, elev=30); sphere = Bloch(axes=ax). def animate(i):; sphere.clear(); sphere.add_vectors([np_sin(theta), 0, np_cos(theta)]); sphere.add_points([sx[:i+1], sy[:i+1], sz[:i+1]]); sphere.make_sphere(); return ax. def init():; sphere.vector_color = ['r']; return ax. ani = FuncAnimation(fig, animate, arange(len(sx)),; init_func=init, blit=True, repeat=False). ani.save('bloch_sphere.mp4', fps=20). Traceback (most recent call last):; File ""dir_gen_anim.py"", line 87, in <module>; ani.save('bloch_sphere.mp4', fps=20); File ""/home/rohan/anaconda3/envs/nbdev/lib/python3.8/site-packages/matplotlib/animation.py"", line 1144, in save; anim._init_draw() # Clear the initial frame; File ""/home/rohan/anaconda3/envs/nbdev/lib/python3.8/site-packages/matplotlib/animation.py"", line 1727, in _init_draw; for a in self._drawn_artists:; TypeError: 'Axes3D' object is not iterable. ```",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1558#issuecomment-842087604
https://github.com/qutip/qutip/pull/1558#issuecomment-842087604:728,Usability,Clear,Clear,728,"and this in dir_gen_anim.py; ```python; fig = figure(); ax = Axes3D(fig, azim=-40, elev=30); sphere = Bloch(axes=ax). def animate(i):; sphere.clear(); sphere.add_vectors([np_sin(theta), 0, np_cos(theta)]); sphere.add_points([sx[:i+1], sy[:i+1], sz[:i+1]]); sphere.make_sphere(); return ax. def init():; sphere.vector_color = ['r']; return ax. ani = FuncAnimation(fig, animate, arange(len(sx)),; init_func=init, blit=True, repeat=False). ani.save('bloch_sphere.mp4', fps=20). Traceback (most recent call last):; File ""dir_gen_anim.py"", line 87, in <module>; ani.save('bloch_sphere.mp4', fps=20); File ""/home/rohan/anaconda3/envs/nbdev/lib/python3.8/site-packages/matplotlib/animation.py"", line 1144, in save; anim._init_draw() # Clear the initial frame; File ""/home/rohan/anaconda3/envs/nbdev/lib/python3.8/site-packages/matplotlib/animation.py"", line 1727, in _init_draw; for a in self._drawn_artists:; TypeError: 'Axes3D' object is not iterable. ```",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1558#issuecomment-842087604
https://github.com/qutip/qutip/pull/1558#issuecomment-842089563:107,Integrability,depend,dependencies,107,This is my conda env file for linux; ```yaml; name: nbdev; channels:; - fastai; - defaults; - conda-forge; dependencies:; - _r-mutex; - _tflow_select; - absl-py; - alabaster; - asn1crypto; - astor; - astroid; - attrs; - babel; - backcall; - backports; - backports.functools_lru_cache; - blas; - bleach; - bwidget; - bzip2; - c-ares; - ca-certificates; - cairo; - certifi; - cffi; - chardet; - cloudpickle; - compiler-rt; - constantly; - cryptography; - curl; - cycler; - cython; - dbus; - decorator; - defusedxml; - docutils; - entrypoints; - expat; - fastcache; - flake8; - fontconfig; - freetype; - fribidi; - gast; - gettext; - glib; - gmp; - gmpy2; - graphite2; - grpcio; - gsl; - h5py; - harfbuzz; - hdf5; - html5lib; - icu; - idna; - imagesize; - intel-openmp; - ipykernel; - ipython; - ipython_genutils; - isort; - jbig; - jedi; - jinja2; - jpeg; - jsonschema; - jupyter_client; - jupyter_contrib_core; - jupyter_contrib_nbextensions; - jupyter_core; - jupyter_highlight_selected_word; - jupyter_latex_envs; - jupyter_nbextensions_configurator; - keras-applications; - keras-preprocessing; - keyring; - krb5; - lazy-object-proxy; - libcurl; - libcxx; - libcxxabi; - libedit; - libffi; - libgcc; - libgfortran; - libiconv; - libopenblas; - libpng; - libprotobuf; - libsodium; - libssh2; - libtiff; - libxml2; - libxslt; - llvm; - llvm-openmp; - lxml; - make; - markdown; - markupsafe; - matplotlib; - mccabe; - mistune; - mkl; - mkl_fft; - mkl_random; - mock; - mpc; - mpfr; - mpmath; - nbconvert; - nbformat; - ncurses; - nomkl; - notebook; - numpy; - numpy-base; - numpydoc; - olefile; - openblas; - openblas-devel; - openssl; - packaging; - pandas; - pandoc; - pandocfilters; - pango; - pari; - parso; - patsy; - pbr; - pcre; - perl; - pexpect; - pickleshare; - pillow; - pip; - pixman; - prometheus_client; - prompt_toolkit; - protobuf; - psutil; - ptyprocess; - pycodestyle; - pycparser; - pyflakes; - pygments; - pylint; - pyopenssl; - pyparsing; - pyqt; - pyrsistent; - pysocks; - python;,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1558#issuecomment-842089563
https://github.com/qutip/qutip/pull/1558#issuecomment-842089563:2824,Integrability,wrap,wrapt,2824,enblas-devel; - openssl; - packaging; - pandas; - pandoc; - pandocfilters; - pango; - pari; - parso; - patsy; - pbr; - pcre; - perl; - pexpect; - pickleshare; - pillow; - pip; - pixman; - prometheus_client; - prompt_toolkit; - protobuf; - psutil; - ptyprocess; - pycodestyle; - pycparser; - pyflakes; - pygments; - pylint; - pyopenssl; - pyparsing; - pyqt; - pyrsistent; - pysocks; - python; - python-dateutil; - python-symengine; - pytz; - pyyaml; - pyzmq; - qt; - qtawesome; - qtconsole; - qtpy; - qutip; - r-base; - r-clisymbols; - readline; - reportlab; - requests; - rope; - scikit-learn; - scipy; - send2trash; - setuptools; - simplegeneric; - sip; - six; - snowballstemmer; - sphinx; - sphinxcontrib; - sphinxcontrib-applehelp; - sphinxcontrib-devhelp; - sphinxcontrib-htmlhelp; - sphinxcontrib-jsmath; - sphinxcontrib-qthelp; - sphinxcontrib-serializinghtml; - sphinxcontrib-websupport; - spyder; - spyder-kernels; - sqlite; - symengine; - symmetrica; - sympow; - sympy; - tensorboard; - tensorflow; - tensorflow-base; - tensorflow-estimator; - termcolor; - terminado; - testpath; - tk; - tktable; - tornado; - traitlets; - typed-ast; - typing; - urllib3; - wcwidth; - webencodings; - werkzeug; - wheel; - wrapt; - wurlitzer; - xz; - yaml; - zeromq; - tqdm; - zlib; - zstd; - pytest; - numba; - hypothesis; - pytest-cov; - mypy; - pytest-xdist; - watchdog; - pytest-runner; - coveralls; - doctr; - gitpython; - pre-commit; - tox; - cookiecutter; - pdbpp; - sphinx-autobuild; - sphinx-autodoc-typehints; - sphinx_rtd_theme; - travis-encrypt; - twine; - nbval; - nbsphinx; - watermark; - ipyparallel; - unittest2pytest; - pytest-benchmark; - pytest-repeat; - pytest-subtests; - fastcore; - fastscript; - asttokens; - cached-property; - crayons; - executing; - flask; - humanize; - ipywidgets; - itsdangerous; - jsonpickle; - jupyter; - littleutils; - nbconvert; - outdated; - portpicker; - sqlalchemy; - widgetsnbextension; - nbdime; - rich; - mayavi; - pip:; - birdseye; - icecream; - nbdev==1.,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1558#issuecomment-842089563
https://github.com/qutip/qutip/pull/1558#issuecomment-842089563:3333,Performance,cache,cached-property,3333,enblas-devel; - openssl; - packaging; - pandas; - pandoc; - pandocfilters; - pango; - pari; - parso; - patsy; - pbr; - pcre; - perl; - pexpect; - pickleshare; - pillow; - pip; - pixman; - prometheus_client; - prompt_toolkit; - protobuf; - psutil; - ptyprocess; - pycodestyle; - pycparser; - pyflakes; - pygments; - pylint; - pyopenssl; - pyparsing; - pyqt; - pyrsistent; - pysocks; - python; - python-dateutil; - python-symengine; - pytz; - pyyaml; - pyzmq; - qt; - qtawesome; - qtconsole; - qtpy; - qutip; - r-base; - r-clisymbols; - readline; - reportlab; - requests; - rope; - scikit-learn; - scipy; - send2trash; - setuptools; - simplegeneric; - sip; - six; - snowballstemmer; - sphinx; - sphinxcontrib; - sphinxcontrib-applehelp; - sphinxcontrib-devhelp; - sphinxcontrib-htmlhelp; - sphinxcontrib-jsmath; - sphinxcontrib-qthelp; - sphinxcontrib-serializinghtml; - sphinxcontrib-websupport; - spyder; - spyder-kernels; - sqlite; - symengine; - symmetrica; - sympow; - sympy; - tensorboard; - tensorflow; - tensorflow-base; - tensorflow-estimator; - termcolor; - terminado; - testpath; - tk; - tktable; - tornado; - traitlets; - typed-ast; - typing; - urllib3; - wcwidth; - webencodings; - werkzeug; - wheel; - wrapt; - wurlitzer; - xz; - yaml; - zeromq; - tqdm; - zlib; - zstd; - pytest; - numba; - hypothesis; - pytest-cov; - mypy; - pytest-xdist; - watchdog; - pytest-runner; - coveralls; - doctr; - gitpython; - pre-commit; - tox; - cookiecutter; - pdbpp; - sphinx-autobuild; - sphinx-autodoc-typehints; - sphinx_rtd_theme; - travis-encrypt; - twine; - nbval; - nbsphinx; - watermark; - ipyparallel; - unittest2pytest; - pytest-benchmark; - pytest-repeat; - pytest-subtests; - fastcore; - fastscript; - asttokens; - cached-property; - crayons; - executing; - flask; - humanize; - ipywidgets; - itsdangerous; - jsonpickle; - jupyter; - littleutils; - nbconvert; - outdated; - portpicker; - sqlalchemy; - widgetsnbextension; - nbdime; - rich; - mayavi; - pip:; - birdseye; - icecream; - nbdev==1.,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1558#issuecomment-842089563
https://github.com/qutip/qutip/pull/1558#issuecomment-842089563:338,Security,certificate,certificates,338,functools_lru_cache; - blas; - bleach; - bwidget; - bzip2; - c-ares; - ca-certificates; - cairo; - certifi; - cffi; - chardet; - cloudpickle; - compiler-rt; - constantly; - cryptography; - curl; - cycler; - cython; - dbus; - decorator; - defusedxml; - docutils; - entrypoints; - expat; - fastcache; - flake8; - fontconfig; - freetype; - fribidi; - gast; - gettext; - glib; - gmp; - gmpy2; - graphite2; - grpcio; - gsl; - h5py; - harfbuzz; - hdf5; - html5lib; - icu; - idna; - imagesize; - intel-openmp; - ipykernel; - ipython; - ipython_genutils; - isort; - jbig; - jedi; - jinja2; - jpeg; - jsonschema; - jupyter_client; - jupyter_contrib_core; - jupyter_contrib_nbextensions; - jupyter_core; - jupyter_highlight_selected_word; - jupyter_latex_envs; - jupyter_nbextensions_configurator; - keras-applications; - keras-preprocessing; - keyring; - krb5; - lazy-object-proxy; - libcurl; - libcxx; - libcxxabi; - libedit; - libffi; - libgcc; - libgfortran; - libiconv; - libopenblas; - libpng; - libprotobuf; - libsodium; - libssh2; - libtiff; - libxml2; - libxslt; - llvm; - llvm-openmp; - lxml; - make; - markdown; - markupsafe; - matplotlib; - mccabe; - mistune; - mkl; - mkl_fft; - mkl_random; - mock; - mpc; - mpfr; - mpmath; - nbconvert; - nbformat; - ncurses; - nomkl; - notebook; - numpy; - numpy-base; - numpydoc; - olefile; - openblas; - openblas-devel; - openssl; - packaging; - pandas; - pandoc; - pandocfilters; - pango; - pari; - parso; - patsy; - pbr; - pcre; - perl; - pexpect; - pickleshare; - pillow; - pip; - pixman; - prometheus_client; - prompt_toolkit; - protobuf; - psutil; - ptyprocess; - pycodestyle; - pycparser; - pyflakes; - pygments; - pylint; - pyopenssl; - pyparsing; - pyqt; - pyrsistent; - pysocks; - python;,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1558#issuecomment-842089563
https://github.com/qutip/qutip/pull/1558#issuecomment-842089563:3150,Security,encrypt,encrypt,3150,enblas-devel; - openssl; - packaging; - pandas; - pandoc; - pandocfilters; - pango; - pari; - parso; - patsy; - pbr; - pcre; - perl; - pexpect; - pickleshare; - pillow; - pip; - pixman; - prometheus_client; - prompt_toolkit; - protobuf; - psutil; - ptyprocess; - pycodestyle; - pycparser; - pyflakes; - pygments; - pylint; - pyopenssl; - pyparsing; - pyqt; - pyrsistent; - pysocks; - python; - python-dateutil; - python-symengine; - pytz; - pyyaml; - pyzmq; - qt; - qtawesome; - qtconsole; - qtpy; - qutip; - r-base; - r-clisymbols; - readline; - reportlab; - requests; - rope; - scikit-learn; - scipy; - send2trash; - setuptools; - simplegeneric; - sip; - six; - snowballstemmer; - sphinx; - sphinxcontrib; - sphinxcontrib-applehelp; - sphinxcontrib-devhelp; - sphinxcontrib-htmlhelp; - sphinxcontrib-jsmath; - sphinxcontrib-qthelp; - sphinxcontrib-serializinghtml; - sphinxcontrib-websupport; - spyder; - spyder-kernels; - sqlite; - symengine; - symmetrica; - sympow; - sympy; - tensorboard; - tensorflow; - tensorflow-base; - tensorflow-estimator; - termcolor; - terminado; - testpath; - tk; - tktable; - tornado; - traitlets; - typed-ast; - typing; - urllib3; - wcwidth; - webencodings; - werkzeug; - wheel; - wrapt; - wurlitzer; - xz; - yaml; - zeromq; - tqdm; - zlib; - zstd; - pytest; - numba; - hypothesis; - pytest-cov; - mypy; - pytest-xdist; - watchdog; - pytest-runner; - coveralls; - doctr; - gitpython; - pre-commit; - tox; - cookiecutter; - pdbpp; - sphinx-autobuild; - sphinx-autodoc-typehints; - sphinx_rtd_theme; - travis-encrypt; - twine; - nbval; - nbsphinx; - watermark; - ipyparallel; - unittest2pytest; - pytest-benchmark; - pytest-repeat; - pytest-subtests; - fastcore; - fastscript; - asttokens; - cached-property; - crayons; - executing; - flask; - humanize; - ipywidgets; - itsdangerous; - jsonpickle; - jupyter; - littleutils; - nbconvert; - outdated; - portpicker; - sqlalchemy; - widgetsnbextension; - nbdime; - rich; - mayavi; - pip:; - birdseye; - icecream; - nbdev==1.,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1558#issuecomment-842089563
https://github.com/qutip/qutip/pull/1558#issuecomment-842089563:1460,Testability,mock,mock,1460,ycler; - cython; - dbus; - decorator; - defusedxml; - docutils; - entrypoints; - expat; - fastcache; - flake8; - fontconfig; - freetype; - fribidi; - gast; - gettext; - glib; - gmp; - gmpy2; - graphite2; - grpcio; - gsl; - h5py; - harfbuzz; - hdf5; - html5lib; - icu; - idna; - imagesize; - intel-openmp; - ipykernel; - ipython; - ipython_genutils; - isort; - jbig; - jedi; - jinja2; - jpeg; - jsonschema; - jupyter_client; - jupyter_contrib_core; - jupyter_contrib_nbextensions; - jupyter_core; - jupyter_highlight_selected_word; - jupyter_latex_envs; - jupyter_nbextensions_configurator; - keras-applications; - keras-preprocessing; - keyring; - krb5; - lazy-object-proxy; - libcurl; - libcxx; - libcxxabi; - libedit; - libffi; - libgcc; - libgfortran; - libiconv; - libopenblas; - libpng; - libprotobuf; - libsodium; - libssh2; - libtiff; - libxml2; - libxslt; - llvm; - llvm-openmp; - lxml; - make; - markdown; - markupsafe; - matplotlib; - mccabe; - mistune; - mkl; - mkl_fft; - mkl_random; - mock; - mpc; - mpfr; - mpmath; - nbconvert; - nbformat; - ncurses; - nomkl; - notebook; - numpy; - numpy-base; - numpydoc; - olefile; - openblas; - openblas-devel; - openssl; - packaging; - pandas; - pandoc; - pandocfilters; - pango; - pari; - parso; - patsy; - pbr; - pcre; - perl; - pexpect; - pickleshare; - pillow; - pip; - pixman; - prometheus_client; - prompt_toolkit; - protobuf; - psutil; - ptyprocess; - pycodestyle; - pycparser; - pyflakes; - pygments; - pylint; - pyopenssl; - pyparsing; - pyqt; - pyrsistent; - pysocks; - python; - python-dateutil; - python-symengine; - pytz; - pyyaml; - pyzmq; - qt; - qtawesome; - qtconsole; - qtpy; - qutip; - r-base; - r-clisymbols; - readline; - reportlab; - requests; - rope; - scikit-learn; - scipy; - send2trash; - setuptools; - simplegeneric; - sip; - six; - snowballstemmer; - sphinx; - sphinxcontrib; - sphinxcontrib-applehelp; - sphinxcontrib-devhelp; - sphinxcontrib-htmlhelp; - sphinxcontrib-jsmath; - sphinxcontrib-qthelp; - sphinxcontrib-ser,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1558#issuecomment-842089563
https://github.com/qutip/qutip/pull/1558#issuecomment-842089563:2689,Testability,test,testpath,2689,enblas-devel; - openssl; - packaging; - pandas; - pandoc; - pandocfilters; - pango; - pari; - parso; - patsy; - pbr; - pcre; - perl; - pexpect; - pickleshare; - pillow; - pip; - pixman; - prometheus_client; - prompt_toolkit; - protobuf; - psutil; - ptyprocess; - pycodestyle; - pycparser; - pyflakes; - pygments; - pylint; - pyopenssl; - pyparsing; - pyqt; - pyrsistent; - pysocks; - python; - python-dateutil; - python-symengine; - pytz; - pyyaml; - pyzmq; - qt; - qtawesome; - qtconsole; - qtpy; - qutip; - r-base; - r-clisymbols; - readline; - reportlab; - requests; - rope; - scikit-learn; - scipy; - send2trash; - setuptools; - simplegeneric; - sip; - six; - snowballstemmer; - sphinx; - sphinxcontrib; - sphinxcontrib-applehelp; - sphinxcontrib-devhelp; - sphinxcontrib-htmlhelp; - sphinxcontrib-jsmath; - sphinxcontrib-qthelp; - sphinxcontrib-serializinghtml; - sphinxcontrib-websupport; - spyder; - spyder-kernels; - sqlite; - symengine; - symmetrica; - sympow; - sympy; - tensorboard; - tensorflow; - tensorflow-base; - tensorflow-estimator; - termcolor; - terminado; - testpath; - tk; - tktable; - tornado; - traitlets; - typed-ast; - typing; - urllib3; - wcwidth; - webencodings; - werkzeug; - wheel; - wrapt; - wurlitzer; - xz; - yaml; - zeromq; - tqdm; - zlib; - zstd; - pytest; - numba; - hypothesis; - pytest-cov; - mypy; - pytest-xdist; - watchdog; - pytest-runner; - coveralls; - doctr; - gitpython; - pre-commit; - tox; - cookiecutter; - pdbpp; - sphinx-autobuild; - sphinx-autodoc-typehints; - sphinx_rtd_theme; - travis-encrypt; - twine; - nbval; - nbsphinx; - watermark; - ipyparallel; - unittest2pytest; - pytest-benchmark; - pytest-repeat; - pytest-subtests; - fastcore; - fastscript; - asttokens; - cached-property; - crayons; - executing; - flask; - humanize; - ipywidgets; - itsdangerous; - jsonpickle; - jupyter; - littleutils; - nbconvert; - outdated; - portpicker; - sqlalchemy; - widgetsnbextension; - nbdime; - rich; - mayavi; - pip:; - birdseye; - icecream; - nbdev==1.,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1558#issuecomment-842089563
https://github.com/qutip/qutip/pull/1558#issuecomment-842089563:3245,Testability,benchmark,benchmark,3245,enblas-devel; - openssl; - packaging; - pandas; - pandoc; - pandocfilters; - pango; - pari; - parso; - patsy; - pbr; - pcre; - perl; - pexpect; - pickleshare; - pillow; - pip; - pixman; - prometheus_client; - prompt_toolkit; - protobuf; - psutil; - ptyprocess; - pycodestyle; - pycparser; - pyflakes; - pygments; - pylint; - pyopenssl; - pyparsing; - pyqt; - pyrsistent; - pysocks; - python; - python-dateutil; - python-symengine; - pytz; - pyyaml; - pyzmq; - qt; - qtawesome; - qtconsole; - qtpy; - qutip; - r-base; - r-clisymbols; - readline; - reportlab; - requests; - rope; - scikit-learn; - scipy; - send2trash; - setuptools; - simplegeneric; - sip; - six; - snowballstemmer; - sphinx; - sphinxcontrib; - sphinxcontrib-applehelp; - sphinxcontrib-devhelp; - sphinxcontrib-htmlhelp; - sphinxcontrib-jsmath; - sphinxcontrib-qthelp; - sphinxcontrib-serializinghtml; - sphinxcontrib-websupport; - spyder; - spyder-kernels; - sqlite; - symengine; - symmetrica; - sympow; - sympy; - tensorboard; - tensorflow; - tensorflow-base; - tensorflow-estimator; - termcolor; - terminado; - testpath; - tk; - tktable; - tornado; - traitlets; - typed-ast; - typing; - urllib3; - wcwidth; - webencodings; - werkzeug; - wheel; - wrapt; - wurlitzer; - xz; - yaml; - zeromq; - tqdm; - zlib; - zstd; - pytest; - numba; - hypothesis; - pytest-cov; - mypy; - pytest-xdist; - watchdog; - pytest-runner; - coveralls; - doctr; - gitpython; - pre-commit; - tox; - cookiecutter; - pdbpp; - sphinx-autobuild; - sphinx-autodoc-typehints; - sphinx_rtd_theme; - travis-encrypt; - twine; - nbval; - nbsphinx; - watermark; - ipyparallel; - unittest2pytest; - pytest-benchmark; - pytest-repeat; - pytest-subtests; - fastcore; - fastscript; - asttokens; - cached-property; - crayons; - executing; - flask; - humanize; - ipywidgets; - itsdangerous; - jsonpickle; - jupyter; - littleutils; - nbconvert; - outdated; - portpicker; - sqlalchemy; - widgetsnbextension; - nbdime; - rich; - mayavi; - pip:; - birdseye; - icecream; - nbdev==1.,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1558#issuecomment-842089563
https://github.com/qutip/qutip/pull/1558#issuecomment-842089563:2197,Usability,learn,learn,2197,; - libgfortran; - libiconv; - libopenblas; - libpng; - libprotobuf; - libsodium; - libssh2; - libtiff; - libxml2; - libxslt; - llvm; - llvm-openmp; - lxml; - make; - markdown; - markupsafe; - matplotlib; - mccabe; - mistune; - mkl; - mkl_fft; - mkl_random; - mock; - mpc; - mpfr; - mpmath; - nbconvert; - nbformat; - ncurses; - nomkl; - notebook; - numpy; - numpy-base; - numpydoc; - olefile; - openblas; - openblas-devel; - openssl; - packaging; - pandas; - pandoc; - pandocfilters; - pango; - pari; - parso; - patsy; - pbr; - pcre; - perl; - pexpect; - pickleshare; - pillow; - pip; - pixman; - prometheus_client; - prompt_toolkit; - protobuf; - psutil; - ptyprocess; - pycodestyle; - pycparser; - pyflakes; - pygments; - pylint; - pyopenssl; - pyparsing; - pyqt; - pyrsistent; - pysocks; - python; - python-dateutil; - python-symengine; - pytz; - pyyaml; - pyzmq; - qt; - qtawesome; - qtconsole; - qtpy; - qutip; - r-base; - r-clisymbols; - readline; - reportlab; - requests; - rope; - scikit-learn; - scipy; - send2trash; - setuptools; - simplegeneric; - sip; - six; - snowballstemmer; - sphinx; - sphinxcontrib; - sphinxcontrib-applehelp; - sphinxcontrib-devhelp; - sphinxcontrib-htmlhelp; - sphinxcontrib-jsmath; - sphinxcontrib-qthelp; - sphinxcontrib-serializinghtml; - sphinxcontrib-websupport; - spyder; - spyder-kernels; - sqlite; - symengine; - symmetrica; - sympow; - sympy; - tensorboard; - tensorflow; - tensorflow-base; - tensorflow-estimator; - termcolor; - terminado; - testpath; - tk; - tktable; - tornado; - traitlets; - typed-ast; - typing; - urllib3; - wcwidth; - webencodings; - werkzeug; - wheel; - wrapt; - wurlitzer; - xz; - yaml; - zeromq; - tqdm; - zlib; - zstd; - pytest; - numba; - hypothesis; - pytest-cov; - mypy; - pytest-xdist; - watchdog; - pytest-runner; - coveralls; - doctr; - gitpython; - pre-commit; - tox; - cookiecutter; - pdbpp; - sphinx-autobuild; - sphinx-autodoc-typehints; - sphinx_rtd_theme; - travis-encrypt; - twine; - nbval; - nbsphinx; - watermark,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1558#issuecomment-842089563
https://github.com/qutip/qutip/pull/1558#issuecomment-842089563:2243,Usability,simpl,simplegeneric,2243,ng; - libprotobuf; - libsodium; - libssh2; - libtiff; - libxml2; - libxslt; - llvm; - llvm-openmp; - lxml; - make; - markdown; - markupsafe; - matplotlib; - mccabe; - mistune; - mkl; - mkl_fft; - mkl_random; - mock; - mpc; - mpfr; - mpmath; - nbconvert; - nbformat; - ncurses; - nomkl; - notebook; - numpy; - numpy-base; - numpydoc; - olefile; - openblas; - openblas-devel; - openssl; - packaging; - pandas; - pandoc; - pandocfilters; - pango; - pari; - parso; - patsy; - pbr; - pcre; - perl; - pexpect; - pickleshare; - pillow; - pip; - pixman; - prometheus_client; - prompt_toolkit; - protobuf; - psutil; - ptyprocess; - pycodestyle; - pycparser; - pyflakes; - pygments; - pylint; - pyopenssl; - pyparsing; - pyqt; - pyrsistent; - pysocks; - python; - python-dateutil; - python-symengine; - pytz; - pyyaml; - pyzmq; - qt; - qtawesome; - qtconsole; - qtpy; - qutip; - r-base; - r-clisymbols; - readline; - reportlab; - requests; - rope; - scikit-learn; - scipy; - send2trash; - setuptools; - simplegeneric; - sip; - six; - snowballstemmer; - sphinx; - sphinxcontrib; - sphinxcontrib-applehelp; - sphinxcontrib-devhelp; - sphinxcontrib-htmlhelp; - sphinxcontrib-jsmath; - sphinxcontrib-qthelp; - sphinxcontrib-serializinghtml; - sphinxcontrib-websupport; - spyder; - spyder-kernels; - sqlite; - symengine; - symmetrica; - sympow; - sympy; - tensorboard; - tensorflow; - tensorflow-base; - tensorflow-estimator; - termcolor; - terminado; - testpath; - tk; - tktable; - tornado; - traitlets; - typed-ast; - typing; - urllib3; - wcwidth; - webencodings; - werkzeug; - wheel; - wrapt; - wurlitzer; - xz; - yaml; - zeromq; - tqdm; - zlib; - zstd; - pytest; - numba; - hypothesis; - pytest-cov; - mypy; - pytest-xdist; - watchdog; - pytest-runner; - coveralls; - doctr; - gitpython; - pre-commit; - tox; - cookiecutter; - pdbpp; - sphinx-autobuild; - sphinx-autodoc-typehints; - sphinx_rtd_theme; - travis-encrypt; - twine; - nbval; - nbsphinx; - watermark; - ipyparallel; - unittest2pytest; - pytest-bench,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1558#issuecomment-842089563
https://github.com/qutip/qutip/issues/1559#issuecomment-846382792:84,Availability,error,error,84,"I did try to understand the question you are investigating, but a quick look at the error report you can see that the problem is just in the final plotting. If you only fit the first 500 data points, you can only plot those first 500 points, unless you do some extrapolation in advance. So change the line to `ax.plot(times[:500], final, 'r')` should work.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1559#issuecomment-846382792
https://github.com/qutip/qutip/issues/1560#issuecomment-849604641:231,Integrability,depend,dependence,231,"I haven't checked, but I'd bet it's because we construct a new Liouvillian `QobjEvo` on entry to `mesolve` with collapse operators. If so, this is definitely a bug - we should have detected that the collapse operators have no time-dependence, so don't need to overwrite the `tlist`. As a temporary work-around, you can construct the Liouvillian directly and pass it to `mesolve`:; ```python; liouvillian = qutip.liouvillian(ham, collapse); qutip.mesolve(liouvillian, rho, eval_times); ```; which should work fine for now.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1560#issuecomment-849604641
https://github.com/qutip/qutip/issues/1560#issuecomment-849604641:181,Safety,detect,detected,181,"I haven't checked, but I'd bet it's because we construct a new Liouvillian `QobjEvo` on entry to `mesolve` with collapse operators. If so, this is definitely a bug - we should have detected that the collapse operators have no time-dependence, so don't need to overwrite the `tlist`. As a temporary work-around, you can construct the Liouvillian directly and pass it to `mesolve`:; ```python; liouvillian = qutip.liouvillian(ham, collapse); qutip.mesolve(liouvillian, rho, eval_times); ```; which should work fine for now.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1560#issuecomment-849604641
https://github.com/qutip/qutip/pull/1561#issuecomment-849750278:318,Integrability,depend,dependent,318,"I've just pushed an extra commit purely to keep CodeClimate happy - I had to touch a line in a logic block that CodeClimate already didn't like, so it moaned that I hadn't fixed it. This just separates out the logic to make it a bit easier to read. As a side-effect, it allows iterable type to be used inside the time-dependent object list of `QobjEvo` (only - doesn't affect anywhere that doesn't use `QobjEvo`), so; ```python; qutip.QobjEvo([qutip.sigmax(), (qutip.sigmay(), '1')]); ```; is now a valid specifier (note the tuple in the list).",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1561#issuecomment-849750278
https://github.com/qutip/qutip/pull/1561#issuecomment-849750278:95,Testability,log,logic,95,"I've just pushed an extra commit purely to keep CodeClimate happy - I had to touch a line in a logic block that CodeClimate already didn't like, so it moaned that I hadn't fixed it. This just separates out the logic to make it a bit easier to read. As a side-effect, it allows iterable type to be used inside the time-dependent object list of `QobjEvo` (only - doesn't affect anywhere that doesn't use `QobjEvo`), so; ```python; qutip.QobjEvo([qutip.sigmax(), (qutip.sigmay(), '1')]); ```; is now a valid specifier (note the tuple in the list).",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1561#issuecomment-849750278
https://github.com/qutip/qutip/pull/1561#issuecomment-849750278:210,Testability,log,logic,210,"I've just pushed an extra commit purely to keep CodeClimate happy - I had to touch a line in a logic block that CodeClimate already didn't like, so it moaned that I hadn't fixed it. This just separates out the logic to make it a bit easier to read. As a side-effect, it allows iterable type to be used inside the time-dependent object list of `QobjEvo` (only - doesn't affect anywhere that doesn't use `QobjEvo`), so; ```python; qutip.QobjEvo([qutip.sigmax(), (qutip.sigmay(), '1')]); ```; is now a valid specifier (note the tuple in the list).",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1561#issuecomment-849750278
https://github.com/qutip/qutip/pull/1563#issuecomment-852728895:202,Integrability,depend,dependabot,202,[![Coverage Status](https://coveralls.io/builds/40227940/badge)](https://coveralls.io/builds/40227940). Coverage increased (+0.01%) to 64.941% when pulling **78983f00acb67892bd75a66a380d5d46018e1e7c on dependabot/pip/doc/urllib3-1.26.5** into **acb6cfe23f951673b8f4bcba7ea0b7a62b1e6305 on master**.,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1563#issuecomment-852728895
https://github.com/qutip/qutip/pull/1564#issuecomment-852993886:223,Deployability,update,update-,223,[![Coverage Status](https://coveralls.io/builds/40239573/badge)](https://coveralls.io/builds/40239573). Coverage increased (+0.009%) to 64.937% when pulling **40af6dde3a558f2b2ba78b0ca03a34b6208f9be7 on quantshah:changelog-update-4.6.2** into **acb6cfe23f951673b8f4bcba7ea0b7a62b1e6305 on qutip:master**.,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1564#issuecomment-852993886
https://github.com/qutip/qutip/issues/1566#issuecomment-857532355:1394,Availability,mainten,maintenance,1394,"Hi @VolodyaCO, thanks for reporting this!; I think the reason for `tlist` being overridden is because the result will be independent of `tlist` when the input is a steady-state. This can be seen in the following equations:; ![image](https://user-images.githubusercontent.com/57414022/121327018-5d313680-c913-11eb-9760-ca6004daca18.png); where rho is the initial state (`state0`) and H is the Hamiltonian of the system. I use the fact that rho is a steady-state to remove its temporal dependence. This derivation is simplified assuming unitary evolution (no collapse operators) but the same applies in the most general case where we include the collapse operators. This is my guess on why `tlist=[0]` is employed when using `state0=None`: the result does not depend on `tlist`. Hence, this is probably not a bug as the result should be mathematically correct. That being said, I would also expect the same output shape for the cases shown above unless explicitly mentioned in the docstring of the function. Thus, I think the way to go here is to document this behaviour in the docstring (as well as removing the t appearing in correlation_..._1t docstring) as any change in the output shape will break backwards compatibility. However, it may be worth considering whether this is the intended behaviour for QuTiP 5. I would suggest removing `state0=None` as possible input for simplicity in the maintenance and testing or at least I would make the example shown by @VolodyaCO to be consistent and have the same output. Let us see what the QuTiP admin team thinks :smile:",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1566#issuecomment-857532355
https://github.com/qutip/qutip/issues/1566#issuecomment-857532355:484,Integrability,depend,dependence,484,"Hi @VolodyaCO, thanks for reporting this!; I think the reason for `tlist` being overridden is because the result will be independent of `tlist` when the input is a steady-state. This can be seen in the following equations:; ![image](https://user-images.githubusercontent.com/57414022/121327018-5d313680-c913-11eb-9760-ca6004daca18.png); where rho is the initial state (`state0`) and H is the Hamiltonian of the system. I use the fact that rho is a steady-state to remove its temporal dependence. This derivation is simplified assuming unitary evolution (no collapse operators) but the same applies in the most general case where we include the collapse operators. This is my guess on why `tlist=[0]` is employed when using `state0=None`: the result does not depend on `tlist`. Hence, this is probably not a bug as the result should be mathematically correct. That being said, I would also expect the same output shape for the cases shown above unless explicitly mentioned in the docstring of the function. Thus, I think the way to go here is to document this behaviour in the docstring (as well as removing the t appearing in correlation_..._1t docstring) as any change in the output shape will break backwards compatibility. However, it may be worth considering whether this is the intended behaviour for QuTiP 5. I would suggest removing `state0=None` as possible input for simplicity in the maintenance and testing or at least I would make the example shown by @VolodyaCO to be consistent and have the same output. Let us see what the QuTiP admin team thinks :smile:",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1566#issuecomment-857532355
https://github.com/qutip/qutip/issues/1566#issuecomment-857532355:758,Integrability,depend,depend,758,"Hi @VolodyaCO, thanks for reporting this!; I think the reason for `tlist` being overridden is because the result will be independent of `tlist` when the input is a steady-state. This can be seen in the following equations:; ![image](https://user-images.githubusercontent.com/57414022/121327018-5d313680-c913-11eb-9760-ca6004daca18.png); where rho is the initial state (`state0`) and H is the Hamiltonian of the system. I use the fact that rho is a steady-state to remove its temporal dependence. This derivation is simplified assuming unitary evolution (no collapse operators) but the same applies in the most general case where we include the collapse operators. This is my guess on why `tlist=[0]` is employed when using `state0=None`: the result does not depend on `tlist`. Hence, this is probably not a bug as the result should be mathematically correct. That being said, I would also expect the same output shape for the cases shown above unless explicitly mentioned in the docstring of the function. Thus, I think the way to go here is to document this behaviour in the docstring (as well as removing the t appearing in correlation_..._1t docstring) as any change in the output shape will break backwards compatibility. However, it may be worth considering whether this is the intended behaviour for QuTiP 5. I would suggest removing `state0=None` as possible input for simplicity in the maintenance and testing or at least I would make the example shown by @VolodyaCO to be consistent and have the same output. Let us see what the QuTiP admin team thinks :smile:",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1566#issuecomment-857532355
https://github.com/qutip/qutip/issues/1566#issuecomment-857532355:1410,Testability,test,testing,1410,"Hi @VolodyaCO, thanks for reporting this!; I think the reason for `tlist` being overridden is because the result will be independent of `tlist` when the input is a steady-state. This can be seen in the following equations:; ![image](https://user-images.githubusercontent.com/57414022/121327018-5d313680-c913-11eb-9760-ca6004daca18.png); where rho is the initial state (`state0`) and H is the Hamiltonian of the system. I use the fact that rho is a steady-state to remove its temporal dependence. This derivation is simplified assuming unitary evolution (no collapse operators) but the same applies in the most general case where we include the collapse operators. This is my guess on why `tlist=[0]` is employed when using `state0=None`: the result does not depend on `tlist`. Hence, this is probably not a bug as the result should be mathematically correct. That being said, I would also expect the same output shape for the cases shown above unless explicitly mentioned in the docstring of the function. Thus, I think the way to go here is to document this behaviour in the docstring (as well as removing the t appearing in correlation_..._1t docstring) as any change in the output shape will break backwards compatibility. However, it may be worth considering whether this is the intended behaviour for QuTiP 5. I would suggest removing `state0=None` as possible input for simplicity in the maintenance and testing or at least I would make the example shown by @VolodyaCO to be consistent and have the same output. Let us see what the QuTiP admin team thinks :smile:",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1566#issuecomment-857532355
https://github.com/qutip/qutip/issues/1566#issuecomment-857532355:515,Usability,simpl,simplified,515,"Hi @VolodyaCO, thanks for reporting this!; I think the reason for `tlist` being overridden is because the result will be independent of `tlist` when the input is a steady-state. This can be seen in the following equations:; ![image](https://user-images.githubusercontent.com/57414022/121327018-5d313680-c913-11eb-9760-ca6004daca18.png); where rho is the initial state (`state0`) and H is the Hamiltonian of the system. I use the fact that rho is a steady-state to remove its temporal dependence. This derivation is simplified assuming unitary evolution (no collapse operators) but the same applies in the most general case where we include the collapse operators. This is my guess on why `tlist=[0]` is employed when using `state0=None`: the result does not depend on `tlist`. Hence, this is probably not a bug as the result should be mathematically correct. That being said, I would also expect the same output shape for the cases shown above unless explicitly mentioned in the docstring of the function. Thus, I think the way to go here is to document this behaviour in the docstring (as well as removing the t appearing in correlation_..._1t docstring) as any change in the output shape will break backwards compatibility. However, it may be worth considering whether this is the intended behaviour for QuTiP 5. I would suggest removing `state0=None` as possible input for simplicity in the maintenance and testing or at least I would make the example shown by @VolodyaCO to be consistent and have the same output. Let us see what the QuTiP admin team thinks :smile:",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1566#issuecomment-857532355
https://github.com/qutip/qutip/issues/1566#issuecomment-857532355:1376,Usability,simpl,simplicity,1376,"Hi @VolodyaCO, thanks for reporting this!; I think the reason for `tlist` being overridden is because the result will be independent of `tlist` when the input is a steady-state. This can be seen in the following equations:; ![image](https://user-images.githubusercontent.com/57414022/121327018-5d313680-c913-11eb-9760-ca6004daca18.png); where rho is the initial state (`state0`) and H is the Hamiltonian of the system. I use the fact that rho is a steady-state to remove its temporal dependence. This derivation is simplified assuming unitary evolution (no collapse operators) but the same applies in the most general case where we include the collapse operators. This is my guess on why `tlist=[0]` is employed when using `state0=None`: the result does not depend on `tlist`. Hence, this is probably not a bug as the result should be mathematically correct. That being said, I would also expect the same output shape for the cases shown above unless explicitly mentioned in the docstring of the function. Thus, I think the way to go here is to document this behaviour in the docstring (as well as removing the t appearing in correlation_..._1t docstring) as any change in the output shape will break backwards compatibility. However, it may be worth considering whether this is the intended behaviour for QuTiP 5. I would suggest removing `state0=None` as possible input for simplicity in the maintenance and testing or at least I would make the example shown by @VolodyaCO to be consistent and have the same output. Let us see what the QuTiP admin team thinks :smile:",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1566#issuecomment-857532355
https://github.com/qutip/qutip/issues/1566#issuecomment-857615073:438,Usability,clear,clear,438,"This appears to already be the document behaviour, see https://qutip.org/docs/latest/apidoc/functions.html#qutip.correlation.correlation_2op_2t:. > tlist: array_like; > list of times for t. tlist must be positive and contain the element 0. **When taking steady-steady; > correlations only one tlist value is necessary, i.e. when t → ∞; here tlist is automatically set, ignoring user input.**. Perhaps the documentation could be made more clear, but I don't think we should change the behaviour without a compelling reason since other QuTiP users may rely on it, and it seems sensible to return only a single result in the steady state case.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1566#issuecomment-857615073
https://github.com/qutip/qutip/pull/1567#issuecomment-855433303:216,Usability,guid,guide-states-typo,216,[![Coverage Status](https://coveralls.io/builds/40340740/badge)](https://coveralls.io/builds/40340740). Coverage increased (+0.004%) to 64.95% when pulling **51f8f2732253c7b89cd30afc4c0101760342db80 on LaurentAjdnik:guide-states-typo** into **b836829f7c5389185b676eed7c5f801613689f9f on qutip:master**.,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1567#issuecomment-855433303
https://github.com/qutip/qutip/issues/1571#issuecomment-858740451:314,Availability,error,error,314,"Most of it is already in qutip or in development:; - We already have a progress bar.; - We have feedback to support solvers where parameters are changed depending on the current state. Those should not updated at each time-step, but included in the rhs. Otherwise, it will increase runtime and often the numerical error. We mostly use multistep method (Adams and BDF) which are particularly sensible to that.; - In my rework of `mcsolve`, I'm including the capacity to stop after a certain time, (already merged) and after the error bar gets under a certain tolerance. I have not though an equivalent for `me/sesolve` would be needed but it would be simple enough to add. We could have function that takes the expect value and tell the solver to stop or continue. ; - I was thinking of adding the ability to step through the evolution (draft in #1455):; ```; solver = MeSolver(H, c_ops, options=opt); solver.start(t0, rho0); for t in [t1,t2, ...]:; rho_t = solver.step(t, args=new_args); ```; Which would work like a `yield`:; ```; solver = MeSolver(H, c_ops, options=opt); for rho_t in solver.yield_run(rho0, tlist):; if needed:; solver.update_parameter(args=new_args); ```; I prefer using steps since you don't have do define `tlist` first, you could use it in a `while True` loop or interactively.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1571#issuecomment-858740451
https://github.com/qutip/qutip/issues/1571#issuecomment-858740451:527,Availability,error,error,527,"Most of it is already in qutip or in development:; - We already have a progress bar.; - We have feedback to support solvers where parameters are changed depending on the current state. Those should not updated at each time-step, but included in the rhs. Otherwise, it will increase runtime and often the numerical error. We mostly use multistep method (Adams and BDF) which are particularly sensible to that.; - In my rework of `mcsolve`, I'm including the capacity to stop after a certain time, (already merged) and after the error bar gets under a certain tolerance. I have not though an equivalent for `me/sesolve` would be needed but it would be simple enough to add. We could have function that takes the expect value and tell the solver to stop or continue. ; - I was thinking of adding the ability to step through the evolution (draft in #1455):; ```; solver = MeSolver(H, c_ops, options=opt); solver.start(t0, rho0); for t in [t1,t2, ...]:; rho_t = solver.step(t, args=new_args); ```; Which would work like a `yield`:; ```; solver = MeSolver(H, c_ops, options=opt); for rho_t in solver.yield_run(rho0, tlist):; if needed:; solver.update_parameter(args=new_args); ```; I prefer using steps since you don't have do define `tlist` first, you could use it in a `while True` loop or interactively.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1571#issuecomment-858740451
https://github.com/qutip/qutip/issues/1571#issuecomment-858740451:558,Availability,toler,tolerance,558,"Most of it is already in qutip or in development:; - We already have a progress bar.; - We have feedback to support solvers where parameters are changed depending on the current state. Those should not updated at each time-step, but included in the rhs. Otherwise, it will increase runtime and often the numerical error. We mostly use multistep method (Adams and BDF) which are particularly sensible to that.; - In my rework of `mcsolve`, I'm including the capacity to stop after a certain time, (already merged) and after the error bar gets under a certain tolerance. I have not though an equivalent for `me/sesolve` would be needed but it would be simple enough to add. We could have function that takes the expect value and tell the solver to stop or continue. ; - I was thinking of adding the ability to step through the evolution (draft in #1455):; ```; solver = MeSolver(H, c_ops, options=opt); solver.start(t0, rho0); for t in [t1,t2, ...]:; rho_t = solver.step(t, args=new_args); ```; Which would work like a `yield`:; ```; solver = MeSolver(H, c_ops, options=opt); for rho_t in solver.yield_run(rho0, tlist):; if needed:; solver.update_parameter(args=new_args); ```; I prefer using steps since you don't have do define `tlist` first, you could use it in a `while True` loop or interactively.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1571#issuecomment-858740451
https://github.com/qutip/qutip/issues/1571#issuecomment-858740451:202,Deployability,update,updated,202,"Most of it is already in qutip or in development:; - We already have a progress bar.; - We have feedback to support solvers where parameters are changed depending on the current state. Those should not updated at each time-step, but included in the rhs. Otherwise, it will increase runtime and often the numerical error. We mostly use multistep method (Adams and BDF) which are particularly sensible to that.; - In my rework of `mcsolve`, I'm including the capacity to stop after a certain time, (already merged) and after the error bar gets under a certain tolerance. I have not though an equivalent for `me/sesolve` would be needed but it would be simple enough to add. We could have function that takes the expect value and tell the solver to stop or continue. ; - I was thinking of adding the ability to step through the evolution (draft in #1455):; ```; solver = MeSolver(H, c_ops, options=opt); solver.start(t0, rho0); for t in [t1,t2, ...]:; rho_t = solver.step(t, args=new_args); ```; Which would work like a `yield`:; ```; solver = MeSolver(H, c_ops, options=opt); for rho_t in solver.yield_run(rho0, tlist):; if needed:; solver.update_parameter(args=new_args); ```; I prefer using steps since you don't have do define `tlist` first, you could use it in a `while True` loop or interactively.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1571#issuecomment-858740451
https://github.com/qutip/qutip/issues/1571#issuecomment-858740451:153,Integrability,depend,depending,153,"Most of it is already in qutip or in development:; - We already have a progress bar.; - We have feedback to support solvers where parameters are changed depending on the current state. Those should not updated at each time-step, but included in the rhs. Otherwise, it will increase runtime and often the numerical error. We mostly use multistep method (Adams and BDF) which are particularly sensible to that.; - In my rework of `mcsolve`, I'm including the capacity to stop after a certain time, (already merged) and after the error bar gets under a certain tolerance. I have not though an equivalent for `me/sesolve` would be needed but it would be simple enough to add. We could have function that takes the expect value and tell the solver to stop or continue. ; - I was thinking of adding the ability to step through the evolution (draft in #1455):; ```; solver = MeSolver(H, c_ops, options=opt); solver.start(t0, rho0); for t in [t1,t2, ...]:; rho_t = solver.step(t, args=new_args); ```; Which would work like a `yield`:; ```; solver = MeSolver(H, c_ops, options=opt); for rho_t in solver.yield_run(rho0, tlist):; if needed:; solver.update_parameter(args=new_args); ```; I prefer using steps since you don't have do define `tlist` first, you could use it in a `while True` loop or interactively.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1571#issuecomment-858740451
https://github.com/qutip/qutip/issues/1571#issuecomment-858740451:71,Usability,progress bar,progress bar,71,"Most of it is already in qutip or in development:; - We already have a progress bar.; - We have feedback to support solvers where parameters are changed depending on the current state. Those should not updated at each time-step, but included in the rhs. Otherwise, it will increase runtime and often the numerical error. We mostly use multistep method (Adams and BDF) which are particularly sensible to that.; - In my rework of `mcsolve`, I'm including the capacity to stop after a certain time, (already merged) and after the error bar gets under a certain tolerance. I have not though an equivalent for `me/sesolve` would be needed but it would be simple enough to add. We could have function that takes the expect value and tell the solver to stop or continue. ; - I was thinking of adding the ability to step through the evolution (draft in #1455):; ```; solver = MeSolver(H, c_ops, options=opt); solver.start(t0, rho0); for t in [t1,t2, ...]:; rho_t = solver.step(t, args=new_args); ```; Which would work like a `yield`:; ```; solver = MeSolver(H, c_ops, options=opt); for rho_t in solver.yield_run(rho0, tlist):; if needed:; solver.update_parameter(args=new_args); ```; I prefer using steps since you don't have do define `tlist` first, you could use it in a `while True` loop or interactively.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1571#issuecomment-858740451
https://github.com/qutip/qutip/issues/1571#issuecomment-858740451:96,Usability,feedback,feedback,96,"Most of it is already in qutip or in development:; - We already have a progress bar.; - We have feedback to support solvers where parameters are changed depending on the current state. Those should not updated at each time-step, but included in the rhs. Otherwise, it will increase runtime and often the numerical error. We mostly use multistep method (Adams and BDF) which are particularly sensible to that.; - In my rework of `mcsolve`, I'm including the capacity to stop after a certain time, (already merged) and after the error bar gets under a certain tolerance. I have not though an equivalent for `me/sesolve` would be needed but it would be simple enough to add. We could have function that takes the expect value and tell the solver to stop or continue. ; - I was thinking of adding the ability to step through the evolution (draft in #1455):; ```; solver = MeSolver(H, c_ops, options=opt); solver.start(t0, rho0); for t in [t1,t2, ...]:; rho_t = solver.step(t, args=new_args); ```; Which would work like a `yield`:; ```; solver = MeSolver(H, c_ops, options=opt); for rho_t in solver.yield_run(rho0, tlist):; if needed:; solver.update_parameter(args=new_args); ```; I prefer using steps since you don't have do define `tlist` first, you could use it in a `while True` loop or interactively.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1571#issuecomment-858740451
https://github.com/qutip/qutip/issues/1571#issuecomment-858740451:650,Usability,simpl,simple,650,"Most of it is already in qutip or in development:; - We already have a progress bar.; - We have feedback to support solvers where parameters are changed depending on the current state. Those should not updated at each time-step, but included in the rhs. Otherwise, it will increase runtime and often the numerical error. We mostly use multistep method (Adams and BDF) which are particularly sensible to that.; - In my rework of `mcsolve`, I'm including the capacity to stop after a certain time, (already merged) and after the error bar gets under a certain tolerance. I have not though an equivalent for `me/sesolve` would be needed but it would be simple enough to add. We could have function that takes the expect value and tell the solver to stop or continue. ; - I was thinking of adding the ability to step through the evolution (draft in #1455):; ```; solver = MeSolver(H, c_ops, options=opt); solver.start(t0, rho0); for t in [t1,t2, ...]:; rho_t = solver.step(t, args=new_args); ```; Which would work like a `yield`:; ```; solver = MeSolver(H, c_ops, options=opt); for rho_t in solver.yield_run(rho0, tlist):; if needed:; solver.update_parameter(args=new_args); ```; I prefer using steps since you don't have do define `tlist` first, you could use it in a `while True` loop or interactively.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1571#issuecomment-858740451
https://github.com/qutip/qutip/issues/1571#issuecomment-859578358:379,Integrability,depend,dependent,379,"@Ericgig `.step(...)` looks like a great solution. We should definine more precisely what one is allowed to modify in between calls to `.step` and document that. Aside regarding things we have already implemented: I know -- my point is that there are many such things and we have only implemented one kind of each (for example, what kind of progress bar is appropriate is highly dependent on the environment the code is running in -- if the code is running on a server without a terminal it might be some kind of logging, inside a hypothetical QuTiP UI GUI application it might be a progress bar provided by the GUI toolkit being used, etc).",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1571#issuecomment-859578358
https://github.com/qutip/qutip/issues/1571#issuecomment-859578358:513,Testability,log,logging,513,"@Ericgig `.step(...)` looks like a great solution. We should definine more precisely what one is allowed to modify in between calls to `.step` and document that. Aside regarding things we have already implemented: I know -- my point is that there are many such things and we have only implemented one kind of each (for example, what kind of progress bar is appropriate is highly dependent on the environment the code is running in -- if the code is running on a server without a terminal it might be some kind of logging, inside a hypothetical QuTiP UI GUI application it might be a progress bar provided by the GUI toolkit being used, etc).",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1571#issuecomment-859578358
https://github.com/qutip/qutip/issues/1571#issuecomment-859578358:341,Usability,progress bar,progress bar,341,"@Ericgig `.step(...)` looks like a great solution. We should definine more precisely what one is allowed to modify in between calls to `.step` and document that. Aside regarding things we have already implemented: I know -- my point is that there are many such things and we have only implemented one kind of each (for example, what kind of progress bar is appropriate is highly dependent on the environment the code is running in -- if the code is running on a server without a terminal it might be some kind of logging, inside a hypothetical QuTiP UI GUI application it might be a progress bar provided by the GUI toolkit being used, etc).",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1571#issuecomment-859578358
https://github.com/qutip/qutip/issues/1571#issuecomment-859578358:583,Usability,progress bar,progress bar,583,"@Ericgig `.step(...)` looks like a great solution. We should definine more precisely what one is allowed to modify in between calls to `.step` and document that. Aside regarding things we have already implemented: I know -- my point is that there are many such things and we have only implemented one kind of each (for example, what kind of progress bar is appropriate is highly dependent on the environment the code is running in -- if the code is running on a server without a terminal it might be some kind of logging, inside a hypothetical QuTiP UI GUI application it might be a progress bar provided by the GUI toolkit being used, etc).",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1571#issuecomment-859578358
https://github.com/qutip/qutip/issues/1571#issuecomment-859754215:2952,Availability,avail,available,2952,"ecomment-859717563 on the requirements: beyond yielding the propagated states, we'll also have to modify the controls, i.e. the time-dependencies for QuTiP's nested-list format. Within the `krotov` package, these would always be numpy arrays. As an explanation, see [the figure for Krotov's update scheme](https://qucontrol.github.io/krotov/v1.2.1/_images/krotovscheme.svg) from [the documentation](https://qucontrol.github.io/krotov/v1.2.1/07_krotovs_method.html#time-discretization). The single-step-`mesolve` would be for the ""(2) forward-propagation with updated control"" in the bottom of the diagram: After each propagation time step, we calculate a new control value based on the current propagated state and other information (the ∂H/∂ϵ and stored backward-propagated states χ). The new control value is then used for the next time step. I'd also add that `mesolve` ideally should be ""thread-safe"" in the sense that we may have multiple `mesolve` run in parallel (index k in the diagram, where all the different k contribute to the update of the control values at the next time step), within whatever parallelization framework Python makes available. I vaguely remember looking at some Runge-Kutta implementations within scipy where this was a problem. I noted this in the docstring of krotov's [`DensityMatrixODEPropagator`](https://github.com/qucontrol/krotov/blob/master/src/krotov/propagators.py#L162), which was an attempt to adapt some of `mesolve`'s inner workings to Krotov's needs. It turned out the overhead was still too large for this work very well, cf. the large runtime of the [corresponding example](https://qucontrol.github.io/krotov/v1.2.1/notebooks/06_example_3states.html). To get very technical, Krotov's requirements are laid out in the documentation of the [`Propagator`](https://github.com/qucontrol/krotov/blob/master/src/krotov/propagators.py#L125) abstract base class, [`DensityMatrixODEPropagator`](https://github.com/qucontrol/krotov/blob/master/src/krotov/propagat",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1571#issuecomment-859754215
https://github.com/qutip/qutip/issues/1571#issuecomment-859754215:2096,Deployability,update,update,2096,"ve`, but it's certainly less flexible. So even then, an mesolve that can do single steps would still be great. I would also think that being able to do time steps would be exceedingly useful to *any* gradient-based optimal control scheme. Wouldn't it greatly simplify your own GRAPE implementation? I'm referring to the ""Object model"" in [Optimal Quantum Control in QuTiP](https://qutip.org/docs/latest/guide/guide-control.html?highlight=grape#optimal-quantum-control-in-qutip), specifically the `TimeslotComputer` (in fact, we looked at whether `TimeslotComputer` could be used for krotov at the time, but couldn't quite figure it out). I elaborated a little bit in https://github.com/qucontrol/krotov/issues/93#issuecomment-859717563 on the requirements: beyond yielding the propagated states, we'll also have to modify the controls, i.e. the time-dependencies for QuTiP's nested-list format. Within the `krotov` package, these would always be numpy arrays. As an explanation, see [the figure for Krotov's update scheme](https://qucontrol.github.io/krotov/v1.2.1/_images/krotovscheme.svg) from [the documentation](https://qucontrol.github.io/krotov/v1.2.1/07_krotovs_method.html#time-discretization). The single-step-`mesolve` would be for the ""(2) forward-propagation with updated control"" in the bottom of the diagram: After each propagation time step, we calculate a new control value based on the current propagated state and other information (the ∂H/∂ϵ and stored backward-propagated states χ). The new control value is then used for the next time step. I'd also add that `mesolve` ideally should be ""thread-safe"" in the sense that we may have multiple `mesolve` run in parallel (index k in the diagram, where all the different k contribute to the update of the control values at the next time step), within whatever parallelization framework Python makes available. I vaguely remember looking at some Runge-Kutta implementations within scipy where this was a problem. I noted this in the doc",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1571#issuecomment-859754215
https://github.com/qutip/qutip/issues/1571#issuecomment-859754215:2364,Deployability,update,updated,2364,"um Control in QuTiP](https://qutip.org/docs/latest/guide/guide-control.html?highlight=grape#optimal-quantum-control-in-qutip), specifically the `TimeslotComputer` (in fact, we looked at whether `TimeslotComputer` could be used for krotov at the time, but couldn't quite figure it out). I elaborated a little bit in https://github.com/qucontrol/krotov/issues/93#issuecomment-859717563 on the requirements: beyond yielding the propagated states, we'll also have to modify the controls, i.e. the time-dependencies for QuTiP's nested-list format. Within the `krotov` package, these would always be numpy arrays. As an explanation, see [the figure for Krotov's update scheme](https://qucontrol.github.io/krotov/v1.2.1/_images/krotovscheme.svg) from [the documentation](https://qucontrol.github.io/krotov/v1.2.1/07_krotovs_method.html#time-discretization). The single-step-`mesolve` would be for the ""(2) forward-propagation with updated control"" in the bottom of the diagram: After each propagation time step, we calculate a new control value based on the current propagated state and other information (the ∂H/∂ϵ and stored backward-propagated states χ). The new control value is then used for the next time step. I'd also add that `mesolve` ideally should be ""thread-safe"" in the sense that we may have multiple `mesolve` run in parallel (index k in the diagram, where all the different k contribute to the update of the control values at the next time step), within whatever parallelization framework Python makes available. I vaguely remember looking at some Runge-Kutta implementations within scipy where this was a problem. I noted this in the docstring of krotov's [`DensityMatrixODEPropagator`](https://github.com/qucontrol/krotov/blob/master/src/krotov/propagators.py#L162), which was an attempt to adapt some of `mesolve`'s inner workings to Krotov's needs. It turned out the overhead was still too large for this work very well, cf. the large runtime of the [corresponding example](https://quco",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1571#issuecomment-859754215
https://github.com/qutip/qutip/issues/1571#issuecomment-859754215:2844,Deployability,update,update,2844,"ecomment-859717563 on the requirements: beyond yielding the propagated states, we'll also have to modify the controls, i.e. the time-dependencies for QuTiP's nested-list format. Within the `krotov` package, these would always be numpy arrays. As an explanation, see [the figure for Krotov's update scheme](https://qucontrol.github.io/krotov/v1.2.1/_images/krotovscheme.svg) from [the documentation](https://qucontrol.github.io/krotov/v1.2.1/07_krotovs_method.html#time-discretization). The single-step-`mesolve` would be for the ""(2) forward-propagation with updated control"" in the bottom of the diagram: After each propagation time step, we calculate a new control value based on the current propagated state and other information (the ∂H/∂ϵ and stored backward-propagated states χ). The new control value is then used for the next time step. I'd also add that `mesolve` ideally should be ""thread-safe"" in the sense that we may have multiple `mesolve` run in parallel (index k in the diagram, where all the different k contribute to the update of the control values at the next time step), within whatever parallelization framework Python makes available. I vaguely remember looking at some Runge-Kutta implementations within scipy where this was a problem. I noted this in the docstring of krotov's [`DensityMatrixODEPropagator`](https://github.com/qucontrol/krotov/blob/master/src/krotov/propagators.py#L162), which was an attempt to adapt some of `mesolve`'s inner workings to Krotov's needs. It turned out the overhead was still too large for this work very well, cf. the large runtime of the [corresponding example](https://qucontrol.github.io/krotov/v1.2.1/notebooks/06_example_3states.html). To get very technical, Krotov's requirements are laid out in the documentation of the [`Propagator`](https://github.com/qucontrol/krotov/blob/master/src/krotov/propagators.py#L125) abstract base class, [`DensityMatrixODEPropagator`](https://github.com/qucontrol/krotov/blob/master/src/krotov/propagat",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1571#issuecomment-859754215
https://github.com/qutip/qutip/issues/1571#issuecomment-859754215:3243,Energy Efficiency,adapt,adapt,3243,"s_method.html#time-discretization). The single-step-`mesolve` would be for the ""(2) forward-propagation with updated control"" in the bottom of the diagram: After each propagation time step, we calculate a new control value based on the current propagated state and other information (the ∂H/∂ϵ and stored backward-propagated states χ). The new control value is then used for the next time step. I'd also add that `mesolve` ideally should be ""thread-safe"" in the sense that we may have multiple `mesolve` run in parallel (index k in the diagram, where all the different k contribute to the update of the control values at the next time step), within whatever parallelization framework Python makes available. I vaguely remember looking at some Runge-Kutta implementations within scipy where this was a problem. I noted this in the docstring of krotov's [`DensityMatrixODEPropagator`](https://github.com/qucontrol/krotov/blob/master/src/krotov/propagators.py#L162), which was an attempt to adapt some of `mesolve`'s inner workings to Krotov's needs. It turned out the overhead was still too large for this work very well, cf. the large runtime of the [corresponding example](https://qucontrol.github.io/krotov/v1.2.1/notebooks/06_example_3states.html). To get very technical, Krotov's requirements are laid out in the documentation of the [`Propagator`](https://github.com/qucontrol/krotov/blob/master/src/krotov/propagators.py#L125) abstract base class, [`DensityMatrixODEPropagator`](https://github.com/qucontrol/krotov/blob/master/src/krotov/propagators.py#L162) being a particular example. In particular, the interface we define there is strictly for a single time step, makes no reference to `tlist` and we use ``H=[H0, [H1, u]]`` where `u` is a scalar for that particular timestep. However, I can easily write a wrapper around an `mesolve` that would work something along the lines of the pseudo-code from https://github.com/qucontrol/krotov/issues/93#issuecomment-859717563:. ~~~; for (i, state) ",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1571#issuecomment-859754215
https://github.com/qutip/qutip/issues/1571#issuecomment-859754215:1938,Integrability,depend,dependencies,1938,"or Newton polynomials). That work hasn't really been going anywhere lately, though. It may or may not end up being faster than `mesolve`, but it's certainly less flexible. So even then, an mesolve that can do single steps would still be great. I would also think that being able to do time steps would be exceedingly useful to *any* gradient-based optimal control scheme. Wouldn't it greatly simplify your own GRAPE implementation? I'm referring to the ""Object model"" in [Optimal Quantum Control in QuTiP](https://qutip.org/docs/latest/guide/guide-control.html?highlight=grape#optimal-quantum-control-in-qutip), specifically the `TimeslotComputer` (in fact, we looked at whether `TimeslotComputer` could be used for krotov at the time, but couldn't quite figure it out). I elaborated a little bit in https://github.com/qucontrol/krotov/issues/93#issuecomment-859717563 on the requirements: beyond yielding the propagated states, we'll also have to modify the controls, i.e. the time-dependencies for QuTiP's nested-list format. Within the `krotov` package, these would always be numpy arrays. As an explanation, see [the figure for Krotov's update scheme](https://qucontrol.github.io/krotov/v1.2.1/_images/krotovscheme.svg) from [the documentation](https://qucontrol.github.io/krotov/v1.2.1/07_krotovs_method.html#time-discretization). The single-step-`mesolve` would be for the ""(2) forward-propagation with updated control"" in the bottom of the diagram: After each propagation time step, we calculate a new control value based on the current propagated state and other information (the ∂H/∂ϵ and stored backward-propagated states χ). The new control value is then used for the next time step. I'd also add that `mesolve` ideally should be ""thread-safe"" in the sense that we may have multiple `mesolve` run in parallel (index k in the diagram, where all the different k contribute to the update of the control values at the next time step), within whatever parallelization framework Python makes ava",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1571#issuecomment-859754215
https://github.com/qutip/qutip/issues/1571#issuecomment-859754215:3866,Integrability,interface,interface,3866,"on makes available. I vaguely remember looking at some Runge-Kutta implementations within scipy where this was a problem. I noted this in the docstring of krotov's [`DensityMatrixODEPropagator`](https://github.com/qucontrol/krotov/blob/master/src/krotov/propagators.py#L162), which was an attempt to adapt some of `mesolve`'s inner workings to Krotov's needs. It turned out the overhead was still too large for this work very well, cf. the large runtime of the [corresponding example](https://qucontrol.github.io/krotov/v1.2.1/notebooks/06_example_3states.html). To get very technical, Krotov's requirements are laid out in the documentation of the [`Propagator`](https://github.com/qucontrol/krotov/blob/master/src/krotov/propagators.py#L125) abstract base class, [`DensityMatrixODEPropagator`](https://github.com/qucontrol/krotov/blob/master/src/krotov/propagators.py#L162) being a particular example. In particular, the interface we define there is strictly for a single time step, makes no reference to `tlist` and we use ``H=[H0, [H1, u]]`` where `u` is a scalar for that particular timestep. However, I can easily write a wrapper around an `mesolve` that would work something along the lines of the pseudo-code from https://github.com/qucontrol/krotov/issues/93#issuecomment-859717563:. ~~~; for (i, state) in enumerate(; mesolve([H0, [H1, ctrl_array]], state0, list); ):; # assuming `state` is at tlist[i]; new_val = calculate_control_value_for_next_step(state); ctrl_array[i] = new_val; ctrl_array[i+1] = new_val # ignoring IndexError; ~~~. So I don't think you'd have to worry about these details: any implementation with low overhead that would allow me to get the states from `mesolve` as well as tweak the control fields for the next time step should be sufficient. In particular, the `.step` that you discuss in https://github.com/qutip/qutip/issues/1571#issuecomment-858740451 looks very much like it's going in the right direction! The one option from the earlier https://github.com/qu",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1571#issuecomment-859754215
https://github.com/qutip/qutip/issues/1571#issuecomment-859754215:4071,Integrability,wrap,wrapper,4071,"ensityMatrixODEPropagator`](https://github.com/qucontrol/krotov/blob/master/src/krotov/propagators.py#L162), which was an attempt to adapt some of `mesolve`'s inner workings to Krotov's needs. It turned out the overhead was still too large for this work very well, cf. the large runtime of the [corresponding example](https://qucontrol.github.io/krotov/v1.2.1/notebooks/06_example_3states.html). To get very technical, Krotov's requirements are laid out in the documentation of the [`Propagator`](https://github.com/qucontrol/krotov/blob/master/src/krotov/propagators.py#L125) abstract base class, [`DensityMatrixODEPropagator`](https://github.com/qucontrol/krotov/blob/master/src/krotov/propagators.py#L162) being a particular example. In particular, the interface we define there is strictly for a single time step, makes no reference to `tlist` and we use ``H=[H0, [H1, u]]`` where `u` is a scalar for that particular timestep. However, I can easily write a wrapper around an `mesolve` that would work something along the lines of the pseudo-code from https://github.com/qucontrol/krotov/issues/93#issuecomment-859717563:. ~~~; for (i, state) in enumerate(; mesolve([H0, [H1, ctrl_array]], state0, list); ):; # assuming `state` is at tlist[i]; new_val = calculate_control_value_for_next_step(state); ctrl_array[i] = new_val; ctrl_array[i+1] = new_val # ignoring IndexError; ~~~. So I don't think you'd have to worry about these details: any implementation with low overhead that would allow me to get the states from `mesolve` as well as tweak the control fields for the next time step should be sufficient. In particular, the `.step` that you discuss in https://github.com/qutip/qutip/issues/1571#issuecomment-858740451 looks very much like it's going in the right direction! The one option from the earlier https://github.com/qutip/qutip/issues/1571#issue-917391349 that might *not* work very well is callback functions. I *might* be able to work around that, but it wouldn't really fit into the",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1571#issuecomment-859754215
https://github.com/qutip/qutip/issues/1571#issuecomment-859754215:1117,Modifiability,flexible,flexible,1117,"would something like this be to you? Do you think you'd keep an implementation based on this long term? Or would you end up implementing your own thing in the end anyway?. It would be *extremely* useful. It would become the default propagator for the krotov package. I would expect that with the ability to propagate single time steps with `mesolve`, optimization becomes feasible for any system that `mesolve` can propagate over the entire time grid in less than a few seconds. That would be a huge improvement over the current situation, where the lack of a good propagator limits the optimization effectively to toy problems. We *may* still try to implement in Cython some polynomial propagators (propagators that evaluate `exp[-i H dt] Ψ` or `exp[L dt] ρ` via expansion into a polynomial series - think Taylor series but faster converging, through the use of Chebychev or Newton polynomials). That work hasn't really been going anywhere lately, though. It may or may not end up being faster than `mesolve`, but it's certainly less flexible. So even then, an mesolve that can do single steps would still be great. I would also think that being able to do time steps would be exceedingly useful to *any* gradient-based optimal control scheme. Wouldn't it greatly simplify your own GRAPE implementation? I'm referring to the ""Object model"" in [Optimal Quantum Control in QuTiP](https://qutip.org/docs/latest/guide/guide-control.html?highlight=grape#optimal-quantum-control-in-qutip), specifically the `TimeslotComputer` (in fact, we looked at whether `TimeslotComputer` could be used for krotov at the time, but couldn't quite figure it out). I elaborated a little bit in https://github.com/qucontrol/krotov/issues/93#issuecomment-859717563 on the requirements: beyond yielding the propagated states, we'll also have to modify the controls, i.e. the time-dependencies for QuTiP's nested-list format. Within the `krotov` package, these would always be numpy arrays. As an explanation, see [the figure",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1571#issuecomment-859754215
https://github.com/qutip/qutip/issues/1571#issuecomment-859754215:3243,Modifiability,adapt,adapt,3243,"s_method.html#time-discretization). The single-step-`mesolve` would be for the ""(2) forward-propagation with updated control"" in the bottom of the diagram: After each propagation time step, we calculate a new control value based on the current propagated state and other information (the ∂H/∂ϵ and stored backward-propagated states χ). The new control value is then used for the next time step. I'd also add that `mesolve` ideally should be ""thread-safe"" in the sense that we may have multiple `mesolve` run in parallel (index k in the diagram, where all the different k contribute to the update of the control values at the next time step), within whatever parallelization framework Python makes available. I vaguely remember looking at some Runge-Kutta implementations within scipy where this was a problem. I noted this in the docstring of krotov's [`DensityMatrixODEPropagator`](https://github.com/qucontrol/krotov/blob/master/src/krotov/propagators.py#L162), which was an attempt to adapt some of `mesolve`'s inner workings to Krotov's needs. It turned out the overhead was still too large for this work very well, cf. the large runtime of the [corresponding example](https://qucontrol.github.io/krotov/v1.2.1/notebooks/06_example_3states.html). To get very technical, Krotov's requirements are laid out in the documentation of the [`Propagator`](https://github.com/qucontrol/krotov/blob/master/src/krotov/propagators.py#L125) abstract base class, [`DensityMatrixODEPropagator`](https://github.com/qucontrol/krotov/blob/master/src/krotov/propagators.py#L162) being a particular example. In particular, the interface we define there is strictly for a single time step, makes no reference to `tlist` and we use ``H=[H0, [H1, u]]`` where `u` is a scalar for that particular timestep. However, I can easily write a wrapper around an `mesolve` that would work something along the lines of the pseudo-code from https://github.com/qucontrol/krotov/issues/93#issuecomment-859717563:. ~~~; for (i, state) ",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1571#issuecomment-859754215
https://github.com/qutip/qutip/issues/1571#issuecomment-859754215:433,Performance,optimiz,optimization,433,"Wow! Thanks for getting on this!. Let me elaborate a little. First,. > How useful would something like this be to you? Do you think you'd keep an implementation based on this long term? Or would you end up implementing your own thing in the end anyway?. It would be *extremely* useful. It would become the default propagator for the krotov package. I would expect that with the ability to propagate single time steps with `mesolve`, optimization becomes feasible for any system that `mesolve` can propagate over the entire time grid in less than a few seconds. That would be a huge improvement over the current situation, where the lack of a good propagator limits the optimization effectively to toy problems. We *may* still try to implement in Cython some polynomial propagators (propagators that evaluate `exp[-i H dt] Ψ` or `exp[L dt] ρ` via expansion into a polynomial series - think Taylor series but faster converging, through the use of Chebychev or Newton polynomials). That work hasn't really been going anywhere lately, though. It may or may not end up being faster than `mesolve`, but it's certainly less flexible. So even then, an mesolve that can do single steps would still be great. I would also think that being able to do time steps would be exceedingly useful to *any* gradient-based optimal control scheme. Wouldn't it greatly simplify your own GRAPE implementation? I'm referring to the ""Object model"" in [Optimal Quantum Control in QuTiP](https://qutip.org/docs/latest/guide/guide-control.html?highlight=grape#optimal-quantum-control-in-qutip), specifically the `TimeslotComputer` (in fact, we looked at whether `TimeslotComputer` could be used for krotov at the time, but couldn't quite figure it out). I elaborated a little bit in https://github.com/qucontrol/krotov/issues/93#issuecomment-859717563 on the requirements: beyond yielding the propagated states, we'll also have to modify the controls, i.e. the time-dependencies for QuTiP's nested-list format. Within the `krotov",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1571#issuecomment-859754215
https://github.com/qutip/qutip/issues/1571#issuecomment-859754215:669,Performance,optimiz,optimization,669,"Wow! Thanks for getting on this!. Let me elaborate a little. First,. > How useful would something like this be to you? Do you think you'd keep an implementation based on this long term? Or would you end up implementing your own thing in the end anyway?. It would be *extremely* useful. It would become the default propagator for the krotov package. I would expect that with the ability to propagate single time steps with `mesolve`, optimization becomes feasible for any system that `mesolve` can propagate over the entire time grid in less than a few seconds. That would be a huge improvement over the current situation, where the lack of a good propagator limits the optimization effectively to toy problems. We *may* still try to implement in Cython some polynomial propagators (propagators that evaluate `exp[-i H dt] Ψ` or `exp[L dt] ρ` via expansion into a polynomial series - think Taylor series but faster converging, through the use of Chebychev or Newton polynomials). That work hasn't really been going anywhere lately, though. It may or may not end up being faster than `mesolve`, but it's certainly less flexible. So even then, an mesolve that can do single steps would still be great. I would also think that being able to do time steps would be exceedingly useful to *any* gradient-based optimal control scheme. Wouldn't it greatly simplify your own GRAPE implementation? I'm referring to the ""Object model"" in [Optimal Quantum Control in QuTiP](https://qutip.org/docs/latest/guide/guide-control.html?highlight=grape#optimal-quantum-control-in-qutip), specifically the `TimeslotComputer` (in fact, we looked at whether `TimeslotComputer` could be used for krotov at the time, but couldn't quite figure it out). I elaborated a little bit in https://github.com/qucontrol/krotov/issues/93#issuecomment-859717563 on the requirements: beyond yielding the propagated states, we'll also have to modify the controls, i.e. the time-dependencies for QuTiP's nested-list format. Within the `krotov",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1571#issuecomment-859754215
https://github.com/qutip/qutip/issues/1571#issuecomment-859754215:5130,Performance,optimiz,optimization,5130,"https://github.com/qucontrol/krotov/blob/master/src/krotov/propagators.py#L125) abstract base class, [`DensityMatrixODEPropagator`](https://github.com/qucontrol/krotov/blob/master/src/krotov/propagators.py#L162) being a particular example. In particular, the interface we define there is strictly for a single time step, makes no reference to `tlist` and we use ``H=[H0, [H1, u]]`` where `u` is a scalar for that particular timestep. However, I can easily write a wrapper around an `mesolve` that would work something along the lines of the pseudo-code from https://github.com/qucontrol/krotov/issues/93#issuecomment-859717563:. ~~~; for (i, state) in enumerate(; mesolve([H0, [H1, ctrl_array]], state0, list); ):; # assuming `state` is at tlist[i]; new_val = calculate_control_value_for_next_step(state); ctrl_array[i] = new_val; ctrl_array[i+1] = new_val # ignoring IndexError; ~~~. So I don't think you'd have to worry about these details: any implementation with low overhead that would allow me to get the states from `mesolve` as well as tweak the control fields for the next time step should be sufficient. In particular, the `.step` that you discuss in https://github.com/qutip/qutip/issues/1571#issuecomment-858740451 looks very much like it's going in the right direction! The one option from the earlier https://github.com/qutip/qutip/issues/1571#issue-917391349 that might *not* work very well is callback functions. I *might* be able to work around that, but it wouldn't really fit into the control flow of an optimization. The code. ~~~; solver = MeSolver(H, c_ops, options=opt); solver.start(t0, rho0); for t in [t1,t2, ...]:; rho_t = solver.step(t, args=new_args); ~~~. from https://github.com/qutip/qutip/issues/1571#issuecomment-858740451 on the other hand would definitely fit the bill, assuming that `args=new_args` is the way to modify the control fields. Sorry for the long explanation, but I hope this clarifies the use case. If not, I'll be happy to try to explain better! ;-)",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1571#issuecomment-859754215
https://github.com/qutip/qutip/issues/1571#issuecomment-859754215:2704,Safety,safe,safe,2704,"ecomment-859717563 on the requirements: beyond yielding the propagated states, we'll also have to modify the controls, i.e. the time-dependencies for QuTiP's nested-list format. Within the `krotov` package, these would always be numpy arrays. As an explanation, see [the figure for Krotov's update scheme](https://qucontrol.github.io/krotov/v1.2.1/_images/krotovscheme.svg) from [the documentation](https://qucontrol.github.io/krotov/v1.2.1/07_krotovs_method.html#time-discretization). The single-step-`mesolve` would be for the ""(2) forward-propagation with updated control"" in the bottom of the diagram: After each propagation time step, we calculate a new control value based on the current propagated state and other information (the ∂H/∂ϵ and stored backward-propagated states χ). The new control value is then used for the next time step. I'd also add that `mesolve` ideally should be ""thread-safe"" in the sense that we may have multiple `mesolve` run in parallel (index k in the diagram, where all the different k contribute to the update of the control values at the next time step), within whatever parallelization framework Python makes available. I vaguely remember looking at some Runge-Kutta implementations within scipy where this was a problem. I noted this in the docstring of krotov's [`DensityMatrixODEPropagator`](https://github.com/qucontrol/krotov/blob/master/src/krotov/propagators.py#L162), which was an attempt to adapt some of `mesolve`'s inner workings to Krotov's needs. It turned out the overhead was still too large for this work very well, cf. the large runtime of the [corresponding example](https://qucontrol.github.io/krotov/v1.2.1/notebooks/06_example_3states.html). To get very technical, Krotov's requirements are laid out in the documentation of the [`Propagator`](https://github.com/qucontrol/krotov/blob/master/src/krotov/propagators.py#L125) abstract base class, [`DensityMatrixODEPropagator`](https://github.com/qucontrol/krotov/blob/master/src/krotov/propagat",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1571#issuecomment-859754215
https://github.com/qutip/qutip/issues/1571#issuecomment-859754215:1347,Usability,simpl,simplify,1347,"ingle time steps with `mesolve`, optimization becomes feasible for any system that `mesolve` can propagate over the entire time grid in less than a few seconds. That would be a huge improvement over the current situation, where the lack of a good propagator limits the optimization effectively to toy problems. We *may* still try to implement in Cython some polynomial propagators (propagators that evaluate `exp[-i H dt] Ψ` or `exp[L dt] ρ` via expansion into a polynomial series - think Taylor series but faster converging, through the use of Chebychev or Newton polynomials). That work hasn't really been going anywhere lately, though. It may or may not end up being faster than `mesolve`, but it's certainly less flexible. So even then, an mesolve that can do single steps would still be great. I would also think that being able to do time steps would be exceedingly useful to *any* gradient-based optimal control scheme. Wouldn't it greatly simplify your own GRAPE implementation? I'm referring to the ""Object model"" in [Optimal Quantum Control in QuTiP](https://qutip.org/docs/latest/guide/guide-control.html?highlight=grape#optimal-quantum-control-in-qutip), specifically the `TimeslotComputer` (in fact, we looked at whether `TimeslotComputer` could be used for krotov at the time, but couldn't quite figure it out). I elaborated a little bit in https://github.com/qucontrol/krotov/issues/93#issuecomment-859717563 on the requirements: beyond yielding the propagated states, we'll also have to modify the controls, i.e. the time-dependencies for QuTiP's nested-list format. Within the `krotov` package, these would always be numpy arrays. As an explanation, see [the figure for Krotov's update scheme](https://qucontrol.github.io/krotov/v1.2.1/_images/krotovscheme.svg) from [the documentation](https://qucontrol.github.io/krotov/v1.2.1/07_krotovs_method.html#time-discretization). The single-step-`mesolve` would be for the ""(2) forward-propagation with updated control"" in the bottom of the",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1571#issuecomment-859754215
https://github.com/qutip/qutip/issues/1571#issuecomment-859754215:1491,Usability,guid,guide,1491,"can propagate over the entire time grid in less than a few seconds. That would be a huge improvement over the current situation, where the lack of a good propagator limits the optimization effectively to toy problems. We *may* still try to implement in Cython some polynomial propagators (propagators that evaluate `exp[-i H dt] Ψ` or `exp[L dt] ρ` via expansion into a polynomial series - think Taylor series but faster converging, through the use of Chebychev or Newton polynomials). That work hasn't really been going anywhere lately, though. It may or may not end up being faster than `mesolve`, but it's certainly less flexible. So even then, an mesolve that can do single steps would still be great. I would also think that being able to do time steps would be exceedingly useful to *any* gradient-based optimal control scheme. Wouldn't it greatly simplify your own GRAPE implementation? I'm referring to the ""Object model"" in [Optimal Quantum Control in QuTiP](https://qutip.org/docs/latest/guide/guide-control.html?highlight=grape#optimal-quantum-control-in-qutip), specifically the `TimeslotComputer` (in fact, we looked at whether `TimeslotComputer` could be used for krotov at the time, but couldn't quite figure it out). I elaborated a little bit in https://github.com/qucontrol/krotov/issues/93#issuecomment-859717563 on the requirements: beyond yielding the propagated states, we'll also have to modify the controls, i.e. the time-dependencies for QuTiP's nested-list format. Within the `krotov` package, these would always be numpy arrays. As an explanation, see [the figure for Krotov's update scheme](https://qucontrol.github.io/krotov/v1.2.1/_images/krotovscheme.svg) from [the documentation](https://qucontrol.github.io/krotov/v1.2.1/07_krotovs_method.html#time-discretization). The single-step-`mesolve` would be for the ""(2) forward-propagation with updated control"" in the bottom of the diagram: After each propagation time step, we calculate a new control value based on the cu",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1571#issuecomment-859754215
https://github.com/qutip/qutip/issues/1571#issuecomment-859754215:1497,Usability,guid,guide-control,1497,"can propagate over the entire time grid in less than a few seconds. That would be a huge improvement over the current situation, where the lack of a good propagator limits the optimization effectively to toy problems. We *may* still try to implement in Cython some polynomial propagators (propagators that evaluate `exp[-i H dt] Ψ` or `exp[L dt] ρ` via expansion into a polynomial series - think Taylor series but faster converging, through the use of Chebychev or Newton polynomials). That work hasn't really been going anywhere lately, though. It may or may not end up being faster than `mesolve`, but it's certainly less flexible. So even then, an mesolve that can do single steps would still be great. I would also think that being able to do time steps would be exceedingly useful to *any* gradient-based optimal control scheme. Wouldn't it greatly simplify your own GRAPE implementation? I'm referring to the ""Object model"" in [Optimal Quantum Control in QuTiP](https://qutip.org/docs/latest/guide/guide-control.html?highlight=grape#optimal-quantum-control-in-qutip), specifically the `TimeslotComputer` (in fact, we looked at whether `TimeslotComputer` could be used for krotov at the time, but couldn't quite figure it out). I elaborated a little bit in https://github.com/qucontrol/krotov/issues/93#issuecomment-859717563 on the requirements: beyond yielding the propagated states, we'll also have to modify the controls, i.e. the time-dependencies for QuTiP's nested-list format. Within the `krotov` package, these would always be numpy arrays. As an explanation, see [the figure for Krotov's update scheme](https://qucontrol.github.io/krotov/v1.2.1/_images/krotovscheme.svg) from [the documentation](https://qucontrol.github.io/krotov/v1.2.1/07_krotovs_method.html#time-discretization). The single-step-`mesolve` would be for the ""(2) forward-propagation with updated control"" in the bottom of the diagram: After each propagation time step, we calculate a new control value based on the cu",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1571#issuecomment-859754215
https://github.com/qutip/qutip/issues/1571#issuecomment-859791561:496,Availability,error,error,496,"Most of scipy's solver are not ""thread-safe"", but we will be able to use other solvers in the new version. We will be sure to add at least one which is thread safe. The `args=new_args` refer to the `args` in `[H0, [H1, f(t, args)]]`, in your case, you could use something like:; ```; def f(t, args):; return args['u'] ; ```; We don't have step interpolation with changing coefficient array. It could be added, but we will have to think about it. Using a mutable, as in your example, would create error with most ODE solver with variable step, so I would not recommend it.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1571#issuecomment-859791561
https://github.com/qutip/qutip/issues/1571#issuecomment-859791561:528,Modifiability,variab,variable,528,"Most of scipy's solver are not ""thread-safe"", but we will be able to use other solvers in the new version. We will be sure to add at least one which is thread safe. The `args=new_args` refer to the `args` in `[H0, [H1, f(t, args)]]`, in your case, you could use something like:; ```; def f(t, args):; return args['u'] ; ```; We don't have step interpolation with changing coefficient array. It could be added, but we will have to think about it. Using a mutable, as in your example, would create error with most ODE solver with variable step, so I would not recommend it.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1571#issuecomment-859791561
https://github.com/qutip/qutip/issues/1571#issuecomment-859791561:39,Safety,safe,safe,39,"Most of scipy's solver are not ""thread-safe"", but we will be able to use other solvers in the new version. We will be sure to add at least one which is thread safe. The `args=new_args` refer to the `args` in `[H0, [H1, f(t, args)]]`, in your case, you could use something like:; ```; def f(t, args):; return args['u'] ; ```; We don't have step interpolation with changing coefficient array. It could be added, but we will have to think about it. Using a mutable, as in your example, would create error with most ODE solver with variable step, so I would not recommend it.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1571#issuecomment-859791561
https://github.com/qutip/qutip/issues/1571#issuecomment-859791561:159,Safety,safe,safe,159,"Most of scipy's solver are not ""thread-safe"", but we will be able to use other solvers in the new version. We will be sure to add at least one which is thread safe. The `args=new_args` refer to the `args` in `[H0, [H1, f(t, args)]]`, in your case, you could use something like:; ```; def f(t, args):; return args['u'] ; ```; We don't have step interpolation with changing coefficient array. It could be added, but we will have to think about it. Using a mutable, as in your example, would create error with most ODE solver with variable step, so I would not recommend it.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1571#issuecomment-859791561
https://github.com/qutip/qutip/issues/1571#issuecomment-859873615:436,Deployability,integrat,integrator,436,"I think you might be able to achieve a lot of what you want already. The pseudo-code looks like it's not using `mesolve` super efficiently, though maybe it's only because of simplifications to make a MWE. For example, if your controls are piecewise constant, then it might be inefficient to represent those terms as ""time dependent""; doing so means you incur the cost of multiplying each term by a scalar at every intermediate step the integrator chooses to take, then you have to perform the matrix-vector product for each one individually and add them up. It might be faster already if you evaluate the piecewise varying parts into one ""constant"" part at each point. This isn't guaranteed, because it involves copying rather more data _before_ the call (to construct the constant matrix once), but if the integrator would need to take many intermediate time steps, I expect it would win out. Would something like this work for you?; ```python; times = [0, ...]; # Liouvillians for parts you have control over; control_liouvillians = [qutip.liouvillian(h) for h in control_hamiltonians]; # The time-dependent Hamiltonian for stuff you're not controlling; base_hamiltonian = qutip.QobjEvo([H0, [H1, time_dependence], ...]); # Turn it into a Liouvillian once, so we don't repeat the cost; base = qutip.liouvillian(base_hamiltonian, collapse_operators); state = ...; options = qutip.Options(store_states=False, store_final_state=True); for prev, time in zip(times[:-1], times[1:]):; controls = krotov.get_next_controls(time, state, ...); current_liouvillian = base.copy(); for control, operator in zip(controls, control_liouvillians):; current_liouvillian += control * operator; # ^^^^^^^^^^^^^^^^^^; # each of these terms is a single time-independent Qobj,; # and the sum is a single QobjEvo with all the uncontrolled; # time dependence already handled.; state = qutip.mesolve(current_liouvillian, state, [prev, time], options=options).final_state; ```. By giving `mesolve` the Liouvillian instead of t",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1571#issuecomment-859873615
https://github.com/qutip/qutip/issues/1571#issuecomment-859873615:807,Deployability,integrat,integrator,807,"I think you might be able to achieve a lot of what you want already. The pseudo-code looks like it's not using `mesolve` super efficiently, though maybe it's only because of simplifications to make a MWE. For example, if your controls are piecewise constant, then it might be inefficient to represent those terms as ""time dependent""; doing so means you incur the cost of multiplying each term by a scalar at every intermediate step the integrator chooses to take, then you have to perform the matrix-vector product for each one individually and add them up. It might be faster already if you evaluate the piecewise varying parts into one ""constant"" part at each point. This isn't guaranteed, because it involves copying rather more data _before_ the call (to construct the constant matrix once), but if the integrator would need to take many intermediate time steps, I expect it would win out. Would something like this work for you?; ```python; times = [0, ...]; # Liouvillians for parts you have control over; control_liouvillians = [qutip.liouvillian(h) for h in control_hamiltonians]; # The time-dependent Hamiltonian for stuff you're not controlling; base_hamiltonian = qutip.QobjEvo([H0, [H1, time_dependence], ...]); # Turn it into a Liouvillian once, so we don't repeat the cost; base = qutip.liouvillian(base_hamiltonian, collapse_operators); state = ...; options = qutip.Options(store_states=False, store_final_state=True); for prev, time in zip(times[:-1], times[1:]):; controls = krotov.get_next_controls(time, state, ...); current_liouvillian = base.copy(); for control, operator in zip(controls, control_liouvillians):; current_liouvillian += control * operator; # ^^^^^^^^^^^^^^^^^^; # each of these terms is a single time-independent Qobj,; # and the sum is a single QobjEvo with all the uncontrolled; # time dependence already handled.; state = qutip.mesolve(current_liouvillian, state, [prev, time], options=options).final_state; ```. By giving `mesolve` the Liouvillian instead of t",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1571#issuecomment-859873615
https://github.com/qutip/qutip/issues/1571#issuecomment-859873615:4629,Deployability,integrat,integrator,4629," right now if that internally we'd keep column-stacking/unstacking the state, but in the 5.x branch it'll stop being represented internally by a sparse matrix, and instead it'll be a Fortran-ordered dense matrix, for which the stack/unstack is a free operation. In the form I've written it, this loop is thread-safe already. As it stands in the 4.x series, `mesolve` is re-entrant (I'm fairly sure), but note that it does generally mutate its arguments, especially if you pass a `QobjEvo` Liouvillian as the first argument. As long as you make sure you give each thread a distinct copy of the input Liouvillian, `mesolve` itself doesn't access global state as far as I recall. QuTiP 5 is (probably) going to formalise that (^) sort of low-level calling convention of `mesolve`, but it should work already. The new one look a bit different because instead of doing the setup very manually, there'll be a ""low-level"" function to prepare a master equation problem (and a Schrodinger equation one, etc), and then there'll be a `step` method instead of calling the ""high-level"" interface function `mesolve`, but functionally it'll do largely the same, just with a lot less data copying than the current form has to do. In the new system, it's likely that the function `mesolve` itself will keep the exact same interface it has now, just internally most of its processing will be split into modular components, each of which will be accessible (with different names) to the user to compose themselves, if they want low-level access. We're unlikely to add `yield` to `mesolve` directly because that's a very breaking change to one of QuTiP's core functions (we can't return from a generator, or at least not ergonomically), but we are splitting up the `mesolve` monolith into a much more modular architecture, and making it more user-accessible. The other advantage of this is that the integrator component will just be one element of a composable system, so we'll not be tied to scipy integrators any more.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1571#issuecomment-859873615
https://github.com/qutip/qutip/issues/1571#issuecomment-859873615:4729,Deployability,integrat,integrators,4729," right now if that internally we'd keep column-stacking/unstacking the state, but in the 5.x branch it'll stop being represented internally by a sparse matrix, and instead it'll be a Fortran-ordered dense matrix, for which the stack/unstack is a free operation. In the form I've written it, this loop is thread-safe already. As it stands in the 4.x series, `mesolve` is re-entrant (I'm fairly sure), but note that it does generally mutate its arguments, especially if you pass a `QobjEvo` Liouvillian as the first argument. As long as you make sure you give each thread a distinct copy of the input Liouvillian, `mesolve` itself doesn't access global state as far as I recall. QuTiP 5 is (probably) going to formalise that (^) sort of low-level calling convention of `mesolve`, but it should work already. The new one look a bit different because instead of doing the setup very manually, there'll be a ""low-level"" function to prepare a master equation problem (and a Schrodinger equation one, etc), and then there'll be a `step` method instead of calling the ""high-level"" interface function `mesolve`, but functionally it'll do largely the same, just with a lot less data copying than the current form has to do. In the new system, it's likely that the function `mesolve` itself will keep the exact same interface it has now, just internally most of its processing will be split into modular components, each of which will be accessible (with different names) to the user to compose themselves, if they want low-level access. We're unlikely to add `yield` to `mesolve` directly because that's a very breaking change to one of QuTiP's core functions (we can't return from a generator, or at least not ergonomically), but we are splitting up the `mesolve` monolith into a much more modular architecture, and making it more user-accessible. The other advantage of this is that the integrator component will just be one element of a composable system, so we'll not be tied to scipy integrators any more.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1571#issuecomment-859873615
https://github.com/qutip/qutip/issues/1571#issuecomment-859873615:127,Energy Efficiency,efficient,efficiently,127,"I think you might be able to achieve a lot of what you want already. The pseudo-code looks like it's not using `mesolve` super efficiently, though maybe it's only because of simplifications to make a MWE. For example, if your controls are piecewise constant, then it might be inefficient to represent those terms as ""time dependent""; doing so means you incur the cost of multiplying each term by a scalar at every intermediate step the integrator chooses to take, then you have to perform the matrix-vector product for each one individually and add them up. It might be faster already if you evaluate the piecewise varying parts into one ""constant"" part at each point. This isn't guaranteed, because it involves copying rather more data _before_ the call (to construct the constant matrix once), but if the integrator would need to take many intermediate time steps, I expect it would win out. Would something like this work for you?; ```python; times = [0, ...]; # Liouvillians for parts you have control over; control_liouvillians = [qutip.liouvillian(h) for h in control_hamiltonians]; # The time-dependent Hamiltonian for stuff you're not controlling; base_hamiltonian = qutip.QobjEvo([H0, [H1, time_dependence], ...]); # Turn it into a Liouvillian once, so we don't repeat the cost; base = qutip.liouvillian(base_hamiltonian, collapse_operators); state = ...; options = qutip.Options(store_states=False, store_final_state=True); for prev, time in zip(times[:-1], times[1:]):; controls = krotov.get_next_controls(time, state, ...); current_liouvillian = base.copy(); for control, operator in zip(controls, control_liouvillians):; current_liouvillian += control * operator; # ^^^^^^^^^^^^^^^^^^; # each of these terms is a single time-independent Qobj,; # and the sum is a single QobjEvo with all the uncontrolled; # time dependence already handled.; state = qutip.mesolve(current_liouvillian, state, [prev, time], options=options).final_state; ```. By giving `mesolve` the Liouvillian instead of t",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1571#issuecomment-859873615
https://github.com/qutip/qutip/issues/1571#issuecomment-859873615:322,Integrability,depend,dependent,322,"I think you might be able to achieve a lot of what you want already. The pseudo-code looks like it's not using `mesolve` super efficiently, though maybe it's only because of simplifications to make a MWE. For example, if your controls are piecewise constant, then it might be inefficient to represent those terms as ""time dependent""; doing so means you incur the cost of multiplying each term by a scalar at every intermediate step the integrator chooses to take, then you have to perform the matrix-vector product for each one individually and add them up. It might be faster already if you evaluate the piecewise varying parts into one ""constant"" part at each point. This isn't guaranteed, because it involves copying rather more data _before_ the call (to construct the constant matrix once), but if the integrator would need to take many intermediate time steps, I expect it would win out. Would something like this work for you?; ```python; times = [0, ...]; # Liouvillians for parts you have control over; control_liouvillians = [qutip.liouvillian(h) for h in control_hamiltonians]; # The time-dependent Hamiltonian for stuff you're not controlling; base_hamiltonian = qutip.QobjEvo([H0, [H1, time_dependence], ...]); # Turn it into a Liouvillian once, so we don't repeat the cost; base = qutip.liouvillian(base_hamiltonian, collapse_operators); state = ...; options = qutip.Options(store_states=False, store_final_state=True); for prev, time in zip(times[:-1], times[1:]):; controls = krotov.get_next_controls(time, state, ...); current_liouvillian = base.copy(); for control, operator in zip(controls, control_liouvillians):; current_liouvillian += control * operator; # ^^^^^^^^^^^^^^^^^^; # each of these terms is a single time-independent Qobj,; # and the sum is a single QobjEvo with all the uncontrolled; # time dependence already handled.; state = qutip.mesolve(current_liouvillian, state, [prev, time], options=options).final_state; ```. By giving `mesolve` the Liouvillian instead of t",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1571#issuecomment-859873615
https://github.com/qutip/qutip/issues/1571#issuecomment-859873615:436,Integrability,integrat,integrator,436,"I think you might be able to achieve a lot of what you want already. The pseudo-code looks like it's not using `mesolve` super efficiently, though maybe it's only because of simplifications to make a MWE. For example, if your controls are piecewise constant, then it might be inefficient to represent those terms as ""time dependent""; doing so means you incur the cost of multiplying each term by a scalar at every intermediate step the integrator chooses to take, then you have to perform the matrix-vector product for each one individually and add them up. It might be faster already if you evaluate the piecewise varying parts into one ""constant"" part at each point. This isn't guaranteed, because it involves copying rather more data _before_ the call (to construct the constant matrix once), but if the integrator would need to take many intermediate time steps, I expect it would win out. Would something like this work for you?; ```python; times = [0, ...]; # Liouvillians for parts you have control over; control_liouvillians = [qutip.liouvillian(h) for h in control_hamiltonians]; # The time-dependent Hamiltonian for stuff you're not controlling; base_hamiltonian = qutip.QobjEvo([H0, [H1, time_dependence], ...]); # Turn it into a Liouvillian once, so we don't repeat the cost; base = qutip.liouvillian(base_hamiltonian, collapse_operators); state = ...; options = qutip.Options(store_states=False, store_final_state=True); for prev, time in zip(times[:-1], times[1:]):; controls = krotov.get_next_controls(time, state, ...); current_liouvillian = base.copy(); for control, operator in zip(controls, control_liouvillians):; current_liouvillian += control * operator; # ^^^^^^^^^^^^^^^^^^; # each of these terms is a single time-independent Qobj,; # and the sum is a single QobjEvo with all the uncontrolled; # time dependence already handled.; state = qutip.mesolve(current_liouvillian, state, [prev, time], options=options).final_state; ```. By giving `mesolve` the Liouvillian instead of t",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1571#issuecomment-859873615
https://github.com/qutip/qutip/issues/1571#issuecomment-859873615:807,Integrability,integrat,integrator,807,"I think you might be able to achieve a lot of what you want already. The pseudo-code looks like it's not using `mesolve` super efficiently, though maybe it's only because of simplifications to make a MWE. For example, if your controls are piecewise constant, then it might be inefficient to represent those terms as ""time dependent""; doing so means you incur the cost of multiplying each term by a scalar at every intermediate step the integrator chooses to take, then you have to perform the matrix-vector product for each one individually and add them up. It might be faster already if you evaluate the piecewise varying parts into one ""constant"" part at each point. This isn't guaranteed, because it involves copying rather more data _before_ the call (to construct the constant matrix once), but if the integrator would need to take many intermediate time steps, I expect it would win out. Would something like this work for you?; ```python; times = [0, ...]; # Liouvillians for parts you have control over; control_liouvillians = [qutip.liouvillian(h) for h in control_hamiltonians]; # The time-dependent Hamiltonian for stuff you're not controlling; base_hamiltonian = qutip.QobjEvo([H0, [H1, time_dependence], ...]); # Turn it into a Liouvillian once, so we don't repeat the cost; base = qutip.liouvillian(base_hamiltonian, collapse_operators); state = ...; options = qutip.Options(store_states=False, store_final_state=True); for prev, time in zip(times[:-1], times[1:]):; controls = krotov.get_next_controls(time, state, ...); current_liouvillian = base.copy(); for control, operator in zip(controls, control_liouvillians):; current_liouvillian += control * operator; # ^^^^^^^^^^^^^^^^^^; # each of these terms is a single time-independent Qobj,; # and the sum is a single QobjEvo with all the uncontrolled; # time dependence already handled.; state = qutip.mesolve(current_liouvillian, state, [prev, time], options=options).final_state; ```. By giving `mesolve` the Liouvillian instead of t",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1571#issuecomment-859873615
https://github.com/qutip/qutip/issues/1571#issuecomment-859873615:1100,Integrability,depend,dependent,1100,"`mesolve` super efficiently, though maybe it's only because of simplifications to make a MWE. For example, if your controls are piecewise constant, then it might be inefficient to represent those terms as ""time dependent""; doing so means you incur the cost of multiplying each term by a scalar at every intermediate step the integrator chooses to take, then you have to perform the matrix-vector product for each one individually and add them up. It might be faster already if you evaluate the piecewise varying parts into one ""constant"" part at each point. This isn't guaranteed, because it involves copying rather more data _before_ the call (to construct the constant matrix once), but if the integrator would need to take many intermediate time steps, I expect it would win out. Would something like this work for you?; ```python; times = [0, ...]; # Liouvillians for parts you have control over; control_liouvillians = [qutip.liouvillian(h) for h in control_hamiltonians]; # The time-dependent Hamiltonian for stuff you're not controlling; base_hamiltonian = qutip.QobjEvo([H0, [H1, time_dependence], ...]); # Turn it into a Liouvillian once, so we don't repeat the cost; base = qutip.liouvillian(base_hamiltonian, collapse_operators); state = ...; options = qutip.Options(store_states=False, store_final_state=True); for prev, time in zip(times[:-1], times[1:]):; controls = krotov.get_next_controls(time, state, ...); current_liouvillian = base.copy(); for control, operator in zip(controls, control_liouvillians):; current_liouvillian += control * operator; # ^^^^^^^^^^^^^^^^^^; # each of these terms is a single time-independent Qobj,; # and the sum is a single QobjEvo with all the uncontrolled; # time dependence already handled.; state = qutip.mesolve(current_liouvillian, state, [prev, time], options=options).final_state; ```. By giving `mesolve` the Liouvillian instead of the Hamiltonian and collapse operators separately, you've already done most of its setup, so the time penalties ",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1571#issuecomment-859873615
https://github.com/qutip/qutip/issues/1571#issuecomment-859873615:1825,Integrability,depend,dependence,1825,"lves copying rather more data _before_ the call (to construct the constant matrix once), but if the integrator would need to take many intermediate time steps, I expect it would win out. Would something like this work for you?; ```python; times = [0, ...]; # Liouvillians for parts you have control over; control_liouvillians = [qutip.liouvillian(h) for h in control_hamiltonians]; # The time-dependent Hamiltonian for stuff you're not controlling; base_hamiltonian = qutip.QobjEvo([H0, [H1, time_dependence], ...]); # Turn it into a Liouvillian once, so we don't repeat the cost; base = qutip.liouvillian(base_hamiltonian, collapse_operators); state = ...; options = qutip.Options(store_states=False, store_final_state=True); for prev, time in zip(times[:-1], times[1:]):; controls = krotov.get_next_controls(time, state, ...); current_liouvillian = base.copy(); for control, operator in zip(controls, control_liouvillians):; current_liouvillian += control * operator; # ^^^^^^^^^^^^^^^^^^; # each of these terms is a single time-independent Qobj,; # and the sum is a single QobjEvo with all the uncontrolled; # time dependence already handled.; state = qutip.mesolve(current_liouvillian, state, [prev, time], options=options).final_state; ```. By giving `mesolve` the Liouvillian instead of the Hamiltonian and collapse operators separately, you've already done most of its setup, so the time penalties should be much less than the current system (i.e. you avoid several Kronecker products and safety checks on the time-dependence terms because you've done them once at the start). In theory, that should already work from at least 4.5 onwards, and likely most of it will work from 4.4. In the 5.x series, almost all the intermediary operations should get a speed up as well (`Qobj.__init__` is getting its time slashed, and the line `current_liouvillian += control * operator` may be able to be replaced with one that applies the same in-place calculation optimisations that `mesolve` does internal",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1571#issuecomment-859873615
https://github.com/qutip/qutip/issues/1571#issuecomment-859873615:2229,Integrability,depend,dependence,2229," Turn it into a Liouvillian once, so we don't repeat the cost; base = qutip.liouvillian(base_hamiltonian, collapse_operators); state = ...; options = qutip.Options(store_states=False, store_final_state=True); for prev, time in zip(times[:-1], times[1:]):; controls = krotov.get_next_controls(time, state, ...); current_liouvillian = base.copy(); for control, operator in zip(controls, control_liouvillians):; current_liouvillian += control * operator; # ^^^^^^^^^^^^^^^^^^; # each of these terms is a single time-independent Qobj,; # and the sum is a single QobjEvo with all the uncontrolled; # time dependence already handled.; state = qutip.mesolve(current_liouvillian, state, [prev, time], options=options).final_state; ```. By giving `mesolve` the Liouvillian instead of the Hamiltonian and collapse operators separately, you've already done most of its setup, so the time penalties should be much less than the current system (i.e. you avoid several Kronecker products and safety checks on the time-dependence terms because you've done them once at the start). In theory, that should already work from at least 4.5 onwards, and likely most of it will work from 4.4. In the 5.x series, almost all the intermediary operations should get a speed up as well (`Qobj.__init__` is getting its time slashed, and the line `current_liouvillian += control * operator` may be able to be replaced with one that applies the same in-place calculation optimisations that `mesolve` does internally). One thing you pay a nasty penalty for right now if that internally we'd keep column-stacking/unstacking the state, but in the 5.x branch it'll stop being represented internally by a sparse matrix, and instead it'll be a Fortran-ordered dense matrix, for which the stack/unstack is a free operation. In the form I've written it, this loop is thread-safe already. As it stands in the 4.x series, `mesolve` is re-entrant (I'm fairly sure), but note that it does generally mutate its arguments, especially if you pass",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1571#issuecomment-859873615
https://github.com/qutip/qutip/issues/1571#issuecomment-859873615:3823,Integrability,interface,interface,3823," right now if that internally we'd keep column-stacking/unstacking the state, but in the 5.x branch it'll stop being represented internally by a sparse matrix, and instead it'll be a Fortran-ordered dense matrix, for which the stack/unstack is a free operation. In the form I've written it, this loop is thread-safe already. As it stands in the 4.x series, `mesolve` is re-entrant (I'm fairly sure), but note that it does generally mutate its arguments, especially if you pass a `QobjEvo` Liouvillian as the first argument. As long as you make sure you give each thread a distinct copy of the input Liouvillian, `mesolve` itself doesn't access global state as far as I recall. QuTiP 5 is (probably) going to formalise that (^) sort of low-level calling convention of `mesolve`, but it should work already. The new one look a bit different because instead of doing the setup very manually, there'll be a ""low-level"" function to prepare a master equation problem (and a Schrodinger equation one, etc), and then there'll be a `step` method instead of calling the ""high-level"" interface function `mesolve`, but functionally it'll do largely the same, just with a lot less data copying than the current form has to do. In the new system, it's likely that the function `mesolve` itself will keep the exact same interface it has now, just internally most of its processing will be split into modular components, each of which will be accessible (with different names) to the user to compose themselves, if they want low-level access. We're unlikely to add `yield` to `mesolve` directly because that's a very breaking change to one of QuTiP's core functions (we can't return from a generator, or at least not ergonomically), but we are splitting up the `mesolve` monolith into a much more modular architecture, and making it more user-accessible. The other advantage of this is that the integrator component will just be one element of a composable system, so we'll not be tied to scipy integrators any more.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1571#issuecomment-859873615
https://github.com/qutip/qutip/issues/1571#issuecomment-859873615:4055,Integrability,interface,interface,4055," right now if that internally we'd keep column-stacking/unstacking the state, but in the 5.x branch it'll stop being represented internally by a sparse matrix, and instead it'll be a Fortran-ordered dense matrix, for which the stack/unstack is a free operation. In the form I've written it, this loop is thread-safe already. As it stands in the 4.x series, `mesolve` is re-entrant (I'm fairly sure), but note that it does generally mutate its arguments, especially if you pass a `QobjEvo` Liouvillian as the first argument. As long as you make sure you give each thread a distinct copy of the input Liouvillian, `mesolve` itself doesn't access global state as far as I recall. QuTiP 5 is (probably) going to formalise that (^) sort of low-level calling convention of `mesolve`, but it should work already. The new one look a bit different because instead of doing the setup very manually, there'll be a ""low-level"" function to prepare a master equation problem (and a Schrodinger equation one, etc), and then there'll be a `step` method instead of calling the ""high-level"" interface function `mesolve`, but functionally it'll do largely the same, just with a lot less data copying than the current form has to do. In the new system, it's likely that the function `mesolve` itself will keep the exact same interface it has now, just internally most of its processing will be split into modular components, each of which will be accessible (with different names) to the user to compose themselves, if they want low-level access. We're unlikely to add `yield` to `mesolve` directly because that's a very breaking change to one of QuTiP's core functions (we can't return from a generator, or at least not ergonomically), but we are splitting up the `mesolve` monolith into a much more modular architecture, and making it more user-accessible. The other advantage of this is that the integrator component will just be one element of a composable system, so we'll not be tied to scipy integrators any more.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1571#issuecomment-859873615
https://github.com/qutip/qutip/issues/1571#issuecomment-859873615:4629,Integrability,integrat,integrator,4629," right now if that internally we'd keep column-stacking/unstacking the state, but in the 5.x branch it'll stop being represented internally by a sparse matrix, and instead it'll be a Fortran-ordered dense matrix, for which the stack/unstack is a free operation. In the form I've written it, this loop is thread-safe already. As it stands in the 4.x series, `mesolve` is re-entrant (I'm fairly sure), but note that it does generally mutate its arguments, especially if you pass a `QobjEvo` Liouvillian as the first argument. As long as you make sure you give each thread a distinct copy of the input Liouvillian, `mesolve` itself doesn't access global state as far as I recall. QuTiP 5 is (probably) going to formalise that (^) sort of low-level calling convention of `mesolve`, but it should work already. The new one look a bit different because instead of doing the setup very manually, there'll be a ""low-level"" function to prepare a master equation problem (and a Schrodinger equation one, etc), and then there'll be a `step` method instead of calling the ""high-level"" interface function `mesolve`, but functionally it'll do largely the same, just with a lot less data copying than the current form has to do. In the new system, it's likely that the function `mesolve` itself will keep the exact same interface it has now, just internally most of its processing will be split into modular components, each of which will be accessible (with different names) to the user to compose themselves, if they want low-level access. We're unlikely to add `yield` to `mesolve` directly because that's a very breaking change to one of QuTiP's core functions (we can't return from a generator, or at least not ergonomically), but we are splitting up the `mesolve` monolith into a much more modular architecture, and making it more user-accessible. The other advantage of this is that the integrator component will just be one element of a composable system, so we'll not be tied to scipy integrators any more.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1571#issuecomment-859873615
https://github.com/qutip/qutip/issues/1571#issuecomment-859873615:4729,Integrability,integrat,integrators,4729," right now if that internally we'd keep column-stacking/unstacking the state, but in the 5.x branch it'll stop being represented internally by a sparse matrix, and instead it'll be a Fortran-ordered dense matrix, for which the stack/unstack is a free operation. In the form I've written it, this loop is thread-safe already. As it stands in the 4.x series, `mesolve` is re-entrant (I'm fairly sure), but note that it does generally mutate its arguments, especially if you pass a `QobjEvo` Liouvillian as the first argument. As long as you make sure you give each thread a distinct copy of the input Liouvillian, `mesolve` itself doesn't access global state as far as I recall. QuTiP 5 is (probably) going to formalise that (^) sort of low-level calling convention of `mesolve`, but it should work already. The new one look a bit different because instead of doing the setup very manually, there'll be a ""low-level"" function to prepare a master equation problem (and a Schrodinger equation one, etc), and then there'll be a `step` method instead of calling the ""high-level"" interface function `mesolve`, but functionally it'll do largely the same, just with a lot less data copying than the current form has to do. In the new system, it's likely that the function `mesolve` itself will keep the exact same interface it has now, just internally most of its processing will be split into modular components, each of which will be accessible (with different names) to the user to compose themselves, if they want low-level access. We're unlikely to add `yield` to `mesolve` directly because that's a very breaking change to one of QuTiP's core functions (we can't return from a generator, or at least not ergonomically), but we are splitting up the `mesolve` monolith into a much more modular architecture, and making it more user-accessible. The other advantage of this is that the integrator component will just be one element of a composable system, so we'll not be tied to scipy integrators any more.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1571#issuecomment-859873615
https://github.com/qutip/qutip/issues/1571#issuecomment-859873615:481,Performance,perform,perform,481,"I think you might be able to achieve a lot of what you want already. The pseudo-code looks like it's not using `mesolve` super efficiently, though maybe it's only because of simplifications to make a MWE. For example, if your controls are piecewise constant, then it might be inefficient to represent those terms as ""time dependent""; doing so means you incur the cost of multiplying each term by a scalar at every intermediate step the integrator chooses to take, then you have to perform the matrix-vector product for each one individually and add them up. It might be faster already if you evaluate the piecewise varying parts into one ""constant"" part at each point. This isn't guaranteed, because it involves copying rather more data _before_ the call (to construct the constant matrix once), but if the integrator would need to take many intermediate time steps, I expect it would win out. Would something like this work for you?; ```python; times = [0, ...]; # Liouvillians for parts you have control over; control_liouvillians = [qutip.liouvillian(h) for h in control_hamiltonians]; # The time-dependent Hamiltonian for stuff you're not controlling; base_hamiltonian = qutip.QobjEvo([H0, [H1, time_dependence], ...]); # Turn it into a Liouvillian once, so we don't repeat the cost; base = qutip.liouvillian(base_hamiltonian, collapse_operators); state = ...; options = qutip.Options(store_states=False, store_final_state=True); for prev, time in zip(times[:-1], times[1:]):; controls = krotov.get_next_controls(time, state, ...); current_liouvillian = base.copy(); for control, operator in zip(controls, control_liouvillians):; current_liouvillian += control * operator; # ^^^^^^^^^^^^^^^^^^; # each of these terms is a single time-independent Qobj,; # and the sum is a single QobjEvo with all the uncontrolled; # time dependence already handled.; state = qutip.mesolve(current_liouvillian, state, [prev, time], options=options).final_state; ```. By giving `mesolve` the Liouvillian instead of t",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1571#issuecomment-859873615
https://github.com/qutip/qutip/issues/1571#issuecomment-859873615:2166,Safety,avoid,avoid,2166," Turn it into a Liouvillian once, so we don't repeat the cost; base = qutip.liouvillian(base_hamiltonian, collapse_operators); state = ...; options = qutip.Options(store_states=False, store_final_state=True); for prev, time in zip(times[:-1], times[1:]):; controls = krotov.get_next_controls(time, state, ...); current_liouvillian = base.copy(); for control, operator in zip(controls, control_liouvillians):; current_liouvillian += control * operator; # ^^^^^^^^^^^^^^^^^^; # each of these terms is a single time-independent Qobj,; # and the sum is a single QobjEvo with all the uncontrolled; # time dependence already handled.; state = qutip.mesolve(current_liouvillian, state, [prev, time], options=options).final_state; ```. By giving `mesolve` the Liouvillian instead of the Hamiltonian and collapse operators separately, you've already done most of its setup, so the time penalties should be much less than the current system (i.e. you avoid several Kronecker products and safety checks on the time-dependence terms because you've done them once at the start). In theory, that should already work from at least 4.5 onwards, and likely most of it will work from 4.4. In the 5.x series, almost all the intermediary operations should get a speed up as well (`Qobj.__init__` is getting its time slashed, and the line `current_liouvillian += control * operator` may be able to be replaced with one that applies the same in-place calculation optimisations that `mesolve` does internally). One thing you pay a nasty penalty for right now if that internally we'd keep column-stacking/unstacking the state, but in the 5.x branch it'll stop being represented internally by a sparse matrix, and instead it'll be a Fortran-ordered dense matrix, for which the stack/unstack is a free operation. In the form I've written it, this loop is thread-safe already. As it stands in the 4.x series, `mesolve` is re-entrant (I'm fairly sure), but note that it does generally mutate its arguments, especially if you pass",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1571#issuecomment-859873615
https://github.com/qutip/qutip/issues/1571#issuecomment-859873615:2203,Safety,safe,safety,2203," Turn it into a Liouvillian once, so we don't repeat the cost; base = qutip.liouvillian(base_hamiltonian, collapse_operators); state = ...; options = qutip.Options(store_states=False, store_final_state=True); for prev, time in zip(times[:-1], times[1:]):; controls = krotov.get_next_controls(time, state, ...); current_liouvillian = base.copy(); for control, operator in zip(controls, control_liouvillians):; current_liouvillian += control * operator; # ^^^^^^^^^^^^^^^^^^; # each of these terms is a single time-independent Qobj,; # and the sum is a single QobjEvo with all the uncontrolled; # time dependence already handled.; state = qutip.mesolve(current_liouvillian, state, [prev, time], options=options).final_state; ```. By giving `mesolve` the Liouvillian instead of the Hamiltonian and collapse operators separately, you've already done most of its setup, so the time penalties should be much less than the current system (i.e. you avoid several Kronecker products and safety checks on the time-dependence terms because you've done them once at the start). In theory, that should already work from at least 4.5 onwards, and likely most of it will work from 4.4. In the 5.x series, almost all the intermediary operations should get a speed up as well (`Qobj.__init__` is getting its time slashed, and the line `current_liouvillian += control * operator` may be able to be replaced with one that applies the same in-place calculation optimisations that `mesolve` does internally). One thing you pay a nasty penalty for right now if that internally we'd keep column-stacking/unstacking the state, but in the 5.x branch it'll stop being represented internally by a sparse matrix, and instead it'll be a Fortran-ordered dense matrix, for which the stack/unstack is a free operation. In the form I've written it, this loop is thread-safe already. As it stands in the 4.x series, `mesolve` is re-entrant (I'm fairly sure), but note that it does generally mutate its arguments, especially if you pass",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1571#issuecomment-859873615
https://github.com/qutip/qutip/issues/1571#issuecomment-859873615:3061,Safety,safe,safe,3061,"arately, you've already done most of its setup, so the time penalties should be much less than the current system (i.e. you avoid several Kronecker products and safety checks on the time-dependence terms because you've done them once at the start). In theory, that should already work from at least 4.5 onwards, and likely most of it will work from 4.4. In the 5.x series, almost all the intermediary operations should get a speed up as well (`Qobj.__init__` is getting its time slashed, and the line `current_liouvillian += control * operator` may be able to be replaced with one that applies the same in-place calculation optimisations that `mesolve` does internally). One thing you pay a nasty penalty for right now if that internally we'd keep column-stacking/unstacking the state, but in the 5.x branch it'll stop being represented internally by a sparse matrix, and instead it'll be a Fortran-ordered dense matrix, for which the stack/unstack is a free operation. In the form I've written it, this loop is thread-safe already. As it stands in the 4.x series, `mesolve` is re-entrant (I'm fairly sure), but note that it does generally mutate its arguments, especially if you pass a `QobjEvo` Liouvillian as the first argument. As long as you make sure you give each thread a distinct copy of the input Liouvillian, `mesolve` itself doesn't access global state as far as I recall. QuTiP 5 is (probably) going to formalise that (^) sort of low-level calling convention of `mesolve`, but it should work already. The new one look a bit different because instead of doing the setup very manually, there'll be a ""low-level"" function to prepare a master equation problem (and a Schrodinger equation one, etc), and then there'll be a `step` method instead of calling the ""high-level"" interface function `mesolve`, but functionally it'll do largely the same, just with a lot less data copying than the current form has to do. In the new system, it's likely that the function `mesolve` itself will keep the",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1571#issuecomment-859873615
https://github.com/qutip/qutip/issues/1571#issuecomment-859873615:3387,Security,access,access,3387,"rds, and likely most of it will work from 4.4. In the 5.x series, almost all the intermediary operations should get a speed up as well (`Qobj.__init__` is getting its time slashed, and the line `current_liouvillian += control * operator` may be able to be replaced with one that applies the same in-place calculation optimisations that `mesolve` does internally). One thing you pay a nasty penalty for right now if that internally we'd keep column-stacking/unstacking the state, but in the 5.x branch it'll stop being represented internally by a sparse matrix, and instead it'll be a Fortran-ordered dense matrix, for which the stack/unstack is a free operation. In the form I've written it, this loop is thread-safe already. As it stands in the 4.x series, `mesolve` is re-entrant (I'm fairly sure), but note that it does generally mutate its arguments, especially if you pass a `QobjEvo` Liouvillian as the first argument. As long as you make sure you give each thread a distinct copy of the input Liouvillian, `mesolve` itself doesn't access global state as far as I recall. QuTiP 5 is (probably) going to formalise that (^) sort of low-level calling convention of `mesolve`, but it should work already. The new one look a bit different because instead of doing the setup very manually, there'll be a ""low-level"" function to prepare a master equation problem (and a Schrodinger equation one, etc), and then there'll be a `step` method instead of calling the ""high-level"" interface function `mesolve`, but functionally it'll do largely the same, just with a lot less data copying than the current form has to do. In the new system, it's likely that the function `mesolve` itself will keep the exact same interface it has now, just internally most of its processing will be split into modular components, each of which will be accessible (with different names) to the user to compose themselves, if they want low-level access. We're unlikely to add `yield` to `mesolve` directly because that's a very",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1571#issuecomment-859873615
https://github.com/qutip/qutip/issues/1571#issuecomment-859873615:4177,Security,access,accessible,4177," right now if that internally we'd keep column-stacking/unstacking the state, but in the 5.x branch it'll stop being represented internally by a sparse matrix, and instead it'll be a Fortran-ordered dense matrix, for which the stack/unstack is a free operation. In the form I've written it, this loop is thread-safe already. As it stands in the 4.x series, `mesolve` is re-entrant (I'm fairly sure), but note that it does generally mutate its arguments, especially if you pass a `QobjEvo` Liouvillian as the first argument. As long as you make sure you give each thread a distinct copy of the input Liouvillian, `mesolve` itself doesn't access global state as far as I recall. QuTiP 5 is (probably) going to formalise that (^) sort of low-level calling convention of `mesolve`, but it should work already. The new one look a bit different because instead of doing the setup very manually, there'll be a ""low-level"" function to prepare a master equation problem (and a Schrodinger equation one, etc), and then there'll be a `step` method instead of calling the ""high-level"" interface function `mesolve`, but functionally it'll do largely the same, just with a lot less data copying than the current form has to do. In the new system, it's likely that the function `mesolve` itself will keep the exact same interface it has now, just internally most of its processing will be split into modular components, each of which will be accessible (with different names) to the user to compose themselves, if they want low-level access. We're unlikely to add `yield` to `mesolve` directly because that's a very breaking change to one of QuTiP's core functions (we can't return from a generator, or at least not ergonomically), but we are splitting up the `mesolve` monolith into a much more modular architecture, and making it more user-accessible. The other advantage of this is that the integrator component will just be one element of a composable system, so we'll not be tied to scipy integrators any more.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1571#issuecomment-859873615
https://github.com/qutip/qutip/issues/1571#issuecomment-859873615:4269,Security,access,access,4269," right now if that internally we'd keep column-stacking/unstacking the state, but in the 5.x branch it'll stop being represented internally by a sparse matrix, and instead it'll be a Fortran-ordered dense matrix, for which the stack/unstack is a free operation. In the form I've written it, this loop is thread-safe already. As it stands in the 4.x series, `mesolve` is re-entrant (I'm fairly sure), but note that it does generally mutate its arguments, especially if you pass a `QobjEvo` Liouvillian as the first argument. As long as you make sure you give each thread a distinct copy of the input Liouvillian, `mesolve` itself doesn't access global state as far as I recall. QuTiP 5 is (probably) going to formalise that (^) sort of low-level calling convention of `mesolve`, but it should work already. The new one look a bit different because instead of doing the setup very manually, there'll be a ""low-level"" function to prepare a master equation problem (and a Schrodinger equation one, etc), and then there'll be a `step` method instead of calling the ""high-level"" interface function `mesolve`, but functionally it'll do largely the same, just with a lot less data copying than the current form has to do. In the new system, it's likely that the function `mesolve` itself will keep the exact same interface it has now, just internally most of its processing will be split into modular components, each of which will be accessible (with different names) to the user to compose themselves, if they want low-level access. We're unlikely to add `yield` to `mesolve` directly because that's a very breaking change to one of QuTiP's core functions (we can't return from a generator, or at least not ergonomically), but we are splitting up the `mesolve` monolith into a much more modular architecture, and making it more user-accessible. The other advantage of this is that the integrator component will just be one element of a composable system, so we'll not be tied to scipy integrators any more.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1571#issuecomment-859873615
https://github.com/qutip/qutip/issues/1571#issuecomment-859873615:4577,Security,access,accessible,4577," right now if that internally we'd keep column-stacking/unstacking the state, but in the 5.x branch it'll stop being represented internally by a sparse matrix, and instead it'll be a Fortran-ordered dense matrix, for which the stack/unstack is a free operation. In the form I've written it, this loop is thread-safe already. As it stands in the 4.x series, `mesolve` is re-entrant (I'm fairly sure), but note that it does generally mutate its arguments, especially if you pass a `QobjEvo` Liouvillian as the first argument. As long as you make sure you give each thread a distinct copy of the input Liouvillian, `mesolve` itself doesn't access global state as far as I recall. QuTiP 5 is (probably) going to formalise that (^) sort of low-level calling convention of `mesolve`, but it should work already. The new one look a bit different because instead of doing the setup very manually, there'll be a ""low-level"" function to prepare a master equation problem (and a Schrodinger equation one, etc), and then there'll be a `step` method instead of calling the ""high-level"" interface function `mesolve`, but functionally it'll do largely the same, just with a lot less data copying than the current form has to do. In the new system, it's likely that the function `mesolve` itself will keep the exact same interface it has now, just internally most of its processing will be split into modular components, each of which will be accessible (with different names) to the user to compose themselves, if they want low-level access. We're unlikely to add `yield` to `mesolve` directly because that's a very breaking change to one of QuTiP's core functions (we can't return from a generator, or at least not ergonomically), but we are splitting up the `mesolve` monolith into a much more modular architecture, and making it more user-accessible. The other advantage of this is that the integrator component will just be one element of a composable system, so we'll not be tied to scipy integrators any more.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1571#issuecomment-859873615
https://github.com/qutip/qutip/issues/1571#issuecomment-859873615:174,Usability,simpl,simplifications,174,"I think you might be able to achieve a lot of what you want already. The pseudo-code looks like it's not using `mesolve` super efficiently, though maybe it's only because of simplifications to make a MWE. For example, if your controls are piecewise constant, then it might be inefficient to represent those terms as ""time dependent""; doing so means you incur the cost of multiplying each term by a scalar at every intermediate step the integrator chooses to take, then you have to perform the matrix-vector product for each one individually and add them up. It might be faster already if you evaluate the piecewise varying parts into one ""constant"" part at each point. This isn't guaranteed, because it involves copying rather more data _before_ the call (to construct the constant matrix once), but if the integrator would need to take many intermediate time steps, I expect it would win out. Would something like this work for you?; ```python; times = [0, ...]; # Liouvillians for parts you have control over; control_liouvillians = [qutip.liouvillian(h) for h in control_hamiltonians]; # The time-dependent Hamiltonian for stuff you're not controlling; base_hamiltonian = qutip.QobjEvo([H0, [H1, time_dependence], ...]); # Turn it into a Liouvillian once, so we don't repeat the cost; base = qutip.liouvillian(base_hamiltonian, collapse_operators); state = ...; options = qutip.Options(store_states=False, store_final_state=True); for prev, time in zip(times[:-1], times[1:]):; controls = krotov.get_next_controls(time, state, ...); current_liouvillian = base.copy(); for control, operator in zip(controls, control_liouvillians):; current_liouvillian += control * operator; # ^^^^^^^^^^^^^^^^^^; # each of these terms is a single time-independent Qobj,; # and the sum is a single QobjEvo with all the uncontrolled; # time dependence already handled.; state = qutip.mesolve(current_liouvillian, state, [prev, time], options=options).final_state; ```. By giving `mesolve` the Liouvillian instead of t",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1571#issuecomment-859873615
https://github.com/qutip/qutip/issues/1571#issuecomment-859907481:1436,Deployability,integrat,integrator,1436,"ve to completely define an interchange API, and specify quite explicitly what ""commands"" you can tell this sort of `mesolve` state machine to execute. The pattern in your original comment (reproduced here); ```python; for (i, state) in enumerate(; mesolve([H0, [H1, ctrl_array]], state0, list); ):; # assuming `state` is at tlist[i]; new_val = calculate_control_value_for_next_step(state); ctrl_array[i] = new_val; ctrl_array[i+1] = new_val # ignoring IndexError; ```; is probably a little fragile; doing this means we have to guarantee that at _no point_ is the `ctrl_array` object copied. If you wanted to branch off execution part-way through the iterator, you'd have to copy the whole state, and then you'd lose your reference to the control array unless you kept manually walking the structure of the time-dependent object (internally it gets converted into a `QobjEvo` Liouvillian) to retrieve it. The other problem is that `state0` and the `Qobj` parts of the Hamiltonian aren't mutable; the preprocessing of `mesolve` means that none of those objects will exist inside the integrator loop. That's fine for this use-case, but it's not very general. These problems of mutability would apply to callback functions as well. A different way of using `yield` or callback function would be to really lean into a co-routine sort of pattern. So `mesolve` internally would look like; ```python; def mesolve(H, state, times, c_ops, e_ops, options):; # [... set up problem ...]; integrator = scipy.integrate.ode(...); for time in times[1:]:; state = integrator.step_to(time); instructions = yield _mesolve_output_state(state, time, e_ops); integrator = _mesolve_process_instructions(instructions, integrator); ```; and a call to `mesolve` would be like; ```python; solver = mesolve(H, rho0, times, c_ops); try:; result = next(solver); while True:; next_control = krotov.get_next_control(result.time, result.state); result = solver.send([; ('update-arguments', {'control': next_control}),; ('update-hamilt",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1571#issuecomment-859907481
https://github.com/qutip/qutip/issues/1571#issuecomment-859907481:1830,Deployability,integrat,integrator,1830,"little fragile; doing this means we have to guarantee that at _no point_ is the `ctrl_array` object copied. If you wanted to branch off execution part-way through the iterator, you'd have to copy the whole state, and then you'd lose your reference to the control array unless you kept manually walking the structure of the time-dependent object (internally it gets converted into a `QobjEvo` Liouvillian) to retrieve it. The other problem is that `state0` and the `Qobj` parts of the Hamiltonian aren't mutable; the preprocessing of `mesolve` means that none of those objects will exist inside the integrator loop. That's fine for this use-case, but it's not very general. These problems of mutability would apply to callback functions as well. A different way of using `yield` or callback function would be to really lean into a co-routine sort of pattern. So `mesolve` internally would look like; ```python; def mesolve(H, state, times, c_ops, e_ops, options):; # [... set up problem ...]; integrator = scipy.integrate.ode(...); for time in times[1:]:; state = integrator.step_to(time); instructions = yield _mesolve_output_state(state, time, e_ops); integrator = _mesolve_process_instructions(instructions, integrator); ```; and a call to `mesolve` would be like; ```python; solver = mesolve(H, rho0, times, c_ops); try:; result = next(solver); while True:; next_control = krotov.get_next_control(result.time, result.state); result = solver.send([; ('update-arguments', {'control': next_control}),; ('update-hamiltonian', ...),; ('add-c_op', ...),; # possible examples of API commands; ]); except StopIteration:; pass; ```; That's not super user friendly, but it _is_ nicely re-entrant. You'd have a single object you can copy and branch off, and QuTiP would be able to update the relevant objects for you at any given time. Still, I don't think it's a good strategy in general - we'd have to _very_ rigorously define the ""instructions"" API, and it would be pretty awkward to use. It would also be",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1571#issuecomment-859907481
https://github.com/qutip/qutip/issues/1571#issuecomment-859907481:1849,Deployability,integrat,integrate,1849,"doing this means we have to guarantee that at _no point_ is the `ctrl_array` object copied. If you wanted to branch off execution part-way through the iterator, you'd have to copy the whole state, and then you'd lose your reference to the control array unless you kept manually walking the structure of the time-dependent object (internally it gets converted into a `QobjEvo` Liouvillian) to retrieve it. The other problem is that `state0` and the `Qobj` parts of the Hamiltonian aren't mutable; the preprocessing of `mesolve` means that none of those objects will exist inside the integrator loop. That's fine for this use-case, but it's not very general. These problems of mutability would apply to callback functions as well. A different way of using `yield` or callback function would be to really lean into a co-routine sort of pattern. So `mesolve` internally would look like; ```python; def mesolve(H, state, times, c_ops, e_ops, options):; # [... set up problem ...]; integrator = scipy.integrate.ode(...); for time in times[1:]:; state = integrator.step_to(time); instructions = yield _mesolve_output_state(state, time, e_ops); integrator = _mesolve_process_instructions(instructions, integrator); ```; and a call to `mesolve` would be like; ```python; solver = mesolve(H, rho0, times, c_ops); try:; result = next(solver); while True:; next_control = krotov.get_next_control(result.time, result.state); result = solver.send([; ('update-arguments', {'control': next_control}),; ('update-hamiltonian', ...),; ('add-c_op', ...),; # possible examples of API commands; ]); except StopIteration:; pass; ```; That's not super user friendly, but it _is_ nicely re-entrant. You'd have a single object you can copy and branch off, and QuTiP would be able to update the relevant objects for you at any given time. Still, I don't think it's a good strategy in general - we'd have to _very_ rigorously define the ""instructions"" API, and it would be pretty awkward to use. It would also be a nuisance for ",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1571#issuecomment-859907481
https://github.com/qutip/qutip/issues/1571#issuecomment-859907481:1901,Deployability,integrat,integrator,1901,"ee that at _no point_ is the `ctrl_array` object copied. If you wanted to branch off execution part-way through the iterator, you'd have to copy the whole state, and then you'd lose your reference to the control array unless you kept manually walking the structure of the time-dependent object (internally it gets converted into a `QobjEvo` Liouvillian) to retrieve it. The other problem is that `state0` and the `Qobj` parts of the Hamiltonian aren't mutable; the preprocessing of `mesolve` means that none of those objects will exist inside the integrator loop. That's fine for this use-case, but it's not very general. These problems of mutability would apply to callback functions as well. A different way of using `yield` or callback function would be to really lean into a co-routine sort of pattern. So `mesolve` internally would look like; ```python; def mesolve(H, state, times, c_ops, e_ops, options):; # [... set up problem ...]; integrator = scipy.integrate.ode(...); for time in times[1:]:; state = integrator.step_to(time); instructions = yield _mesolve_output_state(state, time, e_ops); integrator = _mesolve_process_instructions(instructions, integrator); ```; and a call to `mesolve` would be like; ```python; solver = mesolve(H, rho0, times, c_ops); try:; result = next(solver); while True:; next_control = krotov.get_next_control(result.time, result.state); result = solver.send([; ('update-arguments', {'control': next_control}),; ('update-hamiltonian', ...),; ('add-c_op', ...),; # possible examples of API commands; ]); except StopIteration:; pass; ```; That's not super user friendly, but it _is_ nicely re-entrant. You'd have a single object you can copy and branch off, and QuTiP would be able to update the relevant objects for you at any given time. Still, I don't think it's a good strategy in general - we'd have to _very_ rigorously define the ""instructions"" API, and it would be pretty awkward to use. It would also be a nuisance for extensibility, probably; the interm",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1571#issuecomment-859907481
https://github.com/qutip/qutip/issues/1571#issuecomment-859907481:1991,Deployability,integrat,integrator,1991,"lose your reference to the control array unless you kept manually walking the structure of the time-dependent object (internally it gets converted into a `QobjEvo` Liouvillian) to retrieve it. The other problem is that `state0` and the `Qobj` parts of the Hamiltonian aren't mutable; the preprocessing of `mesolve` means that none of those objects will exist inside the integrator loop. That's fine for this use-case, but it's not very general. These problems of mutability would apply to callback functions as well. A different way of using `yield` or callback function would be to really lean into a co-routine sort of pattern. So `mesolve` internally would look like; ```python; def mesolve(H, state, times, c_ops, e_ops, options):; # [... set up problem ...]; integrator = scipy.integrate.ode(...); for time in times[1:]:; state = integrator.step_to(time); instructions = yield _mesolve_output_state(state, time, e_ops); integrator = _mesolve_process_instructions(instructions, integrator); ```; and a call to `mesolve` would be like; ```python; solver = mesolve(H, rho0, times, c_ops); try:; result = next(solver); while True:; next_control = krotov.get_next_control(result.time, result.state); result = solver.send([; ('update-arguments', {'control': next_control}),; ('update-hamiltonian', ...),; ('add-c_op', ...),; # possible examples of API commands; ]); except StopIteration:; pass; ```; That's not super user friendly, but it _is_ nicely re-entrant. You'd have a single object you can copy and branch off, and QuTiP would be able to update the relevant objects for you at any given time. Still, I don't think it's a good strategy in general - we'd have to _very_ rigorously define the ""instructions"" API, and it would be pretty awkward to use. It would also be a nuisance for extensibility, probably; the intermediate state and instructions of `mesolve` would just more APIs we have to maintain and keep constant. Note that you can achieve the exact same thing with a callback function pat",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1571#issuecomment-859907481
https://github.com/qutip/qutip/issues/1571#issuecomment-859907481:2048,Deployability,integrat,integrator,2048,"lose your reference to the control array unless you kept manually walking the structure of the time-dependent object (internally it gets converted into a `QobjEvo` Liouvillian) to retrieve it. The other problem is that `state0` and the `Qobj` parts of the Hamiltonian aren't mutable; the preprocessing of `mesolve` means that none of those objects will exist inside the integrator loop. That's fine for this use-case, but it's not very general. These problems of mutability would apply to callback functions as well. A different way of using `yield` or callback function would be to really lean into a co-routine sort of pattern. So `mesolve` internally would look like; ```python; def mesolve(H, state, times, c_ops, e_ops, options):; # [... set up problem ...]; integrator = scipy.integrate.ode(...); for time in times[1:]:; state = integrator.step_to(time); instructions = yield _mesolve_output_state(state, time, e_ops); integrator = _mesolve_process_instructions(instructions, integrator); ```; and a call to `mesolve` would be like; ```python; solver = mesolve(H, rho0, times, c_ops); try:; result = next(solver); while True:; next_control = krotov.get_next_control(result.time, result.state); result = solver.send([; ('update-arguments', {'control': next_control}),; ('update-hamiltonian', ...),; ('add-c_op', ...),; # possible examples of API commands; ]); except StopIteration:; pass; ```; That's not super user friendly, but it _is_ nicely re-entrant. You'd have a single object you can copy and branch off, and QuTiP would be able to update the relevant objects for you at any given time. Still, I don't think it's a good strategy in general - we'd have to _very_ rigorously define the ""instructions"" API, and it would be pretty awkward to use. It would also be a nuisance for extensibility, probably; the intermediate state and instructions of `mesolve` would just more APIs we have to maintain and keep constant. Note that you can achieve the exact same thing with a callback function pat",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1571#issuecomment-859907481
https://github.com/qutip/qutip/issues/1571#issuecomment-859907481:2292,Deployability,update,update-arguments,2292,"amiltonian aren't mutable; the preprocessing of `mesolve` means that none of those objects will exist inside the integrator loop. That's fine for this use-case, but it's not very general. These problems of mutability would apply to callback functions as well. A different way of using `yield` or callback function would be to really lean into a co-routine sort of pattern. So `mesolve` internally would look like; ```python; def mesolve(H, state, times, c_ops, e_ops, options):; # [... set up problem ...]; integrator = scipy.integrate.ode(...); for time in times[1:]:; state = integrator.step_to(time); instructions = yield _mesolve_output_state(state, time, e_ops); integrator = _mesolve_process_instructions(instructions, integrator); ```; and a call to `mesolve` would be like; ```python; solver = mesolve(H, rho0, times, c_ops); try:; result = next(solver); while True:; next_control = krotov.get_next_control(result.time, result.state); result = solver.send([; ('update-arguments', {'control': next_control}),; ('update-hamiltonian', ...),; ('add-c_op', ...),; # possible examples of API commands; ]); except StopIteration:; pass; ```; That's not super user friendly, but it _is_ nicely re-entrant. You'd have a single object you can copy and branch off, and QuTiP would be able to update the relevant objects for you at any given time. Still, I don't think it's a good strategy in general - we'd have to _very_ rigorously define the ""instructions"" API, and it would be pretty awkward to use. It would also be a nuisance for extensibility, probably; the intermediate state and instructions of `mesolve` would just more APIs we have to maintain and keep constant. Note that you can achieve the exact same thing with a callback function pattern here, except that control would never really pass back to the caller, so it would be impossible to (for example) branch execution part way through. The new, modular system we want to put into QuTiP 5 is an attempt to get the best of all these worlds. ",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1571#issuecomment-859907481
https://github.com/qutip/qutip/issues/1571#issuecomment-859907481:2342,Deployability,update,update-hamiltonian,2342,"amiltonian aren't mutable; the preprocessing of `mesolve` means that none of those objects will exist inside the integrator loop. That's fine for this use-case, but it's not very general. These problems of mutability would apply to callback functions as well. A different way of using `yield` or callback function would be to really lean into a co-routine sort of pattern. So `mesolve` internally would look like; ```python; def mesolve(H, state, times, c_ops, e_ops, options):; # [... set up problem ...]; integrator = scipy.integrate.ode(...); for time in times[1:]:; state = integrator.step_to(time); instructions = yield _mesolve_output_state(state, time, e_ops); integrator = _mesolve_process_instructions(instructions, integrator); ```; and a call to `mesolve` would be like; ```python; solver = mesolve(H, rho0, times, c_ops); try:; result = next(solver); while True:; next_control = krotov.get_next_control(result.time, result.state); result = solver.send([; ('update-arguments', {'control': next_control}),; ('update-hamiltonian', ...),; ('add-c_op', ...),; # possible examples of API commands; ]); except StopIteration:; pass; ```; That's not super user friendly, but it _is_ nicely re-entrant. You'd have a single object you can copy and branch off, and QuTiP would be able to update the relevant objects for you at any given time. Still, I don't think it's a good strategy in general - we'd have to _very_ rigorously define the ""instructions"" API, and it would be pretty awkward to use. It would also be a nuisance for extensibility, probably; the intermediate state and instructions of `mesolve` would just more APIs we have to maintain and keep constant. Note that you can achieve the exact same thing with a callback function pattern here, except that control would never really pass back to the caller, so it would be impossible to (for example) branch execution part way through. The new, modular system we want to put into QuTiP 5 is an attempt to get the best of all these worlds. ",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1571#issuecomment-859907481
https://github.com/qutip/qutip/issues/1571#issuecomment-859907481:2611,Deployability,update,update,2611,"ay of using `yield` or callback function would be to really lean into a co-routine sort of pattern. So `mesolve` internally would look like; ```python; def mesolve(H, state, times, c_ops, e_ops, options):; # [... set up problem ...]; integrator = scipy.integrate.ode(...); for time in times[1:]:; state = integrator.step_to(time); instructions = yield _mesolve_output_state(state, time, e_ops); integrator = _mesolve_process_instructions(instructions, integrator); ```; and a call to `mesolve` would be like; ```python; solver = mesolve(H, rho0, times, c_ops); try:; result = next(solver); while True:; next_control = krotov.get_next_control(result.time, result.state); result = solver.send([; ('update-arguments', {'control': next_control}),; ('update-hamiltonian', ...),; ('add-c_op', ...),; # possible examples of API commands; ]); except StopIteration:; pass; ```; That's not super user friendly, but it _is_ nicely re-entrant. You'd have a single object you can copy and branch off, and QuTiP would be able to update the relevant objects for you at any given time. Still, I don't think it's a good strategy in general - we'd have to _very_ rigorously define the ""instructions"" API, and it would be pretty awkward to use. It would also be a nuisance for extensibility, probably; the intermediate state and instructions of `mesolve` would just more APIs we have to maintain and keep constant. Note that you can achieve the exact same thing with a callback function pattern here, except that control would never really pass back to the caller, so it would be impossible to (for example) branch execution part way through. The new, modular system we want to put into QuTiP 5 is an attempt to get the best of all these worlds. For users who don't need all this low-level behaviour, there'll still be the convenient `mesolve`, which just keeps working the same way it does now. For users (like you) who need more, we'll expose all the inner logic of the `mesolve` loop as separate components, so you'l",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1571#issuecomment-859907481
https://github.com/qutip/qutip/issues/1571#issuecomment-859907481:1166,Integrability,depend,dependent,1166,"entrant and forwards-compatible without hamstringing our ability to extend the APIs in the future would probably not be very ergonomic. Both callbacks and `yield` allow the caller to feed information back into `mesolve`, but in this architecture, we'd have to completely define an interchange API, and specify quite explicitly what ""commands"" you can tell this sort of `mesolve` state machine to execute. The pattern in your original comment (reproduced here); ```python; for (i, state) in enumerate(; mesolve([H0, [H1, ctrl_array]], state0, list); ):; # assuming `state` is at tlist[i]; new_val = calculate_control_value_for_next_step(state); ctrl_array[i] = new_val; ctrl_array[i+1] = new_val # ignoring IndexError; ```; is probably a little fragile; doing this means we have to guarantee that at _no point_ is the `ctrl_array` object copied. If you wanted to branch off execution part-way through the iterator, you'd have to copy the whole state, and then you'd lose your reference to the control array unless you kept manually walking the structure of the time-dependent object (internally it gets converted into a `QobjEvo` Liouvillian) to retrieve it. The other problem is that `state0` and the `Qobj` parts of the Hamiltonian aren't mutable; the preprocessing of `mesolve` means that none of those objects will exist inside the integrator loop. That's fine for this use-case, but it's not very general. These problems of mutability would apply to callback functions as well. A different way of using `yield` or callback function would be to really lean into a co-routine sort of pattern. So `mesolve` internally would look like; ```python; def mesolve(H, state, times, c_ops, e_ops, options):; # [... set up problem ...]; integrator = scipy.integrate.ode(...); for time in times[1:]:; state = integrator.step_to(time); instructions = yield _mesolve_output_state(state, time, e_ops); integrator = _mesolve_process_instructions(instructions, integrator); ```; and a call to `mesolve` would be lik",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1571#issuecomment-859907481
https://github.com/qutip/qutip/issues/1571#issuecomment-859907481:1436,Integrability,integrat,integrator,1436,"ve to completely define an interchange API, and specify quite explicitly what ""commands"" you can tell this sort of `mesolve` state machine to execute. The pattern in your original comment (reproduced here); ```python; for (i, state) in enumerate(; mesolve([H0, [H1, ctrl_array]], state0, list); ):; # assuming `state` is at tlist[i]; new_val = calculate_control_value_for_next_step(state); ctrl_array[i] = new_val; ctrl_array[i+1] = new_val # ignoring IndexError; ```; is probably a little fragile; doing this means we have to guarantee that at _no point_ is the `ctrl_array` object copied. If you wanted to branch off execution part-way through the iterator, you'd have to copy the whole state, and then you'd lose your reference to the control array unless you kept manually walking the structure of the time-dependent object (internally it gets converted into a `QobjEvo` Liouvillian) to retrieve it. The other problem is that `state0` and the `Qobj` parts of the Hamiltonian aren't mutable; the preprocessing of `mesolve` means that none of those objects will exist inside the integrator loop. That's fine for this use-case, but it's not very general. These problems of mutability would apply to callback functions as well. A different way of using `yield` or callback function would be to really lean into a co-routine sort of pattern. So `mesolve` internally would look like; ```python; def mesolve(H, state, times, c_ops, e_ops, options):; # [... set up problem ...]; integrator = scipy.integrate.ode(...); for time in times[1:]:; state = integrator.step_to(time); instructions = yield _mesolve_output_state(state, time, e_ops); integrator = _mesolve_process_instructions(instructions, integrator); ```; and a call to `mesolve` would be like; ```python; solver = mesolve(H, rho0, times, c_ops); try:; result = next(solver); while True:; next_control = krotov.get_next_control(result.time, result.state); result = solver.send([; ('update-arguments', {'control': next_control}),; ('update-hamilt",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1571#issuecomment-859907481
https://github.com/qutip/qutip/issues/1571#issuecomment-859907481:1671,Integrability,rout,routine,1671,"te0, list); ):; # assuming `state` is at tlist[i]; new_val = calculate_control_value_for_next_step(state); ctrl_array[i] = new_val; ctrl_array[i+1] = new_val # ignoring IndexError; ```; is probably a little fragile; doing this means we have to guarantee that at _no point_ is the `ctrl_array` object copied. If you wanted to branch off execution part-way through the iterator, you'd have to copy the whole state, and then you'd lose your reference to the control array unless you kept manually walking the structure of the time-dependent object (internally it gets converted into a `QobjEvo` Liouvillian) to retrieve it. The other problem is that `state0` and the `Qobj` parts of the Hamiltonian aren't mutable; the preprocessing of `mesolve` means that none of those objects will exist inside the integrator loop. That's fine for this use-case, but it's not very general. These problems of mutability would apply to callback functions as well. A different way of using `yield` or callback function would be to really lean into a co-routine sort of pattern. So `mesolve` internally would look like; ```python; def mesolve(H, state, times, c_ops, e_ops, options):; # [... set up problem ...]; integrator = scipy.integrate.ode(...); for time in times[1:]:; state = integrator.step_to(time); instructions = yield _mesolve_output_state(state, time, e_ops); integrator = _mesolve_process_instructions(instructions, integrator); ```; and a call to `mesolve` would be like; ```python; solver = mesolve(H, rho0, times, c_ops); try:; result = next(solver); while True:; next_control = krotov.get_next_control(result.time, result.state); result = solver.send([; ('update-arguments', {'control': next_control}),; ('update-hamiltonian', ...),; ('add-c_op', ...),; # possible examples of API commands; ]); except StopIteration:; pass; ```; That's not super user friendly, but it _is_ nicely re-entrant. You'd have a single object you can copy and branch off, and QuTiP would be able to update the relevant objects ",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1571#issuecomment-859907481
https://github.com/qutip/qutip/issues/1571#issuecomment-859907481:1830,Integrability,integrat,integrator,1830,"little fragile; doing this means we have to guarantee that at _no point_ is the `ctrl_array` object copied. If you wanted to branch off execution part-way through the iterator, you'd have to copy the whole state, and then you'd lose your reference to the control array unless you kept manually walking the structure of the time-dependent object (internally it gets converted into a `QobjEvo` Liouvillian) to retrieve it. The other problem is that `state0` and the `Qobj` parts of the Hamiltonian aren't mutable; the preprocessing of `mesolve` means that none of those objects will exist inside the integrator loop. That's fine for this use-case, but it's not very general. These problems of mutability would apply to callback functions as well. A different way of using `yield` or callback function would be to really lean into a co-routine sort of pattern. So `mesolve` internally would look like; ```python; def mesolve(H, state, times, c_ops, e_ops, options):; # [... set up problem ...]; integrator = scipy.integrate.ode(...); for time in times[1:]:; state = integrator.step_to(time); instructions = yield _mesolve_output_state(state, time, e_ops); integrator = _mesolve_process_instructions(instructions, integrator); ```; and a call to `mesolve` would be like; ```python; solver = mesolve(H, rho0, times, c_ops); try:; result = next(solver); while True:; next_control = krotov.get_next_control(result.time, result.state); result = solver.send([; ('update-arguments', {'control': next_control}),; ('update-hamiltonian', ...),; ('add-c_op', ...),; # possible examples of API commands; ]); except StopIteration:; pass; ```; That's not super user friendly, but it _is_ nicely re-entrant. You'd have a single object you can copy and branch off, and QuTiP would be able to update the relevant objects for you at any given time. Still, I don't think it's a good strategy in general - we'd have to _very_ rigorously define the ""instructions"" API, and it would be pretty awkward to use. It would also be",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1571#issuecomment-859907481
https://github.com/qutip/qutip/issues/1571#issuecomment-859907481:1849,Integrability,integrat,integrate,1849,"doing this means we have to guarantee that at _no point_ is the `ctrl_array` object copied. If you wanted to branch off execution part-way through the iterator, you'd have to copy the whole state, and then you'd lose your reference to the control array unless you kept manually walking the structure of the time-dependent object (internally it gets converted into a `QobjEvo` Liouvillian) to retrieve it. The other problem is that `state0` and the `Qobj` parts of the Hamiltonian aren't mutable; the preprocessing of `mesolve` means that none of those objects will exist inside the integrator loop. That's fine for this use-case, but it's not very general. These problems of mutability would apply to callback functions as well. A different way of using `yield` or callback function would be to really lean into a co-routine sort of pattern. So `mesolve` internally would look like; ```python; def mesolve(H, state, times, c_ops, e_ops, options):; # [... set up problem ...]; integrator = scipy.integrate.ode(...); for time in times[1:]:; state = integrator.step_to(time); instructions = yield _mesolve_output_state(state, time, e_ops); integrator = _mesolve_process_instructions(instructions, integrator); ```; and a call to `mesolve` would be like; ```python; solver = mesolve(H, rho0, times, c_ops); try:; result = next(solver); while True:; next_control = krotov.get_next_control(result.time, result.state); result = solver.send([; ('update-arguments', {'control': next_control}),; ('update-hamiltonian', ...),; ('add-c_op', ...),; # possible examples of API commands; ]); except StopIteration:; pass; ```; That's not super user friendly, but it _is_ nicely re-entrant. You'd have a single object you can copy and branch off, and QuTiP would be able to update the relevant objects for you at any given time. Still, I don't think it's a good strategy in general - we'd have to _very_ rigorously define the ""instructions"" API, and it would be pretty awkward to use. It would also be a nuisance for ",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1571#issuecomment-859907481
https://github.com/qutip/qutip/issues/1571#issuecomment-859907481:1901,Integrability,integrat,integrator,1901,"ee that at _no point_ is the `ctrl_array` object copied. If you wanted to branch off execution part-way through the iterator, you'd have to copy the whole state, and then you'd lose your reference to the control array unless you kept manually walking the structure of the time-dependent object (internally it gets converted into a `QobjEvo` Liouvillian) to retrieve it. The other problem is that `state0` and the `Qobj` parts of the Hamiltonian aren't mutable; the preprocessing of `mesolve` means that none of those objects will exist inside the integrator loop. That's fine for this use-case, but it's not very general. These problems of mutability would apply to callback functions as well. A different way of using `yield` or callback function would be to really lean into a co-routine sort of pattern. So `mesolve` internally would look like; ```python; def mesolve(H, state, times, c_ops, e_ops, options):; # [... set up problem ...]; integrator = scipy.integrate.ode(...); for time in times[1:]:; state = integrator.step_to(time); instructions = yield _mesolve_output_state(state, time, e_ops); integrator = _mesolve_process_instructions(instructions, integrator); ```; and a call to `mesolve` would be like; ```python; solver = mesolve(H, rho0, times, c_ops); try:; result = next(solver); while True:; next_control = krotov.get_next_control(result.time, result.state); result = solver.send([; ('update-arguments', {'control': next_control}),; ('update-hamiltonian', ...),; ('add-c_op', ...),; # possible examples of API commands; ]); except StopIteration:; pass; ```; That's not super user friendly, but it _is_ nicely re-entrant. You'd have a single object you can copy and branch off, and QuTiP would be able to update the relevant objects for you at any given time. Still, I don't think it's a good strategy in general - we'd have to _very_ rigorously define the ""instructions"" API, and it would be pretty awkward to use. It would also be a nuisance for extensibility, probably; the interm",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1571#issuecomment-859907481
https://github.com/qutip/qutip/issues/1571#issuecomment-859907481:1991,Integrability,integrat,integrator,1991,"lose your reference to the control array unless you kept manually walking the structure of the time-dependent object (internally it gets converted into a `QobjEvo` Liouvillian) to retrieve it. The other problem is that `state0` and the `Qobj` parts of the Hamiltonian aren't mutable; the preprocessing of `mesolve` means that none of those objects will exist inside the integrator loop. That's fine for this use-case, but it's not very general. These problems of mutability would apply to callback functions as well. A different way of using `yield` or callback function would be to really lean into a co-routine sort of pattern. So `mesolve` internally would look like; ```python; def mesolve(H, state, times, c_ops, e_ops, options):; # [... set up problem ...]; integrator = scipy.integrate.ode(...); for time in times[1:]:; state = integrator.step_to(time); instructions = yield _mesolve_output_state(state, time, e_ops); integrator = _mesolve_process_instructions(instructions, integrator); ```; and a call to `mesolve` would be like; ```python; solver = mesolve(H, rho0, times, c_ops); try:; result = next(solver); while True:; next_control = krotov.get_next_control(result.time, result.state); result = solver.send([; ('update-arguments', {'control': next_control}),; ('update-hamiltonian', ...),; ('add-c_op', ...),; # possible examples of API commands; ]); except StopIteration:; pass; ```; That's not super user friendly, but it _is_ nicely re-entrant. You'd have a single object you can copy and branch off, and QuTiP would be able to update the relevant objects for you at any given time. Still, I don't think it's a good strategy in general - we'd have to _very_ rigorously define the ""instructions"" API, and it would be pretty awkward to use. It would also be a nuisance for extensibility, probably; the intermediate state and instructions of `mesolve` would just more APIs we have to maintain and keep constant. Note that you can achieve the exact same thing with a callback function pat",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1571#issuecomment-859907481
https://github.com/qutip/qutip/issues/1571#issuecomment-859907481:2048,Integrability,integrat,integrator,2048,"lose your reference to the control array unless you kept manually walking the structure of the time-dependent object (internally it gets converted into a `QobjEvo` Liouvillian) to retrieve it. The other problem is that `state0` and the `Qobj` parts of the Hamiltonian aren't mutable; the preprocessing of `mesolve` means that none of those objects will exist inside the integrator loop. That's fine for this use-case, but it's not very general. These problems of mutability would apply to callback functions as well. A different way of using `yield` or callback function would be to really lean into a co-routine sort of pattern. So `mesolve` internally would look like; ```python; def mesolve(H, state, times, c_ops, e_ops, options):; # [... set up problem ...]; integrator = scipy.integrate.ode(...); for time in times[1:]:; state = integrator.step_to(time); instructions = yield _mesolve_output_state(state, time, e_ops); integrator = _mesolve_process_instructions(instructions, integrator); ```; and a call to `mesolve` would be like; ```python; solver = mesolve(H, rho0, times, c_ops); try:; result = next(solver); while True:; next_control = krotov.get_next_control(result.time, result.state); result = solver.send([; ('update-arguments', {'control': next_control}),; ('update-hamiltonian', ...),; ('add-c_op', ...),; # possible examples of API commands; ]); except StopIteration:; pass; ```; That's not super user friendly, but it _is_ nicely re-entrant. You'd have a single object you can copy and branch off, and QuTiP would be able to update the relevant objects for you at any given time. Still, I don't think it's a good strategy in general - we'd have to _very_ rigorously define the ""instructions"" API, and it would be pretty awkward to use. It would also be a nuisance for extensibility, probably; the intermediate state and instructions of `mesolve` would just more APIs we have to maintain and keep constant. Note that you can achieve the exact same thing with a callback function pat",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1571#issuecomment-859907481
https://github.com/qutip/qutip/issues/1571#issuecomment-859907481:169,Modifiability,extend,extend,169,"Oh, also, about callback functions and `yield`: if we did this, the patterns for making `mesolve` re-entrant and forwards-compatible without hamstringing our ability to extend the APIs in the future would probably not be very ergonomic. Both callbacks and `yield` allow the caller to feed information back into `mesolve`, but in this architecture, we'd have to completely define an interchange API, and specify quite explicitly what ""commands"" you can tell this sort of `mesolve` state machine to execute. The pattern in your original comment (reproduced here); ```python; for (i, state) in enumerate(; mesolve([H0, [H1, ctrl_array]], state0, list); ):; # assuming `state` is at tlist[i]; new_val = calculate_control_value_for_next_step(state); ctrl_array[i] = new_val; ctrl_array[i+1] = new_val # ignoring IndexError; ```; is probably a little fragile; doing this means we have to guarantee that at _no point_ is the `ctrl_array` object copied. If you wanted to branch off execution part-way through the iterator, you'd have to copy the whole state, and then you'd lose your reference to the control array unless you kept manually walking the structure of the time-dependent object (internally it gets converted into a `QobjEvo` Liouvillian) to retrieve it. The other problem is that `state0` and the `Qobj` parts of the Hamiltonian aren't mutable; the preprocessing of `mesolve` means that none of those objects will exist inside the integrator loop. That's fine for this use-case, but it's not very general. These problems of mutability would apply to callback functions as well. A different way of using `yield` or callback function would be to really lean into a co-routine sort of pattern. So `mesolve` internally would look like; ```python; def mesolve(H, state, times, c_ops, e_ops, options):; # [... set up problem ...]; integrator = scipy.integrate.ode(...); for time in times[1:]:; state = integrator.step_to(time); instructions = yield _mesolve_output_state(state, time, e_ops); integrator",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1571#issuecomment-859907481
https://github.com/qutip/qutip/issues/1571#issuecomment-859907481:3515,Security,expose,expose,3515,"tate, time, e_ops); integrator = _mesolve_process_instructions(instructions, integrator); ```; and a call to `mesolve` would be like; ```python; solver = mesolve(H, rho0, times, c_ops); try:; result = next(solver); while True:; next_control = krotov.get_next_control(result.time, result.state); result = solver.send([; ('update-arguments', {'control': next_control}),; ('update-hamiltonian', ...),; ('add-c_op', ...),; # possible examples of API commands; ]); except StopIteration:; pass; ```; That's not super user friendly, but it _is_ nicely re-entrant. You'd have a single object you can copy and branch off, and QuTiP would be able to update the relevant objects for you at any given time. Still, I don't think it's a good strategy in general - we'd have to _very_ rigorously define the ""instructions"" API, and it would be pretty awkward to use. It would also be a nuisance for extensibility, probably; the intermediate state and instructions of `mesolve` would just more APIs we have to maintain and keep constant. Note that you can achieve the exact same thing with a callback function pattern here, except that control would never really pass back to the caller, so it would be impossible to (for example) branch execution part way through. The new, modular system we want to put into QuTiP 5 is an attempt to get the best of all these worlds. For users who don't need all this low-level behaviour, there'll still be the convenient `mesolve`, which just keeps working the same way it does now. For users (like you) who need more, we'll expose all the inner logic of the `mesolve` loop as separate components, so you'll still get all the nice set-up utilities if you want them, but you'll also then just be able to run the inner loop yourself. Since everything is modular, you'll have access to modify _everything_ that `mesolve` can access, so we won't need to define a specific, awkward API, and you can change it in whatever programming style you like, and is appropriate for your use case.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1571#issuecomment-859907481
https://github.com/qutip/qutip/issues/1571#issuecomment-859907481:3763,Security,access,access,3763,"tate, time, e_ops); integrator = _mesolve_process_instructions(instructions, integrator); ```; and a call to `mesolve` would be like; ```python; solver = mesolve(H, rho0, times, c_ops); try:; result = next(solver); while True:; next_control = krotov.get_next_control(result.time, result.state); result = solver.send([; ('update-arguments', {'control': next_control}),; ('update-hamiltonian', ...),; ('add-c_op', ...),; # possible examples of API commands; ]); except StopIteration:; pass; ```; That's not super user friendly, but it _is_ nicely re-entrant. You'd have a single object you can copy and branch off, and QuTiP would be able to update the relevant objects for you at any given time. Still, I don't think it's a good strategy in general - we'd have to _very_ rigorously define the ""instructions"" API, and it would be pretty awkward to use. It would also be a nuisance for extensibility, probably; the intermediate state and instructions of `mesolve` would just more APIs we have to maintain and keep constant. Note that you can achieve the exact same thing with a callback function pattern here, except that control would never really pass back to the caller, so it would be impossible to (for example) branch execution part way through. The new, modular system we want to put into QuTiP 5 is an attempt to get the best of all these worlds. For users who don't need all this low-level behaviour, there'll still be the convenient `mesolve`, which just keeps working the same way it does now. For users (like you) who need more, we'll expose all the inner logic of the `mesolve` loop as separate components, so you'll still get all the nice set-up utilities if you want them, but you'll also then just be able to run the inner loop yourself. Since everything is modular, you'll have access to modify _everything_ that `mesolve` can access, so we won't need to define a specific, awkward API, and you can change it in whatever programming style you like, and is appropriate for your use case.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1571#issuecomment-859907481
https://github.com/qutip/qutip/issues/1571#issuecomment-859907481:3812,Security,access,access,3812,"tate, time, e_ops); integrator = _mesolve_process_instructions(instructions, integrator); ```; and a call to `mesolve` would be like; ```python; solver = mesolve(H, rho0, times, c_ops); try:; result = next(solver); while True:; next_control = krotov.get_next_control(result.time, result.state); result = solver.send([; ('update-arguments', {'control': next_control}),; ('update-hamiltonian', ...),; ('add-c_op', ...),; # possible examples of API commands; ]); except StopIteration:; pass; ```; That's not super user friendly, but it _is_ nicely re-entrant. You'd have a single object you can copy and branch off, and QuTiP would be able to update the relevant objects for you at any given time. Still, I don't think it's a good strategy in general - we'd have to _very_ rigorously define the ""instructions"" API, and it would be pretty awkward to use. It would also be a nuisance for extensibility, probably; the intermediate state and instructions of `mesolve` would just more APIs we have to maintain and keep constant. Note that you can achieve the exact same thing with a callback function pattern here, except that control would never really pass back to the caller, so it would be impossible to (for example) branch execution part way through. The new, modular system we want to put into QuTiP 5 is an attempt to get the best of all these worlds. For users who don't need all this low-level behaviour, there'll still be the convenient `mesolve`, which just keeps working the same way it does now. For users (like you) who need more, we'll expose all the inner logic of the `mesolve` loop as separate components, so you'll still get all the nice set-up utilities if you want them, but you'll also then just be able to run the inner loop yourself. Since everything is modular, you'll have access to modify _everything_ that `mesolve` can access, so we won't need to define a specific, awkward API, and you can change it in whatever programming style you like, and is appropriate for your use case.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1571#issuecomment-859907481
https://github.com/qutip/qutip/issues/1571#issuecomment-859907481:3536,Testability,log,logic,3536,"tate, time, e_ops); integrator = _mesolve_process_instructions(instructions, integrator); ```; and a call to `mesolve` would be like; ```python; solver = mesolve(H, rho0, times, c_ops); try:; result = next(solver); while True:; next_control = krotov.get_next_control(result.time, result.state); result = solver.send([; ('update-arguments', {'control': next_control}),; ('update-hamiltonian', ...),; ('add-c_op', ...),; # possible examples of API commands; ]); except StopIteration:; pass; ```; That's not super user friendly, but it _is_ nicely re-entrant. You'd have a single object you can copy and branch off, and QuTiP would be able to update the relevant objects for you at any given time. Still, I don't think it's a good strategy in general - we'd have to _very_ rigorously define the ""instructions"" API, and it would be pretty awkward to use. It would also be a nuisance for extensibility, probably; the intermediate state and instructions of `mesolve` would just more APIs we have to maintain and keep constant. Note that you can achieve the exact same thing with a callback function pattern here, except that control would never really pass back to the caller, so it would be impossible to (for example) branch execution part way through. The new, modular system we want to put into QuTiP 5 is an attempt to get the best of all these worlds. For users who don't need all this low-level behaviour, there'll still be the convenient `mesolve`, which just keeps working the same way it does now. For users (like you) who need more, we'll expose all the inner logic of the `mesolve` loop as separate components, so you'll still get all the nice set-up utilities if you want them, but you'll also then just be able to run the inner loop yourself. Since everything is modular, you'll have access to modify _everything_ that `mesolve` can access, so we won't need to define a specific, awkward API, and you can change it in whatever programming style you like, and is appropriate for your use case.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1571#issuecomment-859907481
https://github.com/qutip/qutip/issues/1571#issuecomment-859917462:922,Deployability,Integrat,Integrator,922,"I also note that I'm not replying to the thread I thought I was - I thought I was in `krotov`! For my response to the discussion points:; - I think the function `qutip.mesolve` shouldn't change interface at all for 5.0 - we can change its backend, but I think it'll be a huge hindrance to adoption of 5.0 if we make major breaking changes to effectively our premier function, and I don't see a need to do that. We can add, rather than change, and keep `mesolve` as the ""quick-and-dirty"" method that just works.; - I'm in favour of exposing the different parts of the `mesolve` process as user-accessible, composable chunks. So something like exposing a `mesolve_prepare_ode(H, state, c_ops) -> OdeState` function, where `OdeState` has properties `rhs: QobjEvo`, `state: Qobj`, `time: float` (`sesolve_prepare_ode` and `mcsolve_prepare_ode` would presumably return the same object, or a derived object). Then we'd have an `Integrator` class, which encapsulates an integration step using whatever integrator of choice, so there's one that encapsulates the scipy integrator, one which is a Cython-ised RK4 implementation, etc. Then the low-level user would simply write the `for time in times` loop themselves; at this level, there's nothing fancy that QuTiP adds, so we may as well just expose it directly. I think this architecture is approximately what Eric had in mind too, though I presumably haven't used the same names.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1571#issuecomment-859917462
https://github.com/qutip/qutip/issues/1571#issuecomment-859917462:963,Deployability,integrat,integration,963,"I also note that I'm not replying to the thread I thought I was - I thought I was in `krotov`! For my response to the discussion points:; - I think the function `qutip.mesolve` shouldn't change interface at all for 5.0 - we can change its backend, but I think it'll be a huge hindrance to adoption of 5.0 if we make major breaking changes to effectively our premier function, and I don't see a need to do that. We can add, rather than change, and keep `mesolve` as the ""quick-and-dirty"" method that just works.; - I'm in favour of exposing the different parts of the `mesolve` process as user-accessible, composable chunks. So something like exposing a `mesolve_prepare_ode(H, state, c_ops) -> OdeState` function, where `OdeState` has properties `rhs: QobjEvo`, `state: Qobj`, `time: float` (`sesolve_prepare_ode` and `mcsolve_prepare_ode` would presumably return the same object, or a derived object). Then we'd have an `Integrator` class, which encapsulates an integration step using whatever integrator of choice, so there's one that encapsulates the scipy integrator, one which is a Cython-ised RK4 implementation, etc. Then the low-level user would simply write the `for time in times` loop themselves; at this level, there's nothing fancy that QuTiP adds, so we may as well just expose it directly. I think this architecture is approximately what Eric had in mind too, though I presumably haven't used the same names.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1571#issuecomment-859917462
https://github.com/qutip/qutip/issues/1571#issuecomment-859917462:995,Deployability,integrat,integrator,995,"I also note that I'm not replying to the thread I thought I was - I thought I was in `krotov`! For my response to the discussion points:; - I think the function `qutip.mesolve` shouldn't change interface at all for 5.0 - we can change its backend, but I think it'll be a huge hindrance to adoption of 5.0 if we make major breaking changes to effectively our premier function, and I don't see a need to do that. We can add, rather than change, and keep `mesolve` as the ""quick-and-dirty"" method that just works.; - I'm in favour of exposing the different parts of the `mesolve` process as user-accessible, composable chunks. So something like exposing a `mesolve_prepare_ode(H, state, c_ops) -> OdeState` function, where `OdeState` has properties `rhs: QobjEvo`, `state: Qobj`, `time: float` (`sesolve_prepare_ode` and `mcsolve_prepare_ode` would presumably return the same object, or a derived object). Then we'd have an `Integrator` class, which encapsulates an integration step using whatever integrator of choice, so there's one that encapsulates the scipy integrator, one which is a Cython-ised RK4 implementation, etc. Then the low-level user would simply write the `for time in times` loop themselves; at this level, there's nothing fancy that QuTiP adds, so we may as well just expose it directly. I think this architecture is approximately what Eric had in mind too, though I presumably haven't used the same names.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1571#issuecomment-859917462
https://github.com/qutip/qutip/issues/1571#issuecomment-859917462:1060,Deployability,integrat,integrator,1060,"I also note that I'm not replying to the thread I thought I was - I thought I was in `krotov`! For my response to the discussion points:; - I think the function `qutip.mesolve` shouldn't change interface at all for 5.0 - we can change its backend, but I think it'll be a huge hindrance to adoption of 5.0 if we make major breaking changes to effectively our premier function, and I don't see a need to do that. We can add, rather than change, and keep `mesolve` as the ""quick-and-dirty"" method that just works.; - I'm in favour of exposing the different parts of the `mesolve` process as user-accessible, composable chunks. So something like exposing a `mesolve_prepare_ode(H, state, c_ops) -> OdeState` function, where `OdeState` has properties `rhs: QobjEvo`, `state: Qobj`, `time: float` (`sesolve_prepare_ode` and `mcsolve_prepare_ode` would presumably return the same object, or a derived object). Then we'd have an `Integrator` class, which encapsulates an integration step using whatever integrator of choice, so there's one that encapsulates the scipy integrator, one which is a Cython-ised RK4 implementation, etc. Then the low-level user would simply write the `for time in times` loop themselves; at this level, there's nothing fancy that QuTiP adds, so we may as well just expose it directly. I think this architecture is approximately what Eric had in mind too, though I presumably haven't used the same names.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1571#issuecomment-859917462
https://github.com/qutip/qutip/issues/1571#issuecomment-859917462:194,Integrability,interface,interface,194,"I also note that I'm not replying to the thread I thought I was - I thought I was in `krotov`! For my response to the discussion points:; - I think the function `qutip.mesolve` shouldn't change interface at all for 5.0 - we can change its backend, but I think it'll be a huge hindrance to adoption of 5.0 if we make major breaking changes to effectively our premier function, and I don't see a need to do that. We can add, rather than change, and keep `mesolve` as the ""quick-and-dirty"" method that just works.; - I'm in favour of exposing the different parts of the `mesolve` process as user-accessible, composable chunks. So something like exposing a `mesolve_prepare_ode(H, state, c_ops) -> OdeState` function, where `OdeState` has properties `rhs: QobjEvo`, `state: Qobj`, `time: float` (`sesolve_prepare_ode` and `mcsolve_prepare_ode` would presumably return the same object, or a derived object). Then we'd have an `Integrator` class, which encapsulates an integration step using whatever integrator of choice, so there's one that encapsulates the scipy integrator, one which is a Cython-ised RK4 implementation, etc. Then the low-level user would simply write the `for time in times` loop themselves; at this level, there's nothing fancy that QuTiP adds, so we may as well just expose it directly. I think this architecture is approximately what Eric had in mind too, though I presumably haven't used the same names.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1571#issuecomment-859917462
https://github.com/qutip/qutip/issues/1571#issuecomment-859917462:922,Integrability,Integrat,Integrator,922,"I also note that I'm not replying to the thread I thought I was - I thought I was in `krotov`! For my response to the discussion points:; - I think the function `qutip.mesolve` shouldn't change interface at all for 5.0 - we can change its backend, but I think it'll be a huge hindrance to adoption of 5.0 if we make major breaking changes to effectively our premier function, and I don't see a need to do that. We can add, rather than change, and keep `mesolve` as the ""quick-and-dirty"" method that just works.; - I'm in favour of exposing the different parts of the `mesolve` process as user-accessible, composable chunks. So something like exposing a `mesolve_prepare_ode(H, state, c_ops) -> OdeState` function, where `OdeState` has properties `rhs: QobjEvo`, `state: Qobj`, `time: float` (`sesolve_prepare_ode` and `mcsolve_prepare_ode` would presumably return the same object, or a derived object). Then we'd have an `Integrator` class, which encapsulates an integration step using whatever integrator of choice, so there's one that encapsulates the scipy integrator, one which is a Cython-ised RK4 implementation, etc. Then the low-level user would simply write the `for time in times` loop themselves; at this level, there's nothing fancy that QuTiP adds, so we may as well just expose it directly. I think this architecture is approximately what Eric had in mind too, though I presumably haven't used the same names.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1571#issuecomment-859917462
https://github.com/qutip/qutip/issues/1571#issuecomment-859917462:963,Integrability,integrat,integration,963,"I also note that I'm not replying to the thread I thought I was - I thought I was in `krotov`! For my response to the discussion points:; - I think the function `qutip.mesolve` shouldn't change interface at all for 5.0 - we can change its backend, but I think it'll be a huge hindrance to adoption of 5.0 if we make major breaking changes to effectively our premier function, and I don't see a need to do that. We can add, rather than change, and keep `mesolve` as the ""quick-and-dirty"" method that just works.; - I'm in favour of exposing the different parts of the `mesolve` process as user-accessible, composable chunks. So something like exposing a `mesolve_prepare_ode(H, state, c_ops) -> OdeState` function, where `OdeState` has properties `rhs: QobjEvo`, `state: Qobj`, `time: float` (`sesolve_prepare_ode` and `mcsolve_prepare_ode` would presumably return the same object, or a derived object). Then we'd have an `Integrator` class, which encapsulates an integration step using whatever integrator of choice, so there's one that encapsulates the scipy integrator, one which is a Cython-ised RK4 implementation, etc. Then the low-level user would simply write the `for time in times` loop themselves; at this level, there's nothing fancy that QuTiP adds, so we may as well just expose it directly. I think this architecture is approximately what Eric had in mind too, though I presumably haven't used the same names.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1571#issuecomment-859917462
https://github.com/qutip/qutip/issues/1571#issuecomment-859917462:995,Integrability,integrat,integrator,995,"I also note that I'm not replying to the thread I thought I was - I thought I was in `krotov`! For my response to the discussion points:; - I think the function `qutip.mesolve` shouldn't change interface at all for 5.0 - we can change its backend, but I think it'll be a huge hindrance to adoption of 5.0 if we make major breaking changes to effectively our premier function, and I don't see a need to do that. We can add, rather than change, and keep `mesolve` as the ""quick-and-dirty"" method that just works.; - I'm in favour of exposing the different parts of the `mesolve` process as user-accessible, composable chunks. So something like exposing a `mesolve_prepare_ode(H, state, c_ops) -> OdeState` function, where `OdeState` has properties `rhs: QobjEvo`, `state: Qobj`, `time: float` (`sesolve_prepare_ode` and `mcsolve_prepare_ode` would presumably return the same object, or a derived object). Then we'd have an `Integrator` class, which encapsulates an integration step using whatever integrator of choice, so there's one that encapsulates the scipy integrator, one which is a Cython-ised RK4 implementation, etc. Then the low-level user would simply write the `for time in times` loop themselves; at this level, there's nothing fancy that QuTiP adds, so we may as well just expose it directly. I think this architecture is approximately what Eric had in mind too, though I presumably haven't used the same names.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1571#issuecomment-859917462
https://github.com/qutip/qutip/issues/1571#issuecomment-859917462:1060,Integrability,integrat,integrator,1060,"I also note that I'm not replying to the thread I thought I was - I thought I was in `krotov`! For my response to the discussion points:; - I think the function `qutip.mesolve` shouldn't change interface at all for 5.0 - we can change its backend, but I think it'll be a huge hindrance to adoption of 5.0 if we make major breaking changes to effectively our premier function, and I don't see a need to do that. We can add, rather than change, and keep `mesolve` as the ""quick-and-dirty"" method that just works.; - I'm in favour of exposing the different parts of the `mesolve` process as user-accessible, composable chunks. So something like exposing a `mesolve_prepare_ode(H, state, c_ops) -> OdeState` function, where `OdeState` has properties `rhs: QobjEvo`, `state: Qobj`, `time: float` (`sesolve_prepare_ode` and `mcsolve_prepare_ode` would presumably return the same object, or a derived object). Then we'd have an `Integrator` class, which encapsulates an integration step using whatever integrator of choice, so there's one that encapsulates the scipy integrator, one which is a Cython-ised RK4 implementation, etc. Then the low-level user would simply write the `for time in times` loop themselves; at this level, there's nothing fancy that QuTiP adds, so we may as well just expose it directly. I think this architecture is approximately what Eric had in mind too, though I presumably haven't used the same names.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1571#issuecomment-859917462
https://github.com/qutip/qutip/issues/1571#issuecomment-859917462:593,Security,access,accessible,593,"I also note that I'm not replying to the thread I thought I was - I thought I was in `krotov`! For my response to the discussion points:; - I think the function `qutip.mesolve` shouldn't change interface at all for 5.0 - we can change its backend, but I think it'll be a huge hindrance to adoption of 5.0 if we make major breaking changes to effectively our premier function, and I don't see a need to do that. We can add, rather than change, and keep `mesolve` as the ""quick-and-dirty"" method that just works.; - I'm in favour of exposing the different parts of the `mesolve` process as user-accessible, composable chunks. So something like exposing a `mesolve_prepare_ode(H, state, c_ops) -> OdeState` function, where `OdeState` has properties `rhs: QobjEvo`, `state: Qobj`, `time: float` (`sesolve_prepare_ode` and `mcsolve_prepare_ode` would presumably return the same object, or a derived object). Then we'd have an `Integrator` class, which encapsulates an integration step using whatever integrator of choice, so there's one that encapsulates the scipy integrator, one which is a Cython-ised RK4 implementation, etc. Then the low-level user would simply write the `for time in times` loop themselves; at this level, there's nothing fancy that QuTiP adds, so we may as well just expose it directly. I think this architecture is approximately what Eric had in mind too, though I presumably haven't used the same names.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1571#issuecomment-859917462
https://github.com/qutip/qutip/issues/1571#issuecomment-859917462:1285,Security,expose,expose,1285,"I also note that I'm not replying to the thread I thought I was - I thought I was in `krotov`! For my response to the discussion points:; - I think the function `qutip.mesolve` shouldn't change interface at all for 5.0 - we can change its backend, but I think it'll be a huge hindrance to adoption of 5.0 if we make major breaking changes to effectively our premier function, and I don't see a need to do that. We can add, rather than change, and keep `mesolve` as the ""quick-and-dirty"" method that just works.; - I'm in favour of exposing the different parts of the `mesolve` process as user-accessible, composable chunks. So something like exposing a `mesolve_prepare_ode(H, state, c_ops) -> OdeState` function, where `OdeState` has properties `rhs: QobjEvo`, `state: Qobj`, `time: float` (`sesolve_prepare_ode` and `mcsolve_prepare_ode` would presumably return the same object, or a derived object). Then we'd have an `Integrator` class, which encapsulates an integration step using whatever integrator of choice, so there's one that encapsulates the scipy integrator, one which is a Cython-ised RK4 implementation, etc. Then the low-level user would simply write the `for time in times` loop themselves; at this level, there's nothing fancy that QuTiP adds, so we may as well just expose it directly. I think this architecture is approximately what Eric had in mind too, though I presumably haven't used the same names.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1571#issuecomment-859917462
https://github.com/qutip/qutip/issues/1571#issuecomment-859917462:1154,Usability,simpl,simply,1154,"I also note that I'm not replying to the thread I thought I was - I thought I was in `krotov`! For my response to the discussion points:; - I think the function `qutip.mesolve` shouldn't change interface at all for 5.0 - we can change its backend, but I think it'll be a huge hindrance to adoption of 5.0 if we make major breaking changes to effectively our premier function, and I don't see a need to do that. We can add, rather than change, and keep `mesolve` as the ""quick-and-dirty"" method that just works.; - I'm in favour of exposing the different parts of the `mesolve` process as user-accessible, composable chunks. So something like exposing a `mesolve_prepare_ode(H, state, c_ops) -> OdeState` function, where `OdeState` has properties `rhs: QobjEvo`, `state: Qobj`, `time: float` (`sesolve_prepare_ode` and `mcsolve_prepare_ode` would presumably return the same object, or a derived object). Then we'd have an `Integrator` class, which encapsulates an integration step using whatever integrator of choice, so there's one that encapsulates the scipy integrator, one which is a Cython-ised RK4 implementation, etc. Then the low-level user would simply write the `for time in times` loop themselves; at this level, there's nothing fancy that QuTiP adds, so we may as well just expose it directly. I think this architecture is approximately what Eric had in mind too, though I presumably haven't used the same names.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1571#issuecomment-859917462
https://github.com/qutip/qutip/issues/1571#issuecomment-860254243:6209,Availability,down,down,6209,"itten it, this loop is thread-safe already. As it stands in the 4.x series, `mesolve` is re-entrant (I'm fairly sure), but note that it does generally mutate its arguments, especially if you pass a `QobjEvo` Liouvillian as the first argument. As long as you make sure you give each thread a distinct copy of the input Liouvillian, `mesolve` itself doesn't access global state as far as I recall. Just to be clear: there's two interconnected issues here: One is just being ""reentrant"" in the sense that I can safely have multiple `mesolve`'s run in parallel. This doesn't seem to be a problem for `mesolve` as a whole (propagating over the entire time grid). The other issue, at a lower level is whether I can keep the internal state of the integrator (`scipy.integrate.ode` or whatever else `mesolve` might be using) when propagating a single time step (and whether I can have multiple integrators to run in parallel that each safely keep track of their own state). That comes down to the integrator itself being ""reentrant"", of course. Certainly, calling `mesolve` in a loop (`In [19]`) doesn't keep the internal state of the integrator, hence the overhead between `In [21]` compared to `In [18]`. I wouldn't expect it to, of course, but the question is whether a refactoring of `mesolves` internals into an object that keeps state in a thread-safe way and allows doing time steps would alleviate this overhead (like the `mesolve_prepare_ode(H, state, c_ops) -> OdeState` that you propose in https://github.com/qutip/qutip/issues/1571#issuecomment-859917462). On the other hand, looping over the full `mesolve` as in `In [19]` obviously has no problems with parallelization. I wasn't sure if that's what you meant by ""`mesolve` is re-entrant"" or whether recent changes in QuTiP now use a re-entrant internal integrator, i.e. not `scipy.integrate.ode`. At the time I implemented the [`DensityMatrixODEPropagator`](https://github.com/qucontrol/krotov/blob/cfe6b108708cdfd29ab7eee24f2112977b951ed2/src/k",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1571#issuecomment-860254243
https://github.com/qutip/qutip/issues/1571#issuecomment-860254243:962,Deployability,integrat,integrator,962,"Ok, so I did some benchmarking at https://nbviewer.ipython.org/gist/goerz/34af142b78d7e344417d838bbea78aaf/06_example_3states_benchmark.ipynb ([gist](https://gist.github.com/goerz/34af142b78d7e344417d838bbea78aaf)), based on [one of the example notebooks from the Krotov package](https://qucontrol.github.io/krotov/v1.2.1/notebooks/06_example_3states.html). I'll be referring to the numbered cells in that notebook in the discussion below. @jakelishman in https://github.com/qutip/qutip/issues/1571#issuecomment-859873615:. > I think you might be able to achieve a lot of what you want already. The pseudo-code looks like it's not using `mesolve` super efficiently, though maybe it's only because of simplifications to make a MWE. For example, if your controls are piecewise constant, then it might be inefficient to represent those terms as ""time dependent""; doing so means you incur the cost of multiplying each term by a scalar at every intermediate step the integrator chooses to take, then you have to perform the matrix-vector product for each one individually and add them up. That's certainly worth trying: when calling `mesolve` in a loop over the time grid, I did indeed see a significant speedup when summing the Lindbladian into a single constant `Qobj`, see `In [21]` vs `In [24]`. On the other hand, it doesn't always give a speedup: in the low-level [`DensityMatrixODEPropagator`](https://github.com/qucontrol/krotov/blob/cfe6b108708cdfd29ab7eee24f2112977b951ed2/src/krotov/propagators.py#L162) it actually makes the propagation slower, see `In [29]` vs `In [32]`. It's a bit surprising, but then, as you say:. > [...] This isn't guaranteed, because it involves copying rather more data _before_ the call. So that's ok. > Would something like this work for you? [...]; >; > By giving `mesolve` the Liouvillian instead of the Hamiltonian and collapse operators separately. To be clear, I personally never use collapse operators (and the Krotov documentation heavily discourages it). Inst",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1571#issuecomment-860254243
https://github.com/qutip/qutip/issues/1571#issuecomment-860254243:3461,Deployability,update,update,3461,"I am ultimately interested both in open system and closed system dynamics interchangeably. > [...] In the 5.x series, almost all the intermediary operations should get a speed up as well (`Qobj.__init__` is getting its time slashed, and the line `current_liouvillian += control * operator` may be able to be replaced with one that applies the same in-place calculation optimisations that `mesolve` does internally). One thing you pay a nasty penalty for right now if that internally we'd keep column-stacking/unstacking the state, but in the 5.x branch it'll stop being represented internally by a sparse matrix, and instead it'll be a Fortran-ordered dense matrix, for which the stack/unstack is a free operation. That's an extremely exciting prospect! I'd love to be able to have internal sparse data for Qobj's that represent Hamiltonians/Liouvillians, but dense data for Qobj's that represent Hilbert space states or Density matrices. In fact, it looks like a significant part of the overhead in the [calculation of the Krotov's pulse update](https://github.com/qucontrol/krotov/blob/cfe6b108708cdfd29ab7eee24f2112977b951ed2/src/krotov/optimize.py#L466) is due to the stacking/unstacking, see [`profile.svg`](https://gist.githubusercontent.com/goerz/34af142b78d7e344417d838bbea78aaf/raw/f3f49104083d59b9612f153d2f0ff652ea6a9f01/profile.svg) in the [gist](https://gist.github.com/goerz/34af142b78d7e344417d838bbea78aaf#file-profile-svg). In the benchmarking notebook, for the optimization in `In [34]`, that's the extra 6 seconds per iteration (iterations 1-3 should ideally take exactly twice as long as iteration 0, as iteration 0 is a simple forward propagation and all later iterations are one forward and one backward propagations). That's what we have in our Fortran implementation, too: the runtime of the optimization is basically just the runtime of all the internal propagations; calculating the updates should be completely negligible. There's also [shape conversions](https://github.co",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1571#issuecomment-860254243
https://github.com/qutip/qutip/issues/1571#issuecomment-860254243:4331,Deployability,update,updates,4331,"ouvillians, but dense data for Qobj's that represent Hilbert space states or Density matrices. In fact, it looks like a significant part of the overhead in the [calculation of the Krotov's pulse update](https://github.com/qucontrol/krotov/blob/cfe6b108708cdfd29ab7eee24f2112977b951ed2/src/krotov/optimize.py#L466) is due to the stacking/unstacking, see [`profile.svg`](https://gist.githubusercontent.com/goerz/34af142b78d7e344417d838bbea78aaf/raw/f3f49104083d59b9612f153d2f0ff652ea6a9f01/profile.svg) in the [gist](https://gist.github.com/goerz/34af142b78d7e344417d838bbea78aaf#file-profile-svg). In the benchmarking notebook, for the optimization in `In [34]`, that's the extra 6 seconds per iteration (iterations 1-3 should ideally take exactly twice as long as iteration 0, as iteration 0 is a simple forward propagation and all later iterations are one forward and one backward propagations). That's what we have in our Fortran implementation, too: the runtime of the optimization is basically just the runtime of all the internal propagations; calculating the updates should be completely negligible. There's also [shape conversions](https://github.com/qucontrol/krotov/blob/cfe6b108708cdfd29ab7eee24f2112977b951ed2/src/krotov/propagators.py#L254-L260) happening in [`DensityMatrixODEPropagator`](https://github.com/qucontrol/krotov/blob/cfe6b108708cdfd29ab7eee24f2112977b951ed2/src/krotov/propagators.py#L162) which would be nice to eliminate. Lastly, having dense internal storage for states might actually give the same speedup as we've demonstrated in https://qucontrol.github.io/krotov/v1.2.1/notebooks/09_example_numpy.html for doing Krotov with numpy arrays instead of Qobj's -- potentially even more speedup, in fact, since with numpy now *everything* is dense (including the Hamiltonian), whereas the best thing to do numerically would be to do sparse-matrix-dense-vector operations (which is what we do in Fortran, incidentally). > In the form I've written it, this loop is thread-safe ",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1571#issuecomment-860254243
https://github.com/qutip/qutip/issues/1571#issuecomment-860254243:5972,Deployability,integrat,integrator,5972,"ead of Qobj's -- potentially even more speedup, in fact, since with numpy now *everything* is dense (including the Hamiltonian), whereas the best thing to do numerically would be to do sparse-matrix-dense-vector operations (which is what we do in Fortran, incidentally). > In the form I've written it, this loop is thread-safe already. As it stands in the 4.x series, `mesolve` is re-entrant (I'm fairly sure), but note that it does generally mutate its arguments, especially if you pass a `QobjEvo` Liouvillian as the first argument. As long as you make sure you give each thread a distinct copy of the input Liouvillian, `mesolve` itself doesn't access global state as far as I recall. Just to be clear: there's two interconnected issues here: One is just being ""reentrant"" in the sense that I can safely have multiple `mesolve`'s run in parallel. This doesn't seem to be a problem for `mesolve` as a whole (propagating over the entire time grid). The other issue, at a lower level is whether I can keep the internal state of the integrator (`scipy.integrate.ode` or whatever else `mesolve` might be using) when propagating a single time step (and whether I can have multiple integrators to run in parallel that each safely keep track of their own state). That comes down to the integrator itself being ""reentrant"", of course. Certainly, calling `mesolve` in a loop (`In [19]`) doesn't keep the internal state of the integrator, hence the overhead between `In [21]` compared to `In [18]`. I wouldn't expect it to, of course, but the question is whether a refactoring of `mesolves` internals into an object that keeps state in a thread-safe way and allows doing time steps would alleviate this overhead (like the `mesolve_prepare_ode(H, state, c_ops) -> OdeState` that you propose in https://github.com/qutip/qutip/issues/1571#issuecomment-859917462). On the other hand, looping over the full `mesolve` as in `In [19]` obviously has no problems with parallelization. I wasn't sure if that's what you",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1571#issuecomment-860254243
https://github.com/qutip/qutip/issues/1571#issuecomment-860254243:5991,Deployability,integrat,integrate,5991," since with numpy now *everything* is dense (including the Hamiltonian), whereas the best thing to do numerically would be to do sparse-matrix-dense-vector operations (which is what we do in Fortran, incidentally). > In the form I've written it, this loop is thread-safe already. As it stands in the 4.x series, `mesolve` is re-entrant (I'm fairly sure), but note that it does generally mutate its arguments, especially if you pass a `QobjEvo` Liouvillian as the first argument. As long as you make sure you give each thread a distinct copy of the input Liouvillian, `mesolve` itself doesn't access global state as far as I recall. Just to be clear: there's two interconnected issues here: One is just being ""reentrant"" in the sense that I can safely have multiple `mesolve`'s run in parallel. This doesn't seem to be a problem for `mesolve` as a whole (propagating over the entire time grid). The other issue, at a lower level is whether I can keep the internal state of the integrator (`scipy.integrate.ode` or whatever else `mesolve` might be using) when propagating a single time step (and whether I can have multiple integrators to run in parallel that each safely keep track of their own state). That comes down to the integrator itself being ""reentrant"", of course. Certainly, calling `mesolve` in a loop (`In [19]`) doesn't keep the internal state of the integrator, hence the overhead between `In [21]` compared to `In [18]`. I wouldn't expect it to, of course, but the question is whether a refactoring of `mesolves` internals into an object that keeps state in a thread-safe way and allows doing time steps would alleviate this overhead (like the `mesolve_prepare_ode(H, state, c_ops) -> OdeState` that you propose in https://github.com/qutip/qutip/issues/1571#issuecomment-859917462). On the other hand, looping over the full `mesolve` as in `In [19]` obviously has no problems with parallelization. I wasn't sure if that's what you meant by ""`mesolve` is re-entrant"" or whether recent ch",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1571#issuecomment-860254243
https://github.com/qutip/qutip/issues/1571#issuecomment-860254243:6118,Deployability,integrat,integrators,6118,"umerically would be to do sparse-matrix-dense-vector operations (which is what we do in Fortran, incidentally). > In the form I've written it, this loop is thread-safe already. As it stands in the 4.x series, `mesolve` is re-entrant (I'm fairly sure), but note that it does generally mutate its arguments, especially if you pass a `QobjEvo` Liouvillian as the first argument. As long as you make sure you give each thread a distinct copy of the input Liouvillian, `mesolve` itself doesn't access global state as far as I recall. Just to be clear: there's two interconnected issues here: One is just being ""reentrant"" in the sense that I can safely have multiple `mesolve`'s run in parallel. This doesn't seem to be a problem for `mesolve` as a whole (propagating over the entire time grid). The other issue, at a lower level is whether I can keep the internal state of the integrator (`scipy.integrate.ode` or whatever else `mesolve` might be using) when propagating a single time step (and whether I can have multiple integrators to run in parallel that each safely keep track of their own state). That comes down to the integrator itself being ""reentrant"", of course. Certainly, calling `mesolve` in a loop (`In [19]`) doesn't keep the internal state of the integrator, hence the overhead between `In [21]` compared to `In [18]`. I wouldn't expect it to, of course, but the question is whether a refactoring of `mesolves` internals into an object that keeps state in a thread-safe way and allows doing time steps would alleviate this overhead (like the `mesolve_prepare_ode(H, state, c_ops) -> OdeState` that you propose in https://github.com/qutip/qutip/issues/1571#issuecomment-859917462). On the other hand, looping over the full `mesolve` as in `In [19]` obviously has no problems with parallelization. I wasn't sure if that's what you meant by ""`mesolve` is re-entrant"" or whether recent changes in QuTiP now use a re-entrant internal integrator, i.e. not `scipy.integrate.ode`. At the time I ",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1571#issuecomment-860254243
https://github.com/qutip/qutip/issues/1571#issuecomment-860254243:6221,Deployability,integrat,integrator,6221,"itten it, this loop is thread-safe already. As it stands in the 4.x series, `mesolve` is re-entrant (I'm fairly sure), but note that it does generally mutate its arguments, especially if you pass a `QobjEvo` Liouvillian as the first argument. As long as you make sure you give each thread a distinct copy of the input Liouvillian, `mesolve` itself doesn't access global state as far as I recall. Just to be clear: there's two interconnected issues here: One is just being ""reentrant"" in the sense that I can safely have multiple `mesolve`'s run in parallel. This doesn't seem to be a problem for `mesolve` as a whole (propagating over the entire time grid). The other issue, at a lower level is whether I can keep the internal state of the integrator (`scipy.integrate.ode` or whatever else `mesolve` might be using) when propagating a single time step (and whether I can have multiple integrators to run in parallel that each safely keep track of their own state). That comes down to the integrator itself being ""reentrant"", of course. Certainly, calling `mesolve` in a loop (`In [19]`) doesn't keep the internal state of the integrator, hence the overhead between `In [21]` compared to `In [18]`. I wouldn't expect it to, of course, but the question is whether a refactoring of `mesolves` internals into an object that keeps state in a thread-safe way and allows doing time steps would alleviate this overhead (like the `mesolve_prepare_ode(H, state, c_ops) -> OdeState` that you propose in https://github.com/qutip/qutip/issues/1571#issuecomment-859917462). On the other hand, looping over the full `mesolve` as in `In [19]` obviously has no problems with parallelization. I wasn't sure if that's what you meant by ""`mesolve` is re-entrant"" or whether recent changes in QuTiP now use a re-entrant internal integrator, i.e. not `scipy.integrate.ode`. At the time I implemented the [`DensityMatrixODEPropagator`](https://github.com/qucontrol/krotov/blob/cfe6b108708cdfd29ab7eee24f2112977b951ed2/src/k",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1571#issuecomment-860254243
https://github.com/qutip/qutip/issues/1571#issuecomment-860254243:6359,Deployability,integrat,integrator,6359,", but note that it does generally mutate its arguments, especially if you pass a `QobjEvo` Liouvillian as the first argument. As long as you make sure you give each thread a distinct copy of the input Liouvillian, `mesolve` itself doesn't access global state as far as I recall. Just to be clear: there's two interconnected issues here: One is just being ""reentrant"" in the sense that I can safely have multiple `mesolve`'s run in parallel. This doesn't seem to be a problem for `mesolve` as a whole (propagating over the entire time grid). The other issue, at a lower level is whether I can keep the internal state of the integrator (`scipy.integrate.ode` or whatever else `mesolve` might be using) when propagating a single time step (and whether I can have multiple integrators to run in parallel that each safely keep track of their own state). That comes down to the integrator itself being ""reentrant"", of course. Certainly, calling `mesolve` in a loop (`In [19]`) doesn't keep the internal state of the integrator, hence the overhead between `In [21]` compared to `In [18]`. I wouldn't expect it to, of course, but the question is whether a refactoring of `mesolves` internals into an object that keeps state in a thread-safe way and allows doing time steps would alleviate this overhead (like the `mesolve_prepare_ode(H, state, c_ops) -> OdeState` that you propose in https://github.com/qutip/qutip/issues/1571#issuecomment-859917462). On the other hand, looping over the full `mesolve` as in `In [19]` obviously has no problems with parallelization. I wasn't sure if that's what you meant by ""`mesolve` is re-entrant"" or whether recent changes in QuTiP now use a re-entrant internal integrator, i.e. not `scipy.integrate.ode`. At the time I implemented the [`DensityMatrixODEPropagator`](https://github.com/qucontrol/krotov/blob/cfe6b108708cdfd29ab7eee24f2112977b951ed2/src/krotov/propagators.py#L162) by looking at what `mesolve` was doing at a low level for the specific case of density ma",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1571#issuecomment-860254243
https://github.com/qutip/qutip/issues/1571#issuecomment-860254243:7041,Deployability,integrat,integrator,7041,"r (`scipy.integrate.ode` or whatever else `mesolve` might be using) when propagating a single time step (and whether I can have multiple integrators to run in parallel that each safely keep track of their own state). That comes down to the integrator itself being ""reentrant"", of course. Certainly, calling `mesolve` in a loop (`In [19]`) doesn't keep the internal state of the integrator, hence the overhead between `In [21]` compared to `In [18]`. I wouldn't expect it to, of course, but the question is whether a refactoring of `mesolves` internals into an object that keeps state in a thread-safe way and allows doing time steps would alleviate this overhead (like the `mesolve_prepare_ode(H, state, c_ops) -> OdeState` that you propose in https://github.com/qutip/qutip/issues/1571#issuecomment-859917462). On the other hand, looping over the full `mesolve` as in `In [19]` obviously has no problems with parallelization. I wasn't sure if that's what you meant by ""`mesolve` is re-entrant"" or whether recent changes in QuTiP now use a re-entrant internal integrator, i.e. not `scipy.integrate.ode`. At the time I implemented the [`DensityMatrixODEPropagator`](https://github.com/qucontrol/krotov/blob/cfe6b108708cdfd29ab7eee24f2112977b951ed2/src/krotov/propagators.py#L162) by looking at what `mesolve` was doing at a low level for the specific case of density matrices, `scipy.integrate.ode` was definitely being used, and that couldn't handle propagating in parallel (and by ""parallel"" I include alternating propagation steps from two different propagations). I'm also not sure what using `QobjEvo` does: In the benchmarking, there didn't seem to be any difference whether I wrap my nested lists into `QobjEvo` or not. Is there something specific that `QobjEvo` should enable that I can't do with nested lists?. > QuTiP 5 is (probably) going to formalise that (^) sort of low-level calling convention of `mesolve`, but it should work already. The new one look a bit different because instead o",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1571#issuecomment-860254243
https://github.com/qutip/qutip/issues/1571#issuecomment-860254243:7069,Deployability,integrat,integrate,7069," time step (and whether I can have multiple integrators to run in parallel that each safely keep track of their own state). That comes down to the integrator itself being ""reentrant"", of course. Certainly, calling `mesolve` in a loop (`In [19]`) doesn't keep the internal state of the integrator, hence the overhead between `In [21]` compared to `In [18]`. I wouldn't expect it to, of course, but the question is whether a refactoring of `mesolves` internals into an object that keeps state in a thread-safe way and allows doing time steps would alleviate this overhead (like the `mesolve_prepare_ode(H, state, c_ops) -> OdeState` that you propose in https://github.com/qutip/qutip/issues/1571#issuecomment-859917462). On the other hand, looping over the full `mesolve` as in `In [19]` obviously has no problems with parallelization. I wasn't sure if that's what you meant by ""`mesolve` is re-entrant"" or whether recent changes in QuTiP now use a re-entrant internal integrator, i.e. not `scipy.integrate.ode`. At the time I implemented the [`DensityMatrixODEPropagator`](https://github.com/qucontrol/krotov/blob/cfe6b108708cdfd29ab7eee24f2112977b951ed2/src/krotov/propagators.py#L162) by looking at what `mesolve` was doing at a low level for the specific case of density matrices, `scipy.integrate.ode` was definitely being used, and that couldn't handle propagating in parallel (and by ""parallel"" I include alternating propagation steps from two different propagations). I'm also not sure what using `QobjEvo` does: In the benchmarking, there didn't seem to be any difference whether I wrap my nested lists into `QobjEvo` or not. Is there something specific that `QobjEvo` should enable that I can't do with nested lists?. > QuTiP 5 is (probably) going to formalise that (^) sort of low-level calling convention of `mesolve`, but it should work already. The new one look a bit different because instead of doing the setup very manually, there'll be a ""low-level"" function to prepare a master equat",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1571#issuecomment-860254243
https://github.com/qutip/qutip/issues/1571#issuecomment-860254243:7364,Deployability,integrat,integrate,7364,", hence the overhead between `In [21]` compared to `In [18]`. I wouldn't expect it to, of course, but the question is whether a refactoring of `mesolves` internals into an object that keeps state in a thread-safe way and allows doing time steps would alleviate this overhead (like the `mesolve_prepare_ode(H, state, c_ops) -> OdeState` that you propose in https://github.com/qutip/qutip/issues/1571#issuecomment-859917462). On the other hand, looping over the full `mesolve` as in `In [19]` obviously has no problems with parallelization. I wasn't sure if that's what you meant by ""`mesolve` is re-entrant"" or whether recent changes in QuTiP now use a re-entrant internal integrator, i.e. not `scipy.integrate.ode`. At the time I implemented the [`DensityMatrixODEPropagator`](https://github.com/qucontrol/krotov/blob/cfe6b108708cdfd29ab7eee24f2112977b951ed2/src/krotov/propagators.py#L162) by looking at what `mesolve` was doing at a low level for the specific case of density matrices, `scipy.integrate.ode` was definitely being used, and that couldn't handle propagating in parallel (and by ""parallel"" I include alternating propagation steps from two different propagations). I'm also not sure what using `QobjEvo` does: In the benchmarking, there didn't seem to be any difference whether I wrap my nested lists into `QobjEvo` or not. Is there something specific that `QobjEvo` should enable that I can't do with nested lists?. > QuTiP 5 is (probably) going to formalise that (^) sort of low-level calling convention of `mesolve`, but it should work already. The new one look a bit different because instead of doing the setup very manually, there'll be a ""low-level"" function to prepare a master equation problem (and a Schrodinger equation one, etc), and then there'll be a `step` method instead of calling the ""high-level"" interface function `mesolve`, but functionally it'll do largely the same, just with a lot less data copying than the current form has to do. In the new system, it's likely",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1571#issuecomment-860254243
https://github.com/qutip/qutip/issues/1571#issuecomment-860254243:9133,Deployability,integrat,integrate,9133,"e'll be a `step` method instead of calling the ""high-level"" interface function `mesolve`, but functionally it'll do largely the same, just with a lot less data copying than the current form has to do. In the new system, it's likely that the function `mesolve` itself will keep the exact same interface it has now, just internally most of its processing will be split into modular components, each of which will be accessible (with different names) to the user to compose themselves, if they want low-level access. That sounds perfect! I might wait for QuTiP 5 to come out, or if these things are already in `master`, I'll see if I can maybe revisit `DensityMatrixODEPropagator` and maybe also add something for the Hilbert space case (whatever `sesolve` is doing internally). As an aside, I was actually surprised how much better `DensityMatrixODEPropagator` performs compared to looping over `mesolve` (`In [29]` vs `In [21]`): Since the `DensityMatrixODEPropagator` also re-initializes `scipy.integrate.ode` in every time steps, it would seem like the only difference between the two is the overhead of `mesolve` deciding that it has to handle the specific case of density matrix propagation. That might be something to keep an eye on in future QuTiP development: Ideally, calling `mesolve` would have negligible overhead compared to manually doing whatever `mesolve` does internally for a particular case. > We're unlikely to add `yield` to `mesolve` directly because that's a very breaking change to one of QuTiP's core functions (we can't return from a generator, or at least not ergonomically), but we are splitting up the `mesolve` monolith into a much more modular architecture, and making it more user-accessible. The other advantage of this is that the integrator component will just be one element of a composable system, so we'll not be tied to scipy integrators any more. I would absolutely not expect you to modifying how `mesolve` works directly. In fact, I would strongly recommend le",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1571#issuecomment-860254243
https://github.com/qutip/qutip/issues/1571#issuecomment-860254243:9901,Deployability,integrat,integrator,9901," surprised how much better `DensityMatrixODEPropagator` performs compared to looping over `mesolve` (`In [29]` vs `In [21]`): Since the `DensityMatrixODEPropagator` also re-initializes `scipy.integrate.ode` in every time steps, it would seem like the only difference between the two is the overhead of `mesolve` deciding that it has to handle the specific case of density matrix propagation. That might be something to keep an eye on in future QuTiP development: Ideally, calling `mesolve` would have negligible overhead compared to manually doing whatever `mesolve` does internally for a particular case. > We're unlikely to add `yield` to `mesolve` directly because that's a very breaking change to one of QuTiP's core functions (we can't return from a generator, or at least not ergonomically), but we are splitting up the `mesolve` monolith into a much more modular architecture, and making it more user-accessible. The other advantage of this is that the integrator component will just be one element of a composable system, so we'll not be tied to scipy integrators any more. I would absolutely not expect you to modifying how `mesolve` works directly. In fact, I would strongly recommend leaving the `mesolve` interface unchanged. The internal refactoring is all I'm after here. @jakelishman in https://github.com/qutip/qutip/issues/1571#issuecomment-859917462:. > I also note that I'm not replying to the thread I thought I was - I thought I was in `krotov`! For my response to the discussion points:. Yeah, sorry the discussion got a little confused between what I was suggesting in https://github.com/qucontrol/krotov/issues/93 for myself to try out (adding a `yield` to `mesolve` as a dirty hack) and the discussion here about how to address the underlying use case properly in QuTiP itself. So just to be clear: Do *not* add a `yield` to the existing `mesolve` function in QuTiP! I would strongly recommend keeping the existing interface for `mesolve` and just refactor what is going on i",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1571#issuecomment-860254243
https://github.com/qutip/qutip/issues/1571#issuecomment-860254243:10001,Deployability,integrat,integrators,10001," surprised how much better `DensityMatrixODEPropagator` performs compared to looping over `mesolve` (`In [29]` vs `In [21]`): Since the `DensityMatrixODEPropagator` also re-initializes `scipy.integrate.ode` in every time steps, it would seem like the only difference between the two is the overhead of `mesolve` deciding that it has to handle the specific case of density matrix propagation. That might be something to keep an eye on in future QuTiP development: Ideally, calling `mesolve` would have negligible overhead compared to manually doing whatever `mesolve` does internally for a particular case. > We're unlikely to add `yield` to `mesolve` directly because that's a very breaking change to one of QuTiP's core functions (we can't return from a generator, or at least not ergonomically), but we are splitting up the `mesolve` monolith into a much more modular architecture, and making it more user-accessible. The other advantage of this is that the integrator component will just be one element of a composable system, so we'll not be tied to scipy integrators any more. I would absolutely not expect you to modifying how `mesolve` works directly. In fact, I would strongly recommend leaving the `mesolve` interface unchanged. The internal refactoring is all I'm after here. @jakelishman in https://github.com/qutip/qutip/issues/1571#issuecomment-859917462:. > I also note that I'm not replying to the thread I thought I was - I thought I was in `krotov`! For my response to the discussion points:. Yeah, sorry the discussion got a little confused between what I was suggesting in https://github.com/qucontrol/krotov/issues/93 for myself to try out (adding a `yield` to `mesolve` as a dirty hack) and the discussion here about how to address the underlying use case properly in QuTiP itself. So just to be clear: Do *not* add a `yield` to the existing `mesolve` function in QuTiP! I would strongly recommend keeping the existing interface for `mesolve` and just refactor what is going on i",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1571#issuecomment-860254243
https://github.com/qutip/qutip/issues/1571#issuecomment-860254243:11819,Deployability,Integrat,Integrator,11819,"just refactor what is going on in the backend to enable single-time-step propagation with as little overhead as possible. > * I think the function `qutip.mesolve` shouldn't change interface at all for 5.0 - we can change its backend, but I think it'll be a huge hindrance to adoption of 5.0 if we make major breaking changes to effectively our premier function, and I don't see a need to do that. We can add, rather than change, and keep `mesolve` as the ""quick-and-dirty"" method that just works.; > * I'm in favour of exposing the different parts of the `mesolve` process as user-accessible, composable chunks. So something like exposing a `mesolve_prepare_ode(H, state, c_ops) -> OdeState` function, where `OdeState` has properties `rhs: QobjEvo`, `state: Qobj`, `time: float` (`sesolve_prepare_ode` and `mcsolve_prepare_ode` would presumably return the same object, or a derived object). Then we'd have an `Integrator` class, which encapsulates an integration step using whatever integrator of choice, so there's one that encapsulates the scipy integrator, one which is a Cython-ised RK4 implementation, etc. Then the low-level user would simply write the `for time in times` loop themselves; at this level, there's nothing fancy that QuTiP adds, so we may as well just expose it directly. That sounds like the exact right solution! ;-). > I think this architecture is approximately what Eric had in mind too, though I presumably haven't used the same names. Yeah, I think we're actually all on the same page, irrespective of minor implementation/naming details: Have an object that keeps internal state of `mesolve` and allows to advance step-by-step. Personally, I like the naming of `MeSolver` that @Ericgig wrote out in https://github.com/qutip/qutip/issues/1571#issuecomment-858740451, but `mesolve_prepare_ode`/`OdeState` works too. @Ericgig in https://github.com/qutip/qutip/issues/1571#issuecomment-859791561:. > Most of scipy's solver are not ""thread-safe"", but we will be able to use othe",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1571#issuecomment-860254243
https://github.com/qutip/qutip/issues/1571#issuecomment-860254243:11860,Deployability,integrat,integration,11860,"just refactor what is going on in the backend to enable single-time-step propagation with as little overhead as possible. > * I think the function `qutip.mesolve` shouldn't change interface at all for 5.0 - we can change its backend, but I think it'll be a huge hindrance to adoption of 5.0 if we make major breaking changes to effectively our premier function, and I don't see a need to do that. We can add, rather than change, and keep `mesolve` as the ""quick-and-dirty"" method that just works.; > * I'm in favour of exposing the different parts of the `mesolve` process as user-accessible, composable chunks. So something like exposing a `mesolve_prepare_ode(H, state, c_ops) -> OdeState` function, where `OdeState` has properties `rhs: QobjEvo`, `state: Qobj`, `time: float` (`sesolve_prepare_ode` and `mcsolve_prepare_ode` would presumably return the same object, or a derived object). Then we'd have an `Integrator` class, which encapsulates an integration step using whatever integrator of choice, so there's one that encapsulates the scipy integrator, one which is a Cython-ised RK4 implementation, etc. Then the low-level user would simply write the `for time in times` loop themselves; at this level, there's nothing fancy that QuTiP adds, so we may as well just expose it directly. That sounds like the exact right solution! ;-). > I think this architecture is approximately what Eric had in mind too, though I presumably haven't used the same names. Yeah, I think we're actually all on the same page, irrespective of minor implementation/naming details: Have an object that keeps internal state of `mesolve` and allows to advance step-by-step. Personally, I like the naming of `MeSolver` that @Ericgig wrote out in https://github.com/qutip/qutip/issues/1571#issuecomment-858740451, but `mesolve_prepare_ode`/`OdeState` works too. @Ericgig in https://github.com/qutip/qutip/issues/1571#issuecomment-859791561:. > Most of scipy's solver are not ""thread-safe"", but we will be able to use othe",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1571#issuecomment-860254243
https://github.com/qutip/qutip/issues/1571#issuecomment-860254243:11892,Deployability,integrat,integrator,11892,"just refactor what is going on in the backend to enable single-time-step propagation with as little overhead as possible. > * I think the function `qutip.mesolve` shouldn't change interface at all for 5.0 - we can change its backend, but I think it'll be a huge hindrance to adoption of 5.0 if we make major breaking changes to effectively our premier function, and I don't see a need to do that. We can add, rather than change, and keep `mesolve` as the ""quick-and-dirty"" method that just works.; > * I'm in favour of exposing the different parts of the `mesolve` process as user-accessible, composable chunks. So something like exposing a `mesolve_prepare_ode(H, state, c_ops) -> OdeState` function, where `OdeState` has properties `rhs: QobjEvo`, `state: Qobj`, `time: float` (`sesolve_prepare_ode` and `mcsolve_prepare_ode` would presumably return the same object, or a derived object). Then we'd have an `Integrator` class, which encapsulates an integration step using whatever integrator of choice, so there's one that encapsulates the scipy integrator, one which is a Cython-ised RK4 implementation, etc. Then the low-level user would simply write the `for time in times` loop themselves; at this level, there's nothing fancy that QuTiP adds, so we may as well just expose it directly. That sounds like the exact right solution! ;-). > I think this architecture is approximately what Eric had in mind too, though I presumably haven't used the same names. Yeah, I think we're actually all on the same page, irrespective of minor implementation/naming details: Have an object that keeps internal state of `mesolve` and allows to advance step-by-step. Personally, I like the naming of `MeSolver` that @Ericgig wrote out in https://github.com/qutip/qutip/issues/1571#issuecomment-858740451, but `mesolve_prepare_ode`/`OdeState` works too. @Ericgig in https://github.com/qutip/qutip/issues/1571#issuecomment-859791561:. > Most of scipy's solver are not ""thread-safe"", but we will be able to use othe",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1571#issuecomment-860254243
https://github.com/qutip/qutip/issues/1571#issuecomment-860254243:11957,Deployability,integrat,integrator,11957,"just refactor what is going on in the backend to enable single-time-step propagation with as little overhead as possible. > * I think the function `qutip.mesolve` shouldn't change interface at all for 5.0 - we can change its backend, but I think it'll be a huge hindrance to adoption of 5.0 if we make major breaking changes to effectively our premier function, and I don't see a need to do that. We can add, rather than change, and keep `mesolve` as the ""quick-and-dirty"" method that just works.; > * I'm in favour of exposing the different parts of the `mesolve` process as user-accessible, composable chunks. So something like exposing a `mesolve_prepare_ode(H, state, c_ops) -> OdeState` function, where `OdeState` has properties `rhs: QobjEvo`, `state: Qobj`, `time: float` (`sesolve_prepare_ode` and `mcsolve_prepare_ode` would presumably return the same object, or a derived object). Then we'd have an `Integrator` class, which encapsulates an integration step using whatever integrator of choice, so there's one that encapsulates the scipy integrator, one which is a Cython-ised RK4 implementation, etc. Then the low-level user would simply write the `for time in times` loop themselves; at this level, there's nothing fancy that QuTiP adds, so we may as well just expose it directly. That sounds like the exact right solution! ;-). > I think this architecture is approximately what Eric had in mind too, though I presumably haven't used the same names. Yeah, I think we're actually all on the same page, irrespective of minor implementation/naming details: Have an object that keeps internal state of `mesolve` and allows to advance step-by-step. Personally, I like the naming of `MeSolver` that @Ericgig wrote out in https://github.com/qutip/qutip/issues/1571#issuecomment-858740451, but `mesolve_prepare_ode`/`OdeState` works too. @Ericgig in https://github.com/qutip/qutip/issues/1571#issuecomment-859791561:. > Most of scipy's solver are not ""thread-safe"", but we will be able to use othe",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1571#issuecomment-860254243
https://github.com/qutip/qutip/issues/1571#issuecomment-860254243:13066,Deployability,integrat,integrate,13066,"te` has properties `rhs: QobjEvo`, `state: Qobj`, `time: float` (`sesolve_prepare_ode` and `mcsolve_prepare_ode` would presumably return the same object, or a derived object). Then we'd have an `Integrator` class, which encapsulates an integration step using whatever integrator of choice, so there's one that encapsulates the scipy integrator, one which is a Cython-ised RK4 implementation, etc. Then the low-level user would simply write the `for time in times` loop themselves; at this level, there's nothing fancy that QuTiP adds, so we may as well just expose it directly. That sounds like the exact right solution! ;-). > I think this architecture is approximately what Eric had in mind too, though I presumably haven't used the same names. Yeah, I think we're actually all on the same page, irrespective of minor implementation/naming details: Have an object that keeps internal state of `mesolve` and allows to advance step-by-step. Personally, I like the naming of `MeSolver` that @Ericgig wrote out in https://github.com/qutip/qutip/issues/1571#issuecomment-858740451, but `mesolve_prepare_ode`/`OdeState` works too. @Ericgig in https://github.com/qutip/qutip/issues/1571#issuecomment-859791561:. > Most of scipy's solver are not ""thread-safe"", but we will be able to use other solvers in the new version. If you can point me to any thread-safe solver, I'd love to try that out. As already discussed above, if I can replace [`scipy.integrate.ode`](https://github.com/qucontrol/krotov/blob/cfe6b108708cdfd29ab7eee24f2112977b951ed2/src/krotov/propagators.py#L312) in Krotov's [`DensityMatrixODEPropagator`](https://github.com/qucontrol/krotov/blob/cfe6b108708cdfd29ab7eee24f2112977b951ed2/src/krotov/propagators.py#L162) with something that's reentrant so I don't have to [re-initialize the integrator in every time step](https://github.com/qucontrol/krotov/blob/cfe6b108708cdfd29ab7eee24f2112977b951ed2/src/krotov/propagators.py#L244) , that might be a significant performance boost already.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1571#issuecomment-860254243
https://github.com/qutip/qutip/issues/1571#issuecomment-860254243:13423,Deployability,integrat,integrator,13423,"te` has properties `rhs: QobjEvo`, `state: Qobj`, `time: float` (`sesolve_prepare_ode` and `mcsolve_prepare_ode` would presumably return the same object, or a derived object). Then we'd have an `Integrator` class, which encapsulates an integration step using whatever integrator of choice, so there's one that encapsulates the scipy integrator, one which is a Cython-ised RK4 implementation, etc. Then the low-level user would simply write the `for time in times` loop themselves; at this level, there's nothing fancy that QuTiP adds, so we may as well just expose it directly. That sounds like the exact right solution! ;-). > I think this architecture is approximately what Eric had in mind too, though I presumably haven't used the same names. Yeah, I think we're actually all on the same page, irrespective of minor implementation/naming details: Have an object that keeps internal state of `mesolve` and allows to advance step-by-step. Personally, I like the naming of `MeSolver` that @Ericgig wrote out in https://github.com/qutip/qutip/issues/1571#issuecomment-858740451, but `mesolve_prepare_ode`/`OdeState` works too. @Ericgig in https://github.com/qutip/qutip/issues/1571#issuecomment-859791561:. > Most of scipy's solver are not ""thread-safe"", but we will be able to use other solvers in the new version. If you can point me to any thread-safe solver, I'd love to try that out. As already discussed above, if I can replace [`scipy.integrate.ode`](https://github.com/qucontrol/krotov/blob/cfe6b108708cdfd29ab7eee24f2112977b951ed2/src/krotov/propagators.py#L312) in Krotov's [`DensityMatrixODEPropagator`](https://github.com/qucontrol/krotov/blob/cfe6b108708cdfd29ab7eee24f2112977b951ed2/src/krotov/propagators.py#L162) with something that's reentrant so I don't have to [re-initialize the integrator in every time step](https://github.com/qucontrol/krotov/blob/cfe6b108708cdfd29ab7eee24f2112977b951ed2/src/krotov/propagators.py#L244) , that might be a significant performance boost already.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1571#issuecomment-860254243
https://github.com/qutip/qutip/issues/1571#issuecomment-860254243:653,Energy Efficiency,efficient,efficiently,653,"Ok, so I did some benchmarking at https://nbviewer.ipython.org/gist/goerz/34af142b78d7e344417d838bbea78aaf/06_example_3states_benchmark.ipynb ([gist](https://gist.github.com/goerz/34af142b78d7e344417d838bbea78aaf)), based on [one of the example notebooks from the Krotov package](https://qucontrol.github.io/krotov/v1.2.1/notebooks/06_example_3states.html). I'll be referring to the numbered cells in that notebook in the discussion below. @jakelishman in https://github.com/qutip/qutip/issues/1571#issuecomment-859873615:. > I think you might be able to achieve a lot of what you want already. The pseudo-code looks like it's not using `mesolve` super efficiently, though maybe it's only because of simplifications to make a MWE. For example, if your controls are piecewise constant, then it might be inefficient to represent those terms as ""time dependent""; doing so means you incur the cost of multiplying each term by a scalar at every intermediate step the integrator chooses to take, then you have to perform the matrix-vector product for each one individually and add them up. That's certainly worth trying: when calling `mesolve` in a loop over the time grid, I did indeed see a significant speedup when summing the Lindbladian into a single constant `Qobj`, see `In [21]` vs `In [24]`. On the other hand, it doesn't always give a speedup: in the low-level [`DensityMatrixODEPropagator`](https://github.com/qucontrol/krotov/blob/cfe6b108708cdfd29ab7eee24f2112977b951ed2/src/krotov/propagators.py#L162) it actually makes the propagation slower, see `In [29]` vs `In [32]`. It's a bit surprising, but then, as you say:. > [...] This isn't guaranteed, because it involves copying rather more data _before_ the call. So that's ok. > Would something like this work for you? [...]; >; > By giving `mesolve` the Liouvillian instead of the Hamiltonian and collapse operators separately. To be clear, I personally never use collapse operators (and the Krotov documentation heavily discourages it). Inst",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1571#issuecomment-860254243
https://github.com/qutip/qutip/issues/1571#issuecomment-860254243:848,Integrability,depend,dependent,848,"Ok, so I did some benchmarking at https://nbviewer.ipython.org/gist/goerz/34af142b78d7e344417d838bbea78aaf/06_example_3states_benchmark.ipynb ([gist](https://gist.github.com/goerz/34af142b78d7e344417d838bbea78aaf)), based on [one of the example notebooks from the Krotov package](https://qucontrol.github.io/krotov/v1.2.1/notebooks/06_example_3states.html). I'll be referring to the numbered cells in that notebook in the discussion below. @jakelishman in https://github.com/qutip/qutip/issues/1571#issuecomment-859873615:. > I think you might be able to achieve a lot of what you want already. The pseudo-code looks like it's not using `mesolve` super efficiently, though maybe it's only because of simplifications to make a MWE. For example, if your controls are piecewise constant, then it might be inefficient to represent those terms as ""time dependent""; doing so means you incur the cost of multiplying each term by a scalar at every intermediate step the integrator chooses to take, then you have to perform the matrix-vector product for each one individually and add them up. That's certainly worth trying: when calling `mesolve` in a loop over the time grid, I did indeed see a significant speedup when summing the Lindbladian into a single constant `Qobj`, see `In [21]` vs `In [24]`. On the other hand, it doesn't always give a speedup: in the low-level [`DensityMatrixODEPropagator`](https://github.com/qucontrol/krotov/blob/cfe6b108708cdfd29ab7eee24f2112977b951ed2/src/krotov/propagators.py#L162) it actually makes the propagation slower, see `In [29]` vs `In [32]`. It's a bit surprising, but then, as you say:. > [...] This isn't guaranteed, because it involves copying rather more data _before_ the call. So that's ok. > Would something like this work for you? [...]; >; > By giving `mesolve` the Liouvillian instead of the Hamiltonian and collapse operators separately. To be clear, I personally never use collapse operators (and the Krotov documentation heavily discourages it). Inst",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1571#issuecomment-860254243
https://github.com/qutip/qutip/issues/1571#issuecomment-860254243:962,Integrability,integrat,integrator,962,"Ok, so I did some benchmarking at https://nbviewer.ipython.org/gist/goerz/34af142b78d7e344417d838bbea78aaf/06_example_3states_benchmark.ipynb ([gist](https://gist.github.com/goerz/34af142b78d7e344417d838bbea78aaf)), based on [one of the example notebooks from the Krotov package](https://qucontrol.github.io/krotov/v1.2.1/notebooks/06_example_3states.html). I'll be referring to the numbered cells in that notebook in the discussion below. @jakelishman in https://github.com/qutip/qutip/issues/1571#issuecomment-859873615:. > I think you might be able to achieve a lot of what you want already. The pseudo-code looks like it's not using `mesolve` super efficiently, though maybe it's only because of simplifications to make a MWE. For example, if your controls are piecewise constant, then it might be inefficient to represent those terms as ""time dependent""; doing so means you incur the cost of multiplying each term by a scalar at every intermediate step the integrator chooses to take, then you have to perform the matrix-vector product for each one individually and add them up. That's certainly worth trying: when calling `mesolve` in a loop over the time grid, I did indeed see a significant speedup when summing the Lindbladian into a single constant `Qobj`, see `In [21]` vs `In [24]`. On the other hand, it doesn't always give a speedup: in the low-level [`DensityMatrixODEPropagator`](https://github.com/qucontrol/krotov/blob/cfe6b108708cdfd29ab7eee24f2112977b951ed2/src/krotov/propagators.py#L162) it actually makes the propagation slower, see `In [29]` vs `In [32]`. It's a bit surprising, but then, as you say:. > [...] This isn't guaranteed, because it involves copying rather more data _before_ the call. So that's ok. > Would something like this work for you? [...]; >; > By giving `mesolve` the Liouvillian instead of the Hamiltonian and collapse operators separately. To be clear, I personally never use collapse operators (and the Krotov documentation heavily discourages it). Inst",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1571#issuecomment-860254243
https://github.com/qutip/qutip/issues/1571#issuecomment-860254243:5972,Integrability,integrat,integrator,5972,"ead of Qobj's -- potentially even more speedup, in fact, since with numpy now *everything* is dense (including the Hamiltonian), whereas the best thing to do numerically would be to do sparse-matrix-dense-vector operations (which is what we do in Fortran, incidentally). > In the form I've written it, this loop is thread-safe already. As it stands in the 4.x series, `mesolve` is re-entrant (I'm fairly sure), but note that it does generally mutate its arguments, especially if you pass a `QobjEvo` Liouvillian as the first argument. As long as you make sure you give each thread a distinct copy of the input Liouvillian, `mesolve` itself doesn't access global state as far as I recall. Just to be clear: there's two interconnected issues here: One is just being ""reentrant"" in the sense that I can safely have multiple `mesolve`'s run in parallel. This doesn't seem to be a problem for `mesolve` as a whole (propagating over the entire time grid). The other issue, at a lower level is whether I can keep the internal state of the integrator (`scipy.integrate.ode` or whatever else `mesolve` might be using) when propagating a single time step (and whether I can have multiple integrators to run in parallel that each safely keep track of their own state). That comes down to the integrator itself being ""reentrant"", of course. Certainly, calling `mesolve` in a loop (`In [19]`) doesn't keep the internal state of the integrator, hence the overhead between `In [21]` compared to `In [18]`. I wouldn't expect it to, of course, but the question is whether a refactoring of `mesolves` internals into an object that keeps state in a thread-safe way and allows doing time steps would alleviate this overhead (like the `mesolve_prepare_ode(H, state, c_ops) -> OdeState` that you propose in https://github.com/qutip/qutip/issues/1571#issuecomment-859917462). On the other hand, looping over the full `mesolve` as in `In [19]` obviously has no problems with parallelization. I wasn't sure if that's what you",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1571#issuecomment-860254243
https://github.com/qutip/qutip/issues/1571#issuecomment-860254243:5991,Integrability,integrat,integrate,5991," since with numpy now *everything* is dense (including the Hamiltonian), whereas the best thing to do numerically would be to do sparse-matrix-dense-vector operations (which is what we do in Fortran, incidentally). > In the form I've written it, this loop is thread-safe already. As it stands in the 4.x series, `mesolve` is re-entrant (I'm fairly sure), but note that it does generally mutate its arguments, especially if you pass a `QobjEvo` Liouvillian as the first argument. As long as you make sure you give each thread a distinct copy of the input Liouvillian, `mesolve` itself doesn't access global state as far as I recall. Just to be clear: there's two interconnected issues here: One is just being ""reentrant"" in the sense that I can safely have multiple `mesolve`'s run in parallel. This doesn't seem to be a problem for `mesolve` as a whole (propagating over the entire time grid). The other issue, at a lower level is whether I can keep the internal state of the integrator (`scipy.integrate.ode` or whatever else `mesolve` might be using) when propagating a single time step (and whether I can have multiple integrators to run in parallel that each safely keep track of their own state). That comes down to the integrator itself being ""reentrant"", of course. Certainly, calling `mesolve` in a loop (`In [19]`) doesn't keep the internal state of the integrator, hence the overhead between `In [21]` compared to `In [18]`. I wouldn't expect it to, of course, but the question is whether a refactoring of `mesolves` internals into an object that keeps state in a thread-safe way and allows doing time steps would alleviate this overhead (like the `mesolve_prepare_ode(H, state, c_ops) -> OdeState` that you propose in https://github.com/qutip/qutip/issues/1571#issuecomment-859917462). On the other hand, looping over the full `mesolve` as in `In [19]` obviously has no problems with parallelization. I wasn't sure if that's what you meant by ""`mesolve` is re-entrant"" or whether recent ch",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1571#issuecomment-860254243
https://github.com/qutip/qutip/issues/1571#issuecomment-860254243:6118,Integrability,integrat,integrators,6118,"umerically would be to do sparse-matrix-dense-vector operations (which is what we do in Fortran, incidentally). > In the form I've written it, this loop is thread-safe already. As it stands in the 4.x series, `mesolve` is re-entrant (I'm fairly sure), but note that it does generally mutate its arguments, especially if you pass a `QobjEvo` Liouvillian as the first argument. As long as you make sure you give each thread a distinct copy of the input Liouvillian, `mesolve` itself doesn't access global state as far as I recall. Just to be clear: there's two interconnected issues here: One is just being ""reentrant"" in the sense that I can safely have multiple `mesolve`'s run in parallel. This doesn't seem to be a problem for `mesolve` as a whole (propagating over the entire time grid). The other issue, at a lower level is whether I can keep the internal state of the integrator (`scipy.integrate.ode` or whatever else `mesolve` might be using) when propagating a single time step (and whether I can have multiple integrators to run in parallel that each safely keep track of their own state). That comes down to the integrator itself being ""reentrant"", of course. Certainly, calling `mesolve` in a loop (`In [19]`) doesn't keep the internal state of the integrator, hence the overhead between `In [21]` compared to `In [18]`. I wouldn't expect it to, of course, but the question is whether a refactoring of `mesolves` internals into an object that keeps state in a thread-safe way and allows doing time steps would alleviate this overhead (like the `mesolve_prepare_ode(H, state, c_ops) -> OdeState` that you propose in https://github.com/qutip/qutip/issues/1571#issuecomment-859917462). On the other hand, looping over the full `mesolve` as in `In [19]` obviously has no problems with parallelization. I wasn't sure if that's what you meant by ""`mesolve` is re-entrant"" or whether recent changes in QuTiP now use a re-entrant internal integrator, i.e. not `scipy.integrate.ode`. At the time I ",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1571#issuecomment-860254243
https://github.com/qutip/qutip/issues/1571#issuecomment-860254243:6221,Integrability,integrat,integrator,6221,"itten it, this loop is thread-safe already. As it stands in the 4.x series, `mesolve` is re-entrant (I'm fairly sure), but note that it does generally mutate its arguments, especially if you pass a `QobjEvo` Liouvillian as the first argument. As long as you make sure you give each thread a distinct copy of the input Liouvillian, `mesolve` itself doesn't access global state as far as I recall. Just to be clear: there's two interconnected issues here: One is just being ""reentrant"" in the sense that I can safely have multiple `mesolve`'s run in parallel. This doesn't seem to be a problem for `mesolve` as a whole (propagating over the entire time grid). The other issue, at a lower level is whether I can keep the internal state of the integrator (`scipy.integrate.ode` or whatever else `mesolve` might be using) when propagating a single time step (and whether I can have multiple integrators to run in parallel that each safely keep track of their own state). That comes down to the integrator itself being ""reentrant"", of course. Certainly, calling `mesolve` in a loop (`In [19]`) doesn't keep the internal state of the integrator, hence the overhead between `In [21]` compared to `In [18]`. I wouldn't expect it to, of course, but the question is whether a refactoring of `mesolves` internals into an object that keeps state in a thread-safe way and allows doing time steps would alleviate this overhead (like the `mesolve_prepare_ode(H, state, c_ops) -> OdeState` that you propose in https://github.com/qutip/qutip/issues/1571#issuecomment-859917462). On the other hand, looping over the full `mesolve` as in `In [19]` obviously has no problems with parallelization. I wasn't sure if that's what you meant by ""`mesolve` is re-entrant"" or whether recent changes in QuTiP now use a re-entrant internal integrator, i.e. not `scipy.integrate.ode`. At the time I implemented the [`DensityMatrixODEPropagator`](https://github.com/qucontrol/krotov/blob/cfe6b108708cdfd29ab7eee24f2112977b951ed2/src/k",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1571#issuecomment-860254243
https://github.com/qutip/qutip/issues/1571#issuecomment-860254243:6359,Integrability,integrat,integrator,6359,", but note that it does generally mutate its arguments, especially if you pass a `QobjEvo` Liouvillian as the first argument. As long as you make sure you give each thread a distinct copy of the input Liouvillian, `mesolve` itself doesn't access global state as far as I recall. Just to be clear: there's two interconnected issues here: One is just being ""reentrant"" in the sense that I can safely have multiple `mesolve`'s run in parallel. This doesn't seem to be a problem for `mesolve` as a whole (propagating over the entire time grid). The other issue, at a lower level is whether I can keep the internal state of the integrator (`scipy.integrate.ode` or whatever else `mesolve` might be using) when propagating a single time step (and whether I can have multiple integrators to run in parallel that each safely keep track of their own state). That comes down to the integrator itself being ""reentrant"", of course. Certainly, calling `mesolve` in a loop (`In [19]`) doesn't keep the internal state of the integrator, hence the overhead between `In [21]` compared to `In [18]`. I wouldn't expect it to, of course, but the question is whether a refactoring of `mesolves` internals into an object that keeps state in a thread-safe way and allows doing time steps would alleviate this overhead (like the `mesolve_prepare_ode(H, state, c_ops) -> OdeState` that you propose in https://github.com/qutip/qutip/issues/1571#issuecomment-859917462). On the other hand, looping over the full `mesolve` as in `In [19]` obviously has no problems with parallelization. I wasn't sure if that's what you meant by ""`mesolve` is re-entrant"" or whether recent changes in QuTiP now use a re-entrant internal integrator, i.e. not `scipy.integrate.ode`. At the time I implemented the [`DensityMatrixODEPropagator`](https://github.com/qucontrol/krotov/blob/cfe6b108708cdfd29ab7eee24f2112977b951ed2/src/krotov/propagators.py#L162) by looking at what `mesolve` was doing at a low level for the specific case of density ma",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1571#issuecomment-860254243
https://github.com/qutip/qutip/issues/1571#issuecomment-860254243:7041,Integrability,integrat,integrator,7041,"r (`scipy.integrate.ode` or whatever else `mesolve` might be using) when propagating a single time step (and whether I can have multiple integrators to run in parallel that each safely keep track of their own state). That comes down to the integrator itself being ""reentrant"", of course. Certainly, calling `mesolve` in a loop (`In [19]`) doesn't keep the internal state of the integrator, hence the overhead between `In [21]` compared to `In [18]`. I wouldn't expect it to, of course, but the question is whether a refactoring of `mesolves` internals into an object that keeps state in a thread-safe way and allows doing time steps would alleviate this overhead (like the `mesolve_prepare_ode(H, state, c_ops) -> OdeState` that you propose in https://github.com/qutip/qutip/issues/1571#issuecomment-859917462). On the other hand, looping over the full `mesolve` as in `In [19]` obviously has no problems with parallelization. I wasn't sure if that's what you meant by ""`mesolve` is re-entrant"" or whether recent changes in QuTiP now use a re-entrant internal integrator, i.e. not `scipy.integrate.ode`. At the time I implemented the [`DensityMatrixODEPropagator`](https://github.com/qucontrol/krotov/blob/cfe6b108708cdfd29ab7eee24f2112977b951ed2/src/krotov/propagators.py#L162) by looking at what `mesolve` was doing at a low level for the specific case of density matrices, `scipy.integrate.ode` was definitely being used, and that couldn't handle propagating in parallel (and by ""parallel"" I include alternating propagation steps from two different propagations). I'm also not sure what using `QobjEvo` does: In the benchmarking, there didn't seem to be any difference whether I wrap my nested lists into `QobjEvo` or not. Is there something specific that `QobjEvo` should enable that I can't do with nested lists?. > QuTiP 5 is (probably) going to formalise that (^) sort of low-level calling convention of `mesolve`, but it should work already. The new one look a bit different because instead o",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1571#issuecomment-860254243
https://github.com/qutip/qutip/issues/1571#issuecomment-860254243:7069,Integrability,integrat,integrate,7069," time step (and whether I can have multiple integrators to run in parallel that each safely keep track of their own state). That comes down to the integrator itself being ""reentrant"", of course. Certainly, calling `mesolve` in a loop (`In [19]`) doesn't keep the internal state of the integrator, hence the overhead between `In [21]` compared to `In [18]`. I wouldn't expect it to, of course, but the question is whether a refactoring of `mesolves` internals into an object that keeps state in a thread-safe way and allows doing time steps would alleviate this overhead (like the `mesolve_prepare_ode(H, state, c_ops) -> OdeState` that you propose in https://github.com/qutip/qutip/issues/1571#issuecomment-859917462). On the other hand, looping over the full `mesolve` as in `In [19]` obviously has no problems with parallelization. I wasn't sure if that's what you meant by ""`mesolve` is re-entrant"" or whether recent changes in QuTiP now use a re-entrant internal integrator, i.e. not `scipy.integrate.ode`. At the time I implemented the [`DensityMatrixODEPropagator`](https://github.com/qucontrol/krotov/blob/cfe6b108708cdfd29ab7eee24f2112977b951ed2/src/krotov/propagators.py#L162) by looking at what `mesolve` was doing at a low level for the specific case of density matrices, `scipy.integrate.ode` was definitely being used, and that couldn't handle propagating in parallel (and by ""parallel"" I include alternating propagation steps from two different propagations). I'm also not sure what using `QobjEvo` does: In the benchmarking, there didn't seem to be any difference whether I wrap my nested lists into `QobjEvo` or not. Is there something specific that `QobjEvo` should enable that I can't do with nested lists?. > QuTiP 5 is (probably) going to formalise that (^) sort of low-level calling convention of `mesolve`, but it should work already. The new one look a bit different because instead of doing the setup very manually, there'll be a ""low-level"" function to prepare a master equat",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1571#issuecomment-860254243
https://github.com/qutip/qutip/issues/1571#issuecomment-860254243:7364,Integrability,integrat,integrate,7364,", hence the overhead between `In [21]` compared to `In [18]`. I wouldn't expect it to, of course, but the question is whether a refactoring of `mesolves` internals into an object that keeps state in a thread-safe way and allows doing time steps would alleviate this overhead (like the `mesolve_prepare_ode(H, state, c_ops) -> OdeState` that you propose in https://github.com/qutip/qutip/issues/1571#issuecomment-859917462). On the other hand, looping over the full `mesolve` as in `In [19]` obviously has no problems with parallelization. I wasn't sure if that's what you meant by ""`mesolve` is re-entrant"" or whether recent changes in QuTiP now use a re-entrant internal integrator, i.e. not `scipy.integrate.ode`. At the time I implemented the [`DensityMatrixODEPropagator`](https://github.com/qucontrol/krotov/blob/cfe6b108708cdfd29ab7eee24f2112977b951ed2/src/krotov/propagators.py#L162) by looking at what `mesolve` was doing at a low level for the specific case of density matrices, `scipy.integrate.ode` was definitely being used, and that couldn't handle propagating in parallel (and by ""parallel"" I include alternating propagation steps from two different propagations). I'm also not sure what using `QobjEvo` does: In the benchmarking, there didn't seem to be any difference whether I wrap my nested lists into `QobjEvo` or not. Is there something specific that `QobjEvo` should enable that I can't do with nested lists?. > QuTiP 5 is (probably) going to formalise that (^) sort of low-level calling convention of `mesolve`, but it should work already. The new one look a bit different because instead of doing the setup very manually, there'll be a ""low-level"" function to prepare a master equation problem (and a Schrodinger equation one, etc), and then there'll be a `step` method instead of calling the ""high-level"" interface function `mesolve`, but functionally it'll do largely the same, just with a lot less data copying than the current form has to do. In the new system, it's likely",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1571#issuecomment-860254243
https://github.com/qutip/qutip/issues/1571#issuecomment-860254243:7663,Integrability,wrap,wrap,7663,"ate this overhead (like the `mesolve_prepare_ode(H, state, c_ops) -> OdeState` that you propose in https://github.com/qutip/qutip/issues/1571#issuecomment-859917462). On the other hand, looping over the full `mesolve` as in `In [19]` obviously has no problems with parallelization. I wasn't sure if that's what you meant by ""`mesolve` is re-entrant"" or whether recent changes in QuTiP now use a re-entrant internal integrator, i.e. not `scipy.integrate.ode`. At the time I implemented the [`DensityMatrixODEPropagator`](https://github.com/qucontrol/krotov/blob/cfe6b108708cdfd29ab7eee24f2112977b951ed2/src/krotov/propagators.py#L162) by looking at what `mesolve` was doing at a low level for the specific case of density matrices, `scipy.integrate.ode` was definitely being used, and that couldn't handle propagating in parallel (and by ""parallel"" I include alternating propagation steps from two different propagations). I'm also not sure what using `QobjEvo` does: In the benchmarking, there didn't seem to be any difference whether I wrap my nested lists into `QobjEvo` or not. Is there something specific that `QobjEvo` should enable that I can't do with nested lists?. > QuTiP 5 is (probably) going to formalise that (^) sort of low-level calling convention of `mesolve`, but it should work already. The new one look a bit different because instead of doing the setup very manually, there'll be a ""low-level"" function to prepare a master equation problem (and a Schrodinger equation one, etc), and then there'll be a `step` method instead of calling the ""high-level"" interface function `mesolve`, but functionally it'll do largely the same, just with a lot less data copying than the current form has to do. In the new system, it's likely that the function `mesolve` itself will keep the exact same interface it has now, just internally most of its processing will be split into modular components, each of which will be accessible (with different names) to the user to compose themselves, if the",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1571#issuecomment-860254243
https://github.com/qutip/qutip/issues/1571#issuecomment-860254243:8198,Integrability,interface,interface,8198,"ropagator`](https://github.com/qucontrol/krotov/blob/cfe6b108708cdfd29ab7eee24f2112977b951ed2/src/krotov/propagators.py#L162) by looking at what `mesolve` was doing at a low level for the specific case of density matrices, `scipy.integrate.ode` was definitely being used, and that couldn't handle propagating in parallel (and by ""parallel"" I include alternating propagation steps from two different propagations). I'm also not sure what using `QobjEvo` does: In the benchmarking, there didn't seem to be any difference whether I wrap my nested lists into `QobjEvo` or not. Is there something specific that `QobjEvo` should enable that I can't do with nested lists?. > QuTiP 5 is (probably) going to formalise that (^) sort of low-level calling convention of `mesolve`, but it should work already. The new one look a bit different because instead of doing the setup very manually, there'll be a ""low-level"" function to prepare a master equation problem (and a Schrodinger equation one, etc), and then there'll be a `step` method instead of calling the ""high-level"" interface function `mesolve`, but functionally it'll do largely the same, just with a lot less data copying than the current form has to do. In the new system, it's likely that the function `mesolve` itself will keep the exact same interface it has now, just internally most of its processing will be split into modular components, each of which will be accessible (with different names) to the user to compose themselves, if they want low-level access. That sounds perfect! I might wait for QuTiP 5 to come out, or if these things are already in `master`, I'll see if I can maybe revisit `DensityMatrixODEPropagator` and maybe also add something for the Hilbert space case (whatever `sesolve` is doing internally). As an aside, I was actually surprised how much better `DensityMatrixODEPropagator` performs compared to looping over `mesolve` (`In [29]` vs `In [21]`): Since the `DensityMatrixODEPropagator` also re-initializes `scipy.i",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1571#issuecomment-860254243
https://github.com/qutip/qutip/issues/1571#issuecomment-860254243:8430,Integrability,interface,interface,8430,"g propagation steps from two different propagations). I'm also not sure what using `QobjEvo` does: In the benchmarking, there didn't seem to be any difference whether I wrap my nested lists into `QobjEvo` or not. Is there something specific that `QobjEvo` should enable that I can't do with nested lists?. > QuTiP 5 is (probably) going to formalise that (^) sort of low-level calling convention of `mesolve`, but it should work already. The new one look a bit different because instead of doing the setup very manually, there'll be a ""low-level"" function to prepare a master equation problem (and a Schrodinger equation one, etc), and then there'll be a `step` method instead of calling the ""high-level"" interface function `mesolve`, but functionally it'll do largely the same, just with a lot less data copying than the current form has to do. In the new system, it's likely that the function `mesolve` itself will keep the exact same interface it has now, just internally most of its processing will be split into modular components, each of which will be accessible (with different names) to the user to compose themselves, if they want low-level access. That sounds perfect! I might wait for QuTiP 5 to come out, or if these things are already in `master`, I'll see if I can maybe revisit `DensityMatrixODEPropagator` and maybe also add something for the Hilbert space case (whatever `sesolve` is doing internally). As an aside, I was actually surprised how much better `DensityMatrixODEPropagator` performs compared to looping over `mesolve` (`In [29]` vs `In [21]`): Since the `DensityMatrixODEPropagator` also re-initializes `scipy.integrate.ode` in every time steps, it would seem like the only difference between the two is the overhead of `mesolve` deciding that it has to handle the specific case of density matrix propagation. That might be something to keep an eye on in future QuTiP development: Ideally, calling `mesolve` would have negligible overhead compared to manually doing whatev",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1571#issuecomment-860254243
https://github.com/qutip/qutip/issues/1571#issuecomment-860254243:9133,Integrability,integrat,integrate,9133,"e'll be a `step` method instead of calling the ""high-level"" interface function `mesolve`, but functionally it'll do largely the same, just with a lot less data copying than the current form has to do. In the new system, it's likely that the function `mesolve` itself will keep the exact same interface it has now, just internally most of its processing will be split into modular components, each of which will be accessible (with different names) to the user to compose themselves, if they want low-level access. That sounds perfect! I might wait for QuTiP 5 to come out, or if these things are already in `master`, I'll see if I can maybe revisit `DensityMatrixODEPropagator` and maybe also add something for the Hilbert space case (whatever `sesolve` is doing internally). As an aside, I was actually surprised how much better `DensityMatrixODEPropagator` performs compared to looping over `mesolve` (`In [29]` vs `In [21]`): Since the `DensityMatrixODEPropagator` also re-initializes `scipy.integrate.ode` in every time steps, it would seem like the only difference between the two is the overhead of `mesolve` deciding that it has to handle the specific case of density matrix propagation. That might be something to keep an eye on in future QuTiP development: Ideally, calling `mesolve` would have negligible overhead compared to manually doing whatever `mesolve` does internally for a particular case. > We're unlikely to add `yield` to `mesolve` directly because that's a very breaking change to one of QuTiP's core functions (we can't return from a generator, or at least not ergonomically), but we are splitting up the `mesolve` monolith into a much more modular architecture, and making it more user-accessible. The other advantage of this is that the integrator component will just be one element of a composable system, so we'll not be tied to scipy integrators any more. I would absolutely not expect you to modifying how `mesolve` works directly. In fact, I would strongly recommend le",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1571#issuecomment-860254243
https://github.com/qutip/qutip/issues/1571#issuecomment-860254243:9901,Integrability,integrat,integrator,9901," surprised how much better `DensityMatrixODEPropagator` performs compared to looping over `mesolve` (`In [29]` vs `In [21]`): Since the `DensityMatrixODEPropagator` also re-initializes `scipy.integrate.ode` in every time steps, it would seem like the only difference between the two is the overhead of `mesolve` deciding that it has to handle the specific case of density matrix propagation. That might be something to keep an eye on in future QuTiP development: Ideally, calling `mesolve` would have negligible overhead compared to manually doing whatever `mesolve` does internally for a particular case. > We're unlikely to add `yield` to `mesolve` directly because that's a very breaking change to one of QuTiP's core functions (we can't return from a generator, or at least not ergonomically), but we are splitting up the `mesolve` monolith into a much more modular architecture, and making it more user-accessible. The other advantage of this is that the integrator component will just be one element of a composable system, so we'll not be tied to scipy integrators any more. I would absolutely not expect you to modifying how `mesolve` works directly. In fact, I would strongly recommend leaving the `mesolve` interface unchanged. The internal refactoring is all I'm after here. @jakelishman in https://github.com/qutip/qutip/issues/1571#issuecomment-859917462:. > I also note that I'm not replying to the thread I thought I was - I thought I was in `krotov`! For my response to the discussion points:. Yeah, sorry the discussion got a little confused between what I was suggesting in https://github.com/qucontrol/krotov/issues/93 for myself to try out (adding a `yield` to `mesolve` as a dirty hack) and the discussion here about how to address the underlying use case properly in QuTiP itself. So just to be clear: Do *not* add a `yield` to the existing `mesolve` function in QuTiP! I would strongly recommend keeping the existing interface for `mesolve` and just refactor what is going on i",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1571#issuecomment-860254243
https://github.com/qutip/qutip/issues/1571#issuecomment-860254243:10001,Integrability,integrat,integrators,10001," surprised how much better `DensityMatrixODEPropagator` performs compared to looping over `mesolve` (`In [29]` vs `In [21]`): Since the `DensityMatrixODEPropagator` also re-initializes `scipy.integrate.ode` in every time steps, it would seem like the only difference between the two is the overhead of `mesolve` deciding that it has to handle the specific case of density matrix propagation. That might be something to keep an eye on in future QuTiP development: Ideally, calling `mesolve` would have negligible overhead compared to manually doing whatever `mesolve` does internally for a particular case. > We're unlikely to add `yield` to `mesolve` directly because that's a very breaking change to one of QuTiP's core functions (we can't return from a generator, or at least not ergonomically), but we are splitting up the `mesolve` monolith into a much more modular architecture, and making it more user-accessible. The other advantage of this is that the integrator component will just be one element of a composable system, so we'll not be tied to scipy integrators any more. I would absolutely not expect you to modifying how `mesolve` works directly. In fact, I would strongly recommend leaving the `mesolve` interface unchanged. The internal refactoring is all I'm after here. @jakelishman in https://github.com/qutip/qutip/issues/1571#issuecomment-859917462:. > I also note that I'm not replying to the thread I thought I was - I thought I was in `krotov`! For my response to the discussion points:. Yeah, sorry the discussion got a little confused between what I was suggesting in https://github.com/qucontrol/krotov/issues/93 for myself to try out (adding a `yield` to `mesolve` as a dirty hack) and the discussion here about how to address the underlying use case properly in QuTiP itself. So just to be clear: Do *not* add a `yield` to the existing `mesolve` function in QuTiP! I would strongly recommend keeping the existing interface for `mesolve` and just refactor what is going on i",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1571#issuecomment-860254243
https://github.com/qutip/qutip/issues/1571#issuecomment-860254243:10158,Integrability,interface,interface,10158,"rate.ode` in every time steps, it would seem like the only difference between the two is the overhead of `mesolve` deciding that it has to handle the specific case of density matrix propagation. That might be something to keep an eye on in future QuTiP development: Ideally, calling `mesolve` would have negligible overhead compared to manually doing whatever `mesolve` does internally for a particular case. > We're unlikely to add `yield` to `mesolve` directly because that's a very breaking change to one of QuTiP's core functions (we can't return from a generator, or at least not ergonomically), but we are splitting up the `mesolve` monolith into a much more modular architecture, and making it more user-accessible. The other advantage of this is that the integrator component will just be one element of a composable system, so we'll not be tied to scipy integrators any more. I would absolutely not expect you to modifying how `mesolve` works directly. In fact, I would strongly recommend leaving the `mesolve` interface unchanged. The internal refactoring is all I'm after here. @jakelishman in https://github.com/qutip/qutip/issues/1571#issuecomment-859917462:. > I also note that I'm not replying to the thread I thought I was - I thought I was in `krotov`! For my response to the discussion points:. Yeah, sorry the discussion got a little confused between what I was suggesting in https://github.com/qucontrol/krotov/issues/93 for myself to try out (adding a `yield` to `mesolve` as a dirty hack) and the discussion here about how to address the underlying use case properly in QuTiP itself. So just to be clear: Do *not* add a `yield` to the existing `mesolve` function in QuTiP! I would strongly recommend keeping the existing interface for `mesolve` and just refactor what is going on in the backend to enable single-time-step propagation with as little overhead as possible. > * I think the function `qutip.mesolve` shouldn't change interface at all for 5.0 - we can change its backe",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1571#issuecomment-860254243
https://github.com/qutip/qutip/issues/1571#issuecomment-860254243:10881,Integrability,interface,interface,10881,"is is that the integrator component will just be one element of a composable system, so we'll not be tied to scipy integrators any more. I would absolutely not expect you to modifying how `mesolve` works directly. In fact, I would strongly recommend leaving the `mesolve` interface unchanged. The internal refactoring is all I'm after here. @jakelishman in https://github.com/qutip/qutip/issues/1571#issuecomment-859917462:. > I also note that I'm not replying to the thread I thought I was - I thought I was in `krotov`! For my response to the discussion points:. Yeah, sorry the discussion got a little confused between what I was suggesting in https://github.com/qucontrol/krotov/issues/93 for myself to try out (adding a `yield` to `mesolve` as a dirty hack) and the discussion here about how to address the underlying use case properly in QuTiP itself. So just to be clear: Do *not* add a `yield` to the existing `mesolve` function in QuTiP! I would strongly recommend keeping the existing interface for `mesolve` and just refactor what is going on in the backend to enable single-time-step propagation with as little overhead as possible. > * I think the function `qutip.mesolve` shouldn't change interface at all for 5.0 - we can change its backend, but I think it'll be a huge hindrance to adoption of 5.0 if we make major breaking changes to effectively our premier function, and I don't see a need to do that. We can add, rather than change, and keep `mesolve` as the ""quick-and-dirty"" method that just works.; > * I'm in favour of exposing the different parts of the `mesolve` process as user-accessible, composable chunks. So something like exposing a `mesolve_prepare_ode(H, state, c_ops) -> OdeState` function, where `OdeState` has properties `rhs: QobjEvo`, `state: Qobj`, `time: float` (`sesolve_prepare_ode` and `mcsolve_prepare_ode` would presumably return the same object, or a derived object). Then we'd have an `Integrator` class, which encapsulates an integration step using what",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1571#issuecomment-860254243
https://github.com/qutip/qutip/issues/1571#issuecomment-860254243:11089,Integrability,interface,interface,11089,"ks directly. In fact, I would strongly recommend leaving the `mesolve` interface unchanged. The internal refactoring is all I'm after here. @jakelishman in https://github.com/qutip/qutip/issues/1571#issuecomment-859917462:. > I also note that I'm not replying to the thread I thought I was - I thought I was in `krotov`! For my response to the discussion points:. Yeah, sorry the discussion got a little confused between what I was suggesting in https://github.com/qucontrol/krotov/issues/93 for myself to try out (adding a `yield` to `mesolve` as a dirty hack) and the discussion here about how to address the underlying use case properly in QuTiP itself. So just to be clear: Do *not* add a `yield` to the existing `mesolve` function in QuTiP! I would strongly recommend keeping the existing interface for `mesolve` and just refactor what is going on in the backend to enable single-time-step propagation with as little overhead as possible. > * I think the function `qutip.mesolve` shouldn't change interface at all for 5.0 - we can change its backend, but I think it'll be a huge hindrance to adoption of 5.0 if we make major breaking changes to effectively our premier function, and I don't see a need to do that. We can add, rather than change, and keep `mesolve` as the ""quick-and-dirty"" method that just works.; > * I'm in favour of exposing the different parts of the `mesolve` process as user-accessible, composable chunks. So something like exposing a `mesolve_prepare_ode(H, state, c_ops) -> OdeState` function, where `OdeState` has properties `rhs: QobjEvo`, `state: Qobj`, `time: float` (`sesolve_prepare_ode` and `mcsolve_prepare_ode` would presumably return the same object, or a derived object). Then we'd have an `Integrator` class, which encapsulates an integration step using whatever integrator of choice, so there's one that encapsulates the scipy integrator, one which is a Cython-ised RK4 implementation, etc. Then the low-level user would simply write the `for time in times` ",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1571#issuecomment-860254243
https://github.com/qutip/qutip/issues/1571#issuecomment-860254243:11819,Integrability,Integrat,Integrator,11819,"just refactor what is going on in the backend to enable single-time-step propagation with as little overhead as possible. > * I think the function `qutip.mesolve` shouldn't change interface at all for 5.0 - we can change its backend, but I think it'll be a huge hindrance to adoption of 5.0 if we make major breaking changes to effectively our premier function, and I don't see a need to do that. We can add, rather than change, and keep `mesolve` as the ""quick-and-dirty"" method that just works.; > * I'm in favour of exposing the different parts of the `mesolve` process as user-accessible, composable chunks. So something like exposing a `mesolve_prepare_ode(H, state, c_ops) -> OdeState` function, where `OdeState` has properties `rhs: QobjEvo`, `state: Qobj`, `time: float` (`sesolve_prepare_ode` and `mcsolve_prepare_ode` would presumably return the same object, or a derived object). Then we'd have an `Integrator` class, which encapsulates an integration step using whatever integrator of choice, so there's one that encapsulates the scipy integrator, one which is a Cython-ised RK4 implementation, etc. Then the low-level user would simply write the `for time in times` loop themselves; at this level, there's nothing fancy that QuTiP adds, so we may as well just expose it directly. That sounds like the exact right solution! ;-). > I think this architecture is approximately what Eric had in mind too, though I presumably haven't used the same names. Yeah, I think we're actually all on the same page, irrespective of minor implementation/naming details: Have an object that keeps internal state of `mesolve` and allows to advance step-by-step. Personally, I like the naming of `MeSolver` that @Ericgig wrote out in https://github.com/qutip/qutip/issues/1571#issuecomment-858740451, but `mesolve_prepare_ode`/`OdeState` works too. @Ericgig in https://github.com/qutip/qutip/issues/1571#issuecomment-859791561:. > Most of scipy's solver are not ""thread-safe"", but we will be able to use othe",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1571#issuecomment-860254243
https://github.com/qutip/qutip/issues/1571#issuecomment-860254243:11860,Integrability,integrat,integration,11860,"just refactor what is going on in the backend to enable single-time-step propagation with as little overhead as possible. > * I think the function `qutip.mesolve` shouldn't change interface at all for 5.0 - we can change its backend, but I think it'll be a huge hindrance to adoption of 5.0 if we make major breaking changes to effectively our premier function, and I don't see a need to do that. We can add, rather than change, and keep `mesolve` as the ""quick-and-dirty"" method that just works.; > * I'm in favour of exposing the different parts of the `mesolve` process as user-accessible, composable chunks. So something like exposing a `mesolve_prepare_ode(H, state, c_ops) -> OdeState` function, where `OdeState` has properties `rhs: QobjEvo`, `state: Qobj`, `time: float` (`sesolve_prepare_ode` and `mcsolve_prepare_ode` would presumably return the same object, or a derived object). Then we'd have an `Integrator` class, which encapsulates an integration step using whatever integrator of choice, so there's one that encapsulates the scipy integrator, one which is a Cython-ised RK4 implementation, etc. Then the low-level user would simply write the `for time in times` loop themselves; at this level, there's nothing fancy that QuTiP adds, so we may as well just expose it directly. That sounds like the exact right solution! ;-). > I think this architecture is approximately what Eric had in mind too, though I presumably haven't used the same names. Yeah, I think we're actually all on the same page, irrespective of minor implementation/naming details: Have an object that keeps internal state of `mesolve` and allows to advance step-by-step. Personally, I like the naming of `MeSolver` that @Ericgig wrote out in https://github.com/qutip/qutip/issues/1571#issuecomment-858740451, but `mesolve_prepare_ode`/`OdeState` works too. @Ericgig in https://github.com/qutip/qutip/issues/1571#issuecomment-859791561:. > Most of scipy's solver are not ""thread-safe"", but we will be able to use othe",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1571#issuecomment-860254243
https://github.com/qutip/qutip/issues/1571#issuecomment-860254243:11892,Integrability,integrat,integrator,11892,"just refactor what is going on in the backend to enable single-time-step propagation with as little overhead as possible. > * I think the function `qutip.mesolve` shouldn't change interface at all for 5.0 - we can change its backend, but I think it'll be a huge hindrance to adoption of 5.0 if we make major breaking changes to effectively our premier function, and I don't see a need to do that. We can add, rather than change, and keep `mesolve` as the ""quick-and-dirty"" method that just works.; > * I'm in favour of exposing the different parts of the `mesolve` process as user-accessible, composable chunks. So something like exposing a `mesolve_prepare_ode(H, state, c_ops) -> OdeState` function, where `OdeState` has properties `rhs: QobjEvo`, `state: Qobj`, `time: float` (`sesolve_prepare_ode` and `mcsolve_prepare_ode` would presumably return the same object, or a derived object). Then we'd have an `Integrator` class, which encapsulates an integration step using whatever integrator of choice, so there's one that encapsulates the scipy integrator, one which is a Cython-ised RK4 implementation, etc. Then the low-level user would simply write the `for time in times` loop themselves; at this level, there's nothing fancy that QuTiP adds, so we may as well just expose it directly. That sounds like the exact right solution! ;-). > I think this architecture is approximately what Eric had in mind too, though I presumably haven't used the same names. Yeah, I think we're actually all on the same page, irrespective of minor implementation/naming details: Have an object that keeps internal state of `mesolve` and allows to advance step-by-step. Personally, I like the naming of `MeSolver` that @Ericgig wrote out in https://github.com/qutip/qutip/issues/1571#issuecomment-858740451, but `mesolve_prepare_ode`/`OdeState` works too. @Ericgig in https://github.com/qutip/qutip/issues/1571#issuecomment-859791561:. > Most of scipy's solver are not ""thread-safe"", but we will be able to use othe",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1571#issuecomment-860254243
https://github.com/qutip/qutip/issues/1571#issuecomment-860254243:11957,Integrability,integrat,integrator,11957,"just refactor what is going on in the backend to enable single-time-step propagation with as little overhead as possible. > * I think the function `qutip.mesolve` shouldn't change interface at all for 5.0 - we can change its backend, but I think it'll be a huge hindrance to adoption of 5.0 if we make major breaking changes to effectively our premier function, and I don't see a need to do that. We can add, rather than change, and keep `mesolve` as the ""quick-and-dirty"" method that just works.; > * I'm in favour of exposing the different parts of the `mesolve` process as user-accessible, composable chunks. So something like exposing a `mesolve_prepare_ode(H, state, c_ops) -> OdeState` function, where `OdeState` has properties `rhs: QobjEvo`, `state: Qobj`, `time: float` (`sesolve_prepare_ode` and `mcsolve_prepare_ode` would presumably return the same object, or a derived object). Then we'd have an `Integrator` class, which encapsulates an integration step using whatever integrator of choice, so there's one that encapsulates the scipy integrator, one which is a Cython-ised RK4 implementation, etc. Then the low-level user would simply write the `for time in times` loop themselves; at this level, there's nothing fancy that QuTiP adds, so we may as well just expose it directly. That sounds like the exact right solution! ;-). > I think this architecture is approximately what Eric had in mind too, though I presumably haven't used the same names. Yeah, I think we're actually all on the same page, irrespective of minor implementation/naming details: Have an object that keeps internal state of `mesolve` and allows to advance step-by-step. Personally, I like the naming of `MeSolver` that @Ericgig wrote out in https://github.com/qutip/qutip/issues/1571#issuecomment-858740451, but `mesolve_prepare_ode`/`OdeState` works too. @Ericgig in https://github.com/qutip/qutip/issues/1571#issuecomment-859791561:. > Most of scipy's solver are not ""thread-safe"", but we will be able to use othe",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1571#issuecomment-860254243
https://github.com/qutip/qutip/issues/1571#issuecomment-860254243:13066,Integrability,integrat,integrate,13066,"te` has properties `rhs: QobjEvo`, `state: Qobj`, `time: float` (`sesolve_prepare_ode` and `mcsolve_prepare_ode` would presumably return the same object, or a derived object). Then we'd have an `Integrator` class, which encapsulates an integration step using whatever integrator of choice, so there's one that encapsulates the scipy integrator, one which is a Cython-ised RK4 implementation, etc. Then the low-level user would simply write the `for time in times` loop themselves; at this level, there's nothing fancy that QuTiP adds, so we may as well just expose it directly. That sounds like the exact right solution! ;-). > I think this architecture is approximately what Eric had in mind too, though I presumably haven't used the same names. Yeah, I think we're actually all on the same page, irrespective of minor implementation/naming details: Have an object that keeps internal state of `mesolve` and allows to advance step-by-step. Personally, I like the naming of `MeSolver` that @Ericgig wrote out in https://github.com/qutip/qutip/issues/1571#issuecomment-858740451, but `mesolve_prepare_ode`/`OdeState` works too. @Ericgig in https://github.com/qutip/qutip/issues/1571#issuecomment-859791561:. > Most of scipy's solver are not ""thread-safe"", but we will be able to use other solvers in the new version. If you can point me to any thread-safe solver, I'd love to try that out. As already discussed above, if I can replace [`scipy.integrate.ode`](https://github.com/qucontrol/krotov/blob/cfe6b108708cdfd29ab7eee24f2112977b951ed2/src/krotov/propagators.py#L312) in Krotov's [`DensityMatrixODEPropagator`](https://github.com/qucontrol/krotov/blob/cfe6b108708cdfd29ab7eee24f2112977b951ed2/src/krotov/propagators.py#L162) with something that's reentrant so I don't have to [re-initialize the integrator in every time step](https://github.com/qucontrol/krotov/blob/cfe6b108708cdfd29ab7eee24f2112977b951ed2/src/krotov/propagators.py#L244) , that might be a significant performance boost already.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1571#issuecomment-860254243
https://github.com/qutip/qutip/issues/1571#issuecomment-860254243:13423,Integrability,integrat,integrator,13423,"te` has properties `rhs: QobjEvo`, `state: Qobj`, `time: float` (`sesolve_prepare_ode` and `mcsolve_prepare_ode` would presumably return the same object, or a derived object). Then we'd have an `Integrator` class, which encapsulates an integration step using whatever integrator of choice, so there's one that encapsulates the scipy integrator, one which is a Cython-ised RK4 implementation, etc. Then the low-level user would simply write the `for time in times` loop themselves; at this level, there's nothing fancy that QuTiP adds, so we may as well just expose it directly. That sounds like the exact right solution! ;-). > I think this architecture is approximately what Eric had in mind too, though I presumably haven't used the same names. Yeah, I think we're actually all on the same page, irrespective of minor implementation/naming details: Have an object that keeps internal state of `mesolve` and allows to advance step-by-step. Personally, I like the naming of `MeSolver` that @Ericgig wrote out in https://github.com/qutip/qutip/issues/1571#issuecomment-858740451, but `mesolve_prepare_ode`/`OdeState` works too. @Ericgig in https://github.com/qutip/qutip/issues/1571#issuecomment-859791561:. > Most of scipy's solver are not ""thread-safe"", but we will be able to use other solvers in the new version. If you can point me to any thread-safe solver, I'd love to try that out. As already discussed above, if I can replace [`scipy.integrate.ode`](https://github.com/qucontrol/krotov/blob/cfe6b108708cdfd29ab7eee24f2112977b951ed2/src/krotov/propagators.py#L312) in Krotov's [`DensityMatrixODEPropagator`](https://github.com/qucontrol/krotov/blob/cfe6b108708cdfd29ab7eee24f2112977b951ed2/src/krotov/propagators.py#L162) with something that's reentrant so I don't have to [re-initialize the integrator in every time step](https://github.com/qucontrol/krotov/blob/cfe6b108708cdfd29ab7eee24f2112977b951ed2/src/krotov/propagators.py#L244) , that might be a significant performance boost already.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1571#issuecomment-860254243
https://github.com/qutip/qutip/issues/1571#issuecomment-860254243:2282,Modifiability,variab,variable,2282,"o a single constant `Qobj`, see `In [21]` vs `In [24]`. On the other hand, it doesn't always give a speedup: in the low-level [`DensityMatrixODEPropagator`](https://github.com/qucontrol/krotov/blob/cfe6b108708cdfd29ab7eee24f2112977b951ed2/src/krotov/propagators.py#L162) it actually makes the propagation slower, see `In [29]` vs `In [32]`. It's a bit surprising, but then, as you say:. > [...] This isn't guaranteed, because it involves copying rather more data _before_ the call. So that's ok. > Would something like this work for you? [...]; >; > By giving `mesolve` the Liouvillian instead of the Hamiltonian and collapse operators separately. To be clear, I personally never use collapse operators (and the Krotov documentation heavily discourages it). Instead, I have a nested list like `[L0, [L1, control1], ...]` where `L0`, `L1`, ... are super-operators. I should also note that I use `mesolve` both for Schrödinger equations and Lindblad equations (relying on `mesolve` delegating to `sesolve`), and the Krotov package uses `H` as a variable/attribute name to refer to nested-Lindbladians or nested Hamiltonians interchangeable. Sorry if that's causing a bit of confusion. I am ultimately interested both in open system and closed system dynamics interchangeably. > [...] In the 5.x series, almost all the intermediary operations should get a speed up as well (`Qobj.__init__` is getting its time slashed, and the line `current_liouvillian += control * operator` may be able to be replaced with one that applies the same in-place calculation optimisations that `mesolve` does internally). One thing you pay a nasty penalty for right now if that internally we'd keep column-stacking/unstacking the state, but in the 5.x branch it'll stop being represented internally by a sparse matrix, and instead it'll be a Fortran-ordered dense matrix, for which the stack/unstack is a free operation. That's an extremely exciting prospect! I'd love to be able to have internal sparse data for Qobj's that",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1571#issuecomment-860254243
https://github.com/qutip/qutip/issues/1571#issuecomment-860254243:6497,Modifiability,refactor,refactoring,6497,"'t access global state as far as I recall. Just to be clear: there's two interconnected issues here: One is just being ""reentrant"" in the sense that I can safely have multiple `mesolve`'s run in parallel. This doesn't seem to be a problem for `mesolve` as a whole (propagating over the entire time grid). The other issue, at a lower level is whether I can keep the internal state of the integrator (`scipy.integrate.ode` or whatever else `mesolve` might be using) when propagating a single time step (and whether I can have multiple integrators to run in parallel that each safely keep track of their own state). That comes down to the integrator itself being ""reentrant"", of course. Certainly, calling `mesolve` in a loop (`In [19]`) doesn't keep the internal state of the integrator, hence the overhead between `In [21]` compared to `In [18]`. I wouldn't expect it to, of course, but the question is whether a refactoring of `mesolves` internals into an object that keeps state in a thread-safe way and allows doing time steps would alleviate this overhead (like the `mesolve_prepare_ode(H, state, c_ops) -> OdeState` that you propose in https://github.com/qutip/qutip/issues/1571#issuecomment-859917462). On the other hand, looping over the full `mesolve` as in `In [19]` obviously has no problems with parallelization. I wasn't sure if that's what you meant by ""`mesolve` is re-entrant"" or whether recent changes in QuTiP now use a re-entrant internal integrator, i.e. not `scipy.integrate.ode`. At the time I implemented the [`DensityMatrixODEPropagator`](https://github.com/qucontrol/krotov/blob/cfe6b108708cdfd29ab7eee24f2112977b951ed2/src/krotov/propagators.py#L162) by looking at what `mesolve` was doing at a low level for the specific case of density matrices, `scipy.integrate.ode` was definitely being used, and that couldn't handle propagating in parallel (and by ""parallel"" I include alternating propagation steps from two different propagations). I'm also not sure what using `QobjEvo",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1571#issuecomment-860254243
https://github.com/qutip/qutip/issues/1571#issuecomment-860254243:10192,Modifiability,refactor,refactoring,10192,"rence between the two is the overhead of `mesolve` deciding that it has to handle the specific case of density matrix propagation. That might be something to keep an eye on in future QuTiP development: Ideally, calling `mesolve` would have negligible overhead compared to manually doing whatever `mesolve` does internally for a particular case. > We're unlikely to add `yield` to `mesolve` directly because that's a very breaking change to one of QuTiP's core functions (we can't return from a generator, or at least not ergonomically), but we are splitting up the `mesolve` monolith into a much more modular architecture, and making it more user-accessible. The other advantage of this is that the integrator component will just be one element of a composable system, so we'll not be tied to scipy integrators any more. I would absolutely not expect you to modifying how `mesolve` works directly. In fact, I would strongly recommend leaving the `mesolve` interface unchanged. The internal refactoring is all I'm after here. @jakelishman in https://github.com/qutip/qutip/issues/1571#issuecomment-859917462:. > I also note that I'm not replying to the thread I thought I was - I thought I was in `krotov`! For my response to the discussion points:. Yeah, sorry the discussion got a little confused between what I was suggesting in https://github.com/qucontrol/krotov/issues/93 for myself to try out (adding a `yield` to `mesolve` as a dirty hack) and the discussion here about how to address the underlying use case properly in QuTiP itself. So just to be clear: Do *not* add a `yield` to the existing `mesolve` function in QuTiP! I would strongly recommend keeping the existing interface for `mesolve` and just refactor what is going on in the backend to enable single-time-step propagation with as little overhead as possible. > * I think the function `qutip.mesolve` shouldn't change interface at all for 5.0 - we can change its backend, but I think it'll be a huge hindrance to adoption of 5.0 if",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1571#issuecomment-860254243
https://github.com/qutip/qutip/issues/1571#issuecomment-860254243:10914,Modifiability,refactor,refactor,10914,"is is that the integrator component will just be one element of a composable system, so we'll not be tied to scipy integrators any more. I would absolutely not expect you to modifying how `mesolve` works directly. In fact, I would strongly recommend leaving the `mesolve` interface unchanged. The internal refactoring is all I'm after here. @jakelishman in https://github.com/qutip/qutip/issues/1571#issuecomment-859917462:. > I also note that I'm not replying to the thread I thought I was - I thought I was in `krotov`! For my response to the discussion points:. Yeah, sorry the discussion got a little confused between what I was suggesting in https://github.com/qucontrol/krotov/issues/93 for myself to try out (adding a `yield` to `mesolve` as a dirty hack) and the discussion here about how to address the underlying use case properly in QuTiP itself. So just to be clear: Do *not* add a `yield` to the existing `mesolve` function in QuTiP! I would strongly recommend keeping the existing interface for `mesolve` and just refactor what is going on in the backend to enable single-time-step propagation with as little overhead as possible. > * I think the function `qutip.mesolve` shouldn't change interface at all for 5.0 - we can change its backend, but I think it'll be a huge hindrance to adoption of 5.0 if we make major breaking changes to effectively our premier function, and I don't see a need to do that. We can add, rather than change, and keep `mesolve` as the ""quick-and-dirty"" method that just works.; > * I'm in favour of exposing the different parts of the `mesolve` process as user-accessible, composable chunks. So something like exposing a `mesolve_prepare_ode(H, state, c_ops) -> OdeState` function, where `OdeState` has properties `rhs: QobjEvo`, `state: Qobj`, `time: float` (`sesolve_prepare_ode` and `mcsolve_prepare_ode` would presumably return the same object, or a derived object). Then we'd have an `Integrator` class, which encapsulates an integration step using what",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1571#issuecomment-860254243
https://github.com/qutip/qutip/issues/1571#issuecomment-860254243:1007,Performance,perform,perform,1007,"Ok, so I did some benchmarking at https://nbviewer.ipython.org/gist/goerz/34af142b78d7e344417d838bbea78aaf/06_example_3states_benchmark.ipynb ([gist](https://gist.github.com/goerz/34af142b78d7e344417d838bbea78aaf)), based on [one of the example notebooks from the Krotov package](https://qucontrol.github.io/krotov/v1.2.1/notebooks/06_example_3states.html). I'll be referring to the numbered cells in that notebook in the discussion below. @jakelishman in https://github.com/qutip/qutip/issues/1571#issuecomment-859873615:. > I think you might be able to achieve a lot of what you want already. The pseudo-code looks like it's not using `mesolve` super efficiently, though maybe it's only because of simplifications to make a MWE. For example, if your controls are piecewise constant, then it might be inefficient to represent those terms as ""time dependent""; doing so means you incur the cost of multiplying each term by a scalar at every intermediate step the integrator chooses to take, then you have to perform the matrix-vector product for each one individually and add them up. That's certainly worth trying: when calling `mesolve` in a loop over the time grid, I did indeed see a significant speedup when summing the Lindbladian into a single constant `Qobj`, see `In [21]` vs `In [24]`. On the other hand, it doesn't always give a speedup: in the low-level [`DensityMatrixODEPropagator`](https://github.com/qucontrol/krotov/blob/cfe6b108708cdfd29ab7eee24f2112977b951ed2/src/krotov/propagators.py#L162) it actually makes the propagation slower, see `In [29]` vs `In [32]`. It's a bit surprising, but then, as you say:. > [...] This isn't guaranteed, because it involves copying rather more data _before_ the call. So that's ok. > Would something like this work for you? [...]; >; > By giving `mesolve` the Liouvillian instead of the Hamiltonian and collapse operators separately. To be clear, I personally never use collapse operators (and the Krotov documentation heavily discourages it). Inst",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1571#issuecomment-860254243
https://github.com/qutip/qutip/issues/1571#issuecomment-860254243:3562,Performance,optimiz,optimize,3562," 5.x series, almost all the intermediary operations should get a speed up as well (`Qobj.__init__` is getting its time slashed, and the line `current_liouvillian += control * operator` may be able to be replaced with one that applies the same in-place calculation optimisations that `mesolve` does internally). One thing you pay a nasty penalty for right now if that internally we'd keep column-stacking/unstacking the state, but in the 5.x branch it'll stop being represented internally by a sparse matrix, and instead it'll be a Fortran-ordered dense matrix, for which the stack/unstack is a free operation. That's an extremely exciting prospect! I'd love to be able to have internal sparse data for Qobj's that represent Hamiltonians/Liouvillians, but dense data for Qobj's that represent Hilbert space states or Density matrices. In fact, it looks like a significant part of the overhead in the [calculation of the Krotov's pulse update](https://github.com/qucontrol/krotov/blob/cfe6b108708cdfd29ab7eee24f2112977b951ed2/src/krotov/optimize.py#L466) is due to the stacking/unstacking, see [`profile.svg`](https://gist.githubusercontent.com/goerz/34af142b78d7e344417d838bbea78aaf/raw/f3f49104083d59b9612f153d2f0ff652ea6a9f01/profile.svg) in the [gist](https://gist.github.com/goerz/34af142b78d7e344417d838bbea78aaf#file-profile-svg). In the benchmarking notebook, for the optimization in `In [34]`, that's the extra 6 seconds per iteration (iterations 1-3 should ideally take exactly twice as long as iteration 0, as iteration 0 is a simple forward propagation and all later iterations are one forward and one backward propagations). That's what we have in our Fortran implementation, too: the runtime of the optimization is basically just the runtime of all the internal propagations; calculating the updates should be completely negligible. There's also [shape conversions](https://github.com/qucontrol/krotov/blob/cfe6b108708cdfd29ab7eee24f2112977b951ed2/src/krotov/propagators.py#L254-L260) happ",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1571#issuecomment-860254243
https://github.com/qutip/qutip/issues/1571#issuecomment-860254243:3901,Performance,optimiz,optimization,3901,"ly by a sparse matrix, and instead it'll be a Fortran-ordered dense matrix, for which the stack/unstack is a free operation. That's an extremely exciting prospect! I'd love to be able to have internal sparse data for Qobj's that represent Hamiltonians/Liouvillians, but dense data for Qobj's that represent Hilbert space states or Density matrices. In fact, it looks like a significant part of the overhead in the [calculation of the Krotov's pulse update](https://github.com/qucontrol/krotov/blob/cfe6b108708cdfd29ab7eee24f2112977b951ed2/src/krotov/optimize.py#L466) is due to the stacking/unstacking, see [`profile.svg`](https://gist.githubusercontent.com/goerz/34af142b78d7e344417d838bbea78aaf/raw/f3f49104083d59b9612f153d2f0ff652ea6a9f01/profile.svg) in the [gist](https://gist.github.com/goerz/34af142b78d7e344417d838bbea78aaf#file-profile-svg). In the benchmarking notebook, for the optimization in `In [34]`, that's the extra 6 seconds per iteration (iterations 1-3 should ideally take exactly twice as long as iteration 0, as iteration 0 is a simple forward propagation and all later iterations are one forward and one backward propagations). That's what we have in our Fortran implementation, too: the runtime of the optimization is basically just the runtime of all the internal propagations; calculating the updates should be completely negligible. There's also [shape conversions](https://github.com/qucontrol/krotov/blob/cfe6b108708cdfd29ab7eee24f2112977b951ed2/src/krotov/propagators.py#L254-L260) happening in [`DensityMatrixODEPropagator`](https://github.com/qucontrol/krotov/blob/cfe6b108708cdfd29ab7eee24f2112977b951ed2/src/krotov/propagators.py#L162) which would be nice to eliminate. Lastly, having dense internal storage for states might actually give the same speedup as we've demonstrated in https://qucontrol.github.io/krotov/v1.2.1/notebooks/09_example_numpy.html for doing Krotov with numpy arrays instead of Qobj's -- potentially even more speedup, in fact, since with nump",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1571#issuecomment-860254243
https://github.com/qutip/qutip/issues/1571#issuecomment-860254243:4238,Performance,optimiz,optimization,4238,"ouvillians, but dense data for Qobj's that represent Hilbert space states or Density matrices. In fact, it looks like a significant part of the overhead in the [calculation of the Krotov's pulse update](https://github.com/qucontrol/krotov/blob/cfe6b108708cdfd29ab7eee24f2112977b951ed2/src/krotov/optimize.py#L466) is due to the stacking/unstacking, see [`profile.svg`](https://gist.githubusercontent.com/goerz/34af142b78d7e344417d838bbea78aaf/raw/f3f49104083d59b9612f153d2f0ff652ea6a9f01/profile.svg) in the [gist](https://gist.github.com/goerz/34af142b78d7e344417d838bbea78aaf#file-profile-svg). In the benchmarking notebook, for the optimization in `In [34]`, that's the extra 6 seconds per iteration (iterations 1-3 should ideally take exactly twice as long as iteration 0, as iteration 0 is a simple forward propagation and all later iterations are one forward and one backward propagations). That's what we have in our Fortran implementation, too: the runtime of the optimization is basically just the runtime of all the internal propagations; calculating the updates should be completely negligible. There's also [shape conversions](https://github.com/qucontrol/krotov/blob/cfe6b108708cdfd29ab7eee24f2112977b951ed2/src/krotov/propagators.py#L254-L260) happening in [`DensityMatrixODEPropagator`](https://github.com/qucontrol/krotov/blob/cfe6b108708cdfd29ab7eee24f2112977b951ed2/src/krotov/propagators.py#L162) which would be nice to eliminate. Lastly, having dense internal storage for states might actually give the same speedup as we've demonstrated in https://qucontrol.github.io/krotov/v1.2.1/notebooks/09_example_numpy.html for doing Krotov with numpy arrays instead of Qobj's -- potentially even more speedup, in fact, since with numpy now *everything* is dense (including the Hamiltonian), whereas the best thing to do numerically would be to do sparse-matrix-dense-vector operations (which is what we do in Fortran, incidentally). > In the form I've written it, this loop is thread-safe ",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1571#issuecomment-860254243
https://github.com/qutip/qutip/issues/1571#issuecomment-860254243:8997,Performance,perform,performs,8997,"be a ""low-level"" function to prepare a master equation problem (and a Schrodinger equation one, etc), and then there'll be a `step` method instead of calling the ""high-level"" interface function `mesolve`, but functionally it'll do largely the same, just with a lot less data copying than the current form has to do. In the new system, it's likely that the function `mesolve` itself will keep the exact same interface it has now, just internally most of its processing will be split into modular components, each of which will be accessible (with different names) to the user to compose themselves, if they want low-level access. That sounds perfect! I might wait for QuTiP 5 to come out, or if these things are already in `master`, I'll see if I can maybe revisit `DensityMatrixODEPropagator` and maybe also add something for the Hilbert space case (whatever `sesolve` is doing internally). As an aside, I was actually surprised how much better `DensityMatrixODEPropagator` performs compared to looping over `mesolve` (`In [29]` vs `In [21]`): Since the `DensityMatrixODEPropagator` also re-initializes `scipy.integrate.ode` in every time steps, it would seem like the only difference between the two is the overhead of `mesolve` deciding that it has to handle the specific case of density matrix propagation. That might be something to keep an eye on in future QuTiP development: Ideally, calling `mesolve` would have negligible overhead compared to manually doing whatever `mesolve` does internally for a particular case. > We're unlikely to add `yield` to `mesolve` directly because that's a very breaking change to one of QuTiP's core functions (we can't return from a generator, or at least not ergonomically), but we are splitting up the `mesolve` monolith into a much more modular architecture, and making it more user-accessible. The other advantage of this is that the integrator component will just be one element of a composable system, so we'll not be tied to scipy integrators any more. ",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1571#issuecomment-860254243
https://github.com/qutip/qutip/issues/1571#issuecomment-860254243:13598,Performance,perform,performance,13598,"te` has properties `rhs: QobjEvo`, `state: Qobj`, `time: float` (`sesolve_prepare_ode` and `mcsolve_prepare_ode` would presumably return the same object, or a derived object). Then we'd have an `Integrator` class, which encapsulates an integration step using whatever integrator of choice, so there's one that encapsulates the scipy integrator, one which is a Cython-ised RK4 implementation, etc. Then the low-level user would simply write the `for time in times` loop themselves; at this level, there's nothing fancy that QuTiP adds, so we may as well just expose it directly. That sounds like the exact right solution! ;-). > I think this architecture is approximately what Eric had in mind too, though I presumably haven't used the same names. Yeah, I think we're actually all on the same page, irrespective of minor implementation/naming details: Have an object that keeps internal state of `mesolve` and allows to advance step-by-step. Personally, I like the naming of `MeSolver` that @Ericgig wrote out in https://github.com/qutip/qutip/issues/1571#issuecomment-858740451, but `mesolve_prepare_ode`/`OdeState` works too. @Ericgig in https://github.com/qutip/qutip/issues/1571#issuecomment-859791561:. > Most of scipy's solver are not ""thread-safe"", but we will be able to use other solvers in the new version. If you can point me to any thread-safe solver, I'd love to try that out. As already discussed above, if I can replace [`scipy.integrate.ode`](https://github.com/qucontrol/krotov/blob/cfe6b108708cdfd29ab7eee24f2112977b951ed2/src/krotov/propagators.py#L312) in Krotov's [`DensityMatrixODEPropagator`](https://github.com/qucontrol/krotov/blob/cfe6b108708cdfd29ab7eee24f2112977b951ed2/src/krotov/propagators.py#L162) with something that's reentrant so I don't have to [re-initialize the integrator in every time step](https://github.com/qucontrol/krotov/blob/cfe6b108708cdfd29ab7eee24f2112977b951ed2/src/krotov/propagators.py#L244) , that might be a significant performance boost already.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1571#issuecomment-860254243
https://github.com/qutip/qutip/issues/1571#issuecomment-860254243:5262,Safety,safe,safe,5262,"mization is basically just the runtime of all the internal propagations; calculating the updates should be completely negligible. There's also [shape conversions](https://github.com/qucontrol/krotov/blob/cfe6b108708cdfd29ab7eee24f2112977b951ed2/src/krotov/propagators.py#L254-L260) happening in [`DensityMatrixODEPropagator`](https://github.com/qucontrol/krotov/blob/cfe6b108708cdfd29ab7eee24f2112977b951ed2/src/krotov/propagators.py#L162) which would be nice to eliminate. Lastly, having dense internal storage for states might actually give the same speedup as we've demonstrated in https://qucontrol.github.io/krotov/v1.2.1/notebooks/09_example_numpy.html for doing Krotov with numpy arrays instead of Qobj's -- potentially even more speedup, in fact, since with numpy now *everything* is dense (including the Hamiltonian), whereas the best thing to do numerically would be to do sparse-matrix-dense-vector operations (which is what we do in Fortran, incidentally). > In the form I've written it, this loop is thread-safe already. As it stands in the 4.x series, `mesolve` is re-entrant (I'm fairly sure), but note that it does generally mutate its arguments, especially if you pass a `QobjEvo` Liouvillian as the first argument. As long as you make sure you give each thread a distinct copy of the input Liouvillian, `mesolve` itself doesn't access global state as far as I recall. Just to be clear: there's two interconnected issues here: One is just being ""reentrant"" in the sense that I can safely have multiple `mesolve`'s run in parallel. This doesn't seem to be a problem for `mesolve` as a whole (propagating over the entire time grid). The other issue, at a lower level is whether I can keep the internal state of the integrator (`scipy.integrate.ode` or whatever else `mesolve` might be using) when propagating a single time step (and whether I can have multiple integrators to run in parallel that each safely keep track of their own state). That comes down to the integrator itself bein",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1571#issuecomment-860254243
https://github.com/qutip/qutip/issues/1571#issuecomment-860254243:5740,Safety,safe,safely,5740,"minate. Lastly, having dense internal storage for states might actually give the same speedup as we've demonstrated in https://qucontrol.github.io/krotov/v1.2.1/notebooks/09_example_numpy.html for doing Krotov with numpy arrays instead of Qobj's -- potentially even more speedup, in fact, since with numpy now *everything* is dense (including the Hamiltonian), whereas the best thing to do numerically would be to do sparse-matrix-dense-vector operations (which is what we do in Fortran, incidentally). > In the form I've written it, this loop is thread-safe already. As it stands in the 4.x series, `mesolve` is re-entrant (I'm fairly sure), but note that it does generally mutate its arguments, especially if you pass a `QobjEvo` Liouvillian as the first argument. As long as you make sure you give each thread a distinct copy of the input Liouvillian, `mesolve` itself doesn't access global state as far as I recall. Just to be clear: there's two interconnected issues here: One is just being ""reentrant"" in the sense that I can safely have multiple `mesolve`'s run in parallel. This doesn't seem to be a problem for `mesolve` as a whole (propagating over the entire time grid). The other issue, at a lower level is whether I can keep the internal state of the integrator (`scipy.integrate.ode` or whatever else `mesolve` might be using) when propagating a single time step (and whether I can have multiple integrators to run in parallel that each safely keep track of their own state). That comes down to the integrator itself being ""reentrant"", of course. Certainly, calling `mesolve` in a loop (`In [19]`) doesn't keep the internal state of the integrator, hence the overhead between `In [21]` compared to `In [18]`. I wouldn't expect it to, of course, but the question is whether a refactoring of `mesolves` internals into an object that keeps state in a thread-safe way and allows doing time steps would alleviate this overhead (like the `mesolve_prepare_ode(H, state, c_ops) -> OdeState` tha",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1571#issuecomment-860254243
https://github.com/qutip/qutip/issues/1571#issuecomment-860254243:6159,Safety,safe,safely,6159,"umerically would be to do sparse-matrix-dense-vector operations (which is what we do in Fortran, incidentally). > In the form I've written it, this loop is thread-safe already. As it stands in the 4.x series, `mesolve` is re-entrant (I'm fairly sure), but note that it does generally mutate its arguments, especially if you pass a `QobjEvo` Liouvillian as the first argument. As long as you make sure you give each thread a distinct copy of the input Liouvillian, `mesolve` itself doesn't access global state as far as I recall. Just to be clear: there's two interconnected issues here: One is just being ""reentrant"" in the sense that I can safely have multiple `mesolve`'s run in parallel. This doesn't seem to be a problem for `mesolve` as a whole (propagating over the entire time grid). The other issue, at a lower level is whether I can keep the internal state of the integrator (`scipy.integrate.ode` or whatever else `mesolve` might be using) when propagating a single time step (and whether I can have multiple integrators to run in parallel that each safely keep track of their own state). That comes down to the integrator itself being ""reentrant"", of course. Certainly, calling `mesolve` in a loop (`In [19]`) doesn't keep the internal state of the integrator, hence the overhead between `In [21]` compared to `In [18]`. I wouldn't expect it to, of course, but the question is whether a refactoring of `mesolves` internals into an object that keeps state in a thread-safe way and allows doing time steps would alleviate this overhead (like the `mesolve_prepare_ode(H, state, c_ops) -> OdeState` that you propose in https://github.com/qutip/qutip/issues/1571#issuecomment-859917462). On the other hand, looping over the full `mesolve` as in `In [19]` obviously has no problems with parallelization. I wasn't sure if that's what you meant by ""`mesolve` is re-entrant"" or whether recent changes in QuTiP now use a re-entrant internal integrator, i.e. not `scipy.integrate.ode`. At the time I ",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1571#issuecomment-860254243
https://github.com/qutip/qutip/issues/1571#issuecomment-860254243:6577,Safety,safe,safe,6577,"'t access global state as far as I recall. Just to be clear: there's two interconnected issues here: One is just being ""reentrant"" in the sense that I can safely have multiple `mesolve`'s run in parallel. This doesn't seem to be a problem for `mesolve` as a whole (propagating over the entire time grid). The other issue, at a lower level is whether I can keep the internal state of the integrator (`scipy.integrate.ode` or whatever else `mesolve` might be using) when propagating a single time step (and whether I can have multiple integrators to run in parallel that each safely keep track of their own state). That comes down to the integrator itself being ""reentrant"", of course. Certainly, calling `mesolve` in a loop (`In [19]`) doesn't keep the internal state of the integrator, hence the overhead between `In [21]` compared to `In [18]`. I wouldn't expect it to, of course, but the question is whether a refactoring of `mesolves` internals into an object that keeps state in a thread-safe way and allows doing time steps would alleviate this overhead (like the `mesolve_prepare_ode(H, state, c_ops) -> OdeState` that you propose in https://github.com/qutip/qutip/issues/1571#issuecomment-859917462). On the other hand, looping over the full `mesolve` as in `In [19]` obviously has no problems with parallelization. I wasn't sure if that's what you meant by ""`mesolve` is re-entrant"" or whether recent changes in QuTiP now use a re-entrant internal integrator, i.e. not `scipy.integrate.ode`. At the time I implemented the [`DensityMatrixODEPropagator`](https://github.com/qucontrol/krotov/blob/cfe6b108708cdfd29ab7eee24f2112977b951ed2/src/krotov/propagators.py#L162) by looking at what `mesolve` was doing at a low level for the specific case of density matrices, `scipy.integrate.ode` was definitely being used, and that couldn't handle propagating in parallel (and by ""parallel"" I include alternating propagation steps from two different propagations). I'm also not sure what using `QobjEvo",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1571#issuecomment-860254243
https://github.com/qutip/qutip/issues/1571#issuecomment-860254243:12872,Safety,safe,safe,12872,"te` has properties `rhs: QobjEvo`, `state: Qobj`, `time: float` (`sesolve_prepare_ode` and `mcsolve_prepare_ode` would presumably return the same object, or a derived object). Then we'd have an `Integrator` class, which encapsulates an integration step using whatever integrator of choice, so there's one that encapsulates the scipy integrator, one which is a Cython-ised RK4 implementation, etc. Then the low-level user would simply write the `for time in times` loop themselves; at this level, there's nothing fancy that QuTiP adds, so we may as well just expose it directly. That sounds like the exact right solution! ;-). > I think this architecture is approximately what Eric had in mind too, though I presumably haven't used the same names. Yeah, I think we're actually all on the same page, irrespective of minor implementation/naming details: Have an object that keeps internal state of `mesolve` and allows to advance step-by-step. Personally, I like the naming of `MeSolver` that @Ericgig wrote out in https://github.com/qutip/qutip/issues/1571#issuecomment-858740451, but `mesolve_prepare_ode`/`OdeState` works too. @Ericgig in https://github.com/qutip/qutip/issues/1571#issuecomment-859791561:. > Most of scipy's solver are not ""thread-safe"", but we will be able to use other solvers in the new version. If you can point me to any thread-safe solver, I'd love to try that out. As already discussed above, if I can replace [`scipy.integrate.ode`](https://github.com/qucontrol/krotov/blob/cfe6b108708cdfd29ab7eee24f2112977b951ed2/src/krotov/propagators.py#L312) in Krotov's [`DensityMatrixODEPropagator`](https://github.com/qucontrol/krotov/blob/cfe6b108708cdfd29ab7eee24f2112977b951ed2/src/krotov/propagators.py#L162) with something that's reentrant so I don't have to [re-initialize the integrator in every time step](https://github.com/qucontrol/krotov/blob/cfe6b108708cdfd29ab7eee24f2112977b951ed2/src/krotov/propagators.py#L244) , that might be a significant performance boost already.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1571#issuecomment-860254243
https://github.com/qutip/qutip/issues/1571#issuecomment-860254243:12974,Safety,safe,safe,12974,"te` has properties `rhs: QobjEvo`, `state: Qobj`, `time: float` (`sesolve_prepare_ode` and `mcsolve_prepare_ode` would presumably return the same object, or a derived object). Then we'd have an `Integrator` class, which encapsulates an integration step using whatever integrator of choice, so there's one that encapsulates the scipy integrator, one which is a Cython-ised RK4 implementation, etc. Then the low-level user would simply write the `for time in times` loop themselves; at this level, there's nothing fancy that QuTiP adds, so we may as well just expose it directly. That sounds like the exact right solution! ;-). > I think this architecture is approximately what Eric had in mind too, though I presumably haven't used the same names. Yeah, I think we're actually all on the same page, irrespective of minor implementation/naming details: Have an object that keeps internal state of `mesolve` and allows to advance step-by-step. Personally, I like the naming of `MeSolver` that @Ericgig wrote out in https://github.com/qutip/qutip/issues/1571#issuecomment-858740451, but `mesolve_prepare_ode`/`OdeState` works too. @Ericgig in https://github.com/qutip/qutip/issues/1571#issuecomment-859791561:. > Most of scipy's solver are not ""thread-safe"", but we will be able to use other solvers in the new version. If you can point me to any thread-safe solver, I'd love to try that out. As already discussed above, if I can replace [`scipy.integrate.ode`](https://github.com/qucontrol/krotov/blob/cfe6b108708cdfd29ab7eee24f2112977b951ed2/src/krotov/propagators.py#L312) in Krotov's [`DensityMatrixODEPropagator`](https://github.com/qucontrol/krotov/blob/cfe6b108708cdfd29ab7eee24f2112977b951ed2/src/krotov/propagators.py#L162) with something that's reentrant so I don't have to [re-initialize the integrator in every time step](https://github.com/qucontrol/krotov/blob/cfe6b108708cdfd29ab7eee24f2112977b951ed2/src/krotov/propagators.py#L244) , that might be a significant performance boost already.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1571#issuecomment-860254243
https://github.com/qutip/qutip/issues/1571#issuecomment-860254243:5588,Security,access,access,5588,"ixODEPropagator`](https://github.com/qucontrol/krotov/blob/cfe6b108708cdfd29ab7eee24f2112977b951ed2/src/krotov/propagators.py#L162) which would be nice to eliminate. Lastly, having dense internal storage for states might actually give the same speedup as we've demonstrated in https://qucontrol.github.io/krotov/v1.2.1/notebooks/09_example_numpy.html for doing Krotov with numpy arrays instead of Qobj's -- potentially even more speedup, in fact, since with numpy now *everything* is dense (including the Hamiltonian), whereas the best thing to do numerically would be to do sparse-matrix-dense-vector operations (which is what we do in Fortran, incidentally). > In the form I've written it, this loop is thread-safe already. As it stands in the 4.x series, `mesolve` is re-entrant (I'm fairly sure), but note that it does generally mutate its arguments, especially if you pass a `QobjEvo` Liouvillian as the first argument. As long as you make sure you give each thread a distinct copy of the input Liouvillian, `mesolve` itself doesn't access global state as far as I recall. Just to be clear: there's two interconnected issues here: One is just being ""reentrant"" in the sense that I can safely have multiple `mesolve`'s run in parallel. This doesn't seem to be a problem for `mesolve` as a whole (propagating over the entire time grid). The other issue, at a lower level is whether I can keep the internal state of the integrator (`scipy.integrate.ode` or whatever else `mesolve` might be using) when propagating a single time step (and whether I can have multiple integrators to run in parallel that each safely keep track of their own state). That comes down to the integrator itself being ""reentrant"", of course. Certainly, calling `mesolve` in a loop (`In [19]`) doesn't keep the internal state of the integrator, hence the overhead between `In [21]` compared to `In [18]`. I wouldn't expect it to, of course, but the question is whether a refactoring of `mesolves` internals into an object tha",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1571#issuecomment-860254243
https://github.com/qutip/qutip/issues/1571#issuecomment-860254243:8552,Security,access,accessible,8552,"g propagation steps from two different propagations). I'm also not sure what using `QobjEvo` does: In the benchmarking, there didn't seem to be any difference whether I wrap my nested lists into `QobjEvo` or not. Is there something specific that `QobjEvo` should enable that I can't do with nested lists?. > QuTiP 5 is (probably) going to formalise that (^) sort of low-level calling convention of `mesolve`, but it should work already. The new one look a bit different because instead of doing the setup very manually, there'll be a ""low-level"" function to prepare a master equation problem (and a Schrodinger equation one, etc), and then there'll be a `step` method instead of calling the ""high-level"" interface function `mesolve`, but functionally it'll do largely the same, just with a lot less data copying than the current form has to do. In the new system, it's likely that the function `mesolve` itself will keep the exact same interface it has now, just internally most of its processing will be split into modular components, each of which will be accessible (with different names) to the user to compose themselves, if they want low-level access. That sounds perfect! I might wait for QuTiP 5 to come out, or if these things are already in `master`, I'll see if I can maybe revisit `DensityMatrixODEPropagator` and maybe also add something for the Hilbert space case (whatever `sesolve` is doing internally). As an aside, I was actually surprised how much better `DensityMatrixODEPropagator` performs compared to looping over `mesolve` (`In [29]` vs `In [21]`): Since the `DensityMatrixODEPropagator` also re-initializes `scipy.integrate.ode` in every time steps, it would seem like the only difference between the two is the overhead of `mesolve` deciding that it has to handle the specific case of density matrix propagation. That might be something to keep an eye on in future QuTiP development: Ideally, calling `mesolve` would have negligible overhead compared to manually doing whatev",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1571#issuecomment-860254243
https://github.com/qutip/qutip/issues/1571#issuecomment-860254243:8644,Security,access,access,8644,"g propagation steps from two different propagations). I'm also not sure what using `QobjEvo` does: In the benchmarking, there didn't seem to be any difference whether I wrap my nested lists into `QobjEvo` or not. Is there something specific that `QobjEvo` should enable that I can't do with nested lists?. > QuTiP 5 is (probably) going to formalise that (^) sort of low-level calling convention of `mesolve`, but it should work already. The new one look a bit different because instead of doing the setup very manually, there'll be a ""low-level"" function to prepare a master equation problem (and a Schrodinger equation one, etc), and then there'll be a `step` method instead of calling the ""high-level"" interface function `mesolve`, but functionally it'll do largely the same, just with a lot less data copying than the current form has to do. In the new system, it's likely that the function `mesolve` itself will keep the exact same interface it has now, just internally most of its processing will be split into modular components, each of which will be accessible (with different names) to the user to compose themselves, if they want low-level access. That sounds perfect! I might wait for QuTiP 5 to come out, or if these things are already in `master`, I'll see if I can maybe revisit `DensityMatrixODEPropagator` and maybe also add something for the Hilbert space case (whatever `sesolve` is doing internally). As an aside, I was actually surprised how much better `DensityMatrixODEPropagator` performs compared to looping over `mesolve` (`In [29]` vs `In [21]`): Since the `DensityMatrixODEPropagator` also re-initializes `scipy.integrate.ode` in every time steps, it would seem like the only difference between the two is the overhead of `mesolve` deciding that it has to handle the specific case of density matrix propagation. That might be something to keep an eye on in future QuTiP development: Ideally, calling `mesolve` would have negligible overhead compared to manually doing whatev",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1571#issuecomment-860254243
https://github.com/qutip/qutip/issues/1571#issuecomment-860254243:9849,Security,access,accessible,9849,"me out, or if these things are already in `master`, I'll see if I can maybe revisit `DensityMatrixODEPropagator` and maybe also add something for the Hilbert space case (whatever `sesolve` is doing internally). As an aside, I was actually surprised how much better `DensityMatrixODEPropagator` performs compared to looping over `mesolve` (`In [29]` vs `In [21]`): Since the `DensityMatrixODEPropagator` also re-initializes `scipy.integrate.ode` in every time steps, it would seem like the only difference between the two is the overhead of `mesolve` deciding that it has to handle the specific case of density matrix propagation. That might be something to keep an eye on in future QuTiP development: Ideally, calling `mesolve` would have negligible overhead compared to manually doing whatever `mesolve` does internally for a particular case. > We're unlikely to add `yield` to `mesolve` directly because that's a very breaking change to one of QuTiP's core functions (we can't return from a generator, or at least not ergonomically), but we are splitting up the `mesolve` monolith into a much more modular architecture, and making it more user-accessible. The other advantage of this is that the integrator component will just be one element of a composable system, so we'll not be tied to scipy integrators any more. I would absolutely not expect you to modifying how `mesolve` works directly. In fact, I would strongly recommend leaving the `mesolve` interface unchanged. The internal refactoring is all I'm after here. @jakelishman in https://github.com/qutip/qutip/issues/1571#issuecomment-859917462:. > I also note that I'm not replying to the thread I thought I was - I thought I was in `krotov`! For my response to the discussion points:. Yeah, sorry the discussion got a little confused between what I was suggesting in https://github.com/qucontrol/krotov/issues/93 for myself to try out (adding a `yield` to `mesolve` as a dirty hack) and the discussion here about how to address the under",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1571#issuecomment-860254243
https://github.com/qutip/qutip/issues/1571#issuecomment-860254243:11490,Security,access,accessible,11490," the discussion got a little confused between what I was suggesting in https://github.com/qucontrol/krotov/issues/93 for myself to try out (adding a `yield` to `mesolve` as a dirty hack) and the discussion here about how to address the underlying use case properly in QuTiP itself. So just to be clear: Do *not* add a `yield` to the existing `mesolve` function in QuTiP! I would strongly recommend keeping the existing interface for `mesolve` and just refactor what is going on in the backend to enable single-time-step propagation with as little overhead as possible. > * I think the function `qutip.mesolve` shouldn't change interface at all for 5.0 - we can change its backend, but I think it'll be a huge hindrance to adoption of 5.0 if we make major breaking changes to effectively our premier function, and I don't see a need to do that. We can add, rather than change, and keep `mesolve` as the ""quick-and-dirty"" method that just works.; > * I'm in favour of exposing the different parts of the `mesolve` process as user-accessible, composable chunks. So something like exposing a `mesolve_prepare_ode(H, state, c_ops) -> OdeState` function, where `OdeState` has properties `rhs: QobjEvo`, `state: Qobj`, `time: float` (`sesolve_prepare_ode` and `mcsolve_prepare_ode` would presumably return the same object, or a derived object). Then we'd have an `Integrator` class, which encapsulates an integration step using whatever integrator of choice, so there's one that encapsulates the scipy integrator, one which is a Cython-ised RK4 implementation, etc. Then the low-level user would simply write the `for time in times` loop themselves; at this level, there's nothing fancy that QuTiP adds, so we may as well just expose it directly. That sounds like the exact right solution! ;-). > I think this architecture is approximately what Eric had in mind too, though I presumably haven't used the same names. Yeah, I think we're actually all on the same page, irrespective of minor implementation/nami",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1571#issuecomment-860254243
https://github.com/qutip/qutip/issues/1571#issuecomment-860254243:12182,Security,expose,expose,12182,"5.0 - we can change its backend, but I think it'll be a huge hindrance to adoption of 5.0 if we make major breaking changes to effectively our premier function, and I don't see a need to do that. We can add, rather than change, and keep `mesolve` as the ""quick-and-dirty"" method that just works.; > * I'm in favour of exposing the different parts of the `mesolve` process as user-accessible, composable chunks. So something like exposing a `mesolve_prepare_ode(H, state, c_ops) -> OdeState` function, where `OdeState` has properties `rhs: QobjEvo`, `state: Qobj`, `time: float` (`sesolve_prepare_ode` and `mcsolve_prepare_ode` would presumably return the same object, or a derived object). Then we'd have an `Integrator` class, which encapsulates an integration step using whatever integrator of choice, so there's one that encapsulates the scipy integrator, one which is a Cython-ised RK4 implementation, etc. Then the low-level user would simply write the `for time in times` loop themselves; at this level, there's nothing fancy that QuTiP adds, so we may as well just expose it directly. That sounds like the exact right solution! ;-). > I think this architecture is approximately what Eric had in mind too, though I presumably haven't used the same names. Yeah, I think we're actually all on the same page, irrespective of minor implementation/naming details: Have an object that keeps internal state of `mesolve` and allows to advance step-by-step. Personally, I like the naming of `MeSolver` that @Ericgig wrote out in https://github.com/qutip/qutip/issues/1571#issuecomment-858740451, but `mesolve_prepare_ode`/`OdeState` works too. @Ericgig in https://github.com/qutip/qutip/issues/1571#issuecomment-859791561:. > Most of scipy's solver are not ""thread-safe"", but we will be able to use other solvers in the new version. If you can point me to any thread-safe solver, I'd love to try that out. As already discussed above, if I can replace [`scipy.integrate.ode`](https://github.com/qucontrol/",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1571#issuecomment-860254243
https://github.com/qutip/qutip/issues/1571#issuecomment-860254243:18,Testability,benchmark,benchmarking,18,"Ok, so I did some benchmarking at https://nbviewer.ipython.org/gist/goerz/34af142b78d7e344417d838bbea78aaf/06_example_3states_benchmark.ipynb ([gist](https://gist.github.com/goerz/34af142b78d7e344417d838bbea78aaf)), based on [one of the example notebooks from the Krotov package](https://qucontrol.github.io/krotov/v1.2.1/notebooks/06_example_3states.html). I'll be referring to the numbered cells in that notebook in the discussion below. @jakelishman in https://github.com/qutip/qutip/issues/1571#issuecomment-859873615:. > I think you might be able to achieve a lot of what you want already. The pseudo-code looks like it's not using `mesolve` super efficiently, though maybe it's only because of simplifications to make a MWE. For example, if your controls are piecewise constant, then it might be inefficient to represent those terms as ""time dependent""; doing so means you incur the cost of multiplying each term by a scalar at every intermediate step the integrator chooses to take, then you have to perform the matrix-vector product for each one individually and add them up. That's certainly worth trying: when calling `mesolve` in a loop over the time grid, I did indeed see a significant speedup when summing the Lindbladian into a single constant `Qobj`, see `In [21]` vs `In [24]`. On the other hand, it doesn't always give a speedup: in the low-level [`DensityMatrixODEPropagator`](https://github.com/qucontrol/krotov/blob/cfe6b108708cdfd29ab7eee24f2112977b951ed2/src/krotov/propagators.py#L162) it actually makes the propagation slower, see `In [29]` vs `In [32]`. It's a bit surprising, but then, as you say:. > [...] This isn't guaranteed, because it involves copying rather more data _before_ the call. So that's ok. > Would something like this work for you? [...]; >; > By giving `mesolve` the Liouvillian instead of the Hamiltonian and collapse operators separately. To be clear, I personally never use collapse operators (and the Krotov documentation heavily discourages it). Inst",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1571#issuecomment-860254243
https://github.com/qutip/qutip/issues/1571#issuecomment-860254243:3870,Testability,benchmark,benchmarking,3870,"ly by a sparse matrix, and instead it'll be a Fortran-ordered dense matrix, for which the stack/unstack is a free operation. That's an extremely exciting prospect! I'd love to be able to have internal sparse data for Qobj's that represent Hamiltonians/Liouvillians, but dense data for Qobj's that represent Hilbert space states or Density matrices. In fact, it looks like a significant part of the overhead in the [calculation of the Krotov's pulse update](https://github.com/qucontrol/krotov/blob/cfe6b108708cdfd29ab7eee24f2112977b951ed2/src/krotov/optimize.py#L466) is due to the stacking/unstacking, see [`profile.svg`](https://gist.githubusercontent.com/goerz/34af142b78d7e344417d838bbea78aaf/raw/f3f49104083d59b9612f153d2f0ff652ea6a9f01/profile.svg) in the [gist](https://gist.github.com/goerz/34af142b78d7e344417d838bbea78aaf#file-profile-svg). In the benchmarking notebook, for the optimization in `In [34]`, that's the extra 6 seconds per iteration (iterations 1-3 should ideally take exactly twice as long as iteration 0, as iteration 0 is a simple forward propagation and all later iterations are one forward and one backward propagations). That's what we have in our Fortran implementation, too: the runtime of the optimization is basically just the runtime of all the internal propagations; calculating the updates should be completely negligible. There's also [shape conversions](https://github.com/qucontrol/krotov/blob/cfe6b108708cdfd29ab7eee24f2112977b951ed2/src/krotov/propagators.py#L254-L260) happening in [`DensityMatrixODEPropagator`](https://github.com/qucontrol/krotov/blob/cfe6b108708cdfd29ab7eee24f2112977b951ed2/src/krotov/propagators.py#L162) which would be nice to eliminate. Lastly, having dense internal storage for states might actually give the same speedup as we've demonstrated in https://qucontrol.github.io/krotov/v1.2.1/notebooks/09_example_numpy.html for doing Krotov with numpy arrays instead of Qobj's -- potentially even more speedup, in fact, since with nump",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1571#issuecomment-860254243
https://github.com/qutip/qutip/issues/1571#issuecomment-860254243:7600,Testability,benchmark,benchmarking,7600,"ate this overhead (like the `mesolve_prepare_ode(H, state, c_ops) -> OdeState` that you propose in https://github.com/qutip/qutip/issues/1571#issuecomment-859917462). On the other hand, looping over the full `mesolve` as in `In [19]` obviously has no problems with parallelization. I wasn't sure if that's what you meant by ""`mesolve` is re-entrant"" or whether recent changes in QuTiP now use a re-entrant internal integrator, i.e. not `scipy.integrate.ode`. At the time I implemented the [`DensityMatrixODEPropagator`](https://github.com/qucontrol/krotov/blob/cfe6b108708cdfd29ab7eee24f2112977b951ed2/src/krotov/propagators.py#L162) by looking at what `mesolve` was doing at a low level for the specific case of density matrices, `scipy.integrate.ode` was definitely being used, and that couldn't handle propagating in parallel (and by ""parallel"" I include alternating propagation steps from two different propagations). I'm also not sure what using `QobjEvo` does: In the benchmarking, there didn't seem to be any difference whether I wrap my nested lists into `QobjEvo` or not. Is there something specific that `QobjEvo` should enable that I can't do with nested lists?. > QuTiP 5 is (probably) going to formalise that (^) sort of low-level calling convention of `mesolve`, but it should work already. The new one look a bit different because instead of doing the setup very manually, there'll be a ""low-level"" function to prepare a master equation problem (and a Schrodinger equation one, etc), and then there'll be a `step` method instead of calling the ""high-level"" interface function `mesolve`, but functionally it'll do largely the same, just with a lot less data copying than the current form has to do. In the new system, it's likely that the function `mesolve` itself will keep the exact same interface it has now, just internally most of its processing will be split into modular components, each of which will be accessible (with different names) to the user to compose themselves, if the",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1571#issuecomment-860254243
https://github.com/qutip/qutip/issues/1571#issuecomment-860254243:700,Usability,simpl,simplifications,700,"Ok, so I did some benchmarking at https://nbviewer.ipython.org/gist/goerz/34af142b78d7e344417d838bbea78aaf/06_example_3states_benchmark.ipynb ([gist](https://gist.github.com/goerz/34af142b78d7e344417d838bbea78aaf)), based on [one of the example notebooks from the Krotov package](https://qucontrol.github.io/krotov/v1.2.1/notebooks/06_example_3states.html). I'll be referring to the numbered cells in that notebook in the discussion below. @jakelishman in https://github.com/qutip/qutip/issues/1571#issuecomment-859873615:. > I think you might be able to achieve a lot of what you want already. The pseudo-code looks like it's not using `mesolve` super efficiently, though maybe it's only because of simplifications to make a MWE. For example, if your controls are piecewise constant, then it might be inefficient to represent those terms as ""time dependent""; doing so means you incur the cost of multiplying each term by a scalar at every intermediate step the integrator chooses to take, then you have to perform the matrix-vector product for each one individually and add them up. That's certainly worth trying: when calling `mesolve` in a loop over the time grid, I did indeed see a significant speedup when summing the Lindbladian into a single constant `Qobj`, see `In [21]` vs `In [24]`. On the other hand, it doesn't always give a speedup: in the low-level [`DensityMatrixODEPropagator`](https://github.com/qucontrol/krotov/blob/cfe6b108708cdfd29ab7eee24f2112977b951ed2/src/krotov/propagators.py#L162) it actually makes the propagation slower, see `In [29]` vs `In [32]`. It's a bit surprising, but then, as you say:. > [...] This isn't guaranteed, because it involves copying rather more data _before_ the call. So that's ok. > Would something like this work for you? [...]; >; > By giving `mesolve` the Liouvillian instead of the Hamiltonian and collapse operators separately. To be clear, I personally never use collapse operators (and the Krotov documentation heavily discourages it). Inst",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1571#issuecomment-860254243
https://github.com/qutip/qutip/issues/1571#issuecomment-860254243:1893,Usability,clear,clear,1893,"ntermediate step the integrator chooses to take, then you have to perform the matrix-vector product for each one individually and add them up. That's certainly worth trying: when calling `mesolve` in a loop over the time grid, I did indeed see a significant speedup when summing the Lindbladian into a single constant `Qobj`, see `In [21]` vs `In [24]`. On the other hand, it doesn't always give a speedup: in the low-level [`DensityMatrixODEPropagator`](https://github.com/qucontrol/krotov/blob/cfe6b108708cdfd29ab7eee24f2112977b951ed2/src/krotov/propagators.py#L162) it actually makes the propagation slower, see `In [29]` vs `In [32]`. It's a bit surprising, but then, as you say:. > [...] This isn't guaranteed, because it involves copying rather more data _before_ the call. So that's ok. > Would something like this work for you? [...]; >; > By giving `mesolve` the Liouvillian instead of the Hamiltonian and collapse operators separately. To be clear, I personally never use collapse operators (and the Krotov documentation heavily discourages it). Instead, I have a nested list like `[L0, [L1, control1], ...]` where `L0`, `L1`, ... are super-operators. I should also note that I use `mesolve` both for Schrödinger equations and Lindblad equations (relying on `mesolve` delegating to `sesolve`), and the Krotov package uses `H` as a variable/attribute name to refer to nested-Lindbladians or nested Hamiltonians interchangeable. Sorry if that's causing a bit of confusion. I am ultimately interested both in open system and closed system dynamics interchangeably. > [...] In the 5.x series, almost all the intermediary operations should get a speed up as well (`Qobj.__init__` is getting its time slashed, and the line `current_liouvillian += control * operator` may be able to be replaced with one that applies the same in-place calculation optimisations that `mesolve` does internally). One thing you pay a nasty penalty for right now if that internally we'd keep column-stacking/unstacking",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1571#issuecomment-860254243
https://github.com/qutip/qutip/issues/1571#issuecomment-860254243:4063,Usability,simpl,simple,4063,"ly by a sparse matrix, and instead it'll be a Fortran-ordered dense matrix, for which the stack/unstack is a free operation. That's an extremely exciting prospect! I'd love to be able to have internal sparse data for Qobj's that represent Hamiltonians/Liouvillians, but dense data for Qobj's that represent Hilbert space states or Density matrices. In fact, it looks like a significant part of the overhead in the [calculation of the Krotov's pulse update](https://github.com/qucontrol/krotov/blob/cfe6b108708cdfd29ab7eee24f2112977b951ed2/src/krotov/optimize.py#L466) is due to the stacking/unstacking, see [`profile.svg`](https://gist.githubusercontent.com/goerz/34af142b78d7e344417d838bbea78aaf/raw/f3f49104083d59b9612f153d2f0ff652ea6a9f01/profile.svg) in the [gist](https://gist.github.com/goerz/34af142b78d7e344417d838bbea78aaf#file-profile-svg). In the benchmarking notebook, for the optimization in `In [34]`, that's the extra 6 seconds per iteration (iterations 1-3 should ideally take exactly twice as long as iteration 0, as iteration 0 is a simple forward propagation and all later iterations are one forward and one backward propagations). That's what we have in our Fortran implementation, too: the runtime of the optimization is basically just the runtime of all the internal propagations; calculating the updates should be completely negligible. There's also [shape conversions](https://github.com/qucontrol/krotov/blob/cfe6b108708cdfd29ab7eee24f2112977b951ed2/src/krotov/propagators.py#L254-L260) happening in [`DensityMatrixODEPropagator`](https://github.com/qucontrol/krotov/blob/cfe6b108708cdfd29ab7eee24f2112977b951ed2/src/krotov/propagators.py#L162) which would be nice to eliminate. Lastly, having dense internal storage for states might actually give the same speedup as we've demonstrated in https://qucontrol.github.io/krotov/v1.2.1/notebooks/09_example_numpy.html for doing Krotov with numpy arrays instead of Qobj's -- potentially even more speedup, in fact, since with nump",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1571#issuecomment-860254243
https://github.com/qutip/qutip/issues/1571#issuecomment-860254243:5639,Usability,clear,clear,5639,"minate. Lastly, having dense internal storage for states might actually give the same speedup as we've demonstrated in https://qucontrol.github.io/krotov/v1.2.1/notebooks/09_example_numpy.html for doing Krotov with numpy arrays instead of Qobj's -- potentially even more speedup, in fact, since with numpy now *everything* is dense (including the Hamiltonian), whereas the best thing to do numerically would be to do sparse-matrix-dense-vector operations (which is what we do in Fortran, incidentally). > In the form I've written it, this loop is thread-safe already. As it stands in the 4.x series, `mesolve` is re-entrant (I'm fairly sure), but note that it does generally mutate its arguments, especially if you pass a `QobjEvo` Liouvillian as the first argument. As long as you make sure you give each thread a distinct copy of the input Liouvillian, `mesolve` itself doesn't access global state as far as I recall. Just to be clear: there's two interconnected issues here: One is just being ""reentrant"" in the sense that I can safely have multiple `mesolve`'s run in parallel. This doesn't seem to be a problem for `mesolve` as a whole (propagating over the entire time grid). The other issue, at a lower level is whether I can keep the internal state of the integrator (`scipy.integrate.ode` or whatever else `mesolve` might be using) when propagating a single time step (and whether I can have multiple integrators to run in parallel that each safely keep track of their own state). That comes down to the integrator itself being ""reentrant"", of course. Certainly, calling `mesolve` in a loop (`In [19]`) doesn't keep the internal state of the integrator, hence the overhead between `In [21]` compared to `In [18]`. I wouldn't expect it to, of course, but the question is whether a refactoring of `mesolves` internals into an object that keeps state in a thread-safe way and allows doing time steps would alleviate this overhead (like the `mesolve_prepare_ode(H, state, c_ops) -> OdeState` tha",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1571#issuecomment-860254243
https://github.com/qutip/qutip/issues/1571#issuecomment-860254243:10758,Usability,clear,clear,10758,"is is that the integrator component will just be one element of a composable system, so we'll not be tied to scipy integrators any more. I would absolutely not expect you to modifying how `mesolve` works directly. In fact, I would strongly recommend leaving the `mesolve` interface unchanged. The internal refactoring is all I'm after here. @jakelishman in https://github.com/qutip/qutip/issues/1571#issuecomment-859917462:. > I also note that I'm not replying to the thread I thought I was - I thought I was in `krotov`! For my response to the discussion points:. Yeah, sorry the discussion got a little confused between what I was suggesting in https://github.com/qucontrol/krotov/issues/93 for myself to try out (adding a `yield` to `mesolve` as a dirty hack) and the discussion here about how to address the underlying use case properly in QuTiP itself. So just to be clear: Do *not* add a `yield` to the existing `mesolve` function in QuTiP! I would strongly recommend keeping the existing interface for `mesolve` and just refactor what is going on in the backend to enable single-time-step propagation with as little overhead as possible. > * I think the function `qutip.mesolve` shouldn't change interface at all for 5.0 - we can change its backend, but I think it'll be a huge hindrance to adoption of 5.0 if we make major breaking changes to effectively our premier function, and I don't see a need to do that. We can add, rather than change, and keep `mesolve` as the ""quick-and-dirty"" method that just works.; > * I'm in favour of exposing the different parts of the `mesolve` process as user-accessible, composable chunks. So something like exposing a `mesolve_prepare_ode(H, state, c_ops) -> OdeState` function, where `OdeState` has properties `rhs: QobjEvo`, `state: Qobj`, `time: float` (`sesolve_prepare_ode` and `mcsolve_prepare_ode` would presumably return the same object, or a derived object). Then we'd have an `Integrator` class, which encapsulates an integration step using what",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1571#issuecomment-860254243
https://github.com/qutip/qutip/issues/1571#issuecomment-860254243:12051,Usability,simpl,simply,12051,"5.0 - we can change its backend, but I think it'll be a huge hindrance to adoption of 5.0 if we make major breaking changes to effectively our premier function, and I don't see a need to do that. We can add, rather than change, and keep `mesolve` as the ""quick-and-dirty"" method that just works.; > * I'm in favour of exposing the different parts of the `mesolve` process as user-accessible, composable chunks. So something like exposing a `mesolve_prepare_ode(H, state, c_ops) -> OdeState` function, where `OdeState` has properties `rhs: QobjEvo`, `state: Qobj`, `time: float` (`sesolve_prepare_ode` and `mcsolve_prepare_ode` would presumably return the same object, or a derived object). Then we'd have an `Integrator` class, which encapsulates an integration step using whatever integrator of choice, so there's one that encapsulates the scipy integrator, one which is a Cython-ised RK4 implementation, etc. Then the low-level user would simply write the `for time in times` loop themselves; at this level, there's nothing fancy that QuTiP adds, so we may as well just expose it directly. That sounds like the exact right solution! ;-). > I think this architecture is approximately what Eric had in mind too, though I presumably haven't used the same names. Yeah, I think we're actually all on the same page, irrespective of minor implementation/naming details: Have an object that keeps internal state of `mesolve` and allows to advance step-by-step. Personally, I like the naming of `MeSolver` that @Ericgig wrote out in https://github.com/qutip/qutip/issues/1571#issuecomment-858740451, but `mesolve_prepare_ode`/`OdeState` works too. @Ericgig in https://github.com/qutip/qutip/issues/1571#issuecomment-859791561:. > Most of scipy's solver are not ""thread-safe"", but we will be able to use other solvers in the new version. If you can point me to any thread-safe solver, I'd love to try that out. As already discussed above, if I can replace [`scipy.integrate.ode`](https://github.com/qucontrol/",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1571#issuecomment-860254243
https://github.com/qutip/qutip/issues/1571#issuecomment-1226363253:202,Usability,feedback,feedback,202,"The new QuTiP solvers now support `solver.step(self, t, args=args)`. which allows manually stepping the state until time `t` with the optional supplied args. I don't think this quite addresses the full feedback possibilities, but I am noting the progress here.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1571#issuecomment-1226363253
https://github.com/qutip/qutip/pull/1573#issuecomment-866187912:1207,Integrability,interface,interface,1207,"As a comparison, here's the output of `matrix_histogram` from [the example in the _current_ build of the docs](https://qutip.org/docs/latest/guide/guide-visualization.html#visualizing-operators) (QuTiP 4.6.2):. ![QuTiP 4.6.2 guide-visualization-8](https://user-images.githubusercontent.com/5968590/122970595-06e9dc00-d386-11eb-9905-ad65f9254c0a.png). compared to the version produced by this PR:. ![this PR guide-visualization-8](https://user-images.githubusercontent.com/5968590/122970672-19641580-d386-11eb-973b-39423e53637c.png). The original certainly isn't great, but I think its defaults have produced a somewhat better result in this case. It might be worth having a look at some of the defaults here, particularly with regards to the z-axis tic labelling. While we're at it, the rainbow colour scheme is not a good choice - it'd be much better to use a diverging colourmap, and preferably something a bit more perceptually uniform. ---. I'm not completely sold on the idea that our functions should take so many different optional arguments. We return the figure and axes instances, which means anything the user can do anything that's basic matplotlib commands - we don't need to reimplement their interface. Things like the figure size, azimuth and elevation are particular examples of this - it's very simple to set them using matplotlib's interface, and we don't really provide any added benefit by having the options here. Another is the truncated colourbars: why not only accept a `cmap` argument, and allow the user to pass anything that `matplotlib.pyplot.plot` would accept? Then the interface to our function is much simplified, and the user has as much (more, even) control over the colouring.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1573#issuecomment-866187912
https://github.com/qutip/qutip/pull/1573#issuecomment-866187912:1351,Integrability,interface,interface,1351,"As a comparison, here's the output of `matrix_histogram` from [the example in the _current_ build of the docs](https://qutip.org/docs/latest/guide/guide-visualization.html#visualizing-operators) (QuTiP 4.6.2):. ![QuTiP 4.6.2 guide-visualization-8](https://user-images.githubusercontent.com/5968590/122970595-06e9dc00-d386-11eb-9905-ad65f9254c0a.png). compared to the version produced by this PR:. ![this PR guide-visualization-8](https://user-images.githubusercontent.com/5968590/122970672-19641580-d386-11eb-973b-39423e53637c.png). The original certainly isn't great, but I think its defaults have produced a somewhat better result in this case. It might be worth having a look at some of the defaults here, particularly with regards to the z-axis tic labelling. While we're at it, the rainbow colour scheme is not a good choice - it'd be much better to use a diverging colourmap, and preferably something a bit more perceptually uniform. ---. I'm not completely sold on the idea that our functions should take so many different optional arguments. We return the figure and axes instances, which means anything the user can do anything that's basic matplotlib commands - we don't need to reimplement their interface. Things like the figure size, azimuth and elevation are particular examples of this - it's very simple to set them using matplotlib's interface, and we don't really provide any added benefit by having the options here. Another is the truncated colourbars: why not only accept a `cmap` argument, and allow the user to pass anything that `matplotlib.pyplot.plot` would accept? Then the interface to our function is much simplified, and the user has as much (more, even) control over the colouring.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1573#issuecomment-866187912
https://github.com/qutip/qutip/pull/1573#issuecomment-866187912:1601,Integrability,interface,interface,1601,"As a comparison, here's the output of `matrix_histogram` from [the example in the _current_ build of the docs](https://qutip.org/docs/latest/guide/guide-visualization.html#visualizing-operators) (QuTiP 4.6.2):. ![QuTiP 4.6.2 guide-visualization-8](https://user-images.githubusercontent.com/5968590/122970595-06e9dc00-d386-11eb-9905-ad65f9254c0a.png). compared to the version produced by this PR:. ![this PR guide-visualization-8](https://user-images.githubusercontent.com/5968590/122970672-19641580-d386-11eb-973b-39423e53637c.png). The original certainly isn't great, but I think its defaults have produced a somewhat better result in this case. It might be worth having a look at some of the defaults here, particularly with regards to the z-axis tic labelling. While we're at it, the rainbow colour scheme is not a good choice - it'd be much better to use a diverging colourmap, and preferably something a bit more perceptually uniform. ---. I'm not completely sold on the idea that our functions should take so many different optional arguments. We return the figure and axes instances, which means anything the user can do anything that's basic matplotlib commands - we don't need to reimplement their interface. Things like the figure size, azimuth and elevation are particular examples of this - it's very simple to set them using matplotlib's interface, and we don't really provide any added benefit by having the options here. Another is the truncated colourbars: why not only accept a `cmap` argument, and allow the user to pass anything that `matplotlib.pyplot.plot` would accept? Then the interface to our function is much simplified, and the user has as much (more, even) control over the colouring.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1573#issuecomment-866187912
https://github.com/qutip/qutip/pull/1573#issuecomment-866187912:141,Usability,guid,guide,141,"As a comparison, here's the output of `matrix_histogram` from [the example in the _current_ build of the docs](https://qutip.org/docs/latest/guide/guide-visualization.html#visualizing-operators) (QuTiP 4.6.2):. ![QuTiP 4.6.2 guide-visualization-8](https://user-images.githubusercontent.com/5968590/122970595-06e9dc00-d386-11eb-9905-ad65f9254c0a.png). compared to the version produced by this PR:. ![this PR guide-visualization-8](https://user-images.githubusercontent.com/5968590/122970672-19641580-d386-11eb-973b-39423e53637c.png). The original certainly isn't great, but I think its defaults have produced a somewhat better result in this case. It might be worth having a look at some of the defaults here, particularly with regards to the z-axis tic labelling. While we're at it, the rainbow colour scheme is not a good choice - it'd be much better to use a diverging colourmap, and preferably something a bit more perceptually uniform. ---. I'm not completely sold on the idea that our functions should take so many different optional arguments. We return the figure and axes instances, which means anything the user can do anything that's basic matplotlib commands - we don't need to reimplement their interface. Things like the figure size, azimuth and elevation are particular examples of this - it's very simple to set them using matplotlib's interface, and we don't really provide any added benefit by having the options here. Another is the truncated colourbars: why not only accept a `cmap` argument, and allow the user to pass anything that `matplotlib.pyplot.plot` would accept? Then the interface to our function is much simplified, and the user has as much (more, even) control over the colouring.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1573#issuecomment-866187912
https://github.com/qutip/qutip/pull/1573#issuecomment-866187912:147,Usability,guid,guide-visualization,147,"As a comparison, here's the output of `matrix_histogram` from [the example in the _current_ build of the docs](https://qutip.org/docs/latest/guide/guide-visualization.html#visualizing-operators) (QuTiP 4.6.2):. ![QuTiP 4.6.2 guide-visualization-8](https://user-images.githubusercontent.com/5968590/122970595-06e9dc00-d386-11eb-9905-ad65f9254c0a.png). compared to the version produced by this PR:. ![this PR guide-visualization-8](https://user-images.githubusercontent.com/5968590/122970672-19641580-d386-11eb-973b-39423e53637c.png). The original certainly isn't great, but I think its defaults have produced a somewhat better result in this case. It might be worth having a look at some of the defaults here, particularly with regards to the z-axis tic labelling. While we're at it, the rainbow colour scheme is not a good choice - it'd be much better to use a diverging colourmap, and preferably something a bit more perceptually uniform. ---. I'm not completely sold on the idea that our functions should take so many different optional arguments. We return the figure and axes instances, which means anything the user can do anything that's basic matplotlib commands - we don't need to reimplement their interface. Things like the figure size, azimuth and elevation are particular examples of this - it's very simple to set them using matplotlib's interface, and we don't really provide any added benefit by having the options here. Another is the truncated colourbars: why not only accept a `cmap` argument, and allow the user to pass anything that `matplotlib.pyplot.plot` would accept? Then the interface to our function is much simplified, and the user has as much (more, even) control over the colouring.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1573#issuecomment-866187912
https://github.com/qutip/qutip/pull/1573#issuecomment-866187912:225,Usability,guid,guide-visualization-,225,"As a comparison, here's the output of `matrix_histogram` from [the example in the _current_ build of the docs](https://qutip.org/docs/latest/guide/guide-visualization.html#visualizing-operators) (QuTiP 4.6.2):. ![QuTiP 4.6.2 guide-visualization-8](https://user-images.githubusercontent.com/5968590/122970595-06e9dc00-d386-11eb-9905-ad65f9254c0a.png). compared to the version produced by this PR:. ![this PR guide-visualization-8](https://user-images.githubusercontent.com/5968590/122970672-19641580-d386-11eb-973b-39423e53637c.png). The original certainly isn't great, but I think its defaults have produced a somewhat better result in this case. It might be worth having a look at some of the defaults here, particularly with regards to the z-axis tic labelling. While we're at it, the rainbow colour scheme is not a good choice - it'd be much better to use a diverging colourmap, and preferably something a bit more perceptually uniform. ---. I'm not completely sold on the idea that our functions should take so many different optional arguments. We return the figure and axes instances, which means anything the user can do anything that's basic matplotlib commands - we don't need to reimplement their interface. Things like the figure size, azimuth and elevation are particular examples of this - it's very simple to set them using matplotlib's interface, and we don't really provide any added benefit by having the options here. Another is the truncated colourbars: why not only accept a `cmap` argument, and allow the user to pass anything that `matplotlib.pyplot.plot` would accept? Then the interface to our function is much simplified, and the user has as much (more, even) control over the colouring.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1573#issuecomment-866187912
https://github.com/qutip/qutip/pull/1573#issuecomment-866187912:407,Usability,guid,guide-visualization-,407,"As a comparison, here's the output of `matrix_histogram` from [the example in the _current_ build of the docs](https://qutip.org/docs/latest/guide/guide-visualization.html#visualizing-operators) (QuTiP 4.6.2):. ![QuTiP 4.6.2 guide-visualization-8](https://user-images.githubusercontent.com/5968590/122970595-06e9dc00-d386-11eb-9905-ad65f9254c0a.png). compared to the version produced by this PR:. ![this PR guide-visualization-8](https://user-images.githubusercontent.com/5968590/122970672-19641580-d386-11eb-973b-39423e53637c.png). The original certainly isn't great, but I think its defaults have produced a somewhat better result in this case. It might be worth having a look at some of the defaults here, particularly with regards to the z-axis tic labelling. While we're at it, the rainbow colour scheme is not a good choice - it'd be much better to use a diverging colourmap, and preferably something a bit more perceptually uniform. ---. I'm not completely sold on the idea that our functions should take so many different optional arguments. We return the figure and axes instances, which means anything the user can do anything that's basic matplotlib commands - we don't need to reimplement their interface. Things like the figure size, azimuth and elevation are particular examples of this - it's very simple to set them using matplotlib's interface, and we don't really provide any added benefit by having the options here. Another is the truncated colourbars: why not only accept a `cmap` argument, and allow the user to pass anything that `matplotlib.pyplot.plot` would accept? Then the interface to our function is much simplified, and the user has as much (more, even) control over the colouring.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1573#issuecomment-866187912
https://github.com/qutip/qutip/pull/1573#issuecomment-866187912:1313,Usability,simpl,simple,1313,"As a comparison, here's the output of `matrix_histogram` from [the example in the _current_ build of the docs](https://qutip.org/docs/latest/guide/guide-visualization.html#visualizing-operators) (QuTiP 4.6.2):. ![QuTiP 4.6.2 guide-visualization-8](https://user-images.githubusercontent.com/5968590/122970595-06e9dc00-d386-11eb-9905-ad65f9254c0a.png). compared to the version produced by this PR:. ![this PR guide-visualization-8](https://user-images.githubusercontent.com/5968590/122970672-19641580-d386-11eb-973b-39423e53637c.png). The original certainly isn't great, but I think its defaults have produced a somewhat better result in this case. It might be worth having a look at some of the defaults here, particularly with regards to the z-axis tic labelling. While we're at it, the rainbow colour scheme is not a good choice - it'd be much better to use a diverging colourmap, and preferably something a bit more perceptually uniform. ---. I'm not completely sold on the idea that our functions should take so many different optional arguments. We return the figure and axes instances, which means anything the user can do anything that's basic matplotlib commands - we don't need to reimplement their interface. Things like the figure size, azimuth and elevation are particular examples of this - it's very simple to set them using matplotlib's interface, and we don't really provide any added benefit by having the options here. Another is the truncated colourbars: why not only accept a `cmap` argument, and allow the user to pass anything that `matplotlib.pyplot.plot` would accept? Then the interface to our function is much simplified, and the user has as much (more, even) control over the colouring.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1573#issuecomment-866187912
https://github.com/qutip/qutip/pull/1573#issuecomment-866187912:1635,Usability,simpl,simplified,1635,"As a comparison, here's the output of `matrix_histogram` from [the example in the _current_ build of the docs](https://qutip.org/docs/latest/guide/guide-visualization.html#visualizing-operators) (QuTiP 4.6.2):. ![QuTiP 4.6.2 guide-visualization-8](https://user-images.githubusercontent.com/5968590/122970595-06e9dc00-d386-11eb-9905-ad65f9254c0a.png). compared to the version produced by this PR:. ![this PR guide-visualization-8](https://user-images.githubusercontent.com/5968590/122970672-19641580-d386-11eb-973b-39423e53637c.png). The original certainly isn't great, but I think its defaults have produced a somewhat better result in this case. It might be worth having a look at some of the defaults here, particularly with regards to the z-axis tic labelling. While we're at it, the rainbow colour scheme is not a good choice - it'd be much better to use a diverging colourmap, and preferably something a bit more perceptually uniform. ---. I'm not completely sold on the idea that our functions should take so many different optional arguments. We return the figure and axes instances, which means anything the user can do anything that's basic matplotlib commands - we don't need to reimplement their interface. Things like the figure size, azimuth and elevation are particular examples of this - it's very simple to set them using matplotlib's interface, and we don't really provide any added benefit by having the options here. Another is the truncated colourbars: why not only accept a `cmap` argument, and allow the user to pass anything that `matplotlib.pyplot.plot` would accept? Then the interface to our function is much simplified, and the user has as much (more, even) control over the colouring.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1573#issuecomment-866187912
https://github.com/qutip/qutip/pull/1573#issuecomment-867217699:166,Integrability,depend,depends,166,"@Ericgig ,@jakelishman thanks for reviews and the comments. I agree with Jake, the default `'jet'` colormap isn't very nice and I believe choosing the right colormap depends on the problem and values of the input matrix `M`. Personaly I love to have 0s in white and the others colored and that's because non-zeros elements maybe important and should catch the attention.; I thinks the code (in docs) producing the input matrix should be changed and that's because:; 1- it has lots of off-diagonal elements which raises the renown problem of overlaping bars. ; 2- maximum value and minum value of input matrix are very different and nearly non of the colormaps makes the results nice. Showing a thermal state's density matrix maybe a good option:; ```python; from qutip import thermal_dm, matrix_histogram. rho_th = thermal_dm(6,2); options = {'cmap':'hot_r',; 'stick': True,; 'cbar_pad':.0,; 'zticks':[0, 0.365, 0.5],; 'azim':65,; 'elev':35,; 'shade': False}; matrix_histogram(rho_th, limits=[0,0.5],options=options); ```; ![anim1](https://user-images.githubusercontent.com/24582081/123172512-7cdb6980-d492-11eb-9133-e3492e73d948.gif). **the old one:**. ![anim2](https://user-images.githubusercontent.com/24582081/123172639-a5636380-d492-11eb-98e0-75da9ad6f96e.gif). I agree that because the function returns `fig` and `ax` the user can modify nearly everything, but most of them may not be easy to implement for everyone. If we want the colors to be less flashy we have to set `shade` to `True` and there are 2 problems with turning on the shading:; 1- bars with nearly equal values have different colors (like 0s); 2- in some azimuthal viewing angle the `lightsource` produces shadows. ![mat_hist_new_azim=30](https://user-images.githubusercontent.com/24582081/123178802-37706980-d49d-11eb-97ca-afb3539c69eb.jpg); **turing around by 180°:**; ![mat_hist_new_azim=210](https://user-images.githubusercontent.com/24582081/123178811-3d664a80-d49d-11eb-991d-17b3179a784e.jpg). the second one can be solved",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1573#issuecomment-867217699
https://github.com/qutip/qutip/pull/1574#issuecomment-861634545:218,Testability,test,tests-to-github-actions,218,[![Coverage Status](https://coveralls.io/builds/40603210/badge)](https://coveralls.io/builds/40603210). Coverage increased (+0.2%) to 65.597% when pulling **c446e4acd0e4b87a7993a9861440debe5436023b on jakelishman:move-tests-to-github-actions** into **be241cac446062f8817f61ee4f14a6cbdb8351a6 on qutip:dev.major**.,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1574#issuecomment-861634545
https://github.com/qutip/qutip/pull/1574#issuecomment-861647038:177,Usability,clear,clearly,177,"@hodgestar: I'll leave this for a bit if you want to review it, but it's _almost_ all just code that we've already included in `master`. There's several points where things can clearly be improved (`__init__.py`), but that's also the case on `master`, and so far it's not been a super high priority.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1574#issuecomment-861647038
https://github.com/qutip/qutip/pull/1574#issuecomment-861857564:33,Performance,load,load,33,Absolutely - it already helped a load on `master` to catch pending deprecations and old code. As soon as we've got the warnings fixed on `dev.major` we'll turn it right back on.,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1574#issuecomment-861857564
https://github.com/qutip/qutip/pull/1575#issuecomment-861872837:69,Integrability,interface,interface,69,"We can remove it here. It is working but does not have a user facing interface or documentation, so I don't think any user use it.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1575#issuecomment-861872837
https://github.com/qutip/qutip/pull/1575#issuecomment-862288347:233,Availability,error,errors,233,"Ok, cool. I'll merge this and we can remove unused bits of `mcsolve` in a different PR. > 139 lines of only white space change in pulsegen.py!. I was just searching for `np.random` in the codebase and fixing files with that and pep8 errors, but I think there might be quite a few more hiding in the control module!",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1575#issuecomment-862288347
https://github.com/qutip/qutip/pull/1577#issuecomment-862377861:44,Availability,failure,failures,44,"Note: it _did_ cause additional CodeClimate failures. I manually approved the run from within CodeClimate (you can see that in the output of the checks). Unfortunately the duplication checker still errors out on a lot of files, because it seems to choke on complex numbers, so we actually don't get detection on loads of our files (not to mention all our Cython files).",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1577#issuecomment-862377861
https://github.com/qutip/qutip/pull/1577#issuecomment-862377861:198,Availability,error,errors,198,"Note: it _did_ cause additional CodeClimate failures. I manually approved the run from within CodeClimate (you can see that in the output of the checks). Unfortunately the duplication checker still errors out on a lot of files, because it seems to choke on complex numbers, so we actually don't get detection on loads of our files (not to mention all our Cython files).",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1577#issuecomment-862377861
https://github.com/qutip/qutip/pull/1577#issuecomment-862377861:312,Performance,load,loads,312,"Note: it _did_ cause additional CodeClimate failures. I manually approved the run from within CodeClimate (you can see that in the output of the checks). Unfortunately the duplication checker still errors out on a lot of files, because it seems to choke on complex numbers, so we actually don't get detection on loads of our files (not to mention all our Cython files).",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1577#issuecomment-862377861
https://github.com/qutip/qutip/pull/1577#issuecomment-862377861:299,Safety,detect,detection,299,"Note: it _did_ cause additional CodeClimate failures. I manually approved the run from within CodeClimate (you can see that in the output of the checks). Unfortunately the duplication checker still errors out on a lot of files, because it seems to choke on complex numbers, so we actually don't get detection on loads of our files (not to mention all our Cython files).",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1577#issuecomment-862377861
https://github.com/qutip/qutip/pull/1577#issuecomment-862563893:186,Availability,down,down,186,I've made codeclimate/codeclimate-duplication#364 to hopefully fix the complex-number parsing problem. Now we need to work on tidying up as much legacy code as we can to get the numbers down!,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1577#issuecomment-862563893
https://github.com/qutip/qutip/pull/1579#issuecomment-863997684:146,Integrability,wrap,wrapped,146,"Note: the reported changes (other than the deletion of the licence from each source file) are all whitespace-only, or simply a reflow of the hard-wrapped text in `LICENSE.txt`. I didn't change the licence at all, other than the holder. I've also checked this with the same tool that GitHub uses, and it will definitely recognise the licence correctly after this. The whitespace-only changes in other files weren't actually 100% intended, but it was a function of how I did the licence detection - I normalised the whitespace at the ends of lines first. Looking through, I guess I only did that when changing the `doc` folder, not the main source code (I had to handle those two cases separately).",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1579#issuecomment-863997684
https://github.com/qutip/qutip/pull/1579#issuecomment-863997684:485,Safety,detect,detection,485,"Note: the reported changes (other than the deletion of the licence from each source file) are all whitespace-only, or simply a reflow of the hard-wrapped text in `LICENSE.txt`. I didn't change the licence at all, other than the holder. I've also checked this with the same tool that GitHub uses, and it will definitely recognise the licence correctly after this. The whitespace-only changes in other files weren't actually 100% intended, but it was a function of how I did the licence detection - I normalised the whitespace at the ends of lines first. Looking through, I guess I only did that when changing the `doc` folder, not the main source code (I had to handle those two cases separately).",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1579#issuecomment-863997684
https://github.com/qutip/qutip/pull/1579#issuecomment-863997684:118,Usability,simpl,simply,118,"Note: the reported changes (other than the deletion of the licence from each source file) are all whitespace-only, or simply a reflow of the hard-wrapped text in `LICENSE.txt`. I didn't change the licence at all, other than the holder. I've also checked this with the same tool that GitHub uses, and it will definitely recognise the licence correctly after this. The whitespace-only changes in other files weren't actually 100% intended, but it was a function of how I did the licence detection - I normalised the whitespace at the ends of lines first. Looking through, I guess I only did that when changing the `doc` folder, not the main source code (I had to handle those two cases separately).",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1579#issuecomment-863997684
https://github.com/qutip/qutip/pull/1579#issuecomment-864019462:572,Safety,safe,safe,572,"Can this be done legally?; Is it acceptable to remove the copyright in the files?; We would be changing the owner of the code. In #1405, it has to have the Nasa copyright by agency policy:; ```; Copyright 2020 United States Government as represented by the Administrator; of the National Aeronautics and Space Administration. All Rights Reserved; ```; I think we could have legal issues if we removed this without their permission. While I agree with removing the ~30 lines header with the license in each file, we should keep the copyright lines unless we can confirm it safe to do so. Luckily, it is mostly Paul, Robert and Alex that have specified it and if they agree then I guess it fine. But if any other contributor added their copyright, we should keep it.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1579#issuecomment-864019462
https://github.com/qutip/qutip/pull/1579#issuecomment-864022506:947,Availability,down,down,947,"This can - see e.g. Numpy that uses the same licence. #1405 would add its additional copyright to the top of the file. This is actually _more_ useful in that case - it's far clearer that that code is under different licence conditions. That said, I'm really not certain about accepting #1405 in its current form. It's not using the data-layer correctly at all, and if we were to include it, we'd really want to do something like that in a more structured way in core QuTiP. Really it should be a properly dispatched implementation of `einsum`, but I think this should come in as part of a much larger discussion on how to handle tensor networks completely; to have it be nice and ergonomic in all cases, I think this will come in at the same time or after the introduction of new dimensions objects. I'm also very wary of introducing code to QuTiP which is licensed by a different holder. I can only imagine that that will really give us problems down the line - how long would NASA own the copyright on that code, for example? Could we modify it? After how many modifications is it no longer NASA's? We wouldn't have control over anything like that, and I think it's probably more hassle than it's worth on our side.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1579#issuecomment-864022506
https://github.com/qutip/qutip/pull/1579#issuecomment-864022506:174,Usability,clear,clearer,174,"This can - see e.g. Numpy that uses the same licence. #1405 would add its additional copyright to the top of the file. This is actually _more_ useful in that case - it's far clearer that that code is under different licence conditions. That said, I'm really not certain about accepting #1405 in its current form. It's not using the data-layer correctly at all, and if we were to include it, we'd really want to do something like that in a more structured way in core QuTiP. Really it should be a properly dispatched implementation of `einsum`, but I think this should come in as part of a much larger discussion on how to handle tensor networks completely; to have it be nice and ergonomic in all cases, I think this will come in at the same time or after the introduction of new dimensions objects. I'm also very wary of introducing code to QuTiP which is licensed by a different holder. I can only imagine that that will really give us problems down the line - how long would NASA own the copyright on that code, for example? Could we modify it? After how many modifications is it no longer NASA's? We wouldn't have control over anything like that, and I think it's probably more hassle than it's worth on our side.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1579#issuecomment-864022506
https://github.com/qutip/qutip/pull/1579#issuecomment-864032584:66,Usability,clear,clear,66,"The NASA copyright needs to be there. As it stands now, it is not clear what the license actually means though, i.e. it is embedded in the QuTiP license which does not make any sense. So that needs to be cleaned up before approval. However, if it is truly BSD licensed then the copyright does not matter for derivative works as it gives permission to do whatever one wants provided the original copyright remains. I am personally fine with the copyright changes going forward. I am not part of the admin team (by choice), but there is a decade of git commits that show my share the the work, and making the cp more broadly applied to QuTiP admin / devs make s a lot of sense going forward.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1579#issuecomment-864032584
https://github.com/qutip/qutip/pull/1579#issuecomment-864038744:808,Testability,assert,asserting,808,"@nonhermitian: we haven't accept #1405 (and also I don't think we will soon, because it'll be part of larger changes), but yeah, if it is accepted, it would need to carry its entire licence with it in the file. We already do this somewhere with a vendored version of `Qcircuit.tex` though that's a whole other can of worms, because that's GPL'd, and I'm really not sure it's legally correct that we've done that. (also sidenote: thanks to you, I'm starting at IBM in Lev Bishop's team on the 5th of July - I've just put in the requisition for my computer!). On second thoughts, surely the more correct solution is to have the main licence read ""Copyright 2011-2021 Rob and Paul, 2021 onwards admin team""? That's more historically accurate, for sure. Another question: does anybody know about the legality of asserting copyright ""2011 and onwards"" in general? Numpy put in specific years, and bump the end year by commit. I'm mostly in favour of moving the licencing to the single `LICENSE.txt` file in order to make all these instances of separately licenced code easier to see and maintain. It also seems to be the way other large-scale open-source projects handle their licensing, it makes it much easier for us to manage the licensing of the entire project. I really don't want to rush this. I don't want to merge it without a proper discussion in a full admin meeting. I'm just trying to put it up ahead of time.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1579#issuecomment-864038744
https://github.com/qutip/qutip/pull/1579#issuecomment-864049973:331,Testability,assert,asserting,331,"> though that's a whole other can of worms, because that's GPL'd. Yes, if it is GPL then it should be removed. That license can be construed to mean that all other pieces of code that use it must be under the same license; One can read the license as all derivative works must be GPL. So I would revert that PR ASAP. > legality of asserting copyright ""2011 and onwards"" in general. Yeah putting years I think is the correct thing. Didn't know that at the time. > I'm starting at IBM in Lev Bishop's team on the 5th of July. Look forward to talking to you in July!",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1579#issuecomment-864049973
https://github.com/qutip/qutip/pull/1579#issuecomment-864059845:1464,Availability,redundant,redundant,1464,"The `Qcircuit.tex` PR was unfortunately many many years ago, long before I made my first commit to QuTiP (according to `git log` it was by Anubhav Vardhan in 2014), so the damage is already done. It was on my mind because there was a PR about updating the version of the code in it (#1187). Nonetheless, we definitely should remove it. @BoxiLi Boxi: `Qcircuit.tex` is a concern for `qutip-qip` more than the main library from 5.0 onwards - it's currently in `qip/circuit_latex.py`, which we'll have removed, but you've gained. It might be most appropriate to handle this the same way Qiskit does - generate code which does `\usepackage{qcircuit}`, and leave it up to the user to have a properly-provisioned LaTeX environment. I note that `qcircuit` is included in MikTeX and TexLive since at least 2018 (but not sure when exactly it was added). > Yeah putting years I think is the correct thing. Didn't know that at the time. Ah, that's good to know, thanks. I'm trying to learn more about licensing - I'm trying to get it sorted now into the right form, but it's a really complicated field. I think if we change `LICENCE.txt` to. ```text; Copyright (c) 2011--2021 Paul Nation and Robert Johansson.; Copyright (c) 2021--2021 QuTiP Admin Team.; All rights reserved. <BSD 3-clause licence>; ```. and update the final `2021` as appropriate, we'll be in the best standing. That's also why we might want to remove the general licence text from each file - it's already redundant, but it'll be much harder to update if we have it scattered everywhere (automation would run the risk of us messing up and changing any external code's licence as well, I think, which would be wrong). > Look forward to talking to you in July!. Me too!",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1579#issuecomment-864059845
https://github.com/qutip/qutip/pull/1579#issuecomment-864059845:1298,Deployability,update,update,1298,"The `Qcircuit.tex` PR was unfortunately many many years ago, long before I made my first commit to QuTiP (according to `git log` it was by Anubhav Vardhan in 2014), so the damage is already done. It was on my mind because there was a PR about updating the version of the code in it (#1187). Nonetheless, we definitely should remove it. @BoxiLi Boxi: `Qcircuit.tex` is a concern for `qutip-qip` more than the main library from 5.0 onwards - it's currently in `qip/circuit_latex.py`, which we'll have removed, but you've gained. It might be most appropriate to handle this the same way Qiskit does - generate code which does `\usepackage{qcircuit}`, and leave it up to the user to have a properly-provisioned LaTeX environment. I note that `qcircuit` is included in MikTeX and TexLive since at least 2018 (but not sure when exactly it was added). > Yeah putting years I think is the correct thing. Didn't know that at the time. Ah, that's good to know, thanks. I'm trying to learn more about licensing - I'm trying to get it sorted now into the right form, but it's a really complicated field. I think if we change `LICENCE.txt` to. ```text; Copyright (c) 2011--2021 Paul Nation and Robert Johansson.; Copyright (c) 2021--2021 QuTiP Admin Team.; All rights reserved. <BSD 3-clause licence>; ```. and update the final `2021` as appropriate, we'll be in the best standing. That's also why we might want to remove the general licence text from each file - it's already redundant, but it'll be much harder to update if we have it scattered everywhere (automation would run the risk of us messing up and changing any external code's licence as well, I think, which would be wrong). > Look forward to talking to you in July!. Me too!",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1579#issuecomment-864059845
https://github.com/qutip/qutip/pull/1579#issuecomment-864059845:1503,Deployability,update,update,1503,"The `Qcircuit.tex` PR was unfortunately many many years ago, long before I made my first commit to QuTiP (according to `git log` it was by Anubhav Vardhan in 2014), so the damage is already done. It was on my mind because there was a PR about updating the version of the code in it (#1187). Nonetheless, we definitely should remove it. @BoxiLi Boxi: `Qcircuit.tex` is a concern for `qutip-qip` more than the main library from 5.0 onwards - it's currently in `qip/circuit_latex.py`, which we'll have removed, but you've gained. It might be most appropriate to handle this the same way Qiskit does - generate code which does `\usepackage{qcircuit}`, and leave it up to the user to have a properly-provisioned LaTeX environment. I note that `qcircuit` is included in MikTeX and TexLive since at least 2018 (but not sure when exactly it was added). > Yeah putting years I think is the correct thing. Didn't know that at the time. Ah, that's good to know, thanks. I'm trying to learn more about licensing - I'm trying to get it sorted now into the right form, but it's a really complicated field. I think if we change `LICENCE.txt` to. ```text; Copyright (c) 2011--2021 Paul Nation and Robert Johansson.; Copyright (c) 2021--2021 QuTiP Admin Team.; All rights reserved. <BSD 3-clause licence>; ```. and update the final `2021` as appropriate, we'll be in the best standing. That's also why we might want to remove the general licence text from each file - it's already redundant, but it'll be much harder to update if we have it scattered everywhere (automation would run the risk of us messing up and changing any external code's licence as well, I think, which would be wrong). > Look forward to talking to you in July!. Me too!",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1579#issuecomment-864059845
https://github.com/qutip/qutip/pull/1579#issuecomment-864059845:1464,Safety,redund,redundant,1464,"The `Qcircuit.tex` PR was unfortunately many many years ago, long before I made my first commit to QuTiP (according to `git log` it was by Anubhav Vardhan in 2014), so the damage is already done. It was on my mind because there was a PR about updating the version of the code in it (#1187). Nonetheless, we definitely should remove it. @BoxiLi Boxi: `Qcircuit.tex` is a concern for `qutip-qip` more than the main library from 5.0 onwards - it's currently in `qip/circuit_latex.py`, which we'll have removed, but you've gained. It might be most appropriate to handle this the same way Qiskit does - generate code which does `\usepackage{qcircuit}`, and leave it up to the user to have a properly-provisioned LaTeX environment. I note that `qcircuit` is included in MikTeX and TexLive since at least 2018 (but not sure when exactly it was added). > Yeah putting years I think is the correct thing. Didn't know that at the time. Ah, that's good to know, thanks. I'm trying to learn more about licensing - I'm trying to get it sorted now into the right form, but it's a really complicated field. I think if we change `LICENCE.txt` to. ```text; Copyright (c) 2011--2021 Paul Nation and Robert Johansson.; Copyright (c) 2021--2021 QuTiP Admin Team.; All rights reserved. <BSD 3-clause licence>; ```. and update the final `2021` as appropriate, we'll be in the best standing. That's also why we might want to remove the general licence text from each file - it's already redundant, but it'll be much harder to update if we have it scattered everywhere (automation would run the risk of us messing up and changing any external code's licence as well, I think, which would be wrong). > Look forward to talking to you in July!. Me too!",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1579#issuecomment-864059845
https://github.com/qutip/qutip/pull/1579#issuecomment-864059845:1571,Safety,risk,risk,1571,"The `Qcircuit.tex` PR was unfortunately many many years ago, long before I made my first commit to QuTiP (according to `git log` it was by Anubhav Vardhan in 2014), so the damage is already done. It was on my mind because there was a PR about updating the version of the code in it (#1187). Nonetheless, we definitely should remove it. @BoxiLi Boxi: `Qcircuit.tex` is a concern for `qutip-qip` more than the main library from 5.0 onwards - it's currently in `qip/circuit_latex.py`, which we'll have removed, but you've gained. It might be most appropriate to handle this the same way Qiskit does - generate code which does `\usepackage{qcircuit}`, and leave it up to the user to have a properly-provisioned LaTeX environment. I note that `qcircuit` is included in MikTeX and TexLive since at least 2018 (but not sure when exactly it was added). > Yeah putting years I think is the correct thing. Didn't know that at the time. Ah, that's good to know, thanks. I'm trying to learn more about licensing - I'm trying to get it sorted now into the right form, but it's a really complicated field. I think if we change `LICENCE.txt` to. ```text; Copyright (c) 2011--2021 Paul Nation and Robert Johansson.; Copyright (c) 2021--2021 QuTiP Admin Team.; All rights reserved. <BSD 3-clause licence>; ```. and update the final `2021` as appropriate, we'll be in the best standing. That's also why we might want to remove the general licence text from each file - it's already redundant, but it'll be much harder to update if we have it scattered everywhere (automation would run the risk of us messing up and changing any external code's licence as well, I think, which would be wrong). > Look forward to talking to you in July!. Me too!",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1579#issuecomment-864059845
https://github.com/qutip/qutip/pull/1579#issuecomment-864059845:124,Testability,log,log,124,"The `Qcircuit.tex` PR was unfortunately many many years ago, long before I made my first commit to QuTiP (according to `git log` it was by Anubhav Vardhan in 2014), so the damage is already done. It was on my mind because there was a PR about updating the version of the code in it (#1187). Nonetheless, we definitely should remove it. @BoxiLi Boxi: `Qcircuit.tex` is a concern for `qutip-qip` more than the main library from 5.0 onwards - it's currently in `qip/circuit_latex.py`, which we'll have removed, but you've gained. It might be most appropriate to handle this the same way Qiskit does - generate code which does `\usepackage{qcircuit}`, and leave it up to the user to have a properly-provisioned LaTeX environment. I note that `qcircuit` is included in MikTeX and TexLive since at least 2018 (but not sure when exactly it was added). > Yeah putting years I think is the correct thing. Didn't know that at the time. Ah, that's good to know, thanks. I'm trying to learn more about licensing - I'm trying to get it sorted now into the right form, but it's a really complicated field. I think if we change `LICENCE.txt` to. ```text; Copyright (c) 2011--2021 Paul Nation and Robert Johansson.; Copyright (c) 2021--2021 QuTiP Admin Team.; All rights reserved. <BSD 3-clause licence>; ```. and update the final `2021` as appropriate, we'll be in the best standing. That's also why we might want to remove the general licence text from each file - it's already redundant, but it'll be much harder to update if we have it scattered everywhere (automation would run the risk of us messing up and changing any external code's licence as well, I think, which would be wrong). > Look forward to talking to you in July!. Me too!",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1579#issuecomment-864059845
https://github.com/qutip/qutip/pull/1579#issuecomment-864059845:973,Usability,learn,learn,973,"The `Qcircuit.tex` PR was unfortunately many many years ago, long before I made my first commit to QuTiP (according to `git log` it was by Anubhav Vardhan in 2014), so the damage is already done. It was on my mind because there was a PR about updating the version of the code in it (#1187). Nonetheless, we definitely should remove it. @BoxiLi Boxi: `Qcircuit.tex` is a concern for `qutip-qip` more than the main library from 5.0 onwards - it's currently in `qip/circuit_latex.py`, which we'll have removed, but you've gained. It might be most appropriate to handle this the same way Qiskit does - generate code which does `\usepackage{qcircuit}`, and leave it up to the user to have a properly-provisioned LaTeX environment. I note that `qcircuit` is included in MikTeX and TexLive since at least 2018 (but not sure when exactly it was added). > Yeah putting years I think is the correct thing. Didn't know that at the time. Ah, that's good to know, thanks. I'm trying to learn more about licensing - I'm trying to get it sorted now into the right form, but it's a really complicated field. I think if we change `LICENCE.txt` to. ```text; Copyright (c) 2011--2021 Paul Nation and Robert Johansson.; Copyright (c) 2021--2021 QuTiP Admin Team.; All rights reserved. <BSD 3-clause licence>; ```. and update the final `2021` as appropriate, we'll be in the best standing. That's also why we might want to remove the general licence text from each file - it's already redundant, but it'll be much harder to update if we have it scattered everywhere (automation would run the risk of us messing up and changing any external code's licence as well, I think, which would be wrong). > Look forward to talking to you in July!. Me too!",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1579#issuecomment-864059845
https://github.com/qutip/qutip/pull/1579#issuecomment-864092614:334,Usability,learn,learn,334,"@nathanshammah: already on the agenda. The splitting seems like a good plan. I would have thought that part of making it uniform would be to remove the lines from each file, so it can be centrally managed. That way, only files that have different licence terms need to note it. This is the way that Numpy, Scipy, CuPy, pandas, scikit-learn, etc etc all handle licensing - none of those specify copyright information in each file, and they all use the exact same licence as QuTiP (except CuPy, which is MIT). If we were GPL'd (like mitiq), we'd have to include the licence, as I understand it, but 3-clause BSD only requires you include the licence file itself.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1579#issuecomment-864092614
https://github.com/qutip/qutip/pull/1579#issuecomment-866977298:87,Deployability,update,updated,87,"@nathanshammah, @Ericgig, @ajgpitch, @nwlambert, @quantshah, @BoxiLi, @hodgestar. I've updated this PR to match what I understand we agreed on. I've also added complete copyright notices to the documentation, including linking the CC-BY-3.0 licence the documentation text is licensed under, and making it clear that it's the documentation _text_ licensed under CC, and that the code is under 3-clause BSD. I've updated the frontmatter, and added a copyright notice to the index, so it's linked from every page in the documentation releases. I have updated the short copyright notice at the bottom of the documentation pages to say ""Copyright 2011 to 2021 inclusive, QuTiP developers and contributors"" to make it consistent with the source code (for the same reasons). As I've added a `_copyright` Sphinx target, the word ""Copyright"" at the bottom of the documentation is now hyperlinked as well. I didn't explicitly split this into more than one PR, but it's split into separate logical commits, which explain their extent and intent.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1579#issuecomment-866977298
https://github.com/qutip/qutip/pull/1579#issuecomment-866977298:411,Deployability,update,updated,411,"@nathanshammah, @Ericgig, @ajgpitch, @nwlambert, @quantshah, @BoxiLi, @hodgestar. I've updated this PR to match what I understand we agreed on. I've also added complete copyright notices to the documentation, including linking the CC-BY-3.0 licence the documentation text is licensed under, and making it clear that it's the documentation _text_ licensed under CC, and that the code is under 3-clause BSD. I've updated the frontmatter, and added a copyright notice to the index, so it's linked from every page in the documentation releases. I have updated the short copyright notice at the bottom of the documentation pages to say ""Copyright 2011 to 2021 inclusive, QuTiP developers and contributors"" to make it consistent with the source code (for the same reasons). As I've added a `_copyright` Sphinx target, the word ""Copyright"" at the bottom of the documentation is now hyperlinked as well. I didn't explicitly split this into more than one PR, but it's split into separate logical commits, which explain their extent and intent.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1579#issuecomment-866977298
https://github.com/qutip/qutip/pull/1579#issuecomment-866977298:531,Deployability,release,releases,531,"@nathanshammah, @Ericgig, @ajgpitch, @nwlambert, @quantshah, @BoxiLi, @hodgestar. I've updated this PR to match what I understand we agreed on. I've also added complete copyright notices to the documentation, including linking the CC-BY-3.0 licence the documentation text is licensed under, and making it clear that it's the documentation _text_ licensed under CC, and that the code is under 3-clause BSD. I've updated the frontmatter, and added a copyright notice to the index, so it's linked from every page in the documentation releases. I have updated the short copyright notice at the bottom of the documentation pages to say ""Copyright 2011 to 2021 inclusive, QuTiP developers and contributors"" to make it consistent with the source code (for the same reasons). As I've added a `_copyright` Sphinx target, the word ""Copyright"" at the bottom of the documentation is now hyperlinked as well. I didn't explicitly split this into more than one PR, but it's split into separate logical commits, which explain their extent and intent.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1579#issuecomment-866977298
https://github.com/qutip/qutip/pull/1579#issuecomment-866977298:548,Deployability,update,updated,548,"@nathanshammah, @Ericgig, @ajgpitch, @nwlambert, @quantshah, @BoxiLi, @hodgestar. I've updated this PR to match what I understand we agreed on. I've also added complete copyright notices to the documentation, including linking the CC-BY-3.0 licence the documentation text is licensed under, and making it clear that it's the documentation _text_ licensed under CC, and that the code is under 3-clause BSD. I've updated the frontmatter, and added a copyright notice to the index, so it's linked from every page in the documentation releases. I have updated the short copyright notice at the bottom of the documentation pages to say ""Copyright 2011 to 2021 inclusive, QuTiP developers and contributors"" to make it consistent with the source code (for the same reasons). As I've added a `_copyright` Sphinx target, the word ""Copyright"" at the bottom of the documentation is now hyperlinked as well. I didn't explicitly split this into more than one PR, but it's split into separate logical commits, which explain their extent and intent.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1579#issuecomment-866977298
https://github.com/qutip/qutip/pull/1579#issuecomment-866977298:979,Testability,log,logical,979,"@nathanshammah, @Ericgig, @ajgpitch, @nwlambert, @quantshah, @BoxiLi, @hodgestar. I've updated this PR to match what I understand we agreed on. I've also added complete copyright notices to the documentation, including linking the CC-BY-3.0 licence the documentation text is licensed under, and making it clear that it's the documentation _text_ licensed under CC, and that the code is under 3-clause BSD. I've updated the frontmatter, and added a copyright notice to the index, so it's linked from every page in the documentation releases. I have updated the short copyright notice at the bottom of the documentation pages to say ""Copyright 2011 to 2021 inclusive, QuTiP developers and contributors"" to make it consistent with the source code (for the same reasons). As I've added a `_copyright` Sphinx target, the word ""Copyright"" at the bottom of the documentation is now hyperlinked as well. I didn't explicitly split this into more than one PR, but it's split into separate logical commits, which explain their extent and intent.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1579#issuecomment-866977298
https://github.com/qutip/qutip/pull/1579#issuecomment-866977298:305,Usability,clear,clear,305,"@nathanshammah, @Ericgig, @ajgpitch, @nwlambert, @quantshah, @BoxiLi, @hodgestar. I've updated this PR to match what I understand we agreed on. I've also added complete copyright notices to the documentation, including linking the CC-BY-3.0 licence the documentation text is licensed under, and making it clear that it's the documentation _text_ licensed under CC, and that the code is under 3-clause BSD. I've updated the frontmatter, and added a copyright notice to the index, so it's linked from every page in the documentation releases. I have updated the short copyright notice at the bottom of the documentation pages to say ""Copyright 2011 to 2021 inclusive, QuTiP developers and contributors"" to make it consistent with the source code (for the same reasons). As I've added a `_copyright` Sphinx target, the word ""Copyright"" at the bottom of the documentation is now hyperlinked as well. I didn't explicitly split this into more than one PR, but it's split into separate logical commits, which explain their extent and intent.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1579#issuecomment-866977298
https://github.com/qutip/qutip/pull/1579#issuecomment-867019111:994,Integrability,interface,interface,994,"@hodgestar: those comments lines you've highlighted were a careless mistake - they shouldn't have been removed, but it's a function of how I implemented the automated removal. I didn't notice them when I checked it through. I've restored them. The `cython: language_level=3` lines in particular are especially important to maintain, so that was very careless of me. That said, utf-8 is the default encoding for Python 3, so those lines aren't actually necessary at all any more. That wasn't the case with Python 2 (which assumed ASCII), but it's no longer an issue. Regardless, I've restored them because this PR wasn't meant to remove that sort of thing. Similarly, since I had to go through everything anyway, I've excluded the whitespace-only changes within files (though I left the normalisation of whitespace specifically at the ends of files). Apologies, I've force-pushed it back rather than applying it as a new commit, so it probably won't render these changes as nicely in the GitHub interface - it was rather easier for me to modify the commit than to make a ""partial reversion"" commit (and it's better for the logs).",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1579#issuecomment-867019111
https://github.com/qutip/qutip/pull/1579#issuecomment-867019111:1122,Testability,log,logs,1122,"@hodgestar: those comments lines you've highlighted were a careless mistake - they shouldn't have been removed, but it's a function of how I implemented the automated removal. I didn't notice them when I checked it through. I've restored them. The `cython: language_level=3` lines in particular are especially important to maintain, so that was very careless of me. That said, utf-8 is the default encoding for Python 3, so those lines aren't actually necessary at all any more. That wasn't the case with Python 2 (which assumed ASCII), but it's no longer an issue. Regardless, I've restored them because this PR wasn't meant to remove that sort of thing. Similarly, since I had to go through everything anyway, I've excluded the whitespace-only changes within files (though I left the normalisation of whitespace specifically at the ends of files). Apologies, I've force-pushed it back rather than applying it as a new commit, so it probably won't render these changes as nicely in the GitHub interface - it was rather easier for me to modify the commit than to make a ""partial reversion"" commit (and it's better for the logs).",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1579#issuecomment-867019111
https://github.com/qutip/qutip/pull/1579#issuecomment-874615277:106,Deployability,release,release,106,"@nathanshammah: by my understanding, technically we're only meant to include years in which we make a new release of the code/documention with modifications from a previous release. I went and checked, and we did it for all of 2011, 2012, ..., 2021, and I assume we'll be doing it for some time beyond that as well, so we should be good. In this new format, it's also much easier to update - there's only something like 3 places in the entire codebase with the years now.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1579#issuecomment-874615277
https://github.com/qutip/qutip/pull/1579#issuecomment-874615277:173,Deployability,release,release,173,"@nathanshammah: by my understanding, technically we're only meant to include years in which we make a new release of the code/documention with modifications from a previous release. I went and checked, and we did it for all of 2011, 2012, ..., 2021, and I assume we'll be doing it for some time beyond that as well, so we should be good. In this new format, it's also much easier to update - there's only something like 3 places in the entire codebase with the years now.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1579#issuecomment-874615277
https://github.com/qutip/qutip/pull/1579#issuecomment-874615277:383,Deployability,update,update,383,"@nathanshammah: by my understanding, technically we're only meant to include years in which we make a new release of the code/documention with modifications from a previous release. I went and checked, and we did it for all of 2011, 2012, ..., 2021, and I assume we'll be doing it for some time beyond that as well, so we should be good. In this new format, it's also much easier to update - there's only something like 3 places in the entire codebase with the years now.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1579#issuecomment-874615277
https://github.com/qutip/qutip/pull/1582#issuecomment-864882142:62,Safety,avoid,avoided,62,"@AGaliciaMartinez This doesn't look terrible to me, but we've avoided silencing warnings like this in qutip so far and it would be nice to keep it that way. Some questions:. * Do you know why qutip's own tests are not affected?; * Which qutip-tensorflow tests are affected? All of them?",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1582#issuecomment-864882142
https://github.com/qutip/qutip/pull/1582#issuecomment-864882142:204,Testability,test,tests,204,"@AGaliciaMartinez This doesn't look terrible to me, but we've avoided silencing warnings like this in qutip so far and it would be nice to keep it that way. Some questions:. * Do you know why qutip's own tests are not affected?; * Which qutip-tensorflow tests are affected? All of them?",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1582#issuecomment-864882142
https://github.com/qutip/qutip/pull/1582#issuecomment-864882142:254,Testability,test,tests,254,"@AGaliciaMartinez This doesn't look terrible to me, but we've avoided silencing warnings like this in qutip so far and it would be nice to keep it that way. Some questions:. * Do you know why qutip's own tests are not affected?; * Which qutip-tensorflow tests are affected? All of them?",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1582#issuecomment-864882142
https://github.com/qutip/qutip/pull/1582#issuecomment-864919889:271,Availability,error,errors,271,"> Which qutip-tensorflow tests are affected? All of them?. Yes, as this warning is raised when qutip is imported. > Do you know why qutip's own tests are not affected?. To be honest, I am not sure. I think at this moment the tests in `dev.major` do not treat warnings as errors (see [this commit](https://github.com/qutip/qutip/commit/c446e4acd0e4b87a7993a9861440debe5436023b)). Although I am not sure if prior to this commit qutip's own tests were affected. However, I have just realised that this is not the first time the deprecation warning from `pyximport` is silenced. In particular, in PR #1506 @jakelishman also silenced this warning in the master branch: ; https://github.com/qutip/qutip/blob/3432bfeb19ba14f1ef51e9e775588e33db17349c/qutip/cy/pyxbuilder.py#L39-L47; I can add the same comment and the `module=pyximport`. Was there any reason to not merge this change in dev.major?",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1582#issuecomment-864919889
https://github.com/qutip/qutip/pull/1582#issuecomment-864919889:25,Testability,test,tests,25,"> Which qutip-tensorflow tests are affected? All of them?. Yes, as this warning is raised when qutip is imported. > Do you know why qutip's own tests are not affected?. To be honest, I am not sure. I think at this moment the tests in `dev.major` do not treat warnings as errors (see [this commit](https://github.com/qutip/qutip/commit/c446e4acd0e4b87a7993a9861440debe5436023b)). Although I am not sure if prior to this commit qutip's own tests were affected. However, I have just realised that this is not the first time the deprecation warning from `pyximport` is silenced. In particular, in PR #1506 @jakelishman also silenced this warning in the master branch: ; https://github.com/qutip/qutip/blob/3432bfeb19ba14f1ef51e9e775588e33db17349c/qutip/cy/pyxbuilder.py#L39-L47; I can add the same comment and the `module=pyximport`. Was there any reason to not merge this change in dev.major?",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1582#issuecomment-864919889
https://github.com/qutip/qutip/pull/1582#issuecomment-864919889:144,Testability,test,tests,144,"> Which qutip-tensorflow tests are affected? All of them?. Yes, as this warning is raised when qutip is imported. > Do you know why qutip's own tests are not affected?. To be honest, I am not sure. I think at this moment the tests in `dev.major` do not treat warnings as errors (see [this commit](https://github.com/qutip/qutip/commit/c446e4acd0e4b87a7993a9861440debe5436023b)). Although I am not sure if prior to this commit qutip's own tests were affected. However, I have just realised that this is not the first time the deprecation warning from `pyximport` is silenced. In particular, in PR #1506 @jakelishman also silenced this warning in the master branch: ; https://github.com/qutip/qutip/blob/3432bfeb19ba14f1ef51e9e775588e33db17349c/qutip/cy/pyxbuilder.py#L39-L47; I can add the same comment and the `module=pyximport`. Was there any reason to not merge this change in dev.major?",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1582#issuecomment-864919889
https://github.com/qutip/qutip/pull/1582#issuecomment-864919889:225,Testability,test,tests,225,"> Which qutip-tensorflow tests are affected? All of them?. Yes, as this warning is raised when qutip is imported. > Do you know why qutip's own tests are not affected?. To be honest, I am not sure. I think at this moment the tests in `dev.major` do not treat warnings as errors (see [this commit](https://github.com/qutip/qutip/commit/c446e4acd0e4b87a7993a9861440debe5436023b)). Although I am not sure if prior to this commit qutip's own tests were affected. However, I have just realised that this is not the first time the deprecation warning from `pyximport` is silenced. In particular, in PR #1506 @jakelishman also silenced this warning in the master branch: ; https://github.com/qutip/qutip/blob/3432bfeb19ba14f1ef51e9e775588e33db17349c/qutip/cy/pyxbuilder.py#L39-L47; I can add the same comment and the `module=pyximport`. Was there any reason to not merge this change in dev.major?",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1582#issuecomment-864919889
https://github.com/qutip/qutip/pull/1582#issuecomment-864919889:438,Testability,test,tests,438,"> Which qutip-tensorflow tests are affected? All of them?. Yes, as this warning is raised when qutip is imported. > Do you know why qutip's own tests are not affected?. To be honest, I am not sure. I think at this moment the tests in `dev.major` do not treat warnings as errors (see [this commit](https://github.com/qutip/qutip/commit/c446e4acd0e4b87a7993a9861440debe5436023b)). Although I am not sure if prior to this commit qutip's own tests were affected. However, I have just realised that this is not the first time the deprecation warning from `pyximport` is silenced. In particular, in PR #1506 @jakelishman also silenced this warning in the master branch: ; https://github.com/qutip/qutip/blob/3432bfeb19ba14f1ef51e9e775588e33db17349c/qutip/cy/pyxbuilder.py#L39-L47; I can add the same comment and the `module=pyximport`. Was there any reason to not merge this change in dev.major?",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1582#issuecomment-864919889
https://github.com/qutip/qutip/pull/1582#issuecomment-864935212:198,Modifiability,config,config,198,"Thank you @AGaliciaMartinez as of late I was getting the same issue with the tests. @hodgestar ; dev.major lacks this lines in the toml. ``` ; [tool.pytest.ini_options]. addopts = ""-Werror --strict-config --strict-markers"". testpaths = [; ""tests"",; ]; ```",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1582#issuecomment-864935212
https://github.com/qutip/qutip/pull/1582#issuecomment-864935212:77,Testability,test,tests,77,"Thank you @AGaliciaMartinez as of late I was getting the same issue with the tests. @hodgestar ; dev.major lacks this lines in the toml. ``` ; [tool.pytest.ini_options]. addopts = ""-Werror --strict-config --strict-markers"". testpaths = [; ""tests"",; ]; ```",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1582#issuecomment-864935212
https://github.com/qutip/qutip/pull/1582#issuecomment-864935212:224,Testability,test,testpaths,224,"Thank you @AGaliciaMartinez as of late I was getting the same issue with the tests. @hodgestar ; dev.major lacks this lines in the toml. ``` ; [tool.pytest.ini_options]. addopts = ""-Werror --strict-config --strict-markers"". testpaths = [; ""tests"",; ]; ```",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1582#issuecomment-864935212
https://github.com/qutip/qutip/pull/1582#issuecomment-864935212:240,Testability,test,tests,240,"Thank you @AGaliciaMartinez as of late I was getting the same issue with the tests. @hodgestar ; dev.major lacks this lines in the toml. ``` ; [tool.pytest.ini_options]. addopts = ""-Werror --strict-config --strict-markers"". testpaths = [; ""tests"",; ]; ```",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1582#issuecomment-864935212
https://github.com/qutip/qutip/pull/1582#issuecomment-864939384:799,Deployability,release,release,799,"Hi both, `dev.major` is currently quite a few commits behind `master`, particularly with regard to dev ops tooling - as you guys are spotting here - though I did bring some of the testing and setup tools up-to-speed last week. The reason we haven't added `-Werror` to the pytest runs on `dev.major` yet is because we haven't fixed all the warnings that are emitted in various parts of the code. We had hoped to do this before starting new projects on it, but I guess that didn't work out in the end. We still want to get it done in the next couple of weeks; the plan is to get #1481 merged, then merge `master` into `dev.major`. We don't want your projects to be blocked, so we can merge this PR in, though we intend to remove this entire file (and all the logistics that go with it) before the 5.0 release. Our original plan for managing the 4.x and development 5.x branches simultaneously started to fray at the edges once we started getting a much larger uptick in contributions; when it was mostly just me and Eric working on the code, it was easy to manage, but now there's lots of us, it's a bit harder (though a good problem to have!).",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1582#issuecomment-864939384
https://github.com/qutip/qutip/pull/1582#issuecomment-864939384:180,Testability,test,testing,180,"Hi both, `dev.major` is currently quite a few commits behind `master`, particularly with regard to dev ops tooling - as you guys are spotting here - though I did bring some of the testing and setup tools up-to-speed last week. The reason we haven't added `-Werror` to the pytest runs on `dev.major` yet is because we haven't fixed all the warnings that are emitted in various parts of the code. We had hoped to do this before starting new projects on it, but I guess that didn't work out in the end. We still want to get it done in the next couple of weeks; the plan is to get #1481 merged, then merge `master` into `dev.major`. We don't want your projects to be blocked, so we can merge this PR in, though we intend to remove this entire file (and all the logistics that go with it) before the 5.0 release. Our original plan for managing the 4.x and development 5.x branches simultaneously started to fray at the edges once we started getting a much larger uptick in contributions; when it was mostly just me and Eric working on the code, it was easy to manage, but now there's lots of us, it's a bit harder (though a good problem to have!).",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1582#issuecomment-864939384
https://github.com/qutip/qutip/pull/1582#issuecomment-864939384:757,Testability,log,logistics,757,"Hi both, `dev.major` is currently quite a few commits behind `master`, particularly with regard to dev ops tooling - as you guys are spotting here - though I did bring some of the testing and setup tools up-to-speed last week. The reason we haven't added `-Werror` to the pytest runs on `dev.major` yet is because we haven't fixed all the warnings that are emitted in various parts of the code. We had hoped to do this before starting new projects on it, but I guess that didn't work out in the end. We still want to get it done in the next couple of weeks; the plan is to get #1481 merged, then merge `master` into `dev.major`. We don't want your projects to be blocked, so we can merge this PR in, though we intend to remove this entire file (and all the logistics that go with it) before the 5.0 release. Our original plan for managing the 4.x and development 5.x branches simultaneously started to fray at the edges once we started getting a much larger uptick in contributions; when it was mostly just me and Eric working on the code, it was easy to manage, but now there's lots of us, it's a bit harder (though a good problem to have!).",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1582#issuecomment-864939384
https://github.com/qutip/qutip/pull/1582#issuecomment-864984165:4284,Performance,optimiz,optimizer,4284,"ete): qutip/essolve.py deleted in HEAD and modified in master. Version master of qutip/essolve.py left in tree.; CONFLICT (modify/delete): qutip/eseries.py deleted in HEAD and modified in master. Version master of qutip/eseries.py left in tree.; CONFLICT (content): Merge conflict in qutip/entropy.py; CONFLICT (modify/delete): qutip/cy/spmatfuncs.pyx deleted in HEAD and modified in master. Version master of qutip/cy/spmatfuncs.pyx left in tree.; CONFLICT (modify/delete): qutip/cy/sparse_routines.pxi deleted in HEAD and modified in master. Version master of qutip/cy/sparse_routines.pxi left in tree.; CONFLICT (modify/delete): qutip/cy/codegen.py deleted in HEAD and modified in master. Version master of qutip/cy/codegen.py left in tree.; CONFLICT (content): Merge conflict in qutip/core/superop_reps.py; CONFLICT (content): Merge conflict in qutip/core/subsystem_apply.py; CONFLICT (content): Merge conflict in qutip/core/states.py; CONFLICT (content): Merge conflict in qutip/core/semidefinite.py; CONFLICT (content): Merge conflict in qutip/core/metrics.py; CONFLICT (content): Merge conflict in qutip/control/pulseoptim.py; CONFLICT (content): Merge conflict in qutip/control/pulsegen.py; CONFLICT (content): Merge conflict in qutip/control/optimizer.py; CONFLICT (content): Merge conflict in qutip/control/dump.py; CONFLICT (content): Merge conflict in qutip/bloch.py; CONFLICT (content): Merge conflict in qutip/_pyxbuilder.py; CONFLICT (content): Merge conflict in qutip/_mkl/utilities.py; CONFLICT (content): Merge conflict in qutip/_mkl/spsolve.py; CONFLICT (content): Merge conflict in qutip/_mkl/spmv.py; CONFLICT (content): Merge conflict in qutip/_mkl/__init__.py; CONFLICT (content): Merge conflict in qutip/__init__.py; CONFLICT (add/add): Merge conflict in VERSION; CONFLICT (content): Merge conflict in MANIFEST.in; CONFLICT (add/add): Merge conflict in .github/workflows/tests.yml; ```. Uh-oh. (This is actually expected: most of these are benign, and I can fix them quickly.)",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1582#issuecomment-864984165
https://github.com/qutip/qutip/pull/1582#issuecomment-864984165:334,Testability,test,tests,334,> we can sort out any conflicts. ```text; [~/code/qutip/qutip/qutip] (qutip-dev) (dev.major); jake@tauros$ git merge master | grep 'CONFLICT'. CONFLICT (content): Merge conflict in setup.py; CONFLICT (add/add): Merge conflict in setup.cfg; CONFLICT (content): Merge conflict in qutip/visualization.py; CONFLICT (modify/delete): qutip/tests/test_superoper.py deleted in HEAD and modified in master. Version master of qutip/tests/test_superoper.py left in tree.; CONFLICT (content): Merge conflict in qutip/tests/test_subsys_apply.py; CONFLICT (content): Merge conflict in qutip/tests/test_random.py; CONFLICT (modify/delete): qutip/tests/test_rand.py deleted in master and modified in HEAD. Version HEAD of qutip/tests/test_rand.py left in tree.; CONFLICT (content): Merge conflict in qutip/tests/test_qubitcircuit.py; CONFLICT (content): Merge conflict in qutip/tests/test_noise.py; CONFLICT (content): Merge conflict in qutip/tests/test_mkl.py; CONFLICT (content): Merge conflict in qutip/tests/test_device.py; CONFLICT (content): Merge conflict in qutip/tests/solve/test_qubit_evolution.py; CONFLICT (content): Merge conflict in qutip/tests/solve/test_brtools.py; CONFLICT (content): Merge conflict in qutip/tests/core/test_superop_reps.py; CONFLICT (content): Merge conflict in qutip/tests/core/test_qobj.py; CONFLICT (content): Merge conflict in qutip/tests/core/test_metrics.py; CONFLICT (content): Merge conflict in qutip/tests/core/test_eigen.py; CONFLICT (modify/delete): qutip/superoperator.py deleted in HEAD and modified in master. Version master of qutip/superoperator.py left in tree.; CONFLICT (modify/delete): qutip/sparse.py deleted in HEAD and modified in master. Version master of qutip/sparse.py left in tree.; CONFLICT (content): Merge conflict in qutip/solve/stochastic.py; CONFLICT (content): Merge conflict in qutip/solve/steadystate.py; CONFLICT (content): Merge conflict in qutip/solve/sesolve.py; CONFLICT (content): Merge conflict in qutip/solve/mesolve.py; CONFLICT (conten,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1582#issuecomment-864984165
https://github.com/qutip/qutip/pull/1582#issuecomment-864984165:422,Testability,test,tests,422,> we can sort out any conflicts. ```text; [~/code/qutip/qutip/qutip] (qutip-dev) (dev.major); jake@tauros$ git merge master | grep 'CONFLICT'. CONFLICT (content): Merge conflict in setup.py; CONFLICT (add/add): Merge conflict in setup.cfg; CONFLICT (content): Merge conflict in qutip/visualization.py; CONFLICT (modify/delete): qutip/tests/test_superoper.py deleted in HEAD and modified in master. Version master of qutip/tests/test_superoper.py left in tree.; CONFLICT (content): Merge conflict in qutip/tests/test_subsys_apply.py; CONFLICT (content): Merge conflict in qutip/tests/test_random.py; CONFLICT (modify/delete): qutip/tests/test_rand.py deleted in master and modified in HEAD. Version HEAD of qutip/tests/test_rand.py left in tree.; CONFLICT (content): Merge conflict in qutip/tests/test_qubitcircuit.py; CONFLICT (content): Merge conflict in qutip/tests/test_noise.py; CONFLICT (content): Merge conflict in qutip/tests/test_mkl.py; CONFLICT (content): Merge conflict in qutip/tests/test_device.py; CONFLICT (content): Merge conflict in qutip/tests/solve/test_qubit_evolution.py; CONFLICT (content): Merge conflict in qutip/tests/solve/test_brtools.py; CONFLICT (content): Merge conflict in qutip/tests/core/test_superop_reps.py; CONFLICT (content): Merge conflict in qutip/tests/core/test_qobj.py; CONFLICT (content): Merge conflict in qutip/tests/core/test_metrics.py; CONFLICT (content): Merge conflict in qutip/tests/core/test_eigen.py; CONFLICT (modify/delete): qutip/superoperator.py deleted in HEAD and modified in master. Version master of qutip/superoperator.py left in tree.; CONFLICT (modify/delete): qutip/sparse.py deleted in HEAD and modified in master. Version master of qutip/sparse.py left in tree.; CONFLICT (content): Merge conflict in qutip/solve/stochastic.py; CONFLICT (content): Merge conflict in qutip/solve/steadystate.py; CONFLICT (content): Merge conflict in qutip/solve/sesolve.py; CONFLICT (content): Merge conflict in qutip/solve/mesolve.py; CONFLICT (conten,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1582#issuecomment-864984165
https://github.com/qutip/qutip/pull/1582#issuecomment-864984165:505,Testability,test,tests,505,> we can sort out any conflicts. ```text; [~/code/qutip/qutip/qutip] (qutip-dev) (dev.major); jake@tauros$ git merge master | grep 'CONFLICT'. CONFLICT (content): Merge conflict in setup.py; CONFLICT (add/add): Merge conflict in setup.cfg; CONFLICT (content): Merge conflict in qutip/visualization.py; CONFLICT (modify/delete): qutip/tests/test_superoper.py deleted in HEAD and modified in master. Version master of qutip/tests/test_superoper.py left in tree.; CONFLICT (content): Merge conflict in qutip/tests/test_subsys_apply.py; CONFLICT (content): Merge conflict in qutip/tests/test_random.py; CONFLICT (modify/delete): qutip/tests/test_rand.py deleted in master and modified in HEAD. Version HEAD of qutip/tests/test_rand.py left in tree.; CONFLICT (content): Merge conflict in qutip/tests/test_qubitcircuit.py; CONFLICT (content): Merge conflict in qutip/tests/test_noise.py; CONFLICT (content): Merge conflict in qutip/tests/test_mkl.py; CONFLICT (content): Merge conflict in qutip/tests/test_device.py; CONFLICT (content): Merge conflict in qutip/tests/solve/test_qubit_evolution.py; CONFLICT (content): Merge conflict in qutip/tests/solve/test_brtools.py; CONFLICT (content): Merge conflict in qutip/tests/core/test_superop_reps.py; CONFLICT (content): Merge conflict in qutip/tests/core/test_qobj.py; CONFLICT (content): Merge conflict in qutip/tests/core/test_metrics.py; CONFLICT (content): Merge conflict in qutip/tests/core/test_eigen.py; CONFLICT (modify/delete): qutip/superoperator.py deleted in HEAD and modified in master. Version master of qutip/superoperator.py left in tree.; CONFLICT (modify/delete): qutip/sparse.py deleted in HEAD and modified in master. Version master of qutip/sparse.py left in tree.; CONFLICT (content): Merge conflict in qutip/solve/stochastic.py; CONFLICT (content): Merge conflict in qutip/solve/steadystate.py; CONFLICT (content): Merge conflict in qutip/solve/sesolve.py; CONFLICT (content): Merge conflict in qutip/solve/mesolve.py; CONFLICT (conten,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1582#issuecomment-864984165
https://github.com/qutip/qutip/pull/1582#issuecomment-864984165:577,Testability,test,tests,577,> we can sort out any conflicts. ```text; [~/code/qutip/qutip/qutip] (qutip-dev) (dev.major); jake@tauros$ git merge master | grep 'CONFLICT'. CONFLICT (content): Merge conflict in setup.py; CONFLICT (add/add): Merge conflict in setup.cfg; CONFLICT (content): Merge conflict in qutip/visualization.py; CONFLICT (modify/delete): qutip/tests/test_superoper.py deleted in HEAD and modified in master. Version master of qutip/tests/test_superoper.py left in tree.; CONFLICT (content): Merge conflict in qutip/tests/test_subsys_apply.py; CONFLICT (content): Merge conflict in qutip/tests/test_random.py; CONFLICT (modify/delete): qutip/tests/test_rand.py deleted in master and modified in HEAD. Version HEAD of qutip/tests/test_rand.py left in tree.; CONFLICT (content): Merge conflict in qutip/tests/test_qubitcircuit.py; CONFLICT (content): Merge conflict in qutip/tests/test_noise.py; CONFLICT (content): Merge conflict in qutip/tests/test_mkl.py; CONFLICT (content): Merge conflict in qutip/tests/test_device.py; CONFLICT (content): Merge conflict in qutip/tests/solve/test_qubit_evolution.py; CONFLICT (content): Merge conflict in qutip/tests/solve/test_brtools.py; CONFLICT (content): Merge conflict in qutip/tests/core/test_superop_reps.py; CONFLICT (content): Merge conflict in qutip/tests/core/test_qobj.py; CONFLICT (content): Merge conflict in qutip/tests/core/test_metrics.py; CONFLICT (content): Merge conflict in qutip/tests/core/test_eigen.py; CONFLICT (modify/delete): qutip/superoperator.py deleted in HEAD and modified in master. Version master of qutip/superoperator.py left in tree.; CONFLICT (modify/delete): qutip/sparse.py deleted in HEAD and modified in master. Version master of qutip/sparse.py left in tree.; CONFLICT (content): Merge conflict in qutip/solve/stochastic.py; CONFLICT (content): Merge conflict in qutip/solve/steadystate.py; CONFLICT (content): Merge conflict in qutip/solve/sesolve.py; CONFLICT (content): Merge conflict in qutip/solve/mesolve.py; CONFLICT (conten,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1582#issuecomment-864984165
https://github.com/qutip/qutip/pull/1582#issuecomment-864984165:631,Testability,test,tests,631,> we can sort out any conflicts. ```text; [~/code/qutip/qutip/qutip] (qutip-dev) (dev.major); jake@tauros$ git merge master | grep 'CONFLICT'. CONFLICT (content): Merge conflict in setup.py; CONFLICT (add/add): Merge conflict in setup.cfg; CONFLICT (content): Merge conflict in qutip/visualization.py; CONFLICT (modify/delete): qutip/tests/test_superoper.py deleted in HEAD and modified in master. Version master of qutip/tests/test_superoper.py left in tree.; CONFLICT (content): Merge conflict in qutip/tests/test_subsys_apply.py; CONFLICT (content): Merge conflict in qutip/tests/test_random.py; CONFLICT (modify/delete): qutip/tests/test_rand.py deleted in master and modified in HEAD. Version HEAD of qutip/tests/test_rand.py left in tree.; CONFLICT (content): Merge conflict in qutip/tests/test_qubitcircuit.py; CONFLICT (content): Merge conflict in qutip/tests/test_noise.py; CONFLICT (content): Merge conflict in qutip/tests/test_mkl.py; CONFLICT (content): Merge conflict in qutip/tests/test_device.py; CONFLICT (content): Merge conflict in qutip/tests/solve/test_qubit_evolution.py; CONFLICT (content): Merge conflict in qutip/tests/solve/test_brtools.py; CONFLICT (content): Merge conflict in qutip/tests/core/test_superop_reps.py; CONFLICT (content): Merge conflict in qutip/tests/core/test_qobj.py; CONFLICT (content): Merge conflict in qutip/tests/core/test_metrics.py; CONFLICT (content): Merge conflict in qutip/tests/core/test_eigen.py; CONFLICT (modify/delete): qutip/superoperator.py deleted in HEAD and modified in master. Version master of qutip/superoperator.py left in tree.; CONFLICT (modify/delete): qutip/sparse.py deleted in HEAD and modified in master. Version master of qutip/sparse.py left in tree.; CONFLICT (content): Merge conflict in qutip/solve/stochastic.py; CONFLICT (content): Merge conflict in qutip/solve/steadystate.py; CONFLICT (content): Merge conflict in qutip/solve/sesolve.py; CONFLICT (content): Merge conflict in qutip/solve/mesolve.py; CONFLICT (conten,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1582#issuecomment-864984165
https://github.com/qutip/qutip/pull/1582#issuecomment-864984165:712,Testability,test,tests,712,> we can sort out any conflicts. ```text; [~/code/qutip/qutip/qutip] (qutip-dev) (dev.major); jake@tauros$ git merge master | grep 'CONFLICT'. CONFLICT (content): Merge conflict in setup.py; CONFLICT (add/add): Merge conflict in setup.cfg; CONFLICT (content): Merge conflict in qutip/visualization.py; CONFLICT (modify/delete): qutip/tests/test_superoper.py deleted in HEAD and modified in master. Version master of qutip/tests/test_superoper.py left in tree.; CONFLICT (content): Merge conflict in qutip/tests/test_subsys_apply.py; CONFLICT (content): Merge conflict in qutip/tests/test_random.py; CONFLICT (modify/delete): qutip/tests/test_rand.py deleted in master and modified in HEAD. Version HEAD of qutip/tests/test_rand.py left in tree.; CONFLICT (content): Merge conflict in qutip/tests/test_qubitcircuit.py; CONFLICT (content): Merge conflict in qutip/tests/test_noise.py; CONFLICT (content): Merge conflict in qutip/tests/test_mkl.py; CONFLICT (content): Merge conflict in qutip/tests/test_device.py; CONFLICT (content): Merge conflict in qutip/tests/solve/test_qubit_evolution.py; CONFLICT (content): Merge conflict in qutip/tests/solve/test_brtools.py; CONFLICT (content): Merge conflict in qutip/tests/core/test_superop_reps.py; CONFLICT (content): Merge conflict in qutip/tests/core/test_qobj.py; CONFLICT (content): Merge conflict in qutip/tests/core/test_metrics.py; CONFLICT (content): Merge conflict in qutip/tests/core/test_eigen.py; CONFLICT (modify/delete): qutip/superoperator.py deleted in HEAD and modified in master. Version master of qutip/superoperator.py left in tree.; CONFLICT (modify/delete): qutip/sparse.py deleted in HEAD and modified in master. Version master of qutip/sparse.py left in tree.; CONFLICT (content): Merge conflict in qutip/solve/stochastic.py; CONFLICT (content): Merge conflict in qutip/solve/steadystate.py; CONFLICT (content): Merge conflict in qutip/solve/sesolve.py; CONFLICT (content): Merge conflict in qutip/solve/mesolve.py; CONFLICT (conten,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1582#issuecomment-864984165
https://github.com/qutip/qutip/pull/1582#issuecomment-864984165:790,Testability,test,tests,790,> we can sort out any conflicts. ```text; [~/code/qutip/qutip/qutip] (qutip-dev) (dev.major); jake@tauros$ git merge master | grep 'CONFLICT'. CONFLICT (content): Merge conflict in setup.py; CONFLICT (add/add): Merge conflict in setup.cfg; CONFLICT (content): Merge conflict in qutip/visualization.py; CONFLICT (modify/delete): qutip/tests/test_superoper.py deleted in HEAD and modified in master. Version master of qutip/tests/test_superoper.py left in tree.; CONFLICT (content): Merge conflict in qutip/tests/test_subsys_apply.py; CONFLICT (content): Merge conflict in qutip/tests/test_random.py; CONFLICT (modify/delete): qutip/tests/test_rand.py deleted in master and modified in HEAD. Version HEAD of qutip/tests/test_rand.py left in tree.; CONFLICT (content): Merge conflict in qutip/tests/test_qubitcircuit.py; CONFLICT (content): Merge conflict in qutip/tests/test_noise.py; CONFLICT (content): Merge conflict in qutip/tests/test_mkl.py; CONFLICT (content): Merge conflict in qutip/tests/test_device.py; CONFLICT (content): Merge conflict in qutip/tests/solve/test_qubit_evolution.py; CONFLICT (content): Merge conflict in qutip/tests/solve/test_brtools.py; CONFLICT (content): Merge conflict in qutip/tests/core/test_superop_reps.py; CONFLICT (content): Merge conflict in qutip/tests/core/test_qobj.py; CONFLICT (content): Merge conflict in qutip/tests/core/test_metrics.py; CONFLICT (content): Merge conflict in qutip/tests/core/test_eigen.py; CONFLICT (modify/delete): qutip/superoperator.py deleted in HEAD and modified in master. Version master of qutip/superoperator.py left in tree.; CONFLICT (modify/delete): qutip/sparse.py deleted in HEAD and modified in master. Version master of qutip/sparse.py left in tree.; CONFLICT (content): Merge conflict in qutip/solve/stochastic.py; CONFLICT (content): Merge conflict in qutip/solve/steadystate.py; CONFLICT (content): Merge conflict in qutip/solve/sesolve.py; CONFLICT (content): Merge conflict in qutip/solve/mesolve.py; CONFLICT (conten,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1582#issuecomment-864984165
https://github.com/qutip/qutip/pull/1582#issuecomment-864984165:862,Testability,test,tests,862,> we can sort out any conflicts. ```text; [~/code/qutip/qutip/qutip] (qutip-dev) (dev.major); jake@tauros$ git merge master | grep 'CONFLICT'. CONFLICT (content): Merge conflict in setup.py; CONFLICT (add/add): Merge conflict in setup.cfg; CONFLICT (content): Merge conflict in qutip/visualization.py; CONFLICT (modify/delete): qutip/tests/test_superoper.py deleted in HEAD and modified in master. Version master of qutip/tests/test_superoper.py left in tree.; CONFLICT (content): Merge conflict in qutip/tests/test_subsys_apply.py; CONFLICT (content): Merge conflict in qutip/tests/test_random.py; CONFLICT (modify/delete): qutip/tests/test_rand.py deleted in master and modified in HEAD. Version HEAD of qutip/tests/test_rand.py left in tree.; CONFLICT (content): Merge conflict in qutip/tests/test_qubitcircuit.py; CONFLICT (content): Merge conflict in qutip/tests/test_noise.py; CONFLICT (content): Merge conflict in qutip/tests/test_mkl.py; CONFLICT (content): Merge conflict in qutip/tests/test_device.py; CONFLICT (content): Merge conflict in qutip/tests/solve/test_qubit_evolution.py; CONFLICT (content): Merge conflict in qutip/tests/solve/test_brtools.py; CONFLICT (content): Merge conflict in qutip/tests/core/test_superop_reps.py; CONFLICT (content): Merge conflict in qutip/tests/core/test_qobj.py; CONFLICT (content): Merge conflict in qutip/tests/core/test_metrics.py; CONFLICT (content): Merge conflict in qutip/tests/core/test_eigen.py; CONFLICT (modify/delete): qutip/superoperator.py deleted in HEAD and modified in master. Version master of qutip/superoperator.py left in tree.; CONFLICT (modify/delete): qutip/sparse.py deleted in HEAD and modified in master. Version master of qutip/sparse.py left in tree.; CONFLICT (content): Merge conflict in qutip/solve/stochastic.py; CONFLICT (content): Merge conflict in qutip/solve/steadystate.py; CONFLICT (content): Merge conflict in qutip/solve/sesolve.py; CONFLICT (content): Merge conflict in qutip/solve/mesolve.py; CONFLICT (conten,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1582#issuecomment-864984165
https://github.com/qutip/qutip/pull/1582#issuecomment-864984165:927,Testability,test,tests,927,> we can sort out any conflicts. ```text; [~/code/qutip/qutip/qutip] (qutip-dev) (dev.major); jake@tauros$ git merge master | grep 'CONFLICT'. CONFLICT (content): Merge conflict in setup.py; CONFLICT (add/add): Merge conflict in setup.cfg; CONFLICT (content): Merge conflict in qutip/visualization.py; CONFLICT (modify/delete): qutip/tests/test_superoper.py deleted in HEAD and modified in master. Version master of qutip/tests/test_superoper.py left in tree.; CONFLICT (content): Merge conflict in qutip/tests/test_subsys_apply.py; CONFLICT (content): Merge conflict in qutip/tests/test_random.py; CONFLICT (modify/delete): qutip/tests/test_rand.py deleted in master and modified in HEAD. Version HEAD of qutip/tests/test_rand.py left in tree.; CONFLICT (content): Merge conflict in qutip/tests/test_qubitcircuit.py; CONFLICT (content): Merge conflict in qutip/tests/test_noise.py; CONFLICT (content): Merge conflict in qutip/tests/test_mkl.py; CONFLICT (content): Merge conflict in qutip/tests/test_device.py; CONFLICT (content): Merge conflict in qutip/tests/solve/test_qubit_evolution.py; CONFLICT (content): Merge conflict in qutip/tests/solve/test_brtools.py; CONFLICT (content): Merge conflict in qutip/tests/core/test_superop_reps.py; CONFLICT (content): Merge conflict in qutip/tests/core/test_qobj.py; CONFLICT (content): Merge conflict in qutip/tests/core/test_metrics.py; CONFLICT (content): Merge conflict in qutip/tests/core/test_eigen.py; CONFLICT (modify/delete): qutip/superoperator.py deleted in HEAD and modified in master. Version master of qutip/superoperator.py left in tree.; CONFLICT (modify/delete): qutip/sparse.py deleted in HEAD and modified in master. Version master of qutip/sparse.py left in tree.; CONFLICT (content): Merge conflict in qutip/solve/stochastic.py; CONFLICT (content): Merge conflict in qutip/solve/steadystate.py; CONFLICT (content): Merge conflict in qutip/solve/sesolve.py; CONFLICT (content): Merge conflict in qutip/solve/mesolve.py; CONFLICT (conten,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1582#issuecomment-864984165
https://github.com/qutip/qutip/pull/1582#issuecomment-864984165:990,Testability,test,tests,990,> we can sort out any conflicts. ```text; [~/code/qutip/qutip/qutip] (qutip-dev) (dev.major); jake@tauros$ git merge master | grep 'CONFLICT'. CONFLICT (content): Merge conflict in setup.py; CONFLICT (add/add): Merge conflict in setup.cfg; CONFLICT (content): Merge conflict in qutip/visualization.py; CONFLICT (modify/delete): qutip/tests/test_superoper.py deleted in HEAD and modified in master. Version master of qutip/tests/test_superoper.py left in tree.; CONFLICT (content): Merge conflict in qutip/tests/test_subsys_apply.py; CONFLICT (content): Merge conflict in qutip/tests/test_random.py; CONFLICT (modify/delete): qutip/tests/test_rand.py deleted in master and modified in HEAD. Version HEAD of qutip/tests/test_rand.py left in tree.; CONFLICT (content): Merge conflict in qutip/tests/test_qubitcircuit.py; CONFLICT (content): Merge conflict in qutip/tests/test_noise.py; CONFLICT (content): Merge conflict in qutip/tests/test_mkl.py; CONFLICT (content): Merge conflict in qutip/tests/test_device.py; CONFLICT (content): Merge conflict in qutip/tests/solve/test_qubit_evolution.py; CONFLICT (content): Merge conflict in qutip/tests/solve/test_brtools.py; CONFLICT (content): Merge conflict in qutip/tests/core/test_superop_reps.py; CONFLICT (content): Merge conflict in qutip/tests/core/test_qobj.py; CONFLICT (content): Merge conflict in qutip/tests/core/test_metrics.py; CONFLICT (content): Merge conflict in qutip/tests/core/test_eigen.py; CONFLICT (modify/delete): qutip/superoperator.py deleted in HEAD and modified in master. Version master of qutip/superoperator.py left in tree.; CONFLICT (modify/delete): qutip/sparse.py deleted in HEAD and modified in master. Version master of qutip/sparse.py left in tree.; CONFLICT (content): Merge conflict in qutip/solve/stochastic.py; CONFLICT (content): Merge conflict in qutip/solve/steadystate.py; CONFLICT (content): Merge conflict in qutip/solve/sesolve.py; CONFLICT (content): Merge conflict in qutip/solve/mesolve.py; CONFLICT (conten,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1582#issuecomment-864984165
https://github.com/qutip/qutip/pull/1582#issuecomment-864984165:1056,Testability,test,tests,1056,e/qutip/qutip/qutip] (qutip-dev) (dev.major); jake@tauros$ git merge master | grep 'CONFLICT'. CONFLICT (content): Merge conflict in setup.py; CONFLICT (add/add): Merge conflict in setup.cfg; CONFLICT (content): Merge conflict in qutip/visualization.py; CONFLICT (modify/delete): qutip/tests/test_superoper.py deleted in HEAD and modified in master. Version master of qutip/tests/test_superoper.py left in tree.; CONFLICT (content): Merge conflict in qutip/tests/test_subsys_apply.py; CONFLICT (content): Merge conflict in qutip/tests/test_random.py; CONFLICT (modify/delete): qutip/tests/test_rand.py deleted in master and modified in HEAD. Version HEAD of qutip/tests/test_rand.py left in tree.; CONFLICT (content): Merge conflict in qutip/tests/test_qubitcircuit.py; CONFLICT (content): Merge conflict in qutip/tests/test_noise.py; CONFLICT (content): Merge conflict in qutip/tests/test_mkl.py; CONFLICT (content): Merge conflict in qutip/tests/test_device.py; CONFLICT (content): Merge conflict in qutip/tests/solve/test_qubit_evolution.py; CONFLICT (content): Merge conflict in qutip/tests/solve/test_brtools.py; CONFLICT (content): Merge conflict in qutip/tests/core/test_superop_reps.py; CONFLICT (content): Merge conflict in qutip/tests/core/test_qobj.py; CONFLICT (content): Merge conflict in qutip/tests/core/test_metrics.py; CONFLICT (content): Merge conflict in qutip/tests/core/test_eigen.py; CONFLICT (modify/delete): qutip/superoperator.py deleted in HEAD and modified in master. Version master of qutip/superoperator.py left in tree.; CONFLICT (modify/delete): qutip/sparse.py deleted in HEAD and modified in master. Version master of qutip/sparse.py left in tree.; CONFLICT (content): Merge conflict in qutip/solve/stochastic.py; CONFLICT (content): Merge conflict in qutip/solve/steadystate.py; CONFLICT (content): Merge conflict in qutip/solve/sesolve.py; CONFLICT (content): Merge conflict in qutip/solve/mesolve.py; CONFLICT (content): Merge conflict in qutip/solve/mcsolve.py; CO,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1582#issuecomment-864984165
https://github.com/qutip/qutip/pull/1582#issuecomment-864984165:1137,Testability,test,tests,1137, grep 'CONFLICT'. CONFLICT (content): Merge conflict in setup.py; CONFLICT (add/add): Merge conflict in setup.cfg; CONFLICT (content): Merge conflict in qutip/visualization.py; CONFLICT (modify/delete): qutip/tests/test_superoper.py deleted in HEAD and modified in master. Version master of qutip/tests/test_superoper.py left in tree.; CONFLICT (content): Merge conflict in qutip/tests/test_subsys_apply.py; CONFLICT (content): Merge conflict in qutip/tests/test_random.py; CONFLICT (modify/delete): qutip/tests/test_rand.py deleted in master and modified in HEAD. Version HEAD of qutip/tests/test_rand.py left in tree.; CONFLICT (content): Merge conflict in qutip/tests/test_qubitcircuit.py; CONFLICT (content): Merge conflict in qutip/tests/test_noise.py; CONFLICT (content): Merge conflict in qutip/tests/test_mkl.py; CONFLICT (content): Merge conflict in qutip/tests/test_device.py; CONFLICT (content): Merge conflict in qutip/tests/solve/test_qubit_evolution.py; CONFLICT (content): Merge conflict in qutip/tests/solve/test_brtools.py; CONFLICT (content): Merge conflict in qutip/tests/core/test_superop_reps.py; CONFLICT (content): Merge conflict in qutip/tests/core/test_qobj.py; CONFLICT (content): Merge conflict in qutip/tests/core/test_metrics.py; CONFLICT (content): Merge conflict in qutip/tests/core/test_eigen.py; CONFLICT (modify/delete): qutip/superoperator.py deleted in HEAD and modified in master. Version master of qutip/superoperator.py left in tree.; CONFLICT (modify/delete): qutip/sparse.py deleted in HEAD and modified in master. Version master of qutip/sparse.py left in tree.; CONFLICT (content): Merge conflict in qutip/solve/stochastic.py; CONFLICT (content): Merge conflict in qutip/solve/steadystate.py; CONFLICT (content): Merge conflict in qutip/solve/sesolve.py; CONFLICT (content): Merge conflict in qutip/solve/mesolve.py; CONFLICT (content): Merge conflict in qutip/solve/mcsolve.py; CONFLICT (content): Merge conflict in qutip/solve/floquet.py; CONFLICT (content,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1582#issuecomment-864984165
https://github.com/qutip/qutip/pull/1582#issuecomment-864984165:1210,Testability,test,tests,1210,(add/add): Merge conflict in setup.cfg; CONFLICT (content): Merge conflict in qutip/visualization.py; CONFLICT (modify/delete): qutip/tests/test_superoper.py deleted in HEAD and modified in master. Version master of qutip/tests/test_superoper.py left in tree.; CONFLICT (content): Merge conflict in qutip/tests/test_subsys_apply.py; CONFLICT (content): Merge conflict in qutip/tests/test_random.py; CONFLICT (modify/delete): qutip/tests/test_rand.py deleted in master and modified in HEAD. Version HEAD of qutip/tests/test_rand.py left in tree.; CONFLICT (content): Merge conflict in qutip/tests/test_qubitcircuit.py; CONFLICT (content): Merge conflict in qutip/tests/test_noise.py; CONFLICT (content): Merge conflict in qutip/tests/test_mkl.py; CONFLICT (content): Merge conflict in qutip/tests/test_device.py; CONFLICT (content): Merge conflict in qutip/tests/solve/test_qubit_evolution.py; CONFLICT (content): Merge conflict in qutip/tests/solve/test_brtools.py; CONFLICT (content): Merge conflict in qutip/tests/core/test_superop_reps.py; CONFLICT (content): Merge conflict in qutip/tests/core/test_qobj.py; CONFLICT (content): Merge conflict in qutip/tests/core/test_metrics.py; CONFLICT (content): Merge conflict in qutip/tests/core/test_eigen.py; CONFLICT (modify/delete): qutip/superoperator.py deleted in HEAD and modified in master. Version master of qutip/superoperator.py left in tree.; CONFLICT (modify/delete): qutip/sparse.py deleted in HEAD and modified in master. Version master of qutip/sparse.py left in tree.; CONFLICT (content): Merge conflict in qutip/solve/stochastic.py; CONFLICT (content): Merge conflict in qutip/solve/steadystate.py; CONFLICT (content): Merge conflict in qutip/solve/sesolve.py; CONFLICT (content): Merge conflict in qutip/solve/mesolve.py; CONFLICT (content): Merge conflict in qutip/solve/mcsolve.py; CONFLICT (content): Merge conflict in qutip/solve/floquet.py; CONFLICT (content): Merge conflict in qutip/solve/countstat.py; CONFLICT (content): Merge co,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1582#issuecomment-864984165
https://github.com/qutip/qutip/pull/1582#issuecomment-864984165:1287,Testability,test,tests,1287,t in qutip/visualization.py; CONFLICT (modify/delete): qutip/tests/test_superoper.py deleted in HEAD and modified in master. Version master of qutip/tests/test_superoper.py left in tree.; CONFLICT (content): Merge conflict in qutip/tests/test_subsys_apply.py; CONFLICT (content): Merge conflict in qutip/tests/test_random.py; CONFLICT (modify/delete): qutip/tests/test_rand.py deleted in master and modified in HEAD. Version HEAD of qutip/tests/test_rand.py left in tree.; CONFLICT (content): Merge conflict in qutip/tests/test_qubitcircuit.py; CONFLICT (content): Merge conflict in qutip/tests/test_noise.py; CONFLICT (content): Merge conflict in qutip/tests/test_mkl.py; CONFLICT (content): Merge conflict in qutip/tests/test_device.py; CONFLICT (content): Merge conflict in qutip/tests/solve/test_qubit_evolution.py; CONFLICT (content): Merge conflict in qutip/tests/solve/test_brtools.py; CONFLICT (content): Merge conflict in qutip/tests/core/test_superop_reps.py; CONFLICT (content): Merge conflict in qutip/tests/core/test_qobj.py; CONFLICT (content): Merge conflict in qutip/tests/core/test_metrics.py; CONFLICT (content): Merge conflict in qutip/tests/core/test_eigen.py; CONFLICT (modify/delete): qutip/superoperator.py deleted in HEAD and modified in master. Version master of qutip/superoperator.py left in tree.; CONFLICT (modify/delete): qutip/sparse.py deleted in HEAD and modified in master. Version master of qutip/sparse.py left in tree.; CONFLICT (content): Merge conflict in qutip/solve/stochastic.py; CONFLICT (content): Merge conflict in qutip/solve/steadystate.py; CONFLICT (content): Merge conflict in qutip/solve/sesolve.py; CONFLICT (content): Merge conflict in qutip/solve/mesolve.py; CONFLICT (content): Merge conflict in qutip/solve/mcsolve.py; CONFLICT (content): Merge conflict in qutip/solve/floquet.py; CONFLICT (content): Merge conflict in qutip/solve/countstat.py; CONFLICT (content): Merge conflict in qutip/solve/correlation.py; CONFLICT (content): Merge conflict ,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1582#issuecomment-864984165
https://github.com/qutip/qutip/pull/1582#issuecomment-864984165:1356,Testability,test,tests,1356,_superoper.py deleted in HEAD and modified in master. Version master of qutip/tests/test_superoper.py left in tree.; CONFLICT (content): Merge conflict in qutip/tests/test_subsys_apply.py; CONFLICT (content): Merge conflict in qutip/tests/test_random.py; CONFLICT (modify/delete): qutip/tests/test_rand.py deleted in master and modified in HEAD. Version HEAD of qutip/tests/test_rand.py left in tree.; CONFLICT (content): Merge conflict in qutip/tests/test_qubitcircuit.py; CONFLICT (content): Merge conflict in qutip/tests/test_noise.py; CONFLICT (content): Merge conflict in qutip/tests/test_mkl.py; CONFLICT (content): Merge conflict in qutip/tests/test_device.py; CONFLICT (content): Merge conflict in qutip/tests/solve/test_qubit_evolution.py; CONFLICT (content): Merge conflict in qutip/tests/solve/test_brtools.py; CONFLICT (content): Merge conflict in qutip/tests/core/test_superop_reps.py; CONFLICT (content): Merge conflict in qutip/tests/core/test_qobj.py; CONFLICT (content): Merge conflict in qutip/tests/core/test_metrics.py; CONFLICT (content): Merge conflict in qutip/tests/core/test_eigen.py; CONFLICT (modify/delete): qutip/superoperator.py deleted in HEAD and modified in master. Version master of qutip/superoperator.py left in tree.; CONFLICT (modify/delete): qutip/sparse.py deleted in HEAD and modified in master. Version master of qutip/sparse.py left in tree.; CONFLICT (content): Merge conflict in qutip/solve/stochastic.py; CONFLICT (content): Merge conflict in qutip/solve/steadystate.py; CONFLICT (content): Merge conflict in qutip/solve/sesolve.py; CONFLICT (content): Merge conflict in qutip/solve/mesolve.py; CONFLICT (content): Merge conflict in qutip/solve/mcsolve.py; CONFLICT (content): Merge conflict in qutip/solve/floquet.py; CONFLICT (content): Merge conflict in qutip/solve/countstat.py; CONFLICT (content): Merge conflict in qutip/solve/correlation.py; CONFLICT (content): Merge conflict in qutip/solve/_brtools.pyx; CONFLICT (content): Merge conflict in qut,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1582#issuecomment-864984165
https://github.com/qutip/qutip/pull/1582#issuecomment-864984165:1428,Testability,test,tests,1428, qutip/tests/test_superoper.py left in tree.; CONFLICT (content): Merge conflict in qutip/tests/test_subsys_apply.py; CONFLICT (content): Merge conflict in qutip/tests/test_random.py; CONFLICT (modify/delete): qutip/tests/test_rand.py deleted in master and modified in HEAD. Version HEAD of qutip/tests/test_rand.py left in tree.; CONFLICT (content): Merge conflict in qutip/tests/test_qubitcircuit.py; CONFLICT (content): Merge conflict in qutip/tests/test_noise.py; CONFLICT (content): Merge conflict in qutip/tests/test_mkl.py; CONFLICT (content): Merge conflict in qutip/tests/test_device.py; CONFLICT (content): Merge conflict in qutip/tests/solve/test_qubit_evolution.py; CONFLICT (content): Merge conflict in qutip/tests/solve/test_brtools.py; CONFLICT (content): Merge conflict in qutip/tests/core/test_superop_reps.py; CONFLICT (content): Merge conflict in qutip/tests/core/test_qobj.py; CONFLICT (content): Merge conflict in qutip/tests/core/test_metrics.py; CONFLICT (content): Merge conflict in qutip/tests/core/test_eigen.py; CONFLICT (modify/delete): qutip/superoperator.py deleted in HEAD and modified in master. Version master of qutip/superoperator.py left in tree.; CONFLICT (modify/delete): qutip/sparse.py deleted in HEAD and modified in master. Version master of qutip/sparse.py left in tree.; CONFLICT (content): Merge conflict in qutip/solve/stochastic.py; CONFLICT (content): Merge conflict in qutip/solve/steadystate.py; CONFLICT (content): Merge conflict in qutip/solve/sesolve.py; CONFLICT (content): Merge conflict in qutip/solve/mesolve.py; CONFLICT (content): Merge conflict in qutip/solve/mcsolve.py; CONFLICT (content): Merge conflict in qutip/solve/floquet.py; CONFLICT (content): Merge conflict in qutip/solve/countstat.py; CONFLICT (content): Merge conflict in qutip/solve/correlation.py; CONFLICT (content): Merge conflict in qutip/solve/_brtools.pyx; CONFLICT (content): Merge conflict in qutip/random_objects.py; CONFLICT (modify/delete): qutip/qobjevo.py delete,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1582#issuecomment-864984165
https://github.com/qutip/qutip/pull/1582#issuecomment-864984165:4928,Testability,test,tests,4928,"ete): qutip/essolve.py deleted in HEAD and modified in master. Version master of qutip/essolve.py left in tree.; CONFLICT (modify/delete): qutip/eseries.py deleted in HEAD and modified in master. Version master of qutip/eseries.py left in tree.; CONFLICT (content): Merge conflict in qutip/entropy.py; CONFLICT (modify/delete): qutip/cy/spmatfuncs.pyx deleted in HEAD and modified in master. Version master of qutip/cy/spmatfuncs.pyx left in tree.; CONFLICT (modify/delete): qutip/cy/sparse_routines.pxi deleted in HEAD and modified in master. Version master of qutip/cy/sparse_routines.pxi left in tree.; CONFLICT (modify/delete): qutip/cy/codegen.py deleted in HEAD and modified in master. Version master of qutip/cy/codegen.py left in tree.; CONFLICT (content): Merge conflict in qutip/core/superop_reps.py; CONFLICT (content): Merge conflict in qutip/core/subsystem_apply.py; CONFLICT (content): Merge conflict in qutip/core/states.py; CONFLICT (content): Merge conflict in qutip/core/semidefinite.py; CONFLICT (content): Merge conflict in qutip/core/metrics.py; CONFLICT (content): Merge conflict in qutip/control/pulseoptim.py; CONFLICT (content): Merge conflict in qutip/control/pulsegen.py; CONFLICT (content): Merge conflict in qutip/control/optimizer.py; CONFLICT (content): Merge conflict in qutip/control/dump.py; CONFLICT (content): Merge conflict in qutip/bloch.py; CONFLICT (content): Merge conflict in qutip/_pyxbuilder.py; CONFLICT (content): Merge conflict in qutip/_mkl/utilities.py; CONFLICT (content): Merge conflict in qutip/_mkl/spsolve.py; CONFLICT (content): Merge conflict in qutip/_mkl/spmv.py; CONFLICT (content): Merge conflict in qutip/_mkl/__init__.py; CONFLICT (content): Merge conflict in qutip/__init__.py; CONFLICT (add/add): Merge conflict in VERSION; CONFLICT (content): Merge conflict in MANIFEST.in; CONFLICT (add/add): Merge conflict in .github/workflows/tests.yml; ```. Uh-oh. (This is actually expected: most of these are benign, and I can fix them quickly.)",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1582#issuecomment-864984165
https://github.com/qutip/qutip/pull/1583#issuecomment-872207526:466,Integrability,interface,interfaces,466,"@Ericgig: yeah, it's not a perfect naming choice. Can you think of a better one? It ended up like that because I started off just calling in `_qfunc_alpha_matrix`, then realised about halfway through that I was actually constructing the conjugate of the matrix formed by stacking coherent states (since that's how it's used), but the name isn't really ideal. @quantshah: I'm just thinking now you might want to have a look at this - you had some thoughts about user interfaces for class-based creation schemes last year, with regards to the displacement operator, which I'll build up into a proper PR at some point as well. Don't worry if you've no time, though.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1583#issuecomment-872207526
https://github.com/qutip/qutip/pull/1583#issuecomment-872210777:653,Integrability,interface,interfaces,653,"Yes I will have a look this weekend. On Thu, 1 Jul 2021 at 14:32, Jake Lishman ***@***.***> wrote:. > @Ericgig <https://github.com/Ericgig>: yeah, it's not a perfect naming; > choice. Can you think of a better one? It ended up like that because I; > started off just calling in _qfunc_alpha_matrix, then realised about; > halfway through that I was actually constructing the conjugate of the; > matrix formed by stacking coherent states (since that's how it's used), but; > the name isn't really ideal.; >; > @quantshah <https://github.com/quantshah>: I'm just thinking now you; > might want to have a look at this - you had some thoughts about user; > interfaces for class-based creation schemes last year, with regards to the; > displacement operator, which I'll build up into a proper PR at some point; > as well. Don't worry if you've no time, though.; >; > —; > You are receiving this because you were mentioned.; > Reply to this email directly, view it on GitHub; > <https://github.com/qutip/qutip/pull/1583#issuecomment-872207526>, or; > unsubscribe; > <https://github.com/notifications/unsubscribe-auth/ABVFIBH3GWFKFVFVL4ZBR2DTVRN6VANCNFSM47AL5RKA>; > .; >",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1583#issuecomment-872210777
https://github.com/qutip/qutip/pull/1583#issuecomment-877241762:556,Energy Efficiency,efficient,efficient,556,"@jakelishman this is great, also thanks @dweigand for this PR. I tried out the function and it is very fast and could be great for specific use cases. My idea was a bit more simple - precomputing the `coherent_dm` operators (using qutip.coherent_dm) and using the `expect` function. But that performs worse that the original `qfunc` as well as this implementation of course. So this is great. I would be happy to merge this but have one thought:. This new implementation is sacrificing the ease-of-understanding of how Q-functions are computed with a very efficient and fast, but complicated class-based implementation. This means that users who want to look under the hood will not fully understand how this is working. I believe the crux of this implementation is a fast computation of the tensors of `coherent_dm` operators for all the alpha values at (x + iy). Personally, on many occasions, I have looked at qutip implementations of quantum operations just to understand what is happening under the hood and I believe several users have often done this to hack around. If someone were to try and understand Q-function computation from this code, it seems simple enough with the call:. ```; np.abs(np.dot(alphas, (self._g*0.5)*vector))**2; ```. for state vectors, or decomposing a density matrix into state vectors and then running the above call. Or . ```; out = np.polyval(; (0.5*g * vector / np.sqrt(scipy.special.factorial(ns)))[::-1],; alpha.conj,; ); ```. But the object `alpha` now constructed with `_qfunc_alpha_matrix` class is a bit difficult to understand. The variable `self.conj = np.empty(x.shape, dtype=np.complex128)` creates a tensor and sets it to a mesh grid (x, -y), but then what does the `__call__()` return? The tensor of `coherent_dm(x+iy)` for each x and y coordinate? But how is it computing it without knowing the Hilbert space dim for the state, which I think is computed on the fly by `ns = np.arange(first, last).reshape(1, 1, -1)`. It seems it caches the `coherent_d",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1583#issuecomment-877241762
https://github.com/qutip/qutip/pull/1583#issuecomment-877241762:2444,Energy Efficiency,efficient,efficient,2444,"er the hood will not fully understand how this is working. I believe the crux of this implementation is a fast computation of the tensors of `coherent_dm` operators for all the alpha values at (x + iy). Personally, on many occasions, I have looked at qutip implementations of quantum operations just to understand what is happening under the hood and I believe several users have often done this to hack around. If someone were to try and understand Q-function computation from this code, it seems simple enough with the call:. ```; np.abs(np.dot(alphas, (self._g*0.5)*vector))**2; ```. for state vectors, or decomposing a density matrix into state vectors and then running the above call. Or . ```; out = np.polyval(; (0.5*g * vector / np.sqrt(scipy.special.factorial(ns)))[::-1],; alpha.conj,; ); ```. But the object `alpha` now constructed with `_qfunc_alpha_matrix` class is a bit difficult to understand. The variable `self.conj = np.empty(x.shape, dtype=np.complex128)` creates a tensor and sets it to a mesh grid (x, -y), but then what does the `__call__()` return? The tensor of `coherent_dm(x+iy)` for each x and y coordinate? But how is it computing it without knowing the Hilbert space dim for the state, which I think is computed on the fly by `ns = np.arange(first, last).reshape(1, 1, -1)`. It seems it caches the `coherent_dm` computed upto `current_size` and then extends it to `size` for new Hilbert space dimensions. . I am sorry if I am being a bit thick here because I understand the overall idea of the code but somehow I am not confident it will be easy for others to understand on first read. Do you think we can make it a bit more transparent how the `_qfunc_alpha_matrix` works and that the crux of the method is computing the operators `coherent_dm` in an efficient way and saving them? If I have understood the code correct, I could try to document it a bit more and simplify it. . Let me know your thoughts and correct me if I misunderstood something @jakelishman @Ericgig",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1583#issuecomment-877241762
https://github.com/qutip/qutip/pull/1583#issuecomment-877241762:1576,Modifiability,variab,variable,1576,"omplicated class-based implementation. This means that users who want to look under the hood will not fully understand how this is working. I believe the crux of this implementation is a fast computation of the tensors of `coherent_dm` operators for all the alpha values at (x + iy). Personally, on many occasions, I have looked at qutip implementations of quantum operations just to understand what is happening under the hood and I believe several users have often done this to hack around. If someone were to try and understand Q-function computation from this code, it seems simple enough with the call:. ```; np.abs(np.dot(alphas, (self._g*0.5)*vector))**2; ```. for state vectors, or decomposing a density matrix into state vectors and then running the above call. Or . ```; out = np.polyval(; (0.5*g * vector / np.sqrt(scipy.special.factorial(ns)))[::-1],; alpha.conj,; ); ```. But the object `alpha` now constructed with `_qfunc_alpha_matrix` class is a bit difficult to understand. The variable `self.conj = np.empty(x.shape, dtype=np.complex128)` creates a tensor and sets it to a mesh grid (x, -y), but then what does the `__call__()` return? The tensor of `coherent_dm(x+iy)` for each x and y coordinate? But how is it computing it without knowing the Hilbert space dim for the state, which I think is computed on the fly by `ns = np.arange(first, last).reshape(1, 1, -1)`. It seems it caches the `coherent_dm` computed upto `current_size` and then extends it to `size` for new Hilbert space dimensions. . I am sorry if I am being a bit thick here because I understand the overall idea of the code but somehow I am not confident it will be easy for others to understand on first read. Do you think we can make it a bit more transparent how the `_qfunc_alpha_matrix` works and that the crux of the method is computing the operators `coherent_dm` in an efficient way and saving them? If I have understood the code correct, I could try to document it a bit more and simplify it. . Let me kno",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1583#issuecomment-877241762
https://github.com/qutip/qutip/pull/1583#issuecomment-877241762:2042,Modifiability,extend,extends,2042,"er the hood will not fully understand how this is working. I believe the crux of this implementation is a fast computation of the tensors of `coherent_dm` operators for all the alpha values at (x + iy). Personally, on many occasions, I have looked at qutip implementations of quantum operations just to understand what is happening under the hood and I believe several users have often done this to hack around. If someone were to try and understand Q-function computation from this code, it seems simple enough with the call:. ```; np.abs(np.dot(alphas, (self._g*0.5)*vector))**2; ```. for state vectors, or decomposing a density matrix into state vectors and then running the above call. Or . ```; out = np.polyval(; (0.5*g * vector / np.sqrt(scipy.special.factorial(ns)))[::-1],; alpha.conj,; ); ```. But the object `alpha` now constructed with `_qfunc_alpha_matrix` class is a bit difficult to understand. The variable `self.conj = np.empty(x.shape, dtype=np.complex128)` creates a tensor and sets it to a mesh grid (x, -y), but then what does the `__call__()` return? The tensor of `coherent_dm(x+iy)` for each x and y coordinate? But how is it computing it without knowing the Hilbert space dim for the state, which I think is computed on the fly by `ns = np.arange(first, last).reshape(1, 1, -1)`. It seems it caches the `coherent_dm` computed upto `current_size` and then extends it to `size` for new Hilbert space dimensions. . I am sorry if I am being a bit thick here because I understand the overall idea of the code but somehow I am not confident it will be easy for others to understand on first read. Do you think we can make it a bit more transparent how the `_qfunc_alpha_matrix` works and that the crux of the method is computing the operators `coherent_dm` in an efficient way and saving them? If I have understood the code correct, I could try to document it a bit more and simplify it. . Let me know your thoughts and correct me if I misunderstood something @jakelishman @Ericgig",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1583#issuecomment-877241762
https://github.com/qutip/qutip/pull/1583#issuecomment-877241762:292,Performance,perform,performs,292,"@jakelishman this is great, also thanks @dweigand for this PR. I tried out the function and it is very fast and could be great for specific use cases. My idea was a bit more simple - precomputing the `coherent_dm` operators (using qutip.coherent_dm) and using the `expect` function. But that performs worse that the original `qfunc` as well as this implementation of course. So this is great. I would be happy to merge this but have one thought:. This new implementation is sacrificing the ease-of-understanding of how Q-functions are computed with a very efficient and fast, but complicated class-based implementation. This means that users who want to look under the hood will not fully understand how this is working. I believe the crux of this implementation is a fast computation of the tensors of `coherent_dm` operators for all the alpha values at (x + iy). Personally, on many occasions, I have looked at qutip implementations of quantum operations just to understand what is happening under the hood and I believe several users have often done this to hack around. If someone were to try and understand Q-function computation from this code, it seems simple enough with the call:. ```; np.abs(np.dot(alphas, (self._g*0.5)*vector))**2; ```. for state vectors, or decomposing a density matrix into state vectors and then running the above call. Or . ```; out = np.polyval(; (0.5*g * vector / np.sqrt(scipy.special.factorial(ns)))[::-1],; alpha.conj,; ); ```. But the object `alpha` now constructed with `_qfunc_alpha_matrix` class is a bit difficult to understand. The variable `self.conj = np.empty(x.shape, dtype=np.complex128)` creates a tensor and sets it to a mesh grid (x, -y), but then what does the `__call__()` return? The tensor of `coherent_dm(x+iy)` for each x and y coordinate? But how is it computing it without knowing the Hilbert space dim for the state, which I think is computed on the fly by `ns = np.arange(first, last).reshape(1, 1, -1)`. It seems it caches the `coherent_d",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1583#issuecomment-877241762
https://github.com/qutip/qutip/pull/1583#issuecomment-877241762:1979,Performance,cache,caches,1979,"er the hood will not fully understand how this is working. I believe the crux of this implementation is a fast computation of the tensors of `coherent_dm` operators for all the alpha values at (x + iy). Personally, on many occasions, I have looked at qutip implementations of quantum operations just to understand what is happening under the hood and I believe several users have often done this to hack around. If someone were to try and understand Q-function computation from this code, it seems simple enough with the call:. ```; np.abs(np.dot(alphas, (self._g*0.5)*vector))**2; ```. for state vectors, or decomposing a density matrix into state vectors and then running the above call. Or . ```; out = np.polyval(; (0.5*g * vector / np.sqrt(scipy.special.factorial(ns)))[::-1],; alpha.conj,; ); ```. But the object `alpha` now constructed with `_qfunc_alpha_matrix` class is a bit difficult to understand. The variable `self.conj = np.empty(x.shape, dtype=np.complex128)` creates a tensor and sets it to a mesh grid (x, -y), but then what does the `__call__()` return? The tensor of `coherent_dm(x+iy)` for each x and y coordinate? But how is it computing it without knowing the Hilbert space dim for the state, which I think is computed on the fly by `ns = np.arange(first, last).reshape(1, 1, -1)`. It seems it caches the `coherent_dm` computed upto `current_size` and then extends it to `size` for new Hilbert space dimensions. . I am sorry if I am being a bit thick here because I understand the overall idea of the code but somehow I am not confident it will be easy for others to understand on first read. Do you think we can make it a bit more transparent how the `_qfunc_alpha_matrix` works and that the crux of the method is computing the operators `coherent_dm` in an efficient way and saving them? If I have understood the code correct, I could try to document it a bit more and simplify it. . Let me know your thoughts and correct me if I misunderstood something @jakelishman @Ericgig",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1583#issuecomment-877241762
https://github.com/qutip/qutip/pull/1583#issuecomment-877241762:174,Usability,simpl,simple,174,"@jakelishman this is great, also thanks @dweigand for this PR. I tried out the function and it is very fast and could be great for specific use cases. My idea was a bit more simple - precomputing the `coherent_dm` operators (using qutip.coherent_dm) and using the `expect` function. But that performs worse that the original `qfunc` as well as this implementation of course. So this is great. I would be happy to merge this but have one thought:. This new implementation is sacrificing the ease-of-understanding of how Q-functions are computed with a very efficient and fast, but complicated class-based implementation. This means that users who want to look under the hood will not fully understand how this is working. I believe the crux of this implementation is a fast computation of the tensors of `coherent_dm` operators for all the alpha values at (x + iy). Personally, on many occasions, I have looked at qutip implementations of quantum operations just to understand what is happening under the hood and I believe several users have often done this to hack around. If someone were to try and understand Q-function computation from this code, it seems simple enough with the call:. ```; np.abs(np.dot(alphas, (self._g*0.5)*vector))**2; ```. for state vectors, or decomposing a density matrix into state vectors and then running the above call. Or . ```; out = np.polyval(; (0.5*g * vector / np.sqrt(scipy.special.factorial(ns)))[::-1],; alpha.conj,; ); ```. But the object `alpha` now constructed with `_qfunc_alpha_matrix` class is a bit difficult to understand. The variable `self.conj = np.empty(x.shape, dtype=np.complex128)` creates a tensor and sets it to a mesh grid (x, -y), but then what does the `__call__()` return? The tensor of `coherent_dm(x+iy)` for each x and y coordinate? But how is it computing it without knowing the Hilbert space dim for the state, which I think is computed on the fly by `ns = np.arange(first, last).reshape(1, 1, -1)`. It seems it caches the `coherent_d",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1583#issuecomment-877241762
https://github.com/qutip/qutip/pull/1583#issuecomment-877241762:1160,Usability,simpl,simple,1160,"specific use cases. My idea was a bit more simple - precomputing the `coherent_dm` operators (using qutip.coherent_dm) and using the `expect` function. But that performs worse that the original `qfunc` as well as this implementation of course. So this is great. I would be happy to merge this but have one thought:. This new implementation is sacrificing the ease-of-understanding of how Q-functions are computed with a very efficient and fast, but complicated class-based implementation. This means that users who want to look under the hood will not fully understand how this is working. I believe the crux of this implementation is a fast computation of the tensors of `coherent_dm` operators for all the alpha values at (x + iy). Personally, on many occasions, I have looked at qutip implementations of quantum operations just to understand what is happening under the hood and I believe several users have often done this to hack around. If someone were to try and understand Q-function computation from this code, it seems simple enough with the call:. ```; np.abs(np.dot(alphas, (self._g*0.5)*vector))**2; ```. for state vectors, or decomposing a density matrix into state vectors and then running the above call. Or . ```; out = np.polyval(; (0.5*g * vector / np.sqrt(scipy.special.factorial(ns)))[::-1],; alpha.conj,; ); ```. But the object `alpha` now constructed with `_qfunc_alpha_matrix` class is a bit difficult to understand. The variable `self.conj = np.empty(x.shape, dtype=np.complex128)` creates a tensor and sets it to a mesh grid (x, -y), but then what does the `__call__()` return? The tensor of `coherent_dm(x+iy)` for each x and y coordinate? But how is it computing it without knowing the Hilbert space dim for the state, which I think is computed on the fly by `ns = np.arange(first, last).reshape(1, 1, -1)`. It seems it caches the `coherent_dm` computed upto `current_size` and then extends it to `size` for new Hilbert space dimensions. . I am sorry if I am being a bit t",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1583#issuecomment-877241762
https://github.com/qutip/qutip/pull/1583#issuecomment-877241762:2556,Usability,simpl,simplify,2556,"er the hood will not fully understand how this is working. I believe the crux of this implementation is a fast computation of the tensors of `coherent_dm` operators for all the alpha values at (x + iy). Personally, on many occasions, I have looked at qutip implementations of quantum operations just to understand what is happening under the hood and I believe several users have often done this to hack around. If someone were to try and understand Q-function computation from this code, it seems simple enough with the call:. ```; np.abs(np.dot(alphas, (self._g*0.5)*vector))**2; ```. for state vectors, or decomposing a density matrix into state vectors and then running the above call. Or . ```; out = np.polyval(; (0.5*g * vector / np.sqrt(scipy.special.factorial(ns)))[::-1],; alpha.conj,; ); ```. But the object `alpha` now constructed with `_qfunc_alpha_matrix` class is a bit difficult to understand. The variable `self.conj = np.empty(x.shape, dtype=np.complex128)` creates a tensor and sets it to a mesh grid (x, -y), but then what does the `__call__()` return? The tensor of `coherent_dm(x+iy)` for each x and y coordinate? But how is it computing it without knowing the Hilbert space dim for the state, which I think is computed on the fly by `ns = np.arange(first, last).reshape(1, 1, -1)`. It seems it caches the `coherent_dm` computed upto `current_size` and then extends it to `size` for new Hilbert space dimensions. . I am sorry if I am being a bit thick here because I understand the overall idea of the code but somehow I am not confident it will be easy for others to understand on first read. Do you think we can make it a bit more transparent how the `_qfunc_alpha_matrix` works and that the crux of the method is computing the operators `coherent_dm` in an efficient way and saving them? If I have understood the code correct, I could try to document it a bit more and simplify it. . Let me know your thoughts and correct me if I misunderstood something @jakelishman @Ericgig",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1583#issuecomment-877241762
https://github.com/qutip/qutip/pull/1583#issuecomment-877254212:1268,Deployability,pipeline,pipelined,1268,"Well, the default implementation for states is actually nearly completely unchanged (the only difference is that I replaced `np.fliplr(array)` with `array[::-1]`, which I think is a more readable idiom for ""backwards""). You're right that in the new form, basically the method is that you cache various parts of the `np.polyval` call into a 3D tensor, rather than recomputing this large polynomial each time. The `np.polyval` call is how you actually go from an array of different values of `alpha` (which comes from the meshgrid) to the coherent state, but doing it with `polyval` means you construct the coherent state and do the dot product simultaneously to save memory. If you need to repeat the calculations a bunch, and you've got enough memory to spare, you can build up all the `alpha**n / sqrt(factorial(n))` tensor once, then just dot it against every state. Since we're dealing with _complex_ Hilbert spaces, the inner product isn't a straight dot product, it needs the conjugate of one of the sides, so we only store the conjugate of the alpha tensor. You can see in the timings that this isn't _always_ the biggest win you'd expect; in some cases, the additional memory usage causes you to be more heavily bound by memory bandwidth issues rather than CPU pipelined stuff, which is another reason we allow forcing either method to be used. If you're interested in the most readable implementation, you might want to look at the test:; https://github.com/qutip/qutip/blob/a20c26307e2f6e738f87efd75abafc3dff4daad5/qutip/tests/test_wigner.py#L251-L260",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1583#issuecomment-877254212
https://github.com/qutip/qutip/pull/1583#issuecomment-877254212:288,Performance,cache,cache,288,"Well, the default implementation for states is actually nearly completely unchanged (the only difference is that I replaced `np.fliplr(array)` with `array[::-1]`, which I think is a more readable idiom for ""backwards""). You're right that in the new form, basically the method is that you cache various parts of the `np.polyval` call into a 3D tensor, rather than recomputing this large polynomial each time. The `np.polyval` call is how you actually go from an array of different values of `alpha` (which comes from the meshgrid) to the coherent state, but doing it with `polyval` means you construct the coherent state and do the dot product simultaneously to save memory. If you need to repeat the calculations a bunch, and you've got enough memory to spare, you can build up all the `alpha**n / sqrt(factorial(n))` tensor once, then just dot it against every state. Since we're dealing with _complex_ Hilbert spaces, the inner product isn't a straight dot product, it needs the conjugate of one of the sides, so we only store the conjugate of the alpha tensor. You can see in the timings that this isn't _always_ the biggest win you'd expect; in some cases, the additional memory usage causes you to be more heavily bound by memory bandwidth issues rather than CPU pipelined stuff, which is another reason we allow forcing either method to be used. If you're interested in the most readable implementation, you might want to look at the test:; https://github.com/qutip/qutip/blob/a20c26307e2f6e738f87efd75abafc3dff4daad5/qutip/tests/test_wigner.py#L251-L260",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1583#issuecomment-877254212
https://github.com/qutip/qutip/pull/1583#issuecomment-877254212:1440,Testability,test,test,1440,"Well, the default implementation for states is actually nearly completely unchanged (the only difference is that I replaced `np.fliplr(array)` with `array[::-1]`, which I think is a more readable idiom for ""backwards""). You're right that in the new form, basically the method is that you cache various parts of the `np.polyval` call into a 3D tensor, rather than recomputing this large polynomial each time. The `np.polyval` call is how you actually go from an array of different values of `alpha` (which comes from the meshgrid) to the coherent state, but doing it with `polyval` means you construct the coherent state and do the dot product simultaneously to save memory. If you need to repeat the calculations a bunch, and you've got enough memory to spare, you can build up all the `alpha**n / sqrt(factorial(n))` tensor once, then just dot it against every state. Since we're dealing with _complex_ Hilbert spaces, the inner product isn't a straight dot product, it needs the conjugate of one of the sides, so we only store the conjugate of the alpha tensor. You can see in the timings that this isn't _always_ the biggest win you'd expect; in some cases, the additional memory usage causes you to be more heavily bound by memory bandwidth issues rather than CPU pipelined stuff, which is another reason we allow forcing either method to be used. If you're interested in the most readable implementation, you might want to look at the test:; https://github.com/qutip/qutip/blob/a20c26307e2f6e738f87efd75abafc3dff4daad5/qutip/tests/test_wigner.py#L251-L260",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1583#issuecomment-877254212
https://github.com/qutip/qutip/pull/1583#issuecomment-877254212:1530,Testability,test,tests,1530,"Well, the default implementation for states is actually nearly completely unchanged (the only difference is that I replaced `np.fliplr(array)` with `array[::-1]`, which I think is a more readable idiom for ""backwards""). You're right that in the new form, basically the method is that you cache various parts of the `np.polyval` call into a 3D tensor, rather than recomputing this large polynomial each time. The `np.polyval` call is how you actually go from an array of different values of `alpha` (which comes from the meshgrid) to the coherent state, but doing it with `polyval` means you construct the coherent state and do the dot product simultaneously to save memory. If you need to repeat the calculations a bunch, and you've got enough memory to spare, you can build up all the `alpha**n / sqrt(factorial(n))` tensor once, then just dot it against every state. Since we're dealing with _complex_ Hilbert spaces, the inner product isn't a straight dot product, it needs the conjugate of one of the sides, so we only store the conjugate of the alpha tensor. You can see in the timings that this isn't _always_ the biggest win you'd expect; in some cases, the additional memory usage causes you to be more heavily bound by memory bandwidth issues rather than CPU pipelined stuff, which is another reason we allow forcing either method to be used. If you're interested in the most readable implementation, you might want to look at the test:; https://github.com/qutip/qutip/blob/a20c26307e2f6e738f87efd75abafc3dff4daad5/qutip/tests/test_wigner.py#L251-L260",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1583#issuecomment-877254212
https://github.com/qutip/qutip/pull/1583#issuecomment-877266741:348,Performance,cache,cache,348,"Oh, also to answer the question more explicitly about `_qfunc_alpha_matrix.__call__`: _that_ function always re-computes the matrix of alphas, returning the relevant bits of the Fock space. The caching behaviour is in the `QFunc` class itself, which manages how many Fock states it needs (see `QFunc._alphas`, which tries to pull the matrix from a cache, or expands the cache if necessary). `QFunc.__call__` calculates the Q function of any quantum state over the given phase-space coordinates, no matter how large the size of Hilbert space of the state is - that means it's got feature parity with `qfunc` in the sense that both; ```python; iterative = functools.partial(qutip.qfunc, xvec=xs, yvec=ys); classbased = qutip.QFunc(xs, ys); ```; can be called with the same objects, and will return the same result, even if the objects change size in between. I see this as sensible functionality in general - if you're plotting a few graphs, it's quite possible that you haven't calculated all your states with the same amount of Fock-space truncation (I frequently scaled the calculation sizes in my PhD for speed), so it's not very useful if the class-based version can only handle fixed Hilbert spaces.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1583#issuecomment-877266741
https://github.com/qutip/qutip/pull/1583#issuecomment-877266741:370,Performance,cache,cache,370,"Oh, also to answer the question more explicitly about `_qfunc_alpha_matrix.__call__`: _that_ function always re-computes the matrix of alphas, returning the relevant bits of the Fock space. The caching behaviour is in the `QFunc` class itself, which manages how many Fock states it needs (see `QFunc._alphas`, which tries to pull the matrix from a cache, or expands the cache if necessary). `QFunc.__call__` calculates the Q function of any quantum state over the given phase-space coordinates, no matter how large the size of Hilbert space of the state is - that means it's got feature parity with `qfunc` in the sense that both; ```python; iterative = functools.partial(qutip.qfunc, xvec=xs, yvec=ys); classbased = qutip.QFunc(xs, ys); ```; can be called with the same objects, and will return the same result, even if the objects change size in between. I see this as sensible functionality in general - if you're plotting a few graphs, it's quite possible that you haven't calculated all your states with the same amount of Fock-space truncation (I frequently scaled the calculation sizes in my PhD for speed), so it's not very useful if the class-based version can only handle fixed Hilbert spaces.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1583#issuecomment-877266741
https://github.com/qutip/qutip/pull/1583#issuecomment-877273495:41,Performance,cache,cache,41,"Thanks Jake, I understand better how the cache is working. Okay let me suggest a few comments within the code so that we (or at least I) can keep track of how this implementation works. If you think they are sensible then feel free to accept and then we can merge this.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1583#issuecomment-877273495
https://github.com/qutip/qutip/pull/1583#issuecomment-877301763:272,Availability,mainten,maintenance,272,"@jakelishman Thanks for this really great PR. I have just a few comments to add to keep track of the private class `_alpha_matrix` and how it behaves. No changes to the code so if you think these comments are reasonable and can help to clarify how it all works for future maintenance, then go ahead and add them and we can merge this.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1583#issuecomment-877301763
https://github.com/qutip/qutip/pull/1583#issuecomment-878145441:322,Availability,error,errors,322,"You want to be very careful using black - we haven't applied it to most of the codebase, so if you're letting it run, then it's going to produce large unrelated changes everywhere and make the PR harder to understand. Also, black doesn't abide by the exact set of rules set up in codeclimate, so it'll also add a bunch of errors. This would be part of a larger change we'd have to make across the whole codebase separately. (*note*: everything I wrote was already codeclimate-compatible - it's probably better to remove the two commits running black)",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1583#issuecomment-878145441
https://github.com/qutip/qutip/pull/1583#issuecomment-878151587:291,Testability,log,logical,291,"Also, once you're done, leave this PR without merging and I'll tidy up the commit history. We shouldn't have things like 374debd (a wrong-way merge) because they really mess with the mainline of the history, and make things harder to traceback, and I can collapse all your changes into one ""logical"" change once it's working.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1583#issuecomment-878151587
https://github.com/qutip/qutip/pull/1583#issuecomment-878190588:293,Testability,log,logical,293,"> Also, once you're done, leave this PR without merging and I'll tidy up the commit history. We shouldn't have things like 374debd (a wrong-way merge) because they really mess with the mainline of the history, and make things harder to traceback, and I can collapse all your changes into one ""logical"" change once it's working. . Ok. But what would be the better way to merge master here then?",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1583#issuecomment-878190588
https://github.com/qutip/qutip/pull/1583#issuecomment-878194970:31,Deployability,patch,patch,31,"Without the black changes, the patch would have applied cleanly, I think. With them, it's better to wait til the end, and then rebase the PR on top of master (in git, not github), then merge the PR into master as normal. The rebase is a destructive operation (rewrites history of the PR), so we have to take more care when working with more than one person, but it's better afterwards. I've heard this called a few things - Atlassian calls it a ""foxtrot merge"", for example. Here's a blog post they made about them, and some of the problems: https://blog.developer.atlassian.com/stop-foxtrots-now/. *Edit*: I usually wouldn't care about this, and we'd just squash the PR into a single commit to avoid all these problems, but in this particular case, the PR is kind of like two logical things at once. First it does @dweigand's original PR (but completed), and then it does what could have been another improvement change to all the code. We want to preserve the history in source control of the original PR (so you can see the changes I made to speed it up), so it needs to go in as two separate commits, doing a regular merge. If you're working on your own stuff, normally you'd be able to just squash and be done with it.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1583#issuecomment-878194970
https://github.com/qutip/qutip/pull/1583#issuecomment-878194970:260,Modifiability,rewrite,rewrites,260,"Without the black changes, the patch would have applied cleanly, I think. With them, it's better to wait til the end, and then rebase the PR on top of master (in git, not github), then merge the PR into master as normal. The rebase is a destructive operation (rewrites history of the PR), so we have to take more care when working with more than one person, but it's better afterwards. I've heard this called a few things - Atlassian calls it a ""foxtrot merge"", for example. Here's a blog post they made about them, and some of the problems: https://blog.developer.atlassian.com/stop-foxtrots-now/. *Edit*: I usually wouldn't care about this, and we'd just squash the PR into a single commit to avoid all these problems, but in this particular case, the PR is kind of like two logical things at once. First it does @dweigand's original PR (but completed), and then it does what could have been another improvement change to all the code. We want to preserve the history in source control of the original PR (so you can see the changes I made to speed it up), so it needs to go in as two separate commits, doing a regular merge. If you're working on your own stuff, normally you'd be able to just squash and be done with it.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1583#issuecomment-878194970
https://github.com/qutip/qutip/pull/1583#issuecomment-878194970:695,Safety,avoid,avoid,695,"Without the black changes, the patch would have applied cleanly, I think. With them, it's better to wait til the end, and then rebase the PR on top of master (in git, not github), then merge the PR into master as normal. The rebase is a destructive operation (rewrites history of the PR), so we have to take more care when working with more than one person, but it's better afterwards. I've heard this called a few things - Atlassian calls it a ""foxtrot merge"", for example. Here's a blog post they made about them, and some of the problems: https://blog.developer.atlassian.com/stop-foxtrots-now/. *Edit*: I usually wouldn't care about this, and we'd just squash the PR into a single commit to avoid all these problems, but in this particular case, the PR is kind of like two logical things at once. First it does @dweigand's original PR (but completed), and then it does what could have been another improvement change to all the code. We want to preserve the history in source control of the original PR (so you can see the changes I made to speed it up), so it needs to go in as two separate commits, doing a regular merge. If you're working on your own stuff, normally you'd be able to just squash and be done with it.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1583#issuecomment-878194970
https://github.com/qutip/qutip/pull/1583#issuecomment-878194970:777,Testability,log,logical,777,"Without the black changes, the patch would have applied cleanly, I think. With them, it's better to wait til the end, and then rebase the PR on top of master (in git, not github), then merge the PR into master as normal. The rebase is a destructive operation (rewrites history of the PR), so we have to take more care when working with more than one person, but it's better afterwards. I've heard this called a few things - Atlassian calls it a ""foxtrot merge"", for example. Here's a blog post they made about them, and some of the problems: https://blog.developer.atlassian.com/stop-foxtrots-now/. *Edit*: I usually wouldn't care about this, and we'd just squash the PR into a single commit to avoid all these problems, but in this particular case, the PR is kind of like two logical things at once. First it does @dweigand's original PR (but completed), and then it does what could have been another improvement change to all the code. We want to preserve the history in source control of the original PR (so you can see the changes I made to speed it up), so it needs to go in as two separate commits, doing a regular merge. If you're working on your own stuff, normally you'd be able to just squash and be done with it.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1583#issuecomment-878194970
https://github.com/qutip/qutip/pull/1584#issuecomment-865241663:160,Security,access,access,160,"I know this is a very simple change, but could we add a test that it works? E.g. maybe a test in which we subclass `Data` and then create an instance of it and access shape?. And perhaps a test that shows that shape is immutable?",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1584#issuecomment-865241663
https://github.com/qutip/qutip/pull/1584#issuecomment-865241663:56,Testability,test,test,56,"I know this is a very simple change, but could we add a test that it works? E.g. maybe a test in which we subclass `Data` and then create an instance of it and access shape?. And perhaps a test that shows that shape is immutable?",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1584#issuecomment-865241663
https://github.com/qutip/qutip/pull/1584#issuecomment-865241663:89,Testability,test,test,89,"I know this is a very simple change, but could we add a test that it works? E.g. maybe a test in which we subclass `Data` and then create an instance of it and access shape?. And perhaps a test that shows that shape is immutable?",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1584#issuecomment-865241663
https://github.com/qutip/qutip/pull/1584#issuecomment-865241663:189,Testability,test,test,189,"I know this is a very simple change, but could we add a test that it works? E.g. maybe a test in which we subclass `Data` and then create an instance of it and access shape?. And perhaps a test that shows that shape is immutable?",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1584#issuecomment-865241663
https://github.com/qutip/qutip/pull/1584#issuecomment-865241663:22,Usability,simpl,simple,22,"I know this is a very simple change, but could we add a test that it works? E.g. maybe a test in which we subclass `Data` and then create an instance of it and access shape?. And perhaps a test that shows that shape is immutable?",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1584#issuecomment-865241663
https://github.com/qutip/qutip/issues/1585#issuecomment-865881447:284,Testability,test,tests,284,"Thanks Kosuke-san! This does look like a genuine bug, seems to be because when constructing the propagator, the dims on the initial state are not set, and this clashes with very recent fixes done on mesolve (e.g., https://github.com/qutip/qutip/pull/1459 ). This wasn't caught by the tests during the above fixes because it seems like the only composite system test is done on a noiseless system, so mesolve isn't called in the propagator construction for that test. thanks for pointing this out.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1585#issuecomment-865881447
https://github.com/qutip/qutip/issues/1585#issuecomment-865881447:361,Testability,test,test,361,"Thanks Kosuke-san! This does look like a genuine bug, seems to be because when constructing the propagator, the dims on the initial state are not set, and this clashes with very recent fixes done on mesolve (e.g., https://github.com/qutip/qutip/pull/1459 ). This wasn't caught by the tests during the above fixes because it seems like the only composite system test is done on a noiseless system, so mesolve isn't called in the propagator construction for that test. thanks for pointing this out.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1585#issuecomment-865881447
https://github.com/qutip/qutip/issues/1585#issuecomment-865881447:461,Testability,test,test,461,"Thanks Kosuke-san! This does look like a genuine bug, seems to be because when constructing the propagator, the dims on the initial state are not set, and this clashes with very recent fixes done on mesolve (e.g., https://github.com/qutip/qutip/pull/1459 ). This wasn't caught by the tests during the above fixes because it seems like the only composite system test is done on a noiseless system, so mesolve isn't called in the propagator construction for that test. thanks for pointing this out.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1585#issuecomment-865881447
https://github.com/qutip/qutip/issues/1585#issuecomment-865903199:720,Availability,toler,tolerances,720,"Yeah, this feels like a bug in `propagator` - I bet at some point we do `qeye(L.shape[0])` instead of `qeye(L.dims[0])`. There's sometimes quite a bit of that in older code - it used to slip through because we weren't super strict about dimension handling, so in certain cases (like this one), we'd accept bad dimensions. I might try and have a look tonight (UK time), if I have time - I've wanted to break up the large `propagator` monolith into smaller components for quite a while. ---. About numerical precision: if you want to try increasing the precision of the integrators, try passing `options=qutip.Options(nsteps=1_000_000, atol=1e-12, rtol=1e-10)` to `propagator`. `atol` and `rtol` are absolute and relative tolerances respectively, and `nsteps` is the number of subdivisions the integrator is _allowed_ to take (if it reaches its tolerance goals, it won't take all of them). You'll find that `atol` and `rtol` will have only a loose relation to the tolerance of your fidelity value, because there's a _lot_ of floating-point operations between those points in which the errors compound, and there's a hard limit on the tolerances the integrator can achieve, so you might not be able to get a perfect answer. The fidelity calculation involves finding the square root of a density operator, so that's another large possible source of error. About times: if you only care about the state at the last time, setting `tlist = np.linspace(0, x, 201)` is quite inefficient. Instead, set `tlist = [0, x]`, and then pass `options=qutip.Options(nsteps=<very very big integer>)`. It's more efficient because it doesn't need to achieve tolerance goals and construct/store `Qobj` instances at every intermediate timestep. Temporary workaround: this is _very_ temporary, and generally a bad idea in QuTiP, but you can ""flatten"" all your operators into a single space for now, while we implement a fix. To do that:; ```python; # initial setup; H = qutip.tensor(...); c_ops = [qutip.tensor(...)]. original",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1585#issuecomment-865903199
https://github.com/qutip/qutip/issues/1585#issuecomment-865903199:843,Availability,toler,tolerance,843,"Yeah, this feels like a bug in `propagator` - I bet at some point we do `qeye(L.shape[0])` instead of `qeye(L.dims[0])`. There's sometimes quite a bit of that in older code - it used to slip through because we weren't super strict about dimension handling, so in certain cases (like this one), we'd accept bad dimensions. I might try and have a look tonight (UK time), if I have time - I've wanted to break up the large `propagator` monolith into smaller components for quite a while. ---. About numerical precision: if you want to try increasing the precision of the integrators, try passing `options=qutip.Options(nsteps=1_000_000, atol=1e-12, rtol=1e-10)` to `propagator`. `atol` and `rtol` are absolute and relative tolerances respectively, and `nsteps` is the number of subdivisions the integrator is _allowed_ to take (if it reaches its tolerance goals, it won't take all of them). You'll find that `atol` and `rtol` will have only a loose relation to the tolerance of your fidelity value, because there's a _lot_ of floating-point operations between those points in which the errors compound, and there's a hard limit on the tolerances the integrator can achieve, so you might not be able to get a perfect answer. The fidelity calculation involves finding the square root of a density operator, so that's another large possible source of error. About times: if you only care about the state at the last time, setting `tlist = np.linspace(0, x, 201)` is quite inefficient. Instead, set `tlist = [0, x]`, and then pass `options=qutip.Options(nsteps=<very very big integer>)`. It's more efficient because it doesn't need to achieve tolerance goals and construct/store `Qobj` instances at every intermediate timestep. Temporary workaround: this is _very_ temporary, and generally a bad idea in QuTiP, but you can ""flatten"" all your operators into a single space for now, while we implement a fix. To do that:; ```python; # initial setup; H = qutip.tensor(...); c_ops = [qutip.tensor(...)]. original",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1585#issuecomment-865903199
https://github.com/qutip/qutip/issues/1585#issuecomment-865903199:962,Availability,toler,tolerance,962,"t some point we do `qeye(L.shape[0])` instead of `qeye(L.dims[0])`. There's sometimes quite a bit of that in older code - it used to slip through because we weren't super strict about dimension handling, so in certain cases (like this one), we'd accept bad dimensions. I might try and have a look tonight (UK time), if I have time - I've wanted to break up the large `propagator` monolith into smaller components for quite a while. ---. About numerical precision: if you want to try increasing the precision of the integrators, try passing `options=qutip.Options(nsteps=1_000_000, atol=1e-12, rtol=1e-10)` to `propagator`. `atol` and `rtol` are absolute and relative tolerances respectively, and `nsteps` is the number of subdivisions the integrator is _allowed_ to take (if it reaches its tolerance goals, it won't take all of them). You'll find that `atol` and `rtol` will have only a loose relation to the tolerance of your fidelity value, because there's a _lot_ of floating-point operations between those points in which the errors compound, and there's a hard limit on the tolerances the integrator can achieve, so you might not be able to get a perfect answer. The fidelity calculation involves finding the square root of a density operator, so that's another large possible source of error. About times: if you only care about the state at the last time, setting `tlist = np.linspace(0, x, 201)` is quite inefficient. Instead, set `tlist = [0, x]`, and then pass `options=qutip.Options(nsteps=<very very big integer>)`. It's more efficient because it doesn't need to achieve tolerance goals and construct/store `Qobj` instances at every intermediate timestep. Temporary workaround: this is _very_ temporary, and generally a bad idea in QuTiP, but you can ""flatten"" all your operators into a single space for now, while we implement a fix. To do that:; ```python; # initial setup; H = qutip.tensor(...); c_ops = [qutip.tensor(...)]. original_dimensions = H.dims.copy(); new_dimensions = list(H.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1585#issuecomment-865903199
https://github.com/qutip/qutip/issues/1585#issuecomment-865903199:1083,Availability,error,errors,1083,"t some point we do `qeye(L.shape[0])` instead of `qeye(L.dims[0])`. There's sometimes quite a bit of that in older code - it used to slip through because we weren't super strict about dimension handling, so in certain cases (like this one), we'd accept bad dimensions. I might try and have a look tonight (UK time), if I have time - I've wanted to break up the large `propagator` monolith into smaller components for quite a while. ---. About numerical precision: if you want to try increasing the precision of the integrators, try passing `options=qutip.Options(nsteps=1_000_000, atol=1e-12, rtol=1e-10)` to `propagator`. `atol` and `rtol` are absolute and relative tolerances respectively, and `nsteps` is the number of subdivisions the integrator is _allowed_ to take (if it reaches its tolerance goals, it won't take all of them). You'll find that `atol` and `rtol` will have only a loose relation to the tolerance of your fidelity value, because there's a _lot_ of floating-point operations between those points in which the errors compound, and there's a hard limit on the tolerances the integrator can achieve, so you might not be able to get a perfect answer. The fidelity calculation involves finding the square root of a density operator, so that's another large possible source of error. About times: if you only care about the state at the last time, setting `tlist = np.linspace(0, x, 201)` is quite inefficient. Instead, set `tlist = [0, x]`, and then pass `options=qutip.Options(nsteps=<very very big integer>)`. It's more efficient because it doesn't need to achieve tolerance goals and construct/store `Qobj` instances at every intermediate timestep. Temporary workaround: this is _very_ temporary, and generally a bad idea in QuTiP, but you can ""flatten"" all your operators into a single space for now, while we implement a fix. To do that:; ```python; # initial setup; H = qutip.tensor(...); c_ops = [qutip.tensor(...)]. original_dimensions = H.dims.copy(); new_dimensions = list(H.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1585#issuecomment-865903199
https://github.com/qutip/qutip/issues/1585#issuecomment-865903199:1132,Availability,toler,tolerances,1132,"t some point we do `qeye(L.shape[0])` instead of `qeye(L.dims[0])`. There's sometimes quite a bit of that in older code - it used to slip through because we weren't super strict about dimension handling, so in certain cases (like this one), we'd accept bad dimensions. I might try and have a look tonight (UK time), if I have time - I've wanted to break up the large `propagator` monolith into smaller components for quite a while. ---. About numerical precision: if you want to try increasing the precision of the integrators, try passing `options=qutip.Options(nsteps=1_000_000, atol=1e-12, rtol=1e-10)` to `propagator`. `atol` and `rtol` are absolute and relative tolerances respectively, and `nsteps` is the number of subdivisions the integrator is _allowed_ to take (if it reaches its tolerance goals, it won't take all of them). You'll find that `atol` and `rtol` will have only a loose relation to the tolerance of your fidelity value, because there's a _lot_ of floating-point operations between those points in which the errors compound, and there's a hard limit on the tolerances the integrator can achieve, so you might not be able to get a perfect answer. The fidelity calculation involves finding the square root of a density operator, so that's another large possible source of error. About times: if you only care about the state at the last time, setting `tlist = np.linspace(0, x, 201)` is quite inefficient. Instead, set `tlist = [0, x]`, and then pass `options=qutip.Options(nsteps=<very very big integer>)`. It's more efficient because it doesn't need to achieve tolerance goals and construct/store `Qobj` instances at every intermediate timestep. Temporary workaround: this is _very_ temporary, and generally a bad idea in QuTiP, but you can ""flatten"" all your operators into a single space for now, while we implement a fix. To do that:; ```python; # initial setup; H = qutip.tensor(...); c_ops = [qutip.tensor(...)]. original_dimensions = H.dims.copy(); new_dimensions = list(H.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1585#issuecomment-865903199
https://github.com/qutip/qutip/issues/1585#issuecomment-865903199:1345,Availability,error,error,1345,"is one), we'd accept bad dimensions. I might try and have a look tonight (UK time), if I have time - I've wanted to break up the large `propagator` monolith into smaller components for quite a while. ---. About numerical precision: if you want to try increasing the precision of the integrators, try passing `options=qutip.Options(nsteps=1_000_000, atol=1e-12, rtol=1e-10)` to `propagator`. `atol` and `rtol` are absolute and relative tolerances respectively, and `nsteps` is the number of subdivisions the integrator is _allowed_ to take (if it reaches its tolerance goals, it won't take all of them). You'll find that `atol` and `rtol` will have only a loose relation to the tolerance of your fidelity value, because there's a _lot_ of floating-point operations between those points in which the errors compound, and there's a hard limit on the tolerances the integrator can achieve, so you might not be able to get a perfect answer. The fidelity calculation involves finding the square root of a density operator, so that's another large possible source of error. About times: if you only care about the state at the last time, setting `tlist = np.linspace(0, x, 201)` is quite inefficient. Instead, set `tlist = [0, x]`, and then pass `options=qutip.Options(nsteps=<very very big integer>)`. It's more efficient because it doesn't need to achieve tolerance goals and construct/store `Qobj` instances at every intermediate timestep. Temporary workaround: this is _very_ temporary, and generally a bad idea in QuTiP, but you can ""flatten"" all your operators into a single space for now, while we implement a fix. To do that:; ```python; # initial setup; H = qutip.tensor(...); c_ops = [qutip.tensor(...)]. original_dimensions = H.dims.copy(); new_dimensions = list(H.shape). H.dims = new_dimensions; for c_op in c_ops:; c_op.dims = new_dimensions. outputs = qutip.propagator(H, times, c_ops=c_ops); for op in outputs:; # the ops are superoperators, so have expanded dimensions; op.dims = [original_d",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1585#issuecomment-865903199
https://github.com/qutip/qutip/issues/1585#issuecomment-865903199:1636,Availability,toler,tolerance,1636,"I might try and have a look tonight (UK time), if I have time - I've wanted to break up the large `propagator` monolith into smaller components for quite a while. ---. About numerical precision: if you want to try increasing the precision of the integrators, try passing `options=qutip.Options(nsteps=1_000_000, atol=1e-12, rtol=1e-10)` to `propagator`. `atol` and `rtol` are absolute and relative tolerances respectively, and `nsteps` is the number of subdivisions the integrator is _allowed_ to take (if it reaches its tolerance goals, it won't take all of them). You'll find that `atol` and `rtol` will have only a loose relation to the tolerance of your fidelity value, because there's a _lot_ of floating-point operations between those points in which the errors compound, and there's a hard limit on the tolerances the integrator can achieve, so you might not be able to get a perfect answer. The fidelity calculation involves finding the square root of a density operator, so that's another large possible source of error. About times: if you only care about the state at the last time, setting `tlist = np.linspace(0, x, 201)` is quite inefficient. Instead, set `tlist = [0, x]`, and then pass `options=qutip.Options(nsteps=<very very big integer>)`. It's more efficient because it doesn't need to achieve tolerance goals and construct/store `Qobj` instances at every intermediate timestep. Temporary workaround: this is _very_ temporary, and generally a bad idea in QuTiP, but you can ""flatten"" all your operators into a single space for now, while we implement a fix. To do that:; ```python; # initial setup; H = qutip.tensor(...); c_ops = [qutip.tensor(...)]. original_dimensions = H.dims.copy(); new_dimensions = list(H.shape). H.dims = new_dimensions; for c_op in c_ops:; c_op.dims = new_dimensions. outputs = qutip.propagator(H, times, c_ops=c_ops); for op in outputs:; # the ops are superoperators, so have expanded dimensions; op.dims = [original_dimensions, original_dimensions]; ```",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1585#issuecomment-865903199
https://github.com/qutip/qutip/issues/1585#issuecomment-865903199:568,Deployability,integrat,integrators,568,"Yeah, this feels like a bug in `propagator` - I bet at some point we do `qeye(L.shape[0])` instead of `qeye(L.dims[0])`. There's sometimes quite a bit of that in older code - it used to slip through because we weren't super strict about dimension handling, so in certain cases (like this one), we'd accept bad dimensions. I might try and have a look tonight (UK time), if I have time - I've wanted to break up the large `propagator` monolith into smaller components for quite a while. ---. About numerical precision: if you want to try increasing the precision of the integrators, try passing `options=qutip.Options(nsteps=1_000_000, atol=1e-12, rtol=1e-10)` to `propagator`. `atol` and `rtol` are absolute and relative tolerances respectively, and `nsteps` is the number of subdivisions the integrator is _allowed_ to take (if it reaches its tolerance goals, it won't take all of them). You'll find that `atol` and `rtol` will have only a loose relation to the tolerance of your fidelity value, because there's a _lot_ of floating-point operations between those points in which the errors compound, and there's a hard limit on the tolerances the integrator can achieve, so you might not be able to get a perfect answer. The fidelity calculation involves finding the square root of a density operator, so that's another large possible source of error. About times: if you only care about the state at the last time, setting `tlist = np.linspace(0, x, 201)` is quite inefficient. Instead, set `tlist = [0, x]`, and then pass `options=qutip.Options(nsteps=<very very big integer>)`. It's more efficient because it doesn't need to achieve tolerance goals and construct/store `Qobj` instances at every intermediate timestep. Temporary workaround: this is _very_ temporary, and generally a bad idea in QuTiP, but you can ""flatten"" all your operators into a single space for now, while we implement a fix. To do that:; ```python; # initial setup; H = qutip.tensor(...); c_ops = [qutip.tensor(...)]. original",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1585#issuecomment-865903199
https://github.com/qutip/qutip/issues/1585#issuecomment-865903199:792,Deployability,integrat,integrator,792,"Yeah, this feels like a bug in `propagator` - I bet at some point we do `qeye(L.shape[0])` instead of `qeye(L.dims[0])`. There's sometimes quite a bit of that in older code - it used to slip through because we weren't super strict about dimension handling, so in certain cases (like this one), we'd accept bad dimensions. I might try and have a look tonight (UK time), if I have time - I've wanted to break up the large `propagator` monolith into smaller components for quite a while. ---. About numerical precision: if you want to try increasing the precision of the integrators, try passing `options=qutip.Options(nsteps=1_000_000, atol=1e-12, rtol=1e-10)` to `propagator`. `atol` and `rtol` are absolute and relative tolerances respectively, and `nsteps` is the number of subdivisions the integrator is _allowed_ to take (if it reaches its tolerance goals, it won't take all of them). You'll find that `atol` and `rtol` will have only a loose relation to the tolerance of your fidelity value, because there's a _lot_ of floating-point operations between those points in which the errors compound, and there's a hard limit on the tolerances the integrator can achieve, so you might not be able to get a perfect answer. The fidelity calculation involves finding the square root of a density operator, so that's another large possible source of error. About times: if you only care about the state at the last time, setting `tlist = np.linspace(0, x, 201)` is quite inefficient. Instead, set `tlist = [0, x]`, and then pass `options=qutip.Options(nsteps=<very very big integer>)`. It's more efficient because it doesn't need to achieve tolerance goals and construct/store `Qobj` instances at every intermediate timestep. Temporary workaround: this is _very_ temporary, and generally a bad idea in QuTiP, but you can ""flatten"" all your operators into a single space for now, while we implement a fix. To do that:; ```python; # initial setup; H = qutip.tensor(...); c_ops = [qutip.tensor(...)]. original",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1585#issuecomment-865903199
https://github.com/qutip/qutip/issues/1585#issuecomment-865903199:1147,Deployability,integrat,integrator,1147,"t some point we do `qeye(L.shape[0])` instead of `qeye(L.dims[0])`. There's sometimes quite a bit of that in older code - it used to slip through because we weren't super strict about dimension handling, so in certain cases (like this one), we'd accept bad dimensions. I might try and have a look tonight (UK time), if I have time - I've wanted to break up the large `propagator` monolith into smaller components for quite a while. ---. About numerical precision: if you want to try increasing the precision of the integrators, try passing `options=qutip.Options(nsteps=1_000_000, atol=1e-12, rtol=1e-10)` to `propagator`. `atol` and `rtol` are absolute and relative tolerances respectively, and `nsteps` is the number of subdivisions the integrator is _allowed_ to take (if it reaches its tolerance goals, it won't take all of them). You'll find that `atol` and `rtol` will have only a loose relation to the tolerance of your fidelity value, because there's a _lot_ of floating-point operations between those points in which the errors compound, and there's a hard limit on the tolerances the integrator can achieve, so you might not be able to get a perfect answer. The fidelity calculation involves finding the square root of a density operator, so that's another large possible source of error. About times: if you only care about the state at the last time, setting `tlist = np.linspace(0, x, 201)` is quite inefficient. Instead, set `tlist = [0, x]`, and then pass `options=qutip.Options(nsteps=<very very big integer>)`. It's more efficient because it doesn't need to achieve tolerance goals and construct/store `Qobj` instances at every intermediate timestep. Temporary workaround: this is _very_ temporary, and generally a bad idea in QuTiP, but you can ""flatten"" all your operators into a single space for now, while we implement a fix. To do that:; ```python; # initial setup; H = qutip.tensor(...); c_ops = [qutip.tensor(...)]. original_dimensions = H.dims.copy(); new_dimensions = list(H.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1585#issuecomment-865903199
https://github.com/qutip/qutip/issues/1585#issuecomment-865903199:1591,Energy Efficiency,efficient,efficient,1591,"I might try and have a look tonight (UK time), if I have time - I've wanted to break up the large `propagator` monolith into smaller components for quite a while. ---. About numerical precision: if you want to try increasing the precision of the integrators, try passing `options=qutip.Options(nsteps=1_000_000, atol=1e-12, rtol=1e-10)` to `propagator`. `atol` and `rtol` are absolute and relative tolerances respectively, and `nsteps` is the number of subdivisions the integrator is _allowed_ to take (if it reaches its tolerance goals, it won't take all of them). You'll find that `atol` and `rtol` will have only a loose relation to the tolerance of your fidelity value, because there's a _lot_ of floating-point operations between those points in which the errors compound, and there's a hard limit on the tolerances the integrator can achieve, so you might not be able to get a perfect answer. The fidelity calculation involves finding the square root of a density operator, so that's another large possible source of error. About times: if you only care about the state at the last time, setting `tlist = np.linspace(0, x, 201)` is quite inefficient. Instead, set `tlist = [0, x]`, and then pass `options=qutip.Options(nsteps=<very very big integer>)`. It's more efficient because it doesn't need to achieve tolerance goals and construct/store `Qobj` instances at every intermediate timestep. Temporary workaround: this is _very_ temporary, and generally a bad idea in QuTiP, but you can ""flatten"" all your operators into a single space for now, while we implement a fix. To do that:; ```python; # initial setup; H = qutip.tensor(...); c_ops = [qutip.tensor(...)]. original_dimensions = H.dims.copy(); new_dimensions = list(H.shape). H.dims = new_dimensions; for c_op in c_ops:; c_op.dims = new_dimensions. outputs = qutip.propagator(H, times, c_ops=c_ops); for op in outputs:; # the ops are superoperators, so have expanded dimensions; op.dims = [original_dimensions, original_dimensions]; ```",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1585#issuecomment-865903199
https://github.com/qutip/qutip/issues/1585#issuecomment-865903199:568,Integrability,integrat,integrators,568,"Yeah, this feels like a bug in `propagator` - I bet at some point we do `qeye(L.shape[0])` instead of `qeye(L.dims[0])`. There's sometimes quite a bit of that in older code - it used to slip through because we weren't super strict about dimension handling, so in certain cases (like this one), we'd accept bad dimensions. I might try and have a look tonight (UK time), if I have time - I've wanted to break up the large `propagator` monolith into smaller components for quite a while. ---. About numerical precision: if you want to try increasing the precision of the integrators, try passing `options=qutip.Options(nsteps=1_000_000, atol=1e-12, rtol=1e-10)` to `propagator`. `atol` and `rtol` are absolute and relative tolerances respectively, and `nsteps` is the number of subdivisions the integrator is _allowed_ to take (if it reaches its tolerance goals, it won't take all of them). You'll find that `atol` and `rtol` will have only a loose relation to the tolerance of your fidelity value, because there's a _lot_ of floating-point operations between those points in which the errors compound, and there's a hard limit on the tolerances the integrator can achieve, so you might not be able to get a perfect answer. The fidelity calculation involves finding the square root of a density operator, so that's another large possible source of error. About times: if you only care about the state at the last time, setting `tlist = np.linspace(0, x, 201)` is quite inefficient. Instead, set `tlist = [0, x]`, and then pass `options=qutip.Options(nsteps=<very very big integer>)`. It's more efficient because it doesn't need to achieve tolerance goals and construct/store `Qobj` instances at every intermediate timestep. Temporary workaround: this is _very_ temporary, and generally a bad idea in QuTiP, but you can ""flatten"" all your operators into a single space for now, while we implement a fix. To do that:; ```python; # initial setup; H = qutip.tensor(...); c_ops = [qutip.tensor(...)]. original",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1585#issuecomment-865903199
https://github.com/qutip/qutip/issues/1585#issuecomment-865903199:792,Integrability,integrat,integrator,792,"Yeah, this feels like a bug in `propagator` - I bet at some point we do `qeye(L.shape[0])` instead of `qeye(L.dims[0])`. There's sometimes quite a bit of that in older code - it used to slip through because we weren't super strict about dimension handling, so in certain cases (like this one), we'd accept bad dimensions. I might try and have a look tonight (UK time), if I have time - I've wanted to break up the large `propagator` monolith into smaller components for quite a while. ---. About numerical precision: if you want to try increasing the precision of the integrators, try passing `options=qutip.Options(nsteps=1_000_000, atol=1e-12, rtol=1e-10)` to `propagator`. `atol` and `rtol` are absolute and relative tolerances respectively, and `nsteps` is the number of subdivisions the integrator is _allowed_ to take (if it reaches its tolerance goals, it won't take all of them). You'll find that `atol` and `rtol` will have only a loose relation to the tolerance of your fidelity value, because there's a _lot_ of floating-point operations between those points in which the errors compound, and there's a hard limit on the tolerances the integrator can achieve, so you might not be able to get a perfect answer. The fidelity calculation involves finding the square root of a density operator, so that's another large possible source of error. About times: if you only care about the state at the last time, setting `tlist = np.linspace(0, x, 201)` is quite inefficient. Instead, set `tlist = [0, x]`, and then pass `options=qutip.Options(nsteps=<very very big integer>)`. It's more efficient because it doesn't need to achieve tolerance goals and construct/store `Qobj` instances at every intermediate timestep. Temporary workaround: this is _very_ temporary, and generally a bad idea in QuTiP, but you can ""flatten"" all your operators into a single space for now, while we implement a fix. To do that:; ```python; # initial setup; H = qutip.tensor(...); c_ops = [qutip.tensor(...)]. original",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1585#issuecomment-865903199
https://github.com/qutip/qutip/issues/1585#issuecomment-865903199:1147,Integrability,integrat,integrator,1147,"t some point we do `qeye(L.shape[0])` instead of `qeye(L.dims[0])`. There's sometimes quite a bit of that in older code - it used to slip through because we weren't super strict about dimension handling, so in certain cases (like this one), we'd accept bad dimensions. I might try and have a look tonight (UK time), if I have time - I've wanted to break up the large `propagator` monolith into smaller components for quite a while. ---. About numerical precision: if you want to try increasing the precision of the integrators, try passing `options=qutip.Options(nsteps=1_000_000, atol=1e-12, rtol=1e-10)` to `propagator`. `atol` and `rtol` are absolute and relative tolerances respectively, and `nsteps` is the number of subdivisions the integrator is _allowed_ to take (if it reaches its tolerance goals, it won't take all of them). You'll find that `atol` and `rtol` will have only a loose relation to the tolerance of your fidelity value, because there's a _lot_ of floating-point operations between those points in which the errors compound, and there's a hard limit on the tolerances the integrator can achieve, so you might not be able to get a perfect answer. The fidelity calculation involves finding the square root of a density operator, so that's another large possible source of error. About times: if you only care about the state at the last time, setting `tlist = np.linspace(0, x, 201)` is quite inefficient. Instead, set `tlist = [0, x]`, and then pass `options=qutip.Options(nsteps=<very very big integer>)`. It's more efficient because it doesn't need to achieve tolerance goals and construct/store `Qobj` instances at every intermediate timestep. Temporary workaround: this is _very_ temporary, and generally a bad idea in QuTiP, but you can ""flatten"" all your operators into a single space for now, while we implement a fix. To do that:; ```python; # initial setup; H = qutip.tensor(...); c_ops = [qutip.tensor(...)]. original_dimensions = H.dims.copy(); new_dimensions = list(H.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1585#issuecomment-865903199
https://github.com/qutip/qutip/issues/1585#issuecomment-865913240:71,Testability,test,test,71,"@nwlambert: here's a thought - do you reckon it's worth implementing a test on the rank of the Hamiltonian/Liouvillian on input to `propagator`? If it's significantly less than full-rank (which it almost invariably will be), there's probably a really good speed-up to be had by evolving the system in a rotated frame.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1585#issuecomment-865913240
https://github.com/qutip/qutip/issues/1585#issuecomment-865915323:25,Integrability,depend,dependence,25,"Ah no, never mind - time dependence would mess you up, and actually the sort of tri-diagonal systems I had in mind aren't so low-rank anyway. Maybe I'll look into it, but it won't be anywhere near as good as I had first thought.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1585#issuecomment-865915323
https://github.com/qutip/qutip/issues/1585#issuecomment-869862680:258,Testability,test,test,258,I've made a very rough attempt at a minimal fix for this issue an another bug I found in #1588. I've leaving a bigger rework of propagators for the QuTiP version 5 branch. @KosukeMizuno @nwlambert @jakelishman -- a review of #1588 and suggestions for better test cases would be appreciated.,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1585#issuecomment-869862680
https://github.com/qutip/qutip/issues/1585#issuecomment-870513900:71,Availability,error,error,71,@KosukeMizuno Thank you very much again for finding and reporting this error. We've addressed the issue in #1588. This fix will be included in the [4.6.3](https://github.com/qutip/qutip/milestone/19) release.,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1585#issuecomment-870513900
https://github.com/qutip/qutip/issues/1585#issuecomment-870513900:200,Deployability,release,release,200,@KosukeMizuno Thank you very much again for finding and reporting this error. We've addressed the issue in #1588. This fix will be included in the [4.6.3](https://github.com/qutip/qutip/milestone/19) release.,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1585#issuecomment-870513900
https://github.com/qutip/qutip/issues/1587#issuecomment-869408770:224,Availability,error,error,224,"Hi Subimal,. This happens because of the truncation of the Fock space. You can see a related discussion here ; https://groups.google.com/g/qutip/c/DD6z8kYUU1I/m/k48XZS1AAgAJ. But in short, with truncation there is always an error in the commutators, so for truncating the Fock states at N photons, I think you find that [a,a.dag()] = \sum_{n=0}^(N-1) |n><n| - N|N><N| (you can check this by writing out these operators as projectors onto fock states, you will notice a*a.dag() is missing a term due to the truncation that should cancel with a term in a.dag()*a). Similarly putting the creation and annihilation operators into the position/momentum definition of the Hamiltonian, you find H = sum_{n=0}^(N-1)(n+0.5) |n><n| + N/2 |N><N|. Hence, since you truncated at 9 photons in your example, there is a degeneracy of the 4.5 eigenvalue. I am not sure if there is much can be done about this in general, perhaps the discussion I linked above might be useful. The main message I suppose is always take a larger cut-off than you think you might need, particularly if you are relying on the commutation relations to simplify things for you (which, given your example, can be a bad idea some times!). . I guess there is an interesting question about what is the best practice in these things, e.g., if you have a non-linear model, what form is it best to put it in before moving to a truncated basis? given your example, I would expect something like normal ordering to be better.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1587#issuecomment-869408770
https://github.com/qutip/qutip/issues/1587#issuecomment-869408770:968,Integrability,message,message,968,"Hi Subimal,. This happens because of the truncation of the Fock space. You can see a related discussion here ; https://groups.google.com/g/qutip/c/DD6z8kYUU1I/m/k48XZS1AAgAJ. But in short, with truncation there is always an error in the commutators, so for truncating the Fock states at N photons, I think you find that [a,a.dag()] = \sum_{n=0}^(N-1) |n><n| - N|N><N| (you can check this by writing out these operators as projectors onto fock states, you will notice a*a.dag() is missing a term due to the truncation that should cancel with a term in a.dag()*a). Similarly putting the creation and annihilation operators into the position/momentum definition of the Hamiltonian, you find H = sum_{n=0}^(N-1)(n+0.5) |n><n| + N/2 |N><N|. Hence, since you truncated at 9 photons in your example, there is a degeneracy of the 4.5 eigenvalue. I am not sure if there is much can be done about this in general, perhaps the discussion I linked above might be useful. The main message I suppose is always take a larger cut-off than you think you might need, particularly if you are relying on the commutation relations to simplify things for you (which, given your example, can be a bad idea some times!). . I guess there is an interesting question about what is the best practice in these things, e.g., if you have a non-linear model, what form is it best to put it in before moving to a truncated basis? given your example, I would expect something like normal ordering to be better.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1587#issuecomment-869408770
https://github.com/qutip/qutip/issues/1587#issuecomment-869408770:1113,Usability,simpl,simplify,1113,"Hi Subimal,. This happens because of the truncation of the Fock space. You can see a related discussion here ; https://groups.google.com/g/qutip/c/DD6z8kYUU1I/m/k48XZS1AAgAJ. But in short, with truncation there is always an error in the commutators, so for truncating the Fock states at N photons, I think you find that [a,a.dag()] = \sum_{n=0}^(N-1) |n><n| - N|N><N| (you can check this by writing out these operators as projectors onto fock states, you will notice a*a.dag() is missing a term due to the truncation that should cancel with a term in a.dag()*a). Similarly putting the creation and annihilation operators into the position/momentum definition of the Hamiltonian, you find H = sum_{n=0}^(N-1)(n+0.5) |n><n| + N/2 |N><N|. Hence, since you truncated at 9 photons in your example, there is a degeneracy of the 4.5 eigenvalue. I am not sure if there is much can be done about this in general, perhaps the discussion I linked above might be useful. The main message I suppose is always take a larger cut-off than you think you might need, particularly if you are relying on the commutation relations to simplify things for you (which, given your example, can be a bad idea some times!). . I guess there is an interesting question about what is the best practice in these things, e.g., if you have a non-linear model, what form is it best to put it in before moving to a truncated basis? given your example, I would expect something like normal ordering to be better.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1587#issuecomment-869408770
https://github.com/qutip/qutip/issues/1587#issuecomment-869562786:117,Availability,error,error,117,"Hi Neill,. Thanks a lot for your answer. I did think the issue was with truncated Fock space but did not expect the 'error' would show up right in the middle of the eigenspectrum. I was expecting it somewhere towards the end of the spectrum. The explicit explanation is very helpful. As you pointed out, it would indeed be useful to have a list of ground rules (like normal ordering you mentioned) ; * for new users; * for those handling a problem where a closed form solution is unknown. I will check if the suggested normal ordering approach is helpful in other cases also. Hopefully it should be alright if I report my findings as a followup comment in this thread. With my best regards; Subimal Deb",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1587#issuecomment-869562786
https://github.com/qutip/qutip/pull/1588#issuecomment-870234573:29,Testability,log,logic,29,"Thanks simon!; I checked the logic of the changes and played with the tests, and looks OK to me.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1588#issuecomment-870234573
https://github.com/qutip/qutip/pull/1588#issuecomment-870234573:70,Testability,test,tests,70,"Thanks simon!; I checked the logic of the changes and played with the tests, and looks OK to me.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1588#issuecomment-870234573
https://github.com/qutip/qutip/pull/1588#issuecomment-870509718:10,Deployability,update,updated,10,Changelog updated and issue added to 4.6.3 milestone.,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1588#issuecomment-870509718
https://github.com/qutip/qutip/pull/1590#issuecomment-876733923:9,Testability,Test,Tests,9,"@Ericgig Tests passed and we both approved, so I've clicked the merge button.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1590#issuecomment-876733923
https://github.com/qutip/qutip/issues/1591#issuecomment-870937294:480,Availability,down,down,480,"Qutip `essolve` and QOtoolbox's `ode2es` both work by diagonalizing `L`. Once the eigenstates are computed, the time evolution is mostly free.; `mesolve` solve the ODE system one time increment at a time. So for any long enough `tlist`, `essolve` will be faster. Also, unless you compiled Qutip yourself with the openmp option, `mesolve` will run on one cpu, while the eigen solver run in parallel. With 16 cpus and the size of your problem, not running in parallel will slow you down. With some luck, the next major version release will be distributed compiled with openmp. . With the present release, if you compile with openmp (https://qutip.org/docs/latest/installation.html#direct-setuptools-source-builds) you should get better time, but correlation will still not be great.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1591#issuecomment-870937294
https://github.com/qutip/qutip/issues/1591#issuecomment-870937294:525,Deployability,release,release,525,"Qutip `essolve` and QOtoolbox's `ode2es` both work by diagonalizing `L`. Once the eigenstates are computed, the time evolution is mostly free.; `mesolve` solve the ODE system one time increment at a time. So for any long enough `tlist`, `essolve` will be faster. Also, unless you compiled Qutip yourself with the openmp option, `mesolve` will run on one cpu, while the eigen solver run in parallel. With 16 cpus and the size of your problem, not running in parallel will slow you down. With some luck, the next major version release will be distributed compiled with openmp. . With the present release, if you compile with openmp (https://qutip.org/docs/latest/installation.html#direct-setuptools-source-builds) you should get better time, but correlation will still not be great.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1591#issuecomment-870937294
https://github.com/qutip/qutip/issues/1591#issuecomment-870937294:594,Deployability,release,release,594,"Qutip `essolve` and QOtoolbox's `ode2es` both work by diagonalizing `L`. Once the eigenstates are computed, the time evolution is mostly free.; `mesolve` solve the ODE system one time increment at a time. So for any long enough `tlist`, `essolve` will be faster. Also, unless you compiled Qutip yourself with the openmp option, `mesolve` will run on one cpu, while the eigen solver run in parallel. With 16 cpus and the size of your problem, not running in parallel will slow you down. With some luck, the next major version release will be distributed compiled with openmp. . With the present release, if you compile with openmp (https://qutip.org/docs/latest/installation.html#direct-setuptools-source-builds) you should get better time, but correlation will still not be great.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1591#issuecomment-870937294
https://github.com/qutip/qutip/issues/1591#issuecomment-870937294:661,Deployability,install,installation,661,"Qutip `essolve` and QOtoolbox's `ode2es` both work by diagonalizing `L`. Once the eigenstates are computed, the time evolution is mostly free.; `mesolve` solve the ODE system one time increment at a time. So for any long enough `tlist`, `essolve` will be faster. Also, unless you compiled Qutip yourself with the openmp option, `mesolve` will run on one cpu, while the eigen solver run in parallel. With 16 cpus and the size of your problem, not running in parallel will slow you down. With some luck, the next major version release will be distributed compiled with openmp. . With the present release, if you compile with openmp (https://qutip.org/docs/latest/installation.html#direct-setuptools-source-builds) you should get better time, but correlation will still not be great.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1591#issuecomment-870937294
https://github.com/qutip/qutip/issues/1591#issuecomment-871031472:350,Availability,avail,available,350,"For a constant Liouvillian, it seems very reasonable that an eigenseries-based solution would be faster? In the end, that massively reduces the number of matrix-matrix operations to be done. I'm not at all familiar with Matlab, but I wouldn't be shocked if that's what your toolbox there is doing too. Looking at your code, you seem to have 16 cores available. QuTiP at present can't make too much use of multiple cores in `mesolve` or `essolve` (though it can in `correlation`), whereas Matlab may well have some fancy parallelised methods for solving eigenvector problems (if doing that method) - we rely on Scipy for our eigenvector calculations, and I'm pretty sure there's no parallelisation in there. There could also be large timing disparities if you're not being linked to good BLAS/LAPACK/ARPACK implementations in Python space. I'm sure that any distributed version of Matlab will come stuffed with lovely libraries compiled specifically for your processor's instruction set, but Scipy may only be able to find Netlib BLAS or (even worse) Accelerate - if so, they probably won't be making good use of vectorised instructions in your processor, and may not be well-optimised for memory access.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1591#issuecomment-871031472
https://github.com/qutip/qutip/issues/1591#issuecomment-871031472:132,Energy Efficiency,reduce,reduces,132,"For a constant Liouvillian, it seems very reasonable that an eigenseries-based solution would be faster? In the end, that massively reduces the number of matrix-matrix operations to be done. I'm not at all familiar with Matlab, but I wouldn't be shocked if that's what your toolbox there is doing too. Looking at your code, you seem to have 16 cores available. QuTiP at present can't make too much use of multiple cores in `mesolve` or `essolve` (though it can in `correlation`), whereas Matlab may well have some fancy parallelised methods for solving eigenvector problems (if doing that method) - we rely on Scipy for our eigenvector calculations, and I'm pretty sure there's no parallelisation in there. There could also be large timing disparities if you're not being linked to good BLAS/LAPACK/ARPACK implementations in Python space. I'm sure that any distributed version of Matlab will come stuffed with lovely libraries compiled specifically for your processor's instruction set, but Scipy may only be able to find Netlib BLAS or (even worse) Accelerate - if so, they probably won't be making good use of vectorised instructions in your processor, and may not be well-optimised for memory access.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1591#issuecomment-871031472
https://github.com/qutip/qutip/issues/1591#issuecomment-871031472:1196,Security,access,access,1196,"For a constant Liouvillian, it seems very reasonable that an eigenseries-based solution would be faster? In the end, that massively reduces the number of matrix-matrix operations to be done. I'm not at all familiar with Matlab, but I wouldn't be shocked if that's what your toolbox there is doing too. Looking at your code, you seem to have 16 cores available. QuTiP at present can't make too much use of multiple cores in `mesolve` or `essolve` (though it can in `correlation`), whereas Matlab may well have some fancy parallelised methods for solving eigenvector problems (if doing that method) - we rely on Scipy for our eigenvector calculations, and I'm pretty sure there's no parallelisation in there. There could also be large timing disparities if you're not being linked to good BLAS/LAPACK/ARPACK implementations in Python space. I'm sure that any distributed version of Matlab will come stuffed with lovely libraries compiled specifically for your processor's instruction set, but Scipy may only be able to find Netlib BLAS or (even worse) Accelerate - if so, they probably won't be making good use of vectorised instructions in your processor, and may not be well-optimised for memory access.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1591#issuecomment-871031472
https://github.com/qutip/qutip/issues/1591#issuecomment-900015271:332,Deployability,update,updates,332,"Just a small additional comment, the ODE solver is probably slow in your case because of the large disparity in parameters (particularly the very large dephasing rate), which makes it a bit stiff I guess (and hence maybe why BDF works a little better than adams in this case?). I will close this issue, but if you have any comments/updates on improving the performance of your example, feel free to comment or re-open it.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1591#issuecomment-900015271
https://github.com/qutip/qutip/issues/1591#issuecomment-900015271:357,Performance,perform,performance,357,"Just a small additional comment, the ODE solver is probably slow in your case because of the large disparity in parameters (particularly the very large dephasing rate), which makes it a bit stiff I guess (and hence maybe why BDF works a little better than adams in this case?). I will close this issue, but if you have any comments/updates on improving the performance of your example, feel free to comment or re-open it.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1591#issuecomment-900015271
https://github.com/qutip/qutip/pull/1593#issuecomment-875447468:46,Deployability,release,release,46,"@jfeist @Ericgig I've added this to the 4.6.3 release milestone. The result of `enr_destroy` was not incorrect, but I'm sure users will appreciate the drastic performance improvement. Even 4s is a long time to wait at a Jupyter notebook prompt even before one starts to call `enr_destroy` often or allow more excitations.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1593#issuecomment-875447468
https://github.com/qutip/qutip/pull/1593#issuecomment-875447468:159,Performance,perform,performance,159,"@jfeist @Ericgig I've added this to the 4.6.3 release milestone. The result of `enr_destroy` was not incorrect, but I'm sure users will appreciate the drastic performance improvement. Even 4s is a long time to wait at a Jupyter notebook prompt even before one starts to call `enr_destroy` often or allow more excitations.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1593#issuecomment-875447468
https://github.com/qutip/qutip/pull/1594#issuecomment-872033231:71,Testability,test,testing,71,"This and #1593 both look like solid improvements to me, I did a little testing and couldn't break anything. Also your approach makes the code much more readable than it was. Probably @hodgestar can comment on whether it is best to combine them into one?",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1594#issuecomment-872033231
https://github.com/qutip/qutip/issues/1595#issuecomment-875116010:42,Safety,safe,safe,42,"I'm wondering, maybe for the colour-blind-safe mode, the traditional black-or-white colour is a better choice? The colour blind cmap goes from dark to bright. If one has a large number of entries, it is inevitable that some of them will be close to the threshold and become hard to distinguish from the background, regardless of the threshold. An alternative could be using a white edge for each blob, distinguish it from the background, e.g.:; ![image](https://user-images.githubusercontent.com/12125783/124672592-967ba880-deb7-11eb-90cb-91c78690a633.png)",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1595#issuecomment-875116010
https://github.com/qutip/qutip/issues/1595#issuecomment-922114051:384,Energy Efficiency,green,green,384,"Following up, even if an option for drawing matrix elements with a border is added, the thresholded version of Hinton diagrams is much more common, especially in the ML community where it first originated. For example:. - https://matplotlib.org/stable/gallery/specialty_plots/hinton_demo.html; - https://www.mathworks.com/help/deeplearning/ref/plotwb.html (NB: not accessible for red–green color blindness, but thresholded nonetheless); - https://tex.stackexchange.com/questions/155291/generate-a-hinton-diagram-using-pgfplots; - https://mathematica.stackexchange.com/questions/194212/how-to-make-hinton-diagrams. Given those examples, I definitely agree that a border option could be really helpful, but it'd still be nice to be able to generate more traditional Hinton diagrams as well.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1595#issuecomment-922114051
https://github.com/qutip/qutip/issues/1595#issuecomment-922114051:365,Security,access,accessible,365,"Following up, even if an option for drawing matrix elements with a border is added, the thresholded version of Hinton diagrams is much more common, especially in the ML community where it first originated. For example:. - https://matplotlib.org/stable/gallery/specialty_plots/hinton_demo.html; - https://www.mathworks.com/help/deeplearning/ref/plotwb.html (NB: not accessible for red–green color blindness, but thresholded nonetheless); - https://tex.stackexchange.com/questions/155291/generate-a-hinton-diagram-using-pgfplots; - https://mathematica.stackexchange.com/questions/194212/how-to-make-hinton-diagrams. Given those examples, I definitely agree that a border option could be really helpful, but it'd still be nice to be able to generate more traditional Hinton diagrams as well.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1595#issuecomment-922114051
https://github.com/qutip/qutip/issues/1596#issuecomment-878364619:311,Energy Efficiency,reduce,reduced,311,"> Looking quickly, the sampling seems too low for the frequency.; > You measure each ~3e-8, but the frequency is ~5e9.; > You will probably get better result with `times=np.linspace(0, 0.00001, 30000)`. This actually was the issue. Turns out scanning over 1GHz range was too much, so I needed to sample more. I reduced to scanning over 1KHz and I could properly plot without increasing the number of sampled points. Thanks so much for your help",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1596#issuecomment-878364619
https://github.com/qutip/qutip/issues/1597#issuecomment-873889697:2911,Integrability,message,message,2911,"irst eigenvalues have really decreased which; > seems not logical because with the x added, the potential should be; > slightly higher. I also use in parallel the PySlise package for Python; > which enables to solve Schödinger equation and finds eigenfunctions and; > eigenvalues and it gives me :; > [ 3.01788 4.11151 5.32044 6.63324 8.02437 9.47380 10.96801 12.49776 ] (it; > was giving the good results for 1) and 2)); > So I don't understant why qutip doesn't give me the same result, I know I; > use two different methods; qutip is just finding eigenvalues of a matrix; > and PySlise solve differential equations but when I don't use displacement; > operator both always give the same result. I tried to write the; > displacement operator my self with the create & destroy operators and the; > Glauber formula because I noticed that the commutation relations were not; > respected cause of the truncation but I didn't work.; >; > If anyone has any ideas I would be very grateful, I have already spent a; > lot of time looking and I am getting desperate.; > I thank you for reading my message, I apologize for any spelling mistakes; > that may remain in my message, (I am in bachelor and English is not my; > native language); >; > *To Reproduce*; >; > import qutip as qtp; > import numpy as np; > H = qtp.displace(8,3)*qtp.num(8)*(qtp.displace(8,3).dag())+0.5*qtp.qeye(8)+qtp.position(8); > print(H.eigenenergies()); >; > The terminal out put is; >; > [-1.94563502 0.44017316 2.61960688 4.31137988 4.99244818 6.16377699; >; > 7.35499586 8.06325407]; >; >; > —; > You are receiving this because you are subscribed to this thread.; > Reply to this email directly, view it on GitHub; > <https://github.com/qutip/qutip/issues/1597>, or unsubscribe; > <https://github.com/notifications/unsubscribe-auth/ABG3YHM6CY56VDDL3JGHFNDTWDJK3ANCNFSM47ZSOL6Q>; > .; >. -- ; -----------------------------------; Senior Research Scientist; RIKEN, Japan; Research Homepage <http://dustygeeks.org/Neill/?page_id=21>",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1597#issuecomment-873889697
https://github.com/qutip/qutip/issues/1597#issuecomment-873889697:2983,Integrability,message,message,2983,"irst eigenvalues have really decreased which; > seems not logical because with the x added, the potential should be; > slightly higher. I also use in parallel the PySlise package for Python; > which enables to solve Schödinger equation and finds eigenfunctions and; > eigenvalues and it gives me :; > [ 3.01788 4.11151 5.32044 6.63324 8.02437 9.47380 10.96801 12.49776 ] (it; > was giving the good results for 1) and 2)); > So I don't understant why qutip doesn't give me the same result, I know I; > use two different methods; qutip is just finding eigenvalues of a matrix; > and PySlise solve differential equations but when I don't use displacement; > operator both always give the same result. I tried to write the; > displacement operator my self with the create & destroy operators and the; > Glauber formula because I noticed that the commutation relations were not; > respected cause of the truncation but I didn't work.; >; > If anyone has any ideas I would be very grateful, I have already spent a; > lot of time looking and I am getting desperate.; > I thank you for reading my message, I apologize for any spelling mistakes; > that may remain in my message, (I am in bachelor and English is not my; > native language); >; > *To Reproduce*; >; > import qutip as qtp; > import numpy as np; > H = qtp.displace(8,3)*qtp.num(8)*(qtp.displace(8,3).dag())+0.5*qtp.qeye(8)+qtp.position(8); > print(H.eigenenergies()); >; > The terminal out put is; >; > [-1.94563502 0.44017316 2.61960688 4.31137988 4.99244818 6.16377699; >; > 7.35499586 8.06325407]; >; >; > —; > You are receiving this because you are subscribed to this thread.; > Reply to this email directly, view it on GitHub; > <https://github.com/qutip/qutip/issues/1597>, or unsubscribe; > <https://github.com/notifications/unsubscribe-auth/ABG3YHM6CY56VDDL3JGHFNDTWDJK3ANCNFSM47ZSOL6Q>; > .; >. -- ; -----------------------------------; Senior Research Scientist; RIKEN, Japan; Research Homepage <http://dustygeeks.org/Neill/?page_id=21>",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1597#issuecomment-873889697
https://github.com/qutip/qutip/issues/1597#issuecomment-873889697:1880,Testability,log,logical,1880,"operator. I want to; > solve the dynamics of a 1D Hamiltonian which consists in two terms, the; > first one a displaced harmonic oscillator and the second one a cosine of; > the position operator.; > Before writing all the Hamiltonian I tried several examples with different; > potentials :; >; > 1. V(x) = 0.5*x**2 --> H_0 = num(dim)+0.5*qeye(dim) I found the good; > eigenvalues [0.5,1.5,2.5,....] no matter what was the dimension; > 2. V(x) = 0.5*(x-3)**2 --> H_1 = displace(dim,3)*H_0*(displace(dim,3).dag()); > I also found the same eigenvalues [0.5,1.5,2.5...] which seems normal; > because the HO is just shifted on the right of the x axis and its shape; > doesn't change.; >; > But when I tried V(x) = 0.5*(x-3)**2+x --> H_2 = H_1 + position(dim) with; > dim = 8 for example, I found the following eigenvalues :; > [-1.94563502 0.44017316 2.61960688 4.31137988 4.99244818 6.16377699; > 7.35499586 8.06325407] .; > The problem is that the first eigenvalues have really decreased which; > seems not logical because with the x added, the potential should be; > slightly higher. I also use in parallel the PySlise package for Python; > which enables to solve Schödinger equation and finds eigenfunctions and; > eigenvalues and it gives me :; > [ 3.01788 4.11151 5.32044 6.63324 8.02437 9.47380 10.96801 12.49776 ] (it; > was giving the good results for 1) and 2)); > So I don't understant why qutip doesn't give me the same result, I know I; > use two different methods; qutip is just finding eigenvalues of a matrix; > and PySlise solve differential equations but when I don't use displacement; > operator both always give the same result. I tried to write the; > displacement operator my self with the create & destroy operators and the; > Glauber formula because I noticed that the commutation relations were not; > respected cause of the truncation but I didn't work.; >; > If anyone has any ideas I would be very grateful, I have already spent a; > lot of time looking and I am getting despe",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1597#issuecomment-873889697
https://github.com/qutip/qutip/issues/1597#issuecomment-873940529:489,Availability,error,errors,489,"Hi Lambert,. Thanks you for your answer ! As you said I tried with a higher number of dimension for the case with V(x) = 0.5*x**2+x and I adjusted the sqrt(2) which was lacking and yes the eigenvalues are converging but not a the good values. For example with dim = 35 I obtain : ; [ 3. 4. 5. 6. 7. 8. 9. 10. 10.76386907 11. 12. 13. 13.99999999 14.59881066 15.00000021 15.99999984 16.99997989 17.7691296 18.00061485 ....] the first values are not far from the PySlise values but after the errors are too important.; And the most weird is that if I use the potential V(x) = 0.5*x**2-x and change the position into - position in the Hamiltonian this times qutip converges at : ; [-3.00000000e+00 -2.00000000e+00 -9.99999948e-01 1.24008598e-06; 1.00001959e+00 2.00021567e+00 3.00168756e+00 4.00939902e+00]; and PySlise gives me : [ -3.00000 -1.99999 -0.99990 0.00084 1.00478 2.01924 3.05719 4.13217 ]; So it gives me the good eigenvalues (expect for the 4th but it's negligible) and I really don't understand why it works in this case and not in the other. Thanks for the time you took for helping me.; Christian",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1597#issuecomment-873940529
https://github.com/qutip/qutip/issues/1597#issuecomment-874060820:84,Availability,error,errors,84,"I guess there's two things, firstly as you go to higher energies, again convergence errors will appear as levels near the cut-off are sensitive to the cut-off. Also, I think you can see the repeated eigenvalue around the middle of the spectrum which was recently discussed here as a consequence of truncation https://github.com/qutip/qutip/issues/1587 . Secondly, as far as I can see the +- x examples give similar convergence. This example is easily solved analytically, the energies are just that of a normal harmonic oscillator + displacement (+-3 in your case) -0.5. You can calculate this with a couple of just linear coordinate transformations in x. Perhaps there is some issue with your +x solution in pyslise?. Also, for this type of question, you are likely to get good feedback/help from the community if you post to the qutip google group https://groups.google.com/g/qutip",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1597#issuecomment-874060820
https://github.com/qutip/qutip/issues/1597#issuecomment-874060820:779,Usability,feedback,feedback,779,"I guess there's two things, firstly as you go to higher energies, again convergence errors will appear as levels near the cut-off are sensitive to the cut-off. Also, I think you can see the repeated eigenvalue around the middle of the spectrum which was recently discussed here as a consequence of truncation https://github.com/qutip/qutip/issues/1587 . Secondly, as far as I can see the +- x examples give similar convergence. This example is easily solved analytically, the energies are just that of a normal harmonic oscillator + displacement (+-3 in your case) -0.5. You can calculate this with a couple of just linear coordinate transformations in x. Perhaps there is some issue with your +x solution in pyslise?. Also, for this type of question, you are likely to get good feedback/help from the community if you post to the qutip google group https://groups.google.com/g/qutip",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1597#issuecomment-874060820
https://github.com/qutip/qutip/pull/1600#issuecomment-875431956:152,Deployability,release,release,152,@quantshah @Ericgig I added the milestone https://github.com/qutip/qutip/milestone/19 to this issue so that we remember to include this PR in the 4.6.3 release.,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1600#issuecomment-875431956
https://github.com/qutip/qutip/pull/1601#issuecomment-875287769:665,Performance,optimiz,optimized,665,"Thanks simon! On the tests we have one that checks the dynamics for the bosonic solver, and one that checks the steady state for the fermionic stuff, but not vice versa. I will try and construct something. I think for the HSolverDL backwards compatibility test, we can reuse the old test (which is essentially the same test I put in for the bosonic solver). In bofin.py itself, I think we can replace _pad_csr() with the cy_pad_csr cythonised version in qutip already (that HSolverDL was already using), its a bit faster (I didn't do it so far because of bug checking, but it should be ok to change now). There are probably lots of small places where things can be optimized a little as well.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1601#issuecomment-875287769
https://github.com/qutip/qutip/pull/1601#issuecomment-875287769:21,Testability,test,tests,21,"Thanks simon! On the tests we have one that checks the dynamics for the bosonic solver, and one that checks the steady state for the fermionic stuff, but not vice versa. I will try and construct something. I think for the HSolverDL backwards compatibility test, we can reuse the old test (which is essentially the same test I put in for the bosonic solver). In bofin.py itself, I think we can replace _pad_csr() with the cy_pad_csr cythonised version in qutip already (that HSolverDL was already using), its a bit faster (I didn't do it so far because of bug checking, but it should be ok to change now). There are probably lots of small places where things can be optimized a little as well.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1601#issuecomment-875287769
https://github.com/qutip/qutip/pull/1601#issuecomment-875287769:256,Testability,test,test,256,"Thanks simon! On the tests we have one that checks the dynamics for the bosonic solver, and one that checks the steady state for the fermionic stuff, but not vice versa. I will try and construct something. I think for the HSolverDL backwards compatibility test, we can reuse the old test (which is essentially the same test I put in for the bosonic solver). In bofin.py itself, I think we can replace _pad_csr() with the cy_pad_csr cythonised version in qutip already (that HSolverDL was already using), its a bit faster (I didn't do it so far because of bug checking, but it should be ok to change now). There are probably lots of small places where things can be optimized a little as well.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1601#issuecomment-875287769
https://github.com/qutip/qutip/pull/1601#issuecomment-875287769:283,Testability,test,test,283,"Thanks simon! On the tests we have one that checks the dynamics for the bosonic solver, and one that checks the steady state for the fermionic stuff, but not vice versa. I will try and construct something. I think for the HSolverDL backwards compatibility test, we can reuse the old test (which is essentially the same test I put in for the bosonic solver). In bofin.py itself, I think we can replace _pad_csr() with the cy_pad_csr cythonised version in qutip already (that HSolverDL was already using), its a bit faster (I didn't do it so far because of bug checking, but it should be ok to change now). There are probably lots of small places where things can be optimized a little as well.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1601#issuecomment-875287769
https://github.com/qutip/qutip/pull/1601#issuecomment-875287769:319,Testability,test,test,319,"Thanks simon! On the tests we have one that checks the dynamics for the bosonic solver, and one that checks the steady state for the fermionic stuff, but not vice versa. I will try and construct something. I think for the HSolverDL backwards compatibility test, we can reuse the old test (which is essentially the same test I put in for the bosonic solver). In bofin.py itself, I think we can replace _pad_csr() with the cy_pad_csr cythonised version in qutip already (that HSolverDL was already using), its a bit faster (I didn't do it so far because of bug checking, but it should be ok to change now). There are probably lots of small places where things can be optimized a little as well.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1601#issuecomment-875287769
https://github.com/qutip/qutip/pull/1601#issuecomment-964982005:371,Integrability,interface,interface,371,"> @hodgestar I gave it a first read. Thank you!. > I would suggest the split the `bofin.py` file and move out the `Bath` to make it less heavy. I've been thinking of splitting the file up a bit too but have been waiting until I was ready to replace heom.py. The Bath and Bath exponent classes could possibly be separated from the solver and solver support classes. > The interface for `Bath` seems quite hard to use. An expansion of the correlation function is useful for the solving, but I feel we should have more helper function for the user. There are three tiers of bath classes:. * Bath: Low-level. One gets to specify exactly the exponents one wants by hand.; * BosonicBath and FermionicBath: Mid-level. Flexible but one has to specify the expansion coefficients.; * DrudeLorentzBath and DrudeLorentzPadeBath: High-level. Support for specific bath models. I discussed having a class that would automatically fit a correlation function with Niell, and he has experiment with that but it's bit tricky to make it work well in a generic way. E.g. For the DrudeLorentz bath there is a divergence in the exponent series at t = 0 which makes it hard to fit numerically. We'd like to add more generic support in future, but the current approach provides all the functionality of the existing HSolverDL and is sufficiently flexible to implement many more higher-level Bath classes easily in the future.; ; > Are `BathExponent` needed? I don't see why there is one object for each term and not one object for the whole decomposition. BathExponent its just a holder for all of the information associated with an expansion term. Three issues with treating whole expansions as one object are:. * some exponents contribute to two expansions (e.g. the RI exponent type); * some exponents are paired (e.g. the + and - types); * having exponents within expansions makes dealing with the hierarchy a mess because one has to have lists of lists of exponents with relationships between them and ADO labels would ha",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1601#issuecomment-964982005
https://github.com/qutip/qutip/pull/1601#issuecomment-964982005:711,Modifiability,Flexible,Flexible,711,"> @hodgestar I gave it a first read. Thank you!. > I would suggest the split the `bofin.py` file and move out the `Bath` to make it less heavy. I've been thinking of splitting the file up a bit too but have been waiting until I was ready to replace heom.py. The Bath and Bath exponent classes could possibly be separated from the solver and solver support classes. > The interface for `Bath` seems quite hard to use. An expansion of the correlation function is useful for the solving, but I feel we should have more helper function for the user. There are three tiers of bath classes:. * Bath: Low-level. One gets to specify exactly the exponents one wants by hand.; * BosonicBath and FermionicBath: Mid-level. Flexible but one has to specify the expansion coefficients.; * DrudeLorentzBath and DrudeLorentzPadeBath: High-level. Support for specific bath models. I discussed having a class that would automatically fit a correlation function with Niell, and he has experiment with that but it's bit tricky to make it work well in a generic way. E.g. For the DrudeLorentz bath there is a divergence in the exponent series at t = 0 which makes it hard to fit numerically. We'd like to add more generic support in future, but the current approach provides all the functionality of the existing HSolverDL and is sufficiently flexible to implement many more higher-level Bath classes easily in the future.; ; > Are `BathExponent` needed? I don't see why there is one object for each term and not one object for the whole decomposition. BathExponent its just a holder for all of the information associated with an expansion term. Three issues with treating whole expansions as one object are:. * some exponents contribute to two expansions (e.g. the RI exponent type); * some exponents are paired (e.g. the + and - types); * having exponents within expansions makes dealing with the hierarchy a mess because one has to have lists of lists of exponents with relationships between them and ADO labels would ha",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1601#issuecomment-964982005
https://github.com/qutip/qutip/pull/1601#issuecomment-964982005:1321,Modifiability,flexible,flexible,1321," > I would suggest the split the `bofin.py` file and move out the `Bath` to make it less heavy. I've been thinking of splitting the file up a bit too but have been waiting until I was ready to replace heom.py. The Bath and Bath exponent classes could possibly be separated from the solver and solver support classes. > The interface for `Bath` seems quite hard to use. An expansion of the correlation function is useful for the solving, but I feel we should have more helper function for the user. There are three tiers of bath classes:. * Bath: Low-level. One gets to specify exactly the exponents one wants by hand.; * BosonicBath and FermionicBath: Mid-level. Flexible but one has to specify the expansion coefficients.; * DrudeLorentzBath and DrudeLorentzPadeBath: High-level. Support for specific bath models. I discussed having a class that would automatically fit a correlation function with Niell, and he has experiment with that but it's bit tricky to make it work well in a generic way. E.g. For the DrudeLorentz bath there is a divergence in the exponent series at t = 0 which makes it hard to fit numerically. We'd like to add more generic support in future, but the current approach provides all the functionality of the existing HSolverDL and is sufficiently flexible to implement many more higher-level Bath classes easily in the future.; ; > Are `BathExponent` needed? I don't see why there is one object for each term and not one object for the whole decomposition. BathExponent its just a holder for all of the information associated with an expansion term. Three issues with treating whole expansions as one object are:. * some exponents contribute to two expansions (e.g. the RI exponent type); * some exponents are paired (e.g. the + and - types); * having exponents within expansions makes dealing with the hierarchy a mess because one has to have lists of lists of exponents with relationships between them and ADO labels would have to become nested too (at least conceptually)",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1601#issuecomment-964982005
https://github.com/qutip/qutip/pull/1601#issuecomment-965101829:414,Integrability,depend,dependent,414,"> I discussed having a class that would automatically fit a correlation function with Niell, and he has experiment with that but it's bit tricky to make it work well in a generic way. E.g. For the DrudeLorentz bath there is a divergence in the exponent series at t = 0 which makes it hard to fit numerically. Yeah, for the fitting stuff, we kept it for the example notebooks, since as simon said it's very problem dependent. hence having a very generic bath interface helps for inputting these low-level cases. . For high-level interface stuff, we can also add the underdamped (brownian-motion) bath example (matsubara + pade as well). We can also add the equivalent for the fermionic case. Simon's setup makes it easy to do.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1601#issuecomment-965101829
https://github.com/qutip/qutip/pull/1601#issuecomment-965101829:458,Integrability,interface,interface,458,"> I discussed having a class that would automatically fit a correlation function with Niell, and he has experiment with that but it's bit tricky to make it work well in a generic way. E.g. For the DrudeLorentz bath there is a divergence in the exponent series at t = 0 which makes it hard to fit numerically. Yeah, for the fitting stuff, we kept it for the example notebooks, since as simon said it's very problem dependent. hence having a very generic bath interface helps for inputting these low-level cases. . For high-level interface stuff, we can also add the underdamped (brownian-motion) bath example (matsubara + pade as well). We can also add the equivalent for the fermionic case. Simon's setup makes it easy to do.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1601#issuecomment-965101829
https://github.com/qutip/qutip/pull/1601#issuecomment-965101829:528,Integrability,interface,interface,528,"> I discussed having a class that would automatically fit a correlation function with Niell, and he has experiment with that but it's bit tricky to make it work well in a generic way. E.g. For the DrudeLorentz bath there is a divergence in the exponent series at t = 0 which makes it hard to fit numerically. Yeah, for the fitting stuff, we kept it for the example notebooks, since as simon said it's very problem dependent. hence having a very generic bath interface helps for inputting these low-level cases. . For high-level interface stuff, we can also add the underdamped (brownian-motion) bath example (matsubara + pade as well). We can also add the equivalent for the fermionic case. Simon's setup makes it easy to do.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1601#issuecomment-965101829
https://github.com/qutip/qutip/pull/1601#issuecomment-965224595:158,Availability,avail,available,158,"Having a tool to fit a correlation function would be great for the user, I see that it's certainly not easy nor a priority.; I believe having high level Bath available will be important to get user to interested. The issue I see with `BathExponent` is that it contain a `Q` which seems to be usually shared for one Bath. While the exponent themselves can share an instance, `_spreQ`, `_spostQ`, `_s_pre_minus_post_Q` and `_s_pre_plus_post_Q` will be independent for each exponent. I don't know how many exponent per Bath you expect, if it's 1~2, it could be fine, but if it get large, you are computing and storing too many copies of these. > some exponents are paired (e.g. the + and - types). If they are to be paired, then why make each exponents independent? I see this as a reason to store them as a whole.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1601#issuecomment-965224595
https://github.com/qutip/qutip/pull/1601#issuecomment-965317784:500,Performance,optimiz,optimizing,500,"> The issue I see with `BathExponent` is that it contain a `Q` which seems to be usually shared for one Bath. While the exponent themselves can share an instance, `_spreQ`, `_spostQ`, `_s_pre_minus_post_Q` and `_s_pre_plus_post_Q` will be independent for each exponent. I don't know how many exponent per Bath you expect, if it's 1~2, it could be fine, but if it get large, you are computing and storing too many copies of these. Usually the number of exponents is less than 10. I have thought about optimizing the `_spreQ` lists so that they share the instances of the superoperators if the underlying Q are the same, but it seemed a complication for not a huge benefit:. The shape of the RHS is `(block * nhe, block * nhe)` where `(block, block)` is the shape of `spre(Q)` and `nhe` is the number of labels in the hierarchy. `nhe ~ k**cutoff` where `k` is the number of exponents and `cutoff` is the maximum hierarchy depth. So the overall size of the RHS is `~ k**(2*cutoff - 1)` times the size of the `_spreQ` list.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1601#issuecomment-965317784
https://github.com/qutip/qutip/pull/1601#issuecomment-975914111:0,Testability,Test,Tests,0,"Tests passed! Merging! Yay, at last!",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1601#issuecomment-975914111
https://github.com/qutip/qutip/issues/1602#issuecomment-875407374:199,Deployability,release,release,199,"Thanks for reporting this, indeed it was missing. I have made a PR to fix it. After the PR is merged, you can use the fixed version by compiling `qutip` from the source yourself or wait for the next release (in a few weeks hopefully). If you want to use the fixed sooner and without compiling `qutip` yourself. An alternative is to use the [`qutip-qip`](https://github.com/qutip/qutip-qip) package. Which is equivalent to the module `qutip.qip` you are using. Everything should work if you replace `from qutip.qip import ...` by `from qutip_qip import ...`.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1602#issuecomment-875407374
https://github.com/qutip/qutip/pull/1603#issuecomment-875428843:147,Deployability,release,release,147,@BoxiLi Just letting you know that I added this to https://github.com/qutip/qutip/milestone/19 so that we remember to include the fix in the 4.6.3 release.,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1603#issuecomment-875428843
https://github.com/qutip/qutip/pull/1603#issuecomment-875530358:13,Testability,test,test,13,An unrelated test fails after this is merged. It doesn't make sense to me...; https://github.com/qutip/qutip/runs/3008054620,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1603#issuecomment-875530358
https://github.com/qutip/qutip/pull/1603#issuecomment-875538184:15,Testability,test,test,15,> An unrelated test fails after this is merged. It doesn't make sense to me...; > https://github.com/qutip/qutip/runs/3008054620. I am very confused too. Could we try re-run it and see what happens?,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1603#issuecomment-875538184
https://github.com/qutip/qutip/issues/1605#issuecomment-879092131:10,Availability,error,error,10,"Yes, this error always comes up when doing something wrong. However, in order to understand what that is, we need to see the actual system being solved.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1605#issuecomment-879092131
https://github.com/qutip/qutip/issues/1605#issuecomment-879105295:111,Availability,error,error,111,"@andriusdc The easiest would be if you supplied a short snippet of Python code that when runs, reproduces this error.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1605#issuecomment-879105295
https://github.com/qutip/qutip/issues/1605#issuecomment-879106109:103,Usability,guid,guide,103,"@andriusdc If you are having trouble formatting the code nicely, I suggest reading the GitHub markdown guide -- https://guides.github.com/features/mastering-markdown/.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1605#issuecomment-879106109
https://github.com/qutip/qutip/issues/1605#issuecomment-879106109:120,Usability,guid,guides,120,"@andriusdc If you are having trouble formatting the code nicely, I suggest reading the GitHub markdown guide -- https://guides.github.com/features/mastering-markdown/.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1605#issuecomment-879106109
https://github.com/qutip/qutip/issues/1605#issuecomment-879127553:54,Availability,error,error,54,"I made a snipped with dummy arrays that reproduce the error. Is it enough?; ````; H=[]. timelist_Jump_op=[]; time=[]; for i in range(t):; H.append(Qobj(np.ones((2,2)))); list_Jump_op.append(Qobj(np.ones((2,2)))); time.append(0.5). estados_val=np.array([; [[ 0.4952317 +0.j , 0.35307695-0.22776115j],; [ 0.35307695+0.22776115j, 0.5047683 +0.j ]],. [[ 0.80942518+0.j , 0.14798043+0.36381018j],; [ 0.14798043-0.36381018j, 0.19057482+0.j ]],. [[ 0.74030166+0.j , -0.42252924+0.11715014j],; [-0.42252924-0.11715014j, 0.25969834+0.j ]],; [[ 0.76627252+0.j , 0.14479804+0.39765874j],; [ 0.14479804-0.39765874j, 0.23372748+0.j ]],; [[ 0.69965345+0.j , 0.4260361 -0.16920917j],; [ 0.4260361 +0.16920917j, 0.30034655+0.j ]],; [[ 0.80355468+0.j , 0.36706718-0.15204028j],; [ 0.36706718+0.15204028j, 0.19644532+0.j ]]]) . predictions=[mesolve(H,; Qobj(estados_val[i]),; time,list_Jump_op,options=Options(nsteps=1000000000)) for i in range(len(estados_val))]`. ```; `---------------------------------------------------------------------------; Exception Traceback (most recent call last); <ipython-input-26-ef5799d8412d> in <module>; 26 [ 0.36706718+0.15204028j, 0.19644532+0.j ]]]) ; 27 ; ---> 28 predictions=[mesolve(H,; 29 Qobj(estados_val[i]),; 30 time,list_Jump_op,options=Options(nsteps=1000000000)) for i in range(len(estados_val))]. <ipython-input-26-ef5799d8412d> in <listcomp>(.0); 26 [ 0.36706718+0.15204028j, 0.19644532+0.j ]]]) ; 27 ; ---> 28 predictions=[mesolve(H,; 29 Qobj(estados_val[i]),; 30 time,list_Jump_op,options=Options(nsteps=1000000000)) for i in range(len(estados_val))]. ~/anaconda3/lib/python3.8/site-packages/qutip/mesolve.py in mesolve(H, rho0, tlist, c_ops, e_ops, args, options, progress_bar, _safe_mode); 270 func(0., v, *ode_args) + v; 271 ; --> 272 res = _generic_ode_solve(func, ode_args, rho0, tlist, e_ops, options,; 273 progress_bar, dims=rho0.dims); 274 res.num_collapse = len(c_ops). ~/anaconda3/lib/python3.8/site-packages/qutip/mesolve.py in _generic_ode_solve(func, ode",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1605#issuecomment-879127553
https://github.com/qutip/qutip/issues/1605#issuecomment-879127553:2129,Availability,error,error,2129,"14798043-0.36381018j, 0.19057482+0.j ]],. [[ 0.74030166+0.j , -0.42252924+0.11715014j],; [-0.42252924-0.11715014j, 0.25969834+0.j ]],; [[ 0.76627252+0.j , 0.14479804+0.39765874j],; [ 0.14479804-0.39765874j, 0.23372748+0.j ]],; [[ 0.69965345+0.j , 0.4260361 -0.16920917j],; [ 0.4260361 +0.16920917j, 0.30034655+0.j ]],; [[ 0.80355468+0.j , 0.36706718-0.15204028j],; [ 0.36706718+0.15204028j, 0.19644532+0.j ]]]) . predictions=[mesolve(H,; Qobj(estados_val[i]),; time,list_Jump_op,options=Options(nsteps=1000000000)) for i in range(len(estados_val))]`. ```; `---------------------------------------------------------------------------; Exception Traceback (most recent call last); <ipython-input-26-ef5799d8412d> in <module>; 26 [ 0.36706718+0.15204028j, 0.19644532+0.j ]]]) ; 27 ; ---> 28 predictions=[mesolve(H,; 29 Qobj(estados_val[i]),; 30 time,list_Jump_op,options=Options(nsteps=1000000000)) for i in range(len(estados_val))]. <ipython-input-26-ef5799d8412d> in <listcomp>(.0); 26 [ 0.36706718+0.15204028j, 0.19644532+0.j ]]]) ; 27 ; ---> 28 predictions=[mesolve(H,; 29 Qobj(estados_val[i]),; 30 time,list_Jump_op,options=Options(nsteps=1000000000)) for i in range(len(estados_val))]. ~/anaconda3/lib/python3.8/site-packages/qutip/mesolve.py in mesolve(H, rho0, tlist, c_ops, e_ops, args, options, progress_bar, _safe_mode); 270 func(0., v, *ode_args) + v; 271 ; --> 272 res = _generic_ode_solve(func, ode_args, rho0, tlist, e_ops, options,; 273 progress_bar, dims=rho0.dims); 274 res.num_collapse = len(c_ops). ~/anaconda3/lib/python3.8/site-packages/qutip/mesolve.py in _generic_ode_solve(func, ode_args, rho0, tlist, e_ops, opt, progress_bar, dims); 515 ; 516 if not r.successful():; --> 517 raise Exception(""ODE integration error: Try to increase ""; 518 ""the allowed number of substeps by increasing ""; 519 ""the nsteps parameter in the Options class.""). Exception: ODE integration error: Try to increase the allowed number of substeps by increasing the nsteps parameter in the Options class.`",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1605#issuecomment-879127553
https://github.com/qutip/qutip/issues/1605#issuecomment-879127553:2286,Availability,error,error,2286,"14798043-0.36381018j, 0.19057482+0.j ]],. [[ 0.74030166+0.j , -0.42252924+0.11715014j],; [-0.42252924-0.11715014j, 0.25969834+0.j ]],; [[ 0.76627252+0.j , 0.14479804+0.39765874j],; [ 0.14479804-0.39765874j, 0.23372748+0.j ]],; [[ 0.69965345+0.j , 0.4260361 -0.16920917j],; [ 0.4260361 +0.16920917j, 0.30034655+0.j ]],; [[ 0.80355468+0.j , 0.36706718-0.15204028j],; [ 0.36706718+0.15204028j, 0.19644532+0.j ]]]) . predictions=[mesolve(H,; Qobj(estados_val[i]),; time,list_Jump_op,options=Options(nsteps=1000000000)) for i in range(len(estados_val))]`. ```; `---------------------------------------------------------------------------; Exception Traceback (most recent call last); <ipython-input-26-ef5799d8412d> in <module>; 26 [ 0.36706718+0.15204028j, 0.19644532+0.j ]]]) ; 27 ; ---> 28 predictions=[mesolve(H,; 29 Qobj(estados_val[i]),; 30 time,list_Jump_op,options=Options(nsteps=1000000000)) for i in range(len(estados_val))]. <ipython-input-26-ef5799d8412d> in <listcomp>(.0); 26 [ 0.36706718+0.15204028j, 0.19644532+0.j ]]]) ; 27 ; ---> 28 predictions=[mesolve(H,; 29 Qobj(estados_val[i]),; 30 time,list_Jump_op,options=Options(nsteps=1000000000)) for i in range(len(estados_val))]. ~/anaconda3/lib/python3.8/site-packages/qutip/mesolve.py in mesolve(H, rho0, tlist, c_ops, e_ops, args, options, progress_bar, _safe_mode); 270 func(0., v, *ode_args) + v; 271 ; --> 272 res = _generic_ode_solve(func, ode_args, rho0, tlist, e_ops, options,; 273 progress_bar, dims=rho0.dims); 274 res.num_collapse = len(c_ops). ~/anaconda3/lib/python3.8/site-packages/qutip/mesolve.py in _generic_ode_solve(func, ode_args, rho0, tlist, e_ops, opt, progress_bar, dims); 515 ; 516 if not r.successful():; --> 517 raise Exception(""ODE integration error: Try to increase ""; 518 ""the allowed number of substeps by increasing ""; 519 ""the nsteps parameter in the Options class.""). Exception: ODE integration error: Try to increase the allowed number of substeps by increasing the nsteps parameter in the Options class.`",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1605#issuecomment-879127553
https://github.com/qutip/qutip/issues/1605#issuecomment-879127553:2117,Deployability,integrat,integration,2117,"14798043-0.36381018j, 0.19057482+0.j ]],. [[ 0.74030166+0.j , -0.42252924+0.11715014j],; [-0.42252924-0.11715014j, 0.25969834+0.j ]],; [[ 0.76627252+0.j , 0.14479804+0.39765874j],; [ 0.14479804-0.39765874j, 0.23372748+0.j ]],; [[ 0.69965345+0.j , 0.4260361 -0.16920917j],; [ 0.4260361 +0.16920917j, 0.30034655+0.j ]],; [[ 0.80355468+0.j , 0.36706718-0.15204028j],; [ 0.36706718+0.15204028j, 0.19644532+0.j ]]]) . predictions=[mesolve(H,; Qobj(estados_val[i]),; time,list_Jump_op,options=Options(nsteps=1000000000)) for i in range(len(estados_val))]`. ```; `---------------------------------------------------------------------------; Exception Traceback (most recent call last); <ipython-input-26-ef5799d8412d> in <module>; 26 [ 0.36706718+0.15204028j, 0.19644532+0.j ]]]) ; 27 ; ---> 28 predictions=[mesolve(H,; 29 Qobj(estados_val[i]),; 30 time,list_Jump_op,options=Options(nsteps=1000000000)) for i in range(len(estados_val))]. <ipython-input-26-ef5799d8412d> in <listcomp>(.0); 26 [ 0.36706718+0.15204028j, 0.19644532+0.j ]]]) ; 27 ; ---> 28 predictions=[mesolve(H,; 29 Qobj(estados_val[i]),; 30 time,list_Jump_op,options=Options(nsteps=1000000000)) for i in range(len(estados_val))]. ~/anaconda3/lib/python3.8/site-packages/qutip/mesolve.py in mesolve(H, rho0, tlist, c_ops, e_ops, args, options, progress_bar, _safe_mode); 270 func(0., v, *ode_args) + v; 271 ; --> 272 res = _generic_ode_solve(func, ode_args, rho0, tlist, e_ops, options,; 273 progress_bar, dims=rho0.dims); 274 res.num_collapse = len(c_ops). ~/anaconda3/lib/python3.8/site-packages/qutip/mesolve.py in _generic_ode_solve(func, ode_args, rho0, tlist, e_ops, opt, progress_bar, dims); 515 ; 516 if not r.successful():; --> 517 raise Exception(""ODE integration error: Try to increase ""; 518 ""the allowed number of substeps by increasing ""; 519 ""the nsteps parameter in the Options class.""). Exception: ODE integration error: Try to increase the allowed number of substeps by increasing the nsteps parameter in the Options class.`",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1605#issuecomment-879127553
https://github.com/qutip/qutip/issues/1605#issuecomment-879127553:2274,Deployability,integrat,integration,2274,"14798043-0.36381018j, 0.19057482+0.j ]],. [[ 0.74030166+0.j , -0.42252924+0.11715014j],; [-0.42252924-0.11715014j, 0.25969834+0.j ]],; [[ 0.76627252+0.j , 0.14479804+0.39765874j],; [ 0.14479804-0.39765874j, 0.23372748+0.j ]],; [[ 0.69965345+0.j , 0.4260361 -0.16920917j],; [ 0.4260361 +0.16920917j, 0.30034655+0.j ]],; [[ 0.80355468+0.j , 0.36706718-0.15204028j],; [ 0.36706718+0.15204028j, 0.19644532+0.j ]]]) . predictions=[mesolve(H,; Qobj(estados_val[i]),; time,list_Jump_op,options=Options(nsteps=1000000000)) for i in range(len(estados_val))]`. ```; `---------------------------------------------------------------------------; Exception Traceback (most recent call last); <ipython-input-26-ef5799d8412d> in <module>; 26 [ 0.36706718+0.15204028j, 0.19644532+0.j ]]]) ; 27 ; ---> 28 predictions=[mesolve(H,; 29 Qobj(estados_val[i]),; 30 time,list_Jump_op,options=Options(nsteps=1000000000)) for i in range(len(estados_val))]. <ipython-input-26-ef5799d8412d> in <listcomp>(.0); 26 [ 0.36706718+0.15204028j, 0.19644532+0.j ]]]) ; 27 ; ---> 28 predictions=[mesolve(H,; 29 Qobj(estados_val[i]),; 30 time,list_Jump_op,options=Options(nsteps=1000000000)) for i in range(len(estados_val))]. ~/anaconda3/lib/python3.8/site-packages/qutip/mesolve.py in mesolve(H, rho0, tlist, c_ops, e_ops, args, options, progress_bar, _safe_mode); 270 func(0., v, *ode_args) + v; 271 ; --> 272 res = _generic_ode_solve(func, ode_args, rho0, tlist, e_ops, options,; 273 progress_bar, dims=rho0.dims); 274 res.num_collapse = len(c_ops). ~/anaconda3/lib/python3.8/site-packages/qutip/mesolve.py in _generic_ode_solve(func, ode_args, rho0, tlist, e_ops, opt, progress_bar, dims); 515 ; 516 if not r.successful():; --> 517 raise Exception(""ODE integration error: Try to increase ""; 518 ""the allowed number of substeps by increasing ""; 519 ""the nsteps parameter in the Options class.""). Exception: ODE integration error: Try to increase the allowed number of substeps by increasing the nsteps parameter in the Options class.`",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1605#issuecomment-879127553
https://github.com/qutip/qutip/issues/1605#issuecomment-879127553:2117,Integrability,integrat,integration,2117,"14798043-0.36381018j, 0.19057482+0.j ]],. [[ 0.74030166+0.j , -0.42252924+0.11715014j],; [-0.42252924-0.11715014j, 0.25969834+0.j ]],; [[ 0.76627252+0.j , 0.14479804+0.39765874j],; [ 0.14479804-0.39765874j, 0.23372748+0.j ]],; [[ 0.69965345+0.j , 0.4260361 -0.16920917j],; [ 0.4260361 +0.16920917j, 0.30034655+0.j ]],; [[ 0.80355468+0.j , 0.36706718-0.15204028j],; [ 0.36706718+0.15204028j, 0.19644532+0.j ]]]) . predictions=[mesolve(H,; Qobj(estados_val[i]),; time,list_Jump_op,options=Options(nsteps=1000000000)) for i in range(len(estados_val))]`. ```; `---------------------------------------------------------------------------; Exception Traceback (most recent call last); <ipython-input-26-ef5799d8412d> in <module>; 26 [ 0.36706718+0.15204028j, 0.19644532+0.j ]]]) ; 27 ; ---> 28 predictions=[mesolve(H,; 29 Qobj(estados_val[i]),; 30 time,list_Jump_op,options=Options(nsteps=1000000000)) for i in range(len(estados_val))]. <ipython-input-26-ef5799d8412d> in <listcomp>(.0); 26 [ 0.36706718+0.15204028j, 0.19644532+0.j ]]]) ; 27 ; ---> 28 predictions=[mesolve(H,; 29 Qobj(estados_val[i]),; 30 time,list_Jump_op,options=Options(nsteps=1000000000)) for i in range(len(estados_val))]. ~/anaconda3/lib/python3.8/site-packages/qutip/mesolve.py in mesolve(H, rho0, tlist, c_ops, e_ops, args, options, progress_bar, _safe_mode); 270 func(0., v, *ode_args) + v; 271 ; --> 272 res = _generic_ode_solve(func, ode_args, rho0, tlist, e_ops, options,; 273 progress_bar, dims=rho0.dims); 274 res.num_collapse = len(c_ops). ~/anaconda3/lib/python3.8/site-packages/qutip/mesolve.py in _generic_ode_solve(func, ode_args, rho0, tlist, e_ops, opt, progress_bar, dims); 515 ; 516 if not r.successful():; --> 517 raise Exception(""ODE integration error: Try to increase ""; 518 ""the allowed number of substeps by increasing ""; 519 ""the nsteps parameter in the Options class.""). Exception: ODE integration error: Try to increase the allowed number of substeps by increasing the nsteps parameter in the Options class.`",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1605#issuecomment-879127553
https://github.com/qutip/qutip/issues/1605#issuecomment-879127553:2274,Integrability,integrat,integration,2274,"14798043-0.36381018j, 0.19057482+0.j ]],. [[ 0.74030166+0.j , -0.42252924+0.11715014j],; [-0.42252924-0.11715014j, 0.25969834+0.j ]],; [[ 0.76627252+0.j , 0.14479804+0.39765874j],; [ 0.14479804-0.39765874j, 0.23372748+0.j ]],; [[ 0.69965345+0.j , 0.4260361 -0.16920917j],; [ 0.4260361 +0.16920917j, 0.30034655+0.j ]],; [[ 0.80355468+0.j , 0.36706718-0.15204028j],; [ 0.36706718+0.15204028j, 0.19644532+0.j ]]]) . predictions=[mesolve(H,; Qobj(estados_val[i]),; time,list_Jump_op,options=Options(nsteps=1000000000)) for i in range(len(estados_val))]`. ```; `---------------------------------------------------------------------------; Exception Traceback (most recent call last); <ipython-input-26-ef5799d8412d> in <module>; 26 [ 0.36706718+0.15204028j, 0.19644532+0.j ]]]) ; 27 ; ---> 28 predictions=[mesolve(H,; 29 Qobj(estados_val[i]),; 30 time,list_Jump_op,options=Options(nsteps=1000000000)) for i in range(len(estados_val))]. <ipython-input-26-ef5799d8412d> in <listcomp>(.0); 26 [ 0.36706718+0.15204028j, 0.19644532+0.j ]]]) ; 27 ; ---> 28 predictions=[mesolve(H,; 29 Qobj(estados_val[i]),; 30 time,list_Jump_op,options=Options(nsteps=1000000000)) for i in range(len(estados_val))]. ~/anaconda3/lib/python3.8/site-packages/qutip/mesolve.py in mesolve(H, rho0, tlist, c_ops, e_ops, args, options, progress_bar, _safe_mode); 270 func(0., v, *ode_args) + v; 271 ; --> 272 res = _generic_ode_solve(func, ode_args, rho0, tlist, e_ops, options,; 273 progress_bar, dims=rho0.dims); 274 res.num_collapse = len(c_ops). ~/anaconda3/lib/python3.8/site-packages/qutip/mesolve.py in _generic_ode_solve(func, ode_args, rho0, tlist, e_ops, opt, progress_bar, dims); 515 ; 516 if not r.successful():; --> 517 raise Exception(""ODE integration error: Try to increase ""; 518 ""the allowed number of substeps by increasing ""; 519 ""the nsteps parameter in the Options class.""). Exception: ODE integration error: Try to increase the allowed number of substeps by increasing the nsteps parameter in the Options class.`",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1605#issuecomment-879127553
https://github.com/qutip/qutip/issues/1605#issuecomment-879127553:810,Safety,predict,predictions,810,"I made a snipped with dummy arrays that reproduce the error. Is it enough?; ````; H=[]. timelist_Jump_op=[]; time=[]; for i in range(t):; H.append(Qobj(np.ones((2,2)))); list_Jump_op.append(Qobj(np.ones((2,2)))); time.append(0.5). estados_val=np.array([; [[ 0.4952317 +0.j , 0.35307695-0.22776115j],; [ 0.35307695+0.22776115j, 0.5047683 +0.j ]],. [[ 0.80942518+0.j , 0.14798043+0.36381018j],; [ 0.14798043-0.36381018j, 0.19057482+0.j ]],. [[ 0.74030166+0.j , -0.42252924+0.11715014j],; [-0.42252924-0.11715014j, 0.25969834+0.j ]],; [[ 0.76627252+0.j , 0.14479804+0.39765874j],; [ 0.14479804-0.39765874j, 0.23372748+0.j ]],; [[ 0.69965345+0.j , 0.4260361 -0.16920917j],; [ 0.4260361 +0.16920917j, 0.30034655+0.j ]],; [[ 0.80355468+0.j , 0.36706718-0.15204028j],; [ 0.36706718+0.15204028j, 0.19644532+0.j ]]]) . predictions=[mesolve(H,; Qobj(estados_val[i]),; time,list_Jump_op,options=Options(nsteps=1000000000)) for i in range(len(estados_val))]`. ```; `---------------------------------------------------------------------------; Exception Traceback (most recent call last); <ipython-input-26-ef5799d8412d> in <module>; 26 [ 0.36706718+0.15204028j, 0.19644532+0.j ]]]) ; 27 ; ---> 28 predictions=[mesolve(H,; 29 Qobj(estados_val[i]),; 30 time,list_Jump_op,options=Options(nsteps=1000000000)) for i in range(len(estados_val))]. <ipython-input-26-ef5799d8412d> in <listcomp>(.0); 26 [ 0.36706718+0.15204028j, 0.19644532+0.j ]]]) ; 27 ; ---> 28 predictions=[mesolve(H,; 29 Qobj(estados_val[i]),; 30 time,list_Jump_op,options=Options(nsteps=1000000000)) for i in range(len(estados_val))]. ~/anaconda3/lib/python3.8/site-packages/qutip/mesolve.py in mesolve(H, rho0, tlist, c_ops, e_ops, args, options, progress_bar, _safe_mode); 270 func(0., v, *ode_args) + v; 271 ; --> 272 res = _generic_ode_solve(func, ode_args, rho0, tlist, e_ops, options,; 273 progress_bar, dims=rho0.dims); 274 res.num_collapse = len(c_ops). ~/anaconda3/lib/python3.8/site-packages/qutip/mesolve.py in _generic_ode_solve(func, ode",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1605#issuecomment-879127553
https://github.com/qutip/qutip/issues/1605#issuecomment-879127553:1185,Safety,predict,predictions,1185,".array([; [[ 0.4952317 +0.j , 0.35307695-0.22776115j],; [ 0.35307695+0.22776115j, 0.5047683 +0.j ]],. [[ 0.80942518+0.j , 0.14798043+0.36381018j],; [ 0.14798043-0.36381018j, 0.19057482+0.j ]],. [[ 0.74030166+0.j , -0.42252924+0.11715014j],; [-0.42252924-0.11715014j, 0.25969834+0.j ]],; [[ 0.76627252+0.j , 0.14479804+0.39765874j],; [ 0.14479804-0.39765874j, 0.23372748+0.j ]],; [[ 0.69965345+0.j , 0.4260361 -0.16920917j],; [ 0.4260361 +0.16920917j, 0.30034655+0.j ]],; [[ 0.80355468+0.j , 0.36706718-0.15204028j],; [ 0.36706718+0.15204028j, 0.19644532+0.j ]]]) . predictions=[mesolve(H,; Qobj(estados_val[i]),; time,list_Jump_op,options=Options(nsteps=1000000000)) for i in range(len(estados_val))]`. ```; `---------------------------------------------------------------------------; Exception Traceback (most recent call last); <ipython-input-26-ef5799d8412d> in <module>; 26 [ 0.36706718+0.15204028j, 0.19644532+0.j ]]]) ; 27 ; ---> 28 predictions=[mesolve(H,; 29 Qobj(estados_val[i]),; 30 time,list_Jump_op,options=Options(nsteps=1000000000)) for i in range(len(estados_val))]. <ipython-input-26-ef5799d8412d> in <listcomp>(.0); 26 [ 0.36706718+0.15204028j, 0.19644532+0.j ]]]) ; 27 ; ---> 28 predictions=[mesolve(H,; 29 Qobj(estados_val[i]),; 30 time,list_Jump_op,options=Options(nsteps=1000000000)) for i in range(len(estados_val))]. ~/anaconda3/lib/python3.8/site-packages/qutip/mesolve.py in mesolve(H, rho0, tlist, c_ops, e_ops, args, options, progress_bar, _safe_mode); 270 func(0., v, *ode_args) + v; 271 ; --> 272 res = _generic_ode_solve(func, ode_args, rho0, tlist, e_ops, options,; 273 progress_bar, dims=rho0.dims); 274 res.num_collapse = len(c_ops). ~/anaconda3/lib/python3.8/site-packages/qutip/mesolve.py in _generic_ode_solve(func, ode_args, rho0, tlist, e_ops, opt, progress_bar, dims); 515 ; 516 if not r.successful():; --> 517 raise Exception(""ODE integration error: Try to increase ""; 518 ""the allowed number of substeps by increasing ""; 519 ""the nsteps parameter in the Opti",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1605#issuecomment-879127553
https://github.com/qutip/qutip/issues/1605#issuecomment-879127553:1443,Safety,predict,predictions,1443,"14798043-0.36381018j, 0.19057482+0.j ]],. [[ 0.74030166+0.j , -0.42252924+0.11715014j],; [-0.42252924-0.11715014j, 0.25969834+0.j ]],; [[ 0.76627252+0.j , 0.14479804+0.39765874j],; [ 0.14479804-0.39765874j, 0.23372748+0.j ]],; [[ 0.69965345+0.j , 0.4260361 -0.16920917j],; [ 0.4260361 +0.16920917j, 0.30034655+0.j ]],; [[ 0.80355468+0.j , 0.36706718-0.15204028j],; [ 0.36706718+0.15204028j, 0.19644532+0.j ]]]) . predictions=[mesolve(H,; Qobj(estados_val[i]),; time,list_Jump_op,options=Options(nsteps=1000000000)) for i in range(len(estados_val))]`. ```; `---------------------------------------------------------------------------; Exception Traceback (most recent call last); <ipython-input-26-ef5799d8412d> in <module>; 26 [ 0.36706718+0.15204028j, 0.19644532+0.j ]]]) ; 27 ; ---> 28 predictions=[mesolve(H,; 29 Qobj(estados_val[i]),; 30 time,list_Jump_op,options=Options(nsteps=1000000000)) for i in range(len(estados_val))]. <ipython-input-26-ef5799d8412d> in <listcomp>(.0); 26 [ 0.36706718+0.15204028j, 0.19644532+0.j ]]]) ; 27 ; ---> 28 predictions=[mesolve(H,; 29 Qobj(estados_val[i]),; 30 time,list_Jump_op,options=Options(nsteps=1000000000)) for i in range(len(estados_val))]. ~/anaconda3/lib/python3.8/site-packages/qutip/mesolve.py in mesolve(H, rho0, tlist, c_ops, e_ops, args, options, progress_bar, _safe_mode); 270 func(0., v, *ode_args) + v; 271 ; --> 272 res = _generic_ode_solve(func, ode_args, rho0, tlist, e_ops, options,; 273 progress_bar, dims=rho0.dims); 274 res.num_collapse = len(c_ops). ~/anaconda3/lib/python3.8/site-packages/qutip/mesolve.py in _generic_ode_solve(func, ode_args, rho0, tlist, e_ops, opt, progress_bar, dims); 515 ; 516 if not r.successful():; --> 517 raise Exception(""ODE integration error: Try to increase ""; 518 ""the allowed number of substeps by increasing ""; 519 ""the nsteps parameter in the Options class.""). Exception: ODE integration error: Try to increase the allowed number of substeps by increasing the nsteps parameter in the Options class.`",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1605#issuecomment-879127553
https://github.com/qutip/qutip/issues/1605#issuecomment-879178905:91,Availability,error,error,91,This fails because time only contain `0.5`. ; You probably meant `time.append(0.5*i)`. The error message is a catch-all for failure in scipy solver and certainly not clear.,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1605#issuecomment-879178905
https://github.com/qutip/qutip/issues/1605#issuecomment-879178905:124,Availability,failure,failure,124,This fails because time only contain `0.5`. ; You probably meant `time.append(0.5*i)`. The error message is a catch-all for failure in scipy solver and certainly not clear.,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1605#issuecomment-879178905
https://github.com/qutip/qutip/issues/1605#issuecomment-879178905:97,Integrability,message,message,97,This fails because time only contain `0.5`. ; You probably meant `time.append(0.5*i)`. The error message is a catch-all for failure in scipy solver and certainly not clear.,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1605#issuecomment-879178905
https://github.com/qutip/qutip/issues/1605#issuecomment-879178905:166,Usability,clear,clear,166,This fails because time only contain `0.5`. ; You probably meant `time.append(0.5*i)`. The error message is a catch-all for failure in scipy solver and certainly not clear.,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1605#issuecomment-879178905
https://github.com/qutip/qutip/issues/1605#issuecomment-879184807:96,Availability,error,error,96,@Ericgig Could we check whether tlist is monotonic when `_safe_mode` is true? It might make the error clearer.,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1605#issuecomment-879184807
https://github.com/qutip/qutip/issues/1605#issuecomment-879184807:102,Usability,clear,clearer,102,@Ericgig Could we check whether tlist is monotonic when `_safe_mode` is true? It might make the error clearer.,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1605#issuecomment-879184807
https://github.com/qutip/qutip/issues/1605#issuecomment-879192853:25,Availability,error,error,25,"Yes, we should catch any error before the ode solver when we can,",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1605#issuecomment-879192853
https://github.com/qutip/qutip/issues/1605#issuecomment-886246136:98,Availability,toler,tolerance,98,"Very probably. The integrator doesn't know what you're trying to achieve, and you've set it exact tolerance limits (either implicitly or explicitly), so it has to integrate within those limits. If you want the steady-state solution, you can try `qutip.steadystate` instead.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1605#issuecomment-886246136
https://github.com/qutip/qutip/issues/1605#issuecomment-886246136:19,Deployability,integrat,integrator,19,"Very probably. The integrator doesn't know what you're trying to achieve, and you've set it exact tolerance limits (either implicitly or explicitly), so it has to integrate within those limits. If you want the steady-state solution, you can try `qutip.steadystate` instead.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1605#issuecomment-886246136
https://github.com/qutip/qutip/issues/1605#issuecomment-886246136:163,Deployability,integrat,integrate,163,"Very probably. The integrator doesn't know what you're trying to achieve, and you've set it exact tolerance limits (either implicitly or explicitly), so it has to integrate within those limits. If you want the steady-state solution, you can try `qutip.steadystate` instead.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1605#issuecomment-886246136
https://github.com/qutip/qutip/issues/1605#issuecomment-886246136:19,Integrability,integrat,integrator,19,"Very probably. The integrator doesn't know what you're trying to achieve, and you've set it exact tolerance limits (either implicitly or explicitly), so it has to integrate within those limits. If you want the steady-state solution, you can try `qutip.steadystate` instead.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1605#issuecomment-886246136
https://github.com/qutip/qutip/issues/1605#issuecomment-886246136:163,Integrability,integrat,integrate,163,"Very probably. The integrator doesn't know what you're trying to achieve, and you've set it exact tolerance limits (either implicitly or explicitly), so it has to integrate within those limits. If you want the steady-state solution, you can try `qutip.steadystate` instead.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1605#issuecomment-886246136
https://github.com/qutip/qutip/issues/1606#issuecomment-879822914:257,Testability,test,test,257,@ozbenh Thanks for reporting this!. Do you perhaps know what is causing this on your M1? Is it something Apple forgot to add to the platform? Or is it that they're deprecating `hw.cpufrequency` entirely?. What was your fix?. Unfortunately we have no way to test on M1 ourselves at the moment. Any suggestions welcome. :|. Perhaps the best we can do at the moment is harden QuTiP against these breakages so that it doesn't fail to import if some of the hardware information is missing on the M1.,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1606#issuecomment-879822914
https://github.com/qutip/qutip/issues/1606#issuecomment-880308664:646,Availability,error,error,646,"It appears that they have removed hw.cpufrequency on these things (About this mac doesn't show a freq. either). I don't know what is their policy in this regard but I did find these two related issues: https://github.com/giampaolo/psutil/issues/1892 and https://github.com/shirou/gopsutil/pull/999. My workaround was to comment out the code and hard-wire a random value in there :-) A quick grep didn't seem to show any use of cpu_freq elsewhere in the code but then I didn't look too much in depth. I don't personally use qutip, my partner does, she's the physicist, I'm just the geek helping hand :). It does look like this code could use some error handling and put some ""reasonable"" default values if the sysctl's fail indeed. Happy to test a patch and report. She's currently away so there will be some latency (I can occasionally ssh into her laptop but it takes preparation), so I can't really submit a PR myself at this point.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1606#issuecomment-880308664
https://github.com/qutip/qutip/issues/1606#issuecomment-880308664:747,Deployability,patch,patch,747,"It appears that they have removed hw.cpufrequency on these things (About this mac doesn't show a freq. either). I don't know what is their policy in this regard but I did find these two related issues: https://github.com/giampaolo/psutil/issues/1892 and https://github.com/shirou/gopsutil/pull/999. My workaround was to comment out the code and hard-wire a random value in there :-) A quick grep didn't seem to show any use of cpu_freq elsewhere in the code but then I didn't look too much in depth. I don't personally use qutip, my partner does, she's the physicist, I'm just the geek helping hand :). It does look like this code could use some error handling and put some ""reasonable"" default values if the sysctl's fail indeed. Happy to test a patch and report. She's currently away so there will be some latency (I can occasionally ssh into her laptop but it takes preparation), so I can't really submit a PR myself at this point.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1606#issuecomment-880308664
https://github.com/qutip/qutip/issues/1606#issuecomment-880308664:808,Performance,latency,latency,808,"It appears that they have removed hw.cpufrequency on these things (About this mac doesn't show a freq. either). I don't know what is their policy in this regard but I did find these two related issues: https://github.com/giampaolo/psutil/issues/1892 and https://github.com/shirou/gopsutil/pull/999. My workaround was to comment out the code and hard-wire a random value in there :-) A quick grep didn't seem to show any use of cpu_freq elsewhere in the code but then I didn't look too much in depth. I don't personally use qutip, my partner does, she's the physicist, I'm just the geek helping hand :). It does look like this code could use some error handling and put some ""reasonable"" default values if the sysctl's fail indeed. Happy to test a patch and report. She's currently away so there will be some latency (I can occasionally ssh into her laptop but it takes preparation), so I can't really submit a PR myself at this point.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1606#issuecomment-880308664
https://github.com/qutip/qutip/issues/1606#issuecomment-880308664:740,Testability,test,test,740,"It appears that they have removed hw.cpufrequency on these things (About this mac doesn't show a freq. either). I don't know what is their policy in this regard but I did find these two related issues: https://github.com/giampaolo/psutil/issues/1892 and https://github.com/shirou/gopsutil/pull/999. My workaround was to comment out the code and hard-wire a random value in there :-) A quick grep didn't seem to show any use of cpu_freq elsewhere in the code but then I didn't look too much in depth. I don't personally use qutip, my partner does, she's the physicist, I'm just the geek helping hand :). It does look like this code could use some error handling and put some ""reasonable"" default values if the sysctl's fail indeed. Happy to test a patch and report. She's currently away so there will be some latency (I can occasionally ssh into her laptop but it takes preparation), so I can't really submit a PR myself at this point.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1606#issuecomment-880308664
https://github.com/qutip/qutip/issues/1606#issuecomment-885023500:21,Availability,error,error,21,"Can confirm both the error and the workaround. As a physicist, I just did this to lines 48 and 49 of `hardware_info.py`; ```; #results.update({'cpu_freq': int(float(os.popen('sysctl -n machdep.cpu.brand_string'); #.readlines()[0].split('@')[1][:-4])*1000)}); results.update({'cpu_freq': 3000}); ```; Works fine now.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1606#issuecomment-885023500
https://github.com/qutip/qutip/issues/1606#issuecomment-885023500:135,Deployability,update,update,135,"Can confirm both the error and the workaround. As a physicist, I just did this to lines 48 and 49 of `hardware_info.py`; ```; #results.update({'cpu_freq': int(float(os.popen('sysctl -n machdep.cpu.brand_string'); #.readlines()[0].split('@')[1][:-4])*1000)}); results.update({'cpu_freq': 3000}); ```; Works fine now.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1606#issuecomment-885023500
https://github.com/qutip/qutip/issues/1606#issuecomment-885023500:267,Deployability,update,update,267,"Can confirm both the error and the workaround. As a physicist, I just did this to lines 48 and 49 of `hardware_info.py`; ```; #results.update({'cpu_freq': int(float(os.popen('sysctl -n machdep.cpu.brand_string'); #.readlines()[0].split('@')[1][:-4])*1000)}); results.update({'cpu_freq': 3000}); ```; Works fine now.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1606#issuecomment-885023500
https://github.com/qutip/qutip/issues/1606#issuecomment-1006748420:202,Testability,test,test,202,"I've merged #1754 so hopefully the master branch works on the Apple M1 machines now. Please give it a try and let us know if anything else is broken. P.S. In particular, it would be good to know if the test suite passes.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1606#issuecomment-1006748420
https://github.com/qutip/qutip/issues/1607#issuecomment-880740863:971,Integrability,wrap,wrappers,971,"I'm not sure about any of these options:; 1. this absolutely should not happen. Trying to detect ""magic"" behaviour based on size is counterintuitive, and breaks other behaviour; it makes it impossible for `Qobj` to correctly handle 1x1 Hilbert spaces. While very infrequently used in practice, trying to backdoor different behaviour through something because it's already there is a nightmare to maintain, and prevents any other use. We've had large problems with 1x1 Hilbert spaces in the past, and 5.x is very strict about handling them safely now.; 2. `mul` should not be defined between two instances of `Data`, because `Data` represents a matrix, and `mul` is between a scalar and a matrix. Still, this seems closest to the correct solution to me, but instead, perhaps the `mul` dispatcher might take an arbitrary Python object as the scalar, and the inner function is responsible for returning `NotImplemented` if it can't handle it? This would require a couple of wrappers around the existing `csr` and `dense` methods, but that's not a huge deal, since the dispatchers are meant to be called from Python space anyway.; 3. same argument as the start of 2: `mul` is already defined as ""scalar \* matrix"", and there's no need for ""matched-shape elementwise multiplication"" to be a defined operation.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1607#issuecomment-880740863
https://github.com/qutip/qutip/issues/1607#issuecomment-880740863:90,Safety,detect,detect,90,"I'm not sure about any of these options:; 1. this absolutely should not happen. Trying to detect ""magic"" behaviour based on size is counterintuitive, and breaks other behaviour; it makes it impossible for `Qobj` to correctly handle 1x1 Hilbert spaces. While very infrequently used in practice, trying to backdoor different behaviour through something because it's already there is a nightmare to maintain, and prevents any other use. We've had large problems with 1x1 Hilbert spaces in the past, and 5.x is very strict about handling them safely now.; 2. `mul` should not be defined between two instances of `Data`, because `Data` represents a matrix, and `mul` is between a scalar and a matrix. Still, this seems closest to the correct solution to me, but instead, perhaps the `mul` dispatcher might take an arbitrary Python object as the scalar, and the inner function is responsible for returning `NotImplemented` if it can't handle it? This would require a couple of wrappers around the existing `csr` and `dense` methods, but that's not a huge deal, since the dispatchers are meant to be called from Python space anyway.; 3. same argument as the start of 2: `mul` is already defined as ""scalar \* matrix"", and there's no need for ""matched-shape elementwise multiplication"" to be a defined operation.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1607#issuecomment-880740863
https://github.com/qutip/qutip/issues/1607#issuecomment-880740863:539,Safety,safe,safely,539,"I'm not sure about any of these options:; 1. this absolutely should not happen. Trying to detect ""magic"" behaviour based on size is counterintuitive, and breaks other behaviour; it makes it impossible for `Qobj` to correctly handle 1x1 Hilbert spaces. While very infrequently used in practice, trying to backdoor different behaviour through something because it's already there is a nightmare to maintain, and prevents any other use. We've had large problems with 1x1 Hilbert spaces in the past, and 5.x is very strict about handling them safely now.; 2. `mul` should not be defined between two instances of `Data`, because `Data` represents a matrix, and `mul` is between a scalar and a matrix. Still, this seems closest to the correct solution to me, but instead, perhaps the `mul` dispatcher might take an arbitrary Python object as the scalar, and the inner function is responsible for returning `NotImplemented` if it can't handle it? This would require a couple of wrappers around the existing `csr` and `dense` methods, but that's not a huge deal, since the dispatchers are meant to be called from Python space anyway.; 3. same argument as the start of 2: `mul` is already defined as ""scalar \* matrix"", and there's no need for ""matched-shape elementwise multiplication"" to be a defined operation.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1607#issuecomment-880740863
https://github.com/qutip/qutip/issues/1607#issuecomment-881323790:158,Availability,error,error,158,"Could we just reach `Data` objects to be multiplied by a scalar so that the Tensorflow backend can accept multiplication by a `tf.Tensor` and either raise an error if it's a not a `1x1` tensor or perform the scalar multiplication if it is? It feels like this is a quirk of Tensorflow that scalars are represented by `1x1` matrices, so it would be nice if the tensorflow backend could handle that quirk itself.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1607#issuecomment-881323790
https://github.com/qutip/qutip/issues/1607#issuecomment-881323790:196,Performance,perform,perform,196,"Could we just reach `Data` objects to be multiplied by a scalar so that the Tensorflow backend can accept multiplication by a `tf.Tensor` and either raise an error if it's a not a `1x1` tensor or perform the scalar multiplication if it is? It feels like this is a quirk of Tensorflow that scalars are represented by `1x1` matrices, so it would be nice if the tensorflow backend could handle that quirk itself.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1607#issuecomment-881323790
https://github.com/qutip/qutip/issues/1607#issuecomment-883317473:347,Energy Efficiency,adapt,adapted,347,"Thanks for the useful feedback, both here and in PR #1611 ! From the discussion in PR #1611 it seems that the second option with the modifications proposed by Jake in this issue seems to be the most sensible approach. Hence, if there are no objections, I will open a PR (which I will probably do tomorrow) where I implement the following changes (adapted from Simon's comment in PR #1611):. - `Qobj.__mul__(self, other) ` ; - dispatch to `data.matmul` if `other` is a `Qobj`; - dispatch to `data.mul` otherwise which will return `NotImplemented` if it does not know how to handle `other`. ; - `Qobj.__rmul__(self, other) `:; - Dispatch to `data.mul` (`other` will never be a Qobj): Notice that in this way both left and right multiplication will behave in the same way. This would also ""solve"" the inconsistency PR #1611 was trying to solve but this time `data.mul` will handle it and will raise NotImplemented whenever required. . - `mul_dense` and `mul_csr`:; - Use a thin wrapper that returns `NotImplemeneted` if input is not a complex python scalar. There are a few things I would like to discuss before opening a PR:; 1) These changes will break backwards compatibility as:; ```python; matrix = np.random.random((2, 2)); qobj = qutip.Qobj(array). qobj * matrix # With the changes this also returns NotImplemented.; matrix * qobj # With the changes this also returns NotImplemented; ```; will now behave consistently (""fixes"" PR #1611). Is this acceptable? I would say yes given that we are doing a major version change. However, it may be a good idea to start raising a deprecation warning in QuTiP 4 if these changes go forward. 2) `data.add` has a similar behaviour to `data.mul` in that it accepts `scale` which is not a `Data` (there are a few more specialisations that also accept an argument that is not a `Data`). Should these specialisations behave in the same way allowing arbitrary python objects as ""scale"" and raise NotImplemented when required or should they just allow a complex py",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1607#issuecomment-883317473
https://github.com/qutip/qutip/issues/1607#issuecomment-883317473:975,Integrability,wrap,wrapper,975,"Thanks for the useful feedback, both here and in PR #1611 ! From the discussion in PR #1611 it seems that the second option with the modifications proposed by Jake in this issue seems to be the most sensible approach. Hence, if there are no objections, I will open a PR (which I will probably do tomorrow) where I implement the following changes (adapted from Simon's comment in PR #1611):. - `Qobj.__mul__(self, other) ` ; - dispatch to `data.matmul` if `other` is a `Qobj`; - dispatch to `data.mul` otherwise which will return `NotImplemented` if it does not know how to handle `other`. ; - `Qobj.__rmul__(self, other) `:; - Dispatch to `data.mul` (`other` will never be a Qobj): Notice that in this way both left and right multiplication will behave in the same way. This would also ""solve"" the inconsistency PR #1611 was trying to solve but this time `data.mul` will handle it and will raise NotImplemented whenever required. . - `mul_dense` and `mul_csr`:; - Use a thin wrapper that returns `NotImplemeneted` if input is not a complex python scalar. There are a few things I would like to discuss before opening a PR:; 1) These changes will break backwards compatibility as:; ```python; matrix = np.random.random((2, 2)); qobj = qutip.Qobj(array). qobj * matrix # With the changes this also returns NotImplemented.; matrix * qobj # With the changes this also returns NotImplemented; ```; will now behave consistently (""fixes"" PR #1611). Is this acceptable? I would say yes given that we are doing a major version change. However, it may be a good idea to start raising a deprecation warning in QuTiP 4 if these changes go forward. 2) `data.add` has a similar behaviour to `data.mul` in that it accepts `scale` which is not a `Data` (there are a few more specialisations that also accept an argument that is not a `Data`). Should these specialisations behave in the same way allowing arbitrary python objects as ""scale"" and raise NotImplemented when required or should they just allow a complex py",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1607#issuecomment-883317473
https://github.com/qutip/qutip/issues/1607#issuecomment-883317473:347,Modifiability,adapt,adapted,347,"Thanks for the useful feedback, both here and in PR #1611 ! From the discussion in PR #1611 it seems that the second option with the modifications proposed by Jake in this issue seems to be the most sensible approach. Hence, if there are no objections, I will open a PR (which I will probably do tomorrow) where I implement the following changes (adapted from Simon's comment in PR #1611):. - `Qobj.__mul__(self, other) ` ; - dispatch to `data.matmul` if `other` is a `Qobj`; - dispatch to `data.mul` otherwise which will return `NotImplemented` if it does not know how to handle `other`. ; - `Qobj.__rmul__(self, other) `:; - Dispatch to `data.mul` (`other` will never be a Qobj): Notice that in this way both left and right multiplication will behave in the same way. This would also ""solve"" the inconsistency PR #1611 was trying to solve but this time `data.mul` will handle it and will raise NotImplemented whenever required. . - `mul_dense` and `mul_csr`:; - Use a thin wrapper that returns `NotImplemeneted` if input is not a complex python scalar. There are a few things I would like to discuss before opening a PR:; 1) These changes will break backwards compatibility as:; ```python; matrix = np.random.random((2, 2)); qobj = qutip.Qobj(array). qobj * matrix # With the changes this also returns NotImplemented.; matrix * qobj # With the changes this also returns NotImplemented; ```; will now behave consistently (""fixes"" PR #1611). Is this acceptable? I would say yes given that we are doing a major version change. However, it may be a good idea to start raising a deprecation warning in QuTiP 4 if these changes go forward. 2) `data.add` has a similar behaviour to `data.mul` in that it accepts `scale` which is not a `Data` (there are a few more specialisations that also accept an argument that is not a `Data`). Should these specialisations behave in the same way allowing arbitrary python objects as ""scale"" and raise NotImplemented when required or should they just allow a complex py",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1607#issuecomment-883317473
https://github.com/qutip/qutip/issues/1607#issuecomment-883317473:2264,Modifiability,Variab,Variable,2264,"sistency PR #1611 was trying to solve but this time `data.mul` will handle it and will raise NotImplemented whenever required. . - `mul_dense` and `mul_csr`:; - Use a thin wrapper that returns `NotImplemeneted` if input is not a complex python scalar. There are a few things I would like to discuss before opening a PR:; 1) These changes will break backwards compatibility as:; ```python; matrix = np.random.random((2, 2)); qobj = qutip.Qobj(array). qobj * matrix # With the changes this also returns NotImplemented.; matrix * qobj # With the changes this also returns NotImplemented; ```; will now behave consistently (""fixes"" PR #1611). Is this acceptable? I would say yes given that we are doing a major version change. However, it may be a good idea to start raising a deprecation warning in QuTiP 4 if these changes go forward. 2) `data.add` has a similar behaviour to `data.mul` in that it accepts `scale` which is not a `Data` (there are a few more specialisations that also accept an argument that is not a `Data`). Should these specialisations behave in the same way allowing arbitrary python objects as ""scale"" and raise NotImplemented when required or should they just allow a complex python scalar? At this moment, `qutip.data.add(dense, dense, np.array(10)` and and `qutip.data.add(dense, dense, tf.constant(10))` works just fine. I guess they work due to the `__complex__` method they implement. Furthermore `qutip.data.add(TfTensor, TfTensor, tf.Variable(10))` also works _and_ can be differentiated. I wonder this is intended behaviour. Supporting this behaviour would be desirable for qutip-tensoflow as functions that create a Qobj as a function of a scalar (such as `alpha` for `displace(N, alpha)` or `z` for `squeezing(a1, a2, z)`) could work with `tf.Variable ` instead if they do not assume at any moment that `alpha` and `z` are python scalars. This could be a huge bonus point for `qutip-tensorflow` or any other library (Jax or Pytorch) that implements auto differentiation.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1607#issuecomment-883317473
https://github.com/qutip/qutip/issues/1607#issuecomment-883317473:2576,Modifiability,Variab,Variable,2576,"sistency PR #1611 was trying to solve but this time `data.mul` will handle it and will raise NotImplemented whenever required. . - `mul_dense` and `mul_csr`:; - Use a thin wrapper that returns `NotImplemeneted` if input is not a complex python scalar. There are a few things I would like to discuss before opening a PR:; 1) These changes will break backwards compatibility as:; ```python; matrix = np.random.random((2, 2)); qobj = qutip.Qobj(array). qobj * matrix # With the changes this also returns NotImplemented.; matrix * qobj # With the changes this also returns NotImplemented; ```; will now behave consistently (""fixes"" PR #1611). Is this acceptable? I would say yes given that we are doing a major version change. However, it may be a good idea to start raising a deprecation warning in QuTiP 4 if these changes go forward. 2) `data.add` has a similar behaviour to `data.mul` in that it accepts `scale` which is not a `Data` (there are a few more specialisations that also accept an argument that is not a `Data`). Should these specialisations behave in the same way allowing arbitrary python objects as ""scale"" and raise NotImplemented when required or should they just allow a complex python scalar? At this moment, `qutip.data.add(dense, dense, np.array(10)` and and `qutip.data.add(dense, dense, tf.constant(10))` works just fine. I guess they work due to the `__complex__` method they implement. Furthermore `qutip.data.add(TfTensor, TfTensor, tf.Variable(10))` also works _and_ can be differentiated. I wonder this is intended behaviour. Supporting this behaviour would be desirable for qutip-tensoflow as functions that create a Qobj as a function of a scalar (such as `alpha` for `displace(N, alpha)` or `z` for `squeezing(a1, a2, z)`) could work with `tf.Variable ` instead if they do not assume at any moment that `alpha` and `z` are python scalars. This could be a huge bonus point for `qutip-tensorflow` or any other library (Jax or Pytorch) that implements auto differentiation.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1607#issuecomment-883317473
https://github.com/qutip/qutip/issues/1607#issuecomment-883317473:22,Usability,feedback,feedback,22,"Thanks for the useful feedback, both here and in PR #1611 ! From the discussion in PR #1611 it seems that the second option with the modifications proposed by Jake in this issue seems to be the most sensible approach. Hence, if there are no objections, I will open a PR (which I will probably do tomorrow) where I implement the following changes (adapted from Simon's comment in PR #1611):. - `Qobj.__mul__(self, other) ` ; - dispatch to `data.matmul` if `other` is a `Qobj`; - dispatch to `data.mul` otherwise which will return `NotImplemented` if it does not know how to handle `other`. ; - `Qobj.__rmul__(self, other) `:; - Dispatch to `data.mul` (`other` will never be a Qobj): Notice that in this way both left and right multiplication will behave in the same way. This would also ""solve"" the inconsistency PR #1611 was trying to solve but this time `data.mul` will handle it and will raise NotImplemented whenever required. . - `mul_dense` and `mul_csr`:; - Use a thin wrapper that returns `NotImplemeneted` if input is not a complex python scalar. There are a few things I would like to discuss before opening a PR:; 1) These changes will break backwards compatibility as:; ```python; matrix = np.random.random((2, 2)); qobj = qutip.Qobj(array). qobj * matrix # With the changes this also returns NotImplemented.; matrix * qobj # With the changes this also returns NotImplemented; ```; will now behave consistently (""fixes"" PR #1611). Is this acceptable? I would say yes given that we are doing a major version change. However, it may be a good idea to start raising a deprecation warning in QuTiP 4 if these changes go forward. 2) `data.add` has a similar behaviour to `data.mul` in that it accepts `scale` which is not a `Data` (there are a few more specialisations that also accept an argument that is not a `Data`). Should these specialisations behave in the same way allowing arbitrary python objects as ""scale"" and raise NotImplemented when required or should they just allow a complex py",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1607#issuecomment-883317473
https://github.com/qutip/qutip/issues/1607#issuecomment-883321575:535,Availability,down,down,535,"This all looks very sensible to me. I'm happy with `qobj * matrix` and `matrix * qobj` both being disallowed (though I also wouldn't mind allowing Numpy to broadcast the multiplication treating `Qobj` as a scalar). The thin wrappers around `add_csr` and `add_dense` (and `add_csr_dense_dense`, etc, if they exist), only need to be done when they're passed to the dispatcher - the functions themselves should remain as they are, so they can conveniently be called with C semantics without needing to cast up to a Python object and back down again. `data.add(left, right, scale)` done at arbitrary precision with no tidying up should be identical to `data.add(left, data.mul(right, scale))` (the operation is called ""fused multiply-add""), so yeah, `add` should agree with `mul`. Good catch!",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1607#issuecomment-883321575
https://github.com/qutip/qutip/issues/1607#issuecomment-883321575:224,Integrability,wrap,wrappers,224,"This all looks very sensible to me. I'm happy with `qobj * matrix` and `matrix * qobj` both being disallowed (though I also wouldn't mind allowing Numpy to broadcast the multiplication treating `Qobj` as a scalar). The thin wrappers around `add_csr` and `add_dense` (and `add_csr_dense_dense`, etc, if they exist), only need to be done when they're passed to the dispatcher - the functions themselves should remain as they are, so they can conveniently be called with C semantics without needing to cast up to a Python object and back down again. `data.add(left, right, scale)` done at arbitrary precision with no tidying up should be identical to `data.add(left, data.mul(right, scale))` (the operation is called ""fused multiply-add""), so yeah, `add` should agree with `mul`. Good catch!",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1607#issuecomment-883321575
https://github.com/qutip/qutip/pull/1609#issuecomment-881312472:501,Availability,error,error,501,"This is a really great idea! Since we're putting this into version 5, I have a suggestion to take things a small step further and try the following:. Let's have only one function element type that accepts functions of the form `f(t, ...)` where `...` is any signature that does not include `POSITIONAL_ONLY` arguments (i.e. no `/`) or a `VAR_POSITIONAL` argument (i.e. no `*args`) and is implemented as follows:. When the function element is constructed, we use `inspect.signature(f)` to:. * raise an error if any `POSITIONAL_ONLY` or `VAR_POSITIONAL` arguments are present; * determine the list of `POSITIONAL_OR_KEYWORD` argument; * determine whether a `VAR_KEYWORDS` argument is present. When the function arguments are updated:. * if `VAR_KEYWORDS` was present, we just keep all arguments; * if not, set the arguments to just `{k: new_args[k] for k in argument_list}`. When the function element is called:. * we can just just call `f(t, **args)` as before, because `args` already contains either just the named arguments we want or all the arguments if a `VAR_KEYWORDS` argument was present in f. Thoughts?",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1609#issuecomment-881312472
https://github.com/qutip/qutip/pull/1609#issuecomment-881312472:723,Deployability,update,updated,723,"This is a really great idea! Since we're putting this into version 5, I have a suggestion to take things a small step further and try the following:. Let's have only one function element type that accepts functions of the form `f(t, ...)` where `...` is any signature that does not include `POSITIONAL_ONLY` arguments (i.e. no `/`) or a `VAR_POSITIONAL` argument (i.e. no `*args`) and is implemented as follows:. When the function element is constructed, we use `inspect.signature(f)` to:. * raise an error if any `POSITIONAL_ONLY` or `VAR_POSITIONAL` arguments are present; * determine the list of `POSITIONAL_OR_KEYWORD` argument; * determine whether a `VAR_KEYWORDS` argument is present. When the function arguments are updated:. * if `VAR_KEYWORDS` was present, we just keep all arguments; * if not, set the arguments to just `{k: new_args[k] for k in argument_list}`. When the function element is called:. * we can just just call `f(t, **args)` as before, because `args` already contains either just the named arguments we want or all the arguments if a `VAR_KEYWORDS` argument was present in f. Thoughts?",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1609#issuecomment-881312472
https://github.com/qutip/qutip/pull/1609#issuecomment-892540881:389,Deployability,upgrade,upgrade,389,"The tests fail because if one defines `f(t, args, k)` and defines `g = partial(f, k=0.5)` then the signature of g is `<Signature (t, args, *, k=5)>`. There will likely be other cases like this (e.g. many decorators will change the signature). I vote that we give up on all the complicated detection of the old syntax and simply ask users to change `f(t, args)` to `f(t, **args)` when they upgrade to QuTiP 5.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1609#issuecomment-892540881
https://github.com/qutip/qutip/pull/1609#issuecomment-892540881:289,Safety,detect,detection,289,"The tests fail because if one defines `f(t, args, k)` and defines `g = partial(f, k=0.5)` then the signature of g is `<Signature (t, args, *, k=5)>`. There will likely be other cases like this (e.g. many decorators will change the signature). I vote that we give up on all the complicated detection of the old syntax and simply ask users to change `f(t, args)` to `f(t, **args)` when they upgrade to QuTiP 5.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1609#issuecomment-892540881
https://github.com/qutip/qutip/pull/1609#issuecomment-892540881:4,Testability,test,tests,4,"The tests fail because if one defines `f(t, args, k)` and defines `g = partial(f, k=0.5)` then the signature of g is `<Signature (t, args, *, k=5)>`. There will likely be other cases like this (e.g. many decorators will change the signature). I vote that we give up on all the complicated detection of the old syntax and simply ask users to change `f(t, args)` to `f(t, **args)` when they upgrade to QuTiP 5.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1609#issuecomment-892540881
https://github.com/qutip/qutip/pull/1609#issuecomment-892540881:321,Usability,simpl,simply,321,"The tests fail because if one defines `f(t, args, k)` and defines `g = partial(f, k=0.5)` then the signature of g is `<Signature (t, args, *, k=5)>`. There will likely be other cases like this (e.g. many decorators will change the signature). I vote that we give up on all the complicated detection of the old syntax and simply ask users to change `f(t, args)` to `f(t, **args)` when they upgrade to QuTiP 5.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1609#issuecomment-892540881
https://github.com/qutip/qutip/pull/1609#issuecomment-892750814:76,Integrability,depend,depending,76,"That would be punishing long time qutip user and making it hard for package depending on qutip to support both v4 and v5. ; We should do our best to support both fully knowing that it will never be perfect. The new method require inspecting the signature anyway,",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1609#issuecomment-892750814
https://github.com/qutip/qutip/pull/1609#issuecomment-894208587:73,Usability,simpl,simplify,73,@Ericgig I decided it was easiest to try out some of my ideas for how to simplify this by coding. The result is #1633. Let me know what you think.,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1609#issuecomment-894208587
https://github.com/qutip/qutip/pull/1610#issuecomment-881301573:114,Performance,perform,performed,114,"I'm wondering whether setting `auto_tidyup` per data type is a good idea? One expects the mathematical operations performed by different data backends to give the same results but setting `auto_tidyup` to `[""CSR""]` by default will break that assumption quite badly. For example, matrices might become singular when sparse and not when dense. There is also a danger of making some benchmarks artificially fast. If we're going to compare backends, we should probably look at both backends with tidyup on or off. Is there a reason that tidyup cannot just be specialized for the new backends that need it?",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1610#issuecomment-881301573
https://github.com/qutip/qutip/pull/1610#issuecomment-881301573:380,Testability,benchmark,benchmarks,380,"I'm wondering whether setting `auto_tidyup` per data type is a good idea? One expects the mathematical operations performed by different data backends to give the same results but setting `auto_tidyup` to `[""CSR""]` by default will break that assumption quite badly. For example, matrices might become singular when sparse and not when dense. There is also a danger of making some benchmarks artificially fast. If we're going to compare backends, we should probably look at both backends with tidyup on or off. Is there a reason that tidyup cannot just be specialized for the new backends that need it?",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1610#issuecomment-881301573
https://github.com/qutip/qutip/pull/1610#issuecomment-881709826:292,Availability,error,error,292,"`auto-tidyup` exist to remove 0s stored in sparse matrices. `auto-tidyup` is quite messy, rounding all values under 1e-12 to 0 per default after each matrix operation can only cause problems. . As for the benchmark, why ask for dense operations to add an extra step to increase their outputs error to the same level as sparse operations so their benchmark do not look to good in comparisons. I think it is fair that the sparse operation's timing include the time needed to manage it's structure. . For auto-differentiation, if operations included are done with `Qobj`, it would have to differentiate tidy-up steps after each operation. But since the tidy-up operation does not have a clean derivative (`out[out < 1e-12] = 0`) it will make the auto-differentiation very inefficient. I see `auto-tidyup` more as a necessary evil to keep sparse matrix efficient. I would argue that we should not have `auto-tidyup` in `Qobj` and have sparse matrix operation clean themselves instead.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1610#issuecomment-881709826
https://github.com/qutip/qutip/pull/1610#issuecomment-881709826:849,Energy Efficiency,efficient,efficient,849,"`auto-tidyup` exist to remove 0s stored in sparse matrices. `auto-tidyup` is quite messy, rounding all values under 1e-12 to 0 per default after each matrix operation can only cause problems. . As for the benchmark, why ask for dense operations to add an extra step to increase their outputs error to the same level as sparse operations so their benchmark do not look to good in comparisons. I think it is fair that the sparse operation's timing include the time needed to manage it's structure. . For auto-differentiation, if operations included are done with `Qobj`, it would have to differentiate tidy-up steps after each operation. But since the tidy-up operation does not have a clean derivative (`out[out < 1e-12] = 0`) it will make the auto-differentiation very inefficient. I see `auto-tidyup` more as a necessary evil to keep sparse matrix efficient. I would argue that we should not have `auto-tidyup` in `Qobj` and have sparse matrix operation clean themselves instead.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1610#issuecomment-881709826
https://github.com/qutip/qutip/pull/1610#issuecomment-881709826:205,Testability,benchmark,benchmark,205,"`auto-tidyup` exist to remove 0s stored in sparse matrices. `auto-tidyup` is quite messy, rounding all values under 1e-12 to 0 per default after each matrix operation can only cause problems. . As for the benchmark, why ask for dense operations to add an extra step to increase their outputs error to the same level as sparse operations so their benchmark do not look to good in comparisons. I think it is fair that the sparse operation's timing include the time needed to manage it's structure. . For auto-differentiation, if operations included are done with `Qobj`, it would have to differentiate tidy-up steps after each operation. But since the tidy-up operation does not have a clean derivative (`out[out < 1e-12] = 0`) it will make the auto-differentiation very inefficient. I see `auto-tidyup` more as a necessary evil to keep sparse matrix efficient. I would argue that we should not have `auto-tidyup` in `Qobj` and have sparse matrix operation clean themselves instead.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1610#issuecomment-881709826
https://github.com/qutip/qutip/pull/1610#issuecomment-881709826:346,Testability,benchmark,benchmark,346,"`auto-tidyup` exist to remove 0s stored in sparse matrices. `auto-tidyup` is quite messy, rounding all values under 1e-12 to 0 per default after each matrix operation can only cause problems. . As for the benchmark, why ask for dense operations to add an extra step to increase their outputs error to the same level as sparse operations so their benchmark do not look to good in comparisons. I think it is fair that the sparse operation's timing include the time needed to manage it's structure. . For auto-differentiation, if operations included are done with `Qobj`, it would have to differentiate tidy-up steps after each operation. But since the tidy-up operation does not have a clean derivative (`out[out < 1e-12] = 0`) it will make the auto-differentiation very inefficient. I see `auto-tidyup` more as a necessary evil to keep sparse matrix efficient. I would argue that we should not have `auto-tidyup` in `Qobj` and have sparse matrix operation clean themselves instead.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1610#issuecomment-881709826
https://github.com/qutip/qutip/pull/1610#issuecomment-882012839:496,Performance,perform,performed,496,"One thing to consider is that CSR and Dense already _dno't_ return the same result for every operation. For example, for matmul:; ```python; size = 100; random = np.random.random((size, size)); a = qt.data.Dense(random); b = qt.data.to['CSR'](a); np.all((a).to_array() == (b).to_array()) # True; np.all((a+a).to_array() == (b+b).to_array()) # True; # This one is different for Dense and CSR even though the operation is the same. ; # This seems to be due to the order at which the operations are performed with Dense; # and CSR matmul and the fact that floating point addition is not associative. ; # (something I learned by reading the test_mathematics in qutip); np.all((a@a).to_array() == (b@b).to_array()) # False.; ```; Although the change in `auto_tidyup` will probably make the difference bigger, given that with tidy-up ""all"" we can not ensure the same output for every operation, I would say that it should be ok to set auto_tidyup to `[CSR]`.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1610#issuecomment-882012839
https://github.com/qutip/qutip/pull/1610#issuecomment-882012839:614,Usability,learn,learned,614,"One thing to consider is that CSR and Dense already _dno't_ return the same result for every operation. For example, for matmul:; ```python; size = 100; random = np.random.random((size, size)); a = qt.data.Dense(random); b = qt.data.to['CSR'](a); np.all((a).to_array() == (b).to_array()) # True; np.all((a+a).to_array() == (b+b).to_array()) # True; # This one is different for Dense and CSR even though the operation is the same. ; # This seems to be due to the order at which the operations are performed with Dense; # and CSR matmul and the fact that floating point addition is not associative. ; # (something I learned by reading the test_mathematics in qutip); np.all((a@a).to_array() == (b@b).to_array()) # False.; ```; Although the change in `auto_tidyup` will probably make the difference bigger, given that with tidy-up ""all"" we can not ensure the same output for every operation, I would say that it should be ok to set auto_tidyup to `[CSR]`.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1610#issuecomment-882012839
https://github.com/qutip/qutip/pull/1610#issuecomment-882040752:1071,Deployability,deploy,deployed,1071,"Yeah, auto-tidyup should be a function of CSR matrices only. It doesn't make sense for dense matrices to have it, that's just burning cycles. As Asier mentioned, you already can't rely on floating-point operations being exactly identical between different matrix types, so there's no particular problem there. The point about auto-differentiation is an excellent reason that it must be allowed to vary between types as well. To be honest, I'm not sure how many cases the auto-tidyup operation actually helps in keeping things efficient. It may well be worth us having a proper investigation, and seeing how often it actually helps. I can tweak the addition and matrix-multiplication sparse algorithms to automatically tidy up when generating their output (if they don't already...), in which case we could probably entirely remove all ""automatic"" tidyup, and just have it be a manual operation?. `isherm_csr_full` is actually explicitly meant to handle all cases, _especially_ those involving matrices that have not been tidied up. The logic is actually sound (it's been deployed in `master` for a while now), but looks like there's a typo made when I handled the merge up, and the data-layer is missing a few of its mathematical tests so it didn't get spotted. I'll fix that now.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1610#issuecomment-882040752
https://github.com/qutip/qutip/pull/1610#issuecomment-882040752:526,Energy Efficiency,efficient,efficient,526,"Yeah, auto-tidyup should be a function of CSR matrices only. It doesn't make sense for dense matrices to have it, that's just burning cycles. As Asier mentioned, you already can't rely on floating-point operations being exactly identical between different matrix types, so there's no particular problem there. The point about auto-differentiation is an excellent reason that it must be allowed to vary between types as well. To be honest, I'm not sure how many cases the auto-tidyup operation actually helps in keeping things efficient. It may well be worth us having a proper investigation, and seeing how often it actually helps. I can tweak the addition and matrix-multiplication sparse algorithms to automatically tidy up when generating their output (if they don't already...), in which case we could probably entirely remove all ""automatic"" tidyup, and just have it be a manual operation?. `isherm_csr_full` is actually explicitly meant to handle all cases, _especially_ those involving matrices that have not been tidied up. The logic is actually sound (it's been deployed in `master` for a while now), but looks like there's a typo made when I handled the merge up, and the data-layer is missing a few of its mathematical tests so it didn't get spotted. I'll fix that now.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1610#issuecomment-882040752
https://github.com/qutip/qutip/pull/1610#issuecomment-882040752:1036,Testability,log,logic,1036,"Yeah, auto-tidyup should be a function of CSR matrices only. It doesn't make sense for dense matrices to have it, that's just burning cycles. As Asier mentioned, you already can't rely on floating-point operations being exactly identical between different matrix types, so there's no particular problem there. The point about auto-differentiation is an excellent reason that it must be allowed to vary between types as well. To be honest, I'm not sure how many cases the auto-tidyup operation actually helps in keeping things efficient. It may well be worth us having a proper investigation, and seeing how often it actually helps. I can tweak the addition and matrix-multiplication sparse algorithms to automatically tidy up when generating their output (if they don't already...), in which case we could probably entirely remove all ""automatic"" tidyup, and just have it be a manual operation?. `isherm_csr_full` is actually explicitly meant to handle all cases, _especially_ those involving matrices that have not been tidied up. The logic is actually sound (it's been deployed in `master` for a while now), but looks like there's a typo made when I handled the merge up, and the data-layer is missing a few of its mathematical tests so it didn't get spotted. I'll fix that now.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1610#issuecomment-882040752
https://github.com/qutip/qutip/pull/1610#issuecomment-882040752:1230,Testability,test,tests,1230,"Yeah, auto-tidyup should be a function of CSR matrices only. It doesn't make sense for dense matrices to have it, that's just burning cycles. As Asier mentioned, you already can't rely on floating-point operations being exactly identical between different matrix types, so there's no particular problem there. The point about auto-differentiation is an excellent reason that it must be allowed to vary between types as well. To be honest, I'm not sure how many cases the auto-tidyup operation actually helps in keeping things efficient. It may well be worth us having a proper investigation, and seeing how often it actually helps. I can tweak the addition and matrix-multiplication sparse algorithms to automatically tidy up when generating their output (if they don't already...), in which case we could probably entirely remove all ""automatic"" tidyup, and just have it be a manual operation?. `isherm_csr_full` is actually explicitly meant to handle all cases, _especially_ those involving matrices that have not been tidied up. The logic is actually sound (it's been deployed in `master` for a while now), but looks like there's a typo made when I handled the merge up, and the data-layer is missing a few of its mathematical tests so it didn't get spotted. I'll fix that now.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1610#issuecomment-882040752
https://github.com/qutip/qutip/pull/1610#issuecomment-882525259:126,Availability,down,down,126,I'm +1 on having auto tidy up being a feature of the individual data layers. Could the auto tidy up setting perhaps be passed down to the data layers and then each layer can handle it in a way that seems sensible to the data layer?,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1610#issuecomment-882525259
https://github.com/qutip/qutip/pull/1610#issuecomment-882525259:69,Modifiability,layers,layers,69,I'm +1 on having auto tidy up being a feature of the individual data layers. Could the auto tidy up setting perhaps be passed down to the data layers and then each layer can handle it in a way that seems sensible to the data layer?,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1610#issuecomment-882525259
https://github.com/qutip/qutip/pull/1610#issuecomment-882525259:143,Modifiability,layers,layers,143,I'm +1 on having auto tidy up being a feature of the individual data layers. Could the auto tidy up setting perhaps be passed down to the data layers and then each layer can handle it in a way that seems sensible to the data layer?,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1610#issuecomment-882525259
https://github.com/qutip/qutip/pull/1611#issuecomment-880664515:941,Availability,down,downstream,941,"I don't think this is the right way to solve your problem, but we probably should be consistent. `Qobj` is not a container for arbitrary data, and a 1x1 `Qobj` basically should never exist. If I remember correctly, the auto-promotion to `Qobj` is to avoid breaking backwards compatibility, because 4.x doesn't use the `@` syntax at all. We almost certainly should be moving to remove that ""feature"", not add to it - it should never work with compound Hilbert spaces (we should be safe-by-default), and trying to detect special behaviour on 1x1 inputs just leads to weird edge cases and breakages all over the place. You probably want some sort of different mechanism for deciding what types a `Qobj.data` instance can accept in `mul`. At the moment, the test is `isinstance(other, numbers.Number)`, but you want to accept `tensorflow.Variable` if the backing data is TF-like. I think the right solution would be based on having some way for downstream classes to expose what types they can accept, perhaps by a well-defined try/except pattern?",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1611#issuecomment-880664515
https://github.com/qutip/qutip/pull/1611#issuecomment-880664515:834,Modifiability,Variab,Variable,834,"I don't think this is the right way to solve your problem, but we probably should be consistent. `Qobj` is not a container for arbitrary data, and a 1x1 `Qobj` basically should never exist. If I remember correctly, the auto-promotion to `Qobj` is to avoid breaking backwards compatibility, because 4.x doesn't use the `@` syntax at all. We almost certainly should be moving to remove that ""feature"", not add to it - it should never work with compound Hilbert spaces (we should be safe-by-default), and trying to detect special behaviour on 1x1 inputs just leads to weird edge cases and breakages all over the place. You probably want some sort of different mechanism for deciding what types a `Qobj.data` instance can accept in `mul`. At the moment, the test is `isinstance(other, numbers.Number)`, but you want to accept `tensorflow.Variable` if the backing data is TF-like. I think the right solution would be based on having some way for downstream classes to expose what types they can accept, perhaps by a well-defined try/except pattern?",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1611#issuecomment-880664515
https://github.com/qutip/qutip/pull/1611#issuecomment-880664515:250,Safety,avoid,avoid,250,"I don't think this is the right way to solve your problem, but we probably should be consistent. `Qobj` is not a container for arbitrary data, and a 1x1 `Qobj` basically should never exist. If I remember correctly, the auto-promotion to `Qobj` is to avoid breaking backwards compatibility, because 4.x doesn't use the `@` syntax at all. We almost certainly should be moving to remove that ""feature"", not add to it - it should never work with compound Hilbert spaces (we should be safe-by-default), and trying to detect special behaviour on 1x1 inputs just leads to weird edge cases and breakages all over the place. You probably want some sort of different mechanism for deciding what types a `Qobj.data` instance can accept in `mul`. At the moment, the test is `isinstance(other, numbers.Number)`, but you want to accept `tensorflow.Variable` if the backing data is TF-like. I think the right solution would be based on having some way for downstream classes to expose what types they can accept, perhaps by a well-defined try/except pattern?",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1611#issuecomment-880664515
https://github.com/qutip/qutip/pull/1611#issuecomment-880664515:480,Safety,safe,safe-by-default,480,"I don't think this is the right way to solve your problem, but we probably should be consistent. `Qobj` is not a container for arbitrary data, and a 1x1 `Qobj` basically should never exist. If I remember correctly, the auto-promotion to `Qobj` is to avoid breaking backwards compatibility, because 4.x doesn't use the `@` syntax at all. We almost certainly should be moving to remove that ""feature"", not add to it - it should never work with compound Hilbert spaces (we should be safe-by-default), and trying to detect special behaviour on 1x1 inputs just leads to weird edge cases and breakages all over the place. You probably want some sort of different mechanism for deciding what types a `Qobj.data` instance can accept in `mul`. At the moment, the test is `isinstance(other, numbers.Number)`, but you want to accept `tensorflow.Variable` if the backing data is TF-like. I think the right solution would be based on having some way for downstream classes to expose what types they can accept, perhaps by a well-defined try/except pattern?",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1611#issuecomment-880664515
https://github.com/qutip/qutip/pull/1611#issuecomment-880664515:512,Safety,detect,detect,512,"I don't think this is the right way to solve your problem, but we probably should be consistent. `Qobj` is not a container for arbitrary data, and a 1x1 `Qobj` basically should never exist. If I remember correctly, the auto-promotion to `Qobj` is to avoid breaking backwards compatibility, because 4.x doesn't use the `@` syntax at all. We almost certainly should be moving to remove that ""feature"", not add to it - it should never work with compound Hilbert spaces (we should be safe-by-default), and trying to detect special behaviour on 1x1 inputs just leads to weird edge cases and breakages all over the place. You probably want some sort of different mechanism for deciding what types a `Qobj.data` instance can accept in `mul`. At the moment, the test is `isinstance(other, numbers.Number)`, but you want to accept `tensorflow.Variable` if the backing data is TF-like. I think the right solution would be based on having some way for downstream classes to expose what types they can accept, perhaps by a well-defined try/except pattern?",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1611#issuecomment-880664515
https://github.com/qutip/qutip/pull/1611#issuecomment-880664515:963,Security,expose,expose,963,"I don't think this is the right way to solve your problem, but we probably should be consistent. `Qobj` is not a container for arbitrary data, and a 1x1 `Qobj` basically should never exist. If I remember correctly, the auto-promotion to `Qobj` is to avoid breaking backwards compatibility, because 4.x doesn't use the `@` syntax at all. We almost certainly should be moving to remove that ""feature"", not add to it - it should never work with compound Hilbert spaces (we should be safe-by-default), and trying to detect special behaviour on 1x1 inputs just leads to weird edge cases and breakages all over the place. You probably want some sort of different mechanism for deciding what types a `Qobj.data` instance can accept in `mul`. At the moment, the test is `isinstance(other, numbers.Number)`, but you want to accept `tensorflow.Variable` if the backing data is TF-like. I think the right solution would be based on having some way for downstream classes to expose what types they can accept, perhaps by a well-defined try/except pattern?",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1611#issuecomment-880664515
https://github.com/qutip/qutip/pull/1611#issuecomment-880664515:754,Testability,test,test,754,"I don't think this is the right way to solve your problem, but we probably should be consistent. `Qobj` is not a container for arbitrary data, and a 1x1 `Qobj` basically should never exist. If I remember correctly, the auto-promotion to `Qobj` is to avoid breaking backwards compatibility, because 4.x doesn't use the `@` syntax at all. We almost certainly should be moving to remove that ""feature"", not add to it - it should never work with compound Hilbert spaces (we should be safe-by-default), and trying to detect special behaviour on 1x1 inputs just leads to weird edge cases and breakages all over the place. You probably want some sort of different mechanism for deciding what types a `Qobj.data` instance can accept in `mul`. At the moment, the test is `isinstance(other, numbers.Number)`, but you want to accept `tensorflow.Variable` if the backing data is TF-like. I think the right solution would be based on having some way for downstream classes to expose what types they can accept, perhaps by a well-defined try/except pattern?",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1611#issuecomment-880664515
https://github.com/qutip/qutip/pull/1611#issuecomment-880821814:125,Availability,error,error,125,"I agree we need to be consistent, but I would also go with `matrix * Qobj` to be right and change `Qobj * array` to raise an error.; `Qobj * Qobj` can be understood as `Qobj @ Qobj` but everything else could use `mul`. If `mul` raise a `TypeError`, we can catch it and return `NotImplemented`. With this, we probably won't need to touch the `Dense` and `CSR` `mul` function and `Variable` will be passed to the `TfTensor` specialization.; The only issue I see is that sometime `Variable * Qobj` will work, other time it will not exist.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1611#issuecomment-880821814
https://github.com/qutip/qutip/pull/1611#issuecomment-880821814:379,Modifiability,Variab,Variable,379,"I agree we need to be consistent, but I would also go with `matrix * Qobj` to be right and change `Qobj * array` to raise an error.; `Qobj * Qobj` can be understood as `Qobj @ Qobj` but everything else could use `mul`. If `mul` raise a `TypeError`, we can catch it and return `NotImplemented`. With this, we probably won't need to touch the `Dense` and `CSR` `mul` function and `Variable` will be passed to the `TfTensor` specialization.; The only issue I see is that sometime `Variable * Qobj` will work, other time it will not exist.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1611#issuecomment-880821814
https://github.com/qutip/qutip/pull/1611#issuecomment-880821814:478,Modifiability,Variab,Variable,478,"I agree we need to be consistent, but I would also go with `matrix * Qobj` to be right and change `Qobj * array` to raise an error.; `Qobj * Qobj` can be understood as `Qobj @ Qobj` but everything else could use `mul`. If `mul` raise a `TypeError`, we can catch it and return `NotImplemented`. With this, we probably won't need to touch the `Dense` and `CSR` `mul` function and `Variable` will be passed to the `TfTensor` specialization.; The only issue I see is that sometime `Variable * Qobj` will work, other time it will not exist.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1611#issuecomment-880821814
https://github.com/qutip/qutip/pull/1611#issuecomment-880850027:103,Deployability,release,releases,103,"Having `Qobj * matrix` work at the moment is to make it easier to transition to the 5.x branch when it releases, since it's the current behaviour of 4.x. Once we've had a bit of time for people to make the transition, I think we should be completely removing this ""functionality"". To me, matrices aren't quantum objects; if you're working with a Numpy array, you should expect Numpy semantics to occur, i.e. Numpy should see `Qobj` as a scalar type, and broadcast against it like that. It's an implementation detail that the backing data is a matrix; the linear algebra theory certainly doesn't demand it. Raising-and-catching is slower than just having the `mul` functions return `NotImplemented`. The only implementations that would need a wrapper are our Cython-based ones, and they can both be wrapped in something like; ```python; class only_allow_numeric:; def __init__(self, inner):; self.inner = inner; def __call__(self, other):; if not isinstance(other, numbers.Number):; return NotImplemented; return self.inner(complex(other)); ; mul.add_specialisations([; (CSR, CSR, only_allow_numeric(mul_csr)),; (Dense, Dense, only_allow_numeric(mul_dense)),; ]); ```. I'm generally fine with `Variable * Qobj` only working sometimes; I think the general intent is that you'd configure the dispatchers to only allow TensorFlow data output, so it would always work for you.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1611#issuecomment-880850027
https://github.com/qutip/qutip/pull/1611#issuecomment-880850027:742,Integrability,wrap,wrapper,742,"Having `Qobj * matrix` work at the moment is to make it easier to transition to the 5.x branch when it releases, since it's the current behaviour of 4.x. Once we've had a bit of time for people to make the transition, I think we should be completely removing this ""functionality"". To me, matrices aren't quantum objects; if you're working with a Numpy array, you should expect Numpy semantics to occur, i.e. Numpy should see `Qobj` as a scalar type, and broadcast against it like that. It's an implementation detail that the backing data is a matrix; the linear algebra theory certainly doesn't demand it. Raising-and-catching is slower than just having the `mul` functions return `NotImplemented`. The only implementations that would need a wrapper are our Cython-based ones, and they can both be wrapped in something like; ```python; class only_allow_numeric:; def __init__(self, inner):; self.inner = inner; def __call__(self, other):; if not isinstance(other, numbers.Number):; return NotImplemented; return self.inner(complex(other)); ; mul.add_specialisations([; (CSR, CSR, only_allow_numeric(mul_csr)),; (Dense, Dense, only_allow_numeric(mul_dense)),; ]); ```. I'm generally fine with `Variable * Qobj` only working sometimes; I think the general intent is that you'd configure the dispatchers to only allow TensorFlow data output, so it would always work for you.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1611#issuecomment-880850027
https://github.com/qutip/qutip/pull/1611#issuecomment-880850027:798,Integrability,wrap,wrapped,798,"Having `Qobj * matrix` work at the moment is to make it easier to transition to the 5.x branch when it releases, since it's the current behaviour of 4.x. Once we've had a bit of time for people to make the transition, I think we should be completely removing this ""functionality"". To me, matrices aren't quantum objects; if you're working with a Numpy array, you should expect Numpy semantics to occur, i.e. Numpy should see `Qobj` as a scalar type, and broadcast against it like that. It's an implementation detail that the backing data is a matrix; the linear algebra theory certainly doesn't demand it. Raising-and-catching is slower than just having the `mul` functions return `NotImplemented`. The only implementations that would need a wrapper are our Cython-based ones, and they can both be wrapped in something like; ```python; class only_allow_numeric:; def __init__(self, inner):; self.inner = inner; def __call__(self, other):; if not isinstance(other, numbers.Number):; return NotImplemented; return self.inner(complex(other)); ; mul.add_specialisations([; (CSR, CSR, only_allow_numeric(mul_csr)),; (Dense, Dense, only_allow_numeric(mul_dense)),; ]); ```. I'm generally fine with `Variable * Qobj` only working sometimes; I think the general intent is that you'd configure the dispatchers to only allow TensorFlow data output, so it would always work for you.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1611#issuecomment-880850027
https://github.com/qutip/qutip/pull/1611#issuecomment-880850027:1193,Modifiability,Variab,Variable,1193,"Having `Qobj * matrix` work at the moment is to make it easier to transition to the 5.x branch when it releases, since it's the current behaviour of 4.x. Once we've had a bit of time for people to make the transition, I think we should be completely removing this ""functionality"". To me, matrices aren't quantum objects; if you're working with a Numpy array, you should expect Numpy semantics to occur, i.e. Numpy should see `Qobj` as a scalar type, and broadcast against it like that. It's an implementation detail that the backing data is a matrix; the linear algebra theory certainly doesn't demand it. Raising-and-catching is slower than just having the `mul` functions return `NotImplemented`. The only implementations that would need a wrapper are our Cython-based ones, and they can both be wrapped in something like; ```python; class only_allow_numeric:; def __init__(self, inner):; self.inner = inner; def __call__(self, other):; if not isinstance(other, numbers.Number):; return NotImplemented; return self.inner(complex(other)); ; mul.add_specialisations([; (CSR, CSR, only_allow_numeric(mul_csr)),; (Dense, Dense, only_allow_numeric(mul_dense)),; ]); ```. I'm generally fine with `Variable * Qobj` only working sometimes; I think the general intent is that you'd configure the dispatchers to only allow TensorFlow data output, so it would always work for you.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1611#issuecomment-880850027
https://github.com/qutip/qutip/pull/1611#issuecomment-880850027:1275,Modifiability,config,configure,1275,"Having `Qobj * matrix` work at the moment is to make it easier to transition to the 5.x branch when it releases, since it's the current behaviour of 4.x. Once we've had a bit of time for people to make the transition, I think we should be completely removing this ""functionality"". To me, matrices aren't quantum objects; if you're working with a Numpy array, you should expect Numpy semantics to occur, i.e. Numpy should see `Qobj` as a scalar type, and broadcast against it like that. It's an implementation detail that the backing data is a matrix; the linear algebra theory certainly doesn't demand it. Raising-and-catching is slower than just having the `mul` functions return `NotImplemented`. The only implementations that would need a wrapper are our Cython-based ones, and they can both be wrapped in something like; ```python; class only_allow_numeric:; def __init__(self, inner):; self.inner = inner; def __call__(self, other):; if not isinstance(other, numbers.Number):; return NotImplemented; return self.inner(complex(other)); ; mul.add_specialisations([; (CSR, CSR, only_allow_numeric(mul_csr)),; (Dense, Dense, only_allow_numeric(mul_dense)),; ]); ```. I'm generally fine with `Variable * Qobj` only working sometimes; I think the general intent is that you'd configure the dispatchers to only allow TensorFlow data output, so it would always work for you.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1611#issuecomment-880850027
https://github.com/qutip/qutip/pull/1611#issuecomment-880866304:39,Deployability,release,release,39,"I would just cut remove it with the v5 release, it will be harder to make breaking changes later and with the removal of `__array__`, we already change the way `Qobj` interact with `numpy`. But if we keep it for a while, we should give a warning when used. My spellcheck correct to ""specializations"".",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1611#issuecomment-880866304
https://github.com/qutip/qutip/pull/1611#issuecomment-882613672:535,Availability,error,error,535,"I agree with this, with some additional points:; 1. `QobjEvo` also needs to be handled by `__matmul__`, but this should be handled by returning `NotImplemented`, and letting `QobjEvo.__rmul__` dispatch it to `QobjEvo.__rmatmul__`.; 1. however we choose to do this, `__mul__` should return `NotImplemented` if the other element can't be handled correctly; it shouldn't raise an exception by itself. The ""Pythonic"" way is to try/catch an exception in handling, but this just means we need to be sure that all `__mul__` methods do proper error checking, and _do_ reject invalid input rather than just silently doing weird stuff.; 1. what do we want to do in response to being multiplied with Numpy arrays? We have to be careful, because otherwise we might do very different things depending on whether we're being multiplied from the left or right by the Numpy array, which isn't really desirable. My first instinct is to say we should make ourselves appear as a scalar type to Numpy, so it broadcasts the multiplication over the scalar values in its array. To do that, we may need to play a little with `__array__`, `__array_ufunc__` and `__array_function__`, and return `NotImplemented` from `Qobj.__mul__(array)`. I think this maybe gives the most useful behaviour? I can't imagine a situation where it would make sense for a data-layer type to accept a Numpy array in a scalar-multiplication routine, and doing things this way allows people to use the broadcasting support of Numpy for convient looping. Just for posterity, I'm really strongly against any automatic promotion to `Qobj`, with the exception of handling scalar numbers in `__add__` and `__sub__`, where mathematical convention is that they mean the relevant identity operator scaled by the scalar. Having that is also necessary to have `sum()` work with `Qobj` ergonomically. I know that's not the suggestion here, just thought I'd mention it again!",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1611#issuecomment-882613672
https://github.com/qutip/qutip/pull/1611#issuecomment-882613672:778,Integrability,depend,depending,778,"I agree with this, with some additional points:; 1. `QobjEvo` also needs to be handled by `__matmul__`, but this should be handled by returning `NotImplemented`, and letting `QobjEvo.__rmul__` dispatch it to `QobjEvo.__rmatmul__`.; 1. however we choose to do this, `__mul__` should return `NotImplemented` if the other element can't be handled correctly; it shouldn't raise an exception by itself. The ""Pythonic"" way is to try/catch an exception in handling, but this just means we need to be sure that all `__mul__` methods do proper error checking, and _do_ reject invalid input rather than just silently doing weird stuff.; 1. what do we want to do in response to being multiplied with Numpy arrays? We have to be careful, because otherwise we might do very different things depending on whether we're being multiplied from the left or right by the Numpy array, which isn't really desirable. My first instinct is to say we should make ourselves appear as a scalar type to Numpy, so it broadcasts the multiplication over the scalar values in its array. To do that, we may need to play a little with `__array__`, `__array_ufunc__` and `__array_function__`, and return `NotImplemented` from `Qobj.__mul__(array)`. I think this maybe gives the most useful behaviour? I can't imagine a situation where it would make sense for a data-layer type to accept a Numpy array in a scalar-multiplication routine, and doing things this way allows people to use the broadcasting support of Numpy for convient looping. Just for posterity, I'm really strongly against any automatic promotion to `Qobj`, with the exception of handling scalar numbers in `__add__` and `__sub__`, where mathematical convention is that they mean the relevant identity operator scaled by the scalar. Having that is also necessary to have `sum()` work with `Qobj` ergonomically. I know that's not the suggestion here, just thought I'd mention it again!",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1611#issuecomment-882613672
https://github.com/qutip/qutip/pull/1611#issuecomment-882613672:1393,Integrability,rout,routine,1393,"I agree with this, with some additional points:; 1. `QobjEvo` also needs to be handled by `__matmul__`, but this should be handled by returning `NotImplemented`, and letting `QobjEvo.__rmul__` dispatch it to `QobjEvo.__rmatmul__`.; 1. however we choose to do this, `__mul__` should return `NotImplemented` if the other element can't be handled correctly; it shouldn't raise an exception by itself. The ""Pythonic"" way is to try/catch an exception in handling, but this just means we need to be sure that all `__mul__` methods do proper error checking, and _do_ reject invalid input rather than just silently doing weird stuff.; 1. what do we want to do in response to being multiplied with Numpy arrays? We have to be careful, because otherwise we might do very different things depending on whether we're being multiplied from the left or right by the Numpy array, which isn't really desirable. My first instinct is to say we should make ourselves appear as a scalar type to Numpy, so it broadcasts the multiplication over the scalar values in its array. To do that, we may need to play a little with `__array__`, `__array_ufunc__` and `__array_function__`, and return `NotImplemented` from `Qobj.__mul__(array)`. I think this maybe gives the most useful behaviour? I can't imagine a situation where it would make sense for a data-layer type to accept a Numpy array in a scalar-multiplication routine, and doing things this way allows people to use the broadcasting support of Numpy for convient looping. Just for posterity, I'm really strongly against any automatic promotion to `Qobj`, with the exception of handling scalar numbers in `__add__` and `__sub__`, where mathematical convention is that they mean the relevant identity operator scaled by the scalar. Having that is also necessary to have `sum()` work with `Qobj` ergonomically. I know that's not the suggestion here, just thought I'd mention it again!",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1611#issuecomment-882613672
https://github.com/qutip/qutip/issues/1613#issuecomment-882522316:62,Deployability,install,install,62,"@mba5811 Which version of QuTiP are you using and how did you install it (e.g. conda, pip, etc)?",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1613#issuecomment-882522316
https://github.com/qutip/qutip/pull/1614#issuecomment-882514922:32,Testability,test,tests,32,Woot. And thanks for adding the tests!,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1614#issuecomment-882514922
https://github.com/qutip/qutip/pull/1614#issuecomment-882516763:164,Integrability,wrap,wrapper,164,"It's interesting to see how my style of writing tests changes and matures. It's being particularly influenced at the moment, because on Qiskit we use a fairly thin wrapper around raw `unittest`, rather than `pytest`, so I'm being exposed to writing in other styles as well.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1614#issuecomment-882516763
https://github.com/qutip/qutip/pull/1614#issuecomment-882516763:230,Security,expose,exposed,230,"It's interesting to see how my style of writing tests changes and matures. It's being particularly influenced at the moment, because on Qiskit we use a fairly thin wrapper around raw `unittest`, rather than `pytest`, so I'm being exposed to writing in other styles as well.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1614#issuecomment-882516763
https://github.com/qutip/qutip/pull/1614#issuecomment-882516763:48,Testability,test,tests,48,"It's interesting to see how my style of writing tests changes and matures. It's being particularly influenced at the moment, because on Qiskit we use a fairly thin wrapper around raw `unittest`, rather than `pytest`, so I'm being exposed to writing in other styles as well.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1614#issuecomment-882516763
https://github.com/qutip/qutip/pull/1615#issuecomment-883256980:87,Energy Efficiency,efficient,efficient,87,"Re tidyup dispatcher: I think this should still exist:. * It's useful for implementing efficient explicity tidyup calls on the different data layers.; * It's useful for specializations on data layer implementations if they want to do, e.g., `__matmul__(self, other): other = other.tidyup() ...` at the start of an operation (not 100% sure this is a good example -- probably other.tidyup() and conversion to sparse needs to happen in one step to happen efficiently, but I feel like there are cases like this out there).",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1615#issuecomment-883256980
https://github.com/qutip/qutip/pull/1615#issuecomment-883256980:452,Energy Efficiency,efficient,efficiently,452,"Re tidyup dispatcher: I think this should still exist:. * It's useful for implementing efficient explicity tidyup calls on the different data layers.; * It's useful for specializations on data layer implementations if they want to do, e.g., `__matmul__(self, other): other = other.tidyup() ...` at the start of an operation (not 100% sure this is a good example -- probably other.tidyup() and conversion to sparse needs to happen in one step to happen efficiently, but I feel like there are cases like this out there).",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1615#issuecomment-883256980
https://github.com/qutip/qutip/pull/1615#issuecomment-883256980:142,Modifiability,layers,layers,142,"Re tidyup dispatcher: I think this should still exist:. * It's useful for implementing efficient explicity tidyup calls on the different data layers.; * It's useful for specializations on data layer implementations if they want to do, e.g., `__matmul__(self, other): other = other.tidyup() ...` at the start of an operation (not 100% sure this is a good example -- probably other.tidyup() and conversion to sparse needs to happen in one step to happen efficiently, but I feel like there are cases like this out there).",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1615#issuecomment-883256980
https://github.com/qutip/qutip/pull/1615#issuecomment-893436254:56,Deployability,update,update,56,@Ericgig Just checking the status of this PR. Should we update it to the latest dev.major and then I can review it again?,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1615#issuecomment-893436254
https://github.com/qutip/qutip/pull/1615#issuecomment-894223373:71,Testability,log,logic,71,"I have some slight reservations about the copying around of the tidyup logic in the CSR methods, but it's not in too many places so far, so I'm happy with the duplication for now. If we get more copies, I would recommend we define an inline method that does the `if real < tol: ... if imag < tol: ...` dance for us.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1615#issuecomment-894223373
https://github.com/qutip/qutip/issues/1616#issuecomment-883192074:964,Availability,robust,robust,964,"Hi Chester,. I'm not that familiar with matplotlib on Windows, but I'm guessing that; something has gone wrong with the event loop being used to render the; matplotlib figures (possibly QuTiP did something wrong or maybe something; else happened). Could you confirm that you're using the TkAgg matplotlib backend? You can; check with matplot.get_backend(). And are you using IPython or the ordinary; Python console?. Usually only:. b = qutip.Bloch(); b.show(). is required to display the plot. Behind the scenes .show() and; .make_sphere() both call .render(...). I suspect that the empty axes you; are seeing might be related to having rendered the sphere a few different; times. Could you start a new Python console and try:. import qutip; import matplotlib.pyplot as plt; b = qutip.Bloch(); b.render(); plt.show(). I'm hoping that will give you just the plot you are looking for (and so; give you a work around for now). The reason this might be slightly more; robust is that internally b.show() renders the sphere onto the existing; axes, which could possibly be related to the issue you are seeing. After; closing the plot window, running b.render() and plt.show() should display; the sphere again. If that fails, could you confirm that you can show any plots with; matplotlib?. You could also try updating to a more recent matplotlib, but let's perhaps; leave that as a last resort. Yours sincerely,; Simon Cross",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1616#issuecomment-883192074
https://github.com/qutip/qutip/issues/1616#issuecomment-883428764:115,Deployability,update,update,115,"So I decided to reinstall Python (Anaconda specifically) to get a fresh slate as in my own debugging and trying to update packages other code started to behave weirdly. Here is my current qutip.about():; QuTiP Version: 4.6.2; Numpy Version: 1.20.1; Scipy Version: 1.6.2; Cython Version: 0.29.23; Matplotlib Version: 3.3.4; Python Version: 3.8.8; Number of CPUs: 4; BLAS Info: INTEL MKL; OPENMP Installed: False; INTEL MKL Ext: False; Platform Info: Windows (AMD64); Installation path: C:\ProgramData\Anaconda3\lib\site-packages\qutip. I am using the Qt5Agg matplotlib backend, and changing to the TkAgg backend gives the same behaviour. However, running the code you pasted in a separate (command line) console I am able to view the sphere with even the b.show() command.; I still have this behaviour in my editor however (Visual Studio Code) so I think the problem is something to so with my debug environment, this code even behaves as it should in the powershell window in VS code. ; I know this isnt the VS code issue page but if you have any suggestions I'd much appreciate it",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1616#issuecomment-883428764
https://github.com/qutip/qutip/issues/1616#issuecomment-883428764:394,Deployability,Install,Installed,394,"So I decided to reinstall Python (Anaconda specifically) to get a fresh slate as in my own debugging and trying to update packages other code started to behave weirdly. Here is my current qutip.about():; QuTiP Version: 4.6.2; Numpy Version: 1.20.1; Scipy Version: 1.6.2; Cython Version: 0.29.23; Matplotlib Version: 3.3.4; Python Version: 3.8.8; Number of CPUs: 4; BLAS Info: INTEL MKL; OPENMP Installed: False; INTEL MKL Ext: False; Platform Info: Windows (AMD64); Installation path: C:\ProgramData\Anaconda3\lib\site-packages\qutip. I am using the Qt5Agg matplotlib backend, and changing to the TkAgg backend gives the same behaviour. However, running the code you pasted in a separate (command line) console I am able to view the sphere with even the b.show() command.; I still have this behaviour in my editor however (Visual Studio Code) so I think the problem is something to so with my debug environment, this code even behaves as it should in the powershell window in VS code. ; I know this isnt the VS code issue page but if you have any suggestions I'd much appreciate it",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1616#issuecomment-883428764
https://github.com/qutip/qutip/issues/1616#issuecomment-883428764:466,Deployability,Install,Installation,466,"So I decided to reinstall Python (Anaconda specifically) to get a fresh slate as in my own debugging and trying to update packages other code started to behave weirdly. Here is my current qutip.about():; QuTiP Version: 4.6.2; Numpy Version: 1.20.1; Scipy Version: 1.6.2; Cython Version: 0.29.23; Matplotlib Version: 3.3.4; Python Version: 3.8.8; Number of CPUs: 4; BLAS Info: INTEL MKL; OPENMP Installed: False; INTEL MKL Ext: False; Platform Info: Windows (AMD64); Installation path: C:\ProgramData\Anaconda3\lib\site-packages\qutip. I am using the Qt5Agg matplotlib backend, and changing to the TkAgg backend gives the same behaviour. However, running the code you pasted in a separate (command line) console I am able to view the sphere with even the b.show() command.; I still have this behaviour in my editor however (Visual Studio Code) so I think the problem is something to so with my debug environment, this code even behaves as it should in the powershell window in VS code. ; I know this isnt the VS code issue page but if you have any suggestions I'd much appreciate it",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1616#issuecomment-883428764
https://github.com/qutip/qutip/issues/1616#issuecomment-883428764:955,Energy Efficiency,power,powershell,955,"So I decided to reinstall Python (Anaconda specifically) to get a fresh slate as in my own debugging and trying to update packages other code started to behave weirdly. Here is my current qutip.about():; QuTiP Version: 4.6.2; Numpy Version: 1.20.1; Scipy Version: 1.6.2; Cython Version: 0.29.23; Matplotlib Version: 3.3.4; Python Version: 3.8.8; Number of CPUs: 4; BLAS Info: INTEL MKL; OPENMP Installed: False; INTEL MKL Ext: False; Platform Info: Windows (AMD64); Installation path: C:\ProgramData\Anaconda3\lib\site-packages\qutip. I am using the Qt5Agg matplotlib backend, and changing to the TkAgg backend gives the same behaviour. However, running the code you pasted in a separate (command line) console I am able to view the sphere with even the b.show() command.; I still have this behaviour in my editor however (Visual Studio Code) so I think the problem is something to so with my debug environment, this code even behaves as it should in the powershell window in VS code. ; I know this isnt the VS code issue page but if you have any suggestions I'd much appreciate it",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1616#issuecomment-883428764
https://github.com/qutip/qutip/issues/1616#issuecomment-883458011:81,Deployability,configurat,configurations,81,"Directly in VS code. My launch.json looks like; ```json; 	""version"": ""0.2.0"",; 	""configurations"": [; 		{; 			""name"": ""Python: Current File"",; 			""type"": ""python"",; 			""request"": ""launch"",; 			""program"": ""${file}"",; 			""console"": ""integratedTerminal""; 		}; 	]; }; ```; When using the plt.show() command, the second window only appears after a b.render() command, but thats also necessary for any vectors I want to draw to appear.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1616#issuecomment-883458011
https://github.com/qutip/qutip/issues/1616#issuecomment-883458011:230,Deployability,integrat,integratedTerminal,230,"Directly in VS code. My launch.json looks like; ```json; 	""version"": ""0.2.0"",; 	""configurations"": [; 		{; 			""name"": ""Python: Current File"",; 			""type"": ""python"",; 			""request"": ""launch"",; 			""program"": ""${file}"",; 			""console"": ""integratedTerminal""; 		}; 	]; }; ```; When using the plt.show() command, the second window only appears after a b.render() command, but thats also necessary for any vectors I want to draw to appear.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1616#issuecomment-883458011
https://github.com/qutip/qutip/issues/1616#issuecomment-883458011:230,Integrability,integrat,integratedTerminal,230,"Directly in VS code. My launch.json looks like; ```json; 	""version"": ""0.2.0"",; 	""configurations"": [; 		{; 			""name"": ""Python: Current File"",; 			""type"": ""python"",; 			""request"": ""launch"",; 			""program"": ""${file}"",; 			""console"": ""integratedTerminal""; 		}; 	]; }; ```; When using the plt.show() command, the second window only appears after a b.render() command, but thats also necessary for any vectors I want to draw to appear.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1616#issuecomment-883458011
https://github.com/qutip/qutip/issues/1616#issuecomment-883458011:81,Modifiability,config,configurations,81,"Directly in VS code. My launch.json looks like; ```json; 	""version"": ""0.2.0"",; 	""configurations"": [; 		{; 			""name"": ""Python: Current File"",; 			""type"": ""python"",; 			""request"": ""launch"",; 			""program"": ""${file}"",; 			""console"": ""integratedTerminal""; 		}; 	]; }; ```; When using the plt.show() command, the second window only appears after a b.render() command, but thats also necessary for any vectors I want to draw to appear.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1616#issuecomment-883458011
https://github.com/qutip/qutip/issues/1616#issuecomment-883527200:19,Usability,simpl,simple,19,"To try keep things simple for me, I only have the base environment which VS code activates before any code is run.; The text I have in that box is `Python 3.8.8 64-bit (conda)`. I realise I'm missing the `('base':conda)` as per https://code.visualstudio.com/docs/python/python-tutorial however I havent yet found why this is the case. I am continuing to look as I feel this might be the crux of the problem. As another work around I found that (after updating matplotlib to my current version) I can get some of the expected behaviour from b.show() within VS code by adding the `plt.pause(interval)` command after b.show() (as descibed previously however now I can actually render someting), where the interval is how many seconds I want to view the Bloch sphere for. The b.save() function also works as expected so I can use that as a workaround for now at least. Some more odd behaviour - likely caused by all the updating an reinstalling trying to fix things - is that the plt.show() no longer works as described before. Not a massive loss as I've gained other functionality and I am still able to render other graphs (so matplotlib isnt broken) and the bare 3d axes have stopped appearing.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1616#issuecomment-883527200
https://github.com/qutip/qutip/issues/1616#issuecomment-883527200:583,Usability,pause,pause,583,"To try keep things simple for me, I only have the base environment which VS code activates before any code is run.; The text I have in that box is `Python 3.8.8 64-bit (conda)`. I realise I'm missing the `('base':conda)` as per https://code.visualstudio.com/docs/python/python-tutorial however I havent yet found why this is the case. I am continuing to look as I feel this might be the crux of the problem. As another work around I found that (after updating matplotlib to my current version) I can get some of the expected behaviour from b.show() within VS code by adding the `plt.pause(interval)` command after b.show() (as descibed previously however now I can actually render someting), where the interval is how many seconds I want to view the Bloch sphere for. The b.save() function also works as expected so I can use that as a workaround for now at least. Some more odd behaviour - likely caused by all the updating an reinstalling trying to fix things - is that the plt.show() no longer works as described before. Not a massive loss as I've gained other functionality and I am still able to render other graphs (so matplotlib isnt broken) and the bare 3d axes have stopped appearing.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1616#issuecomment-883527200
https://github.com/qutip/qutip/issues/1616#issuecomment-883541243:82,Energy Efficiency,power,powershell,82,"Not sure if this is a conda issue now as I can run the test script in the windows powershell terminal with `python .\qutiptest.py` where qutiptest.py is; ```python; import qutip; b=qutip.Bloch(); b.show(); ```; and I get the same behaviour as when I run throught the VS code debugger, where the matplotlib window flashes briefly. I can also recreate the rest of the VS code behaviour like this.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1616#issuecomment-883541243
https://github.com/qutip/qutip/issues/1616#issuecomment-883541243:55,Testability,test,test,55,"Not sure if this is a conda issue now as I can run the test script in the windows powershell terminal with `python .\qutiptest.py` where qutiptest.py is; ```python; import qutip; b=qutip.Bloch(); b.show(); ```; and I get the same behaviour as when I run throught the VS code debugger, where the matplotlib window flashes briefly. I can also recreate the rest of the VS code behaviour like this.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1616#issuecomment-883541243
https://github.com/qutip/qutip/issues/1616#issuecomment-883619754:1691,Availability,error,error,1691,"So after starting with a fresh install of Anaconda and going through the steps described in https://qutip.org/docs/4.1/installation.html to install through conda-forge and conda, I am still seeing the same behaviour. However I have found a workaround that gives me exactly what I want. During my debugging I ending up adding the `b.make_sphere()` command, this seems to have caused the extra set of axes to keep appearing. I found that by omitting the `make_sphere` command and just replacing `b.show()` with `plt.show()` worked perfectly.; Heres my MWE; ```python; import qutip; import matplotlib.pyplot as plt; b=qutip.Bloch(). b.add_vectors([1,0,0]); b.render(). plt.show(); ```. My `qutip.about()` output is:; ```; QuTiP Version: 4.6.2; Numpy Version: 1.20.3; Scipy Version: 1.6.2; Cython Version: 0.29.24; Matplotlib Version: 3.3.4; Python Version: 3.9.5; Number of CPUs: 4; BLAS Info: INTEL MKL; OPENMP Installed: False; INTEL MKL Ext: False; Platform Info: Windows (AMD64); Installation path: C:\Users\Chester\.conda\envs\qutip-env\lib\site-packages\qutip; ```. Hopefully this helps someone. @jakelishman I tried interactive mode toggling when this problem first occurred as that's what the behaviour reminded me of too. Gave it another go with my example in this text (replacing the `plt.show()` with `b.show()`) but still same behaviour.; I think it's to do with something similar to the problem/solution in https://stackoverflow.com/questions/12369693/how-to-make-the-plot-not-disappear/12905317 as `self.fig` within the Bloch class is initialised in `render()` (and then called in `show()`) a similar way. But I am not familiar enough with the qutip backend to know if this is an error, especially as this does not seem like a common issue.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1616#issuecomment-883619754
https://github.com/qutip/qutip/issues/1616#issuecomment-883619754:31,Deployability,install,install,31,"So after starting with a fresh install of Anaconda and going through the steps described in https://qutip.org/docs/4.1/installation.html to install through conda-forge and conda, I am still seeing the same behaviour. However I have found a workaround that gives me exactly what I want. During my debugging I ending up adding the `b.make_sphere()` command, this seems to have caused the extra set of axes to keep appearing. I found that by omitting the `make_sphere` command and just replacing `b.show()` with `plt.show()` worked perfectly.; Heres my MWE; ```python; import qutip; import matplotlib.pyplot as plt; b=qutip.Bloch(). b.add_vectors([1,0,0]); b.render(). plt.show(); ```. My `qutip.about()` output is:; ```; QuTiP Version: 4.6.2; Numpy Version: 1.20.3; Scipy Version: 1.6.2; Cython Version: 0.29.24; Matplotlib Version: 3.3.4; Python Version: 3.9.5; Number of CPUs: 4; BLAS Info: INTEL MKL; OPENMP Installed: False; INTEL MKL Ext: False; Platform Info: Windows (AMD64); Installation path: C:\Users\Chester\.conda\envs\qutip-env\lib\site-packages\qutip; ```. Hopefully this helps someone. @jakelishman I tried interactive mode toggling when this problem first occurred as that's what the behaviour reminded me of too. Gave it another go with my example in this text (replacing the `plt.show()` with `b.show()`) but still same behaviour.; I think it's to do with something similar to the problem/solution in https://stackoverflow.com/questions/12369693/how-to-make-the-plot-not-disappear/12905317 as `self.fig` within the Bloch class is initialised in `render()` (and then called in `show()`) a similar way. But I am not familiar enough with the qutip backend to know if this is an error, especially as this does not seem like a common issue.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1616#issuecomment-883619754
https://github.com/qutip/qutip/issues/1616#issuecomment-883619754:119,Deployability,install,installation,119,"So after starting with a fresh install of Anaconda and going through the steps described in https://qutip.org/docs/4.1/installation.html to install through conda-forge and conda, I am still seeing the same behaviour. However I have found a workaround that gives me exactly what I want. During my debugging I ending up adding the `b.make_sphere()` command, this seems to have caused the extra set of axes to keep appearing. I found that by omitting the `make_sphere` command and just replacing `b.show()` with `plt.show()` worked perfectly.; Heres my MWE; ```python; import qutip; import matplotlib.pyplot as plt; b=qutip.Bloch(). b.add_vectors([1,0,0]); b.render(). plt.show(); ```. My `qutip.about()` output is:; ```; QuTiP Version: 4.6.2; Numpy Version: 1.20.3; Scipy Version: 1.6.2; Cython Version: 0.29.24; Matplotlib Version: 3.3.4; Python Version: 3.9.5; Number of CPUs: 4; BLAS Info: INTEL MKL; OPENMP Installed: False; INTEL MKL Ext: False; Platform Info: Windows (AMD64); Installation path: C:\Users\Chester\.conda\envs\qutip-env\lib\site-packages\qutip; ```. Hopefully this helps someone. @jakelishman I tried interactive mode toggling when this problem first occurred as that's what the behaviour reminded me of too. Gave it another go with my example in this text (replacing the `plt.show()` with `b.show()`) but still same behaviour.; I think it's to do with something similar to the problem/solution in https://stackoverflow.com/questions/12369693/how-to-make-the-plot-not-disappear/12905317 as `self.fig` within the Bloch class is initialised in `render()` (and then called in `show()`) a similar way. But I am not familiar enough with the qutip backend to know if this is an error, especially as this does not seem like a common issue.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1616#issuecomment-883619754
https://github.com/qutip/qutip/issues/1616#issuecomment-883619754:140,Deployability,install,install,140,"So after starting with a fresh install of Anaconda and going through the steps described in https://qutip.org/docs/4.1/installation.html to install through conda-forge and conda, I am still seeing the same behaviour. However I have found a workaround that gives me exactly what I want. During my debugging I ending up adding the `b.make_sphere()` command, this seems to have caused the extra set of axes to keep appearing. I found that by omitting the `make_sphere` command and just replacing `b.show()` with `plt.show()` worked perfectly.; Heres my MWE; ```python; import qutip; import matplotlib.pyplot as plt; b=qutip.Bloch(). b.add_vectors([1,0,0]); b.render(). plt.show(); ```. My `qutip.about()` output is:; ```; QuTiP Version: 4.6.2; Numpy Version: 1.20.3; Scipy Version: 1.6.2; Cython Version: 0.29.24; Matplotlib Version: 3.3.4; Python Version: 3.9.5; Number of CPUs: 4; BLAS Info: INTEL MKL; OPENMP Installed: False; INTEL MKL Ext: False; Platform Info: Windows (AMD64); Installation path: C:\Users\Chester\.conda\envs\qutip-env\lib\site-packages\qutip; ```. Hopefully this helps someone. @jakelishman I tried interactive mode toggling when this problem first occurred as that's what the behaviour reminded me of too. Gave it another go with my example in this text (replacing the `plt.show()` with `b.show()`) but still same behaviour.; I think it's to do with something similar to the problem/solution in https://stackoverflow.com/questions/12369693/how-to-make-the-plot-not-disappear/12905317 as `self.fig` within the Bloch class is initialised in `render()` (and then called in `show()`) a similar way. But I am not familiar enough with the qutip backend to know if this is an error, especially as this does not seem like a common issue.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1616#issuecomment-883619754
https://github.com/qutip/qutip/issues/1616#issuecomment-883619754:909,Deployability,Install,Installed,909,"So after starting with a fresh install of Anaconda and going through the steps described in https://qutip.org/docs/4.1/installation.html to install through conda-forge and conda, I am still seeing the same behaviour. However I have found a workaround that gives me exactly what I want. During my debugging I ending up adding the `b.make_sphere()` command, this seems to have caused the extra set of axes to keep appearing. I found that by omitting the `make_sphere` command and just replacing `b.show()` with `plt.show()` worked perfectly.; Heres my MWE; ```python; import qutip; import matplotlib.pyplot as plt; b=qutip.Bloch(). b.add_vectors([1,0,0]); b.render(). plt.show(); ```. My `qutip.about()` output is:; ```; QuTiP Version: 4.6.2; Numpy Version: 1.20.3; Scipy Version: 1.6.2; Cython Version: 0.29.24; Matplotlib Version: 3.3.4; Python Version: 3.9.5; Number of CPUs: 4; BLAS Info: INTEL MKL; OPENMP Installed: False; INTEL MKL Ext: False; Platform Info: Windows (AMD64); Installation path: C:\Users\Chester\.conda\envs\qutip-env\lib\site-packages\qutip; ```. Hopefully this helps someone. @jakelishman I tried interactive mode toggling when this problem first occurred as that's what the behaviour reminded me of too. Gave it another go with my example in this text (replacing the `plt.show()` with `b.show()`) but still same behaviour.; I think it's to do with something similar to the problem/solution in https://stackoverflow.com/questions/12369693/how-to-make-the-plot-not-disappear/12905317 as `self.fig` within the Bloch class is initialised in `render()` (and then called in `show()`) a similar way. But I am not familiar enough with the qutip backend to know if this is an error, especially as this does not seem like a common issue.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1616#issuecomment-883619754
https://github.com/qutip/qutip/issues/1616#issuecomment-883619754:981,Deployability,Install,Installation,981,"So after starting with a fresh install of Anaconda and going through the steps described in https://qutip.org/docs/4.1/installation.html to install through conda-forge and conda, I am still seeing the same behaviour. However I have found a workaround that gives me exactly what I want. During my debugging I ending up adding the `b.make_sphere()` command, this seems to have caused the extra set of axes to keep appearing. I found that by omitting the `make_sphere` command and just replacing `b.show()` with `plt.show()` worked perfectly.; Heres my MWE; ```python; import qutip; import matplotlib.pyplot as plt; b=qutip.Bloch(). b.add_vectors([1,0,0]); b.render(). plt.show(); ```. My `qutip.about()` output is:; ```; QuTiP Version: 4.6.2; Numpy Version: 1.20.3; Scipy Version: 1.6.2; Cython Version: 0.29.24; Matplotlib Version: 3.3.4; Python Version: 3.9.5; Number of CPUs: 4; BLAS Info: INTEL MKL; OPENMP Installed: False; INTEL MKL Ext: False; Platform Info: Windows (AMD64); Installation path: C:\Users\Chester\.conda\envs\qutip-env\lib\site-packages\qutip; ```. Hopefully this helps someone. @jakelishman I tried interactive mode toggling when this problem first occurred as that's what the behaviour reminded me of too. Gave it another go with my example in this text (replacing the `plt.show()` with `b.show()`) but still same behaviour.; I think it's to do with something similar to the problem/solution in https://stackoverflow.com/questions/12369693/how-to-make-the-plot-not-disappear/12905317 as `self.fig` within the Bloch class is initialised in `render()` (and then called in `show()`) a similar way. But I am not familiar enough with the qutip backend to know if this is an error, especially as this does not seem like a common issue.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1616#issuecomment-883619754
https://github.com/qutip/qutip/issues/1616#issuecomment-884790771:113,Availability,robust,robust,113,"@ChesterCamm @jakelishman I've attempted to clean up the figure state tracking in Bloch.render() to make it more robust. As a bonus, I can no longer crash .render() in my own Python console by closing a figure and calling .render() now updates any existing figure that is already shown. @ChesterCamm Feedback on whether my change helps your case would be appreciated. The new code also works with all sort of combinations of .show() and .render() in a Jupyter notebook for me.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1616#issuecomment-884790771
https://github.com/qutip/qutip/issues/1616#issuecomment-884790771:236,Deployability,update,updates,236,"@ChesterCamm @jakelishman I've attempted to clean up the figure state tracking in Bloch.render() to make it more robust. As a bonus, I can no longer crash .render() in my own Python console by closing a figure and calling .render() now updates any existing figure that is already shown. @ChesterCamm Feedback on whether my change helps your case would be appreciated. The new code also works with all sort of combinations of .show() and .render() in a Jupyter notebook for me.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1616#issuecomment-884790771
https://github.com/qutip/qutip/issues/1616#issuecomment-884790771:300,Usability,Feedback,Feedback,300,"@ChesterCamm @jakelishman I've attempted to clean up the figure state tracking in Bloch.render() to make it more robust. As a bonus, I can no longer crash .render() in my own Python console by closing a figure and calling .render() now updates any existing figure that is already shown. @ChesterCamm Feedback on whether my change helps your case would be appreciated. The new code also works with all sort of combinations of .show() and .render() in a Jupyter notebook for me.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1616#issuecomment-884790771
https://github.com/qutip/qutip/issues/1617#issuecomment-885064386:1075,Deployability,patch,patch,1075,"Hi @michelinesoley,. Your bug report inspired me to dig into the `qutip.control.optimize_pulse` sparse matrix support which lead to some fixes in #1621. When you increase `N` in your example from 2 to 3, it changes the internal type used by the optimizer to represent propagators. You can also make the `N = 2` case fail by changing the last line to:. ```python; result = cpo.optimize_pulse_unitary(..., dyn_params=dict(oper_dtype=Qobj, sparse_eigen_decomp=True)); ```. Your example can be made to work for `N = 3` (albeit slowly) by changing the following lines:. ```python; mapped = Qobj(mapped, dims=[[N]*4 + [2]*4] * 2); ```; (which was a bug in the example itself -- it created a Qobj with the right shape but wrong dimensions) and the last line to . ```python; result = cpo.optimize_pulse_unitary(..., dyn_params=dict(oper_dtype=Qobj, sparse_eigen_decomp=False)); ```; For me the `N = 3` case was slower with `sparse_eigen_decomp=True`, but perhaps it will be better for your full problem. If you would like to try `sparse_eigen_decomp=True` you are welcome to try the patch in PR #1621 and I would appreciate feedback on any performance issues for larger systems. We are currently working to support bigger systems in QuTiP 5 by using the new flexible Qobj data layer (which supports both sparse and dense matrices already and will hopefully support GPU and TensorFlow matrices in the near future).",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1617#issuecomment-885064386
https://github.com/qutip/qutip/issues/1617#issuecomment-885064386:1250,Modifiability,flexible,flexible,1250,"Hi @michelinesoley,. Your bug report inspired me to dig into the `qutip.control.optimize_pulse` sparse matrix support which lead to some fixes in #1621. When you increase `N` in your example from 2 to 3, it changes the internal type used by the optimizer to represent propagators. You can also make the `N = 2` case fail by changing the last line to:. ```python; result = cpo.optimize_pulse_unitary(..., dyn_params=dict(oper_dtype=Qobj, sparse_eigen_decomp=True)); ```. Your example can be made to work for `N = 3` (albeit slowly) by changing the following lines:. ```python; mapped = Qobj(mapped, dims=[[N]*4 + [2]*4] * 2); ```; (which was a bug in the example itself -- it created a Qobj with the right shape but wrong dimensions) and the last line to . ```python; result = cpo.optimize_pulse_unitary(..., dyn_params=dict(oper_dtype=Qobj, sparse_eigen_decomp=False)); ```; For me the `N = 3` case was slower with `sparse_eigen_decomp=True`, but perhaps it will be better for your full problem. If you would like to try `sparse_eigen_decomp=True` you are welcome to try the patch in PR #1621 and I would appreciate feedback on any performance issues for larger systems. We are currently working to support bigger systems in QuTiP 5 by using the new flexible Qobj data layer (which supports both sparse and dense matrices already and will hopefully support GPU and TensorFlow matrices in the near future).",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1617#issuecomment-885064386
https://github.com/qutip/qutip/issues/1617#issuecomment-885064386:245,Performance,optimiz,optimizer,245,"Hi @michelinesoley,. Your bug report inspired me to dig into the `qutip.control.optimize_pulse` sparse matrix support which lead to some fixes in #1621. When you increase `N` in your example from 2 to 3, it changes the internal type used by the optimizer to represent propagators. You can also make the `N = 2` case fail by changing the last line to:. ```python; result = cpo.optimize_pulse_unitary(..., dyn_params=dict(oper_dtype=Qobj, sparse_eigen_decomp=True)); ```. Your example can be made to work for `N = 3` (albeit slowly) by changing the following lines:. ```python; mapped = Qobj(mapped, dims=[[N]*4 + [2]*4] * 2); ```; (which was a bug in the example itself -- it created a Qobj with the right shape but wrong dimensions) and the last line to . ```python; result = cpo.optimize_pulse_unitary(..., dyn_params=dict(oper_dtype=Qobj, sparse_eigen_decomp=False)); ```; For me the `N = 3` case was slower with `sparse_eigen_decomp=True`, but perhaps it will be better for your full problem. If you would like to try `sparse_eigen_decomp=True` you are welcome to try the patch in PR #1621 and I would appreciate feedback on any performance issues for larger systems. We are currently working to support bigger systems in QuTiP 5 by using the new flexible Qobj data layer (which supports both sparse and dense matrices already and will hopefully support GPU and TensorFlow matrices in the near future).",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1617#issuecomment-885064386
https://github.com/qutip/qutip/issues/1617#issuecomment-885064386:1132,Performance,perform,performance,1132,"Hi @michelinesoley,. Your bug report inspired me to dig into the `qutip.control.optimize_pulse` sparse matrix support which lead to some fixes in #1621. When you increase `N` in your example from 2 to 3, it changes the internal type used by the optimizer to represent propagators. You can also make the `N = 2` case fail by changing the last line to:. ```python; result = cpo.optimize_pulse_unitary(..., dyn_params=dict(oper_dtype=Qobj, sparse_eigen_decomp=True)); ```. Your example can be made to work for `N = 3` (albeit slowly) by changing the following lines:. ```python; mapped = Qobj(mapped, dims=[[N]*4 + [2]*4] * 2); ```; (which was a bug in the example itself -- it created a Qobj with the right shape but wrong dimensions) and the last line to . ```python; result = cpo.optimize_pulse_unitary(..., dyn_params=dict(oper_dtype=Qobj, sparse_eigen_decomp=False)); ```; For me the `N = 3` case was slower with `sparse_eigen_decomp=True`, but perhaps it will be better for your full problem. If you would like to try `sparse_eigen_decomp=True` you are welcome to try the patch in PR #1621 and I would appreciate feedback on any performance issues for larger systems. We are currently working to support bigger systems in QuTiP 5 by using the new flexible Qobj data layer (which supports both sparse and dense matrices already and will hopefully support GPU and TensorFlow matrices in the near future).",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1617#issuecomment-885064386
https://github.com/qutip/qutip/issues/1617#issuecomment-885064386:1116,Usability,feedback,feedback,1116,"Hi @michelinesoley,. Your bug report inspired me to dig into the `qutip.control.optimize_pulse` sparse matrix support which lead to some fixes in #1621. When you increase `N` in your example from 2 to 3, it changes the internal type used by the optimizer to represent propagators. You can also make the `N = 2` case fail by changing the last line to:. ```python; result = cpo.optimize_pulse_unitary(..., dyn_params=dict(oper_dtype=Qobj, sparse_eigen_decomp=True)); ```. Your example can be made to work for `N = 3` (albeit slowly) by changing the following lines:. ```python; mapped = Qobj(mapped, dims=[[N]*4 + [2]*4] * 2); ```; (which was a bug in the example itself -- it created a Qobj with the right shape but wrong dimensions) and the last line to . ```python; result = cpo.optimize_pulse_unitary(..., dyn_params=dict(oper_dtype=Qobj, sparse_eigen_decomp=False)); ```; For me the `N = 3` case was slower with `sparse_eigen_decomp=True`, but perhaps it will be better for your full problem. If you would like to try `sparse_eigen_decomp=True` you are welcome to try the patch in PR #1621 and I would appreciate feedback on any performance issues for larger systems. We are currently working to support bigger systems in QuTiP 5 by using the new flexible Qobj data layer (which supports both sparse and dense matrices already and will hopefully support GPU and TensorFlow matrices in the near future).",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1617#issuecomment-885064386
https://github.com/qutip/qutip/issues/1617#issuecomment-886058842:143,Deployability,patch,patch,143,"Thank you so much all of your help and for responding so quickly! The fix to the example works very well, thanks!. I am working on getting the patch working and installed commits ecca45c, 3e908bb, 8ce7757, 03b4cb7, 346b2e7, and a1c809a. I am getting a ValueError when I run the example and think I might have accidentally missed a commit - would you have an idea of what I might be missing? I am including my QuTiP version information below. Thanks for all of your help. QuTiP Version: 4.7.0.dev0+a1c809a; Numpy Version: 1.21.0; Scipy Version: 1.4.1; Cython Version: 0.29.24; Matplotlib Version: 3.4.2; Python Version: 3.7.6; Number of CPUs: 2; BLAS Info: OPENBLAS; OPENMP Installed: False; INTEL MKL Ext: False; Platform Info: Darwin (x86_64)",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1617#issuecomment-886058842
https://github.com/qutip/qutip/issues/1617#issuecomment-886058842:161,Deployability,install,installed,161,"Thank you so much all of your help and for responding so quickly! The fix to the example works very well, thanks!. I am working on getting the patch working and installed commits ecca45c, 3e908bb, 8ce7757, 03b4cb7, 346b2e7, and a1c809a. I am getting a ValueError when I run the example and think I might have accidentally missed a commit - would you have an idea of what I might be missing? I am including my QuTiP version information below. Thanks for all of your help. QuTiP Version: 4.7.0.dev0+a1c809a; Numpy Version: 1.21.0; Scipy Version: 1.4.1; Cython Version: 0.29.24; Matplotlib Version: 3.4.2; Python Version: 3.7.6; Number of CPUs: 2; BLAS Info: OPENBLAS; OPENMP Installed: False; INTEL MKL Ext: False; Platform Info: Darwin (x86_64)",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1617#issuecomment-886058842
https://github.com/qutip/qutip/issues/1617#issuecomment-886058842:673,Deployability,Install,Installed,673,"Thank you so much all of your help and for responding so quickly! The fix to the example works very well, thanks!. I am working on getting the patch working and installed commits ecca45c, 3e908bb, 8ce7757, 03b4cb7, 346b2e7, and a1c809a. I am getting a ValueError when I run the example and think I might have accidentally missed a commit - would you have an idea of what I might be missing? I am including my QuTiP version information below. Thanks for all of your help. QuTiP Version: 4.7.0.dev0+a1c809a; Numpy Version: 1.21.0; Scipy Version: 1.4.1; Cython Version: 0.29.24; Matplotlib Version: 3.4.2; Python Version: 3.7.6; Number of CPUs: 2; BLAS Info: OPENBLAS; OPENMP Installed: False; INTEL MKL Ext: False; Platform Info: Darwin (x86_64)",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1617#issuecomment-886058842
https://github.com/qutip/qutip/issues/1617#issuecomment-886098212:110,Availability,error,error,110,"Thanks! I used git checkout for ecca45c and reinstalled with python setup.py install, and I get the following error for the minimal example:; ```; Traceback (most recent call last):; File ""MinimalErrorExample.py"", line 62, in <module>; result = cpo.optimize_pulse_unitary(drift, ctrls, U_0, U_targ, n_ts, evo_time, fid_err_targ=fid_err_targ, min_grad=min_grad, max_iter=max_iter, max_wall_time=max_wall_time, out_file_ext=f_ext, init_pulse_type=p_type, log_level=log_level,gen_stats=True,dyn_params=dict(oper_dtype=Qobj,sparse_eigen_decomp=True)); File ""/Users/msoley/opt/anaconda3/lib/python3.7/site-packages/qutip/control/pulseoptim.py"", line 757, in optimize_pulse_unitary; gen_stats=gen_stats); File ""/Users/msoley/opt/anaconda3/lib/python3.7/site-packages/qutip/control/pulseoptim.py"", line 459, in optimize_pulse; result = optim.run_optimization(); File ""/Users/msoley/opt/anaconda3/lib/python3.7/site-packages/qutip/control/optimizer.py"", line 957, in run_optimization; result = self._create_result(); File ""/Users/msoley/opt/anaconda3/lib/python3.7/site-packages/qutip/control/optimizer.py"", line 362, in _create_result; result.initial_fid_err = self.dynamics.fid_computer.get_fid_err(); File ""/Users/msoley/opt/anaconda3/lib/python3.7/site-packages/qutip/control/fidcomp.py"", line 412, in get_fid_err; return np.abs(1 - self.get_fidelity()); File ""/Users/msoley/opt/anaconda3/lib/python3.7/site-packages/qutip/control/fidcomp.py"", line 422, in get_fidelity; self.fid_norm_func(self.get_fidelity_prenorm()); File ""/Users/msoley/opt/anaconda3/lib/python3.7/site-packages/qutip/control/fidcomp.py"", line 438, in get_fidelity_prenorm; dyn.compute_evolution(); File ""/Users/msoley/opt/anaconda3/lib/python3.7/site-packages/qutip/control/dynamics.py"", line 1394, in compute_evolution; self.tslot_computer.recompute_evolution(); File ""/Users/msoley/opt/anaconda3/lib/python3.7/site-packages/qutip/control/tslotcomp.py"", line 265, in recompute_evolution; prop_comp._compute_prop_grad(k, j); File ""/Us",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1617#issuecomment-886098212
https://github.com/qutip/qutip/issues/1617#issuecomment-886098212:77,Deployability,install,install,77,"Thanks! I used git checkout for ecca45c and reinstalled with python setup.py install, and I get the following error for the minimal example:; ```; Traceback (most recent call last):; File ""MinimalErrorExample.py"", line 62, in <module>; result = cpo.optimize_pulse_unitary(drift, ctrls, U_0, U_targ, n_ts, evo_time, fid_err_targ=fid_err_targ, min_grad=min_grad, max_iter=max_iter, max_wall_time=max_wall_time, out_file_ext=f_ext, init_pulse_type=p_type, log_level=log_level,gen_stats=True,dyn_params=dict(oper_dtype=Qobj,sparse_eigen_decomp=True)); File ""/Users/msoley/opt/anaconda3/lib/python3.7/site-packages/qutip/control/pulseoptim.py"", line 757, in optimize_pulse_unitary; gen_stats=gen_stats); File ""/Users/msoley/opt/anaconda3/lib/python3.7/site-packages/qutip/control/pulseoptim.py"", line 459, in optimize_pulse; result = optim.run_optimization(); File ""/Users/msoley/opt/anaconda3/lib/python3.7/site-packages/qutip/control/optimizer.py"", line 957, in run_optimization; result = self._create_result(); File ""/Users/msoley/opt/anaconda3/lib/python3.7/site-packages/qutip/control/optimizer.py"", line 362, in _create_result; result.initial_fid_err = self.dynamics.fid_computer.get_fid_err(); File ""/Users/msoley/opt/anaconda3/lib/python3.7/site-packages/qutip/control/fidcomp.py"", line 412, in get_fid_err; return np.abs(1 - self.get_fidelity()); File ""/Users/msoley/opt/anaconda3/lib/python3.7/site-packages/qutip/control/fidcomp.py"", line 422, in get_fidelity; self.fid_norm_func(self.get_fidelity_prenorm()); File ""/Users/msoley/opt/anaconda3/lib/python3.7/site-packages/qutip/control/fidcomp.py"", line 438, in get_fidelity_prenorm; dyn.compute_evolution(); File ""/Users/msoley/opt/anaconda3/lib/python3.7/site-packages/qutip/control/dynamics.py"", line 1394, in compute_evolution; self.tslot_computer.recompute_evolution(); File ""/Users/msoley/opt/anaconda3/lib/python3.7/site-packages/qutip/control/tslotcomp.py"", line 265, in recompute_evolution; prop_comp._compute_prop_grad(k, j); File ""/Us",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1617#issuecomment-886098212
https://github.com/qutip/qutip/issues/1617#issuecomment-886098212:3237,Deployability,install,installation,3237,"line 412, in get_fid_err; return np.abs(1 - self.get_fidelity()); File ""/Users/msoley/opt/anaconda3/lib/python3.7/site-packages/qutip/control/fidcomp.py"", line 422, in get_fidelity; self.fid_norm_func(self.get_fidelity_prenorm()); File ""/Users/msoley/opt/anaconda3/lib/python3.7/site-packages/qutip/control/fidcomp.py"", line 438, in get_fidelity_prenorm; dyn.compute_evolution(); File ""/Users/msoley/opt/anaconda3/lib/python3.7/site-packages/qutip/control/dynamics.py"", line 1394, in compute_evolution; self.tslot_computer.recompute_evolution(); File ""/Users/msoley/opt/anaconda3/lib/python3.7/site-packages/qutip/control/tslotcomp.py"", line 265, in recompute_evolution; prop_comp._compute_prop_grad(k, j); File ""/Users/msoley/opt/anaconda3/lib/python3.7/site-packages/qutip/control/propcomp.py"", line 239, in _compute_prop_grad; dyn._ensure_decomp_curr(k); File ""/Users/msoley/opt/anaconda3/lib/python3.7/site-packages/qutip/control/dynamics.py"", line 1410, in _ensure_decomp_curr; self._spectral_decomp(k); File ""/Users/msoley/opt/anaconda3/lib/python3.7/site-packages/qutip/control/dynamics.py"", line 1627, in _spectral_decomp; dims=self.dyn_dims); File ""/Users/msoley/opt/anaconda3/lib/python3.7/site-packages/qutip/qobj.py"", line 273, in __init__; _tmp = sp.csr_matrix(inpt, dtype=complex, copy=do_copy); File ""/Users/msoley/opt/anaconda3/lib/python3.7/site-packages/scipy/sparse/compressed.py"", line 88, in __init__; self._set_self(self.__class__(coo_matrix(arg1, dtype=dtype))); File ""/Users/msoley/opt/anaconda3/lib/python3.7/site-packages/scipy/sparse/coo.py"", line 191, in __init__; self.row, self.col = M.nonzero(); File ""/Users/msoley/opt/anaconda3/lib/python3.7/site-packages/scipy/sparse/base.py"", line 287, in __bool__; raise ValueError(""The truth value of an array with more than one ""; ValueError: The truth value of an array with more than one element is ambiguous. Use a.any() or a.all().; ```. Is there something I am missing in my installation? Thanks again for all of your help.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1617#issuecomment-886098212
https://github.com/qutip/qutip/issues/1617#issuecomment-886098212:931,Performance,optimiz,optimizer,931,"Thanks! I used git checkout for ecca45c and reinstalled with python setup.py install, and I get the following error for the minimal example:; ```; Traceback (most recent call last):; File ""MinimalErrorExample.py"", line 62, in <module>; result = cpo.optimize_pulse_unitary(drift, ctrls, U_0, U_targ, n_ts, evo_time, fid_err_targ=fid_err_targ, min_grad=min_grad, max_iter=max_iter, max_wall_time=max_wall_time, out_file_ext=f_ext, init_pulse_type=p_type, log_level=log_level,gen_stats=True,dyn_params=dict(oper_dtype=Qobj,sparse_eigen_decomp=True)); File ""/Users/msoley/opt/anaconda3/lib/python3.7/site-packages/qutip/control/pulseoptim.py"", line 757, in optimize_pulse_unitary; gen_stats=gen_stats); File ""/Users/msoley/opt/anaconda3/lib/python3.7/site-packages/qutip/control/pulseoptim.py"", line 459, in optimize_pulse; result = optim.run_optimization(); File ""/Users/msoley/opt/anaconda3/lib/python3.7/site-packages/qutip/control/optimizer.py"", line 957, in run_optimization; result = self._create_result(); File ""/Users/msoley/opt/anaconda3/lib/python3.7/site-packages/qutip/control/optimizer.py"", line 362, in _create_result; result.initial_fid_err = self.dynamics.fid_computer.get_fid_err(); File ""/Users/msoley/opt/anaconda3/lib/python3.7/site-packages/qutip/control/fidcomp.py"", line 412, in get_fid_err; return np.abs(1 - self.get_fidelity()); File ""/Users/msoley/opt/anaconda3/lib/python3.7/site-packages/qutip/control/fidcomp.py"", line 422, in get_fidelity; self.fid_norm_func(self.get_fidelity_prenorm()); File ""/Users/msoley/opt/anaconda3/lib/python3.7/site-packages/qutip/control/fidcomp.py"", line 438, in get_fidelity_prenorm; dyn.compute_evolution(); File ""/Users/msoley/opt/anaconda3/lib/python3.7/site-packages/qutip/control/dynamics.py"", line 1394, in compute_evolution; self.tslot_computer.recompute_evolution(); File ""/Users/msoley/opt/anaconda3/lib/python3.7/site-packages/qutip/control/tslotcomp.py"", line 265, in recompute_evolution; prop_comp._compute_prop_grad(k, j); File ""/Us",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1617#issuecomment-886098212
https://github.com/qutip/qutip/issues/1617#issuecomment-886098212:1085,Performance,optimiz,optimizer,1085,"y install, and I get the following error for the minimal example:; ```; Traceback (most recent call last):; File ""MinimalErrorExample.py"", line 62, in <module>; result = cpo.optimize_pulse_unitary(drift, ctrls, U_0, U_targ, n_ts, evo_time, fid_err_targ=fid_err_targ, min_grad=min_grad, max_iter=max_iter, max_wall_time=max_wall_time, out_file_ext=f_ext, init_pulse_type=p_type, log_level=log_level,gen_stats=True,dyn_params=dict(oper_dtype=Qobj,sparse_eigen_decomp=True)); File ""/Users/msoley/opt/anaconda3/lib/python3.7/site-packages/qutip/control/pulseoptim.py"", line 757, in optimize_pulse_unitary; gen_stats=gen_stats); File ""/Users/msoley/opt/anaconda3/lib/python3.7/site-packages/qutip/control/pulseoptim.py"", line 459, in optimize_pulse; result = optim.run_optimization(); File ""/Users/msoley/opt/anaconda3/lib/python3.7/site-packages/qutip/control/optimizer.py"", line 957, in run_optimization; result = self._create_result(); File ""/Users/msoley/opt/anaconda3/lib/python3.7/site-packages/qutip/control/optimizer.py"", line 362, in _create_result; result.initial_fid_err = self.dynamics.fid_computer.get_fid_err(); File ""/Users/msoley/opt/anaconda3/lib/python3.7/site-packages/qutip/control/fidcomp.py"", line 412, in get_fid_err; return np.abs(1 - self.get_fidelity()); File ""/Users/msoley/opt/anaconda3/lib/python3.7/site-packages/qutip/control/fidcomp.py"", line 422, in get_fidelity; self.fid_norm_func(self.get_fidelity_prenorm()); File ""/Users/msoley/opt/anaconda3/lib/python3.7/site-packages/qutip/control/fidcomp.py"", line 438, in get_fidelity_prenorm; dyn.compute_evolution(); File ""/Users/msoley/opt/anaconda3/lib/python3.7/site-packages/qutip/control/dynamics.py"", line 1394, in compute_evolution; self.tslot_computer.recompute_evolution(); File ""/Users/msoley/opt/anaconda3/lib/python3.7/site-packages/qutip/control/tslotcomp.py"", line 265, in recompute_evolution; prop_comp._compute_prop_grad(k, j); File ""/Users/msoley/opt/anaconda3/lib/python3.7/site-packages/qutip/control/propcom",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1617#issuecomment-886098212
https://github.com/qutip/qutip/issues/1617#issuecomment-893413782:58,Deployability,release,release,58,#1621 has been merged and should be included in the 4.6.3 release.,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1617#issuecomment-893413782
https://github.com/qutip/qutip/pull/1619#issuecomment-892545572:135,Availability,robust,robust,135,"@Ericgig @nwlambert @jakelishman I'm hoping one of you has a chance to review. This makes the Bloch sphere plotting significantly more robust for me, so it would be nice to merge it.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1619#issuecomment-892545572
https://github.com/qutip/qutip/pull/1619#issuecomment-950309855:257,Integrability,depend,dependent,257,"@AGaliciaMartinez @gaurav-iiser Since you are looking at the Bloch sphere code too, I'd appreciate some more eyes / trying out of these changes if you have time. We don't have great tests for these plotting functions and the behaviour is rather environment dependent (Python console vs IPython console vs Jupyter notebook vs Spyder).",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1619#issuecomment-950309855
https://github.com/qutip/qutip/pull/1619#issuecomment-950309855:182,Testability,test,tests,182,"@AGaliciaMartinez @gaurav-iiser Since you are looking at the Bloch sphere code too, I'd appreciate some more eyes / trying out of these changes if you have time. We don't have great tests for these plotting functions and the behaviour is rather environment dependent (Python console vs IPython console vs Jupyter notebook vs Spyder).",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1619#issuecomment-950309855
https://github.com/qutip/qutip/pull/1619#issuecomment-988068295:163,Availability,redundant,redundant,163,"I tried it locally and `show` print the figure twice, whether you provide a figure or not. `render` itself print the picture so having it in `show` make `display` redundant. Otherwise, it work fine.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1619#issuecomment-988068295
https://github.com/qutip/qutip/pull/1619#issuecomment-988068295:163,Safety,redund,redundant,163,"I tried it locally and `show` print the figure twice, whether you provide a figure or not. `render` itself print the picture so having it in `show` make `display` redundant. Otherwise, it work fine.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1619#issuecomment-988068295
https://github.com/qutip/qutip/pull/1619#issuecomment-988089216:165,Availability,redundant,redundant,165,"> I tried it locally and `show` print the figure twice, whether you provide a figure or not. `render` itself print the picture so having it in `show` make `display` redundant. Otherwise, it work fine. Where were you running your example? Python console, IPython console, Jupyter notebook? I'm guessing the IPython console because of the reference to `display`, but I wanted to double check.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1619#issuecomment-988089216
https://github.com/qutip/qutip/pull/1619#issuecomment-988089216:165,Safety,redund,redundant,165,"> I tried it locally and `show` print the figure twice, whether you provide a figure or not. `render` itself print the picture so having it in `show` make `display` redundant. Otherwise, it work fine. Where were you running your example? Python console, IPython console, Jupyter notebook? I'm guessing the IPython console because of the reference to `display`, but I wanted to double check.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1619#issuecomment-988089216
https://github.com/qutip/qutip/pull/1619#issuecomment-989293761:197,Availability,down,downside,197,"@Ericgig Thanks for finding that -- I obviously missed a last round of testing in Jupyter notebooks. I've added a special case for the inline backed in Jupyter notebook and even more comments. The downside is that the whole situation with matplotlib is crazy and the current Bloch implementation is not making things any more sane. The upside is that things now seem to work fairly nicely for me in practice. Holding thumbs that they work nicely for you too. P.S. As a bonus, `b.show()` now works for displaying the colormap and the `b.fig` special case is no longer needed (although it still works too).",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1619#issuecomment-989293761
https://github.com/qutip/qutip/pull/1619#issuecomment-989293761:71,Testability,test,testing,71,"@Ericgig Thanks for finding that -- I obviously missed a last round of testing in Jupyter notebooks. I've added a special case for the inline backed in Jupyter notebook and even more comments. The downside is that the whole situation with matplotlib is crazy and the current Bloch implementation is not making things any more sane. The upside is that things now seem to work fairly nicely for me in practice. Holding thumbs that they work nicely for you too. P.S. As a bonus, `b.show()` now works for displaying the colormap and the `b.fig` special case is no longer needed (although it still works too).",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1619#issuecomment-989293761
https://github.com/qutip/qutip/pull/1620#issuecomment-885075257:172,Safety,detect,detecting,172,"@AGaliciaMartinez Perhaps it would be better to check for whether `other` is complex directly using `isinstance(other, numbers.Number)`. This is the canonical approach for detecting scalar numbers and avoids raising and catching an exception and allows objects that support just `__complex__` to still be dispatched for special handling.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1620#issuecomment-885075257
https://github.com/qutip/qutip/pull/1620#issuecomment-885075257:201,Safety,avoid,avoids,201,"@AGaliciaMartinez Perhaps it would be better to check for whether `other` is complex directly using `isinstance(other, numbers.Number)`. This is the canonical approach for detecting scalar numbers and avoids raising and catching an exception and allows objects that support just `__complex__` to still be dispatched for special handling.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1620#issuecomment-885075257
https://github.com/qutip/qutip/pull/1620#issuecomment-885550798:1534,Availability,error,error,1534,"There are two reasons I did not go with `isinstance(other, numbers.Number)`:; - This returns False when `other` is a NumPy array or TensorFlow tensor which makes `__mul__` significantly less flexible.; - If we accept objects that are not instances of `numbers.Number`, we will still have to use `complex(other)`. This is necessary to infer if the output is hermitian or unitary. Hence, instead of doing a set of `isinstance` checks and `shape` checks for NumPy TensorFlow or any other future library we may want to be somewhat compatible with, we just check whether other it can be casted to `complex`. If it can, `mul` makes sense and we let the specialisation do whatever they ""want"" (they could always just do complex(value) in any case). I must admit that the try except with complex also seems not ideal to me. But I could not find a better implementation that fitted the requirements. I mean, we do use this same code pattern at some other points in the code (in `__matmul__` we raise not implemented if `other` can not be casted to Qobj and we catch this with a try) but what worries me is: what happens if `complex(other)` raises TypeError not because we do not know how to do the cast but because the user made a mistake in the code? An example of this could be:; ```python; arrray = np.array([1,2]) # length 2 array; qobj*array; ```; This will return `TypeError` but with a different message if we catch it in the `complex(other)` try execpt. ; - _With_ a try execpt that returns NotImplemented (current implementation) the error message is:` TypeError: operand 'Qobj' does not support ufuncs (__array_ufunc__=None)`; - Wehreas _without_ the try expect (not returnt NotImplemented if `complex(other)` fails), the error message is: `TypeError: only length-1 arrays can be converted to Python scalars`, which could be a useful error message.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1620#issuecomment-885550798
https://github.com/qutip/qutip/pull/1620#issuecomment-885550798:1723,Availability,error,error,1723,"There are two reasons I did not go with `isinstance(other, numbers.Number)`:; - This returns False when `other` is a NumPy array or TensorFlow tensor which makes `__mul__` significantly less flexible.; - If we accept objects that are not instances of `numbers.Number`, we will still have to use `complex(other)`. This is necessary to infer if the output is hermitian or unitary. Hence, instead of doing a set of `isinstance` checks and `shape` checks for NumPy TensorFlow or any other future library we may want to be somewhat compatible with, we just check whether other it can be casted to `complex`. If it can, `mul` makes sense and we let the specialisation do whatever they ""want"" (they could always just do complex(value) in any case). I must admit that the try except with complex also seems not ideal to me. But I could not find a better implementation that fitted the requirements. I mean, we do use this same code pattern at some other points in the code (in `__matmul__` we raise not implemented if `other` can not be casted to Qobj and we catch this with a try) but what worries me is: what happens if `complex(other)` raises TypeError not because we do not know how to do the cast but because the user made a mistake in the code? An example of this could be:; ```python; arrray = np.array([1,2]) # length 2 array; qobj*array; ```; This will return `TypeError` but with a different message if we catch it in the `complex(other)` try execpt. ; - _With_ a try execpt that returns NotImplemented (current implementation) the error message is:` TypeError: operand 'Qobj' does not support ufuncs (__array_ufunc__=None)`; - Wehreas _without_ the try expect (not returnt NotImplemented if `complex(other)` fails), the error message is: `TypeError: only length-1 arrays can be converted to Python scalars`, which could be a useful error message.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1620#issuecomment-885550798
https://github.com/qutip/qutip/pull/1620#issuecomment-885550798:1835,Availability,error,error,1835,"There are two reasons I did not go with `isinstance(other, numbers.Number)`:; - This returns False when `other` is a NumPy array or TensorFlow tensor which makes `__mul__` significantly less flexible.; - If we accept objects that are not instances of `numbers.Number`, we will still have to use `complex(other)`. This is necessary to infer if the output is hermitian or unitary. Hence, instead of doing a set of `isinstance` checks and `shape` checks for NumPy TensorFlow or any other future library we may want to be somewhat compatible with, we just check whether other it can be casted to `complex`. If it can, `mul` makes sense and we let the specialisation do whatever they ""want"" (they could always just do complex(value) in any case). I must admit that the try except with complex also seems not ideal to me. But I could not find a better implementation that fitted the requirements. I mean, we do use this same code pattern at some other points in the code (in `__matmul__` we raise not implemented if `other` can not be casted to Qobj and we catch this with a try) but what worries me is: what happens if `complex(other)` raises TypeError not because we do not know how to do the cast but because the user made a mistake in the code? An example of this could be:; ```python; arrray = np.array([1,2]) # length 2 array; qobj*array; ```; This will return `TypeError` but with a different message if we catch it in the `complex(other)` try execpt. ; - _With_ a try execpt that returns NotImplemented (current implementation) the error message is:` TypeError: operand 'Qobj' does not support ufuncs (__array_ufunc__=None)`; - Wehreas _without_ the try expect (not returnt NotImplemented if `complex(other)` fails), the error message is: `TypeError: only length-1 arrays can be converted to Python scalars`, which could be a useful error message.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1620#issuecomment-885550798
https://github.com/qutip/qutip/pull/1620#issuecomment-885550798:1394,Integrability,message,message,1394,"There are two reasons I did not go with `isinstance(other, numbers.Number)`:; - This returns False when `other` is a NumPy array or TensorFlow tensor which makes `__mul__` significantly less flexible.; - If we accept objects that are not instances of `numbers.Number`, we will still have to use `complex(other)`. This is necessary to infer if the output is hermitian or unitary. Hence, instead of doing a set of `isinstance` checks and `shape` checks for NumPy TensorFlow or any other future library we may want to be somewhat compatible with, we just check whether other it can be casted to `complex`. If it can, `mul` makes sense and we let the specialisation do whatever they ""want"" (they could always just do complex(value) in any case). I must admit that the try except with complex also seems not ideal to me. But I could not find a better implementation that fitted the requirements. I mean, we do use this same code pattern at some other points in the code (in `__matmul__` we raise not implemented if `other` can not be casted to Qobj and we catch this with a try) but what worries me is: what happens if `complex(other)` raises TypeError not because we do not know how to do the cast but because the user made a mistake in the code? An example of this could be:; ```python; arrray = np.array([1,2]) # length 2 array; qobj*array; ```; This will return `TypeError` but with a different message if we catch it in the `complex(other)` try execpt. ; - _With_ a try execpt that returns NotImplemented (current implementation) the error message is:` TypeError: operand 'Qobj' does not support ufuncs (__array_ufunc__=None)`; - Wehreas _without_ the try expect (not returnt NotImplemented if `complex(other)` fails), the error message is: `TypeError: only length-1 arrays can be converted to Python scalars`, which could be a useful error message.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1620#issuecomment-885550798
https://github.com/qutip/qutip/pull/1620#issuecomment-885550798:1540,Integrability,message,message,1540,"There are two reasons I did not go with `isinstance(other, numbers.Number)`:; - This returns False when `other` is a NumPy array or TensorFlow tensor which makes `__mul__` significantly less flexible.; - If we accept objects that are not instances of `numbers.Number`, we will still have to use `complex(other)`. This is necessary to infer if the output is hermitian or unitary. Hence, instead of doing a set of `isinstance` checks and `shape` checks for NumPy TensorFlow or any other future library we may want to be somewhat compatible with, we just check whether other it can be casted to `complex`. If it can, `mul` makes sense and we let the specialisation do whatever they ""want"" (they could always just do complex(value) in any case). I must admit that the try except with complex also seems not ideal to me. But I could not find a better implementation that fitted the requirements. I mean, we do use this same code pattern at some other points in the code (in `__matmul__` we raise not implemented if `other` can not be casted to Qobj and we catch this with a try) but what worries me is: what happens if `complex(other)` raises TypeError not because we do not know how to do the cast but because the user made a mistake in the code? An example of this could be:; ```python; arrray = np.array([1,2]) # length 2 array; qobj*array; ```; This will return `TypeError` but with a different message if we catch it in the `complex(other)` try execpt. ; - _With_ a try execpt that returns NotImplemented (current implementation) the error message is:` TypeError: operand 'Qobj' does not support ufuncs (__array_ufunc__=None)`; - Wehreas _without_ the try expect (not returnt NotImplemented if `complex(other)` fails), the error message is: `TypeError: only length-1 arrays can be converted to Python scalars`, which could be a useful error message.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1620#issuecomment-885550798
https://github.com/qutip/qutip/pull/1620#issuecomment-885550798:1729,Integrability,message,message,1729,"There are two reasons I did not go with `isinstance(other, numbers.Number)`:; - This returns False when `other` is a NumPy array or TensorFlow tensor which makes `__mul__` significantly less flexible.; - If we accept objects that are not instances of `numbers.Number`, we will still have to use `complex(other)`. This is necessary to infer if the output is hermitian or unitary. Hence, instead of doing a set of `isinstance` checks and `shape` checks for NumPy TensorFlow or any other future library we may want to be somewhat compatible with, we just check whether other it can be casted to `complex`. If it can, `mul` makes sense and we let the specialisation do whatever they ""want"" (they could always just do complex(value) in any case). I must admit that the try except with complex also seems not ideal to me. But I could not find a better implementation that fitted the requirements. I mean, we do use this same code pattern at some other points in the code (in `__matmul__` we raise not implemented if `other` can not be casted to Qobj and we catch this with a try) but what worries me is: what happens if `complex(other)` raises TypeError not because we do not know how to do the cast but because the user made a mistake in the code? An example of this could be:; ```python; arrray = np.array([1,2]) # length 2 array; qobj*array; ```; This will return `TypeError` but with a different message if we catch it in the `complex(other)` try execpt. ; - _With_ a try execpt that returns NotImplemented (current implementation) the error message is:` TypeError: operand 'Qobj' does not support ufuncs (__array_ufunc__=None)`; - Wehreas _without_ the try expect (not returnt NotImplemented if `complex(other)` fails), the error message is: `TypeError: only length-1 arrays can be converted to Python scalars`, which could be a useful error message.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1620#issuecomment-885550798
https://github.com/qutip/qutip/pull/1620#issuecomment-885550798:1841,Integrability,message,message,1841,"There are two reasons I did not go with `isinstance(other, numbers.Number)`:; - This returns False when `other` is a NumPy array or TensorFlow tensor which makes `__mul__` significantly less flexible.; - If we accept objects that are not instances of `numbers.Number`, we will still have to use `complex(other)`. This is necessary to infer if the output is hermitian or unitary. Hence, instead of doing a set of `isinstance` checks and `shape` checks for NumPy TensorFlow or any other future library we may want to be somewhat compatible with, we just check whether other it can be casted to `complex`. If it can, `mul` makes sense and we let the specialisation do whatever they ""want"" (they could always just do complex(value) in any case). I must admit that the try except with complex also seems not ideal to me. But I could not find a better implementation that fitted the requirements. I mean, we do use this same code pattern at some other points in the code (in `__matmul__` we raise not implemented if `other` can not be casted to Qobj and we catch this with a try) but what worries me is: what happens if `complex(other)` raises TypeError not because we do not know how to do the cast but because the user made a mistake in the code? An example of this could be:; ```python; arrray = np.array([1,2]) # length 2 array; qobj*array; ```; This will return `TypeError` but with a different message if we catch it in the `complex(other)` try execpt. ; - _With_ a try execpt that returns NotImplemented (current implementation) the error message is:` TypeError: operand 'Qobj' does not support ufuncs (__array_ufunc__=None)`; - Wehreas _without_ the try expect (not returnt NotImplemented if `complex(other)` fails), the error message is: `TypeError: only length-1 arrays can be converted to Python scalars`, which could be a useful error message.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1620#issuecomment-885550798
https://github.com/qutip/qutip/pull/1620#issuecomment-885550798:191,Modifiability,flexible,flexible,191,"There are two reasons I did not go with `isinstance(other, numbers.Number)`:; - This returns False when `other` is a NumPy array or TensorFlow tensor which makes `__mul__` significantly less flexible.; - If we accept objects that are not instances of `numbers.Number`, we will still have to use `complex(other)`. This is necessary to infer if the output is hermitian or unitary. Hence, instead of doing a set of `isinstance` checks and `shape` checks for NumPy TensorFlow or any other future library we may want to be somewhat compatible with, we just check whether other it can be casted to `complex`. If it can, `mul` makes sense and we let the specialisation do whatever they ""want"" (they could always just do complex(value) in any case). I must admit that the try except with complex also seems not ideal to me. But I could not find a better implementation that fitted the requirements. I mean, we do use this same code pattern at some other points in the code (in `__matmul__` we raise not implemented if `other` can not be casted to Qobj and we catch this with a try) but what worries me is: what happens if `complex(other)` raises TypeError not because we do not know how to do the cast but because the user made a mistake in the code? An example of this could be:; ```python; arrray = np.array([1,2]) # length 2 array; qobj*array; ```; This will return `TypeError` but with a different message if we catch it in the `complex(other)` try execpt. ; - _With_ a try execpt that returns NotImplemented (current implementation) the error message is:` TypeError: operand 'Qobj' does not support ufuncs (__array_ufunc__=None)`; - Wehreas _without_ the try expect (not returnt NotImplemented if `complex(other)` fails), the error message is: `TypeError: only length-1 arrays can be converted to Python scalars`, which could be a useful error message.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1620#issuecomment-885550798
https://github.com/qutip/qutip/pull/1620#issuecomment-889006152:1403,Availability,error,error,1403,"hat a scalar is (which classes are scalars) and at what level do we define it (who is responsible for returning NotImplemented). Proposed solutions:; 1) Let the _specialisation_ return `NotImplemented` and set `isherm` only when `complex(other)` is possible. This defines what an scalar is at the _specialisation_ level. However:; - It may cause inconsistent behaviour where some operations are allowed for a data layer (`TfTensor` or any other) but not for another one. I would argue that all specialisations should accept the same input, although operations may be handled differently internally (for example, in tensorflow we want to keep the graph state).; - `NotImplemented` only makes sense for some special binary methods (`__add__`, `__lt__`, etc) as Python employs `NotImplemented` to try `other`'s binary method. My concern is that if the dispatcher is used by itself at some points of the code (such as for the solver) returning `NotImplemented` may cause wrong error messages or even unexpected behaviour with future specialisations ( for instance, although it now raises a deprecation warning, `NotImplemented` is considered as `True` when evaluated as a condition). It seems to me that we should avoid having `NotImplemented` in python space (except for arithmetic operations in a class where they are useful and always make sense).; ; 2) Simon suggested to define what a scalar is at the _dispatcher_ level (or something similar to this but correct me if I am wrong). This would require to have a function that casts any defined scalar to a complex scalar. The dispatcher would be responsible to ensure that the correct scalar gets passed appropriately to the specialisation and for returning not implemented if necessary. ; - This solves the inconsistency problem as you could register a ""new"" scalar and define how it gets cast to a python complex scalar with a function (in most of the times, if not always, this will be `complex(other)`). ; - This does _not_ solve having `NotImplem",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1620#issuecomment-889006152
https://github.com/qutip/qutip/pull/1620#issuecomment-889006152:1409,Integrability,message,messages,1409,"hat a scalar is (which classes are scalars) and at what level do we define it (who is responsible for returning NotImplemented). Proposed solutions:; 1) Let the _specialisation_ return `NotImplemented` and set `isherm` only when `complex(other)` is possible. This defines what an scalar is at the _specialisation_ level. However:; - It may cause inconsistent behaviour where some operations are allowed for a data layer (`TfTensor` or any other) but not for another one. I would argue that all specialisations should accept the same input, although operations may be handled differently internally (for example, in tensorflow we want to keep the graph state).; - `NotImplemented` only makes sense for some special binary methods (`__add__`, `__lt__`, etc) as Python employs `NotImplemented` to try `other`'s binary method. My concern is that if the dispatcher is used by itself at some points of the code (such as for the solver) returning `NotImplemented` may cause wrong error messages or even unexpected behaviour with future specialisations ( for instance, although it now raises a deprecation warning, `NotImplemented` is considered as `True` when evaluated as a condition). It seems to me that we should avoid having `NotImplemented` in python space (except for arithmetic operations in a class where they are useful and always make sense).; ; 2) Simon suggested to define what a scalar is at the _dispatcher_ level (or something similar to this but correct me if I am wrong). This would require to have a function that casts any defined scalar to a complex scalar. The dispatcher would be responsible to ensure that the correct scalar gets passed appropriately to the specialisation and for returning not implemented if necessary. ; - This solves the inconsistency problem as you could register a ""new"" scalar and define how it gets cast to a python complex scalar with a function (in most of the times, if not always, this will be `complex(other)`). ; - This does _not_ solve having `NotImplem",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1620#issuecomment-889006152
https://github.com/qutip/qutip/pull/1620#issuecomment-889006152:3692,Integrability,depend,dependencies,3692,"her would be responsible to ensure that the correct scalar gets passed appropriately to the specialisation and for returning not implemented if necessary. ; - This solves the inconsistency problem as you could register a ""new"" scalar and define how it gets cast to a python complex scalar with a function (in most of the times, if not always, this will be `complex(other)`). ; - This does _not_ solve having `NotImplemented` at the python space.; - It seems to be challenging to implement and will probably make things more difficult to maintain. 3) We can also define more rigorously what a scalar is for `Qobj` with a list, `_ALLOWED_SCALARS = [numbers.Number, ...]` that defines what we accept as scalars. We then do: `isinstace(other, _ALLOWED_SCALARS)` and return `NotImplemented` if not there. Two options here:; 1) QuTiP allows only `numbers.Number`:; - In this case `qutip-tensorflow` can extend `_ALLOWED_SCALARS` with tf.Variable and tf.Tensor. However, if the user uses two plug-ins, say qutip-tensorflow and qutip-something-that-does-not-work-well-with-tensorflow (second plug-in), the second plug-in may not work properly. ; - The above point is not a big deal if we make clear that _ALLOWED_SCALARS must accept `complex(other)` for compatibility reasons. In this way the second plug-in can always default to `complex(other)` (this is already the default behaviour of `mul_dense`).; 2) QuTiP allows `numbers.Number`, `ndarray` of shape `(,)`, `tf.Variable` of shape `(,)` and more in the future.; - The upside of this method with respect to 3.1 is that users know which types they must accept.; - This is probably not a good idea as it means qutip has to handle new dependencies (tensorflow and probalby more in the future).; - This _still_ defines what an scalar is at he `Qobj` level. I think this is not bad as it seems to be the only way of avoiding `NotImplemented` at Python space exept for in special methods (`__mul__`, ...). I think that 3.i is the closest to an ideal solution.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1620#issuecomment-889006152
https://github.com/qutip/qutip/pull/1620#issuecomment-889006152:2910,Modifiability,extend,extend,2910,"m wrong). This would require to have a function that casts any defined scalar to a complex scalar. The dispatcher would be responsible to ensure that the correct scalar gets passed appropriately to the specialisation and for returning not implemented if necessary. ; - This solves the inconsistency problem as you could register a ""new"" scalar and define how it gets cast to a python complex scalar with a function (in most of the times, if not always, this will be `complex(other)`). ; - This does _not_ solve having `NotImplemented` at the python space.; - It seems to be challenging to implement and will probably make things more difficult to maintain. 3) We can also define more rigorously what a scalar is for `Qobj` with a list, `_ALLOWED_SCALARS = [numbers.Number, ...]` that defines what we accept as scalars. We then do: `isinstace(other, _ALLOWED_SCALARS)` and return `NotImplemented` if not there. Two options here:; 1) QuTiP allows only `numbers.Number`:; - In this case `qutip-tensorflow` can extend `_ALLOWED_SCALARS` with tf.Variable and tf.Tensor. However, if the user uses two plug-ins, say qutip-tensorflow and qutip-something-that-does-not-work-well-with-tensorflow (second plug-in), the second plug-in may not work properly. ; - The above point is not a big deal if we make clear that _ALLOWED_SCALARS must accept `complex(other)` for compatibility reasons. In this way the second plug-in can always default to `complex(other)` (this is already the default behaviour of `mul_dense`).; 2) QuTiP allows `numbers.Number`, `ndarray` of shape `(,)`, `tf.Variable` of shape `(,)` and more in the future.; - The upside of this method with respect to 3.1 is that users know which types they must accept.; - This is probably not a good idea as it means qutip has to handle new dependencies (tensorflow and probalby more in the future).; - This _still_ defines what an scalar is at he `Qobj` level. I think this is not bad as it seems to be the only way of avoiding `NotImplemented` at Pyt",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1620#issuecomment-889006152
https://github.com/qutip/qutip/pull/1620#issuecomment-889006152:2944,Modifiability,Variab,Variable,2944,"hat casts any defined scalar to a complex scalar. The dispatcher would be responsible to ensure that the correct scalar gets passed appropriately to the specialisation and for returning not implemented if necessary. ; - This solves the inconsistency problem as you could register a ""new"" scalar and define how it gets cast to a python complex scalar with a function (in most of the times, if not always, this will be `complex(other)`). ; - This does _not_ solve having `NotImplemented` at the python space.; - It seems to be challenging to implement and will probably make things more difficult to maintain. 3) We can also define more rigorously what a scalar is for `Qobj` with a list, `_ALLOWED_SCALARS = [numbers.Number, ...]` that defines what we accept as scalars. We then do: `isinstace(other, _ALLOWED_SCALARS)` and return `NotImplemented` if not there. Two options here:; 1) QuTiP allows only `numbers.Number`:; - In this case `qutip-tensorflow` can extend `_ALLOWED_SCALARS` with tf.Variable and tf.Tensor. However, if the user uses two plug-ins, say qutip-tensorflow and qutip-something-that-does-not-work-well-with-tensorflow (second plug-in), the second plug-in may not work properly. ; - The above point is not a big deal if we make clear that _ALLOWED_SCALARS must accept `complex(other)` for compatibility reasons. In this way the second plug-in can always default to `complex(other)` (this is already the default behaviour of `mul_dense`).; 2) QuTiP allows `numbers.Number`, `ndarray` of shape `(,)`, `tf.Variable` of shape `(,)` and more in the future.; - The upside of this method with respect to 3.1 is that users know which types they must accept.; - This is probably not a good idea as it means qutip has to handle new dependencies (tensorflow and probalby more in the future).; - This _still_ defines what an scalar is at he `Qobj` level. I think this is not bad as it seems to be the only way of avoiding `NotImplemented` at Python space exept for in special methods (`__mul__`",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1620#issuecomment-889006152
https://github.com/qutip/qutip/pull/1620#issuecomment-889006152:2998,Modifiability,plug-in,plug-ins,2998,"her would be responsible to ensure that the correct scalar gets passed appropriately to the specialisation and for returning not implemented if necessary. ; - This solves the inconsistency problem as you could register a ""new"" scalar and define how it gets cast to a python complex scalar with a function (in most of the times, if not always, this will be `complex(other)`). ; - This does _not_ solve having `NotImplemented` at the python space.; - It seems to be challenging to implement and will probably make things more difficult to maintain. 3) We can also define more rigorously what a scalar is for `Qobj` with a list, `_ALLOWED_SCALARS = [numbers.Number, ...]` that defines what we accept as scalars. We then do: `isinstace(other, _ALLOWED_SCALARS)` and return `NotImplemented` if not there. Two options here:; 1) QuTiP allows only `numbers.Number`:; - In this case `qutip-tensorflow` can extend `_ALLOWED_SCALARS` with tf.Variable and tf.Tensor. However, if the user uses two plug-ins, say qutip-tensorflow and qutip-something-that-does-not-work-well-with-tensorflow (second plug-in), the second plug-in may not work properly. ; - The above point is not a big deal if we make clear that _ALLOWED_SCALARS must accept `complex(other)` for compatibility reasons. In this way the second plug-in can always default to `complex(other)` (this is already the default behaviour of `mul_dense`).; 2) QuTiP allows `numbers.Number`, `ndarray` of shape `(,)`, `tf.Variable` of shape `(,)` and more in the future.; - The upside of this method with respect to 3.1 is that users know which types they must accept.; - This is probably not a good idea as it means qutip has to handle new dependencies (tensorflow and probalby more in the future).; - This _still_ defines what an scalar is at he `Qobj` level. I think this is not bad as it seems to be the only way of avoiding `NotImplemented` at Python space exept for in special methods (`__mul__`, ...). I think that 3.i is the closest to an ideal solution.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1620#issuecomment-889006152
https://github.com/qutip/qutip/pull/1620#issuecomment-889006152:3097,Modifiability,plug-in,plug-in,3097,"her would be responsible to ensure that the correct scalar gets passed appropriately to the specialisation and for returning not implemented if necessary. ; - This solves the inconsistency problem as you could register a ""new"" scalar and define how it gets cast to a python complex scalar with a function (in most of the times, if not always, this will be `complex(other)`). ; - This does _not_ solve having `NotImplemented` at the python space.; - It seems to be challenging to implement and will probably make things more difficult to maintain. 3) We can also define more rigorously what a scalar is for `Qobj` with a list, `_ALLOWED_SCALARS = [numbers.Number, ...]` that defines what we accept as scalars. We then do: `isinstace(other, _ALLOWED_SCALARS)` and return `NotImplemented` if not there. Two options here:; 1) QuTiP allows only `numbers.Number`:; - In this case `qutip-tensorflow` can extend `_ALLOWED_SCALARS` with tf.Variable and tf.Tensor. However, if the user uses two plug-ins, say qutip-tensorflow and qutip-something-that-does-not-work-well-with-tensorflow (second plug-in), the second plug-in may not work properly. ; - The above point is not a big deal if we make clear that _ALLOWED_SCALARS must accept `complex(other)` for compatibility reasons. In this way the second plug-in can always default to `complex(other)` (this is already the default behaviour of `mul_dense`).; 2) QuTiP allows `numbers.Number`, `ndarray` of shape `(,)`, `tf.Variable` of shape `(,)` and more in the future.; - The upside of this method with respect to 3.1 is that users know which types they must accept.; - This is probably not a good idea as it means qutip has to handle new dependencies (tensorflow and probalby more in the future).; - This _still_ defines what an scalar is at he `Qobj` level. I think this is not bad as it seems to be the only way of avoiding `NotImplemented` at Python space exept for in special methods (`__mul__`, ...). I think that 3.i is the closest to an ideal solution.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1620#issuecomment-889006152
https://github.com/qutip/qutip/pull/1620#issuecomment-889006152:3118,Modifiability,plug-in,plug-in,3118,"her would be responsible to ensure that the correct scalar gets passed appropriately to the specialisation and for returning not implemented if necessary. ; - This solves the inconsistency problem as you could register a ""new"" scalar and define how it gets cast to a python complex scalar with a function (in most of the times, if not always, this will be `complex(other)`). ; - This does _not_ solve having `NotImplemented` at the python space.; - It seems to be challenging to implement and will probably make things more difficult to maintain. 3) We can also define more rigorously what a scalar is for `Qobj` with a list, `_ALLOWED_SCALARS = [numbers.Number, ...]` that defines what we accept as scalars. We then do: `isinstace(other, _ALLOWED_SCALARS)` and return `NotImplemented` if not there. Two options here:; 1) QuTiP allows only `numbers.Number`:; - In this case `qutip-tensorflow` can extend `_ALLOWED_SCALARS` with tf.Variable and tf.Tensor. However, if the user uses two plug-ins, say qutip-tensorflow and qutip-something-that-does-not-work-well-with-tensorflow (second plug-in), the second plug-in may not work properly. ; - The above point is not a big deal if we make clear that _ALLOWED_SCALARS must accept `complex(other)` for compatibility reasons. In this way the second plug-in can always default to `complex(other)` (this is already the default behaviour of `mul_dense`).; 2) QuTiP allows `numbers.Number`, `ndarray` of shape `(,)`, `tf.Variable` of shape `(,)` and more in the future.; - The upside of this method with respect to 3.1 is that users know which types they must accept.; - This is probably not a good idea as it means qutip has to handle new dependencies (tensorflow and probalby more in the future).; - This _still_ defines what an scalar is at he `Qobj` level. I think this is not bad as it seems to be the only way of avoiding `NotImplemented` at Python space exept for in special methods (`__mul__`, ...). I think that 3.i is the closest to an ideal solution.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1620#issuecomment-889006152
https://github.com/qutip/qutip/pull/1620#issuecomment-889006152:3305,Modifiability,plug-in,plug-in,3305,"her would be responsible to ensure that the correct scalar gets passed appropriately to the specialisation and for returning not implemented if necessary. ; - This solves the inconsistency problem as you could register a ""new"" scalar and define how it gets cast to a python complex scalar with a function (in most of the times, if not always, this will be `complex(other)`). ; - This does _not_ solve having `NotImplemented` at the python space.; - It seems to be challenging to implement and will probably make things more difficult to maintain. 3) We can also define more rigorously what a scalar is for `Qobj` with a list, `_ALLOWED_SCALARS = [numbers.Number, ...]` that defines what we accept as scalars. We then do: `isinstace(other, _ALLOWED_SCALARS)` and return `NotImplemented` if not there. Two options here:; 1) QuTiP allows only `numbers.Number`:; - In this case `qutip-tensorflow` can extend `_ALLOWED_SCALARS` with tf.Variable and tf.Tensor. However, if the user uses two plug-ins, say qutip-tensorflow and qutip-something-that-does-not-work-well-with-tensorflow (second plug-in), the second plug-in may not work properly. ; - The above point is not a big deal if we make clear that _ALLOWED_SCALARS must accept `complex(other)` for compatibility reasons. In this way the second plug-in can always default to `complex(other)` (this is already the default behaviour of `mul_dense`).; 2) QuTiP allows `numbers.Number`, `ndarray` of shape `(,)`, `tf.Variable` of shape `(,)` and more in the future.; - The upside of this method with respect to 3.1 is that users know which types they must accept.; - This is probably not a good idea as it means qutip has to handle new dependencies (tensorflow and probalby more in the future).; - This _still_ defines what an scalar is at he `Qobj` level. I think this is not bad as it seems to be the only way of avoiding `NotImplemented` at Python space exept for in special methods (`__mul__`, ...). I think that 3.i is the closest to an ideal solution.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1620#issuecomment-889006152
https://github.com/qutip/qutip/pull/1620#issuecomment-889006152:3473,Modifiability,Variab,Variable,3473,"her would be responsible to ensure that the correct scalar gets passed appropriately to the specialisation and for returning not implemented if necessary. ; - This solves the inconsistency problem as you could register a ""new"" scalar and define how it gets cast to a python complex scalar with a function (in most of the times, if not always, this will be `complex(other)`). ; - This does _not_ solve having `NotImplemented` at the python space.; - It seems to be challenging to implement and will probably make things more difficult to maintain. 3) We can also define more rigorously what a scalar is for `Qobj` with a list, `_ALLOWED_SCALARS = [numbers.Number, ...]` that defines what we accept as scalars. We then do: `isinstace(other, _ALLOWED_SCALARS)` and return `NotImplemented` if not there. Two options here:; 1) QuTiP allows only `numbers.Number`:; - In this case `qutip-tensorflow` can extend `_ALLOWED_SCALARS` with tf.Variable and tf.Tensor. However, if the user uses two plug-ins, say qutip-tensorflow and qutip-something-that-does-not-work-well-with-tensorflow (second plug-in), the second plug-in may not work properly. ; - The above point is not a big deal if we make clear that _ALLOWED_SCALARS must accept `complex(other)` for compatibility reasons. In this way the second plug-in can always default to `complex(other)` (this is already the default behaviour of `mul_dense`).; 2) QuTiP allows `numbers.Number`, `ndarray` of shape `(,)`, `tf.Variable` of shape `(,)` and more in the future.; - The upside of this method with respect to 3.1 is that users know which types they must accept.; - This is probably not a good idea as it means qutip has to handle new dependencies (tensorflow and probalby more in the future).; - This _still_ defines what an scalar is at he `Qobj` level. I think this is not bad as it seems to be the only way of avoiding `NotImplemented` at Python space exept for in special methods (`__mul__`, ...). I think that 3.i is the closest to an ideal solution.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1620#issuecomment-889006152
https://github.com/qutip/qutip/pull/1620#issuecomment-889006152:1640,Safety,avoid,avoid,1640,"s defines what an scalar is at the _specialisation_ level. However:; - It may cause inconsistent behaviour where some operations are allowed for a data layer (`TfTensor` or any other) but not for another one. I would argue that all specialisations should accept the same input, although operations may be handled differently internally (for example, in tensorflow we want to keep the graph state).; - `NotImplemented` only makes sense for some special binary methods (`__add__`, `__lt__`, etc) as Python employs `NotImplemented` to try `other`'s binary method. My concern is that if the dispatcher is used by itself at some points of the code (such as for the solver) returning `NotImplemented` may cause wrong error messages or even unexpected behaviour with future specialisations ( for instance, although it now raises a deprecation warning, `NotImplemented` is considered as `True` when evaluated as a condition). It seems to me that we should avoid having `NotImplemented` in python space (except for arithmetic operations in a class where they are useful and always make sense).; ; 2) Simon suggested to define what a scalar is at the _dispatcher_ level (or something similar to this but correct me if I am wrong). This would require to have a function that casts any defined scalar to a complex scalar. The dispatcher would be responsible to ensure that the correct scalar gets passed appropriately to the specialisation and for returning not implemented if necessary. ; - This solves the inconsistency problem as you could register a ""new"" scalar and define how it gets cast to a python complex scalar with a function (in most of the times, if not always, this will be `complex(other)`). ; - This does _not_ solve having `NotImplemented` at the python space.; - It seems to be challenging to implement and will probably make things more difficult to maintain. 3) We can also define more rigorously what a scalar is for `Qobj` with a list, `_ALLOWED_SCALARS = [numbers.Number, ...]` that define",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1620#issuecomment-889006152
https://github.com/qutip/qutip/pull/1620#issuecomment-889006152:3871,Safety,avoid,avoiding,3871,"her would be responsible to ensure that the correct scalar gets passed appropriately to the specialisation and for returning not implemented if necessary. ; - This solves the inconsistency problem as you could register a ""new"" scalar and define how it gets cast to a python complex scalar with a function (in most of the times, if not always, this will be `complex(other)`). ; - This does _not_ solve having `NotImplemented` at the python space.; - It seems to be challenging to implement and will probably make things more difficult to maintain. 3) We can also define more rigorously what a scalar is for `Qobj` with a list, `_ALLOWED_SCALARS = [numbers.Number, ...]` that defines what we accept as scalars. We then do: `isinstace(other, _ALLOWED_SCALARS)` and return `NotImplemented` if not there. Two options here:; 1) QuTiP allows only `numbers.Number`:; - In this case `qutip-tensorflow` can extend `_ALLOWED_SCALARS` with tf.Variable and tf.Tensor. However, if the user uses two plug-ins, say qutip-tensorflow and qutip-something-that-does-not-work-well-with-tensorflow (second plug-in), the second plug-in may not work properly. ; - The above point is not a big deal if we make clear that _ALLOWED_SCALARS must accept `complex(other)` for compatibility reasons. In this way the second plug-in can always default to `complex(other)` (this is already the default behaviour of `mul_dense`).; 2) QuTiP allows `numbers.Number`, `ndarray` of shape `(,)`, `tf.Variable` of shape `(,)` and more in the future.; - The upside of this method with respect to 3.1 is that users know which types they must accept.; - This is probably not a good idea as it means qutip has to handle new dependencies (tensorflow and probalby more in the future).; - This _still_ defines what an scalar is at he `Qobj` level. I think this is not bad as it seems to be the only way of avoiding `NotImplemented` at Python space exept for in special methods (`__mul__`, ...). I think that 3.i is the closest to an ideal solution.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1620#issuecomment-889006152
https://github.com/qutip/qutip/pull/1620#issuecomment-889006152:3198,Usability,clear,clear,3198,"her would be responsible to ensure that the correct scalar gets passed appropriately to the specialisation and for returning not implemented if necessary. ; - This solves the inconsistency problem as you could register a ""new"" scalar and define how it gets cast to a python complex scalar with a function (in most of the times, if not always, this will be `complex(other)`). ; - This does _not_ solve having `NotImplemented` at the python space.; - It seems to be challenging to implement and will probably make things more difficult to maintain. 3) We can also define more rigorously what a scalar is for `Qobj` with a list, `_ALLOWED_SCALARS = [numbers.Number, ...]` that defines what we accept as scalars. We then do: `isinstace(other, _ALLOWED_SCALARS)` and return `NotImplemented` if not there. Two options here:; 1) QuTiP allows only `numbers.Number`:; - In this case `qutip-tensorflow` can extend `_ALLOWED_SCALARS` with tf.Variable and tf.Tensor. However, if the user uses two plug-ins, say qutip-tensorflow and qutip-something-that-does-not-work-well-with-tensorflow (second plug-in), the second plug-in may not work properly. ; - The above point is not a big deal if we make clear that _ALLOWED_SCALARS must accept `complex(other)` for compatibility reasons. In this way the second plug-in can always default to `complex(other)` (this is already the default behaviour of `mul_dense`).; 2) QuTiP allows `numbers.Number`, `ndarray` of shape `(,)`, `tf.Variable` of shape `(,)` and more in the future.; - The upside of this method with respect to 3.1 is that users know which types they must accept.; - This is probably not a good idea as it means qutip has to handle new dependencies (tensorflow and probalby more in the future).; - This _still_ defines what an scalar is at he `Qobj` level. I think this is not bad as it seems to be the only way of avoiding `NotImplemented` at Python space exept for in special methods (`__mul__`, ...). I think that 3.i is the closest to an ideal solution.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1620#issuecomment-889006152
https://github.com/qutip/qutip/pull/1620#issuecomment-889018969:299,Availability,error,error,299,"This all seems incredibly complicated. How about all specialisations stored in the dispatcher take `object` as the scalar type, and throw a TypeError if they can't handle it. `Qobj.__mul__` just does a `try/except`, and returns `NotImplemented` if it catches a TypeError. If it doesn't catch a type error, it calls a separate function, something like; ```python; @functools.singledispatch; def _scalar_properties(x):; return {; # if the matrix was Hermitian, is the output Hermitian (True), or not known (False); 'preserves_hermicity': bool,; # regardless of the input matrix, is the output Hermitian (True), or not known (False); # (i.e. was the scalar zero-like).; 'forces_hermicity': bool,; # if the matrix was unitary, is it still unitary (True), or not known (False); 'preserves_unitarity': Optional[bool],; }; ```; Then just register types with the functools dispatcher?. So then `Qobj.__mul__` looks like:; ```python; def __mul__(self, other):; if isinstance(other, (Qobj, QobjEvo)):; return self.__matmul__(other); try:; out = _data.mul(self.data, other); except TypeError:; return NotImplemented; properties = _scalar_properties(other); isherm = properties['forces_hermicity'] or (self.isherm and properties['preserves_hermicity'] or None); isunitary = self.isunitary and properties['preserves_unitarity'] or None; return Qobj(; out, copy=False, dims=self.dims, isherm=isherm, isunitary=isunitary,; ); ```; (I've probably not got the property truthiness checking exactly right, but that's the principle.)",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1620#issuecomment-889018969
https://github.com/qutip/qutip/pull/1620#issuecomment-889778895:145,Usability,feedback,feedback,145,"I am actually fine with using a try/except with `data.mul` (definitely better than try/except with `complex(other)`). Is just that from previous feedback I thought this was not the canonical approach?. Regarding to `_scalar_properties`, I think it is a very interesting idea that would definitely be helpful for symbolic representations of `Qobj`. For current extensions (qutip-tensorflow and qutip-cupy) it is not really needed as `complex(other)` works just fine. I would prefer to not implement it and leave this feature for another PR.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1620#issuecomment-889778895
https://github.com/qutip/qutip/pull/1620#issuecomment-891906074:263,Usability,simpl,simplest,263,I After the discussion in the GSoC meeting I changed the implementation to:; - try `mul` and return `NotImplemented` if `TypeError` is raised. (as jake suggested); - try `complex(other)` to inger `ishemr` and `isunitary`. (as Eric suggested). I think this is the simplest solution. @jakelishman are you ok with this implementation? I think the ideas of numpy broadcasting Qobj as scalar and `_scalar_properties` are really good but probably out of the scope of this PR.,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1620#issuecomment-891906074
https://github.com/qutip/qutip/pull/1620#issuecomment-892573255:25,Availability,failure,failure,25,"I don't know if the test failure is related or not -- it *looks* unrelated but it is a data layer test, so we should probably check a bit carefully.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1620#issuecomment-892573255
https://github.com/qutip/qutip/pull/1620#issuecomment-892573255:20,Testability,test,test,20,"I don't know if the test failure is related or not -- it *looks* unrelated but it is a data layer test, so we should probably check a bit carefully.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1620#issuecomment-892573255
https://github.com/qutip/qutip/pull/1620#issuecomment-892573255:98,Testability,test,test,98,"I don't know if the test failure is related or not -- it *looks* unrelated but it is a data layer test, so we should probably check a bit carefully.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1620#issuecomment-892573255
https://github.com/qutip/qutip/pull/1620#issuecomment-892631295:33,Deployability,update,update,33,@AGaliciaMartinez Could you also update the changelog entry in the PR description to say something about the change?,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1620#issuecomment-892631295
https://github.com/qutip/qutip/pull/1620#issuecomment-892862214:506,Modifiability,extend,extend,506,"> Do we have any tests for whether the isherm and isunitary preserving logic is correct?. We do have a few tests, see for instance `test_QobjUnitaryOper` which I modified in this PR to track a few more cases. However, the current tests are not very exhaustive. For example, they do not really ensure that hermiticity is inferred in the operation. some rethinking of these tests may be beneficial but I would prefer leaving that for another PR. Should I open an issue to remember this or do you prefer if I extend these tests in this PR?",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1620#issuecomment-892862214
https://github.com/qutip/qutip/pull/1620#issuecomment-892862214:17,Testability,test,tests,17,"> Do we have any tests for whether the isherm and isunitary preserving logic is correct?. We do have a few tests, see for instance `test_QobjUnitaryOper` which I modified in this PR to track a few more cases. However, the current tests are not very exhaustive. For example, they do not really ensure that hermiticity is inferred in the operation. some rethinking of these tests may be beneficial but I would prefer leaving that for another PR. Should I open an issue to remember this or do you prefer if I extend these tests in this PR?",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1620#issuecomment-892862214
https://github.com/qutip/qutip/pull/1620#issuecomment-892862214:71,Testability,log,logic,71,"> Do we have any tests for whether the isherm and isunitary preserving logic is correct?. We do have a few tests, see for instance `test_QobjUnitaryOper` which I modified in this PR to track a few more cases. However, the current tests are not very exhaustive. For example, they do not really ensure that hermiticity is inferred in the operation. some rethinking of these tests may be beneficial but I would prefer leaving that for another PR. Should I open an issue to remember this or do you prefer if I extend these tests in this PR?",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1620#issuecomment-892862214
https://github.com/qutip/qutip/pull/1620#issuecomment-892862214:107,Testability,test,tests,107,"> Do we have any tests for whether the isherm and isunitary preserving logic is correct?. We do have a few tests, see for instance `test_QobjUnitaryOper` which I modified in this PR to track a few more cases. However, the current tests are not very exhaustive. For example, they do not really ensure that hermiticity is inferred in the operation. some rethinking of these tests may be beneficial but I would prefer leaving that for another PR. Should I open an issue to remember this or do you prefer if I extend these tests in this PR?",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1620#issuecomment-892862214
https://github.com/qutip/qutip/pull/1620#issuecomment-892862214:230,Testability,test,tests,230,"> Do we have any tests for whether the isherm and isunitary preserving logic is correct?. We do have a few tests, see for instance `test_QobjUnitaryOper` which I modified in this PR to track a few more cases. However, the current tests are not very exhaustive. For example, they do not really ensure that hermiticity is inferred in the operation. some rethinking of these tests may be beneficial but I would prefer leaving that for another PR. Should I open an issue to remember this or do you prefer if I extend these tests in this PR?",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1620#issuecomment-892862214
https://github.com/qutip/qutip/pull/1620#issuecomment-892862214:372,Testability,test,tests,372,"> Do we have any tests for whether the isherm and isunitary preserving logic is correct?. We do have a few tests, see for instance `test_QobjUnitaryOper` which I modified in this PR to track a few more cases. However, the current tests are not very exhaustive. For example, they do not really ensure that hermiticity is inferred in the operation. some rethinking of these tests may be beneficial but I would prefer leaving that for another PR. Should I open an issue to remember this or do you prefer if I extend these tests in this PR?",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1620#issuecomment-892862214
https://github.com/qutip/qutip/pull/1620#issuecomment-892862214:519,Testability,test,tests,519,"> Do we have any tests for whether the isherm and isunitary preserving logic is correct?. We do have a few tests, see for instance `test_QobjUnitaryOper` which I modified in this PR to track a few more cases. However, the current tests are not very exhaustive. For example, they do not really ensure that hermiticity is inferred in the operation. some rethinking of these tests may be beneficial but I would prefer leaving that for another PR. Should I open an issue to remember this or do you prefer if I extend these tests in this PR?",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1620#issuecomment-892862214
https://github.com/qutip/qutip/pull/1620#issuecomment-893430207:441,Modifiability,extend,extend,441,"> We do have a few tests, see for instance `test_QobjUnitaryOper` which I modified in this PR to track a few more cases. Perfect. Thank you!. > However, the current tests are not very exhaustive. For example, they do not really ensure that hermiticity is inferred in the operation. some rethinking of these tests may be beneficial but I would prefer leaving that for another PR. Should I open an issue to remember this or do you prefer if I extend these tests in this PR?. Happy to leave this for another PR.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1620#issuecomment-893430207
https://github.com/qutip/qutip/pull/1620#issuecomment-893430207:19,Testability,test,tests,19,"> We do have a few tests, see for instance `test_QobjUnitaryOper` which I modified in this PR to track a few more cases. Perfect. Thank you!. > However, the current tests are not very exhaustive. For example, they do not really ensure that hermiticity is inferred in the operation. some rethinking of these tests may be beneficial but I would prefer leaving that for another PR. Should I open an issue to remember this or do you prefer if I extend these tests in this PR?. Happy to leave this for another PR.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1620#issuecomment-893430207
https://github.com/qutip/qutip/pull/1620#issuecomment-893430207:165,Testability,test,tests,165,"> We do have a few tests, see for instance `test_QobjUnitaryOper` which I modified in this PR to track a few more cases. Perfect. Thank you!. > However, the current tests are not very exhaustive. For example, they do not really ensure that hermiticity is inferred in the operation. some rethinking of these tests may be beneficial but I would prefer leaving that for another PR. Should I open an issue to remember this or do you prefer if I extend these tests in this PR?. Happy to leave this for another PR.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1620#issuecomment-893430207
https://github.com/qutip/qutip/pull/1620#issuecomment-893430207:307,Testability,test,tests,307,"> We do have a few tests, see for instance `test_QobjUnitaryOper` which I modified in this PR to track a few more cases. Perfect. Thank you!. > However, the current tests are not very exhaustive. For example, they do not really ensure that hermiticity is inferred in the operation. some rethinking of these tests may be beneficial but I would prefer leaving that for another PR. Should I open an issue to remember this or do you prefer if I extend these tests in this PR?. Happy to leave this for another PR.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1620#issuecomment-893430207
https://github.com/qutip/qutip/pull/1620#issuecomment-893430207:454,Testability,test,tests,454,"> We do have a few tests, see for instance `test_QobjUnitaryOper` which I modified in this PR to track a few more cases. Perfect. Thank you!. > However, the current tests are not very exhaustive. For example, they do not really ensure that hermiticity is inferred in the operation. some rethinking of these tests may be beneficial but I would prefer leaving that for another PR. Should I open an issue to remember this or do you prefer if I extend these tests in this PR?. Happy to leave this for another PR.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1620#issuecomment-893430207
https://github.com/qutip/qutip/pull/1621#issuecomment-892573655:234,Performance,optimiz,optimization-csr-support-and-fix-qobj-with-sparse-eigens,234,[![Coverage Status](https://coveralls.io/builds/41895317/badge)](https://coveralls.io/builds/41895317). Coverage increased (+0.1%) to 65.914% when pulling **d6f993ef42c77803c6628914f381cc9933338623 on hodgestar:feature/remove-control-optimization-csr-support-and-fix-qobj-with-sparse-eigens** into **0eab37a0c49cb4cab31cd69c30ef14fb30089429 on qutip:master**.,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1621#issuecomment-892573655
https://github.com/qutip/qutip/issues/1623#issuecomment-886175452:849,Energy Efficiency,efficient,efficient,849,"Pure numerically speaking, the last `diss_coeff` is a way larger than the others.; ```python; >>>diss_coeff; [0.19836061612310207j,; 0.25470007277190326j,; 0.223606797519535j,; 4925.267477050309j]; ```; With this large frequency, if you want to solve the dynamics using ODE, I don't think there is a way to make it faster. You have to either simplify your model mathematically, or, because there is no time dependency in your system, use the (deprecated) `essolve` that computes the dynamics using eigenvalues. Thinking about the physics, the T2 time is much smaller than your `tlist`, the system has already fully decohered. PS: @jakelishman It seems that the `essolve` does have some use-cases? Like in small systems for verification perpose. I remember there is another PR that also mentions it. As we deprecated it, I'm wondering if there is an efficient alternative in QuTiP?",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1623#issuecomment-886175452
https://github.com/qutip/qutip/issues/1623#issuecomment-886175452:407,Integrability,depend,dependency,407,"Pure numerically speaking, the last `diss_coeff` is a way larger than the others.; ```python; >>>diss_coeff; [0.19836061612310207j,; 0.25470007277190326j,; 0.223606797519535j,; 4925.267477050309j]; ```; With this large frequency, if you want to solve the dynamics using ODE, I don't think there is a way to make it faster. You have to either simplify your model mathematically, or, because there is no time dependency in your system, use the (deprecated) `essolve` that computes the dynamics using eigenvalues. Thinking about the physics, the T2 time is much smaller than your `tlist`, the system has already fully decohered. PS: @jakelishman It seems that the `essolve` does have some use-cases? Like in small systems for verification perpose. I remember there is another PR that also mentions it. As we deprecated it, I'm wondering if there is an efficient alternative in QuTiP?",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1623#issuecomment-886175452
https://github.com/qutip/qutip/issues/1623#issuecomment-886175452:342,Usability,simpl,simplify,342,"Pure numerically speaking, the last `diss_coeff` is a way larger than the others.; ```python; >>>diss_coeff; [0.19836061612310207j,; 0.25470007277190326j,; 0.223606797519535j,; 4925.267477050309j]; ```; With this large frequency, if you want to solve the dynamics using ODE, I don't think there is a way to make it faster. You have to either simplify your model mathematically, or, because there is no time dependency in your system, use the (deprecated) `essolve` that computes the dynamics using eigenvalues. Thinking about the physics, the T2 time is much smaller than your `tlist`, the system has already fully decohered. PS: @jakelishman It seems that the `essolve` does have some use-cases? Like in small systems for verification perpose. I remember there is another PR that also mentions it. As we deprecated it, I'm wondering if there is an efficient alternative in QuTiP?",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1623#issuecomment-886175452
https://github.com/qutip/qutip/issues/1623#issuecomment-886178364:65,Availability,error,error,65,"@BoxiLi Thank you, that was the root of the problem. I'd made an error while defining the list of coefficients. It's working fine now.; That last coefficient was not supposed to be that large.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1623#issuecomment-886178364
https://github.com/qutip/qutip/issues/1624#issuecomment-887782852:215,Availability,error,error,215,"As stated in the docstring in the function, the a_ops Cubic_Spline must be a tuple (f(w), g(t)). This was my mistake (possibly this could be updated in the online documentation on BRME). Closing this as there is no error. Although I will note there is a legitimate error if the array passed to `qt.Cubic_Spline` is too large. In this case, `np.array2string` uses the default `threshold` argument which means the saved array is compressed (e.g. `[0,1,2,...,8,9,10]`). The way to fix this is to explicitly set the threshold argument.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1624#issuecomment-887782852
https://github.com/qutip/qutip/issues/1624#issuecomment-887782852:265,Availability,error,error,265,"As stated in the docstring in the function, the a_ops Cubic_Spline must be a tuple (f(w), g(t)). This was my mistake (possibly this could be updated in the online documentation on BRME). Closing this as there is no error. Although I will note there is a legitimate error if the array passed to `qt.Cubic_Spline` is too large. In this case, `np.array2string` uses the default `threshold` argument which means the saved array is compressed (e.g. `[0,1,2,...,8,9,10]`). The way to fix this is to explicitly set the threshold argument.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1624#issuecomment-887782852
https://github.com/qutip/qutip/issues/1624#issuecomment-887782852:141,Deployability,update,updated,141,"As stated in the docstring in the function, the a_ops Cubic_Spline must be a tuple (f(w), g(t)). This was my mistake (possibly this could be updated in the online documentation on BRME). Closing this as there is no error. Although I will note there is a legitimate error if the array passed to `qt.Cubic_Spline` is too large. In this case, `np.array2string` uses the default `threshold` argument which means the saved array is compressed (e.g. `[0,1,2,...,8,9,10]`). The way to fix this is to explicitly set the threshold argument.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1624#issuecomment-887782852
https://github.com/qutip/qutip/issues/1624#issuecomment-892692218:211,Deployability,release,release,211,@jsmarsha11 Thank you for reporting this and figuring things out. The use of `np.array2string` is indeed suboptimal and will hopefully be removed as part of the solver rework in QuTiP version 5 which we hope to release later this year.,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1624#issuecomment-892692218
https://github.com/qutip/qutip/pull/1626#issuecomment-891908560:39,Testability,test,tests,39,@hodgestar @Ericgig I think the failed tests are unrelated to this PR. Could you rerun the tests?,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1626#issuecomment-891908560
https://github.com/qutip/qutip/pull/1626#issuecomment-891908560:91,Testability,test,tests,91,@hodgestar @Ericgig I think the failed tests are unrelated to this PR. Could you rerun the tests?,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1626#issuecomment-891908560
https://github.com/qutip/qutip/pull/1630#issuecomment-893461777:21,Deployability,update,updated,21,@hodgestar changelog updated.,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1630#issuecomment-893461777
https://github.com/qutip/qutip/pull/1632#issuecomment-893326408:1015,Energy Efficiency,charge,charge,1015,"@maij Thanks! The test code looks like a good start. Could you add it to `qutip/tests/test_wigner.py`?. Other tests we could add:. * We could write a more general test that compares the output of spin_q_function to a simpler implementation based on the definition -- something like:; ```python; state = qutip.spin_coherent(spin, theta_prime, phi_prime); direct_q = (state.dag() * qutip.ket2dm(psi) * state).norm() / np.pi; ```; Note: I named the angles `theta_prime` and `phi_prime` to emphasize that we can apply this test to cases where the angles for the state psi and the ones passed to spin_q_function are different. * We should also add a test for passing in arrays of theta and phi (i.e. were we really get out a mesh grid for Q values) since that was the primary use case for which `spin_q_function` was defined. Ideas for future PRs:. * It would be nice to also add tests for `spin_wigner` (I am suspicious of it now because of the problems with spin_q_function). Thank you for looking at these and taking charge of this bit of QuTiP.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1632#issuecomment-893326408
https://github.com/qutip/qutip/pull/1632#issuecomment-893326408:18,Testability,test,test,18,"@maij Thanks! The test code looks like a good start. Could you add it to `qutip/tests/test_wigner.py`?. Other tests we could add:. * We could write a more general test that compares the output of spin_q_function to a simpler implementation based on the definition -- something like:; ```python; state = qutip.spin_coherent(spin, theta_prime, phi_prime); direct_q = (state.dag() * qutip.ket2dm(psi) * state).norm() / np.pi; ```; Note: I named the angles `theta_prime` and `phi_prime` to emphasize that we can apply this test to cases where the angles for the state psi and the ones passed to spin_q_function are different. * We should also add a test for passing in arrays of theta and phi (i.e. were we really get out a mesh grid for Q values) since that was the primary use case for which `spin_q_function` was defined. Ideas for future PRs:. * It would be nice to also add tests for `spin_wigner` (I am suspicious of it now because of the problems with spin_q_function). Thank you for looking at these and taking charge of this bit of QuTiP.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1632#issuecomment-893326408
https://github.com/qutip/qutip/pull/1632#issuecomment-893326408:80,Testability,test,tests,80,"@maij Thanks! The test code looks like a good start. Could you add it to `qutip/tests/test_wigner.py`?. Other tests we could add:. * We could write a more general test that compares the output of spin_q_function to a simpler implementation based on the definition -- something like:; ```python; state = qutip.spin_coherent(spin, theta_prime, phi_prime); direct_q = (state.dag() * qutip.ket2dm(psi) * state).norm() / np.pi; ```; Note: I named the angles `theta_prime` and `phi_prime` to emphasize that we can apply this test to cases where the angles for the state psi and the ones passed to spin_q_function are different. * We should also add a test for passing in arrays of theta and phi (i.e. were we really get out a mesh grid for Q values) since that was the primary use case for which `spin_q_function` was defined. Ideas for future PRs:. * It would be nice to also add tests for `spin_wigner` (I am suspicious of it now because of the problems with spin_q_function). Thank you for looking at these and taking charge of this bit of QuTiP.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1632#issuecomment-893326408
https://github.com/qutip/qutip/pull/1632#issuecomment-893326408:110,Testability,test,tests,110,"@maij Thanks! The test code looks like a good start. Could you add it to `qutip/tests/test_wigner.py`?. Other tests we could add:. * We could write a more general test that compares the output of spin_q_function to a simpler implementation based on the definition -- something like:; ```python; state = qutip.spin_coherent(spin, theta_prime, phi_prime); direct_q = (state.dag() * qutip.ket2dm(psi) * state).norm() / np.pi; ```; Note: I named the angles `theta_prime` and `phi_prime` to emphasize that we can apply this test to cases where the angles for the state psi and the ones passed to spin_q_function are different. * We should also add a test for passing in arrays of theta and phi (i.e. were we really get out a mesh grid for Q values) since that was the primary use case for which `spin_q_function` was defined. Ideas for future PRs:. * It would be nice to also add tests for `spin_wigner` (I am suspicious of it now because of the problems with spin_q_function). Thank you for looking at these and taking charge of this bit of QuTiP.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1632#issuecomment-893326408
https://github.com/qutip/qutip/pull/1632#issuecomment-893326408:163,Testability,test,test,163,"@maij Thanks! The test code looks like a good start. Could you add it to `qutip/tests/test_wigner.py`?. Other tests we could add:. * We could write a more general test that compares the output of spin_q_function to a simpler implementation based on the definition -- something like:; ```python; state = qutip.spin_coherent(spin, theta_prime, phi_prime); direct_q = (state.dag() * qutip.ket2dm(psi) * state).norm() / np.pi; ```; Note: I named the angles `theta_prime` and `phi_prime` to emphasize that we can apply this test to cases where the angles for the state psi and the ones passed to spin_q_function are different. * We should also add a test for passing in arrays of theta and phi (i.e. were we really get out a mesh grid for Q values) since that was the primary use case for which `spin_q_function` was defined. Ideas for future PRs:. * It would be nice to also add tests for `spin_wigner` (I am suspicious of it now because of the problems with spin_q_function). Thank you for looking at these and taking charge of this bit of QuTiP.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1632#issuecomment-893326408
https://github.com/qutip/qutip/pull/1632#issuecomment-893326408:519,Testability,test,test,519,"@maij Thanks! The test code looks like a good start. Could you add it to `qutip/tests/test_wigner.py`?. Other tests we could add:. * We could write a more general test that compares the output of spin_q_function to a simpler implementation based on the definition -- something like:; ```python; state = qutip.spin_coherent(spin, theta_prime, phi_prime); direct_q = (state.dag() * qutip.ket2dm(psi) * state).norm() / np.pi; ```; Note: I named the angles `theta_prime` and `phi_prime` to emphasize that we can apply this test to cases where the angles for the state psi and the ones passed to spin_q_function are different. * We should also add a test for passing in arrays of theta and phi (i.e. were we really get out a mesh grid for Q values) since that was the primary use case for which `spin_q_function` was defined. Ideas for future PRs:. * It would be nice to also add tests for `spin_wigner` (I am suspicious of it now because of the problems with spin_q_function). Thank you for looking at these and taking charge of this bit of QuTiP.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1632#issuecomment-893326408
https://github.com/qutip/qutip/pull/1632#issuecomment-893326408:645,Testability,test,test,645,"@maij Thanks! The test code looks like a good start. Could you add it to `qutip/tests/test_wigner.py`?. Other tests we could add:. * We could write a more general test that compares the output of spin_q_function to a simpler implementation based on the definition -- something like:; ```python; state = qutip.spin_coherent(spin, theta_prime, phi_prime); direct_q = (state.dag() * qutip.ket2dm(psi) * state).norm() / np.pi; ```; Note: I named the angles `theta_prime` and `phi_prime` to emphasize that we can apply this test to cases where the angles for the state psi and the ones passed to spin_q_function are different. * We should also add a test for passing in arrays of theta and phi (i.e. were we really get out a mesh grid for Q values) since that was the primary use case for which `spin_q_function` was defined. Ideas for future PRs:. * It would be nice to also add tests for `spin_wigner` (I am suspicious of it now because of the problems with spin_q_function). Thank you for looking at these and taking charge of this bit of QuTiP.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1632#issuecomment-893326408
https://github.com/qutip/qutip/pull/1632#issuecomment-893326408:875,Testability,test,tests,875,"@maij Thanks! The test code looks like a good start. Could you add it to `qutip/tests/test_wigner.py`?. Other tests we could add:. * We could write a more general test that compares the output of spin_q_function to a simpler implementation based on the definition -- something like:; ```python; state = qutip.spin_coherent(spin, theta_prime, phi_prime); direct_q = (state.dag() * qutip.ket2dm(psi) * state).norm() / np.pi; ```; Note: I named the angles `theta_prime` and `phi_prime` to emphasize that we can apply this test to cases where the angles for the state psi and the ones passed to spin_q_function are different. * We should also add a test for passing in arrays of theta and phi (i.e. were we really get out a mesh grid for Q values) since that was the primary use case for which `spin_q_function` was defined. Ideas for future PRs:. * It would be nice to also add tests for `spin_wigner` (I am suspicious of it now because of the problems with spin_q_function). Thank you for looking at these and taking charge of this bit of QuTiP.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1632#issuecomment-893326408
https://github.com/qutip/qutip/pull/1632#issuecomment-893326408:217,Usability,simpl,simpler,217,"@maij Thanks! The test code looks like a good start. Could you add it to `qutip/tests/test_wigner.py`?. Other tests we could add:. * We could write a more general test that compares the output of spin_q_function to a simpler implementation based on the definition -- something like:; ```python; state = qutip.spin_coherent(spin, theta_prime, phi_prime); direct_q = (state.dag() * qutip.ket2dm(psi) * state).norm() / np.pi; ```; Note: I named the angles `theta_prime` and `phi_prime` to emphasize that we can apply this test to cases where the angles for the state psi and the ones passed to spin_q_function are different. * We should also add a test for passing in arrays of theta and phi (i.e. were we really get out a mesh grid for Q values) since that was the primary use case for which `spin_q_function` was defined. Ideas for future PRs:. * It would be nice to also add tests for `spin_wigner` (I am suspicious of it now because of the problems with spin_q_function). Thank you for looking at these and taking charge of this bit of QuTiP.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1632#issuecomment-893326408
https://github.com/qutip/qutip/pull/1632#issuecomment-893964617:1007,Deployability,integrat,integrate,1007,"@hodgestar I've added some tests for the spin_q_function. At the moment it tests a random density matrix for three different spin values. I'm not very familiar with qutip's style for writing tests, I would normally write a test function that would also take arguments but that doesn't seem to be the norm here. We could also do something similar to the `TestHusimiQ` class of tests. I've had a look at the `spin_wigner` function as well, and I believe that had the same issue of density matrix indexing.; I've re-implemented it (and the `_rho_kq` function) and I've added details to the docstrings including relevant references.; Should I create a separate PR for this or should I expand the scope of this PR?. NB: At the moment I can't think of an easy way to test the spin Wigner function because there is no simpler/alternative definition that I am aware of to verify the implementation against.; There are simple tests such as if the imaginary part is less than some threshold (currently true), does it integrate to 1 (currently not true, not sure why).",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1632#issuecomment-893964617
https://github.com/qutip/qutip/pull/1632#issuecomment-893964617:1007,Integrability,integrat,integrate,1007,"@hodgestar I've added some tests for the spin_q_function. At the moment it tests a random density matrix for three different spin values. I'm not very familiar with qutip's style for writing tests, I would normally write a test function that would also take arguments but that doesn't seem to be the norm here. We could also do something similar to the `TestHusimiQ` class of tests. I've had a look at the `spin_wigner` function as well, and I believe that had the same issue of density matrix indexing.; I've re-implemented it (and the `_rho_kq` function) and I've added details to the docstrings including relevant references.; Should I create a separate PR for this or should I expand the scope of this PR?. NB: At the moment I can't think of an easy way to test the spin Wigner function because there is no simpler/alternative definition that I am aware of to verify the implementation against.; There are simple tests such as if the imaginary part is less than some threshold (currently true), does it integrate to 1 (currently not true, not sure why).",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1632#issuecomment-893964617
https://github.com/qutip/qutip/pull/1632#issuecomment-893964617:27,Testability,test,tests,27,"@hodgestar I've added some tests for the spin_q_function. At the moment it tests a random density matrix for three different spin values. I'm not very familiar with qutip's style for writing tests, I would normally write a test function that would also take arguments but that doesn't seem to be the norm here. We could also do something similar to the `TestHusimiQ` class of tests. I've had a look at the `spin_wigner` function as well, and I believe that had the same issue of density matrix indexing.; I've re-implemented it (and the `_rho_kq` function) and I've added details to the docstrings including relevant references.; Should I create a separate PR for this or should I expand the scope of this PR?. NB: At the moment I can't think of an easy way to test the spin Wigner function because there is no simpler/alternative definition that I am aware of to verify the implementation against.; There are simple tests such as if the imaginary part is less than some threshold (currently true), does it integrate to 1 (currently not true, not sure why).",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1632#issuecomment-893964617
https://github.com/qutip/qutip/pull/1632#issuecomment-893964617:75,Testability,test,tests,75,"@hodgestar I've added some tests for the spin_q_function. At the moment it tests a random density matrix for three different spin values. I'm not very familiar with qutip's style for writing tests, I would normally write a test function that would also take arguments but that doesn't seem to be the norm here. We could also do something similar to the `TestHusimiQ` class of tests. I've had a look at the `spin_wigner` function as well, and I believe that had the same issue of density matrix indexing.; I've re-implemented it (and the `_rho_kq` function) and I've added details to the docstrings including relevant references.; Should I create a separate PR for this or should I expand the scope of this PR?. NB: At the moment I can't think of an easy way to test the spin Wigner function because there is no simpler/alternative definition that I am aware of to verify the implementation against.; There are simple tests such as if the imaginary part is less than some threshold (currently true), does it integrate to 1 (currently not true, not sure why).",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1632#issuecomment-893964617
https://github.com/qutip/qutip/pull/1632#issuecomment-893964617:191,Testability,test,tests,191,"@hodgestar I've added some tests for the spin_q_function. At the moment it tests a random density matrix for three different spin values. I'm not very familiar with qutip's style for writing tests, I would normally write a test function that would also take arguments but that doesn't seem to be the norm here. We could also do something similar to the `TestHusimiQ` class of tests. I've had a look at the `spin_wigner` function as well, and I believe that had the same issue of density matrix indexing.; I've re-implemented it (and the `_rho_kq` function) and I've added details to the docstrings including relevant references.; Should I create a separate PR for this or should I expand the scope of this PR?. NB: At the moment I can't think of an easy way to test the spin Wigner function because there is no simpler/alternative definition that I am aware of to verify the implementation against.; There are simple tests such as if the imaginary part is less than some threshold (currently true), does it integrate to 1 (currently not true, not sure why).",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1632#issuecomment-893964617
https://github.com/qutip/qutip/pull/1632#issuecomment-893964617:223,Testability,test,test,223,"@hodgestar I've added some tests for the spin_q_function. At the moment it tests a random density matrix for three different spin values. I'm not very familiar with qutip's style for writing tests, I would normally write a test function that would also take arguments but that doesn't seem to be the norm here. We could also do something similar to the `TestHusimiQ` class of tests. I've had a look at the `spin_wigner` function as well, and I believe that had the same issue of density matrix indexing.; I've re-implemented it (and the `_rho_kq` function) and I've added details to the docstrings including relevant references.; Should I create a separate PR for this or should I expand the scope of this PR?. NB: At the moment I can't think of an easy way to test the spin Wigner function because there is no simpler/alternative definition that I am aware of to verify the implementation against.; There are simple tests such as if the imaginary part is less than some threshold (currently true), does it integrate to 1 (currently not true, not sure why).",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1632#issuecomment-893964617
https://github.com/qutip/qutip/pull/1632#issuecomment-893964617:354,Testability,Test,TestHusimiQ,354,"@hodgestar I've added some tests for the spin_q_function. At the moment it tests a random density matrix for three different spin values. I'm not very familiar with qutip's style for writing tests, I would normally write a test function that would also take arguments but that doesn't seem to be the norm here. We could also do something similar to the `TestHusimiQ` class of tests. I've had a look at the `spin_wigner` function as well, and I believe that had the same issue of density matrix indexing.; I've re-implemented it (and the `_rho_kq` function) and I've added details to the docstrings including relevant references.; Should I create a separate PR for this or should I expand the scope of this PR?. NB: At the moment I can't think of an easy way to test the spin Wigner function because there is no simpler/alternative definition that I am aware of to verify the implementation against.; There are simple tests such as if the imaginary part is less than some threshold (currently true), does it integrate to 1 (currently not true, not sure why).",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1632#issuecomment-893964617
https://github.com/qutip/qutip/pull/1632#issuecomment-893964617:376,Testability,test,tests,376,"@hodgestar I've added some tests for the spin_q_function. At the moment it tests a random density matrix for three different spin values. I'm not very familiar with qutip's style for writing tests, I would normally write a test function that would also take arguments but that doesn't seem to be the norm here. We could also do something similar to the `TestHusimiQ` class of tests. I've had a look at the `spin_wigner` function as well, and I believe that had the same issue of density matrix indexing.; I've re-implemented it (and the `_rho_kq` function) and I've added details to the docstrings including relevant references.; Should I create a separate PR for this or should I expand the scope of this PR?. NB: At the moment I can't think of an easy way to test the spin Wigner function because there is no simpler/alternative definition that I am aware of to verify the implementation against.; There are simple tests such as if the imaginary part is less than some threshold (currently true), does it integrate to 1 (currently not true, not sure why).",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1632#issuecomment-893964617
https://github.com/qutip/qutip/pull/1632#issuecomment-893964617:761,Testability,test,test,761,"@hodgestar I've added some tests for the spin_q_function. At the moment it tests a random density matrix for three different spin values. I'm not very familiar with qutip's style for writing tests, I would normally write a test function that would also take arguments but that doesn't seem to be the norm here. We could also do something similar to the `TestHusimiQ` class of tests. I've had a look at the `spin_wigner` function as well, and I believe that had the same issue of density matrix indexing.; I've re-implemented it (and the `_rho_kq` function) and I've added details to the docstrings including relevant references.; Should I create a separate PR for this or should I expand the scope of this PR?. NB: At the moment I can't think of an easy way to test the spin Wigner function because there is no simpler/alternative definition that I am aware of to verify the implementation against.; There are simple tests such as if the imaginary part is less than some threshold (currently true), does it integrate to 1 (currently not true, not sure why).",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1632#issuecomment-893964617
https://github.com/qutip/qutip/pull/1632#issuecomment-893964617:917,Testability,test,tests,917,"@hodgestar I've added some tests for the spin_q_function. At the moment it tests a random density matrix for three different spin values. I'm not very familiar with qutip's style for writing tests, I would normally write a test function that would also take arguments but that doesn't seem to be the norm here. We could also do something similar to the `TestHusimiQ` class of tests. I've had a look at the `spin_wigner` function as well, and I believe that had the same issue of density matrix indexing.; I've re-implemented it (and the `_rho_kq` function) and I've added details to the docstrings including relevant references.; Should I create a separate PR for this or should I expand the scope of this PR?. NB: At the moment I can't think of an easy way to test the spin Wigner function because there is no simpler/alternative definition that I am aware of to verify the implementation against.; There are simple tests such as if the imaginary part is less than some threshold (currently true), does it integrate to 1 (currently not true, not sure why).",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1632#issuecomment-893964617
https://github.com/qutip/qutip/pull/1632#issuecomment-893964617:811,Usability,simpl,simpler,811,"@hodgestar I've added some tests for the spin_q_function. At the moment it tests a random density matrix for three different spin values. I'm not very familiar with qutip's style for writing tests, I would normally write a test function that would also take arguments but that doesn't seem to be the norm here. We could also do something similar to the `TestHusimiQ` class of tests. I've had a look at the `spin_wigner` function as well, and I believe that had the same issue of density matrix indexing.; I've re-implemented it (and the `_rho_kq` function) and I've added details to the docstrings including relevant references.; Should I create a separate PR for this or should I expand the scope of this PR?. NB: At the moment I can't think of an easy way to test the spin Wigner function because there is no simpler/alternative definition that I am aware of to verify the implementation against.; There are simple tests such as if the imaginary part is less than some threshold (currently true), does it integrate to 1 (currently not true, not sure why).",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1632#issuecomment-893964617
https://github.com/qutip/qutip/pull/1632#issuecomment-893964617:910,Usability,simpl,simple,910,"@hodgestar I've added some tests for the spin_q_function. At the moment it tests a random density matrix for three different spin values. I'm not very familiar with qutip's style for writing tests, I would normally write a test function that would also take arguments but that doesn't seem to be the norm here. We could also do something similar to the `TestHusimiQ` class of tests. I've had a look at the `spin_wigner` function as well, and I believe that had the same issue of density matrix indexing.; I've re-implemented it (and the `_rho_kq` function) and I've added details to the docstrings including relevant references.; Should I create a separate PR for this or should I expand the scope of this PR?. NB: At the moment I can't think of an easy way to test the spin Wigner function because there is no simpler/alternative definition that I am aware of to verify the implementation against.; There are simple tests such as if the imaginary part is less than some threshold (currently true), does it integrate to 1 (currently not true, not sure why).",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1632#issuecomment-893964617
https://github.com/qutip/qutip/pull/1632#issuecomment-894939089:184,Testability,test,test,184,@hodgestar I decided to add the `spin_wigner` changes in which I've resolved the normalization issue and indexing problems that were also in the `spin_q_function`. I've added a simple test to check for normalization and real-ness of the spin Wigner.,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1632#issuecomment-894939089
https://github.com/qutip/qutip/pull/1632#issuecomment-894939089:177,Usability,simpl,simple,177,@hodgestar I decided to add the `spin_wigner` changes in which I've resolved the normalization issue and indexing problems that were also in the `spin_q_function`. I've added a simple test to check for normalization and real-ness of the spin Wigner.,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1632#issuecomment-894939089
https://github.com/qutip/qutip/pull/1632#issuecomment-904598186:509,Deployability,integrat,integrate,509,"@maij The code is looking good to me. I've requested some changes and after that I'd like to do a final review, but I think we're in good shape. My thoughts on the remaining questions:. > Decide if the spin_wigner function should return only real values be default (as is currently done for the spin_q_function). I'm +1 on returning real values since the Wigner function is real valued and this is more consistent (unless you're aware of any strange cases where it might somehow not be?). > Decide whether to integrate the W function normalization in _rho_kq rather than at the top level. We divide all terms by (2*j + 1) only to end up multiplying it back out at the end which is a waste of time (_rho_kq is called d**2 times, d=2*j+1) . The benefit of leaving it as-is is that it reads like most definitions in literature. I'm +1 on sticking to the definitions in literature unless there is a measured speed penalty. `2*j + 1` likely can't be that big and the small number of arithmetic operations required is probably dwarfed by the matrix multiplications happening. . > Decide if normalization factor for Wigner and spin Q function should be included (Davis et al. suggest the normalization factor is only introduced during integration: Eq 14 https://arxiv.org/abs/2008.10167). Here I would try stick as closely as possible to the previous behaviour of these functions (i.e. cases which worked before should hopefully return the same answer now) and then document clearly what the normalization factor is and how it should be added or removed.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1632#issuecomment-904598186
https://github.com/qutip/qutip/pull/1632#issuecomment-904598186:1228,Deployability,integrat,integration,1228,"@maij The code is looking good to me. I've requested some changes and after that I'd like to do a final review, but I think we're in good shape. My thoughts on the remaining questions:. > Decide if the spin_wigner function should return only real values be default (as is currently done for the spin_q_function). I'm +1 on returning real values since the Wigner function is real valued and this is more consistent (unless you're aware of any strange cases where it might somehow not be?). > Decide whether to integrate the W function normalization in _rho_kq rather than at the top level. We divide all terms by (2*j + 1) only to end up multiplying it back out at the end which is a waste of time (_rho_kq is called d**2 times, d=2*j+1) . The benefit of leaving it as-is is that it reads like most definitions in literature. I'm +1 on sticking to the definitions in literature unless there is a measured speed penalty. `2*j + 1` likely can't be that big and the small number of arithmetic operations required is probably dwarfed by the matrix multiplications happening. . > Decide if normalization factor for Wigner and spin Q function should be included (Davis et al. suggest the normalization factor is only introduced during integration: Eq 14 https://arxiv.org/abs/2008.10167). Here I would try stick as closely as possible to the previous behaviour of these functions (i.e. cases which worked before should hopefully return the same answer now) and then document clearly what the normalization factor is and how it should be added or removed.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1632#issuecomment-904598186
https://github.com/qutip/qutip/pull/1632#issuecomment-904598186:509,Integrability,integrat,integrate,509,"@maij The code is looking good to me. I've requested some changes and after that I'd like to do a final review, but I think we're in good shape. My thoughts on the remaining questions:. > Decide if the spin_wigner function should return only real values be default (as is currently done for the spin_q_function). I'm +1 on returning real values since the Wigner function is real valued and this is more consistent (unless you're aware of any strange cases where it might somehow not be?). > Decide whether to integrate the W function normalization in _rho_kq rather than at the top level. We divide all terms by (2*j + 1) only to end up multiplying it back out at the end which is a waste of time (_rho_kq is called d**2 times, d=2*j+1) . The benefit of leaving it as-is is that it reads like most definitions in literature. I'm +1 on sticking to the definitions in literature unless there is a measured speed penalty. `2*j + 1` likely can't be that big and the small number of arithmetic operations required is probably dwarfed by the matrix multiplications happening. . > Decide if normalization factor for Wigner and spin Q function should be included (Davis et al. suggest the normalization factor is only introduced during integration: Eq 14 https://arxiv.org/abs/2008.10167). Here I would try stick as closely as possible to the previous behaviour of these functions (i.e. cases which worked before should hopefully return the same answer now) and then document clearly what the normalization factor is and how it should be added or removed.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1632#issuecomment-904598186
https://github.com/qutip/qutip/pull/1632#issuecomment-904598186:1228,Integrability,integrat,integration,1228,"@maij The code is looking good to me. I've requested some changes and after that I'd like to do a final review, but I think we're in good shape. My thoughts on the remaining questions:. > Decide if the spin_wigner function should return only real values be default (as is currently done for the spin_q_function). I'm +1 on returning real values since the Wigner function is real valued and this is more consistent (unless you're aware of any strange cases where it might somehow not be?). > Decide whether to integrate the W function normalization in _rho_kq rather than at the top level. We divide all terms by (2*j + 1) only to end up multiplying it back out at the end which is a waste of time (_rho_kq is called d**2 times, d=2*j+1) . The benefit of leaving it as-is is that it reads like most definitions in literature. I'm +1 on sticking to the definitions in literature unless there is a measured speed penalty. `2*j + 1` likely can't be that big and the small number of arithmetic operations required is probably dwarfed by the matrix multiplications happening. . > Decide if normalization factor for Wigner and spin Q function should be included (Davis et al. suggest the normalization factor is only introduced during integration: Eq 14 https://arxiv.org/abs/2008.10167). Here I would try stick as closely as possible to the previous behaviour of these functions (i.e. cases which worked before should hopefully return the same answer now) and then document clearly what the normalization factor is and how it should be added or removed.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1632#issuecomment-904598186
https://github.com/qutip/qutip/pull/1632#issuecomment-904598186:1468,Usability,clear,clearly,1468,"@maij The code is looking good to me. I've requested some changes and after that I'd like to do a final review, but I think we're in good shape. My thoughts on the remaining questions:. > Decide if the spin_wigner function should return only real values be default (as is currently done for the spin_q_function). I'm +1 on returning real values since the Wigner function is real valued and this is more consistent (unless you're aware of any strange cases where it might somehow not be?). > Decide whether to integrate the W function normalization in _rho_kq rather than at the top level. We divide all terms by (2*j + 1) only to end up multiplying it back out at the end which is a waste of time (_rho_kq is called d**2 times, d=2*j+1) . The benefit of leaving it as-is is that it reads like most definitions in literature. I'm +1 on sticking to the definitions in literature unless there is a measured speed penalty. `2*j + 1` likely can't be that big and the small number of arithmetic operations required is probably dwarfed by the matrix multiplications happening. . > Decide if normalization factor for Wigner and spin Q function should be included (Davis et al. suggest the normalization factor is only introduced during integration: Eq 14 https://arxiv.org/abs/2008.10167). Here I would try stick as closely as possible to the previous behaviour of these functions (i.e. cases which worked before should hopefully return the same answer now) and then document clearly what the normalization factor is and how it should be added or removed.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1632#issuecomment-904598186
https://github.com/qutip/qutip/pull/1632#issuecomment-917315644:64,Energy Efficiency,reduce,reduced,64,"@hodgestar I have implemented most of your suggested changes. I reduced the largest spin used in the spin Wigner tests, but left the spin Q function as-is because it was fast enough. I've removed the normalization from the functions themselves and described the normalization criterion in the docstrings.; The spin Wigner is now real.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1632#issuecomment-917315644
https://github.com/qutip/qutip/pull/1632#issuecomment-917315644:113,Testability,test,tests,113,"@hodgestar I have implemented most of your suggested changes. I reduced the largest spin used in the spin Wigner tests, but left the spin Q function as-is because it was fast enough. I've removed the normalization from the functions themselves and described the normalization criterion in the docstrings.; The spin Wigner is now real.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1632#issuecomment-917315644
https://github.com/qutip/qutip/pull/1633#issuecomment-894223136:213,Usability,simpl,simpler-kwfunc,213,[![Coverage Status](https://coveralls.io/builds/42999730/badge)](https://coveralls.io/builds/42999730). Coverage decreased (-0.003%) to 64.878% when pulling **f76005dba12f4e8f5840e4469aacbafb5a5ec204 on hodgestar:simpler-kwfunc** into **f8ed1be97946171ae8ba9242673cf2674430da56 on qutip:dev.major**.,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1633#issuecomment-894223136
https://github.com/qutip/qutip/pull/1633#issuecomment-894438481:575,Deployability,update,update,575,"It's very clean, I really like the `set & set` and reusing the classes. But in v4, while we used `f(t, args)` in most examples, we never said that it should be the exact signature up to variable name, so I don't think it an appropriate check for which version to use. Ideally, the check should be good enough we don't need to change any tests not directly related to the addition of this feature. Also what should; ```; def f(t, w, a=1):; return a. coeff = coefficient(f, args={'w':1}); coeff.replace_arguments(a=2)(0); ```; give? Since `a` is not given, it's not our job to update it, or should we add it to `_f_arg_names`?",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1633#issuecomment-894438481
https://github.com/qutip/qutip/pull/1633#issuecomment-894438481:186,Modifiability,variab,variable,186,"It's very clean, I really like the `set & set` and reusing the classes. But in v4, while we used `f(t, args)` in most examples, we never said that it should be the exact signature up to variable name, so I don't think it an appropriate check for which version to use. Ideally, the check should be good enough we don't need to change any tests not directly related to the addition of this feature. Also what should; ```; def f(t, w, a=1):; return a. coeff = coefficient(f, args={'w':1}); coeff.replace_arguments(a=2)(0); ```; give? Since `a` is not given, it's not our job to update it, or should we add it to `_f_arg_names`?",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1633#issuecomment-894438481
https://github.com/qutip/qutip/pull/1633#issuecomment-894438481:337,Testability,test,tests,337,"It's very clean, I really like the `set & set` and reusing the classes. But in v4, while we used `f(t, args)` in most examples, we never said that it should be the exact signature up to variable name, so I don't think it an appropriate check for which version to use. Ideally, the check should be good enough we don't need to change any tests not directly related to the addition of this feature. Also what should; ```; def f(t, w, a=1):; return a. coeff = coefficient(f, args={'w':1}); coeff.replace_arguments(a=2)(0); ```; give? Since `a` is not given, it's not our job to update it, or should we add it to `_f_arg_names`?",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1633#issuecomment-894438481
https://github.com/qutip/qutip/pull/1633#issuecomment-894670390:809,Deployability,update,update,809,"> It's very clean, I really like the `set & set` and reusing the classes. Thanks!. > But in v4, while we used `f(t, args)` in most examples, we never said that it should be the exact signature up to variable name, so I don't think it an appropriate check for which version to use. Ideally, the check should be good enough we don't need to change any tests not directly related to the addition of this feature. I'm open to modifying the check for QuTiP v4 functions, but I would like to keep the check simple. To quote the Zen of Python, ""If the implementation is hard to explain, it's a bad idea."". :). > Also what should; > ; > ```; > def f(t, w, a=1):; > return a; > ; > coeff = coefficient(f, args={'w':1}); > coeff.replace_arguments(a=2)(0); > ```; > ; > give? Since `a` is not given, it's not our job to update it, or should we add it to `_f_arg_names`?. I think this works fine already in this branch. `a` is included in `_f_arg_names`, so it can be specified via `.replace_arguments(...)` but since it has a default it can also be left out.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1633#issuecomment-894670390
https://github.com/qutip/qutip/pull/1633#issuecomment-894670390:199,Modifiability,variab,variable,199,"> It's very clean, I really like the `set & set` and reusing the classes. Thanks!. > But in v4, while we used `f(t, args)` in most examples, we never said that it should be the exact signature up to variable name, so I don't think it an appropriate check for which version to use. Ideally, the check should be good enough we don't need to change any tests not directly related to the addition of this feature. I'm open to modifying the check for QuTiP v4 functions, but I would like to keep the check simple. To quote the Zen of Python, ""If the implementation is hard to explain, it's a bad idea."". :). > Also what should; > ; > ```; > def f(t, w, a=1):; > return a; > ; > coeff = coefficient(f, args={'w':1}); > coeff.replace_arguments(a=2)(0); > ```; > ; > give? Since `a` is not given, it's not our job to update it, or should we add it to `_f_arg_names`?. I think this works fine already in this branch. `a` is included in `_f_arg_names`, so it can be specified via `.replace_arguments(...)` but since it has a default it can also be left out.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1633#issuecomment-894670390
https://github.com/qutip/qutip/pull/1633#issuecomment-894670390:350,Testability,test,tests,350,"> It's very clean, I really like the `set & set` and reusing the classes. Thanks!. > But in v4, while we used `f(t, args)` in most examples, we never said that it should be the exact signature up to variable name, so I don't think it an appropriate check for which version to use. Ideally, the check should be good enough we don't need to change any tests not directly related to the addition of this feature. I'm open to modifying the check for QuTiP v4 functions, but I would like to keep the check simple. To quote the Zen of Python, ""If the implementation is hard to explain, it's a bad idea."". :). > Also what should; > ; > ```; > def f(t, w, a=1):; > return a; > ; > coeff = coefficient(f, args={'w':1}); > coeff.replace_arguments(a=2)(0); > ```; > ; > give? Since `a` is not given, it's not our job to update it, or should we add it to `_f_arg_names`?. I think this works fine already in this branch. `a` is included in `_f_arg_names`, so it can be specified via `.replace_arguments(...)` but since it has a default it can also be left out.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1633#issuecomment-894670390
https://github.com/qutip/qutip/pull/1633#issuecomment-894670390:501,Usability,simpl,simple,501,"> It's very clean, I really like the `set & set` and reusing the classes. Thanks!. > But in v4, while we used `f(t, args)` in most examples, we never said that it should be the exact signature up to variable name, so I don't think it an appropriate check for which version to use. Ideally, the check should be good enough we don't need to change any tests not directly related to the addition of this feature. I'm open to modifying the check for QuTiP v4 functions, but I would like to keep the check simple. To quote the Zen of Python, ""If the implementation is hard to explain, it's a bad idea."". :). > Also what should; > ; > ```; > def f(t, w, a=1):; > return a; > ; > coeff = coefficient(f, args={'w':1}); > coeff.replace_arguments(a=2)(0); > ```; > ; > give? Since `a` is not given, it's not our job to update it, or should we add it to `_f_arg_names`?. I think this works fine already in this branch. `a` is included in `_f_arg_names`, so it can be specified via `.replace_arguments(...)` but since it has a default it can also be left out.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1633#issuecomment-894670390
https://github.com/qutip/qutip/pull/1633#issuecomment-904725956:272,Usability,simpl,simple,272,"@Ericgig I'm back from vacation so I'm keen to restart the discussion on this and hopefully get it merge. Any suggestions for a better way to tell whether the coefficient function expects the old-style arguments? I'm happy to do the coding, but I'd like to keep the check simple and I don't have a better idea for it right now.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1633#issuecomment-904725956
https://github.com/qutip/qutip/pull/1633#issuecomment-920950599:10,Testability,test,tests,10,I see the tests for the last commit as both passing and failing...; Could you merge dev.major to rerun the tests.,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1633#issuecomment-920950599
https://github.com/qutip/qutip/pull/1633#issuecomment-920950599:107,Testability,test,tests,107,I see the tests for the last commit as both passing and failing...; Could you merge dev.major to rerun the tests.,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1633#issuecomment-920950599
https://github.com/qutip/qutip/pull/1633#issuecomment-921738684:12,Testability,test,tests,12,> I see the tests for the last commit as both passing and failing...; > Could you merge dev.major to rerun the tests. Merged.,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1633#issuecomment-921738684
https://github.com/qutip/qutip/pull/1633#issuecomment-921738684:111,Testability,test,tests,111,> I see the tests for the last commit as both passing and failing...; > Could you merge dev.major to rerun the tests. Merged.,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1633#issuecomment-921738684
https://github.com/qutip/qutip/pull/1633#issuecomment-925011432:30,Testability,test,tests,30,Rebase done. Just waiting for tests to finish re-running.,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1633#issuecomment-925011432
https://github.com/qutip/qutip/issues/1634#issuecomment-895475026:61,Deployability,release,released,61,"This sounds like an old issue we had, around when numpy 1.20 released - we pushed a fix for that in QuTiP 4.5.3. Could you post the output of `qutip.about()` to show your Numpy and QuTiP versions?",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1634#issuecomment-895475026
https://github.com/qutip/qutip/issues/1634#issuecomment-895496158:218,Deployability,Install,Installed,218,"I have done this, giving:. QuTiP Version: 4.5.2; Numpy Version: 1.20.3; Scipy Version: 1.6.2; Cython Version: 0.29.24; Matplotlib Version: 3.3.4; Python Version: 3.7.10; Number of CPUs: 4; BLAS Info: INTEL MKL; OPENMP Installed: False; INTEL MKL Ext: True; Platform Info: Darwin (x86_64); Installation path: /Users/Nathan/opt/anaconda3/lib/python3.7/site-packages/qutip. This explains the issue you have mentioned. However, I've been unable to update qutip via conda using Terminal to a newer version, would there be any reason for this?",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1634#issuecomment-895496158
https://github.com/qutip/qutip/issues/1634#issuecomment-895496158:289,Deployability,Install,Installation,289,"I have done this, giving:. QuTiP Version: 4.5.2; Numpy Version: 1.20.3; Scipy Version: 1.6.2; Cython Version: 0.29.24; Matplotlib Version: 3.3.4; Python Version: 3.7.10; Number of CPUs: 4; BLAS Info: INTEL MKL; OPENMP Installed: False; INTEL MKL Ext: True; Platform Info: Darwin (x86_64); Installation path: /Users/Nathan/opt/anaconda3/lib/python3.7/site-packages/qutip. This explains the issue you have mentioned. However, I've been unable to update qutip via conda using Terminal to a newer version, would there be any reason for this?",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1634#issuecomment-895496158
https://github.com/qutip/qutip/issues/1634#issuecomment-895496158:444,Deployability,update,update,444,"I have done this, giving:. QuTiP Version: 4.5.2; Numpy Version: 1.20.3; Scipy Version: 1.6.2; Cython Version: 0.29.24; Matplotlib Version: 3.3.4; Python Version: 3.7.10; Number of CPUs: 4; BLAS Info: INTEL MKL; OPENMP Installed: False; INTEL MKL Ext: True; Platform Info: Darwin (x86_64); Installation path: /Users/Nathan/opt/anaconda3/lib/python3.7/site-packages/qutip. This explains the issue you have mentioned. However, I've been unable to update qutip via conda using Terminal to a newer version, would there be any reason for this?",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1634#issuecomment-895496158
https://github.com/qutip/qutip/issues/1634#issuecomment-895511734:76,Availability,down,downgrading,76,"Yeah, so this bug is fixed in QuTiP 4.5.3 and above. You can also fix it by downgrading Numpy to 1.19 or below (in 1.20 they changed how they handle object arrays, which broke us and a few other packages). That's strange that Conda won't let you upgrade beyond 4.5.2; there's no constraint on our conda package which should prevent it. Do you have any other packages installed that depend on QuTiP? If so, they might be pinning our version. What happens when you run `conda update qutip`? (By the way, you can also install `qutip` from `pip` easily since the 4.6 release).",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1634#issuecomment-895511734
https://github.com/qutip/qutip/issues/1634#issuecomment-895511734:246,Deployability,upgrade,upgrade,246,"Yeah, so this bug is fixed in QuTiP 4.5.3 and above. You can also fix it by downgrading Numpy to 1.19 or below (in 1.20 they changed how they handle object arrays, which broke us and a few other packages). That's strange that Conda won't let you upgrade beyond 4.5.2; there's no constraint on our conda package which should prevent it. Do you have any other packages installed that depend on QuTiP? If so, they might be pinning our version. What happens when you run `conda update qutip`? (By the way, you can also install `qutip` from `pip` easily since the 4.6 release).",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1634#issuecomment-895511734
https://github.com/qutip/qutip/issues/1634#issuecomment-895511734:367,Deployability,install,installed,367,"Yeah, so this bug is fixed in QuTiP 4.5.3 and above. You can also fix it by downgrading Numpy to 1.19 or below (in 1.20 they changed how they handle object arrays, which broke us and a few other packages). That's strange that Conda won't let you upgrade beyond 4.5.2; there's no constraint on our conda package which should prevent it. Do you have any other packages installed that depend on QuTiP? If so, they might be pinning our version. What happens when you run `conda update qutip`? (By the way, you can also install `qutip` from `pip` easily since the 4.6 release).",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1634#issuecomment-895511734
https://github.com/qutip/qutip/issues/1634#issuecomment-895511734:474,Deployability,update,update,474,"Yeah, so this bug is fixed in QuTiP 4.5.3 and above. You can also fix it by downgrading Numpy to 1.19 or below (in 1.20 they changed how they handle object arrays, which broke us and a few other packages). That's strange that Conda won't let you upgrade beyond 4.5.2; there's no constraint on our conda package which should prevent it. Do you have any other packages installed that depend on QuTiP? If so, they might be pinning our version. What happens when you run `conda update qutip`? (By the way, you can also install `qutip` from `pip` easily since the 4.6 release).",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1634#issuecomment-895511734
https://github.com/qutip/qutip/issues/1634#issuecomment-895511734:515,Deployability,install,install,515,"Yeah, so this bug is fixed in QuTiP 4.5.3 and above. You can also fix it by downgrading Numpy to 1.19 or below (in 1.20 they changed how they handle object arrays, which broke us and a few other packages). That's strange that Conda won't let you upgrade beyond 4.5.2; there's no constraint on our conda package which should prevent it. Do you have any other packages installed that depend on QuTiP? If so, they might be pinning our version. What happens when you run `conda update qutip`? (By the way, you can also install `qutip` from `pip` easily since the 4.6 release).",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1634#issuecomment-895511734
https://github.com/qutip/qutip/issues/1634#issuecomment-895511734:563,Deployability,release,release,563,"Yeah, so this bug is fixed in QuTiP 4.5.3 and above. You can also fix it by downgrading Numpy to 1.19 or below (in 1.20 they changed how they handle object arrays, which broke us and a few other packages). That's strange that Conda won't let you upgrade beyond 4.5.2; there's no constraint on our conda package which should prevent it. Do you have any other packages installed that depend on QuTiP? If so, they might be pinning our version. What happens when you run `conda update qutip`? (By the way, you can also install `qutip` from `pip` easily since the 4.6 release).",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1634#issuecomment-895511734
https://github.com/qutip/qutip/issues/1634#issuecomment-895511734:382,Integrability,depend,depend,382,"Yeah, so this bug is fixed in QuTiP 4.5.3 and above. You can also fix it by downgrading Numpy to 1.19 or below (in 1.20 they changed how they handle object arrays, which broke us and a few other packages). That's strange that Conda won't let you upgrade beyond 4.5.2; there's no constraint on our conda package which should prevent it. Do you have any other packages installed that depend on QuTiP? If so, they might be pinning our version. What happens when you run `conda update qutip`? (By the way, you can also install `qutip` from `pip` easily since the 4.6 release).",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1634#issuecomment-895511734
https://github.com/qutip/qutip/issues/1634#issuecomment-895792055:15,Deployability,update,update,15,"Running `conda update qutip` didn't update my installation. Then, when I tried to install a specific version using `conda install qutip=4.6.2` it gave me a very large number of conflicts. . However, I then removed my install and was able to install the current version of QuTiP using `pip` and it appears to now be working. Thank you for the help.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1634#issuecomment-895792055
https://github.com/qutip/qutip/issues/1634#issuecomment-895792055:36,Deployability,update,update,36,"Running `conda update qutip` didn't update my installation. Then, when I tried to install a specific version using `conda install qutip=4.6.2` it gave me a very large number of conflicts. . However, I then removed my install and was able to install the current version of QuTiP using `pip` and it appears to now be working. Thank you for the help.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1634#issuecomment-895792055
https://github.com/qutip/qutip/issues/1634#issuecomment-895792055:46,Deployability,install,installation,46,"Running `conda update qutip` didn't update my installation. Then, when I tried to install a specific version using `conda install qutip=4.6.2` it gave me a very large number of conflicts. . However, I then removed my install and was able to install the current version of QuTiP using `pip` and it appears to now be working. Thank you for the help.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1634#issuecomment-895792055
https://github.com/qutip/qutip/issues/1634#issuecomment-895792055:82,Deployability,install,install,82,"Running `conda update qutip` didn't update my installation. Then, when I tried to install a specific version using `conda install qutip=4.6.2` it gave me a very large number of conflicts. . However, I then removed my install and was able to install the current version of QuTiP using `pip` and it appears to now be working. Thank you for the help.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1634#issuecomment-895792055
https://github.com/qutip/qutip/issues/1634#issuecomment-895792055:122,Deployability,install,install,122,"Running `conda update qutip` didn't update my installation. Then, when I tried to install a specific version using `conda install qutip=4.6.2` it gave me a very large number of conflicts. . However, I then removed my install and was able to install the current version of QuTiP using `pip` and it appears to now be working. Thank you for the help.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1634#issuecomment-895792055
https://github.com/qutip/qutip/issues/1634#issuecomment-895792055:217,Deployability,install,install,217,"Running `conda update qutip` didn't update my installation. Then, when I tried to install a specific version using `conda install qutip=4.6.2` it gave me a very large number of conflicts. . However, I then removed my install and was able to install the current version of QuTiP using `pip` and it appears to now be working. Thank you for the help.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1634#issuecomment-895792055
https://github.com/qutip/qutip/issues/1634#issuecomment-895792055:241,Deployability,install,install,241,"Running `conda update qutip` didn't update my installation. Then, when I tried to install a specific version using `conda install qutip=4.6.2` it gave me a very large number of conflicts. . However, I then removed my install and was able to install the current version of QuTiP using `pip` and it appears to now be working. Thank you for the help.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1634#issuecomment-895792055
https://github.com/qutip/qutip/issues/1634#issuecomment-895828645:33,Deployability,install,installed,33,"You must have some other package installed that's conflicting with QuTiP somehow - our dependencies are pretty lax. We only ask for Numpy >= 1.16.6 and Scipy >= 1.0 as hard dependencies (with no upper bounds), and both of those versions are old. Good to know it's fixed now.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1634#issuecomment-895828645
https://github.com/qutip/qutip/issues/1634#issuecomment-895828645:87,Integrability,depend,dependencies,87,"You must have some other package installed that's conflicting with QuTiP somehow - our dependencies are pretty lax. We only ask for Numpy >= 1.16.6 and Scipy >= 1.0 as hard dependencies (with no upper bounds), and both of those versions are old. Good to know it's fixed now.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1634#issuecomment-895828645
https://github.com/qutip/qutip/issues/1634#issuecomment-895828645:173,Integrability,depend,dependencies,173,"You must have some other package installed that's conflicting with QuTiP somehow - our dependencies are pretty lax. We only ask for Numpy >= 1.16.6 and Scipy >= 1.0 as hard dependencies (with no upper bounds), and both of those versions are old. Good to know it's fixed now.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1634#issuecomment-895828645
https://github.com/qutip/qutip/pull/1635#issuecomment-898738261:437,Performance,perform,perform,437,"So now tests do run properly. They do not seem to fail. I did add an extra test for the case for the parameter `sparse=True`. This led me to a bug in `eigs_csr` that is now fixed. @jakelishman let me know if you are ok with this implementation. I am not very familiar with Cython so I am not sure how to handle the GIL in this case. I also find quire surprising to need the `sparse` argument in `trace_csr`. Shouldn't this function just perform a sparse computation of the trace norm (sparse always `True`?). Also, should the specialisation `traces_dense`, that currently does not exist, be mapped to the function `_trace_dense` I just wrote?",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1635#issuecomment-898738261
https://github.com/qutip/qutip/pull/1635#issuecomment-898738261:7,Testability,test,tests,7,"So now tests do run properly. They do not seem to fail. I did add an extra test for the case for the parameter `sparse=True`. This led me to a bug in `eigs_csr` that is now fixed. @jakelishman let me know if you are ok with this implementation. I am not very familiar with Cython so I am not sure how to handle the GIL in this case. I also find quire surprising to need the `sparse` argument in `trace_csr`. Shouldn't this function just perform a sparse computation of the trace norm (sparse always `True`?). Also, should the specialisation `traces_dense`, that currently does not exist, be mapped to the function `_trace_dense` I just wrote?",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1635#issuecomment-898738261
https://github.com/qutip/qutip/pull/1635#issuecomment-898738261:75,Testability,test,test,75,"So now tests do run properly. They do not seem to fail. I did add an extra test for the case for the parameter `sparse=True`. This led me to a bug in `eigs_csr` that is now fixed. @jakelishman let me know if you are ok with this implementation. I am not very familiar with Cython so I am not sure how to handle the GIL in this case. I also find quire surprising to need the `sparse` argument in `trace_csr`. Shouldn't this function just perform a sparse computation of the trace norm (sparse always `True`?). Also, should the specialisation `traces_dense`, that currently does not exist, be mapped to the function `_trace_dense` I just wrote?",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1635#issuecomment-898738261
https://github.com/qutip/qutip/pull/1635#issuecomment-898895580:17,Testability,test,test,17,Not sure why the test failed.,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1635#issuecomment-898895580
https://github.com/qutip/qutip/pull/1635#issuecomment-916904969:22,Availability,failure,failure,22,The intermittent test failure in c6d68c0 is unrelated and should be resolved by merging in dev.major.,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1635#issuecomment-916904969
https://github.com/qutip/qutip/pull/1635#issuecomment-916904969:17,Testability,test,test,17,The intermittent test failure in c6d68c0 is unrelated and should be resolved by merging in dev.major.,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1635#issuecomment-916904969
https://github.com/qutip/qutip/pull/1635#issuecomment-929280362:210,Availability,toler,tolerance,210,"I added all the suggested changes. However, now the tets for trace norm with csr matrices started failing (in particular `TestTraceNorm.test_mathematically_correct[CSR[square,sparse]->Number]`). Decreasing the tolerance to `1e-8` solves the problem but given that this was not a problem before (at least I do not remember this happening), I wonder if it is actually signaling that there is something wrong.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1635#issuecomment-929280362
https://github.com/qutip/qutip/pull/1635#issuecomment-929280362:122,Testability,Test,TestTraceNorm,122,"I added all the suggested changes. However, now the tets for trace norm with csr matrices started failing (in particular `TestTraceNorm.test_mathematically_correct[CSR[square,sparse]->Number]`). Decreasing the tolerance to `1e-8` solves the problem but given that this was not a problem before (at least I do not remember this happening), I wonder if it is actually signaling that there is something wrong.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1635#issuecomment-929280362
https://github.com/qutip/qutip/pull/1635#issuecomment-929406921:98,Availability,error,errors,98,"I don't think there is something wrong.; We can expect the matmul output and eigen values to have errors of about 1e-16, (double's precision), then it sums the square-roots, resulting in error up to ~1e-8 when the eigen values should be zeros. So with a tol at 1e-8, the test can fail from numerical error with nothing wrong in the test. If you look are the sparse eigen solver, for a 100x100 matrix with only 10 non-zero values, all along the diagonal, it does not find any` 0` eigen values: there are about 89x `~e-36`, 1x `~e-17` and the 10 non-zeros values. So the `sqrt(~e-17)` is pure numerical error and appear in the test at around 3e-9. ; I ran the test a few thousand times and it fails about 23% of the time, at `tol=3e-8`, it fails about 0.2% of the time and the max is 3.7e-8. So I expect everything is fine and you just need to loosen the tolerance.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1635#issuecomment-929406921
https://github.com/qutip/qutip/pull/1635#issuecomment-929406921:187,Availability,error,error,187,"I don't think there is something wrong.; We can expect the matmul output and eigen values to have errors of about 1e-16, (double's precision), then it sums the square-roots, resulting in error up to ~1e-8 when the eigen values should be zeros. So with a tol at 1e-8, the test can fail from numerical error with nothing wrong in the test. If you look are the sparse eigen solver, for a 100x100 matrix with only 10 non-zero values, all along the diagonal, it does not find any` 0` eigen values: there are about 89x `~e-36`, 1x `~e-17` and the 10 non-zeros values. So the `sqrt(~e-17)` is pure numerical error and appear in the test at around 3e-9. ; I ran the test a few thousand times and it fails about 23% of the time, at `tol=3e-8`, it fails about 0.2% of the time and the max is 3.7e-8. So I expect everything is fine and you just need to loosen the tolerance.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1635#issuecomment-929406921
https://github.com/qutip/qutip/pull/1635#issuecomment-929406921:300,Availability,error,error,300,"I don't think there is something wrong.; We can expect the matmul output and eigen values to have errors of about 1e-16, (double's precision), then it sums the square-roots, resulting in error up to ~1e-8 when the eigen values should be zeros. So with a tol at 1e-8, the test can fail from numerical error with nothing wrong in the test. If you look are the sparse eigen solver, for a 100x100 matrix with only 10 non-zero values, all along the diagonal, it does not find any` 0` eigen values: there are about 89x `~e-36`, 1x `~e-17` and the 10 non-zeros values. So the `sqrt(~e-17)` is pure numerical error and appear in the test at around 3e-9. ; I ran the test a few thousand times and it fails about 23% of the time, at `tol=3e-8`, it fails about 0.2% of the time and the max is 3.7e-8. So I expect everything is fine and you just need to loosen the tolerance.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1635#issuecomment-929406921
https://github.com/qutip/qutip/pull/1635#issuecomment-929406921:601,Availability,error,error,601,"I don't think there is something wrong.; We can expect the matmul output and eigen values to have errors of about 1e-16, (double's precision), then it sums the square-roots, resulting in error up to ~1e-8 when the eigen values should be zeros. So with a tol at 1e-8, the test can fail from numerical error with nothing wrong in the test. If you look are the sparse eigen solver, for a 100x100 matrix with only 10 non-zero values, all along the diagonal, it does not find any` 0` eigen values: there are about 89x `~e-36`, 1x `~e-17` and the 10 non-zeros values. So the `sqrt(~e-17)` is pure numerical error and appear in the test at around 3e-9. ; I ran the test a few thousand times and it fails about 23% of the time, at `tol=3e-8`, it fails about 0.2% of the time and the max is 3.7e-8. So I expect everything is fine and you just need to loosen the tolerance.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1635#issuecomment-929406921
https://github.com/qutip/qutip/pull/1635#issuecomment-929406921:853,Availability,toler,tolerance,853,"I don't think there is something wrong.; We can expect the matmul output and eigen values to have errors of about 1e-16, (double's precision), then it sums the square-roots, resulting in error up to ~1e-8 when the eigen values should be zeros. So with a tol at 1e-8, the test can fail from numerical error with nothing wrong in the test. If you look are the sparse eigen solver, for a 100x100 matrix with only 10 non-zero values, all along the diagonal, it does not find any` 0` eigen values: there are about 89x `~e-36`, 1x `~e-17` and the 10 non-zeros values. So the `sqrt(~e-17)` is pure numerical error and appear in the test at around 3e-9. ; I ran the test a few thousand times and it fails about 23% of the time, at `tol=3e-8`, it fails about 0.2% of the time and the max is 3.7e-8. So I expect everything is fine and you just need to loosen the tolerance.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1635#issuecomment-929406921
https://github.com/qutip/qutip/pull/1635#issuecomment-929406921:271,Testability,test,test,271,"I don't think there is something wrong.; We can expect the matmul output and eigen values to have errors of about 1e-16, (double's precision), then it sums the square-roots, resulting in error up to ~1e-8 when the eigen values should be zeros. So with a tol at 1e-8, the test can fail from numerical error with nothing wrong in the test. If you look are the sparse eigen solver, for a 100x100 matrix with only 10 non-zero values, all along the diagonal, it does not find any` 0` eigen values: there are about 89x `~e-36`, 1x `~e-17` and the 10 non-zeros values. So the `sqrt(~e-17)` is pure numerical error and appear in the test at around 3e-9. ; I ran the test a few thousand times and it fails about 23% of the time, at `tol=3e-8`, it fails about 0.2% of the time and the max is 3.7e-8. So I expect everything is fine and you just need to loosen the tolerance.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1635#issuecomment-929406921
https://github.com/qutip/qutip/pull/1635#issuecomment-929406921:332,Testability,test,test,332,"I don't think there is something wrong.; We can expect the matmul output and eigen values to have errors of about 1e-16, (double's precision), then it sums the square-roots, resulting in error up to ~1e-8 when the eigen values should be zeros. So with a tol at 1e-8, the test can fail from numerical error with nothing wrong in the test. If you look are the sparse eigen solver, for a 100x100 matrix with only 10 non-zero values, all along the diagonal, it does not find any` 0` eigen values: there are about 89x `~e-36`, 1x `~e-17` and the 10 non-zeros values. So the `sqrt(~e-17)` is pure numerical error and appear in the test at around 3e-9. ; I ran the test a few thousand times and it fails about 23% of the time, at `tol=3e-8`, it fails about 0.2% of the time and the max is 3.7e-8. So I expect everything is fine and you just need to loosen the tolerance.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1635#issuecomment-929406921
https://github.com/qutip/qutip/pull/1635#issuecomment-929406921:625,Testability,test,test,625,"I don't think there is something wrong.; We can expect the matmul output and eigen values to have errors of about 1e-16, (double's precision), then it sums the square-roots, resulting in error up to ~1e-8 when the eigen values should be zeros. So with a tol at 1e-8, the test can fail from numerical error with nothing wrong in the test. If you look are the sparse eigen solver, for a 100x100 matrix with only 10 non-zero values, all along the diagonal, it does not find any` 0` eigen values: there are about 89x `~e-36`, 1x `~e-17` and the 10 non-zeros values. So the `sqrt(~e-17)` is pure numerical error and appear in the test at around 3e-9. ; I ran the test a few thousand times and it fails about 23% of the time, at `tol=3e-8`, it fails about 0.2% of the time and the max is 3.7e-8. So I expect everything is fine and you just need to loosen the tolerance.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1635#issuecomment-929406921
https://github.com/qutip/qutip/pull/1635#issuecomment-929406921:658,Testability,test,test,658,"I don't think there is something wrong.; We can expect the matmul output and eigen values to have errors of about 1e-16, (double's precision), then it sums the square-roots, resulting in error up to ~1e-8 when the eigen values should be zeros. So with a tol at 1e-8, the test can fail from numerical error with nothing wrong in the test. If you look are the sparse eigen solver, for a 100x100 matrix with only 10 non-zero values, all along the diagonal, it does not find any` 0` eigen values: there are about 89x `~e-36`, 1x `~e-17` and the 10 non-zeros values. So the `sqrt(~e-17)` is pure numerical error and appear in the test at around 3e-9. ; I ran the test a few thousand times and it fails about 23% of the time, at `tol=3e-8`, it fails about 0.2% of the time and the max is 3.7e-8. So I expect everything is fine and you just need to loosen the tolerance.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1635#issuecomment-929406921
https://github.com/qutip/qutip/pull/1635#issuecomment-930224872:140,Testability,test,tests,140,"Makes sense, thank your for the explanation Eric! While trying to set a sensible value for `tol` I got the problem that 3% of the times the tests fail independently of the `tol` value. This is because the numpy function returns `nan` whereas `trace_csr` does not. To replicate the problem I used the following code:; ```python; import qutip; import scipy; import numpy as np; from qutip.tests.core.data import conftest. # Catch one of those matrices that return nan in the nuclear norm; for i in range(100):; matrix_csr = conftest.random_csr((100,100), 0.001, True); matrix = matrix_csr.to_array() ; result = np.linalg.norm(matrix, 'nuc'). # If it is nan store the matrix for analysis.; if np.isnan(result):; print('got one of those tricky matrices'); nan_matrix = matrix ; nan_matrix_csr = matrix_csr; ; # Scipy's and numpys methods return nan; sc_norm = scipy.linalg.norm(nan_matrix, 'nuc'); print(f'SciPy linalgn nuc norm: {sc_norm}'). np_norm = np.linalg.norm(nan_matrix, 'nuc'); print(f'NumPy linalgn nuc norm: {np_norm}'). # Using svd wich is similar to what numpy/scipy should be doing; u, s, vh = np.linalg.svd(nan_matrix); print(f'SVD method: {s.sum()}'). # Qutip sparse method; print(f'QuTiP trace_csr:{qutip.data.norm.trace_csr(nan_matrix_csr)}'). # This prints; # SciPy linalgn nuc norm: nan; # NumPy linalgn nuc norm: nan; # SVD method: 6.456744360029763; # QuTiP trace_csr:6.456744366739419; ```. As you can see in the above code, it fails to compute a value for NumPy/SciPy but not for a direct method (SVD) or the QuTiP method (which is different to the SVD method but still works). @Ericgig, do you get the same results? They look quite weird and I wonder if I am doing something wrong or whether this is a NumPy/SciPy bug. ```; np.__version__='1.21.2'; qutip.__version__='5.0.0.dev0+7a90dbd'; scipy.__version__='1.7.0'; ```",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1635#issuecomment-930224872
https://github.com/qutip/qutip/pull/1635#issuecomment-930224872:387,Testability,test,tests,387,"Makes sense, thank your for the explanation Eric! While trying to set a sensible value for `tol` I got the problem that 3% of the times the tests fail independently of the `tol` value. This is because the numpy function returns `nan` whereas `trace_csr` does not. To replicate the problem I used the following code:; ```python; import qutip; import scipy; import numpy as np; from qutip.tests.core.data import conftest. # Catch one of those matrices that return nan in the nuclear norm; for i in range(100):; matrix_csr = conftest.random_csr((100,100), 0.001, True); matrix = matrix_csr.to_array() ; result = np.linalg.norm(matrix, 'nuc'). # If it is nan store the matrix for analysis.; if np.isnan(result):; print('got one of those tricky matrices'); nan_matrix = matrix ; nan_matrix_csr = matrix_csr; ; # Scipy's and numpys methods return nan; sc_norm = scipy.linalg.norm(nan_matrix, 'nuc'); print(f'SciPy linalgn nuc norm: {sc_norm}'). np_norm = np.linalg.norm(nan_matrix, 'nuc'); print(f'NumPy linalgn nuc norm: {np_norm}'). # Using svd wich is similar to what numpy/scipy should be doing; u, s, vh = np.linalg.svd(nan_matrix); print(f'SVD method: {s.sum()}'). # Qutip sparse method; print(f'QuTiP trace_csr:{qutip.data.norm.trace_csr(nan_matrix_csr)}'). # This prints; # SciPy linalgn nuc norm: nan; # NumPy linalgn nuc norm: nan; # SVD method: 6.456744360029763; # QuTiP trace_csr:6.456744366739419; ```. As you can see in the above code, it fails to compute a value for NumPy/SciPy but not for a direct method (SVD) or the QuTiP method (which is different to the SVD method but still works). @Ericgig, do you get the same results? They look quite weird and I wonder if I am doing something wrong or whether this is a NumPy/SciPy bug. ```; np.__version__='1.21.2'; qutip.__version__='5.0.0.dev0+7a90dbd'; scipy.__version__='1.7.0'; ```",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1635#issuecomment-930224872
https://github.com/qutip/qutip/pull/1635#issuecomment-930347069:1704,Availability,error,error,1704,"I see the `Nan`'s...; Scipy's `norm` call numpy's `norm` which call `svd` with `compute_uv=False` and it return junk...:. ```; np.linalg.svd(nan_matrix, compute_uv=False); array([ inf, inf, 1.07311390e+000, 9.83440402e-001,; 9.42395122e-001, 9.27989857e-001, 8.23177182e-001, 2.38050872e-022,; 6.40149943e-032, 5.64518572e-033, 9.14729223e-045, 2.72704923e-049,; 1.56401558e-063, 4.83650926e-068, 6.39334574e-081, 2.83836536e-092,; 8.27175428e-096, 1.73661126e-097, 2.01091260e-114, 1.30856687e-123,; 2.06455678e-127, 4.92744107e-155, 5.08952541e-159, 1.74118770e-186,; 9.44136765e-227, 6.23313780e-246, 0.00000000e+000, 0.00000000e+000,; 0.00000000e+000, 0.00000000e+000, 0.00000000e+000, 0.00000000e+000,; 0.00000000e+000, 0.00000000e+000, 0.00000000e+000, 0.00000000e+000,; 0.00000000e+000, 0.00000000e+000, 0.00000000e+000, 0.00000000e+000,; 0.00000000e+000, 0.00000000e+000, 0.00000000e+000, 0.00000000e+000,; 0.00000000e+000, 0.00000000e+000, 0.00000000e+000, 0.00000000e+000,; 0.00000000e+000, 0.00000000e+000, 0.00000000e+000, 0.00000000e+000,; 0.00000000e+000, 0.00000000e+000, 0.00000000e+000, 0.00000000e+000,; 0.00000000e+000, 0.00000000e+000, 0.00000000e+000, 0.00000000e+000,; 0.00000000e+000, 0.00000000e+000, 0.00000000e+000, 0.00000000e+000,; 0.00000000e+000, 0.00000000e+000, 0.00000000e+000, nan,; nan, nan, nan, nan,; nan, nan, nan, nan,; nan, nan, nan, nan,; nan, nan, nan, nan,; nan, nan, nan, nan,; nan, nan, nan, nan,; nan, nan, nan, nan,; nan, nan, nan, 0.00000000e+000]); ```. Put with `compute_uv=True` (default) it work fine... I guess the best we can do is report to numpy... Do you want to do it?. Not computing the `uv` is 10x faster in case everything goes well and these error seem rare, so for now I would use a fall back:; ```; norm = np.linalg.norm(matrix, 'nuc'); if np.isnan(norm):; # Bug in `numpy svd(..., compute_uv=False)` used by `norm(..., 'nuc')`; norm = np.linalg.svd(nan_matrix)[1].sum(); return norm; ```",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1635#issuecomment-930347069
https://github.com/qutip/qutip/pull/1635#issuecomment-932032620:72,Testability,test,tests,72,"It seems that they already know about this bug numpy/numpy#19473. . The tests runs smoothly now so it should be ready to merge. @hodgestar, is there any change missing?",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1635#issuecomment-932032620
https://github.com/qutip/qutip/pull/1636#issuecomment-929639158:51,Safety,avoid,avoid,51,I will add tests. I changed the status to draft to avoid merging.,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1636#issuecomment-929639158
https://github.com/qutip/qutip/pull/1636#issuecomment-929639158:11,Testability,test,tests,11,I will add tests. I changed the status to draft to avoid merging.,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1636#issuecomment-929639158
https://github.com/qutip/qutip/pull/1636#issuecomment-939918060:15,Testability,test,test,15,@hodgestar The test is now included. It turned out to be quite simple with monkeypatch. Thanks for the suggestion!,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1636#issuecomment-939918060
https://github.com/qutip/qutip/pull/1636#issuecomment-939918060:63,Usability,simpl,simple,63,@hodgestar The test is now included. It turned out to be quite simple with monkeypatch. Thanks for the suggestion!,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1636#issuecomment-939918060
https://github.com/qutip/qutip/pull/1636#issuecomment-940959780:57,Deployability,install,installation,57,"@hodgestar, one of the tests seems to have failed at the installation step, although not idea why. Nevertheless, I think it is not related to the changes in this PR. Could you rerun the test?",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1636#issuecomment-940959780
https://github.com/qutip/qutip/pull/1636#issuecomment-940959780:23,Testability,test,tests,23,"@hodgestar, one of the tests seems to have failed at the installation step, although not idea why. Nevertheless, I think it is not related to the changes in this PR. Could you rerun the test?",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1636#issuecomment-940959780
https://github.com/qutip/qutip/pull/1636#issuecomment-940959780:186,Testability,test,test,186,"@hodgestar, one of the tests seems to have failed at the installation step, although not idea why. Nevertheless, I think it is not related to the changes in this PR. Could you rerun the test?",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1636#issuecomment-940959780
https://github.com/qutip/qutip/pull/1637#issuecomment-899083258:0,Testability,Test,Test,0,Test fails do not seem to be related to changes. Could they be rerun?,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1637#issuecomment-899083258
https://github.com/qutip/qutip/issues/1639#issuecomment-908476483:20,Testability,test,tests,20,"@drew-parsons These tests pass in CI and `pytest qutip/tests/test_processor.py -v` passes for me locally on the master branch, so I'm not quite sure how to reproduce.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1639#issuecomment-908476483
https://github.com/qutip/qutip/issues/1639#issuecomment-908476483:55,Testability,test,tests,55,"@drew-parsons These tests pass in CI and `pytest qutip/tests/test_processor.py -v` passes for me locally on the master branch, so I'm not quite sure how to reproduce.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1639#issuecomment-908476483
https://github.com/qutip/qutip/issues/1639#issuecomment-908478147:35,Testability,test,tests,35,"@drew-parsons We don't usually run tests with `pytest-xvfb`, so perhaps that triggers the issue somehow?",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1639#issuecomment-908478147
https://github.com/qutip/qutip/issues/1639#issuecomment-908496458:135,Availability,error,error,135,Sounds like it is xvfb that is interfering with the test environment. I guess if you install it you'll likely be able to reproduce the error.,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1639#issuecomment-908496458
https://github.com/qutip/qutip/issues/1639#issuecomment-908496458:85,Deployability,install,install,85,Sounds like it is xvfb that is interfering with the test environment. I guess if you install it you'll likely be able to reproduce the error.,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1639#issuecomment-908496458
https://github.com/qutip/qutip/issues/1639#issuecomment-908496458:52,Testability,test,test,52,Sounds like it is xvfb that is interfering with the test environment. I guess if you install it you'll likely be able to reproduce the error.,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1639#issuecomment-908496458
https://github.com/qutip/qutip/issues/1639#issuecomment-909005031:71,Testability,test,tests,71,@drew-parsons Is there a goal you are trying to achieve by running the tests headless on xvfb? Just curious about your use case.,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1639#issuecomment-909005031
https://github.com/qutip/qutip/issues/1639#issuecomment-909115791:895,Availability,avail,available,895,"I don't have xvfb (pytest-xvfb) installed specifically for qutip, but it is used by other packages (The general use of pytest-xvfb is to facilitate testing of GUI, graphical or windowing functionality without having an normal Xserver active. That is, it can be useful for automated CI testing of gui packages, for instance in chroots or cloud CI infrastructure). Since qutip doesn't use xvfb directly this bug won't be a problem for general CI testing, where only qutip is loaded on a cloud instance (for instance Debian testing done at https://ci.debian.net/packages/q/qutip/). But before I upload a package to the Debian infrastructure, I like to run the tests on my own system to be confident they're likely to pass. So this is where the problem happens, running tests on my own system, where I have pytest-xvfb installed for testing other packages. (pytest has this bad habit of loading all available plugins whether or not they're actually used by the tests being run. It's quite annoying actually. It would be better if it only loaded plugins specified in conftest.py). So the use case is running the qutip tests on my own system, where pytest-xvfb simply happens to be installed for other purposes not related to qutip. There are ways of working around the problem, for instance the `--no-xvfb` option could be explicitly added to the `pytest` command line. But it can be useful if the test code itself can be made robust with respect to the problem (e.g. in this case just replacing `plt.clf()` with `plt.close('all')`)",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1639#issuecomment-909115791
https://github.com/qutip/qutip/issues/1639#issuecomment-909115791:1422,Availability,robust,robust,1422,"I don't have xvfb (pytest-xvfb) installed specifically for qutip, but it is used by other packages (The general use of pytest-xvfb is to facilitate testing of GUI, graphical or windowing functionality without having an normal Xserver active. That is, it can be useful for automated CI testing of gui packages, for instance in chroots or cloud CI infrastructure). Since qutip doesn't use xvfb directly this bug won't be a problem for general CI testing, where only qutip is loaded on a cloud instance (for instance Debian testing done at https://ci.debian.net/packages/q/qutip/). But before I upload a package to the Debian infrastructure, I like to run the tests on my own system to be confident they're likely to pass. So this is where the problem happens, running tests on my own system, where I have pytest-xvfb installed for testing other packages. (pytest has this bad habit of loading all available plugins whether or not they're actually used by the tests being run. It's quite annoying actually. It would be better if it only loaded plugins specified in conftest.py). So the use case is running the qutip tests on my own system, where pytest-xvfb simply happens to be installed for other purposes not related to qutip. There are ways of working around the problem, for instance the `--no-xvfb` option could be explicitly added to the `pytest` command line. But it can be useful if the test code itself can be made robust with respect to the problem (e.g. in this case just replacing `plt.clf()` with `plt.close('all')`)",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1639#issuecomment-909115791
https://github.com/qutip/qutip/issues/1639#issuecomment-909115791:32,Deployability,install,installed,32,"I don't have xvfb (pytest-xvfb) installed specifically for qutip, but it is used by other packages (The general use of pytest-xvfb is to facilitate testing of GUI, graphical or windowing functionality without having an normal Xserver active. That is, it can be useful for automated CI testing of gui packages, for instance in chroots or cloud CI infrastructure). Since qutip doesn't use xvfb directly this bug won't be a problem for general CI testing, where only qutip is loaded on a cloud instance (for instance Debian testing done at https://ci.debian.net/packages/q/qutip/). But before I upload a package to the Debian infrastructure, I like to run the tests on my own system to be confident they're likely to pass. So this is where the problem happens, running tests on my own system, where I have pytest-xvfb installed for testing other packages. (pytest has this bad habit of loading all available plugins whether or not they're actually used by the tests being run. It's quite annoying actually. It would be better if it only loaded plugins specified in conftest.py). So the use case is running the qutip tests on my own system, where pytest-xvfb simply happens to be installed for other purposes not related to qutip. There are ways of working around the problem, for instance the `--no-xvfb` option could be explicitly added to the `pytest` command line. But it can be useful if the test code itself can be made robust with respect to the problem (e.g. in this case just replacing `plt.clf()` with `plt.close('all')`)",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1639#issuecomment-909115791
https://github.com/qutip/qutip/issues/1639#issuecomment-909115791:815,Deployability,install,installed,815,"I don't have xvfb (pytest-xvfb) installed specifically for qutip, but it is used by other packages (The general use of pytest-xvfb is to facilitate testing of GUI, graphical or windowing functionality without having an normal Xserver active. That is, it can be useful for automated CI testing of gui packages, for instance in chroots or cloud CI infrastructure). Since qutip doesn't use xvfb directly this bug won't be a problem for general CI testing, where only qutip is loaded on a cloud instance (for instance Debian testing done at https://ci.debian.net/packages/q/qutip/). But before I upload a package to the Debian infrastructure, I like to run the tests on my own system to be confident they're likely to pass. So this is where the problem happens, running tests on my own system, where I have pytest-xvfb installed for testing other packages. (pytest has this bad habit of loading all available plugins whether or not they're actually used by the tests being run. It's quite annoying actually. It would be better if it only loaded plugins specified in conftest.py). So the use case is running the qutip tests on my own system, where pytest-xvfb simply happens to be installed for other purposes not related to qutip. There are ways of working around the problem, for instance the `--no-xvfb` option could be explicitly added to the `pytest` command line. But it can be useful if the test code itself can be made robust with respect to the problem (e.g. in this case just replacing `plt.clf()` with `plt.close('all')`)",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1639#issuecomment-909115791
https://github.com/qutip/qutip/issues/1639#issuecomment-909115791:1176,Deployability,install,installed,1176,"I don't have xvfb (pytest-xvfb) installed specifically for qutip, but it is used by other packages (The general use of pytest-xvfb is to facilitate testing of GUI, graphical or windowing functionality without having an normal Xserver active. That is, it can be useful for automated CI testing of gui packages, for instance in chroots or cloud CI infrastructure). Since qutip doesn't use xvfb directly this bug won't be a problem for general CI testing, where only qutip is loaded on a cloud instance (for instance Debian testing done at https://ci.debian.net/packages/q/qutip/). But before I upload a package to the Debian infrastructure, I like to run the tests on my own system to be confident they're likely to pass. So this is where the problem happens, running tests on my own system, where I have pytest-xvfb installed for testing other packages. (pytest has this bad habit of loading all available plugins whether or not they're actually used by the tests being run. It's quite annoying actually. It would be better if it only loaded plugins specified in conftest.py). So the use case is running the qutip tests on my own system, where pytest-xvfb simply happens to be installed for other purposes not related to qutip. There are ways of working around the problem, for instance the `--no-xvfb` option could be explicitly added to the `pytest` command line. But it can be useful if the test code itself can be made robust with respect to the problem (e.g. in this case just replacing `plt.clf()` with `plt.close('all')`)",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1639#issuecomment-909115791
https://github.com/qutip/qutip/issues/1639#issuecomment-909115791:905,Modifiability,plugin,plugins,905,"I don't have xvfb (pytest-xvfb) installed specifically for qutip, but it is used by other packages (The general use of pytest-xvfb is to facilitate testing of GUI, graphical or windowing functionality without having an normal Xserver active. That is, it can be useful for automated CI testing of gui packages, for instance in chroots or cloud CI infrastructure). Since qutip doesn't use xvfb directly this bug won't be a problem for general CI testing, where only qutip is loaded on a cloud instance (for instance Debian testing done at https://ci.debian.net/packages/q/qutip/). But before I upload a package to the Debian infrastructure, I like to run the tests on my own system to be confident they're likely to pass. So this is where the problem happens, running tests on my own system, where I have pytest-xvfb installed for testing other packages. (pytest has this bad habit of loading all available plugins whether or not they're actually used by the tests being run. It's quite annoying actually. It would be better if it only loaded plugins specified in conftest.py). So the use case is running the qutip tests on my own system, where pytest-xvfb simply happens to be installed for other purposes not related to qutip. There are ways of working around the problem, for instance the `--no-xvfb` option could be explicitly added to the `pytest` command line. But it can be useful if the test code itself can be made robust with respect to the problem (e.g. in this case just replacing `plt.clf()` with `plt.close('all')`)",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1639#issuecomment-909115791
https://github.com/qutip/qutip/issues/1639#issuecomment-909115791:1041,Modifiability,plugin,plugins,1041,"I don't have xvfb (pytest-xvfb) installed specifically for qutip, but it is used by other packages (The general use of pytest-xvfb is to facilitate testing of GUI, graphical or windowing functionality without having an normal Xserver active. That is, it can be useful for automated CI testing of gui packages, for instance in chroots or cloud CI infrastructure). Since qutip doesn't use xvfb directly this bug won't be a problem for general CI testing, where only qutip is loaded on a cloud instance (for instance Debian testing done at https://ci.debian.net/packages/q/qutip/). But before I upload a package to the Debian infrastructure, I like to run the tests on my own system to be confident they're likely to pass. So this is where the problem happens, running tests on my own system, where I have pytest-xvfb installed for testing other packages. (pytest has this bad habit of loading all available plugins whether or not they're actually used by the tests being run. It's quite annoying actually. It would be better if it only loaded plugins specified in conftest.py). So the use case is running the qutip tests on my own system, where pytest-xvfb simply happens to be installed for other purposes not related to qutip. There are ways of working around the problem, for instance the `--no-xvfb` option could be explicitly added to the `pytest` command line. But it can be useful if the test code itself can be made robust with respect to the problem (e.g. in this case just replacing `plt.clf()` with `plt.close('all')`)",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1639#issuecomment-909115791
https://github.com/qutip/qutip/issues/1639#issuecomment-909115791:473,Performance,load,loaded,473,"I don't have xvfb (pytest-xvfb) installed specifically for qutip, but it is used by other packages (The general use of pytest-xvfb is to facilitate testing of GUI, graphical or windowing functionality without having an normal Xserver active. That is, it can be useful for automated CI testing of gui packages, for instance in chroots or cloud CI infrastructure). Since qutip doesn't use xvfb directly this bug won't be a problem for general CI testing, where only qutip is loaded on a cloud instance (for instance Debian testing done at https://ci.debian.net/packages/q/qutip/). But before I upload a package to the Debian infrastructure, I like to run the tests on my own system to be confident they're likely to pass. So this is where the problem happens, running tests on my own system, where I have pytest-xvfb installed for testing other packages. (pytest has this bad habit of loading all available plugins whether or not they're actually used by the tests being run. It's quite annoying actually. It would be better if it only loaded plugins specified in conftest.py). So the use case is running the qutip tests on my own system, where pytest-xvfb simply happens to be installed for other purposes not related to qutip. There are ways of working around the problem, for instance the `--no-xvfb` option could be explicitly added to the `pytest` command line. But it can be useful if the test code itself can be made robust with respect to the problem (e.g. in this case just replacing `plt.clf()` with `plt.close('all')`)",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1639#issuecomment-909115791
https://github.com/qutip/qutip/issues/1639#issuecomment-909115791:883,Performance,load,loading,883,"I don't have xvfb (pytest-xvfb) installed specifically for qutip, but it is used by other packages (The general use of pytest-xvfb is to facilitate testing of GUI, graphical or windowing functionality without having an normal Xserver active. That is, it can be useful for automated CI testing of gui packages, for instance in chroots or cloud CI infrastructure). Since qutip doesn't use xvfb directly this bug won't be a problem for general CI testing, where only qutip is loaded on a cloud instance (for instance Debian testing done at https://ci.debian.net/packages/q/qutip/). But before I upload a package to the Debian infrastructure, I like to run the tests on my own system to be confident they're likely to pass. So this is where the problem happens, running tests on my own system, where I have pytest-xvfb installed for testing other packages. (pytest has this bad habit of loading all available plugins whether or not they're actually used by the tests being run. It's quite annoying actually. It would be better if it only loaded plugins specified in conftest.py). So the use case is running the qutip tests on my own system, where pytest-xvfb simply happens to be installed for other purposes not related to qutip. There are ways of working around the problem, for instance the `--no-xvfb` option could be explicitly added to the `pytest` command line. But it can be useful if the test code itself can be made robust with respect to the problem (e.g. in this case just replacing `plt.clf()` with `plt.close('all')`)",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1639#issuecomment-909115791
https://github.com/qutip/qutip/issues/1639#issuecomment-909115791:1034,Performance,load,loaded,1034,"I don't have xvfb (pytest-xvfb) installed specifically for qutip, but it is used by other packages (The general use of pytest-xvfb is to facilitate testing of GUI, graphical or windowing functionality without having an normal Xserver active. That is, it can be useful for automated CI testing of gui packages, for instance in chroots or cloud CI infrastructure). Since qutip doesn't use xvfb directly this bug won't be a problem for general CI testing, where only qutip is loaded on a cloud instance (for instance Debian testing done at https://ci.debian.net/packages/q/qutip/). But before I upload a package to the Debian infrastructure, I like to run the tests on my own system to be confident they're likely to pass. So this is where the problem happens, running tests on my own system, where I have pytest-xvfb installed for testing other packages. (pytest has this bad habit of loading all available plugins whether or not they're actually used by the tests being run. It's quite annoying actually. It would be better if it only loaded plugins specified in conftest.py). So the use case is running the qutip tests on my own system, where pytest-xvfb simply happens to be installed for other purposes not related to qutip. There are ways of working around the problem, for instance the `--no-xvfb` option could be explicitly added to the `pytest` command line. But it can be useful if the test code itself can be made robust with respect to the problem (e.g. in this case just replacing `plt.clf()` with `plt.close('all')`)",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1639#issuecomment-909115791
https://github.com/qutip/qutip/issues/1639#issuecomment-909115791:148,Testability,test,testing,148,"I don't have xvfb (pytest-xvfb) installed specifically for qutip, but it is used by other packages (The general use of pytest-xvfb is to facilitate testing of GUI, graphical or windowing functionality without having an normal Xserver active. That is, it can be useful for automated CI testing of gui packages, for instance in chroots or cloud CI infrastructure). Since qutip doesn't use xvfb directly this bug won't be a problem for general CI testing, where only qutip is loaded on a cloud instance (for instance Debian testing done at https://ci.debian.net/packages/q/qutip/). But before I upload a package to the Debian infrastructure, I like to run the tests on my own system to be confident they're likely to pass. So this is where the problem happens, running tests on my own system, where I have pytest-xvfb installed for testing other packages. (pytest has this bad habit of loading all available plugins whether or not they're actually used by the tests being run. It's quite annoying actually. It would be better if it only loaded plugins specified in conftest.py). So the use case is running the qutip tests on my own system, where pytest-xvfb simply happens to be installed for other purposes not related to qutip. There are ways of working around the problem, for instance the `--no-xvfb` option could be explicitly added to the `pytest` command line. But it can be useful if the test code itself can be made robust with respect to the problem (e.g. in this case just replacing `plt.clf()` with `plt.close('all')`)",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1639#issuecomment-909115791
https://github.com/qutip/qutip/issues/1639#issuecomment-909115791:285,Testability,test,testing,285,"I don't have xvfb (pytest-xvfb) installed specifically for qutip, but it is used by other packages (The general use of pytest-xvfb is to facilitate testing of GUI, graphical or windowing functionality without having an normal Xserver active. That is, it can be useful for automated CI testing of gui packages, for instance in chroots or cloud CI infrastructure). Since qutip doesn't use xvfb directly this bug won't be a problem for general CI testing, where only qutip is loaded on a cloud instance (for instance Debian testing done at https://ci.debian.net/packages/q/qutip/). But before I upload a package to the Debian infrastructure, I like to run the tests on my own system to be confident they're likely to pass. So this is where the problem happens, running tests on my own system, where I have pytest-xvfb installed for testing other packages. (pytest has this bad habit of loading all available plugins whether or not they're actually used by the tests being run. It's quite annoying actually. It would be better if it only loaded plugins specified in conftest.py). So the use case is running the qutip tests on my own system, where pytest-xvfb simply happens to be installed for other purposes not related to qutip. There are ways of working around the problem, for instance the `--no-xvfb` option could be explicitly added to the `pytest` command line. But it can be useful if the test code itself can be made robust with respect to the problem (e.g. in this case just replacing `plt.clf()` with `plt.close('all')`)",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1639#issuecomment-909115791
https://github.com/qutip/qutip/issues/1639#issuecomment-909115791:444,Testability,test,testing,444,"I don't have xvfb (pytest-xvfb) installed specifically for qutip, but it is used by other packages (The general use of pytest-xvfb is to facilitate testing of GUI, graphical or windowing functionality without having an normal Xserver active. That is, it can be useful for automated CI testing of gui packages, for instance in chroots or cloud CI infrastructure). Since qutip doesn't use xvfb directly this bug won't be a problem for general CI testing, where only qutip is loaded on a cloud instance (for instance Debian testing done at https://ci.debian.net/packages/q/qutip/). But before I upload a package to the Debian infrastructure, I like to run the tests on my own system to be confident they're likely to pass. So this is where the problem happens, running tests on my own system, where I have pytest-xvfb installed for testing other packages. (pytest has this bad habit of loading all available plugins whether or not they're actually used by the tests being run. It's quite annoying actually. It would be better if it only loaded plugins specified in conftest.py). So the use case is running the qutip tests on my own system, where pytest-xvfb simply happens to be installed for other purposes not related to qutip. There are ways of working around the problem, for instance the `--no-xvfb` option could be explicitly added to the `pytest` command line. But it can be useful if the test code itself can be made robust with respect to the problem (e.g. in this case just replacing `plt.clf()` with `plt.close('all')`)",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1639#issuecomment-909115791
https://github.com/qutip/qutip/issues/1639#issuecomment-909115791:521,Testability,test,testing,521,"I don't have xvfb (pytest-xvfb) installed specifically for qutip, but it is used by other packages (The general use of pytest-xvfb is to facilitate testing of GUI, graphical or windowing functionality without having an normal Xserver active. That is, it can be useful for automated CI testing of gui packages, for instance in chroots or cloud CI infrastructure). Since qutip doesn't use xvfb directly this bug won't be a problem for general CI testing, where only qutip is loaded on a cloud instance (for instance Debian testing done at https://ci.debian.net/packages/q/qutip/). But before I upload a package to the Debian infrastructure, I like to run the tests on my own system to be confident they're likely to pass. So this is where the problem happens, running tests on my own system, where I have pytest-xvfb installed for testing other packages. (pytest has this bad habit of loading all available plugins whether or not they're actually used by the tests being run. It's quite annoying actually. It would be better if it only loaded plugins specified in conftest.py). So the use case is running the qutip tests on my own system, where pytest-xvfb simply happens to be installed for other purposes not related to qutip. There are ways of working around the problem, for instance the `--no-xvfb` option could be explicitly added to the `pytest` command line. But it can be useful if the test code itself can be made robust with respect to the problem (e.g. in this case just replacing `plt.clf()` with `plt.close('all')`)",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1639#issuecomment-909115791
https://github.com/qutip/qutip/issues/1639#issuecomment-909115791:657,Testability,test,tests,657,"I don't have xvfb (pytest-xvfb) installed specifically for qutip, but it is used by other packages (The general use of pytest-xvfb is to facilitate testing of GUI, graphical or windowing functionality without having an normal Xserver active. That is, it can be useful for automated CI testing of gui packages, for instance in chroots or cloud CI infrastructure). Since qutip doesn't use xvfb directly this bug won't be a problem for general CI testing, where only qutip is loaded on a cloud instance (for instance Debian testing done at https://ci.debian.net/packages/q/qutip/). But before I upload a package to the Debian infrastructure, I like to run the tests on my own system to be confident they're likely to pass. So this is where the problem happens, running tests on my own system, where I have pytest-xvfb installed for testing other packages. (pytest has this bad habit of loading all available plugins whether or not they're actually used by the tests being run. It's quite annoying actually. It would be better if it only loaded plugins specified in conftest.py). So the use case is running the qutip tests on my own system, where pytest-xvfb simply happens to be installed for other purposes not related to qutip. There are ways of working around the problem, for instance the `--no-xvfb` option could be explicitly added to the `pytest` command line. But it can be useful if the test code itself can be made robust with respect to the problem (e.g. in this case just replacing `plt.clf()` with `plt.close('all')`)",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1639#issuecomment-909115791
https://github.com/qutip/qutip/issues/1639#issuecomment-909115791:766,Testability,test,tests,766,"I don't have xvfb (pytest-xvfb) installed specifically for qutip, but it is used by other packages (The general use of pytest-xvfb is to facilitate testing of GUI, graphical or windowing functionality without having an normal Xserver active. That is, it can be useful for automated CI testing of gui packages, for instance in chroots or cloud CI infrastructure). Since qutip doesn't use xvfb directly this bug won't be a problem for general CI testing, where only qutip is loaded on a cloud instance (for instance Debian testing done at https://ci.debian.net/packages/q/qutip/). But before I upload a package to the Debian infrastructure, I like to run the tests on my own system to be confident they're likely to pass. So this is where the problem happens, running tests on my own system, where I have pytest-xvfb installed for testing other packages. (pytest has this bad habit of loading all available plugins whether or not they're actually used by the tests being run. It's quite annoying actually. It would be better if it only loaded plugins specified in conftest.py). So the use case is running the qutip tests on my own system, where pytest-xvfb simply happens to be installed for other purposes not related to qutip. There are ways of working around the problem, for instance the `--no-xvfb` option could be explicitly added to the `pytest` command line. But it can be useful if the test code itself can be made robust with respect to the problem (e.g. in this case just replacing `plt.clf()` with `plt.close('all')`)",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1639#issuecomment-909115791
https://github.com/qutip/qutip/issues/1639#issuecomment-909115791:829,Testability,test,testing,829,"I don't have xvfb (pytest-xvfb) installed specifically for qutip, but it is used by other packages (The general use of pytest-xvfb is to facilitate testing of GUI, graphical or windowing functionality without having an normal Xserver active. That is, it can be useful for automated CI testing of gui packages, for instance in chroots or cloud CI infrastructure). Since qutip doesn't use xvfb directly this bug won't be a problem for general CI testing, where only qutip is loaded on a cloud instance (for instance Debian testing done at https://ci.debian.net/packages/q/qutip/). But before I upload a package to the Debian infrastructure, I like to run the tests on my own system to be confident they're likely to pass. So this is where the problem happens, running tests on my own system, where I have pytest-xvfb installed for testing other packages. (pytest has this bad habit of loading all available plugins whether or not they're actually used by the tests being run. It's quite annoying actually. It would be better if it only loaded plugins specified in conftest.py). So the use case is running the qutip tests on my own system, where pytest-xvfb simply happens to be installed for other purposes not related to qutip. There are ways of working around the problem, for instance the `--no-xvfb` option could be explicitly added to the `pytest` command line. But it can be useful if the test code itself can be made robust with respect to the problem (e.g. in this case just replacing `plt.clf()` with `plt.close('all')`)",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1639#issuecomment-909115791
https://github.com/qutip/qutip/issues/1639#issuecomment-909115791:957,Testability,test,tests,957,"I don't have xvfb (pytest-xvfb) installed specifically for qutip, but it is used by other packages (The general use of pytest-xvfb is to facilitate testing of GUI, graphical or windowing functionality without having an normal Xserver active. That is, it can be useful for automated CI testing of gui packages, for instance in chroots or cloud CI infrastructure). Since qutip doesn't use xvfb directly this bug won't be a problem for general CI testing, where only qutip is loaded on a cloud instance (for instance Debian testing done at https://ci.debian.net/packages/q/qutip/). But before I upload a package to the Debian infrastructure, I like to run the tests on my own system to be confident they're likely to pass. So this is where the problem happens, running tests on my own system, where I have pytest-xvfb installed for testing other packages. (pytest has this bad habit of loading all available plugins whether or not they're actually used by the tests being run. It's quite annoying actually. It would be better if it only loaded plugins specified in conftest.py). So the use case is running the qutip tests on my own system, where pytest-xvfb simply happens to be installed for other purposes not related to qutip. There are ways of working around the problem, for instance the `--no-xvfb` option could be explicitly added to the `pytest` command line. But it can be useful if the test code itself can be made robust with respect to the problem (e.g. in this case just replacing `plt.clf()` with `plt.close('all')`)",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1639#issuecomment-909115791
https://github.com/qutip/qutip/issues/1639#issuecomment-909115791:1113,Testability,test,tests,1113,"I don't have xvfb (pytest-xvfb) installed specifically for qutip, but it is used by other packages (The general use of pytest-xvfb is to facilitate testing of GUI, graphical or windowing functionality without having an normal Xserver active. That is, it can be useful for automated CI testing of gui packages, for instance in chroots or cloud CI infrastructure). Since qutip doesn't use xvfb directly this bug won't be a problem for general CI testing, where only qutip is loaded on a cloud instance (for instance Debian testing done at https://ci.debian.net/packages/q/qutip/). But before I upload a package to the Debian infrastructure, I like to run the tests on my own system to be confident they're likely to pass. So this is where the problem happens, running tests on my own system, where I have pytest-xvfb installed for testing other packages. (pytest has this bad habit of loading all available plugins whether or not they're actually used by the tests being run. It's quite annoying actually. It would be better if it only loaded plugins specified in conftest.py). So the use case is running the qutip tests on my own system, where pytest-xvfb simply happens to be installed for other purposes not related to qutip. There are ways of working around the problem, for instance the `--no-xvfb` option could be explicitly added to the `pytest` command line. But it can be useful if the test code itself can be made robust with respect to the problem (e.g. in this case just replacing `plt.clf()` with `plt.close('all')`)",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1639#issuecomment-909115791
https://github.com/qutip/qutip/issues/1639#issuecomment-909115791:1393,Testability,test,test,1393,"I don't have xvfb (pytest-xvfb) installed specifically for qutip, but it is used by other packages (The general use of pytest-xvfb is to facilitate testing of GUI, graphical or windowing functionality without having an normal Xserver active. That is, it can be useful for automated CI testing of gui packages, for instance in chroots or cloud CI infrastructure). Since qutip doesn't use xvfb directly this bug won't be a problem for general CI testing, where only qutip is loaded on a cloud instance (for instance Debian testing done at https://ci.debian.net/packages/q/qutip/). But before I upload a package to the Debian infrastructure, I like to run the tests on my own system to be confident they're likely to pass. So this is where the problem happens, running tests on my own system, where I have pytest-xvfb installed for testing other packages. (pytest has this bad habit of loading all available plugins whether or not they're actually used by the tests being run. It's quite annoying actually. It would be better if it only loaded plugins specified in conftest.py). So the use case is running the qutip tests on my own system, where pytest-xvfb simply happens to be installed for other purposes not related to qutip. There are ways of working around the problem, for instance the `--no-xvfb` option could be explicitly added to the `pytest` command line. But it can be useful if the test code itself can be made robust with respect to the problem (e.g. in this case just replacing `plt.clf()` with `plt.close('all')`)",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1639#issuecomment-909115791
https://github.com/qutip/qutip/issues/1639#issuecomment-909115791:1155,Usability,simpl,simply,1155,"I don't have xvfb (pytest-xvfb) installed specifically for qutip, but it is used by other packages (The general use of pytest-xvfb is to facilitate testing of GUI, graphical or windowing functionality without having an normal Xserver active. That is, it can be useful for automated CI testing of gui packages, for instance in chroots or cloud CI infrastructure). Since qutip doesn't use xvfb directly this bug won't be a problem for general CI testing, where only qutip is loaded on a cloud instance (for instance Debian testing done at https://ci.debian.net/packages/q/qutip/). But before I upload a package to the Debian infrastructure, I like to run the tests on my own system to be confident they're likely to pass. So this is where the problem happens, running tests on my own system, where I have pytest-xvfb installed for testing other packages. (pytest has this bad habit of loading all available plugins whether or not they're actually used by the tests being run. It's quite annoying actually. It would be better if it only loaded plugins specified in conftest.py). So the use case is running the qutip tests on my own system, where pytest-xvfb simply happens to be installed for other purposes not related to qutip. There are ways of working around the problem, for instance the `--no-xvfb` option could be explicitly added to the `pytest` command line. But it can be useful if the test code itself can be made robust with respect to the problem (e.g. in this case just replacing `plt.clf()` with `plt.close('all')`)",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1639#issuecomment-909115791
https://github.com/qutip/qutip/issues/1639#issuecomment-909159005:43,Availability,avail,available,43,"> pytest has this bad habit of loading all available plugins whether or not they're actually used by the tests being run. It's quite annoying actually. It would be better if it only loaded plugins specified in conftest.py. Absolutely agree with this. > But it can be useful if the test code itself can be made robust with respect to the problem. Also yes - if I understand right, it's just the testing code that's a problem here, right, not the actual internal code? We can't swap to `pyplot.close('all')` in the library code (for obvious side-effect-y reasons), but if it's in the tests, then it shouldn't be an issue to change. I wonder why it caused a problem in the first place, though - if we could track it down (does `xvfb` do similar things to inline backends with respect to ""capturing"" images during construction/return?) it would be nice to use something slightly more targetted than `pyplot.close('all')`.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1639#issuecomment-909159005
https://github.com/qutip/qutip/issues/1639#issuecomment-909159005:310,Availability,robust,robust,310,"> pytest has this bad habit of loading all available plugins whether or not they're actually used by the tests being run. It's quite annoying actually. It would be better if it only loaded plugins specified in conftest.py. Absolutely agree with this. > But it can be useful if the test code itself can be made robust with respect to the problem. Also yes - if I understand right, it's just the testing code that's a problem here, right, not the actual internal code? We can't swap to `pyplot.close('all')` in the library code (for obvious side-effect-y reasons), but if it's in the tests, then it shouldn't be an issue to change. I wonder why it caused a problem in the first place, though - if we could track it down (does `xvfb` do similar things to inline backends with respect to ""capturing"" images during construction/return?) it would be nice to use something slightly more targetted than `pyplot.close('all')`.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1639#issuecomment-909159005
https://github.com/qutip/qutip/issues/1639#issuecomment-909159005:713,Availability,down,down,713,"> pytest has this bad habit of loading all available plugins whether or not they're actually used by the tests being run. It's quite annoying actually. It would be better if it only loaded plugins specified in conftest.py. Absolutely agree with this. > But it can be useful if the test code itself can be made robust with respect to the problem. Also yes - if I understand right, it's just the testing code that's a problem here, right, not the actual internal code? We can't swap to `pyplot.close('all')` in the library code (for obvious side-effect-y reasons), but if it's in the tests, then it shouldn't be an issue to change. I wonder why it caused a problem in the first place, though - if we could track it down (does `xvfb` do similar things to inline backends with respect to ""capturing"" images during construction/return?) it would be nice to use something slightly more targetted than `pyplot.close('all')`.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1639#issuecomment-909159005
https://github.com/qutip/qutip/issues/1639#issuecomment-909159005:53,Modifiability,plugin,plugins,53,"> pytest has this bad habit of loading all available plugins whether or not they're actually used by the tests being run. It's quite annoying actually. It would be better if it only loaded plugins specified in conftest.py. Absolutely agree with this. > But it can be useful if the test code itself can be made robust with respect to the problem. Also yes - if I understand right, it's just the testing code that's a problem here, right, not the actual internal code? We can't swap to `pyplot.close('all')` in the library code (for obvious side-effect-y reasons), but if it's in the tests, then it shouldn't be an issue to change. I wonder why it caused a problem in the first place, though - if we could track it down (does `xvfb` do similar things to inline backends with respect to ""capturing"" images during construction/return?) it would be nice to use something slightly more targetted than `pyplot.close('all')`.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1639#issuecomment-909159005
https://github.com/qutip/qutip/issues/1639#issuecomment-909159005:189,Modifiability,plugin,plugins,189,"> pytest has this bad habit of loading all available plugins whether or not they're actually used by the tests being run. It's quite annoying actually. It would be better if it only loaded plugins specified in conftest.py. Absolutely agree with this. > But it can be useful if the test code itself can be made robust with respect to the problem. Also yes - if I understand right, it's just the testing code that's a problem here, right, not the actual internal code? We can't swap to `pyplot.close('all')` in the library code (for obvious side-effect-y reasons), but if it's in the tests, then it shouldn't be an issue to change. I wonder why it caused a problem in the first place, though - if we could track it down (does `xvfb` do similar things to inline backends with respect to ""capturing"" images during construction/return?) it would be nice to use something slightly more targetted than `pyplot.close('all')`.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1639#issuecomment-909159005
https://github.com/qutip/qutip/issues/1639#issuecomment-909159005:31,Performance,load,loading,31,"> pytest has this bad habit of loading all available plugins whether or not they're actually used by the tests being run. It's quite annoying actually. It would be better if it only loaded plugins specified in conftest.py. Absolutely agree with this. > But it can be useful if the test code itself can be made robust with respect to the problem. Also yes - if I understand right, it's just the testing code that's a problem here, right, not the actual internal code? We can't swap to `pyplot.close('all')` in the library code (for obvious side-effect-y reasons), but if it's in the tests, then it shouldn't be an issue to change. I wonder why it caused a problem in the first place, though - if we could track it down (does `xvfb` do similar things to inline backends with respect to ""capturing"" images during construction/return?) it would be nice to use something slightly more targetted than `pyplot.close('all')`.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1639#issuecomment-909159005
https://github.com/qutip/qutip/issues/1639#issuecomment-909159005:182,Performance,load,loaded,182,"> pytest has this bad habit of loading all available plugins whether or not they're actually used by the tests being run. It's quite annoying actually. It would be better if it only loaded plugins specified in conftest.py. Absolutely agree with this. > But it can be useful if the test code itself can be made robust with respect to the problem. Also yes - if I understand right, it's just the testing code that's a problem here, right, not the actual internal code? We can't swap to `pyplot.close('all')` in the library code (for obvious side-effect-y reasons), but if it's in the tests, then it shouldn't be an issue to change. I wonder why it caused a problem in the first place, though - if we could track it down (does `xvfb` do similar things to inline backends with respect to ""capturing"" images during construction/return?) it would be nice to use something slightly more targetted than `pyplot.close('all')`.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1639#issuecomment-909159005
https://github.com/qutip/qutip/issues/1639#issuecomment-909159005:105,Testability,test,tests,105,"> pytest has this bad habit of loading all available plugins whether or not they're actually used by the tests being run. It's quite annoying actually. It would be better if it only loaded plugins specified in conftest.py. Absolutely agree with this. > But it can be useful if the test code itself can be made robust with respect to the problem. Also yes - if I understand right, it's just the testing code that's a problem here, right, not the actual internal code? We can't swap to `pyplot.close('all')` in the library code (for obvious side-effect-y reasons), but if it's in the tests, then it shouldn't be an issue to change. I wonder why it caused a problem in the first place, though - if we could track it down (does `xvfb` do similar things to inline backends with respect to ""capturing"" images during construction/return?) it would be nice to use something slightly more targetted than `pyplot.close('all')`.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1639#issuecomment-909159005
https://github.com/qutip/qutip/issues/1639#issuecomment-909159005:281,Testability,test,test,281,"> pytest has this bad habit of loading all available plugins whether or not they're actually used by the tests being run. It's quite annoying actually. It would be better if it only loaded plugins specified in conftest.py. Absolutely agree with this. > But it can be useful if the test code itself can be made robust with respect to the problem. Also yes - if I understand right, it's just the testing code that's a problem here, right, not the actual internal code? We can't swap to `pyplot.close('all')` in the library code (for obvious side-effect-y reasons), but if it's in the tests, then it shouldn't be an issue to change. I wonder why it caused a problem in the first place, though - if we could track it down (does `xvfb` do similar things to inline backends with respect to ""capturing"" images during construction/return?) it would be nice to use something slightly more targetted than `pyplot.close('all')`.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1639#issuecomment-909159005
https://github.com/qutip/qutip/issues/1639#issuecomment-909159005:394,Testability,test,testing,394,"> pytest has this bad habit of loading all available plugins whether or not they're actually used by the tests being run. It's quite annoying actually. It would be better if it only loaded plugins specified in conftest.py. Absolutely agree with this. > But it can be useful if the test code itself can be made robust with respect to the problem. Also yes - if I understand right, it's just the testing code that's a problem here, right, not the actual internal code? We can't swap to `pyplot.close('all')` in the library code (for obvious side-effect-y reasons), but if it's in the tests, then it shouldn't be an issue to change. I wonder why it caused a problem in the first place, though - if we could track it down (does `xvfb` do similar things to inline backends with respect to ""capturing"" images during construction/return?) it would be nice to use something slightly more targetted than `pyplot.close('all')`.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1639#issuecomment-909159005
https://github.com/qutip/qutip/issues/1639#issuecomment-909159005:582,Testability,test,tests,582,"> pytest has this bad habit of loading all available plugins whether or not they're actually used by the tests being run. It's quite annoying actually. It would be better if it only loaded plugins specified in conftest.py. Absolutely agree with this. > But it can be useful if the test code itself can be made robust with respect to the problem. Also yes - if I understand right, it's just the testing code that's a problem here, right, not the actual internal code? We can't swap to `pyplot.close('all')` in the library code (for obvious side-effect-y reasons), but if it's in the tests, then it shouldn't be an issue to change. I wonder why it caused a problem in the first place, though - if we could track it down (does `xvfb` do similar things to inline backends with respect to ""capturing"" images during construction/return?) it would be nice to use something slightly more targetted than `pyplot.close('all')`.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1639#issuecomment-909159005
https://github.com/qutip/qutip/issues/1639#issuecomment-909191682:347,Availability,error,error,347,"@drew-parsons If fixing this will help packaging for Debian, we will definitely fix it!. This appears to be considered an `Xvfb` bug (or at least the discussion in https://github.com/The-Compiler/pytest-xvfb/issues/11 suggests that), but having tests close their windows does seem polite anyway. Installing `xvfb` and `pytest-xvfb` reproduces the error for me and adding `plt.close(""all"")` to the end of `testPlot` removes the error again. After that the rest of the test suite passes, although there have been some reports in the pytest-xvfb of timing or test order sensitive results, so there may be more problems to be found later. For now I'll open a PR that adds the `plt.close(""all"")`.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1639#issuecomment-909191682
https://github.com/qutip/qutip/issues/1639#issuecomment-909191682:427,Availability,error,error,427,"@drew-parsons If fixing this will help packaging for Debian, we will definitely fix it!. This appears to be considered an `Xvfb` bug (or at least the discussion in https://github.com/The-Compiler/pytest-xvfb/issues/11 suggests that), but having tests close their windows does seem polite anyway. Installing `xvfb` and `pytest-xvfb` reproduces the error for me and adding `plt.close(""all"")` to the end of `testPlot` removes the error again. After that the rest of the test suite passes, although there have been some reports in the pytest-xvfb of timing or test order sensitive results, so there may be more problems to be found later. For now I'll open a PR that adds the `plt.close(""all"")`.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1639#issuecomment-909191682
https://github.com/qutip/qutip/issues/1639#issuecomment-909191682:296,Deployability,Install,Installing,296,"@drew-parsons If fixing this will help packaging for Debian, we will definitely fix it!. This appears to be considered an `Xvfb` bug (or at least the discussion in https://github.com/The-Compiler/pytest-xvfb/issues/11 suggests that), but having tests close their windows does seem polite anyway. Installing `xvfb` and `pytest-xvfb` reproduces the error for me and adding `plt.close(""all"")` to the end of `testPlot` removes the error again. After that the rest of the test suite passes, although there have been some reports in the pytest-xvfb of timing or test order sensitive results, so there may be more problems to be found later. For now I'll open a PR that adds the `plt.close(""all"")`.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1639#issuecomment-909191682
https://github.com/qutip/qutip/issues/1639#issuecomment-909191682:245,Testability,test,tests,245,"@drew-parsons If fixing this will help packaging for Debian, we will definitely fix it!. This appears to be considered an `Xvfb` bug (or at least the discussion in https://github.com/The-Compiler/pytest-xvfb/issues/11 suggests that), but having tests close their windows does seem polite anyway. Installing `xvfb` and `pytest-xvfb` reproduces the error for me and adding `plt.close(""all"")` to the end of `testPlot` removes the error again. After that the rest of the test suite passes, although there have been some reports in the pytest-xvfb of timing or test order sensitive results, so there may be more problems to be found later. For now I'll open a PR that adds the `plt.close(""all"")`.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1639#issuecomment-909191682
https://github.com/qutip/qutip/issues/1639#issuecomment-909191682:405,Testability,test,testPlot,405,"@drew-parsons If fixing this will help packaging for Debian, we will definitely fix it!. This appears to be considered an `Xvfb` bug (or at least the discussion in https://github.com/The-Compiler/pytest-xvfb/issues/11 suggests that), but having tests close their windows does seem polite anyway. Installing `xvfb` and `pytest-xvfb` reproduces the error for me and adding `plt.close(""all"")` to the end of `testPlot` removes the error again. After that the rest of the test suite passes, although there have been some reports in the pytest-xvfb of timing or test order sensitive results, so there may be more problems to be found later. For now I'll open a PR that adds the `plt.close(""all"")`.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1639#issuecomment-909191682
https://github.com/qutip/qutip/issues/1639#issuecomment-909191682:467,Testability,test,test,467,"@drew-parsons If fixing this will help packaging for Debian, we will definitely fix it!. This appears to be considered an `Xvfb` bug (or at least the discussion in https://github.com/The-Compiler/pytest-xvfb/issues/11 suggests that), but having tests close their windows does seem polite anyway. Installing `xvfb` and `pytest-xvfb` reproduces the error for me and adding `plt.close(""all"")` to the end of `testPlot` removes the error again. After that the rest of the test suite passes, although there have been some reports in the pytest-xvfb of timing or test order sensitive results, so there may be more problems to be found later. For now I'll open a PR that adds the `plt.close(""all"")`.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1639#issuecomment-909191682
https://github.com/qutip/qutip/issues/1639#issuecomment-909191682:556,Testability,test,test,556,"@drew-parsons If fixing this will help packaging for Debian, we will definitely fix it!. This appears to be considered an `Xvfb` bug (or at least the discussion in https://github.com/The-Compiler/pytest-xvfb/issues/11 suggests that), but having tests close their windows does seem polite anyway. Installing `xvfb` and `pytest-xvfb` reproduces the error for me and adding `plt.close(""all"")` to the end of `testPlot` removes the error again. After that the rest of the test suite passes, although there have been some reports in the pytest-xvfb of timing or test order sensitive results, so there may be more problems to be found later. For now I'll open a PR that adds the `plt.close(""all"")`.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1639#issuecomment-909191682
https://github.com/qutip/qutip/issues/1639#issuecomment-909207169:164,Testability,test,test,164,"There's only those two references in test_processor.py that are affected as far as I can see. So that PR should work fine. Closing only the specific `fig` from the test is a good idea too, not as stentorious as closing ""all"".",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1639#issuecomment-909207169
https://github.com/qutip/qutip/issues/1639#issuecomment-912159847:114,Availability,error,error,114,"Curious cross-reference from [mdanalysis](https://github.com/MDAnalysis/mdanalysis). Their tests trigger the same error (likely again because of pytest-xvfb),; ```; XIO: fatal IO error 0 (Success) on X server "":1029""; ```; Their error is not so simple to clear, since they use the object oriented matplotlib API (e.g. using AxesSubplot `matplotlib.axes._subplots.AxesSubplot`) rather than matplotlib.pyplot. So they don't have access to `plt.close()` and `axes.cla()` doesn't prevent the error, probably for the same reason that `plt.clf()` didn't work for qutip. One point they have which is worth noting: they recommend using the environment variable `MPLBACKEND=agg` for headless CI testing. And sure enough the XIO error does not occur with mdanalysis if `MPLBACKEND=agg` is set. For qutip the `plt.close(fig)` patch is still the best (more robust) solution though.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1639#issuecomment-912159847
https://github.com/qutip/qutip/issues/1639#issuecomment-912159847:179,Availability,error,error,179,"Curious cross-reference from [mdanalysis](https://github.com/MDAnalysis/mdanalysis). Their tests trigger the same error (likely again because of pytest-xvfb),; ```; XIO: fatal IO error 0 (Success) on X server "":1029""; ```; Their error is not so simple to clear, since they use the object oriented matplotlib API (e.g. using AxesSubplot `matplotlib.axes._subplots.AxesSubplot`) rather than matplotlib.pyplot. So they don't have access to `plt.close()` and `axes.cla()` doesn't prevent the error, probably for the same reason that `plt.clf()` didn't work for qutip. One point they have which is worth noting: they recommend using the environment variable `MPLBACKEND=agg` for headless CI testing. And sure enough the XIO error does not occur with mdanalysis if `MPLBACKEND=agg` is set. For qutip the `plt.close(fig)` patch is still the best (more robust) solution though.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1639#issuecomment-912159847
https://github.com/qutip/qutip/issues/1639#issuecomment-912159847:229,Availability,error,error,229,"Curious cross-reference from [mdanalysis](https://github.com/MDAnalysis/mdanalysis). Their tests trigger the same error (likely again because of pytest-xvfb),; ```; XIO: fatal IO error 0 (Success) on X server "":1029""; ```; Their error is not so simple to clear, since they use the object oriented matplotlib API (e.g. using AxesSubplot `matplotlib.axes._subplots.AxesSubplot`) rather than matplotlib.pyplot. So they don't have access to `plt.close()` and `axes.cla()` doesn't prevent the error, probably for the same reason that `plt.clf()` didn't work for qutip. One point they have which is worth noting: they recommend using the environment variable `MPLBACKEND=agg` for headless CI testing. And sure enough the XIO error does not occur with mdanalysis if `MPLBACKEND=agg` is set. For qutip the `plt.close(fig)` patch is still the best (more robust) solution though.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1639#issuecomment-912159847
https://github.com/qutip/qutip/issues/1639#issuecomment-912159847:488,Availability,error,error,488,"Curious cross-reference from [mdanalysis](https://github.com/MDAnalysis/mdanalysis). Their tests trigger the same error (likely again because of pytest-xvfb),; ```; XIO: fatal IO error 0 (Success) on X server "":1029""; ```; Their error is not so simple to clear, since they use the object oriented matplotlib API (e.g. using AxesSubplot `matplotlib.axes._subplots.AxesSubplot`) rather than matplotlib.pyplot. So they don't have access to `plt.close()` and `axes.cla()` doesn't prevent the error, probably for the same reason that `plt.clf()` didn't work for qutip. One point they have which is worth noting: they recommend using the environment variable `MPLBACKEND=agg` for headless CI testing. And sure enough the XIO error does not occur with mdanalysis if `MPLBACKEND=agg` is set. For qutip the `plt.close(fig)` patch is still the best (more robust) solution though.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1639#issuecomment-912159847
https://github.com/qutip/qutip/issues/1639#issuecomment-912159847:719,Availability,error,error,719,"Curious cross-reference from [mdanalysis](https://github.com/MDAnalysis/mdanalysis). Their tests trigger the same error (likely again because of pytest-xvfb),; ```; XIO: fatal IO error 0 (Success) on X server "":1029""; ```; Their error is not so simple to clear, since they use the object oriented matplotlib API (e.g. using AxesSubplot `matplotlib.axes._subplots.AxesSubplot`) rather than matplotlib.pyplot. So they don't have access to `plt.close()` and `axes.cla()` doesn't prevent the error, probably for the same reason that `plt.clf()` didn't work for qutip. One point they have which is worth noting: they recommend using the environment variable `MPLBACKEND=agg` for headless CI testing. And sure enough the XIO error does not occur with mdanalysis if `MPLBACKEND=agg` is set. For qutip the `plt.close(fig)` patch is still the best (more robust) solution though.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1639#issuecomment-912159847
https://github.com/qutip/qutip/issues/1639#issuecomment-912159847:845,Availability,robust,robust,845,"Curious cross-reference from [mdanalysis](https://github.com/MDAnalysis/mdanalysis). Their tests trigger the same error (likely again because of pytest-xvfb),; ```; XIO: fatal IO error 0 (Success) on X server "":1029""; ```; Their error is not so simple to clear, since they use the object oriented matplotlib API (e.g. using AxesSubplot `matplotlib.axes._subplots.AxesSubplot`) rather than matplotlib.pyplot. So they don't have access to `plt.close()` and `axes.cla()` doesn't prevent the error, probably for the same reason that `plt.clf()` didn't work for qutip. One point they have which is worth noting: they recommend using the environment variable `MPLBACKEND=agg` for headless CI testing. And sure enough the XIO error does not occur with mdanalysis if `MPLBACKEND=agg` is set. For qutip the `plt.close(fig)` patch is still the best (more robust) solution though.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1639#issuecomment-912159847
https://github.com/qutip/qutip/issues/1639#issuecomment-912159847:815,Deployability,patch,patch,815,"Curious cross-reference from [mdanalysis](https://github.com/MDAnalysis/mdanalysis). Their tests trigger the same error (likely again because of pytest-xvfb),; ```; XIO: fatal IO error 0 (Success) on X server "":1029""; ```; Their error is not so simple to clear, since they use the object oriented matplotlib API (e.g. using AxesSubplot `matplotlib.axes._subplots.AxesSubplot`) rather than matplotlib.pyplot. So they don't have access to `plt.close()` and `axes.cla()` doesn't prevent the error, probably for the same reason that `plt.clf()` didn't work for qutip. One point they have which is worth noting: they recommend using the environment variable `MPLBACKEND=agg` for headless CI testing. And sure enough the XIO error does not occur with mdanalysis if `MPLBACKEND=agg` is set. For qutip the `plt.close(fig)` patch is still the best (more robust) solution though.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1639#issuecomment-912159847
https://github.com/qutip/qutip/issues/1639#issuecomment-912159847:644,Modifiability,variab,variable,644,"Curious cross-reference from [mdanalysis](https://github.com/MDAnalysis/mdanalysis). Their tests trigger the same error (likely again because of pytest-xvfb),; ```; XIO: fatal IO error 0 (Success) on X server "":1029""; ```; Their error is not so simple to clear, since they use the object oriented matplotlib API (e.g. using AxesSubplot `matplotlib.axes._subplots.AxesSubplot`) rather than matplotlib.pyplot. So they don't have access to `plt.close()` and `axes.cla()` doesn't prevent the error, probably for the same reason that `plt.clf()` didn't work for qutip. One point they have which is worth noting: they recommend using the environment variable `MPLBACKEND=agg` for headless CI testing. And sure enough the XIO error does not occur with mdanalysis if `MPLBACKEND=agg` is set. For qutip the `plt.close(fig)` patch is still the best (more robust) solution though.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1639#issuecomment-912159847
https://github.com/qutip/qutip/issues/1639#issuecomment-912159847:427,Security,access,access,427,"Curious cross-reference from [mdanalysis](https://github.com/MDAnalysis/mdanalysis). Their tests trigger the same error (likely again because of pytest-xvfb),; ```; XIO: fatal IO error 0 (Success) on X server "":1029""; ```; Their error is not so simple to clear, since they use the object oriented matplotlib API (e.g. using AxesSubplot `matplotlib.axes._subplots.AxesSubplot`) rather than matplotlib.pyplot. So they don't have access to `plt.close()` and `axes.cla()` doesn't prevent the error, probably for the same reason that `plt.clf()` didn't work for qutip. One point they have which is worth noting: they recommend using the environment variable `MPLBACKEND=agg` for headless CI testing. And sure enough the XIO error does not occur with mdanalysis if `MPLBACKEND=agg` is set. For qutip the `plt.close(fig)` patch is still the best (more robust) solution though.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1639#issuecomment-912159847
https://github.com/qutip/qutip/issues/1639#issuecomment-912159847:91,Testability,test,tests,91,"Curious cross-reference from [mdanalysis](https://github.com/MDAnalysis/mdanalysis). Their tests trigger the same error (likely again because of pytest-xvfb),; ```; XIO: fatal IO error 0 (Success) on X server "":1029""; ```; Their error is not so simple to clear, since they use the object oriented matplotlib API (e.g. using AxesSubplot `matplotlib.axes._subplots.AxesSubplot`) rather than matplotlib.pyplot. So they don't have access to `plt.close()` and `axes.cla()` doesn't prevent the error, probably for the same reason that `plt.clf()` didn't work for qutip. One point they have which is worth noting: they recommend using the environment variable `MPLBACKEND=agg` for headless CI testing. And sure enough the XIO error does not occur with mdanalysis if `MPLBACKEND=agg` is set. For qutip the `plt.close(fig)` patch is still the best (more robust) solution though.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1639#issuecomment-912159847
https://github.com/qutip/qutip/issues/1639#issuecomment-912159847:686,Testability,test,testing,686,"Curious cross-reference from [mdanalysis](https://github.com/MDAnalysis/mdanalysis). Their tests trigger the same error (likely again because of pytest-xvfb),; ```; XIO: fatal IO error 0 (Success) on X server "":1029""; ```; Their error is not so simple to clear, since they use the object oriented matplotlib API (e.g. using AxesSubplot `matplotlib.axes._subplots.AxesSubplot`) rather than matplotlib.pyplot. So they don't have access to `plt.close()` and `axes.cla()` doesn't prevent the error, probably for the same reason that `plt.clf()` didn't work for qutip. One point they have which is worth noting: they recommend using the environment variable `MPLBACKEND=agg` for headless CI testing. And sure enough the XIO error does not occur with mdanalysis if `MPLBACKEND=agg` is set. For qutip the `plt.close(fig)` patch is still the best (more robust) solution though.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1639#issuecomment-912159847
https://github.com/qutip/qutip/issues/1639#issuecomment-912159847:245,Usability,simpl,simple,245,"Curious cross-reference from [mdanalysis](https://github.com/MDAnalysis/mdanalysis). Their tests trigger the same error (likely again because of pytest-xvfb),; ```; XIO: fatal IO error 0 (Success) on X server "":1029""; ```; Their error is not so simple to clear, since they use the object oriented matplotlib API (e.g. using AxesSubplot `matplotlib.axes._subplots.AxesSubplot`) rather than matplotlib.pyplot. So they don't have access to `plt.close()` and `axes.cla()` doesn't prevent the error, probably for the same reason that `plt.clf()` didn't work for qutip. One point they have which is worth noting: they recommend using the environment variable `MPLBACKEND=agg` for headless CI testing. And sure enough the XIO error does not occur with mdanalysis if `MPLBACKEND=agg` is set. For qutip the `plt.close(fig)` patch is still the best (more robust) solution though.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1639#issuecomment-912159847
https://github.com/qutip/qutip/issues/1639#issuecomment-912159847:255,Usability,clear,clear,255,"Curious cross-reference from [mdanalysis](https://github.com/MDAnalysis/mdanalysis). Their tests trigger the same error (likely again because of pytest-xvfb),; ```; XIO: fatal IO error 0 (Success) on X server "":1029""; ```; Their error is not so simple to clear, since they use the object oriented matplotlib API (e.g. using AxesSubplot `matplotlib.axes._subplots.AxesSubplot`) rather than matplotlib.pyplot. So they don't have access to `plt.close()` and `axes.cla()` doesn't prevent the error, probably for the same reason that `plt.clf()` didn't work for qutip. One point they have which is worth noting: they recommend using the environment variable `MPLBACKEND=agg` for headless CI testing. And sure enough the XIO error does not occur with mdanalysis if `MPLBACKEND=agg` is set. For qutip the `plt.close(fig)` patch is still the best (more robust) solution though.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1639#issuecomment-912159847
https://github.com/qutip/qutip/issues/1639#issuecomment-912397571:41,Safety,avoid,avoids,41,"@drew-parsons I imagine `MPLBACKEND=agg` avoids the issue by not using X at all. I have used it in the past for matplotlib tests, and it's not a bad idea perhaps to switch the QuTiP visualization tests to the `agg` backend, but it's not something I'm going to tackle right now I don't think (too many other big QuTiP changes up in the air at the moment).",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1639#issuecomment-912397571
https://github.com/qutip/qutip/issues/1639#issuecomment-912397571:123,Testability,test,tests,123,"@drew-parsons I imagine `MPLBACKEND=agg` avoids the issue by not using X at all. I have used it in the past for matplotlib tests, and it's not a bad idea perhaps to switch the QuTiP visualization tests to the `agg` backend, but it's not something I'm going to tackle right now I don't think (too many other big QuTiP changes up in the air at the moment).",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1639#issuecomment-912397571
https://github.com/qutip/qutip/issues/1639#issuecomment-912397571:196,Testability,test,tests,196,"@drew-parsons I imagine `MPLBACKEND=agg` avoids the issue by not using X at all. I have used it in the past for matplotlib tests, and it's not a bad idea perhaps to switch the QuTiP visualization tests to the `agg` backend, but it's not something I'm going to tackle right now I don't think (too many other big QuTiP changes up in the air at the moment).",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1639#issuecomment-912397571
https://github.com/qutip/qutip/issues/1640#issuecomment-902706073:181,Deployability,release,release,181,"Thank you for reporting.; This should be already fixed in the `master` branch.; You can use `master`, we keep it stable enough that it can be used at any time, or wait for the next release.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1640#issuecomment-902706073
https://github.com/qutip/qutip/pull/1641#issuecomment-904676572:211,Testability,test,test-maths-remove-unnecessary-scipy-sparse-use,211,[![Coverage Status](https://coveralls.io/builds/42370531/badge)](https://coveralls.io/builds/42370531). Coverage remained the same at 64.891% when pulling **65d67ed872d82b58f922148f23fa62108a52368b on hodgestar:test-maths-remove-unnecessary-scipy-sparse-use** into **0a9fd8d6b06731d269b6d6e7fb8169d06a4ce8ca on qutip:dev.major**.,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1641#issuecomment-904676572
https://github.com/qutip/qutip/issues/1642#issuecomment-905691827:915,Testability,test,testing,915,"The function `rand_herm` doesn't return a uniformly random sample from the space of Hermitean matrices -- instead it uses by default a simpler procedure of generating a random matrix with moderately sized entries and then calculating `M + M.conj().transpose()`. The following note in the `rand_herm` documentation explains how to select the eigenvalues:. > If given a list/ndarray as input 'N', this function returns a; > random Hermitian object with eigenvalues given in the list/ndarray.; > This is accomplished via complex Jacobi rotations. While this method; > is ~50% faster than the corresponding (real only) Matlab code, it should; > not be repeatedly used for generating matrices larger than ~1000x1000. Specifically one may generate random eigenvalues and supply those. I don't think anyone is against improving the `rand_XXX` function to have better statistical properties, but they're primarily used for testing and simple trial data at the moment, so their implementations have been good enough so far.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1642#issuecomment-905691827
https://github.com/qutip/qutip/issues/1642#issuecomment-905691827:135,Usability,simpl,simpler,135,"The function `rand_herm` doesn't return a uniformly random sample from the space of Hermitean matrices -- instead it uses by default a simpler procedure of generating a random matrix with moderately sized entries and then calculating `M + M.conj().transpose()`. The following note in the `rand_herm` documentation explains how to select the eigenvalues:. > If given a list/ndarray as input 'N', this function returns a; > random Hermitian object with eigenvalues given in the list/ndarray.; > This is accomplished via complex Jacobi rotations. While this method; > is ~50% faster than the corresponding (real only) Matlab code, it should; > not be repeatedly used for generating matrices larger than ~1000x1000. Specifically one may generate random eigenvalues and supply those. I don't think anyone is against improving the `rand_XXX` function to have better statistical properties, but they're primarily used for testing and simple trial data at the moment, so their implementations have been good enough so far.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1642#issuecomment-905691827
https://github.com/qutip/qutip/issues/1642#issuecomment-905691827:927,Usability,simpl,simple,927,"The function `rand_herm` doesn't return a uniformly random sample from the space of Hermitean matrices -- instead it uses by default a simpler procedure of generating a random matrix with moderately sized entries and then calculating `M + M.conj().transpose()`. The following note in the `rand_herm` documentation explains how to select the eigenvalues:. > If given a list/ndarray as input 'N', this function returns a; > random Hermitian object with eigenvalues given in the list/ndarray.; > This is accomplished via complex Jacobi rotations. While this method; > is ~50% faster than the corresponding (real only) Matlab code, it should; > not be repeatedly used for generating matrices larger than ~1000x1000. Specifically one may generate random eigenvalues and supply those. I don't think anyone is against improving the `rand_XXX` function to have better statistical properties, but they're primarily used for testing and simple trial data at the moment, so their implementations have been good enough so far.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1642#issuecomment-905691827
https://github.com/qutip/qutip/issues/1642#issuecomment-905696188:374,Usability,intuit,intuitive,374,"Looking at our algorithm, it does seem a bit questionable for positive-definite matrices, but to be fair, what constitutes sufficiently random? The eigenvalues being chosen on the interval (0, 1] is also pretty arbitrary. When you start throwing in extra constraints like ""matrix density"" and ""positive-definite"", it becomes difficult to sample a useful measure that has an intuitive definition of random. We're certainly not against improving the algorithm if you've got ideas, though. The current algorithm (noted in the docstring) is ""diagonal dominance"" - basically we add extra stuff onto the diagonal to ensure that the eigenvalues end up all positive. That's why you see them getting bigger as the dimension increases. To some degree, it's the intended behaviour. @hodgestar: this is specifically about positive-definite matrices, and supplying eigenvalues is incompatible with that (though perhaps that's a bug!). It shouldn't be too difficult to make that work by messing around with the Cholesky decomposition, but that would be hard to get right with respect to the density.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1642#issuecomment-905696188
https://github.com/qutip/qutip/issues/1642#issuecomment-905707288:132,Availability,error,error,132,Supplying negative or zero eigenvalues in the list and `pos_def=True` is certainly non-sensical input and should possibly return an error (and I think doesn't at the moment).,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1642#issuecomment-905707288
https://github.com/qutip/qutip/issues/1642#issuecomment-905715259:143,Integrability,wrap,wrap,143,"QuTiP doesn't have one built in at the moment, but [`toqito`](https://vprusso.github.io/toqito/) can do it as numpy arrays, which you can just wrap in `Qobj`. There's no scope for `density` there, though (and it would be very difficult to do so, I think!).",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1642#issuecomment-905715259
https://github.com/qutip/qutip/issues/1642#issuecomment-905717962:145,Integrability,wrap,wrap,145,"> QuTiP doesn't have one built in at the moment, but [`toqito`](https://vprusso.github.io/toqito/) can do it as numpy arrays, which you can just wrap in `Qobj`. There's no scope for `density` there, though (and it would be very difficult to do so, I think!). Thanks :)",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1642#issuecomment-905717962
https://github.com/qutip/qutip/pull/1643#issuecomment-920331445:209,Deployability,integrat,integrators,209,[![Coverage Status](https://coveralls.io/builds/43279924/badge)](https://coveralls.io/builds/43279924). Coverage increased (+0.2%) to 65.124% when pulling **ac8e9d40d23d253173918a2d353d47f23abdf633 on Ericgig:integrators** into **f8ed1be97946171ae8ba9242673cf2674430da56 on qutip:dev.major**.,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1643#issuecomment-920331445
https://github.com/qutip/qutip/pull/1643#issuecomment-920331445:209,Integrability,integrat,integrators,209,[![Coverage Status](https://coveralls.io/builds/43279924/badge)](https://coveralls.io/builds/43279924). Coverage increased (+0.2%) to 65.124% when pulling **ac8e9d40d23d253173918a2d353d47f23abdf633 on Ericgig:integrators** into **f8ed1be97946171ae8ba9242673cf2674430da56 on qutip:dev.major**.,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1643#issuecomment-920331445
https://github.com/qutip/qutip/pull/1643#issuecomment-925113187:39,Deployability,integrat,integrators,39,"@Ericgig Do you have examples of where integrators are used?. Some of the interface choices seem inconsistent -- e.g. `system` is a `QobjEvo` instance (so it has dims) but the states are `data` (which don't have dims, type, etc). Perhaps this makes sense given how things are used, but it would be good to be consistent (especially given that accessing `.data` is very fast and would allow the integrator access to the dims and various high-level operations). Perhaps one solution is to have two levels of interface -- i.e. a low-level one (`get_state`, `set_state`, `integrate`) and a high-level one (`run`) where the signature of `run` changes to `run(initial_qobj, tlist) -> final_qobj` and `run` calls `get_state`, `set_state` and `integrate`?. I will also do a more line by line review shortly.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1643#issuecomment-925113187
https://github.com/qutip/qutip/pull/1643#issuecomment-925113187:394,Deployability,integrat,integrator,394,"@Ericgig Do you have examples of where integrators are used?. Some of the interface choices seem inconsistent -- e.g. `system` is a `QobjEvo` instance (so it has dims) but the states are `data` (which don't have dims, type, etc). Perhaps this makes sense given how things are used, but it would be good to be consistent (especially given that accessing `.data` is very fast and would allow the integrator access to the dims and various high-level operations). Perhaps one solution is to have two levels of interface -- i.e. a low-level one (`get_state`, `set_state`, `integrate`) and a high-level one (`run`) where the signature of `run` changes to `run(initial_qobj, tlist) -> final_qobj` and `run` calls `get_state`, `set_state` and `integrate`?. I will also do a more line by line review shortly.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1643#issuecomment-925113187
https://github.com/qutip/qutip/pull/1643#issuecomment-925113187:568,Deployability,integrat,integrate,568,"@Ericgig Do you have examples of where integrators are used?. Some of the interface choices seem inconsistent -- e.g. `system` is a `QobjEvo` instance (so it has dims) but the states are `data` (which don't have dims, type, etc). Perhaps this makes sense given how things are used, but it would be good to be consistent (especially given that accessing `.data` is very fast and would allow the integrator access to the dims and various high-level operations). Perhaps one solution is to have two levels of interface -- i.e. a low-level one (`get_state`, `set_state`, `integrate`) and a high-level one (`run`) where the signature of `run` changes to `run(initial_qobj, tlist) -> final_qobj` and `run` calls `get_state`, `set_state` and `integrate`?. I will also do a more line by line review shortly.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1643#issuecomment-925113187
https://github.com/qutip/qutip/pull/1643#issuecomment-925113187:736,Deployability,integrat,integrate,736,"@Ericgig Do you have examples of where integrators are used?. Some of the interface choices seem inconsistent -- e.g. `system` is a `QobjEvo` instance (so it has dims) but the states are `data` (which don't have dims, type, etc). Perhaps this makes sense given how things are used, but it would be good to be consistent (especially given that accessing `.data` is very fast and would allow the integrator access to the dims and various high-level operations). Perhaps one solution is to have two levels of interface -- i.e. a low-level one (`get_state`, `set_state`, `integrate`) and a high-level one (`run`) where the signature of `run` changes to `run(initial_qobj, tlist) -> final_qobj` and `run` calls `get_state`, `set_state` and `integrate`?. I will also do a more line by line review shortly.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1643#issuecomment-925113187
https://github.com/qutip/qutip/pull/1643#issuecomment-925113187:39,Integrability,integrat,integrators,39,"@Ericgig Do you have examples of where integrators are used?. Some of the interface choices seem inconsistent -- e.g. `system` is a `QobjEvo` instance (so it has dims) but the states are `data` (which don't have dims, type, etc). Perhaps this makes sense given how things are used, but it would be good to be consistent (especially given that accessing `.data` is very fast and would allow the integrator access to the dims and various high-level operations). Perhaps one solution is to have two levels of interface -- i.e. a low-level one (`get_state`, `set_state`, `integrate`) and a high-level one (`run`) where the signature of `run` changes to `run(initial_qobj, tlist) -> final_qobj` and `run` calls `get_state`, `set_state` and `integrate`?. I will also do a more line by line review shortly.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1643#issuecomment-925113187
https://github.com/qutip/qutip/pull/1643#issuecomment-925113187:74,Integrability,interface,interface,74,"@Ericgig Do you have examples of where integrators are used?. Some of the interface choices seem inconsistent -- e.g. `system` is a `QobjEvo` instance (so it has dims) but the states are `data` (which don't have dims, type, etc). Perhaps this makes sense given how things are used, but it would be good to be consistent (especially given that accessing `.data` is very fast and would allow the integrator access to the dims and various high-level operations). Perhaps one solution is to have two levels of interface -- i.e. a low-level one (`get_state`, `set_state`, `integrate`) and a high-level one (`run`) where the signature of `run` changes to `run(initial_qobj, tlist) -> final_qobj` and `run` calls `get_state`, `set_state` and `integrate`?. I will also do a more line by line review shortly.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1643#issuecomment-925113187
https://github.com/qutip/qutip/pull/1643#issuecomment-925113187:394,Integrability,integrat,integrator,394,"@Ericgig Do you have examples of where integrators are used?. Some of the interface choices seem inconsistent -- e.g. `system` is a `QobjEvo` instance (so it has dims) but the states are `data` (which don't have dims, type, etc). Perhaps this makes sense given how things are used, but it would be good to be consistent (especially given that accessing `.data` is very fast and would allow the integrator access to the dims and various high-level operations). Perhaps one solution is to have two levels of interface -- i.e. a low-level one (`get_state`, `set_state`, `integrate`) and a high-level one (`run`) where the signature of `run` changes to `run(initial_qobj, tlist) -> final_qobj` and `run` calls `get_state`, `set_state` and `integrate`?. I will also do a more line by line review shortly.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1643#issuecomment-925113187
https://github.com/qutip/qutip/pull/1643#issuecomment-925113187:506,Integrability,interface,interface,506,"@Ericgig Do you have examples of where integrators are used?. Some of the interface choices seem inconsistent -- e.g. `system` is a `QobjEvo` instance (so it has dims) but the states are `data` (which don't have dims, type, etc). Perhaps this makes sense given how things are used, but it would be good to be consistent (especially given that accessing `.data` is very fast and would allow the integrator access to the dims and various high-level operations). Perhaps one solution is to have two levels of interface -- i.e. a low-level one (`get_state`, `set_state`, `integrate`) and a high-level one (`run`) where the signature of `run` changes to `run(initial_qobj, tlist) -> final_qobj` and `run` calls `get_state`, `set_state` and `integrate`?. I will also do a more line by line review shortly.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1643#issuecomment-925113187
https://github.com/qutip/qutip/pull/1643#issuecomment-925113187:568,Integrability,integrat,integrate,568,"@Ericgig Do you have examples of where integrators are used?. Some of the interface choices seem inconsistent -- e.g. `system` is a `QobjEvo` instance (so it has dims) but the states are `data` (which don't have dims, type, etc). Perhaps this makes sense given how things are used, but it would be good to be consistent (especially given that accessing `.data` is very fast and would allow the integrator access to the dims and various high-level operations). Perhaps one solution is to have two levels of interface -- i.e. a low-level one (`get_state`, `set_state`, `integrate`) and a high-level one (`run`) where the signature of `run` changes to `run(initial_qobj, tlist) -> final_qobj` and `run` calls `get_state`, `set_state` and `integrate`?. I will also do a more line by line review shortly.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1643#issuecomment-925113187
https://github.com/qutip/qutip/pull/1643#issuecomment-925113187:736,Integrability,integrat,integrate,736,"@Ericgig Do you have examples of where integrators are used?. Some of the interface choices seem inconsistent -- e.g. `system` is a `QobjEvo` instance (so it has dims) but the states are `data` (which don't have dims, type, etc). Perhaps this makes sense given how things are used, but it would be good to be consistent (especially given that accessing `.data` is very fast and would allow the integrator access to the dims and various high-level operations). Perhaps one solution is to have two levels of interface -- i.e. a low-level one (`get_state`, `set_state`, `integrate`) and a high-level one (`run`) where the signature of `run` changes to `run(initial_qobj, tlist) -> final_qobj` and `run` calls `get_state`, `set_state` and `integrate`?. I will also do a more line by line review shortly.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1643#issuecomment-925113187
https://github.com/qutip/qutip/pull/1643#issuecomment-925113187:343,Security,access,accessing,343,"@Ericgig Do you have examples of where integrators are used?. Some of the interface choices seem inconsistent -- e.g. `system` is a `QobjEvo` instance (so it has dims) but the states are `data` (which don't have dims, type, etc). Perhaps this makes sense given how things are used, but it would be good to be consistent (especially given that accessing `.data` is very fast and would allow the integrator access to the dims and various high-level operations). Perhaps one solution is to have two levels of interface -- i.e. a low-level one (`get_state`, `set_state`, `integrate`) and a high-level one (`run`) where the signature of `run` changes to `run(initial_qobj, tlist) -> final_qobj` and `run` calls `get_state`, `set_state` and `integrate`?. I will also do a more line by line review shortly.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1643#issuecomment-925113187
https://github.com/qutip/qutip/pull/1643#issuecomment-925113187:405,Security,access,access,405,"@Ericgig Do you have examples of where integrators are used?. Some of the interface choices seem inconsistent -- e.g. `system` is a `QobjEvo` instance (so it has dims) but the states are `data` (which don't have dims, type, etc). Perhaps this makes sense given how things are used, but it would be good to be consistent (especially given that accessing `.data` is very fast and would allow the integrator access to the dims and various high-level operations). Perhaps one solution is to have two levels of interface -- i.e. a low-level one (`get_state`, `set_state`, `integrate`) and a high-level one (`run`) where the signature of `run` changes to `run(initial_qobj, tlist) -> final_qobj` and `run` calls `get_state`, `set_state` and `integrate`?. I will also do a more line by line review shortly.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1643#issuecomment-925113187
https://github.com/qutip/qutip/pull/1643#issuecomment-925137656:63,Deployability,integrat,integrator,63,"Here is [sesolve](https://github.com/Ericgig/qutip/blob/solver.integrator/qutip/solver/sesolve.py) using it. And here is the [base solver](https://github.com/Ericgig/qutip/blob/solver.integrator/qutip/solver/solver_base.py).; I planned to do the dimension check in the solver. So `Sesolve.step(t)` and will call will `Integrator.integrate` and build the `Qobj`.; Likewise `SeSolver.run` call `Integrator.run`, there the `Result` object create the `Qobj`. I want the solver to copy the state only if it stores it, not if it only compute the expectation values. ; All the physics, which I consider the dims check to be part of, is done at the `Solver` level. We also don't have a no dims `QobjEvo`. . I made the `Integrator` to focus more on the ODE mathematics, but the creation of `Qobj` is quite fast so I don't mind either ways for the input types, but the dims check will still be done at the `Solver` level, not `Integrator`.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1643#issuecomment-925137656
https://github.com/qutip/qutip/pull/1643#issuecomment-925137656:184,Deployability,integrat,integrator,184,"Here is [sesolve](https://github.com/Ericgig/qutip/blob/solver.integrator/qutip/solver/sesolve.py) using it. And here is the [base solver](https://github.com/Ericgig/qutip/blob/solver.integrator/qutip/solver/solver_base.py).; I planned to do the dimension check in the solver. So `Sesolve.step(t)` and will call will `Integrator.integrate` and build the `Qobj`.; Likewise `SeSolver.run` call `Integrator.run`, there the `Result` object create the `Qobj`. I want the solver to copy the state only if it stores it, not if it only compute the expectation values. ; All the physics, which I consider the dims check to be part of, is done at the `Solver` level. We also don't have a no dims `QobjEvo`. . I made the `Integrator` to focus more on the ODE mathematics, but the creation of `Qobj` is quite fast so I don't mind either ways for the input types, but the dims check will still be done at the `Solver` level, not `Integrator`.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1643#issuecomment-925137656
https://github.com/qutip/qutip/pull/1643#issuecomment-925137656:318,Deployability,Integrat,Integrator,318,"Here is [sesolve](https://github.com/Ericgig/qutip/blob/solver.integrator/qutip/solver/sesolve.py) using it. And here is the [base solver](https://github.com/Ericgig/qutip/blob/solver.integrator/qutip/solver/solver_base.py).; I planned to do the dimension check in the solver. So `Sesolve.step(t)` and will call will `Integrator.integrate` and build the `Qobj`.; Likewise `SeSolver.run` call `Integrator.run`, there the `Result` object create the `Qobj`. I want the solver to copy the state only if it stores it, not if it only compute the expectation values. ; All the physics, which I consider the dims check to be part of, is done at the `Solver` level. We also don't have a no dims `QobjEvo`. . I made the `Integrator` to focus more on the ODE mathematics, but the creation of `Qobj` is quite fast so I don't mind either ways for the input types, but the dims check will still be done at the `Solver` level, not `Integrator`.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1643#issuecomment-925137656
https://github.com/qutip/qutip/pull/1643#issuecomment-925137656:329,Deployability,integrat,integrate,329,"Here is [sesolve](https://github.com/Ericgig/qutip/blob/solver.integrator/qutip/solver/sesolve.py) using it. And here is the [base solver](https://github.com/Ericgig/qutip/blob/solver.integrator/qutip/solver/solver_base.py).; I planned to do the dimension check in the solver. So `Sesolve.step(t)` and will call will `Integrator.integrate` and build the `Qobj`.; Likewise `SeSolver.run` call `Integrator.run`, there the `Result` object create the `Qobj`. I want the solver to copy the state only if it stores it, not if it only compute the expectation values. ; All the physics, which I consider the dims check to be part of, is done at the `Solver` level. We also don't have a no dims `QobjEvo`. . I made the `Integrator` to focus more on the ODE mathematics, but the creation of `Qobj` is quite fast so I don't mind either ways for the input types, but the dims check will still be done at the `Solver` level, not `Integrator`.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1643#issuecomment-925137656
https://github.com/qutip/qutip/pull/1643#issuecomment-925137656:393,Deployability,Integrat,Integrator,393,"Here is [sesolve](https://github.com/Ericgig/qutip/blob/solver.integrator/qutip/solver/sesolve.py) using it. And here is the [base solver](https://github.com/Ericgig/qutip/blob/solver.integrator/qutip/solver/solver_base.py).; I planned to do the dimension check in the solver. So `Sesolve.step(t)` and will call will `Integrator.integrate` and build the `Qobj`.; Likewise `SeSolver.run` call `Integrator.run`, there the `Result` object create the `Qobj`. I want the solver to copy the state only if it stores it, not if it only compute the expectation values. ; All the physics, which I consider the dims check to be part of, is done at the `Solver` level. We also don't have a no dims `QobjEvo`. . I made the `Integrator` to focus more on the ODE mathematics, but the creation of `Qobj` is quite fast so I don't mind either ways for the input types, but the dims check will still be done at the `Solver` level, not `Integrator`.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1643#issuecomment-925137656
https://github.com/qutip/qutip/pull/1643#issuecomment-925137656:711,Deployability,Integrat,Integrator,711,"Here is [sesolve](https://github.com/Ericgig/qutip/blob/solver.integrator/qutip/solver/sesolve.py) using it. And here is the [base solver](https://github.com/Ericgig/qutip/blob/solver.integrator/qutip/solver/solver_base.py).; I planned to do the dimension check in the solver. So `Sesolve.step(t)` and will call will `Integrator.integrate` and build the `Qobj`.; Likewise `SeSolver.run` call `Integrator.run`, there the `Result` object create the `Qobj`. I want the solver to copy the state only if it stores it, not if it only compute the expectation values. ; All the physics, which I consider the dims check to be part of, is done at the `Solver` level. We also don't have a no dims `QobjEvo`. . I made the `Integrator` to focus more on the ODE mathematics, but the creation of `Qobj` is quite fast so I don't mind either ways for the input types, but the dims check will still be done at the `Solver` level, not `Integrator`.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1643#issuecomment-925137656
https://github.com/qutip/qutip/pull/1643#issuecomment-925137656:917,Deployability,Integrat,Integrator,917,"Here is [sesolve](https://github.com/Ericgig/qutip/blob/solver.integrator/qutip/solver/sesolve.py) using it. And here is the [base solver](https://github.com/Ericgig/qutip/blob/solver.integrator/qutip/solver/solver_base.py).; I planned to do the dimension check in the solver. So `Sesolve.step(t)` and will call will `Integrator.integrate` and build the `Qobj`.; Likewise `SeSolver.run` call `Integrator.run`, there the `Result` object create the `Qobj`. I want the solver to copy the state only if it stores it, not if it only compute the expectation values. ; All the physics, which I consider the dims check to be part of, is done at the `Solver` level. We also don't have a no dims `QobjEvo`. . I made the `Integrator` to focus more on the ODE mathematics, but the creation of `Qobj` is quite fast so I don't mind either ways for the input types, but the dims check will still be done at the `Solver` level, not `Integrator`.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1643#issuecomment-925137656
https://github.com/qutip/qutip/pull/1643#issuecomment-925137656:63,Integrability,integrat,integrator,63,"Here is [sesolve](https://github.com/Ericgig/qutip/blob/solver.integrator/qutip/solver/sesolve.py) using it. And here is the [base solver](https://github.com/Ericgig/qutip/blob/solver.integrator/qutip/solver/solver_base.py).; I planned to do the dimension check in the solver. So `Sesolve.step(t)` and will call will `Integrator.integrate` and build the `Qobj`.; Likewise `SeSolver.run` call `Integrator.run`, there the `Result` object create the `Qobj`. I want the solver to copy the state only if it stores it, not if it only compute the expectation values. ; All the physics, which I consider the dims check to be part of, is done at the `Solver` level. We also don't have a no dims `QobjEvo`. . I made the `Integrator` to focus more on the ODE mathematics, but the creation of `Qobj` is quite fast so I don't mind either ways for the input types, but the dims check will still be done at the `Solver` level, not `Integrator`.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1643#issuecomment-925137656
https://github.com/qutip/qutip/pull/1643#issuecomment-925137656:184,Integrability,integrat,integrator,184,"Here is [sesolve](https://github.com/Ericgig/qutip/blob/solver.integrator/qutip/solver/sesolve.py) using it. And here is the [base solver](https://github.com/Ericgig/qutip/blob/solver.integrator/qutip/solver/solver_base.py).; I planned to do the dimension check in the solver. So `Sesolve.step(t)` and will call will `Integrator.integrate` and build the `Qobj`.; Likewise `SeSolver.run` call `Integrator.run`, there the `Result` object create the `Qobj`. I want the solver to copy the state only if it stores it, not if it only compute the expectation values. ; All the physics, which I consider the dims check to be part of, is done at the `Solver` level. We also don't have a no dims `QobjEvo`. . I made the `Integrator` to focus more on the ODE mathematics, but the creation of `Qobj` is quite fast so I don't mind either ways for the input types, but the dims check will still be done at the `Solver` level, not `Integrator`.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1643#issuecomment-925137656
https://github.com/qutip/qutip/pull/1643#issuecomment-925137656:318,Integrability,Integrat,Integrator,318,"Here is [sesolve](https://github.com/Ericgig/qutip/blob/solver.integrator/qutip/solver/sesolve.py) using it. And here is the [base solver](https://github.com/Ericgig/qutip/blob/solver.integrator/qutip/solver/solver_base.py).; I planned to do the dimension check in the solver. So `Sesolve.step(t)` and will call will `Integrator.integrate` and build the `Qobj`.; Likewise `SeSolver.run` call `Integrator.run`, there the `Result` object create the `Qobj`. I want the solver to copy the state only if it stores it, not if it only compute the expectation values. ; All the physics, which I consider the dims check to be part of, is done at the `Solver` level. We also don't have a no dims `QobjEvo`. . I made the `Integrator` to focus more on the ODE mathematics, but the creation of `Qobj` is quite fast so I don't mind either ways for the input types, but the dims check will still be done at the `Solver` level, not `Integrator`.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1643#issuecomment-925137656
https://github.com/qutip/qutip/pull/1643#issuecomment-925137656:329,Integrability,integrat,integrate,329,"Here is [sesolve](https://github.com/Ericgig/qutip/blob/solver.integrator/qutip/solver/sesolve.py) using it. And here is the [base solver](https://github.com/Ericgig/qutip/blob/solver.integrator/qutip/solver/solver_base.py).; I planned to do the dimension check in the solver. So `Sesolve.step(t)` and will call will `Integrator.integrate` and build the `Qobj`.; Likewise `SeSolver.run` call `Integrator.run`, there the `Result` object create the `Qobj`. I want the solver to copy the state only if it stores it, not if it only compute the expectation values. ; All the physics, which I consider the dims check to be part of, is done at the `Solver` level. We also don't have a no dims `QobjEvo`. . I made the `Integrator` to focus more on the ODE mathematics, but the creation of `Qobj` is quite fast so I don't mind either ways for the input types, but the dims check will still be done at the `Solver` level, not `Integrator`.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1643#issuecomment-925137656
https://github.com/qutip/qutip/pull/1643#issuecomment-925137656:393,Integrability,Integrat,Integrator,393,"Here is [sesolve](https://github.com/Ericgig/qutip/blob/solver.integrator/qutip/solver/sesolve.py) using it. And here is the [base solver](https://github.com/Ericgig/qutip/blob/solver.integrator/qutip/solver/solver_base.py).; I planned to do the dimension check in the solver. So `Sesolve.step(t)` and will call will `Integrator.integrate` and build the `Qobj`.; Likewise `SeSolver.run` call `Integrator.run`, there the `Result` object create the `Qobj`. I want the solver to copy the state only if it stores it, not if it only compute the expectation values. ; All the physics, which I consider the dims check to be part of, is done at the `Solver` level. We also don't have a no dims `QobjEvo`. . I made the `Integrator` to focus more on the ODE mathematics, but the creation of `Qobj` is quite fast so I don't mind either ways for the input types, but the dims check will still be done at the `Solver` level, not `Integrator`.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1643#issuecomment-925137656
https://github.com/qutip/qutip/pull/1643#issuecomment-925137656:711,Integrability,Integrat,Integrator,711,"Here is [sesolve](https://github.com/Ericgig/qutip/blob/solver.integrator/qutip/solver/sesolve.py) using it. And here is the [base solver](https://github.com/Ericgig/qutip/blob/solver.integrator/qutip/solver/solver_base.py).; I planned to do the dimension check in the solver. So `Sesolve.step(t)` and will call will `Integrator.integrate` and build the `Qobj`.; Likewise `SeSolver.run` call `Integrator.run`, there the `Result` object create the `Qobj`. I want the solver to copy the state only if it stores it, not if it only compute the expectation values. ; All the physics, which I consider the dims check to be part of, is done at the `Solver` level. We also don't have a no dims `QobjEvo`. . I made the `Integrator` to focus more on the ODE mathematics, but the creation of `Qobj` is quite fast so I don't mind either ways for the input types, but the dims check will still be done at the `Solver` level, not `Integrator`.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1643#issuecomment-925137656
https://github.com/qutip/qutip/pull/1643#issuecomment-925137656:917,Integrability,Integrat,Integrator,917,"Here is [sesolve](https://github.com/Ericgig/qutip/blob/solver.integrator/qutip/solver/sesolve.py) using it. And here is the [base solver](https://github.com/Ericgig/qutip/blob/solver.integrator/qutip/solver/solver_base.py).; I planned to do the dimension check in the solver. So `Sesolve.step(t)` and will call will `Integrator.integrate` and build the `Qobj`.; Likewise `SeSolver.run` call `Integrator.run`, there the `Result` object create the `Qobj`. I want the solver to copy the state only if it stores it, not if it only compute the expectation values. ; All the physics, which I consider the dims check to be part of, is done at the `Solver` level. We also don't have a no dims `QobjEvo`. . I made the `Integrator` to focus more on the ODE mathematics, but the creation of `Qobj` is quite fast so I don't mind either ways for the input types, but the dims check will still be done at the `Solver` level, not `Integrator`.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1643#issuecomment-925137656
https://github.com/qutip/qutip/pull/1643#issuecomment-925428011:127,Deployability,integrat,integrators,127,"Thank you for doing this quickly, I guess you did until quite late. Yes, tests in `test_integrator` are parameterized over all integrators registered in `sesolve_integrators`, etc.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1643#issuecomment-925428011
https://github.com/qutip/qutip/pull/1643#issuecomment-925428011:127,Integrability,integrat,integrators,127,"Thank you for doing this quickly, I guess you did until quite late. Yes, tests in `test_integrator` are parameterized over all integrators registered in `sesolve_integrators`, etc.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1643#issuecomment-925428011
https://github.com/qutip/qutip/pull/1643#issuecomment-925428011:104,Modifiability,parameteriz,parameterized,104,"Thank you for doing this quickly, I guess you did until quite late. Yes, tests in `test_integrator` are parameterized over all integrators registered in `sesolve_integrators`, etc.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1643#issuecomment-925428011
https://github.com/qutip/qutip/pull/1643#issuecomment-925428011:73,Testability,test,tests,73,"Thank you for doing this quickly, I guess you did until quite late. Yes, tests in `test_integrator` are parameterized over all integrators registered in `sesolve_integrators`, etc.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1643#issuecomment-925428011
https://github.com/qutip/qutip/pull/1643#issuecomment-925988667:16,Deployability,integrat,integrate,16,"> I think the `.integrate(t, step=....)` interface is currently way too complex, as evidenced by the difficulty of implementing it and the hard to resolve issues.; > ; > SciPy has a much simpler ODE interface -- see https://github.com/scipy/scipy/blob/v1.7.1/scipy/integrate/_ivp/base.py#L25-L214. Essentially a single `.step()` function.; > ; > Is there a reason we could not implement something similar here, and just have one `.step()` method and then implement `.integrate()` on top of that?. The `.step()` is essentially `.integrate(self.t)`, sot there would be no need for both.; If you mean having `step()` always advance one internal integrator step, we don't always have that possibility, `dop853` cannot advance only one step. And it would require to safe `self.back` each time even when not needed.; If you want a method to just advance to the time `t`, what ever it is as `scipy` seems to do, it will crush `mcsolve` speed. `mcsolve` has a root finding step that require a some back and forth and ode schemes all have their quirks when doing this. For actual use `integrate`, `step` and `backstep` can be 3 methods. I had this in the evolver PR but was told to merge them... The complexity could be split: have `integrate` for normal evolution (`sesovle`, `mesolve`), and `step` or `mcstep` for `mcsolve`.; This would also make it easier to create new Integrator for special use, it is easier to choose not to support `mcsolve` if the logic is split.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1643#issuecomment-925988667
https://github.com/qutip/qutip/pull/1643#issuecomment-925988667:265,Deployability,integrat,integrate,265,"> I think the `.integrate(t, step=....)` interface is currently way too complex, as evidenced by the difficulty of implementing it and the hard to resolve issues.; > ; > SciPy has a much simpler ODE interface -- see https://github.com/scipy/scipy/blob/v1.7.1/scipy/integrate/_ivp/base.py#L25-L214. Essentially a single `.step()` function.; > ; > Is there a reason we could not implement something similar here, and just have one `.step()` method and then implement `.integrate()` on top of that?. The `.step()` is essentially `.integrate(self.t)`, sot there would be no need for both.; If you mean having `step()` always advance one internal integrator step, we don't always have that possibility, `dop853` cannot advance only one step. And it would require to safe `self.back` each time even when not needed.; If you want a method to just advance to the time `t`, what ever it is as `scipy` seems to do, it will crush `mcsolve` speed. `mcsolve` has a root finding step that require a some back and forth and ode schemes all have their quirks when doing this. For actual use `integrate`, `step` and `backstep` can be 3 methods. I had this in the evolver PR but was told to merge them... The complexity could be split: have `integrate` for normal evolution (`sesovle`, `mesolve`), and `step` or `mcstep` for `mcsolve`.; This would also make it easier to create new Integrator for special use, it is easier to choose not to support `mcsolve` if the logic is split.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1643#issuecomment-925988667
https://github.com/qutip/qutip/pull/1643#issuecomment-925988667:467,Deployability,integrat,integrate,467,"> I think the `.integrate(t, step=....)` interface is currently way too complex, as evidenced by the difficulty of implementing it and the hard to resolve issues.; > ; > SciPy has a much simpler ODE interface -- see https://github.com/scipy/scipy/blob/v1.7.1/scipy/integrate/_ivp/base.py#L25-L214. Essentially a single `.step()` function.; > ; > Is there a reason we could not implement something similar here, and just have one `.step()` method and then implement `.integrate()` on top of that?. The `.step()` is essentially `.integrate(self.t)`, sot there would be no need for both.; If you mean having `step()` always advance one internal integrator step, we don't always have that possibility, `dop853` cannot advance only one step. And it would require to safe `self.back` each time even when not needed.; If you want a method to just advance to the time `t`, what ever it is as `scipy` seems to do, it will crush `mcsolve` speed. `mcsolve` has a root finding step that require a some back and forth and ode schemes all have their quirks when doing this. For actual use `integrate`, `step` and `backstep` can be 3 methods. I had this in the evolver PR but was told to merge them... The complexity could be split: have `integrate` for normal evolution (`sesovle`, `mesolve`), and `step` or `mcstep` for `mcsolve`.; This would also make it easier to create new Integrator for special use, it is easier to choose not to support `mcsolve` if the logic is split.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1643#issuecomment-925988667
https://github.com/qutip/qutip/pull/1643#issuecomment-925988667:528,Deployability,integrat,integrate,528,"> I think the `.integrate(t, step=....)` interface is currently way too complex, as evidenced by the difficulty of implementing it and the hard to resolve issues.; > ; > SciPy has a much simpler ODE interface -- see https://github.com/scipy/scipy/blob/v1.7.1/scipy/integrate/_ivp/base.py#L25-L214. Essentially a single `.step()` function.; > ; > Is there a reason we could not implement something similar here, and just have one `.step()` method and then implement `.integrate()` on top of that?. The `.step()` is essentially `.integrate(self.t)`, sot there would be no need for both.; If you mean having `step()` always advance one internal integrator step, we don't always have that possibility, `dop853` cannot advance only one step. And it would require to safe `self.back` each time even when not needed.; If you want a method to just advance to the time `t`, what ever it is as `scipy` seems to do, it will crush `mcsolve` speed. `mcsolve` has a root finding step that require a some back and forth and ode schemes all have their quirks when doing this. For actual use `integrate`, `step` and `backstep` can be 3 methods. I had this in the evolver PR but was told to merge them... The complexity could be split: have `integrate` for normal evolution (`sesovle`, `mesolve`), and `step` or `mcstep` for `mcsolve`.; This would also make it easier to create new Integrator for special use, it is easier to choose not to support `mcsolve` if the logic is split.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1643#issuecomment-925988667
https://github.com/qutip/qutip/pull/1643#issuecomment-925988667:642,Deployability,integrat,integrator,642,"> I think the `.integrate(t, step=....)` interface is currently way too complex, as evidenced by the difficulty of implementing it and the hard to resolve issues.; > ; > SciPy has a much simpler ODE interface -- see https://github.com/scipy/scipy/blob/v1.7.1/scipy/integrate/_ivp/base.py#L25-L214. Essentially a single `.step()` function.; > ; > Is there a reason we could not implement something similar here, and just have one `.step()` method and then implement `.integrate()` on top of that?. The `.step()` is essentially `.integrate(self.t)`, sot there would be no need for both.; If you mean having `step()` always advance one internal integrator step, we don't always have that possibility, `dop853` cannot advance only one step. And it would require to safe `self.back` each time even when not needed.; If you want a method to just advance to the time `t`, what ever it is as `scipy` seems to do, it will crush `mcsolve` speed. `mcsolve` has a root finding step that require a some back and forth and ode schemes all have their quirks when doing this. For actual use `integrate`, `step` and `backstep` can be 3 methods. I had this in the evolver PR but was told to merge them... The complexity could be split: have `integrate` for normal evolution (`sesovle`, `mesolve`), and `step` or `mcstep` for `mcsolve`.; This would also make it easier to create new Integrator for special use, it is easier to choose not to support `mcsolve` if the logic is split.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1643#issuecomment-925988667
https://github.com/qutip/qutip/pull/1643#issuecomment-925988667:1076,Deployability,integrat,integrate,1076,"> I think the `.integrate(t, step=....)` interface is currently way too complex, as evidenced by the difficulty of implementing it and the hard to resolve issues.; > ; > SciPy has a much simpler ODE interface -- see https://github.com/scipy/scipy/blob/v1.7.1/scipy/integrate/_ivp/base.py#L25-L214. Essentially a single `.step()` function.; > ; > Is there a reason we could not implement something similar here, and just have one `.step()` method and then implement `.integrate()` on top of that?. The `.step()` is essentially `.integrate(self.t)`, sot there would be no need for both.; If you mean having `step()` always advance one internal integrator step, we don't always have that possibility, `dop853` cannot advance only one step. And it would require to safe `self.back` each time even when not needed.; If you want a method to just advance to the time `t`, what ever it is as `scipy` seems to do, it will crush `mcsolve` speed. `mcsolve` has a root finding step that require a some back and forth and ode schemes all have their quirks when doing this. For actual use `integrate`, `step` and `backstep` can be 3 methods. I had this in the evolver PR but was told to merge them... The complexity could be split: have `integrate` for normal evolution (`sesovle`, `mesolve`), and `step` or `mcstep` for `mcsolve`.; This would also make it easier to create new Integrator for special use, it is easier to choose not to support `mcsolve` if the logic is split.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1643#issuecomment-925988667
https://github.com/qutip/qutip/pull/1643#issuecomment-925988667:1224,Deployability,integrat,integrate,1224,"> I think the `.integrate(t, step=....)` interface is currently way too complex, as evidenced by the difficulty of implementing it and the hard to resolve issues.; > ; > SciPy has a much simpler ODE interface -- see https://github.com/scipy/scipy/blob/v1.7.1/scipy/integrate/_ivp/base.py#L25-L214. Essentially a single `.step()` function.; > ; > Is there a reason we could not implement something similar here, and just have one `.step()` method and then implement `.integrate()` on top of that?. The `.step()` is essentially `.integrate(self.t)`, sot there would be no need for both.; If you mean having `step()` always advance one internal integrator step, we don't always have that possibility, `dop853` cannot advance only one step. And it would require to safe `self.back` each time even when not needed.; If you want a method to just advance to the time `t`, what ever it is as `scipy` seems to do, it will crush `mcsolve` speed. `mcsolve` has a root finding step that require a some back and forth and ode schemes all have their quirks when doing this. For actual use `integrate`, `step` and `backstep` can be 3 methods. I had this in the evolver PR but was told to merge them... The complexity could be split: have `integrate` for normal evolution (`sesovle`, `mesolve`), and `step` or `mcstep` for `mcsolve`.; This would also make it easier to create new Integrator for special use, it is easier to choose not to support `mcsolve` if the logic is split.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1643#issuecomment-925988667
https://github.com/qutip/qutip/pull/1643#issuecomment-925988667:1364,Deployability,Integrat,Integrator,1364,"> I think the `.integrate(t, step=....)` interface is currently way too complex, as evidenced by the difficulty of implementing it and the hard to resolve issues.; > ; > SciPy has a much simpler ODE interface -- see https://github.com/scipy/scipy/blob/v1.7.1/scipy/integrate/_ivp/base.py#L25-L214. Essentially a single `.step()` function.; > ; > Is there a reason we could not implement something similar here, and just have one `.step()` method and then implement `.integrate()` on top of that?. The `.step()` is essentially `.integrate(self.t)`, sot there would be no need for both.; If you mean having `step()` always advance one internal integrator step, we don't always have that possibility, `dop853` cannot advance only one step. And it would require to safe `self.back` each time even when not needed.; If you want a method to just advance to the time `t`, what ever it is as `scipy` seems to do, it will crush `mcsolve` speed. `mcsolve` has a root finding step that require a some back and forth and ode schemes all have their quirks when doing this. For actual use `integrate`, `step` and `backstep` can be 3 methods. I had this in the evolver PR but was told to merge them... The complexity could be split: have `integrate` for normal evolution (`sesovle`, `mesolve`), and `step` or `mcstep` for `mcsolve`.; This would also make it easier to create new Integrator for special use, it is easier to choose not to support `mcsolve` if the logic is split.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1643#issuecomment-925988667
https://github.com/qutip/qutip/pull/1643#issuecomment-925988667:16,Integrability,integrat,integrate,16,"> I think the `.integrate(t, step=....)` interface is currently way too complex, as evidenced by the difficulty of implementing it and the hard to resolve issues.; > ; > SciPy has a much simpler ODE interface -- see https://github.com/scipy/scipy/blob/v1.7.1/scipy/integrate/_ivp/base.py#L25-L214. Essentially a single `.step()` function.; > ; > Is there a reason we could not implement something similar here, and just have one `.step()` method and then implement `.integrate()` on top of that?. The `.step()` is essentially `.integrate(self.t)`, sot there would be no need for both.; If you mean having `step()` always advance one internal integrator step, we don't always have that possibility, `dop853` cannot advance only one step. And it would require to safe `self.back` each time even when not needed.; If you want a method to just advance to the time `t`, what ever it is as `scipy` seems to do, it will crush `mcsolve` speed. `mcsolve` has a root finding step that require a some back and forth and ode schemes all have their quirks when doing this. For actual use `integrate`, `step` and `backstep` can be 3 methods. I had this in the evolver PR but was told to merge them... The complexity could be split: have `integrate` for normal evolution (`sesovle`, `mesolve`), and `step` or `mcstep` for `mcsolve`.; This would also make it easier to create new Integrator for special use, it is easier to choose not to support `mcsolve` if the logic is split.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1643#issuecomment-925988667
https://github.com/qutip/qutip/pull/1643#issuecomment-925988667:41,Integrability,interface,interface,41,"> I think the `.integrate(t, step=....)` interface is currently way too complex, as evidenced by the difficulty of implementing it and the hard to resolve issues.; > ; > SciPy has a much simpler ODE interface -- see https://github.com/scipy/scipy/blob/v1.7.1/scipy/integrate/_ivp/base.py#L25-L214. Essentially a single `.step()` function.; > ; > Is there a reason we could not implement something similar here, and just have one `.step()` method and then implement `.integrate()` on top of that?. The `.step()` is essentially `.integrate(self.t)`, sot there would be no need for both.; If you mean having `step()` always advance one internal integrator step, we don't always have that possibility, `dop853` cannot advance only one step. And it would require to safe `self.back` each time even when not needed.; If you want a method to just advance to the time `t`, what ever it is as `scipy` seems to do, it will crush `mcsolve` speed. `mcsolve` has a root finding step that require a some back and forth and ode schemes all have their quirks when doing this. For actual use `integrate`, `step` and `backstep` can be 3 methods. I had this in the evolver PR but was told to merge them... The complexity could be split: have `integrate` for normal evolution (`sesovle`, `mesolve`), and `step` or `mcstep` for `mcsolve`.; This would also make it easier to create new Integrator for special use, it is easier to choose not to support `mcsolve` if the logic is split.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1643#issuecomment-925988667
https://github.com/qutip/qutip/pull/1643#issuecomment-925988667:199,Integrability,interface,interface,199,"> I think the `.integrate(t, step=....)` interface is currently way too complex, as evidenced by the difficulty of implementing it and the hard to resolve issues.; > ; > SciPy has a much simpler ODE interface -- see https://github.com/scipy/scipy/blob/v1.7.1/scipy/integrate/_ivp/base.py#L25-L214. Essentially a single `.step()` function.; > ; > Is there a reason we could not implement something similar here, and just have one `.step()` method and then implement `.integrate()` on top of that?. The `.step()` is essentially `.integrate(self.t)`, sot there would be no need for both.; If you mean having `step()` always advance one internal integrator step, we don't always have that possibility, `dop853` cannot advance only one step. And it would require to safe `self.back` each time even when not needed.; If you want a method to just advance to the time `t`, what ever it is as `scipy` seems to do, it will crush `mcsolve` speed. `mcsolve` has a root finding step that require a some back and forth and ode schemes all have their quirks when doing this. For actual use `integrate`, `step` and `backstep` can be 3 methods. I had this in the evolver PR but was told to merge them... The complexity could be split: have `integrate` for normal evolution (`sesovle`, `mesolve`), and `step` or `mcstep` for `mcsolve`.; This would also make it easier to create new Integrator for special use, it is easier to choose not to support `mcsolve` if the logic is split.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1643#issuecomment-925988667
https://github.com/qutip/qutip/pull/1643#issuecomment-925988667:265,Integrability,integrat,integrate,265,"> I think the `.integrate(t, step=....)` interface is currently way too complex, as evidenced by the difficulty of implementing it and the hard to resolve issues.; > ; > SciPy has a much simpler ODE interface -- see https://github.com/scipy/scipy/blob/v1.7.1/scipy/integrate/_ivp/base.py#L25-L214. Essentially a single `.step()` function.; > ; > Is there a reason we could not implement something similar here, and just have one `.step()` method and then implement `.integrate()` on top of that?. The `.step()` is essentially `.integrate(self.t)`, sot there would be no need for both.; If you mean having `step()` always advance one internal integrator step, we don't always have that possibility, `dop853` cannot advance only one step. And it would require to safe `self.back` each time even when not needed.; If you want a method to just advance to the time `t`, what ever it is as `scipy` seems to do, it will crush `mcsolve` speed. `mcsolve` has a root finding step that require a some back and forth and ode schemes all have their quirks when doing this. For actual use `integrate`, `step` and `backstep` can be 3 methods. I had this in the evolver PR but was told to merge them... The complexity could be split: have `integrate` for normal evolution (`sesovle`, `mesolve`), and `step` or `mcstep` for `mcsolve`.; This would also make it easier to create new Integrator for special use, it is easier to choose not to support `mcsolve` if the logic is split.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1643#issuecomment-925988667
https://github.com/qutip/qutip/pull/1643#issuecomment-925988667:467,Integrability,integrat,integrate,467,"> I think the `.integrate(t, step=....)` interface is currently way too complex, as evidenced by the difficulty of implementing it and the hard to resolve issues.; > ; > SciPy has a much simpler ODE interface -- see https://github.com/scipy/scipy/blob/v1.7.1/scipy/integrate/_ivp/base.py#L25-L214. Essentially a single `.step()` function.; > ; > Is there a reason we could not implement something similar here, and just have one `.step()` method and then implement `.integrate()` on top of that?. The `.step()` is essentially `.integrate(self.t)`, sot there would be no need for both.; If you mean having `step()` always advance one internal integrator step, we don't always have that possibility, `dop853` cannot advance only one step. And it would require to safe `self.back` each time even when not needed.; If you want a method to just advance to the time `t`, what ever it is as `scipy` seems to do, it will crush `mcsolve` speed. `mcsolve` has a root finding step that require a some back and forth and ode schemes all have their quirks when doing this. For actual use `integrate`, `step` and `backstep` can be 3 methods. I had this in the evolver PR but was told to merge them... The complexity could be split: have `integrate` for normal evolution (`sesovle`, `mesolve`), and `step` or `mcstep` for `mcsolve`.; This would also make it easier to create new Integrator for special use, it is easier to choose not to support `mcsolve` if the logic is split.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1643#issuecomment-925988667
https://github.com/qutip/qutip/pull/1643#issuecomment-925988667:528,Integrability,integrat,integrate,528,"> I think the `.integrate(t, step=....)` interface is currently way too complex, as evidenced by the difficulty of implementing it and the hard to resolve issues.; > ; > SciPy has a much simpler ODE interface -- see https://github.com/scipy/scipy/blob/v1.7.1/scipy/integrate/_ivp/base.py#L25-L214. Essentially a single `.step()` function.; > ; > Is there a reason we could not implement something similar here, and just have one `.step()` method and then implement `.integrate()` on top of that?. The `.step()` is essentially `.integrate(self.t)`, sot there would be no need for both.; If you mean having `step()` always advance one internal integrator step, we don't always have that possibility, `dop853` cannot advance only one step. And it would require to safe `self.back` each time even when not needed.; If you want a method to just advance to the time `t`, what ever it is as `scipy` seems to do, it will crush `mcsolve` speed. `mcsolve` has a root finding step that require a some back and forth and ode schemes all have their quirks when doing this. For actual use `integrate`, `step` and `backstep` can be 3 methods. I had this in the evolver PR but was told to merge them... The complexity could be split: have `integrate` for normal evolution (`sesovle`, `mesolve`), and `step` or `mcstep` for `mcsolve`.; This would also make it easier to create new Integrator for special use, it is easier to choose not to support `mcsolve` if the logic is split.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1643#issuecomment-925988667
https://github.com/qutip/qutip/pull/1643#issuecomment-925988667:642,Integrability,integrat,integrator,642,"> I think the `.integrate(t, step=....)` interface is currently way too complex, as evidenced by the difficulty of implementing it and the hard to resolve issues.; > ; > SciPy has a much simpler ODE interface -- see https://github.com/scipy/scipy/blob/v1.7.1/scipy/integrate/_ivp/base.py#L25-L214. Essentially a single `.step()` function.; > ; > Is there a reason we could not implement something similar here, and just have one `.step()` method and then implement `.integrate()` on top of that?. The `.step()` is essentially `.integrate(self.t)`, sot there would be no need for both.; If you mean having `step()` always advance one internal integrator step, we don't always have that possibility, `dop853` cannot advance only one step. And it would require to safe `self.back` each time even when not needed.; If you want a method to just advance to the time `t`, what ever it is as `scipy` seems to do, it will crush `mcsolve` speed. `mcsolve` has a root finding step that require a some back and forth and ode schemes all have their quirks when doing this. For actual use `integrate`, `step` and `backstep` can be 3 methods. I had this in the evolver PR but was told to merge them... The complexity could be split: have `integrate` for normal evolution (`sesovle`, `mesolve`), and `step` or `mcstep` for `mcsolve`.; This would also make it easier to create new Integrator for special use, it is easier to choose not to support `mcsolve` if the logic is split.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1643#issuecomment-925988667
https://github.com/qutip/qutip/pull/1643#issuecomment-925988667:1076,Integrability,integrat,integrate,1076,"> I think the `.integrate(t, step=....)` interface is currently way too complex, as evidenced by the difficulty of implementing it and the hard to resolve issues.; > ; > SciPy has a much simpler ODE interface -- see https://github.com/scipy/scipy/blob/v1.7.1/scipy/integrate/_ivp/base.py#L25-L214. Essentially a single `.step()` function.; > ; > Is there a reason we could not implement something similar here, and just have one `.step()` method and then implement `.integrate()` on top of that?. The `.step()` is essentially `.integrate(self.t)`, sot there would be no need for both.; If you mean having `step()` always advance one internal integrator step, we don't always have that possibility, `dop853` cannot advance only one step. And it would require to safe `self.back` each time even when not needed.; If you want a method to just advance to the time `t`, what ever it is as `scipy` seems to do, it will crush `mcsolve` speed. `mcsolve` has a root finding step that require a some back and forth and ode schemes all have their quirks when doing this. For actual use `integrate`, `step` and `backstep` can be 3 methods. I had this in the evolver PR but was told to merge them... The complexity could be split: have `integrate` for normal evolution (`sesovle`, `mesolve`), and `step` or `mcstep` for `mcsolve`.; This would also make it easier to create new Integrator for special use, it is easier to choose not to support `mcsolve` if the logic is split.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1643#issuecomment-925988667
https://github.com/qutip/qutip/pull/1643#issuecomment-925988667:1224,Integrability,integrat,integrate,1224,"> I think the `.integrate(t, step=....)` interface is currently way too complex, as evidenced by the difficulty of implementing it and the hard to resolve issues.; > ; > SciPy has a much simpler ODE interface -- see https://github.com/scipy/scipy/blob/v1.7.1/scipy/integrate/_ivp/base.py#L25-L214. Essentially a single `.step()` function.; > ; > Is there a reason we could not implement something similar here, and just have one `.step()` method and then implement `.integrate()` on top of that?. The `.step()` is essentially `.integrate(self.t)`, sot there would be no need for both.; If you mean having `step()` always advance one internal integrator step, we don't always have that possibility, `dop853` cannot advance only one step. And it would require to safe `self.back` each time even when not needed.; If you want a method to just advance to the time `t`, what ever it is as `scipy` seems to do, it will crush `mcsolve` speed. `mcsolve` has a root finding step that require a some back and forth and ode schemes all have their quirks when doing this. For actual use `integrate`, `step` and `backstep` can be 3 methods. I had this in the evolver PR but was told to merge them... The complexity could be split: have `integrate` for normal evolution (`sesovle`, `mesolve`), and `step` or `mcstep` for `mcsolve`.; This would also make it easier to create new Integrator for special use, it is easier to choose not to support `mcsolve` if the logic is split.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1643#issuecomment-925988667
https://github.com/qutip/qutip/pull/1643#issuecomment-925988667:1364,Integrability,Integrat,Integrator,1364,"> I think the `.integrate(t, step=....)` interface is currently way too complex, as evidenced by the difficulty of implementing it and the hard to resolve issues.; > ; > SciPy has a much simpler ODE interface -- see https://github.com/scipy/scipy/blob/v1.7.1/scipy/integrate/_ivp/base.py#L25-L214. Essentially a single `.step()` function.; > ; > Is there a reason we could not implement something similar here, and just have one `.step()` method and then implement `.integrate()` on top of that?. The `.step()` is essentially `.integrate(self.t)`, sot there would be no need for both.; If you mean having `step()` always advance one internal integrator step, we don't always have that possibility, `dop853` cannot advance only one step. And it would require to safe `self.back` each time even when not needed.; If you want a method to just advance to the time `t`, what ever it is as `scipy` seems to do, it will crush `mcsolve` speed. `mcsolve` has a root finding step that require a some back and forth and ode schemes all have their quirks when doing this. For actual use `integrate`, `step` and `backstep` can be 3 methods. I had this in the evolver PR but was told to merge them... The complexity could be split: have `integrate` for normal evolution (`sesovle`, `mesolve`), and `step` or `mcstep` for `mcsolve`.; This would also make it easier to create new Integrator for special use, it is easier to choose not to support `mcsolve` if the logic is split.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1643#issuecomment-925988667
https://github.com/qutip/qutip/pull/1643#issuecomment-925988667:1146,Modifiability,evolve,evolver,1146,"> I think the `.integrate(t, step=....)` interface is currently way too complex, as evidenced by the difficulty of implementing it and the hard to resolve issues.; > ; > SciPy has a much simpler ODE interface -- see https://github.com/scipy/scipy/blob/v1.7.1/scipy/integrate/_ivp/base.py#L25-L214. Essentially a single `.step()` function.; > ; > Is there a reason we could not implement something similar here, and just have one `.step()` method and then implement `.integrate()` on top of that?. The `.step()` is essentially `.integrate(self.t)`, sot there would be no need for both.; If you mean having `step()` always advance one internal integrator step, we don't always have that possibility, `dop853` cannot advance only one step. And it would require to safe `self.back` each time even when not needed.; If you want a method to just advance to the time `t`, what ever it is as `scipy` seems to do, it will crush `mcsolve` speed. `mcsolve` has a root finding step that require a some back and forth and ode schemes all have their quirks when doing this. For actual use `integrate`, `step` and `backstep` can be 3 methods. I had this in the evolver PR but was told to merge them... The complexity could be split: have `integrate` for normal evolution (`sesovle`, `mesolve`), and `step` or `mcstep` for `mcsolve`.; This would also make it easier to create new Integrator for special use, it is easier to choose not to support `mcsolve` if the logic is split.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1643#issuecomment-925988667
https://github.com/qutip/qutip/pull/1643#issuecomment-925988667:761,Safety,safe,safe,761,"> I think the `.integrate(t, step=....)` interface is currently way too complex, as evidenced by the difficulty of implementing it and the hard to resolve issues.; > ; > SciPy has a much simpler ODE interface -- see https://github.com/scipy/scipy/blob/v1.7.1/scipy/integrate/_ivp/base.py#L25-L214. Essentially a single `.step()` function.; > ; > Is there a reason we could not implement something similar here, and just have one `.step()` method and then implement `.integrate()` on top of that?. The `.step()` is essentially `.integrate(self.t)`, sot there would be no need for both.; If you mean having `step()` always advance one internal integrator step, we don't always have that possibility, `dop853` cannot advance only one step. And it would require to safe `self.back` each time even when not needed.; If you want a method to just advance to the time `t`, what ever it is as `scipy` seems to do, it will crush `mcsolve` speed. `mcsolve` has a root finding step that require a some back and forth and ode schemes all have their quirks when doing this. For actual use `integrate`, `step` and `backstep` can be 3 methods. I had this in the evolver PR but was told to merge them... The complexity could be split: have `integrate` for normal evolution (`sesovle`, `mesolve`), and `step` or `mcstep` for `mcsolve`.; This would also make it easier to create new Integrator for special use, it is easier to choose not to support `mcsolve` if the logic is split.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1643#issuecomment-925988667
https://github.com/qutip/qutip/pull/1643#issuecomment-925988667:1447,Testability,log,logic,1447,"> I think the `.integrate(t, step=....)` interface is currently way too complex, as evidenced by the difficulty of implementing it and the hard to resolve issues.; > ; > SciPy has a much simpler ODE interface -- see https://github.com/scipy/scipy/blob/v1.7.1/scipy/integrate/_ivp/base.py#L25-L214. Essentially a single `.step()` function.; > ; > Is there a reason we could not implement something similar here, and just have one `.step()` method and then implement `.integrate()` on top of that?. The `.step()` is essentially `.integrate(self.t)`, sot there would be no need for both.; If you mean having `step()` always advance one internal integrator step, we don't always have that possibility, `dop853` cannot advance only one step. And it would require to safe `self.back` each time even when not needed.; If you want a method to just advance to the time `t`, what ever it is as `scipy` seems to do, it will crush `mcsolve` speed. `mcsolve` has a root finding step that require a some back and forth and ode schemes all have their quirks when doing this. For actual use `integrate`, `step` and `backstep` can be 3 methods. I had this in the evolver PR but was told to merge them... The complexity could be split: have `integrate` for normal evolution (`sesovle`, `mesolve`), and `step` or `mcstep` for `mcsolve`.; This would also make it easier to create new Integrator for special use, it is easier to choose not to support `mcsolve` if the logic is split.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1643#issuecomment-925988667
https://github.com/qutip/qutip/pull/1643#issuecomment-925988667:187,Usability,simpl,simpler,187,"> I think the `.integrate(t, step=....)` interface is currently way too complex, as evidenced by the difficulty of implementing it and the hard to resolve issues.; > ; > SciPy has a much simpler ODE interface -- see https://github.com/scipy/scipy/blob/v1.7.1/scipy/integrate/_ivp/base.py#L25-L214. Essentially a single `.step()` function.; > ; > Is there a reason we could not implement something similar here, and just have one `.step()` method and then implement `.integrate()` on top of that?. The `.step()` is essentially `.integrate(self.t)`, sot there would be no need for both.; If you mean having `step()` always advance one internal integrator step, we don't always have that possibility, `dop853` cannot advance only one step. And it would require to safe `self.back` each time even when not needed.; If you want a method to just advance to the time `t`, what ever it is as `scipy` seems to do, it will crush `mcsolve` speed. `mcsolve` has a root finding step that require a some back and forth and ode schemes all have their quirks when doing this. For actual use `integrate`, `step` and `backstep` can be 3 methods. I had this in the evolver PR but was told to merge them... The complexity could be split: have `integrate` for normal evolution (`sesovle`, `mesolve`), and `step` or `mcstep` for `mcsolve`.; This would also make it easier to create new Integrator for special use, it is easier to choose not to support `mcsolve` if the logic is split.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1643#issuecomment-925988667
https://github.com/qutip/qutip/pull/1643#issuecomment-933862294:297,Integrability,depend,depending,297,"@hodgestar ; I added default values to options and a default `mcstep`. I added a doc-string entry for `integrator_options`, but please check it. About `mcstep` optimization for scipy's `ode`, I tested both the methods and there can be a factor 2 in timing between both, but it can be in both ways depending on the conditions. So I used `mcsolve`'s method for `zvode` and the new method for `lsoda`. This way, the default will run like `v4`, but you have an alternative when it's not ideal.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1643#issuecomment-933862294
https://github.com/qutip/qutip/pull/1643#issuecomment-933862294:160,Performance,optimiz,optimization,160,"@hodgestar ; I added default values to options and a default `mcstep`. I added a doc-string entry for `integrator_options`, but please check it. About `mcstep` optimization for scipy's `ode`, I tested both the methods and there can be a factor 2 in timing between both, but it can be in both ways depending on the conditions. So I used `mcsolve`'s method for `zvode` and the new method for `lsoda`. This way, the default will run like `v4`, but you have an alternative when it's not ideal.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1643#issuecomment-933862294
https://github.com/qutip/qutip/pull/1643#issuecomment-933862294:194,Testability,test,tested,194,"@hodgestar ; I added default values to options and a default `mcstep`. I added a doc-string entry for `integrator_options`, but please check it. About `mcstep` optimization for scipy's `ode`, I tested both the methods and there can be a factor 2 in timing between both, but it can be in both ways depending on the conditions. So I used `mcsolve`'s method for `zvode` and the new method for `lsoda`. This way, the default will run like `v4`, but you have an alternative when it's not ideal.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1643#issuecomment-933862294
https://github.com/qutip/qutip/pull/1644#issuecomment-908484939:53,Deployability,integrat,integrator,53,"@nathanshammah ; I expect it to be easy to use as an integrator:; ` _evolve_krylov_tlist` is essentially the `run`, `time_evolution` is `integrate`.; The interface just need to be adapted.; It would work well with `sesolve` and `mcsolve`.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1644#issuecomment-908484939
https://github.com/qutip/qutip/pull/1644#issuecomment-908484939:137,Deployability,integrat,integrate,137,"@nathanshammah ; I expect it to be easy to use as an integrator:; ` _evolve_krylov_tlist` is essentially the `run`, `time_evolution` is `integrate`.; The interface just need to be adapted.; It would work well with `sesolve` and `mcsolve`.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1644#issuecomment-908484939
https://github.com/qutip/qutip/pull/1644#issuecomment-908484939:180,Energy Efficiency,adapt,adapted,180,"@nathanshammah ; I expect it to be easy to use as an integrator:; ` _evolve_krylov_tlist` is essentially the `run`, `time_evolution` is `integrate`.; The interface just need to be adapted.; It would work well with `sesolve` and `mcsolve`.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1644#issuecomment-908484939
https://github.com/qutip/qutip/pull/1644#issuecomment-908484939:53,Integrability,integrat,integrator,53,"@nathanshammah ; I expect it to be easy to use as an integrator:; ` _evolve_krylov_tlist` is essentially the `run`, `time_evolution` is `integrate`.; The interface just need to be adapted.; It would work well with `sesolve` and `mcsolve`.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1644#issuecomment-908484939
https://github.com/qutip/qutip/pull/1644#issuecomment-908484939:137,Integrability,integrat,integrate,137,"@nathanshammah ; I expect it to be easy to use as an integrator:; ` _evolve_krylov_tlist` is essentially the `run`, `time_evolution` is `integrate`.; The interface just need to be adapted.; It would work well with `sesolve` and `mcsolve`.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1644#issuecomment-908484939
https://github.com/qutip/qutip/pull/1644#issuecomment-908484939:154,Integrability,interface,interface,154,"@nathanshammah ; I expect it to be easy to use as an integrator:; ` _evolve_krylov_tlist` is essentially the `run`, `time_evolution` is `integrate`.; The interface just need to be adapted.; It would work well with `sesolve` and `mcsolve`.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1644#issuecomment-908484939
https://github.com/qutip/qutip/pull/1644#issuecomment-908484939:180,Modifiability,adapt,adapted,180,"@nathanshammah ; I expect it to be easy to use as an integrator:; ` _evolve_krylov_tlist` is essentially the `run`, `time_evolution` is `integrate`.; The interface just need to be adapted.; It would work well with `sesolve` and `mcsolve`.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1644#issuecomment-908484939
https://github.com/qutip/qutip/pull/1644#issuecomment-953951326:208,Deployability,integrat,integrators,208,[![Coverage Status](https://coveralls.io/builds/48593127/badge)](https://coveralls.io/builds/48593127). Coverage increased (+1.4%) to 67.07% when pulling **ec1c71c02f434b2d56fad69a8db2069f22a6b9bf on Ericgig:integrators.verner** into **414c5eccd2263a5607bf9f57b3b73381ea377504 on qutip:dev.major**.,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1644#issuecomment-953951326
https://github.com/qutip/qutip/pull/1644#issuecomment-953951326:208,Integrability,integrat,integrators,208,[![Coverage Status](https://coveralls.io/builds/48593127/badge)](https://coveralls.io/builds/48593127). Coverage increased (+1.4%) to 67.07% when pulling **ec1c71c02f434b2d56fad69a8db2069f22a6b9bf on Ericgig:integrators.verner** into **414c5eccd2263a5607bf9f57b3b73381ea377504 on qutip:dev.major**.,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1644#issuecomment-953951326
https://github.com/qutip/qutip/pull/1645#issuecomment-907406782:219,Testability,test,test,219,[![Coverage Status](https://coveralls.io/builds/42475208/badge)](https://coveralls.io/builds/42475208). Coverage increased (+0.004%) to 65.767% when pulling **1144ecc5578c2c0d7919874d372a037d58614314 on Ericgig:mcsolve.test.fix** into **b9f66c6ea29a4c215f188085cf3059974a45876d on qutip:master**.,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1645#issuecomment-907406782
https://github.com/qutip/qutip/pull/1647#issuecomment-908306079:710,Availability,down,down,710,"Yes, we have binary operator defined for `Data` with object of the same type, but since for a while we only used `CSR`, there are probably some in the code where the `Data` types can be mixed. It will cause problem when we start using multiple types together. Also `/=` is used in `Qobj`, so some `TfTensor` no having them will cause problem as it is right now. We could remove operator support or fully support them, but the present something used, partially supported will cause issues. I prefer full support. By adding operator in `base.Date`, new type don't need to do anything so it's not causing difficulties when creating new types and it will work as expected everywhere, so we don't have to hunt them down. It also make the code cleaner.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1647#issuecomment-908306079
https://github.com/qutip/qutip/pull/1647#issuecomment-909064274:386,Usability,simpl,simple,386,"> The fear I have with removing them is I expect we will forget some in untested code...; > But let's go with removing them. Woot. Code that is entirely untested is probably already broken. ;) . > Do we keep the ones with scalar: `Data / scalar`, `-Data`?; > They probably won't cause problems, but to be consistent I would also remove them. I'm happy with those being removed or being simple calls to other methods on the Data class. The fewer methods Data layer classes have to implement themselves, the better.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1647#issuecomment-909064274
https://github.com/qutip/qutip/pull/1648#issuecomment-909203229:170,Testability,test,test,170,"@BoxiLi Would you be happy to apply this to `qutip-qip` too?. @drew-parsons Could you check that this works for you and that I haven't missed any other cases? The entire test suite passed for me, but one never knows.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1648#issuecomment-909203229
https://github.com/qutip/qutip/pull/1648#issuecomment-909311635:20,Deployability,patch,patched,20,"Passes fine for me, patched onto 4.6.2.; Running tests locally,; ```; ...; tests/test_processor.py::TestCircuitProcessor::testPlot PASSED [ 79%]; ...; tests/test_wigner.py::test_wigner_clenshaw_sp_iter_dm PASSED [100%]. === 1910 passed, 20 skipped, 67 deselected, 53 warnings in 472.83s (0:07:52) ===; autopkgtest [16:47:24]: test test-qutip: -----------------------]; autopkgtest [16:47:24]: test test-qutip: - - - - - - - - - - results - - - - - - - - - -; test-qutip PASS; autopkgtest [16:47:24]: @@@@@@@@@@@@@@@@@@@@ summary; test-qutip PASS; ```",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1648#issuecomment-909311635
https://github.com/qutip/qutip/pull/1648#issuecomment-909311635:49,Testability,test,tests,49,"Passes fine for me, patched onto 4.6.2.; Running tests locally,; ```; ...; tests/test_processor.py::TestCircuitProcessor::testPlot PASSED [ 79%]; ...; tests/test_wigner.py::test_wigner_clenshaw_sp_iter_dm PASSED [100%]. === 1910 passed, 20 skipped, 67 deselected, 53 warnings in 472.83s (0:07:52) ===; autopkgtest [16:47:24]: test test-qutip: -----------------------]; autopkgtest [16:47:24]: test test-qutip: - - - - - - - - - - results - - - - - - - - - -; test-qutip PASS; autopkgtest [16:47:24]: @@@@@@@@@@@@@@@@@@@@ summary; test-qutip PASS; ```",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1648#issuecomment-909311635
https://github.com/qutip/qutip/pull/1648#issuecomment-909311635:75,Testability,test,tests,75,"Passes fine for me, patched onto 4.6.2.; Running tests locally,; ```; ...; tests/test_processor.py::TestCircuitProcessor::testPlot PASSED [ 79%]; ...; tests/test_wigner.py::test_wigner_clenshaw_sp_iter_dm PASSED [100%]. === 1910 passed, 20 skipped, 67 deselected, 53 warnings in 472.83s (0:07:52) ===; autopkgtest [16:47:24]: test test-qutip: -----------------------]; autopkgtest [16:47:24]: test test-qutip: - - - - - - - - - - results - - - - - - - - - -; test-qutip PASS; autopkgtest [16:47:24]: @@@@@@@@@@@@@@@@@@@@ summary; test-qutip PASS; ```",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1648#issuecomment-909311635
https://github.com/qutip/qutip/pull/1648#issuecomment-909311635:100,Testability,Test,TestCircuitProcessor,100,"Passes fine for me, patched onto 4.6.2.; Running tests locally,; ```; ...; tests/test_processor.py::TestCircuitProcessor::testPlot PASSED [ 79%]; ...; tests/test_wigner.py::test_wigner_clenshaw_sp_iter_dm PASSED [100%]. === 1910 passed, 20 skipped, 67 deselected, 53 warnings in 472.83s (0:07:52) ===; autopkgtest [16:47:24]: test test-qutip: -----------------------]; autopkgtest [16:47:24]: test test-qutip: - - - - - - - - - - results - - - - - - - - - -; test-qutip PASS; autopkgtest [16:47:24]: @@@@@@@@@@@@@@@@@@@@ summary; test-qutip PASS; ```",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1648#issuecomment-909311635
https://github.com/qutip/qutip/pull/1648#issuecomment-909311635:122,Testability,test,testPlot,122,"Passes fine for me, patched onto 4.6.2.; Running tests locally,; ```; ...; tests/test_processor.py::TestCircuitProcessor::testPlot PASSED [ 79%]; ...; tests/test_wigner.py::test_wigner_clenshaw_sp_iter_dm PASSED [100%]. === 1910 passed, 20 skipped, 67 deselected, 53 warnings in 472.83s (0:07:52) ===; autopkgtest [16:47:24]: test test-qutip: -----------------------]; autopkgtest [16:47:24]: test test-qutip: - - - - - - - - - - results - - - - - - - - - -; test-qutip PASS; autopkgtest [16:47:24]: @@@@@@@@@@@@@@@@@@@@ summary; test-qutip PASS; ```",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1648#issuecomment-909311635
https://github.com/qutip/qutip/pull/1648#issuecomment-909311635:151,Testability,test,tests,151,"Passes fine for me, patched onto 4.6.2.; Running tests locally,; ```; ...; tests/test_processor.py::TestCircuitProcessor::testPlot PASSED [ 79%]; ...; tests/test_wigner.py::test_wigner_clenshaw_sp_iter_dm PASSED [100%]. === 1910 passed, 20 skipped, 67 deselected, 53 warnings in 472.83s (0:07:52) ===; autopkgtest [16:47:24]: test test-qutip: -----------------------]; autopkgtest [16:47:24]: test test-qutip: - - - - - - - - - - results - - - - - - - - - -; test-qutip PASS; autopkgtest [16:47:24]: @@@@@@@@@@@@@@@@@@@@ summary; test-qutip PASS; ```",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1648#issuecomment-909311635
https://github.com/qutip/qutip/pull/1648#issuecomment-909311635:326,Testability,test,test,326,"Passes fine for me, patched onto 4.6.2.; Running tests locally,; ```; ...; tests/test_processor.py::TestCircuitProcessor::testPlot PASSED [ 79%]; ...; tests/test_wigner.py::test_wigner_clenshaw_sp_iter_dm PASSED [100%]. === 1910 passed, 20 skipped, 67 deselected, 53 warnings in 472.83s (0:07:52) ===; autopkgtest [16:47:24]: test test-qutip: -----------------------]; autopkgtest [16:47:24]: test test-qutip: - - - - - - - - - - results - - - - - - - - - -; test-qutip PASS; autopkgtest [16:47:24]: @@@@@@@@@@@@@@@@@@@@ summary; test-qutip PASS; ```",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1648#issuecomment-909311635
https://github.com/qutip/qutip/pull/1648#issuecomment-909311635:331,Testability,test,test-qutip,331,"Passes fine for me, patched onto 4.6.2.; Running tests locally,; ```; ...; tests/test_processor.py::TestCircuitProcessor::testPlot PASSED [ 79%]; ...; tests/test_wigner.py::test_wigner_clenshaw_sp_iter_dm PASSED [100%]. === 1910 passed, 20 skipped, 67 deselected, 53 warnings in 472.83s (0:07:52) ===; autopkgtest [16:47:24]: test test-qutip: -----------------------]; autopkgtest [16:47:24]: test test-qutip: - - - - - - - - - - results - - - - - - - - - -; test-qutip PASS; autopkgtest [16:47:24]: @@@@@@@@@@@@@@@@@@@@ summary; test-qutip PASS; ```",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1648#issuecomment-909311635
https://github.com/qutip/qutip/pull/1648#issuecomment-909311635:393,Testability,test,test,393,"Passes fine for me, patched onto 4.6.2.; Running tests locally,; ```; ...; tests/test_processor.py::TestCircuitProcessor::testPlot PASSED [ 79%]; ...; tests/test_wigner.py::test_wigner_clenshaw_sp_iter_dm PASSED [100%]. === 1910 passed, 20 skipped, 67 deselected, 53 warnings in 472.83s (0:07:52) ===; autopkgtest [16:47:24]: test test-qutip: -----------------------]; autopkgtest [16:47:24]: test test-qutip: - - - - - - - - - - results - - - - - - - - - -; test-qutip PASS; autopkgtest [16:47:24]: @@@@@@@@@@@@@@@@@@@@ summary; test-qutip PASS; ```",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1648#issuecomment-909311635
https://github.com/qutip/qutip/pull/1648#issuecomment-909311635:398,Testability,test,test-qutip,398,"Passes fine for me, patched onto 4.6.2.; Running tests locally,; ```; ...; tests/test_processor.py::TestCircuitProcessor::testPlot PASSED [ 79%]; ...; tests/test_wigner.py::test_wigner_clenshaw_sp_iter_dm PASSED [100%]. === 1910 passed, 20 skipped, 67 deselected, 53 warnings in 472.83s (0:07:52) ===; autopkgtest [16:47:24]: test test-qutip: -----------------------]; autopkgtest [16:47:24]: test test-qutip: - - - - - - - - - - results - - - - - - - - - -; test-qutip PASS; autopkgtest [16:47:24]: @@@@@@@@@@@@@@@@@@@@ summary; test-qutip PASS; ```",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1648#issuecomment-909311635
https://github.com/qutip/qutip/pull/1648#issuecomment-909311635:459,Testability,test,test-qutip,459,"Passes fine for me, patched onto 4.6.2.; Running tests locally,; ```; ...; tests/test_processor.py::TestCircuitProcessor::testPlot PASSED [ 79%]; ...; tests/test_wigner.py::test_wigner_clenshaw_sp_iter_dm PASSED [100%]. === 1910 passed, 20 skipped, 67 deselected, 53 warnings in 472.83s (0:07:52) ===; autopkgtest [16:47:24]: test test-qutip: -----------------------]; autopkgtest [16:47:24]: test test-qutip: - - - - - - - - - - results - - - - - - - - - -; test-qutip PASS; autopkgtest [16:47:24]: @@@@@@@@@@@@@@@@@@@@ summary; test-qutip PASS; ```",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1648#issuecomment-909311635
https://github.com/qutip/qutip/pull/1648#issuecomment-909311635:530,Testability,test,test-qutip,530,"Passes fine for me, patched onto 4.6.2.; Running tests locally,; ```; ...; tests/test_processor.py::TestCircuitProcessor::testPlot PASSED [ 79%]; ...; tests/test_wigner.py::test_wigner_clenshaw_sp_iter_dm PASSED [100%]. === 1910 passed, 20 skipped, 67 deselected, 53 warnings in 472.83s (0:07:52) ===; autopkgtest [16:47:24]: test test-qutip: -----------------------]; autopkgtest [16:47:24]: test test-qutip: - - - - - - - - - - results - - - - - - - - - -; test-qutip PASS; autopkgtest [16:47:24]: @@@@@@@@@@@@@@@@@@@@ summary; test-qutip PASS; ```",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1648#issuecomment-909311635
https://github.com/qutip/qutip/pull/1648#issuecomment-909749680:239,Testability,test,test-under-xvfb-,239,[![Coverage Status](https://coveralls.io/builds/42542345/badge)](https://coveralls.io/builds/42542345). Coverage increased (+0.02%) to 65.758% when pulling **d08058b2cc134947d1a3838d960a5af26fa49ab7 on hodgestar:feature/fix-processor-plot-test-under-xvfb-gh1639** into **ac27129f9171de4641d0787515872427f8f1983c on qutip:master**.,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1648#issuecomment-909749680
https://github.com/qutip/qutip/issues/1650#issuecomment-912900577:105,Testability,test,testing,105,"Also, I run these codes on Jupyter notebook but on my PC's terminal, I could successfully import ``qubit.testing`` and ``qubit``.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1650#issuecomment-912900577
https://github.com/qutip/qutip/issues/1650#issuecomment-913454099:106,Testability,test,testing,106,"@RunawayFancy Apologies, I'm not 100% sure which case you said worked and which didn't. Did ""import qutip.testing"" working in your terminal but fail in your Jupyter notebook?",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1650#issuecomment-913454099
https://github.com/qutip/qutip/issues/1650#issuecomment-913463573:101,Deployability,install,installed,101,@hodgestar Yes. I could import `qutip.testing` in my terminal but fail in Jupyter notebook. But I re-installed the qutip lib and now it could be imported successfully.,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1650#issuecomment-913463573
https://github.com/qutip/qutip/issues/1650#issuecomment-913463573:38,Testability,test,testing,38,@hodgestar Yes. I could import `qutip.testing` in my terminal but fail in Jupyter notebook. But I re-installed the qutip lib and now it could be imported successfully.,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1650#issuecomment-913463573
https://github.com/qutip/qutip/issues/1650#issuecomment-913469588:33,Deployability,install,installing,33,@hodgestar As a proverb says: re-installing solves 99% of the problem XD.,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1650#issuecomment-913469588
https://github.com/qutip/qutip/pull/1651#issuecomment-980020050:24,Deployability,update,update,24,"@Ericgig Is the plan to update qutip.solve.bloch_redfield and remove br_codegen, etc in a follow up PR?",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1651#issuecomment-980020050
https://github.com/qutip/qutip/pull/1651#issuecomment-1010222890:393,Availability,avail,available,393,"@hodgestar , I think I responded to all your comments.; The tests for core/blochredfield.py are present, I think it has a 100% coverage.; I did little cut and paste, but stayed close to the original cython code when possible. The question I still have is about the `a_ops` format: I made breaking changes from v4, so I want to be sure the new way is clear. I think `matmul_var_data` should be available in `core/data` not implemented here, but I don't want to touch that part in this PR.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1651#issuecomment-1010222890
https://github.com/qutip/qutip/pull/1651#issuecomment-1010222890:60,Testability,test,tests,60,"@hodgestar , I think I responded to all your comments.; The tests for core/blochredfield.py are present, I think it has a 100% coverage.; I did little cut and paste, but stayed close to the original cython code when possible. The question I still have is about the `a_ops` format: I made breaking changes from v4, so I want to be sure the new way is clear. I think `matmul_var_data` should be available in `core/data` not implemented here, but I don't want to touch that part in this PR.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1651#issuecomment-1010222890
https://github.com/qutip/qutip/pull/1651#issuecomment-1010222890:350,Usability,clear,clear,350,"@hodgestar , I think I responded to all your comments.; The tests for core/blochredfield.py are present, I think it has a 100% coverage.; I did little cut and paste, but stayed close to the original cython code when possible. The question I still have is about the `a_ops` format: I made breaking changes from v4, so I want to be sure the new way is clear. I think `matmul_var_data` should be available in `core/data` not implemented here, but I don't want to touch that part in this PR.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1651#issuecomment-1010222890
https://github.com/qutip/qutip/pull/1652#issuecomment-914083278:210,Deployability,patch,patch-,210,[![Coverage Status](https://coveralls.io/builds/42690711/badge)](https://coveralls.io/builds/42690711). Coverage remained the same at 65.763% when pulling **4ba6c3a1b16bfbaf85065191f2a03e58d62e55af on Erotemic:patch-1** into **d78b3b1fbd058f3fb727dd271da14af0dafbb99d on qutip:master**.,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1652#issuecomment-914083278
https://github.com/qutip/qutip/pull/1652#issuecomment-914132388:668,Availability,ping,pinging,668,"@Erotemic Thank you for documenting this. I will merge it shortly & have marked if for inclusion in QuTiP 4.6.3. Note that qutip-qip has also been split out into it's own package (https://github.com/qutip/qutip-qip) in preparation for QuTiP 5 so we should update it there too. `reverse_states` seems to reverse the order of the array of quantum and classical bits. It is a bit odd, so I'm happy to leave it undocumented. The original commit just read:. ```; commit dcf8d363718b6ee5a8a17ec9af00df4bc8aea166; Author: Robert Johansson; Date: Mon May 26 19:11:44 2014 +0900. allow reversing the circuit represenation. added support for multigate symbol; ```. @BoxiLi Just pinging you so you know I merged this and can comment if you like.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1652#issuecomment-914132388
https://github.com/qutip/qutip/pull/1652#issuecomment-914132388:256,Deployability,update,update,256,"@Erotemic Thank you for documenting this. I will merge it shortly & have marked if for inclusion in QuTiP 4.6.3. Note that qutip-qip has also been split out into it's own package (https://github.com/qutip/qutip-qip) in preparation for QuTiP 5 so we should update it there too. `reverse_states` seems to reverse the order of the array of quantum and classical bits. It is a bit odd, so I'm happy to leave it undocumented. The original commit just read:. ```; commit dcf8d363718b6ee5a8a17ec9af00df4bc8aea166; Author: Robert Johansson; Date: Mon May 26 19:11:44 2014 +0900. allow reversing the circuit represenation. added support for multigate symbol; ```. @BoxiLi Just pinging you so you know I merged this and can comment if you like.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1652#issuecomment-914132388
https://github.com/qutip/qutip/pull/1652#issuecomment-914132388:407,Usability,undo,undocumented,407,"@Erotemic Thank you for documenting this. I will merge it shortly & have marked if for inclusion in QuTiP 4.6.3. Note that qutip-qip has also been split out into it's own package (https://github.com/qutip/qutip-qip) in preparation for QuTiP 5 so we should update it there too. `reverse_states` seems to reverse the order of the array of quantum and classical bits. It is a bit odd, so I'm happy to leave it undocumented. The original commit just read:. ```; commit dcf8d363718b6ee5a8a17ec9af00df4bc8aea166; Author: Robert Johansson; Date: Mon May 26 19:11:44 2014 +0900. allow reversing the circuit represenation. added support for multigate symbol; ```. @BoxiLi Just pinging you so you know I merged this and can comment if you like.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1652#issuecomment-914132388
https://github.com/qutip/qutip/pull/1654#issuecomment-914888716:202,Integrability,depend,dependabot,202,[![Coverage Status](https://coveralls.io/builds/42716719/badge)](https://coveralls.io/builds/42716719). Coverage increased (+0.03%) to 65.763% when pulling **f3580f770b5bc3f67b54ce90cfc7dbd1551b5960 on dependabot/pip/doc/pillow-8.3.2** into **cd525d1392bb764716a2278b3c7c0c3fdf6c64c4 on master**.,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1654#issuecomment-914888716
https://github.com/qutip/qutip/pull/1655#issuecomment-925558661:229,Deployability,configurat,configuration,229,"@Ericgig any tips how to locally run `pycodestyle` linter so that it follows same settings as `codeclimate`? When I run it locally it show way more warnings than `codeclimate`, seems a lot more restrictive. I'm sure some sort of configuration is missing. I checked the [contribution guide](https://qutip.org/docs/latest/development/contributing.html) but this particular matter is not detailed. If you explain how to run linter locally I would be happy to also update the docs and document it for the future contributors.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1655#issuecomment-925558661
https://github.com/qutip/qutip/pull/1655#issuecomment-925558661:461,Deployability,update,update,461,"@Ericgig any tips how to locally run `pycodestyle` linter so that it follows same settings as `codeclimate`? When I run it locally it show way more warnings than `codeclimate`, seems a lot more restrictive. I'm sure some sort of configuration is missing. I checked the [contribution guide](https://qutip.org/docs/latest/development/contributing.html) but this particular matter is not detailed. If you explain how to run linter locally I would be happy to also update the docs and document it for the future contributors.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1655#issuecomment-925558661
https://github.com/qutip/qutip/pull/1655#issuecomment-925558661:229,Modifiability,config,configuration,229,"@Ericgig any tips how to locally run `pycodestyle` linter so that it follows same settings as `codeclimate`? When I run it locally it show way more warnings than `codeclimate`, seems a lot more restrictive. I'm sure some sort of configuration is missing. I checked the [contribution guide](https://qutip.org/docs/latest/development/contributing.html) but this particular matter is not detailed. If you explain how to run linter locally I would be happy to also update the docs and document it for the future contributors.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1655#issuecomment-925558661
https://github.com/qutip/qutip/pull/1655#issuecomment-925558661:283,Usability,guid,guide,283,"@Ericgig any tips how to locally run `pycodestyle` linter so that it follows same settings as `codeclimate`? When I run it locally it show way more warnings than `codeclimate`, seems a lot more restrictive. I'm sure some sort of configuration is missing. I checked the [contribution guide](https://qutip.org/docs/latest/development/contributing.html) but this particular matter is not detailed. If you explain how to run linter locally I would be happy to also update the docs and document it for the future contributors.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1655#issuecomment-925558661
https://github.com/qutip/qutip/pull/1655#issuecomment-926628157:49,Availability,error,errors,49,"@Ericgig sure I will be happy to fix the linting errors, I seem to have missed your previous message about codeclimate, sorry about that.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1655#issuecomment-926628157
https://github.com/qutip/qutip/pull/1655#issuecomment-926628157:93,Integrability,message,message,93,"@Ericgig sure I will be happy to fix the linting errors, I seem to have missed your previous message about codeclimate, sorry about that.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1655#issuecomment-926628157
https://github.com/qutip/qutip/pull/1655#issuecomment-926659144:241,Testability,test,test,241,"I think I found what you want: `git diff master | pycodestyle --diff`. It run the linter on the diff between the branches. So it should see the same issues as `codeclimat`.; Everything looks good with your last commit, I am just waiting for test to finish to review.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1655#issuecomment-926659144
https://github.com/qutip/qutip/pull/1656#issuecomment-917036156:205,Availability,down,down,205,"@Ericgig Thanks for finding this. I don't think we should add a setting for this though -- it's too obscure. The point of returning `None` when `p == 0` seems to be to avoid division by zero, not to round down small probabilities. I think we should either 1) update the test or 2) if we lots some precision in a recent change, try to get that precision back. Do you know which change caused the loss of precision?",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1656#issuecomment-917036156
https://github.com/qutip/qutip/pull/1656#issuecomment-917036156:259,Deployability,update,update,259,"@Ericgig Thanks for finding this. I don't think we should add a setting for this though -- it's too obscure. The point of returning `None` when `p == 0` seems to be to avoid division by zero, not to round down small probabilities. I think we should either 1) update the test or 2) if we lots some precision in a recent change, try to get that precision back. Do you know which change caused the loss of precision?",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1656#issuecomment-917036156
https://github.com/qutip/qutip/pull/1656#issuecomment-917036156:168,Safety,avoid,avoid,168,"@Ericgig Thanks for finding this. I don't think we should add a setting for this though -- it's too obscure. The point of returning `None` when `p == 0` seems to be to avoid division by zero, not to round down small probabilities. I think we should either 1) update the test or 2) if we lots some precision in a recent change, try to get that precision back. Do you know which change caused the loss of precision?",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1656#issuecomment-917036156
https://github.com/qutip/qutip/pull/1656#issuecomment-917036156:270,Testability,test,test,270,"@Ericgig Thanks for finding this. I don't think we should add a setting for this though -- it's too obscure. The point of returning `None` when `p == 0` seems to be to avoid division by zero, not to round down small probabilities. I think we should either 1) update the test or 2) if we lots some precision in a recent change, try to get that precision back. Do you know which change caused the loss of precision?",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1656#issuecomment-917036156
https://github.com/qutip/qutip/pull/1656#issuecomment-917054484:215,Deployability,update,update,215,"No, I don't know what exactly caused this. All operation are through `Qobj`. Maybe `tidyup` have some effect.; But testing for a pure `0` with floating number is never a good idea. Which test do you think we should update. `test_quantumcircuit` is testing what it should.; `test_measurement` tests case which have `0` probabilities with `np.testing.assert_almost_equal`.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1656#issuecomment-917054484
https://github.com/qutip/qutip/pull/1656#issuecomment-917054484:115,Testability,test,testing,115,"No, I don't know what exactly caused this. All operation are through `Qobj`. Maybe `tidyup` have some effect.; But testing for a pure `0` with floating number is never a good idea. Which test do you think we should update. `test_quantumcircuit` is testing what it should.; `test_measurement` tests case which have `0` probabilities with `np.testing.assert_almost_equal`.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1656#issuecomment-917054484
https://github.com/qutip/qutip/pull/1656#issuecomment-917054484:187,Testability,test,test,187,"No, I don't know what exactly caused this. All operation are through `Qobj`. Maybe `tidyup` have some effect.; But testing for a pure `0` with floating number is never a good idea. Which test do you think we should update. `test_quantumcircuit` is testing what it should.; `test_measurement` tests case which have `0` probabilities with `np.testing.assert_almost_equal`.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1656#issuecomment-917054484
https://github.com/qutip/qutip/pull/1656#issuecomment-917054484:248,Testability,test,testing,248,"No, I don't know what exactly caused this. All operation are through `Qobj`. Maybe `tidyup` have some effect.; But testing for a pure `0` with floating number is never a good idea. Which test do you think we should update. `test_quantumcircuit` is testing what it should.; `test_measurement` tests case which have `0` probabilities with `np.testing.assert_almost_equal`.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1656#issuecomment-917054484
https://github.com/qutip/qutip/pull/1656#issuecomment-917054484:292,Testability,test,tests,292,"No, I don't know what exactly caused this. All operation are through `Qobj`. Maybe `tidyup` have some effect.; But testing for a pure `0` with floating number is never a good idea. Which test do you think we should update. `test_quantumcircuit` is testing what it should.; `test_measurement` tests case which have `0` probabilities with `np.testing.assert_almost_equal`.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1656#issuecomment-917054484
https://github.com/qutip/qutip/pull/1656#issuecomment-917054484:341,Testability,test,testing,341,"No, I don't know what exactly caused this. All operation are through `Qobj`. Maybe `tidyup` have some effect.; But testing for a pure `0` with floating number is never a good idea. Which test do you think we should update. `test_quantumcircuit` is testing what it should.; `test_measurement` tests case which have `0` probabilities with `np.testing.assert_almost_equal`.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1656#issuecomment-917054484
https://github.com/qutip/qutip/pull/1656#issuecomment-917056083:219,Availability,toler,tolerance,219,"The failing test in `CircuitSimulator` is likely from `run_statistics`, which collects all the possible outcomes wrt. the measurement result. If the measurement result is `None`, it will skip that state. I can also set tolerance there, or update the test.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1656#issuecomment-917056083
https://github.com/qutip/qutip/pull/1656#issuecomment-917056083:239,Deployability,update,update,239,"The failing test in `CircuitSimulator` is likely from `run_statistics`, which collects all the possible outcomes wrt. the measurement result. If the measurement result is `None`, it will skip that state. I can also set tolerance there, or update the test.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1656#issuecomment-917056083
https://github.com/qutip/qutip/pull/1656#issuecomment-917056083:12,Testability,test,test,12,"The failing test in `CircuitSimulator` is likely from `run_statistics`, which collects all the possible outcomes wrt. the measurement result. If the measurement result is `None`, it will skip that state. I can also set tolerance there, or update the test.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1656#issuecomment-917056083
https://github.com/qutip/qutip/pull/1656#issuecomment-917056083:250,Testability,test,test,250,"The failing test in `CircuitSimulator` is likely from `run_statistics`, which collects all the possible outcomes wrt. the measurement result. If the measurement result is `None`, it will skip that state. I can also set tolerance there, or update the test.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1656#issuecomment-917056083
https://github.com/qutip/qutip/pull/1656#issuecomment-917229773:76,Availability,reliab,reliably,76,"I think it's quite important to understand why this happened. Previously we reliably had an exactly correct result, and now we don't. This particular check for `p != 0` of a float is I think okay because it's there specially to avoid division by exactly zero. I can think of at least two plausible scenarios:. 1. The issue was caused by the removal of auto_tidyup, in which case I think either a setting like this with an explicit check in either the measurement functions or the simulator are good solutions (although it should be possible to override the setting on a per-call basis, just like with atol). 2. The issue was caused by the removal of the data layer mathematical operations, and in particular, by the replacement of `data / value` by `data.mul(data, 1 / value)`, in which case I think the solution is to add a `div` operation to the data classes so that we don't lose this accuracy.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1656#issuecomment-917229773
https://github.com/qutip/qutip/pull/1656#issuecomment-917229773:228,Safety,avoid,avoid,228,"I think it's quite important to understand why this happened. Previously we reliably had an exactly correct result, and now we don't. This particular check for `p != 0` of a float is I think okay because it's there specially to avoid division by exactly zero. I can think of at least two plausible scenarios:. 1. The issue was caused by the removal of auto_tidyup, in which case I think either a setting like this with an explicit check in either the measurement functions or the simulator are good solutions (although it should be possible to override the setting on a per-call basis, just like with atol). 2. The issue was caused by the removal of the data layer mathematical operations, and in particular, by the replacement of `data / value` by `data.mul(data, 1 / value)`, in which case I think the solution is to add a `div` operation to the data classes so that we don't lose this accuracy.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1656#issuecomment-917229773
https://github.com/qutip/qutip/pull/1657#issuecomment-920075921:60,Testability,test,tests,60,"@Ericgig I re-triggered the builds. If that doesn't fix the tests, could you merge dev.major into this PR?",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1657#issuecomment-920075921
https://github.com/qutip/qutip/pull/1657#issuecomment-920189096:221,Testability,test,tests,221,[![Coverage Status](https://coveralls.io/builds/42898363/badge)](https://coveralls.io/builds/42898363). Coverage increased (+0.03%) to 64.907% when pulling **3d6cfc0553ff66eabda803f748380bd328e9b337 on Ericgig:stochastic.tests** into **7362b32449a821293940de9690734b6331594289 on qutip:dev.major**.,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1657#issuecomment-920189096
https://github.com/qutip/qutip/issues/1659#issuecomment-917295134:259,Testability,test,tests,259,"Hi albertomercurio, it's not needed to open an issue first but always nice to know it's coming.; The feature seems interesting, thank you for contributing. I took a quick look at your `steadystate-floquet` branch, the function look good. ; Have you added new tests for it?; Please open the PR when you have time, it does not have to be final.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1659#issuecomment-917295134
https://github.com/qutip/qutip/issues/1659#issuecomment-917369967:14,Testability,test,tested,14,"Hi Ericgig, i tested it with a Rabi Hamiltonian. It returns the steadystate immediately! [This is the plot](https://ibb.co/PthSzRd) of the master equation time evolution with the direct steadystate expectation value.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1659#issuecomment-917369967
https://github.com/qutip/qutip/pull/1660#issuecomment-917454056:391,Deployability,update,update,391,"Hi albertomercurio, ; Thank you for the contribution. We will need at least one automated test: a function in `qutip/tests/test_correlation.py` that call `steadystate_floquet` and would fail if something is wrong. For example, in the next major version of qutip, `Qobj.data.tocsc()` will fail. We want it to be caught when running the tests in `qutip/tests` instead of having to remember to update it. It could be simply to running your manual test and instead of plotting the result, checking it with `numpy.testing.assert_allclose`. Ideally it should be done twice, once for `sparse=True` and once for `sparse=False`.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1660#issuecomment-917454056
https://github.com/qutip/qutip/pull/1660#issuecomment-917454056:90,Testability,test,test,90,"Hi albertomercurio, ; Thank you for the contribution. We will need at least one automated test: a function in `qutip/tests/test_correlation.py` that call `steadystate_floquet` and would fail if something is wrong. For example, in the next major version of qutip, `Qobj.data.tocsc()` will fail. We want it to be caught when running the tests in `qutip/tests` instead of having to remember to update it. It could be simply to running your manual test and instead of plotting the result, checking it with `numpy.testing.assert_allclose`. Ideally it should be done twice, once for `sparse=True` and once for `sparse=False`.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1660#issuecomment-917454056
https://github.com/qutip/qutip/pull/1660#issuecomment-917454056:117,Testability,test,tests,117,"Hi albertomercurio, ; Thank you for the contribution. We will need at least one automated test: a function in `qutip/tests/test_correlation.py` that call `steadystate_floquet` and would fail if something is wrong. For example, in the next major version of qutip, `Qobj.data.tocsc()` will fail. We want it to be caught when running the tests in `qutip/tests` instead of having to remember to update it. It could be simply to running your manual test and instead of plotting the result, checking it with `numpy.testing.assert_allclose`. Ideally it should be done twice, once for `sparse=True` and once for `sparse=False`.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1660#issuecomment-917454056
https://github.com/qutip/qutip/pull/1660#issuecomment-917454056:335,Testability,test,tests,335,"Hi albertomercurio, ; Thank you for the contribution. We will need at least one automated test: a function in `qutip/tests/test_correlation.py` that call `steadystate_floquet` and would fail if something is wrong. For example, in the next major version of qutip, `Qobj.data.tocsc()` will fail. We want it to be caught when running the tests in `qutip/tests` instead of having to remember to update it. It could be simply to running your manual test and instead of plotting the result, checking it with `numpy.testing.assert_allclose`. Ideally it should be done twice, once for `sparse=True` and once for `sparse=False`.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1660#issuecomment-917454056
https://github.com/qutip/qutip/pull/1660#issuecomment-917454056:351,Testability,test,tests,351,"Hi albertomercurio, ; Thank you for the contribution. We will need at least one automated test: a function in `qutip/tests/test_correlation.py` that call `steadystate_floquet` and would fail if something is wrong. For example, in the next major version of qutip, `Qobj.data.tocsc()` will fail. We want it to be caught when running the tests in `qutip/tests` instead of having to remember to update it. It could be simply to running your manual test and instead of plotting the result, checking it with `numpy.testing.assert_allclose`. Ideally it should be done twice, once for `sparse=True` and once for `sparse=False`.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1660#issuecomment-917454056
https://github.com/qutip/qutip/pull/1660#issuecomment-917454056:444,Testability,test,test,444,"Hi albertomercurio, ; Thank you for the contribution. We will need at least one automated test: a function in `qutip/tests/test_correlation.py` that call `steadystate_floquet` and would fail if something is wrong. For example, in the next major version of qutip, `Qobj.data.tocsc()` will fail. We want it to be caught when running the tests in `qutip/tests` instead of having to remember to update it. It could be simply to running your manual test and instead of plotting the result, checking it with `numpy.testing.assert_allclose`. Ideally it should be done twice, once for `sparse=True` and once for `sparse=False`.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1660#issuecomment-917454056
https://github.com/qutip/qutip/pull/1660#issuecomment-917454056:509,Testability,test,testing,509,"Hi albertomercurio, ; Thank you for the contribution. We will need at least one automated test: a function in `qutip/tests/test_correlation.py` that call `steadystate_floquet` and would fail if something is wrong. For example, in the next major version of qutip, `Qobj.data.tocsc()` will fail. We want it to be caught when running the tests in `qutip/tests` instead of having to remember to update it. It could be simply to running your manual test and instead of plotting the result, checking it with `numpy.testing.assert_allclose`. Ideally it should be done twice, once for `sparse=True` and once for `sparse=False`.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1660#issuecomment-917454056
https://github.com/qutip/qutip/pull/1660#issuecomment-917454056:414,Usability,simpl,simply,414,"Hi albertomercurio, ; Thank you for the contribution. We will need at least one automated test: a function in `qutip/tests/test_correlation.py` that call `steadystate_floquet` and would fail if something is wrong. For example, in the next major version of qutip, `Qobj.data.tocsc()` will fail. We want it to be caught when running the tests in `qutip/tests` instead of having to remember to update it. It could be simply to running your manual test and instead of plotting the result, checking it with `numpy.testing.assert_allclose`. Ideally it should be done twice, once for `sparse=True` and once for `sparse=False`.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1660#issuecomment-917454056
https://github.com/qutip/qutip/pull/1660#issuecomment-917597103:76,Availability,error,errors,76,I added the test in `qutip/tests/test_correlation.py` and pytest returns no errors. Why not put it inside the `qutip/tests/test_steadystate.py` file instead?,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1660#issuecomment-917597103
https://github.com/qutip/qutip/pull/1660#issuecomment-917597103:12,Testability,test,test,12,I added the test in `qutip/tests/test_correlation.py` and pytest returns no errors. Why not put it inside the `qutip/tests/test_steadystate.py` file instead?,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1660#issuecomment-917597103
https://github.com/qutip/qutip/pull/1660#issuecomment-917597103:27,Testability,test,tests,27,I added the test in `qutip/tests/test_correlation.py` and pytest returns no errors. Why not put it inside the `qutip/tests/test_steadystate.py` file instead?,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1660#issuecomment-917597103
https://github.com/qutip/qutip/pull/1660#issuecomment-917597103:117,Testability,test,tests,117,I added the test in `qutip/tests/test_correlation.py` and pytest returns no errors. Why not put it inside the `qutip/tests/test_steadystate.py` file instead?,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1660#issuecomment-917597103
https://github.com/qutip/qutip/pull/1660#issuecomment-917699054:36,Testability,test,tests,36,"Ok, I just put it inside the `qutip/tests/test_steadystae.py` file.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1660#issuecomment-917699054
https://github.com/qutip/qutip/pull/1660#issuecomment-929203460:119,Deployability,update,update,119,"Merged!; Thank you Alberto. If you want to continue contribute on it: add support for independent `L_m` and `L_p`.; Or update it for v5, presently the `dev.major` branch, we would really appreciate.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1660#issuecomment-929203460
https://github.com/qutip/qutip/issues/1661#issuecomment-919287769:11,Deployability,release,release,11,The latest release of Qutip has some fixes for arrays of `Qobj`. Updating to 4.6.2 should solve the issue.,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1661#issuecomment-919287769
https://github.com/qutip/qutip/issues/1663#issuecomment-927605654:133,Deployability,update,updated,133,"@sahrak Thank you for reporting this. The parameters for `sesolve` changed slightly since the guide was written and the guide wasn't updated. I will make a PR to fix it shortly, but in the mean time you can run:. ```python; qutip.floquet.fsesolve(H, psi0=psi0, tlist=tlist, e_ops=[qutip.num(2)], args=args); ```",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1663#issuecomment-927605654
https://github.com/qutip/qutip/issues/1663#issuecomment-927605654:94,Usability,guid,guide,94,"@sahrak Thank you for reporting this. The parameters for `sesolve` changed slightly since the guide was written and the guide wasn't updated. I will make a PR to fix it shortly, but in the mean time you can run:. ```python; qutip.floquet.fsesolve(H, psi0=psi0, tlist=tlist, e_ops=[qutip.num(2)], args=args); ```",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1663#issuecomment-927605654
https://github.com/qutip/qutip/issues/1663#issuecomment-927605654:120,Usability,guid,guide,120,"@sahrak Thank you for reporting this. The parameters for `sesolve` changed slightly since the guide was written and the guide wasn't updated. I will make a PR to fix it shortly, but in the mean time you can run:. ```python; qutip.floquet.fsesolve(H, psi0=psi0, tlist=tlist, e_ops=[qutip.num(2)], args=args); ```",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1663#issuecomment-927605654
https://github.com/qutip/qutip/issues/1665#issuecomment-923207818:86,Integrability,depend,depend,86,"I cannot give an example without knowing what lambda is.; If the lambda term does not depend on rho, I would not use `mesolve` but just build the matrix using `numpy` and `scipy`.; The other terms can be represented as `qutip.liouvillian(H) - (qutip.spre(T) - qutip.spost(T))/2`.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1665#issuecomment-923207818
https://github.com/qutip/qutip/issues/1665#issuecomment-923607868:421,Integrability,depend,depend,421,"Hi; Lambda is diagonal matrix that describes repopulation in atomic system; and not act on density matrix in master equation ; You can see more details in chapter 5 of book:; Optically polarized atoms; By Simon M. Rochester. Thanks again . Sent from my iPhone. > On Sep 20, 2021, at 11:47 PM, Eric Giguère ***@***.***> wrote:; > ; > I cannot give an example without knowing what lambda is.; > If the lambda term does not depend on rho, I would not use mesolve but just build the matrix using numpy and scipy.; > The other terms can be represented as qutip.liouvillian(H) - (qutip.spre(T) - qutip.spost(T))/2.; > ; > —; > You are receiving this because you authored the thread.; > Reply to this email directly, view it on GitHub, or unsubscribe.; > Triage notifications on the go with GitHub Mobile for iOS or Android.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1665#issuecomment-923607868
https://github.com/qutip/qutip/issues/1668#issuecomment-925327795:928,Deployability,update,updated,928,"Hi Emi,; There are a few options:; `krylovsolver` could exist independently of Qutip and be used as:; ```; import qutip; from krylovsolver import krylovsolve; ...; result = krylovsolve(H, psi, tlist, ...); ```. If you want it to be part of qutip itself, since it solve the same problem as `sesolve`, it could be inserted as an options to `sesolve` or be it's own function. It would be better to not have too many function doing the same thing, but since we don't have many alternative method in `sesolve` it could be overlooked. Seeing the state of `krylovsolve`, both would be quite easy to do. Do you have benchmarks to compare it to `sesolve`? From what I understand, `krylovsolve` is a faster `sesolve` limited to constant Hamiltonian. So it would be interesting to see how fast it is. If we add `krylovsolve` to qutip, would you be able to maintain it? A new major version of qutip is in development and it will need to be updated.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1668#issuecomment-925327795
https://github.com/qutip/qutip/issues/1668#issuecomment-925327795:608,Testability,benchmark,benchmarks,608,"Hi Emi,; There are a few options:; `krylovsolver` could exist independently of Qutip and be used as:; ```; import qutip; from krylovsolver import krylovsolve; ...; result = krylovsolve(H, psi, tlist, ...); ```. If you want it to be part of qutip itself, since it solve the same problem as `sesolve`, it could be inserted as an options to `sesolve` or be it's own function. It would be better to not have too many function doing the same thing, but since we don't have many alternative method in `sesolve` it could be overlooked. Seeing the state of `krylovsolve`, both would be quite easy to do. Do you have benchmarks to compare it to `sesolve`? From what I understand, `krylovsolve` is a faster `sesolve` limited to constant Hamiltonian. So it would be interesting to see how fast it is. If we add `krylovsolve` to qutip, would you be able to maintain it? A new major version of qutip is in development and it will need to be updated.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1668#issuecomment-925327795
https://github.com/qutip/qutip/issues/1668#issuecomment-926236528:930,Availability,down,down,930,"Hello Eric, thank you for the quick response!. We have spoken with some members of the qutip team during the grant meetings regarding porting it directly into qutip, and we agreed it would be a good addition as a separate solver. There are a couple of we-believe-good reasons to provide <code>krylovsolve</code> as another qutip solver. As you mention, the method is currently limited to constant closed system Hamiltonians. Another possible addition discussed during the meetings was support for open quantum systems, which provides another unitary-fund grant opportunity for some students!. Another important application for many-body systems comes in handy with Krylov. Given the memory limitations from matrix representation of operators and the exponential growth of many-body systems Hilbert spaces, the limit of qubits on which the solvers live is around 15 qubits. This limitation gets expanded (in exchange for some slow down in the computations) to a few more qubits exploiting the binary operational nature of many-body systems. While any solver could use operations instead of matrices, it is a good testing bead to use Krylov's algorithm because of a property when constructing this space. This feature is a must-have within our research group, and everyone could also benefit from it. More importantly, Krylov is gaining increasing interest in the research community, and we believe that providing it as a qutip solver will increase the traffic of the repository. Regarding benchmarks and some documentation, we have a public jupyter notebook with some benchmarks here [krylov use examples](https://colab.research.google.com/drive/1f7ng8q9QNEzaZ97vGop3aIip8GPtl3GR?usp=sharing), and there's also a [medium blog post](https://medium.com/@julian.ruffinelli/krylov-approximation-method-for-quantum-evolution-148b3f023ec4) with some other details. As for maintenance, yes, the way this code-block fits in should not be problematic to update even with qutip changes. We use <code>krylovsolve<",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1668#issuecomment-926236528
https://github.com/qutip/qutip/issues/1668#issuecomment-926236528:1865,Availability,mainten,maintenance,1865,"regarding porting it directly into qutip, and we agreed it would be a good addition as a separate solver. There are a couple of we-believe-good reasons to provide <code>krylovsolve</code> as another qutip solver. As you mention, the method is currently limited to constant closed system Hamiltonians. Another possible addition discussed during the meetings was support for open quantum systems, which provides another unitary-fund grant opportunity for some students!. Another important application for many-body systems comes in handy with Krylov. Given the memory limitations from matrix representation of operators and the exponential growth of many-body systems Hilbert spaces, the limit of qubits on which the solvers live is around 15 qubits. This limitation gets expanded (in exchange for some slow down in the computations) to a few more qubits exploiting the binary operational nature of many-body systems. While any solver could use operations instead of matrices, it is a good testing bead to use Krylov's algorithm because of a property when constructing this space. This feature is a must-have within our research group, and everyone could also benefit from it. More importantly, Krylov is gaining increasing interest in the research community, and we believe that providing it as a qutip solver will increase the traffic of the repository. Regarding benchmarks and some documentation, we have a public jupyter notebook with some benchmarks here [krylov use examples](https://colab.research.google.com/drive/1f7ng8q9QNEzaZ97vGop3aIip8GPtl3GR?usp=sharing), and there's also a [medium blog post](https://medium.com/@julian.ruffinelli/krylov-approximation-method-for-quantum-evolution-148b3f023ec4) with some other details. As for maintenance, yes, the way this code-block fits in should not be problematic to update even with qutip changes. We use <code>krylovsolve</code> for research and will keep the solver repo outside qutip up to date and (hopefully!) inside of it for the community.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1668#issuecomment-926236528
https://github.com/qutip/qutip/issues/1668#issuecomment-926236528:1944,Deployability,update,update,1944,"regarding porting it directly into qutip, and we agreed it would be a good addition as a separate solver. There are a couple of we-believe-good reasons to provide <code>krylovsolve</code> as another qutip solver. As you mention, the method is currently limited to constant closed system Hamiltonians. Another possible addition discussed during the meetings was support for open quantum systems, which provides another unitary-fund grant opportunity for some students!. Another important application for many-body systems comes in handy with Krylov. Given the memory limitations from matrix representation of operators and the exponential growth of many-body systems Hilbert spaces, the limit of qubits on which the solvers live is around 15 qubits. This limitation gets expanded (in exchange for some slow down in the computations) to a few more qubits exploiting the binary operational nature of many-body systems. While any solver could use operations instead of matrices, it is a good testing bead to use Krylov's algorithm because of a property when constructing this space. This feature is a must-have within our research group, and everyone could also benefit from it. More importantly, Krylov is gaining increasing interest in the research community, and we believe that providing it as a qutip solver will increase the traffic of the repository. Regarding benchmarks and some documentation, we have a public jupyter notebook with some benchmarks here [krylov use examples](https://colab.research.google.com/drive/1f7ng8q9QNEzaZ97vGop3aIip8GPtl3GR?usp=sharing), and there's also a [medium blog post](https://medium.com/@julian.ruffinelli/krylov-approximation-method-for-quantum-evolution-148b3f023ec4) with some other details. As for maintenance, yes, the way this code-block fits in should not be problematic to update even with qutip changes. We use <code>krylovsolve</code> for research and will keep the solver repo outside qutip up to date and (hopefully!) inside of it for the community.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1668#issuecomment-926236528
https://github.com/qutip/qutip/issues/1668#issuecomment-926236528:1112,Testability,test,testing,1112,"ngs regarding porting it directly into qutip, and we agreed it would be a good addition as a separate solver. There are a couple of we-believe-good reasons to provide <code>krylovsolve</code> as another qutip solver. As you mention, the method is currently limited to constant closed system Hamiltonians. Another possible addition discussed during the meetings was support for open quantum systems, which provides another unitary-fund grant opportunity for some students!. Another important application for many-body systems comes in handy with Krylov. Given the memory limitations from matrix representation of operators and the exponential growth of many-body systems Hilbert spaces, the limit of qubits on which the solvers live is around 15 qubits. This limitation gets expanded (in exchange for some slow down in the computations) to a few more qubits exploiting the binary operational nature of many-body systems. While any solver could use operations instead of matrices, it is a good testing bead to use Krylov's algorithm because of a property when constructing this space. This feature is a must-have within our research group, and everyone could also benefit from it. More importantly, Krylov is gaining increasing interest in the research community, and we believe that providing it as a qutip solver will increase the traffic of the repository. Regarding benchmarks and some documentation, we have a public jupyter notebook with some benchmarks here [krylov use examples](https://colab.research.google.com/drive/1f7ng8q9QNEzaZ97vGop3aIip8GPtl3GR?usp=sharing), and there's also a [medium blog post](https://medium.com/@julian.ruffinelli/krylov-approximation-method-for-quantum-evolution-148b3f023ec4) with some other details. As for maintenance, yes, the way this code-block fits in should not be problematic to update even with qutip changes. We use <code>krylovsolve</code> for research and will keep the solver repo outside qutip up to date and (hopefully!) inside of it for the communi",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1668#issuecomment-926236528
https://github.com/qutip/qutip/issues/1668#issuecomment-926236528:1488,Testability,benchmark,benchmarks,1488,"regarding porting it directly into qutip, and we agreed it would be a good addition as a separate solver. There are a couple of we-believe-good reasons to provide <code>krylovsolve</code> as another qutip solver. As you mention, the method is currently limited to constant closed system Hamiltonians. Another possible addition discussed during the meetings was support for open quantum systems, which provides another unitary-fund grant opportunity for some students!. Another important application for many-body systems comes in handy with Krylov. Given the memory limitations from matrix representation of operators and the exponential growth of many-body systems Hilbert spaces, the limit of qubits on which the solvers live is around 15 qubits. This limitation gets expanded (in exchange for some slow down in the computations) to a few more qubits exploiting the binary operational nature of many-body systems. While any solver could use operations instead of matrices, it is a good testing bead to use Krylov's algorithm because of a property when constructing this space. This feature is a must-have within our research group, and everyone could also benefit from it. More importantly, Krylov is gaining increasing interest in the research community, and we believe that providing it as a qutip solver will increase the traffic of the repository. Regarding benchmarks and some documentation, we have a public jupyter notebook with some benchmarks here [krylov use examples](https://colab.research.google.com/drive/1f7ng8q9QNEzaZ97vGop3aIip8GPtl3GR?usp=sharing), and there's also a [medium blog post](https://medium.com/@julian.ruffinelli/krylov-approximation-method-for-quantum-evolution-148b3f023ec4) with some other details. As for maintenance, yes, the way this code-block fits in should not be problematic to update even with qutip changes. We use <code>krylovsolve</code> for research and will keep the solver repo outside qutip up to date and (hopefully!) inside of it for the community.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1668#issuecomment-926236528
https://github.com/qutip/qutip/issues/1668#issuecomment-926236528:1567,Testability,benchmark,benchmarks,1567,"regarding porting it directly into qutip, and we agreed it would be a good addition as a separate solver. There are a couple of we-believe-good reasons to provide <code>krylovsolve</code> as another qutip solver. As you mention, the method is currently limited to constant closed system Hamiltonians. Another possible addition discussed during the meetings was support for open quantum systems, which provides another unitary-fund grant opportunity for some students!. Another important application for many-body systems comes in handy with Krylov. Given the memory limitations from matrix representation of operators and the exponential growth of many-body systems Hilbert spaces, the limit of qubits on which the solvers live is around 15 qubits. This limitation gets expanded (in exchange for some slow down in the computations) to a few more qubits exploiting the binary operational nature of many-body systems. While any solver could use operations instead of matrices, it is a good testing bead to use Krylov's algorithm because of a property when constructing this space. This feature is a must-have within our research group, and everyone could also benefit from it. More importantly, Krylov is gaining increasing interest in the research community, and we believe that providing it as a qutip solver will increase the traffic of the repository. Regarding benchmarks and some documentation, we have a public jupyter notebook with some benchmarks here [krylov use examples](https://colab.research.google.com/drive/1f7ng8q9QNEzaZ97vGop3aIip8GPtl3GR?usp=sharing), and there's also a [medium blog post](https://medium.com/@julian.ruffinelli/krylov-approximation-method-for-quantum-evolution-148b3f023ec4) with some other details. As for maintenance, yes, the way this code-block fits in should not be problematic to update even with qutip changes. We use <code>krylovsolve</code> for research and will keep the solver repo outside qutip up to date and (hopefully!) inside of it for the community.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1668#issuecomment-926236528
https://github.com/qutip/qutip/issues/1668#issuecomment-973132966:294,Availability,Ping,Pinging,294,"A blog post with the method is now hosted also at https://unitary.fund/posts/krylov.html; @Ericgig @emilianomfortes what is the next step? I suggest you proceed by opening a PR. Due to the limitations of the method applicability, I could see a use for it as `krylovsolve` for the time being. ; Pinging also @quantshah @cgranade who've been involved in the mentoring of the project.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1668#issuecomment-973132966
https://github.com/qutip/qutip/issues/1668#issuecomment-1097168085:153,Usability,guid,guide,153,Do you have time to add some of the documentation for krylovsolve to the QuTiP documentation? Converting the example Jupyter notebook and blog post to a guide (under `doc/guide/` in the qutip repository) might be one sensible approach.,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1668#issuecomment-1097168085
https://github.com/qutip/qutip/issues/1668#issuecomment-1097168085:171,Usability,guid,guide,171,Do you have time to add some of the documentation for krylovsolve to the QuTiP documentation? Converting the example Jupyter notebook and blog post to a guide (under `doc/guide/` in the qutip repository) might be one sensible approach.,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1668#issuecomment-1097168085
https://github.com/qutip/qutip/issues/1668#issuecomment-1126039633:39,Usability,guid,guide,39,Thanks @emilianomfortes for adding the guide. :rocket:,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1668#issuecomment-1126039633
https://github.com/qutip/qutip/pull/1670#issuecomment-926922437:242,Usability,simpl,simple,242,"> I also made a [`einsum` dispatched function](https://github.com/Ericgig/qutip/tree/einsum) as an alternative to this, (with a working `einsum_csr` for a pair of csr matrices). Cool! I agree that element-wise multiply is a pretty common and simple operation though, so it's probably worthwhile having regardless of whether we have einsum or not.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1670#issuecomment-926922437
https://github.com/qutip/qutip/pull/1670#issuecomment-928390255:273,Availability,error,error,273,"I added support for `nan`.; But most `CSR` operation are not careful about them, `mul` as a fast pass that `*0` return a new zeros matrix without ever reading the original array. I believe that instead of supporting `nan`, operation that could create `nan` should raise an error.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1670#issuecomment-928390255
https://github.com/qutip/qutip/issues/1671#issuecomment-927737428:49,Integrability,Depend,Depending,49,"@riccameng Hi!. I think this is very achievable. Depending a bit on your time scales, it might make sense to work with QuTiP 5, which is currently under development in the `dev.major` branch. Version 5 includes much better QobjEvo support, much cleaner and more pluggable solvers (which should be merged into `dev.major` later this week), and a pluggable data layer. Some of these might be very helpful to you. For the rest of the discussion I will assume we are targeting QuTiP 5 unless you tell me otherwise. Some questions and thoughts from my side:. * As a first step you might be able to use v5s sparse (csr) data layer and write a custom ODE solver that performs the low-level evolution across multiple cores.; * If that works nicely, it could be extended to work across multiple nodes.; * For quantum circuit simulation, I think you can just ask @BoxiLi in a separate issue in https://github.com/qutip/qutip-qip about adding support for sparse unitaries in circuit simulation. I'm not sure if there are reasons why this might be difficult, but let's open an issue there and see.; * If the operators or states are too big to be stored in main memory even when they're sparse, we'll also need to figure out how to store them. Possibly this would involve a new data layer of some sort, but let's cross that road when we get to it.; * One of the challenges with HPC support is how to ensure we don't break it while continuing to evolve QuTiP. There are two challenges here. The first is to make sure that the code runs correctly -- I'm guessing there is some way to run MPI nicely on a single machine in our unit tests. The second is to make sure that performance isn't negatively impacted by changes. Do you have any thoughts on either of these?. It's exciting to see QuTiP being used on really big hardware. Looking forward to working with you however we can.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1671#issuecomment-927737428
https://github.com/qutip/qutip/issues/1671#issuecomment-927737428:753,Modifiability,extend,extended,753,"@riccameng Hi!. I think this is very achievable. Depending a bit on your time scales, it might make sense to work with QuTiP 5, which is currently under development in the `dev.major` branch. Version 5 includes much better QobjEvo support, much cleaner and more pluggable solvers (which should be merged into `dev.major` later this week), and a pluggable data layer. Some of these might be very helpful to you. For the rest of the discussion I will assume we are targeting QuTiP 5 unless you tell me otherwise. Some questions and thoughts from my side:. * As a first step you might be able to use v5s sparse (csr) data layer and write a custom ODE solver that performs the low-level evolution across multiple cores.; * If that works nicely, it could be extended to work across multiple nodes.; * For quantum circuit simulation, I think you can just ask @BoxiLi in a separate issue in https://github.com/qutip/qutip-qip about adding support for sparse unitaries in circuit simulation. I'm not sure if there are reasons why this might be difficult, but let's open an issue there and see.; * If the operators or states are too big to be stored in main memory even when they're sparse, we'll also need to figure out how to store them. Possibly this would involve a new data layer of some sort, but let's cross that road when we get to it.; * One of the challenges with HPC support is how to ensure we don't break it while continuing to evolve QuTiP. There are two challenges here. The first is to make sure that the code runs correctly -- I'm guessing there is some way to run MPI nicely on a single machine in our unit tests. The second is to make sure that performance isn't negatively impacted by changes. Do you have any thoughts on either of these?. It's exciting to see QuTiP being used on really big hardware. Looking forward to working with you however we can.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1671#issuecomment-927737428
https://github.com/qutip/qutip/issues/1671#issuecomment-927737428:1432,Modifiability,evolve,evolve,1432,"@riccameng Hi!. I think this is very achievable. Depending a bit on your time scales, it might make sense to work with QuTiP 5, which is currently under development in the `dev.major` branch. Version 5 includes much better QobjEvo support, much cleaner and more pluggable solvers (which should be merged into `dev.major` later this week), and a pluggable data layer. Some of these might be very helpful to you. For the rest of the discussion I will assume we are targeting QuTiP 5 unless you tell me otherwise. Some questions and thoughts from my side:. * As a first step you might be able to use v5s sparse (csr) data layer and write a custom ODE solver that performs the low-level evolution across multiple cores.; * If that works nicely, it could be extended to work across multiple nodes.; * For quantum circuit simulation, I think you can just ask @BoxiLi in a separate issue in https://github.com/qutip/qutip-qip about adding support for sparse unitaries in circuit simulation. I'm not sure if there are reasons why this might be difficult, but let's open an issue there and see.; * If the operators or states are too big to be stored in main memory even when they're sparse, we'll also need to figure out how to store them. Possibly this would involve a new data layer of some sort, but let's cross that road when we get to it.; * One of the challenges with HPC support is how to ensure we don't break it while continuing to evolve QuTiP. There are two challenges here. The first is to make sure that the code runs correctly -- I'm guessing there is some way to run MPI nicely on a single machine in our unit tests. The second is to make sure that performance isn't negatively impacted by changes. Do you have any thoughts on either of these?. It's exciting to see QuTiP being used on really big hardware. Looking forward to working with you however we can.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1671#issuecomment-927737428
https://github.com/qutip/qutip/issues/1671#issuecomment-927737428:660,Performance,perform,performs,660,"@riccameng Hi!. I think this is very achievable. Depending a bit on your time scales, it might make sense to work with QuTiP 5, which is currently under development in the `dev.major` branch. Version 5 includes much better QobjEvo support, much cleaner and more pluggable solvers (which should be merged into `dev.major` later this week), and a pluggable data layer. Some of these might be very helpful to you. For the rest of the discussion I will assume we are targeting QuTiP 5 unless you tell me otherwise. Some questions and thoughts from my side:. * As a first step you might be able to use v5s sparse (csr) data layer and write a custom ODE solver that performs the low-level evolution across multiple cores.; * If that works nicely, it could be extended to work across multiple nodes.; * For quantum circuit simulation, I think you can just ask @BoxiLi in a separate issue in https://github.com/qutip/qutip-qip about adding support for sparse unitaries in circuit simulation. I'm not sure if there are reasons why this might be difficult, but let's open an issue there and see.; * If the operators or states are too big to be stored in main memory even when they're sparse, we'll also need to figure out how to store them. Possibly this would involve a new data layer of some sort, but let's cross that road when we get to it.; * One of the challenges with HPC support is how to ensure we don't break it while continuing to evolve QuTiP. There are two challenges here. The first is to make sure that the code runs correctly -- I'm guessing there is some way to run MPI nicely on a single machine in our unit tests. The second is to make sure that performance isn't negatively impacted by changes. Do you have any thoughts on either of these?. It's exciting to see QuTiP being used on really big hardware. Looking forward to working with you however we can.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1671#issuecomment-927737428
https://github.com/qutip/qutip/issues/1671#issuecomment-927737428:1655,Performance,perform,performance,1655,"@riccameng Hi!. I think this is very achievable. Depending a bit on your time scales, it might make sense to work with QuTiP 5, which is currently under development in the `dev.major` branch. Version 5 includes much better QobjEvo support, much cleaner and more pluggable solvers (which should be merged into `dev.major` later this week), and a pluggable data layer. Some of these might be very helpful to you. For the rest of the discussion I will assume we are targeting QuTiP 5 unless you tell me otherwise. Some questions and thoughts from my side:. * As a first step you might be able to use v5s sparse (csr) data layer and write a custom ODE solver that performs the low-level evolution across multiple cores.; * If that works nicely, it could be extended to work across multiple nodes.; * For quantum circuit simulation, I think you can just ask @BoxiLi in a separate issue in https://github.com/qutip/qutip-qip about adding support for sparse unitaries in circuit simulation. I'm not sure if there are reasons why this might be difficult, but let's open an issue there and see.; * If the operators or states are too big to be stored in main memory even when they're sparse, we'll also need to figure out how to store them. Possibly this would involve a new data layer of some sort, but let's cross that road when we get to it.; * One of the challenges with HPC support is how to ensure we don't break it while continuing to evolve QuTiP. There are two challenges here. The first is to make sure that the code runs correctly -- I'm guessing there is some way to run MPI nicely on a single machine in our unit tests. The second is to make sure that performance isn't negatively impacted by changes. Do you have any thoughts on either of these?. It's exciting to see QuTiP being used on really big hardware. Looking forward to working with you however we can.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1671#issuecomment-927737428
https://github.com/qutip/qutip/issues/1671#issuecomment-927737428:1616,Testability,test,tests,1616,"@riccameng Hi!. I think this is very achievable. Depending a bit on your time scales, it might make sense to work with QuTiP 5, which is currently under development in the `dev.major` branch. Version 5 includes much better QobjEvo support, much cleaner and more pluggable solvers (which should be merged into `dev.major` later this week), and a pluggable data layer. Some of these might be very helpful to you. For the rest of the discussion I will assume we are targeting QuTiP 5 unless you tell me otherwise. Some questions and thoughts from my side:. * As a first step you might be able to use v5s sparse (csr) data layer and write a custom ODE solver that performs the low-level evolution across multiple cores.; * If that works nicely, it could be extended to work across multiple nodes.; * For quantum circuit simulation, I think you can just ask @BoxiLi in a separate issue in https://github.com/qutip/qutip-qip about adding support for sparse unitaries in circuit simulation. I'm not sure if there are reasons why this might be difficult, but let's open an issue there and see.; * If the operators or states are too big to be stored in main memory even when they're sparse, we'll also need to figure out how to store them. Possibly this would involve a new data layer of some sort, but let's cross that road when we get to it.; * One of the challenges with HPC support is how to ensure we don't break it while continuing to evolve QuTiP. There are two challenges here. The first is to make sure that the code runs correctly -- I'm guessing there is some way to run MPI nicely on a single machine in our unit tests. The second is to make sure that performance isn't negatively impacted by changes. Do you have any thoughts on either of these?. It's exciting to see QuTiP being used on really big hardware. Looking forward to working with you however we can.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1671#issuecomment-927737428
https://github.com/qutip/qutip/issues/1671#issuecomment-927913489:322,Performance,bottleneck,bottlenecks,322,"Great feedback @hodgestar. Let me add this: It would be nice to clarify explicitly benchmarks from the beginning. ; A bit like you did when mentioning the 14 qubit cap for QFT gate simulation. ; For example, goals of this would be:; - For qutip/qutip: Faster `mesolve` (add details of a typical example with current times/bottlenecks); - - For qutip/qutip: More qubits simulated in `mesolve` and `steadystate` ; - For qutip/qutip-qip: Capability to simulate more qubits (add current example with benchmark + code). For all examples we could add details of a typical example with current times/bottlenecks (we could use gists). This can be of very wide interest, but finding physical examples of interests and use cases would be helpful. For example, qubit space nevertheless explodes exponentially. But adding even a bit more qubits in `steadystate` can impact state of the art simulation of dissipative phase transitions in many-body systems. I also think that having a sort of code design template could help. This is a more general point triggered by this issue. This may be a QuTiP idea but looks at some point more technical.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1671#issuecomment-927913489
https://github.com/qutip/qutip/issues/1671#issuecomment-927913489:593,Performance,bottleneck,bottlenecks,593,"Great feedback @hodgestar. Let me add this: It would be nice to clarify explicitly benchmarks from the beginning. ; A bit like you did when mentioning the 14 qubit cap for QFT gate simulation. ; For example, goals of this would be:; - For qutip/qutip: Faster `mesolve` (add details of a typical example with current times/bottlenecks); - - For qutip/qutip: More qubits simulated in `mesolve` and `steadystate` ; - For qutip/qutip-qip: Capability to simulate more qubits (add current example with benchmark + code). For all examples we could add details of a typical example with current times/bottlenecks (we could use gists). This can be of very wide interest, but finding physical examples of interests and use cases would be helpful. For example, qubit space nevertheless explodes exponentially. But adding even a bit more qubits in `steadystate` can impact state of the art simulation of dissipative phase transitions in many-body systems. I also think that having a sort of code design template could help. This is a more general point triggered by this issue. This may be a QuTiP idea but looks at some point more technical.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1671#issuecomment-927913489
https://github.com/qutip/qutip/issues/1671#issuecomment-927913489:83,Testability,benchmark,benchmarks,83,"Great feedback @hodgestar. Let me add this: It would be nice to clarify explicitly benchmarks from the beginning. ; A bit like you did when mentioning the 14 qubit cap for QFT gate simulation. ; For example, goals of this would be:; - For qutip/qutip: Faster `mesolve` (add details of a typical example with current times/bottlenecks); - - For qutip/qutip: More qubits simulated in `mesolve` and `steadystate` ; - For qutip/qutip-qip: Capability to simulate more qubits (add current example with benchmark + code). For all examples we could add details of a typical example with current times/bottlenecks (we could use gists). This can be of very wide interest, but finding physical examples of interests and use cases would be helpful. For example, qubit space nevertheless explodes exponentially. But adding even a bit more qubits in `steadystate` can impact state of the art simulation of dissipative phase transitions in many-body systems. I also think that having a sort of code design template could help. This is a more general point triggered by this issue. This may be a QuTiP idea but looks at some point more technical.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1671#issuecomment-927913489
https://github.com/qutip/qutip/issues/1671#issuecomment-927913489:496,Testability,benchmark,benchmark,496,"Great feedback @hodgestar. Let me add this: It would be nice to clarify explicitly benchmarks from the beginning. ; A bit like you did when mentioning the 14 qubit cap for QFT gate simulation. ; For example, goals of this would be:; - For qutip/qutip: Faster `mesolve` (add details of a typical example with current times/bottlenecks); - - For qutip/qutip: More qubits simulated in `mesolve` and `steadystate` ; - For qutip/qutip-qip: Capability to simulate more qubits (add current example with benchmark + code). For all examples we could add details of a typical example with current times/bottlenecks (we could use gists). This can be of very wide interest, but finding physical examples of interests and use cases would be helpful. For example, qubit space nevertheless explodes exponentially. But adding even a bit more qubits in `steadystate` can impact state of the art simulation of dissipative phase transitions in many-body systems. I also think that having a sort of code design template could help. This is a more general point triggered by this issue. This may be a QuTiP idea but looks at some point more technical.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1671#issuecomment-927913489
https://github.com/qutip/qutip/issues/1671#issuecomment-927913489:6,Usability,feedback,feedback,6,"Great feedback @hodgestar. Let me add this: It would be nice to clarify explicitly benchmarks from the beginning. ; A bit like you did when mentioning the 14 qubit cap for QFT gate simulation. ; For example, goals of this would be:; - For qutip/qutip: Faster `mesolve` (add details of a typical example with current times/bottlenecks); - - For qutip/qutip: More qubits simulated in `mesolve` and `steadystate` ; - For qutip/qutip-qip: Capability to simulate more qubits (add current example with benchmark + code). For all examples we could add details of a typical example with current times/bottlenecks (we could use gists). This can be of very wide interest, but finding physical examples of interests and use cases would be helpful. For example, qubit space nevertheless explodes exponentially. But adding even a bit more qubits in `steadystate` can impact state of the art simulation of dissipative phase transitions in many-body systems. I also think that having a sort of code design template could help. This is a more general point triggered by this issue. This may be a QuTiP idea but looks at some point more technical.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1671#issuecomment-927913489
https://github.com/qutip/qutip/issues/1671#issuecomment-946521985:117,Deployability,install,installed,117,"Hi everyone and thank you all for the helpful advices.; I started testing OpenMP on v4. Some news from my side:; - I installed Qutip with OpenMP on Marconi100 and Galileo100 ; - I chose the spin-chain.ipynb example in https://github.com/qutip/qutip-notebooks/ for testing; - I passed options to `mesolve` in this way (varying n1, n2 and also the number of spins N): ; ```; opts=Options(num_cpus=n1 openmp_threads=n2, use_openmp=True); result = mesolve(H, psi0, tlist, c_op_list, sz_list, options=opts); ```; Unfortunately I didn't get any improvement. Do you have any ideas about it? Am I using OpenMP wrong or is the example chosen not adequate? Can you point me a snippet of code that you are sure works with OpenMP? ; Thank you so much!!!",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1671#issuecomment-946521985
https://github.com/qutip/qutip/issues/1671#issuecomment-946521985:66,Testability,test,testing,66,"Hi everyone and thank you all for the helpful advices.; I started testing OpenMP on v4. Some news from my side:; - I installed Qutip with OpenMP on Marconi100 and Galileo100 ; - I chose the spin-chain.ipynb example in https://github.com/qutip/qutip-notebooks/ for testing; - I passed options to `mesolve` in this way (varying n1, n2 and also the number of spins N): ; ```; opts=Options(num_cpus=n1 openmp_threads=n2, use_openmp=True); result = mesolve(H, psi0, tlist, c_op_list, sz_list, options=opts); ```; Unfortunately I didn't get any improvement. Do you have any ideas about it? Am I using OpenMP wrong or is the example chosen not adequate? Can you point me a snippet of code that you are sure works with OpenMP? ; Thank you so much!!!",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1671#issuecomment-946521985
https://github.com/qutip/qutip/issues/1671#issuecomment-946521985:264,Testability,test,testing,264,"Hi everyone and thank you all for the helpful advices.; I started testing OpenMP on v4. Some news from my side:; - I installed Qutip with OpenMP on Marconi100 and Galileo100 ; - I chose the spin-chain.ipynb example in https://github.com/qutip/qutip-notebooks/ for testing; - I passed options to `mesolve` in this way (varying n1, n2 and also the number of spins N): ; ```; opts=Options(num_cpus=n1 openmp_threads=n2, use_openmp=True); result = mesolve(H, psi0, tlist, c_op_list, sz_list, options=opts); ```; Unfortunately I didn't get any improvement. Do you have any ideas about it? Am I using OpenMP wrong or is the example chosen not adequate? Can you point me a snippet of code that you are sure works with OpenMP? ; Thank you so much!!!",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1671#issuecomment-946521985
https://github.com/qutip/qutip/issues/1671#issuecomment-947162020:223,Deployability,Install,Installed,223,"@riccameng I think the first thing to check is whether QuTiP has been compiled with OpenMP and has successfully built its own OpenMP support. You can do this with:; ```python; import qutip; qutip.about() # look for ""OPENMP Installed""; qutip.settings.has_openmp # should be True; qutip.settings.openmp_thresh # this is the number of non-zero elements a problem needs to have before OpenMP is activated; ```. If the above shows that QuTiP has found OpenMP successfully, would you mind creating a pastebin or gist the actual code you ran somewhere, along with the values of the parameters? Debugging this with a later number of unknowns could potential waste a lot of time. If not, could you clarify (i.e. provide shell commands used) what ""installed QuTiP with OpenMP"" means.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1671#issuecomment-947162020
https://github.com/qutip/qutip/issues/1671#issuecomment-947162020:738,Deployability,install,installed,738,"@riccameng I think the first thing to check is whether QuTiP has been compiled with OpenMP and has successfully built its own OpenMP support. You can do this with:; ```python; import qutip; qutip.about() # look for ""OPENMP Installed""; qutip.settings.has_openmp # should be True; qutip.settings.openmp_thresh # this is the number of non-zero elements a problem needs to have before OpenMP is activated; ```. If the above shows that QuTiP has found OpenMP successfully, would you mind creating a pastebin or gist the actual code you ran somewhere, along with the values of the parameters? Debugging this with a later number of unknowns could potential waste a lot of time. If not, could you clarify (i.e. provide shell commands used) what ""installed QuTiP with OpenMP"" means.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1671#issuecomment-947162020
https://github.com/qutip/qutip/issues/1671#issuecomment-948005544:142,Testability,test,tests,142,"`setup.py` do not add the `-fopenmp` flag on linux. It still use the openmp version of the `CSR * vector` product but without any gain... Our tests only check that openmp does not break anything, not for speedup so it was broken for quite some time.; It should be is quick fix. But even when fixed the scaling is not great, I get at most a 2x.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1671#issuecomment-948005544
https://github.com/qutip/qutip/issues/1672#issuecomment-929486716:91,Deployability,release,release,91,"Thanks for your comment!; I somehow missed the note that it's on a TODO for the next major release - that's great, as it will make things a bit more consistent.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1672#issuecomment-929486716
https://github.com/qutip/qutip/issues/1673#issuecomment-927694147:1191,Modifiability,evolve,evolve,1191,"@cgranade Thank you for the detailed write-up. I have some questions below. I have my own ideas of answers to some of these questions, but I'd like to hear yours. * What do you see as the primary drivers for this new feature?; * What is the advantage of this over using the existing superoperator representations?; * Can this advantage be carryied over into, e.g., using solvers, eigenvalue finding, etc?; * Would it be better to have a new object, sort of like QobjEvo but for sums rather than evolutions?; * How do you see the various mathematical operations working?. Given that currently `dims` describe the dimension of the Hilbert space and that the dimension isn't changing, I feel `dims` is perhaps an odd place to put the number of elements in the sum, but that doesn't prevent this becoming a feature of Qobj in some other way. Either way, QobjEvo would need to support this too (probably not a giant amount of work, but some careful checking would be needed) & some other parts of the code might be surprised. @jakelishman had some ideas for revamping dims support in QuTiP. I don't think it's the same idea, but the two definitely overlap in terms of which parts of QuTiP they'd evolve. Jake, would you mind posting the link to your dims proposal here if you have it handy (apologies, I seem to have lost it). Even if dims isn't the right place for this, it would be good for me to reread it.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1673#issuecomment-927694147
https://github.com/qutip/qutip/issues/1673#issuecomment-927981574:2522,Integrability,interface,interface,2522,"lution that works for both. > * What is the advantage of this over using the existing superoperator representations?. I don't think there is one, per se, in the same sense that there's no strict advantage to superoperators over Choi operators over χ operators — each is useful in different contexts, such that QuTiP supports all three in order to allow users to pick the right representation for their problem. Similarly, operator-sum decompositions of channels are quite common and are useful in some special circumstances (e.g.: expressing a Choi-rank–sparse channel without requiring a 4^n × 4^n matrix). In the Quantum Development Kit, for instance, we use `qutip.to_kraus` to express user-supplied superoperators, Choi operators, and χ operators in terms of an operator-sum decomposition that is then passed to the underlying open systems simulator. While the operator-sum decomposition is quite useful internally to the simulator, that's not a detail that we want to enforce upon users, such that QuTiP's support for multiple superoperator representations is quite useful in presenting a user-friendly interface for configuring noise models. > * Can this advantage be carryied over into, e.g., using solvers, eigenvalue finding, etc?. I'm not sure I entirely follow, sorry?. > * Would it be better to have a new object, sort of like QobjEvo but for sums rather than evolutions?. Perhaps, but at least for the operator-sum decomposition of channels, it would feel a bit weird to me to have superoperators, Choi operators and χ operators all have one Python type, but for Kraus representations to have a fully different Python type. Whether I represent Λ(ρ) by 0.9 𝟙ρ𝟙 + 0.1 𝑋ρ𝑋 or {√(0.9) 𝟙, √(0.1) 𝑋}, they both represent the same function from density operators to density operators. > * How do you see the various mathematical operations working?. My thought here would be that an operator-sum decomposition of a channel is just that: a representation of a channel. Thus, if `lambda_` is a `Qo",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1673#issuecomment-927981574
https://github.com/qutip/qutip/issues/1673#issuecomment-927981574:2536,Modifiability,config,configuring,2536,"lution that works for both. > * What is the advantage of this over using the existing superoperator representations?. I don't think there is one, per se, in the same sense that there's no strict advantage to superoperators over Choi operators over χ operators — each is useful in different contexts, such that QuTiP supports all three in order to allow users to pick the right representation for their problem. Similarly, operator-sum decompositions of channels are quite common and are useful in some special circumstances (e.g.: expressing a Choi-rank–sparse channel without requiring a 4^n × 4^n matrix). In the Quantum Development Kit, for instance, we use `qutip.to_kraus` to express user-supplied superoperators, Choi operators, and χ operators in terms of an operator-sum decomposition that is then passed to the underlying open systems simulator. While the operator-sum decomposition is quite useful internally to the simulator, that's not a detail that we want to enforce upon users, such that QuTiP's support for multiple superoperator representations is quite useful in presenting a user-friendly interface for configuring noise models. > * Can this advantage be carryied over into, e.g., using solvers, eigenvalue finding, etc?. I'm not sure I entirely follow, sorry?. > * Would it be better to have a new object, sort of like QobjEvo but for sums rather than evolutions?. Perhaps, but at least for the operator-sum decomposition of channels, it would feel a bit weird to me to have superoperators, Choi operators and χ operators all have one Python type, but for Kraus representations to have a fully different Python type. Whether I represent Λ(ρ) by 0.9 𝟙ρ𝟙 + 0.1 𝑋ρ𝑋 or {√(0.9) 𝟙, √(0.1) 𝑋}, they both represent the same function from density operators to density operators. > * How do you see the various mathematical operations working?. My thought here would be that an operator-sum decomposition of a channel is just that: a representation of a channel. Thus, if `lambda_` is a `Qo",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1673#issuecomment-927981574
https://github.com/qutip/qutip/issues/1673#issuecomment-927981574:4731,Modifiability,evolve,evolve,4731,"epresentations to have a fully different Python type. Whether I represent Λ(ρ) by 0.9 𝟙ρ𝟙 + 0.1 𝑋ρ𝑋 or {√(0.9) 𝟙, √(0.1) 𝑋}, they both represent the same function from density operators to density operators. > * How do you see the various mathematical operations working?. My thought here would be that an operator-sum decomposition of a channel is just that: a representation of a channel. Thus, if `lambda_` is a `Qobj` representing the operator-sum decomposition of Λ and `phi` is the representation of Φ, then `lambda_ + phi` should be some superoperator representation (most likely Kraus to match inputs) of the function (Λ + Φ)(ρ) = Λ﴾ρ) + Φ(ρ). Similarly, multiplying by a scalar 𝑠 would rescale each term by √𝑠 so that the corresponding function is (𝑠Λ)(ρ) = s · (Λ(ρ)) and multiplying two channels in Kraus decomposition would return their decomposition, (ΦΛ)(ρ) = (Φ ∘ Λ)(ρ) = Φ(Λ(ρ)). > Given that currently `dims` describe the dimension of the Hilbert space and that the dimension isn't changing, I feel `dims` is perhaps an odd place to put the number of elements in the sum, but that doesn't prevent this becoming a feature of Qobj in some other way. Fair enough; I guess my thinking there was that the term index is indeed just another kind of index, but if there's a better way to represent that in the metadata for a Qobj than in `dims`, I'm all for it!. > Either way, QobjEvo would need to support this too (probably not a giant amount of work, but some careful checking would be needed) & some other parts of the code might be surprised.; > ; > @jakelishman had some ideas for revamping dims support in QuTiP. I don't think it's the same idea, but the two definitely overlap in terms of which parts of QuTiP they'd evolve. Jake, would you mind posting the link to your dims proposal here if you have it handy (apologies, I seem to have lost it). Even if dims isn't the right place for this, it would be good for me to reread it. Ah, nice, I hadn't realized! I'll take a look, then!",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1673#issuecomment-927981574
https://github.com/qutip/qutip/issues/1673#issuecomment-927981574:2508,Usability,user-friendly,user-friendly,2508,"lution that works for both. > * What is the advantage of this over using the existing superoperator representations?. I don't think there is one, per se, in the same sense that there's no strict advantage to superoperators over Choi operators over χ operators — each is useful in different contexts, such that QuTiP supports all three in order to allow users to pick the right representation for their problem. Similarly, operator-sum decompositions of channels are quite common and are useful in some special circumstances (e.g.: expressing a Choi-rank–sparse channel without requiring a 4^n × 4^n matrix). In the Quantum Development Kit, for instance, we use `qutip.to_kraus` to express user-supplied superoperators, Choi operators, and χ operators in terms of an operator-sum decomposition that is then passed to the underlying open systems simulator. While the operator-sum decomposition is quite useful internally to the simulator, that's not a detail that we want to enforce upon users, such that QuTiP's support for multiple superoperator representations is quite useful in presenting a user-friendly interface for configuring noise models. > * Can this advantage be carryied over into, e.g., using solvers, eigenvalue finding, etc?. I'm not sure I entirely follow, sorry?. > * Would it be better to have a new object, sort of like QobjEvo but for sums rather than evolutions?. Perhaps, but at least for the operator-sum decomposition of channels, it would feel a bit weird to me to have superoperators, Choi operators and χ operators all have one Python type, but for Kraus representations to have a fully different Python type. Whether I represent Λ(ρ) by 0.9 𝟙ρ𝟙 + 0.1 𝑋ρ𝑋 or {√(0.9) 𝟙, √(0.1) 𝑋}, they both represent the same function from density operators to density operators. > * How do you see the various mathematical operations working?. My thought here would be that an operator-sum decomposition of a channel is just that: a representation of a channel. Thus, if `lambda_` is a `Qo",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1673#issuecomment-927981574
https://github.com/qutip/qutip/issues/1673#issuecomment-940314000:6,Deployability,update,update,6,"Quick update for readers: We (@cgranade, @jakelishman, @Ericgig and I) agreed that the best next step is to implement a draft `Instrument` class that shows the function signatures and interactions with `Qobj` and a few examples and then to see where to go from there.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1673#issuecomment-940314000
https://github.com/qutip/qutip/pull/1674#issuecomment-991972646:30,Testability,test,testing,30,"The following can be used for testing: @hodgestar ; ```python; import qutip. dm = qutip.rand_dm(4); fig, ax = qutip.hinton(dm); fig.show(). qutip.settings.colorblind_safe = True; fig, ax = qutip.hinton(dm, color_style=""threshold""); fig.show(); qutip.settings.colorblind_safe = False. fig, ax = qutip.hinton(dm, color_style=""phase""); fig.show(); ```",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1674#issuecomment-991972646
https://github.com/qutip/qutip/pull/1675#issuecomment-927639215:221,Deployability,update,update-floquet-guide-fesolve-call,221,[![Coverage Status](https://coveralls.io/builds/43080503/badge)](https://coveralls.io/builds/43080503). Coverage increased (+0.004%) to 65.871% when pulling **a377949b2d459876aebac0e60f494924566f7453 on hodgestar:feature/update-floquet-guide-fesolve-call** into **9b235c48217fbc9965f993757b0819ebf8ee1f16 on qutip:master**.,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1675#issuecomment-927639215
https://github.com/qutip/qutip/pull/1675#issuecomment-927639215:236,Usability,guid,guide-fesolve-call,236,[![Coverage Status](https://coveralls.io/builds/43080503/badge)](https://coveralls.io/builds/43080503). Coverage increased (+0.004%) to 65.871% when pulling **a377949b2d459876aebac0e60f494924566f7453 on hodgestar:feature/update-floquet-guide-fesolve-call** into **9b235c48217fbc9965f993757b0819ebf8ee1f16 on qutip:master**.,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1675#issuecomment-927639215
https://github.com/qutip/qutip/pull/1678#issuecomment-929083917:265,Deployability,Update,Update,265,"@jakelishman @nathanshammah I'm guessing out site.css file go dropped accidentally at some point, but I don't actually know why the custom styling in it is there. I could just delete the styling that was there before and we could slowly re-add it if we need to?. **Update**:; * We don't use `alert` anywhere in the generated HTML.; * We don't use `navbar-text` anywhere.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1678#issuecomment-929083917
https://github.com/qutip/qutip/pull/1678#issuecomment-929097733:99,Integrability,message,message,99,"The styling all got added in 5b4777450f5ba2becb790efb3af85482a1704c73 which has the cryptic commit message ""add github fix"". :)",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1678#issuecomment-929097733
https://github.com/qutip/qutip/issues/1683#issuecomment-933398132:61,Availability,down,down,61,"I think this is a good addition. Whether it's accepted comes down to how much complexity it adds to the Bloch sphere class, I suspect. Perhaps open the PR and let's see what the code changes look like?",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1683#issuecomment-933398132
https://github.com/qutip/qutip/issues/1683#issuecomment-933426001:63,Availability,down,down,63,"> I think this is a good addition. Whether it's accepted comes down to how much complexity it adds to the Bloch sphere class, I suspect. Perhaps open the PR and let's see what the code changes look like?. Thank you so much :D ; I will open a PR soon.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1683#issuecomment-933426001
https://github.com/qutip/qutip/issues/1684#issuecomment-933439082:101,Integrability,depend,dependent,101,`rhs_**.pyx` or `cqobjevo_compiled_coeff_**.pyx` are cython compiled function for string-format time-dependent systems.; `rhs_**.pyx` create a function for the right hand side (rhs) of the equation solved by the solver. It's now mostly used in `brmesolve`. `cqobjevo_compiled_coeff_**.pyx` is used in `QobjEvo` with string coefficient. . Which version are you using?; `QobjEvo` should not be found in `Results` and `QobjEvo` can be pickle in recent version...,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1684#issuecomment-933439082
https://github.com/qutip/qutip/issues/1684#issuecomment-934241770:377,Performance,load,load,377,"I can reproduce this problem.; (Note: environment is different of my previous reply, but qutip is latest 4.6.2). I attached a notebook:; https://gist.github.com/KosukeMizuno/5f879603b6343a18fdf0dc50f3f8b7b0#file-checkpyx-ipynb. How to reproduce:; 1. run this notebook; - A `cqobjevo_compiled_coeff_xxx.pyx` file is generated at cell[2].; 2. save output by pickle (cell[4]); 3. load pickled file (cell[5]); - it succeeds.; 4. restart kernel; - At this timing, `pyx` file was automatically removed.; 5. run cell[5] (load pickled file); - it fails. ```; Exception ignored in: <function QobjEvo.__del__ at 0x000001E0295BC4C0>; Traceback (most recent call last):; File ""c:\users\mizuno\research\py38\lib\site-packages\qutip\qobjevo.py"", line 624, in __del__; for file_ in self.coeff_files:; AttributeError: 'QobjEvo' object has no attribute 'coeff_files'; ---------------------------------------------------------------------------; ModuleNotFoundError Traceback (most recent call last); <ipython-input-1-ca5f267c7a72> in <module>; 1 with Path('mesolvedat.pkl').open('rb') as f:; ----> 2 out2 = pickle.load(f). ModuleNotFoundError: No module named 'cqobjevo_compiled_coeff_5082571634280'; ```",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1684#issuecomment-934241770
https://github.com/qutip/qutip/issues/1684#issuecomment-934241770:514,Performance,load,load,514,"I can reproduce this problem.; (Note: environment is different of my previous reply, but qutip is latest 4.6.2). I attached a notebook:; https://gist.github.com/KosukeMizuno/5f879603b6343a18fdf0dc50f3f8b7b0#file-checkpyx-ipynb. How to reproduce:; 1. run this notebook; - A `cqobjevo_compiled_coeff_xxx.pyx` file is generated at cell[2].; 2. save output by pickle (cell[4]); 3. load pickled file (cell[5]); - it succeeds.; 4. restart kernel; - At this timing, `pyx` file was automatically removed.; 5. run cell[5] (load pickled file); - it fails. ```; Exception ignored in: <function QobjEvo.__del__ at 0x000001E0295BC4C0>; Traceback (most recent call last):; File ""c:\users\mizuno\research\py38\lib\site-packages\qutip\qobjevo.py"", line 624, in __del__; for file_ in self.coeff_files:; AttributeError: 'QobjEvo' object has no attribute 'coeff_files'; ---------------------------------------------------------------------------; ModuleNotFoundError Traceback (most recent call last); <ipython-input-1-ca5f267c7a72> in <module>; 1 with Path('mesolvedat.pkl').open('rb') as f:; ----> 2 out2 = pickle.load(f). ModuleNotFoundError: No module named 'cqobjevo_compiled_coeff_5082571634280'; ```",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1684#issuecomment-934241770
https://github.com/qutip/qutip/issues/1684#issuecomment-934241770:1097,Performance,load,load,1097,"I can reproduce this problem.; (Note: environment is different of my previous reply, but qutip is latest 4.6.2). I attached a notebook:; https://gist.github.com/KosukeMizuno/5f879603b6343a18fdf0dc50f3f8b7b0#file-checkpyx-ipynb. How to reproduce:; 1. run this notebook; - A `cqobjevo_compiled_coeff_xxx.pyx` file is generated at cell[2].; 2. save output by pickle (cell[4]); 3. load pickled file (cell[5]); - it succeeds.; 4. restart kernel; - At this timing, `pyx` file was automatically removed.; 5. run cell[5] (load pickled file); - it fails. ```; Exception ignored in: <function QobjEvo.__del__ at 0x000001E0295BC4C0>; Traceback (most recent call last):; File ""c:\users\mizuno\research\py38\lib\site-packages\qutip\qobjevo.py"", line 624, in __del__; for file_ in self.coeff_files:; AttributeError: 'QobjEvo' object has no attribute 'coeff_files'; ---------------------------------------------------------------------------; ModuleNotFoundError Traceback (most recent call last); <ipython-input-1-ca5f267c7a72> in <module>; 1 with Path('mesolvedat.pkl').open('rb') as f:; ----> 2 out2 = pickle.load(f). ModuleNotFoundError: No module named 'cqobjevo_compiled_coeff_5082571634280'; ```",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1684#issuecomment-934241770
https://github.com/qutip/qutip/issues/1684#issuecomment-934345372:382,Deployability,update,update,382,"Looking at it, the issue is in `sesolve` which is called by `mesovle` when no `c_ops` are passed. It save the Hamiltonian in the results. If you do; ```; if hasattr(out, 'SolverSystem'):; out.SolverSystem = None; ```; before pickling, it should work. But I would suggest to extract the states as numpy arrays and use `numpy.save`. With it, the data should stay readable even if you update numpy or python, while any qutip (or scipy) update could make it impossible to unpickle `Qobj`.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1684#issuecomment-934345372
https://github.com/qutip/qutip/issues/1684#issuecomment-934345372:433,Deployability,update,update,433,"Looking at it, the issue is in `sesolve` which is called by `mesovle` when no `c_ops` are passed. It save the Hamiltonian in the results. If you do; ```; if hasattr(out, 'SolverSystem'):; out.SolverSystem = None; ```; before pickling, it should work. But I would suggest to extract the states as numpy arrays and use `numpy.save`. With it, the data should stay readable even if you update numpy or python, while any qutip (or scipy) update could make it impossible to unpickle `Qobj`.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1684#issuecomment-934345372
https://github.com/qutip/qutip/pull/1685#issuecomment-934332552:1008,Integrability,interface,interfaces,1008,"General comment about plotting on the Bloch sphere:. QuTiP currently supports drawing either ""points"" or ""vectors"" (i.e. arrows). Both are specified as `(x, y, z)` coordinates and these are *not* required to lie on the surface of the sphere. Lying outside the sphere is perhaps a bit odd, but lying inside the sphere is a common occurrence -- e.g. when plotting sub-components of a density matrix. There is a method `add_states` that converts states into `(x, y, z)` coordinates and adds them as either points or vectors as requested. I would thus recommend being able to specify lines and arcs using either `(x, y, z)` coordinates or states and not introducing spherical coordinates right now. I'm not against duplicating some of the functionality of `add_points(..., meth=""l"")` in the new functions we add here. For one, the `meth=""l""` is not particular intuitive when looking for a function to draw lines, and, secondly, it doesn't provide particularly flexible styling. My vote is to keep the old method interfaces fairly consistent with how they are now so as not to disrupt existing uses (adding some new optional parameters or tweaking things to look better is fine), and to add a couple of new methods. Let's try not to make the internals of `Bloch` more messy though.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1685#issuecomment-934332552
https://github.com/qutip/qutip/pull/1685#issuecomment-934332552:956,Modifiability,flexible,flexible,956,"General comment about plotting on the Bloch sphere:. QuTiP currently supports drawing either ""points"" or ""vectors"" (i.e. arrows). Both are specified as `(x, y, z)` coordinates and these are *not* required to lie on the surface of the sphere. Lying outside the sphere is perhaps a bit odd, but lying inside the sphere is a common occurrence -- e.g. when plotting sub-components of a density matrix. There is a method `add_states` that converts states into `(x, y, z)` coordinates and adds them as either points or vectors as requested. I would thus recommend being able to specify lines and arcs using either `(x, y, z)` coordinates or states and not introducing spherical coordinates right now. I'm not against duplicating some of the functionality of `add_points(..., meth=""l"")` in the new functions we add here. For one, the `meth=""l""` is not particular intuitive when looking for a function to draw lines, and, secondly, it doesn't provide particularly flexible styling. My vote is to keep the old method interfaces fairly consistent with how they are now so as not to disrupt existing uses (adding some new optional parameters or tweaking things to look better is fine), and to add a couple of new methods. Let's try not to make the internals of `Bloch` more messy though.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1685#issuecomment-934332552
https://github.com/qutip/qutip/pull/1685#issuecomment-934332552:856,Usability,intuit,intuitive,856,"General comment about plotting on the Bloch sphere:. QuTiP currently supports drawing either ""points"" or ""vectors"" (i.e. arrows). Both are specified as `(x, y, z)` coordinates and these are *not* required to lie on the surface of the sphere. Lying outside the sphere is perhaps a bit odd, but lying inside the sphere is a common occurrence -- e.g. when plotting sub-components of a density matrix. There is a method `add_states` that converts states into `(x, y, z)` coordinates and adds them as either points or vectors as requested. I would thus recommend being able to specify lines and arcs using either `(x, y, z)` coordinates or states and not introducing spherical coordinates right now. I'm not against duplicating some of the functionality of `add_points(..., meth=""l"")` in the new functions we add here. For one, the `meth=""l""` is not particular intuitive when looking for a function to draw lines, and, secondly, it doesn't provide particularly flexible styling. My vote is to keep the old method interfaces fairly consistent with how they are now so as not to disrupt existing uses (adding some new optional parameters or tweaking things to look better is fine), and to add a couple of new methods. Let's try not to make the internals of `Bloch` more messy though.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1685#issuecomment-934332552
https://github.com/qutip/qutip/pull/1685#issuecomment-934344538:1036,Availability,error,errors,1036,"> It would just be a matter of transforming the spherical coordinates into cartesian coordinates to be used by `add_points`. The following code would work:; > ; > ```python; > b = qutip.Bloch(); > ; > # Range of theta and phi; > th = np.linspace(0, np.pi/2, 20); > phi = np.linspace(0, np.pi/4, 20); > r = 1; > ; > xp = r*np.sin(th)*np.cos(phi); > yp = r*np.sin(th)*np.sin(phi); > zp = r*np.cos(th); > ; > pnts = [xp, yp, zp]; > b.add_points(pnts, meth='l'); > b.render(); > ```. There is a slight problem with this type of code:; 1. By using linspace for theta and phi as you have suggested, the values of theta and phi will not let the arc follow the shortest path and it will be a curve. For example, even in your plot, you'll see the arc is curved, whereas we are trying to plot an arc on the longitude.; 2. Another issue here is if I give you two random points, say (1/sqrt(3),1/sqrt(3),1/sqrt(3)) and (-1/sqrt(3),1/sqrt(3),-1/sqrt(3)), then using `add_points` to draw a curve is very cumbersome at the user-end and thus, prone to errors.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1685#issuecomment-934344538
https://github.com/qutip/qutip/pull/1685#issuecomment-934360018:1044,Integrability,interface,interfaces,1044,"> General comment about plotting on the Bloch sphere:; > ; > QuTiP currently supports drawing either ""points"" or ""vectors"" (i.e. arrows). Both are specified as `(x, y, z)` coordinates and these are _not_ required to lie on the surface of the sphere. Lying outside the sphere is perhaps a bit odd, but lying inside the sphere is a common occurrence -- e.g. when plotting sub-components of a density matrix.; > ; > There is a method `add_states` that converts states into `(x, y, z)` coordinates and adds them as either points or vectors as requested.; > ; > I would thus recommend being able to specify lines and arcs using either `(x, y, z)` coordinates or states and not introducing spherical coordinates right now.; > ; > I'm not against duplicating some of the functionality of `add_points(..., meth=""l"")` in the new functions we add here. For one, the `meth=""l""` is not particular intuitive when looking for a function to draw lines, and, secondly, it doesn't provide particularly flexible styling.; > ; > My vote is to keep the old method interfaces fairly consistent with how they are now so as not to disrupt existing uses (adding some new optional parameters or tweaking things to look better is fine), and to add a couple of new methods. Let's try not to make the internals of `Bloch` more messy though. Thanks a lot, Simon (@hodgestar). My modification to the bloch.py follows what you have suggested. ; Also, the code can plot arcs inside and outside the bloch sphere too, and the line segment can be drawn between any two points. And the inputs have to be in cartesian coordinates.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1685#issuecomment-934360018
https://github.com/qutip/qutip/pull/1685#issuecomment-934360018:985,Modifiability,flexible,flexible,985,"> General comment about plotting on the Bloch sphere:; > ; > QuTiP currently supports drawing either ""points"" or ""vectors"" (i.e. arrows). Both are specified as `(x, y, z)` coordinates and these are _not_ required to lie on the surface of the sphere. Lying outside the sphere is perhaps a bit odd, but lying inside the sphere is a common occurrence -- e.g. when plotting sub-components of a density matrix.; > ; > There is a method `add_states` that converts states into `(x, y, z)` coordinates and adds them as either points or vectors as requested.; > ; > I would thus recommend being able to specify lines and arcs using either `(x, y, z)` coordinates or states and not introducing spherical coordinates right now.; > ; > I'm not against duplicating some of the functionality of `add_points(..., meth=""l"")` in the new functions we add here. For one, the `meth=""l""` is not particular intuitive when looking for a function to draw lines, and, secondly, it doesn't provide particularly flexible styling.; > ; > My vote is to keep the old method interfaces fairly consistent with how they are now so as not to disrupt existing uses (adding some new optional parameters or tweaking things to look better is fine), and to add a couple of new methods. Let's try not to make the internals of `Bloch` more messy though. Thanks a lot, Simon (@hodgestar). My modification to the bloch.py follows what you have suggested. ; Also, the code can plot arcs inside and outside the bloch sphere too, and the line segment can be drawn between any two points. And the inputs have to be in cartesian coordinates.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1685#issuecomment-934360018
https://github.com/qutip/qutip/pull/1685#issuecomment-934360018:885,Usability,intuit,intuitive,885,"> General comment about plotting on the Bloch sphere:; > ; > QuTiP currently supports drawing either ""points"" or ""vectors"" (i.e. arrows). Both are specified as `(x, y, z)` coordinates and these are _not_ required to lie on the surface of the sphere. Lying outside the sphere is perhaps a bit odd, but lying inside the sphere is a common occurrence -- e.g. when plotting sub-components of a density matrix.; > ; > There is a method `add_states` that converts states into `(x, y, z)` coordinates and adds them as either points or vectors as requested.; > ; > I would thus recommend being able to specify lines and arcs using either `(x, y, z)` coordinates or states and not introducing spherical coordinates right now.; > ; > I'm not against duplicating some of the functionality of `add_points(..., meth=""l"")` in the new functions we add here. For one, the `meth=""l""` is not particular intuitive when looking for a function to draw lines, and, secondly, it doesn't provide particularly flexible styling.; > ; > My vote is to keep the old method interfaces fairly consistent with how they are now so as not to disrupt existing uses (adding some new optional parameters or tweaking things to look better is fine), and to add a couple of new methods. Let's try not to make the internals of `Bloch` more messy though. Thanks a lot, Simon (@hodgestar). My modification to the bloch.py follows what you have suggested. ; Also, the code can plot arcs inside and outside the bloch sphere too, and the line segment can be drawn between any two points. And the inputs have to be in cartesian coordinates.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1685#issuecomment-934360018
https://github.com/qutip/qutip/pull/1685#issuecomment-937556421:2218,Energy Efficiency,reduce,reduces,2218,"3) # Initial point normalized; > r2 = np.array([1, 0, 0]) # Final point; > t = np.linspace(0,1,100) # Parametrization; > ; > # All the points in this line are contained in the plane defined by r1 and r2.; > line = r1[:, np.newaxis]*t + r2[:, np.newaxis]*(1-t) ; > ; > # This will normalize all the points in the line such that they now have length 1 with respect to the center of the sphere. ; > # Since the points are still contained in the plane defined by r1 and r2, this will be the arc you are looking for.; > arc = line/np.linalg.norm(line, axis=0); > ; > b.add_points([arc[0,:], arc[1,:], arc[2,:]], meth='l'); > b.render(); > ```; > ; > I agree that this is not straightforward and hence QuTiP will benefit from having the method `add_arc`. I would however suggest changing the implementation using an algorithm based on the code I propose in this comment, as it requires far less lines of code and hence it is easier to both understand how it is implemented and to maintain it.; > ; > Regarding to `add_line` I would vote to not include it as a method here. Instead, I would provide an explicit example in the documentation showing how to draw lines with `add_points` to make it more discoverable. I believe that not being able to change the line style easily is a problem that this PR should not tackle. I think it would be great if in the future `add_points` and `add_states` could accept a kwarg that is directly passed to `matplotlib`. This would facilitate drawing with arbitrary styles. Thanks, @AGaliciaMartinez. Also, this is a wonderful suggestion, and it reduces the number of lines of codes by a lot. The only issue that arises is when the points are diagonally opposite but that can be fixed. ; So, is it okay if I take your code above, modify it for the general scenario, make changes to the `add_arc`, and push it again? I'm sorry I haven't contributed before and hence, don't know what is right or what counts as plagiarism. Please suggest @AGaliciaMartinez @hodgestar @BoxiLi",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1685#issuecomment-937556421
https://github.com/qutip/qutip/pull/1685#issuecomment-937579234:74,Energy Efficiency,reduce,reduces,74,"> Thanks, @AGaliciaMartinez. Also, this is a wonderful suggestion, and it reduces the number of lines of codes by a lot. The only issue that arises is when the points are diagonally opposite but that can be fixed. Good point! I did not consider that initially. For this case, since it is not possible to define a single arc but rather there are infinite possibilities, I would suggest to simply raise an exception. What do you think @gaurav-iiser ?. > So, is it okay if I take your code above, modify it for the general scenario, make changes to the add_arc, and push it again? . I think there is an option somewhere to make someone a coauthor of the code, but do not worry about that, it is not necessary here. You can either push the changes to this pull request or, since this will require significant changes to the code, you could create a new one. I personally prefer creating a new PR since it leaves a cleaner commit history, but both are fine.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1685#issuecomment-937579234
https://github.com/qutip/qutip/pull/1685#issuecomment-937579234:388,Usability,simpl,simply,388,"> Thanks, @AGaliciaMartinez. Also, this is a wonderful suggestion, and it reduces the number of lines of codes by a lot. The only issue that arises is when the points are diagonally opposite but that can be fixed. Good point! I did not consider that initially. For this case, since it is not possible to define a single arc but rather there are infinite possibilities, I would suggest to simply raise an exception. What do you think @gaurav-iiser ?. > So, is it okay if I take your code above, modify it for the general scenario, make changes to the add_arc, and push it again? . I think there is an option somewhere to make someone a coauthor of the code, but do not worry about that, it is not necessary here. You can either push the changes to this pull request or, since this will require significant changes to the code, you could create a new one. I personally prefer creating a new PR since it leaves a cleaner commit history, but both are fine.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1685#issuecomment-937579234
https://github.com/qutip/qutip/pull/1685#issuecomment-937583899:76,Energy Efficiency,reduce,reduces,76,"> > Thanks, @AGaliciaMartinez. Also, this is a wonderful suggestion, and it reduces the number of lines of codes by a lot. The only issue that arises is when the points are diagonally opposite but that can be fixed.; > ; > Good point! I did not consider that initially. For this case, since it is not possible to define a single arc but rather there are infinite possibilities, I would suggest to simply raise an exception. What do you think @gaurav-iiser ?. Yes, I think raising an exception is a good idea. > ; > > So, is it okay if I take your code above, modify it for the general scenario, make changes to the add_arc, and push it again?; > ; > I think there is an option somewhere to make someone a coauthor of the code, but do not worry about that, it is not necessary here. You can either push the changes to this pull request or, since this will require significant changes to the code, you could create a new one. I personally prefer creating a new PR since it leaves a cleaner commit history, but both are fine. Thanks again for your advice. :); I will probably create a new PR in a day or two by making respective changes to `add_arc`.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1685#issuecomment-937583899
https://github.com/qutip/qutip/pull/1685#issuecomment-937583899:397,Usability,simpl,simply,397,"> > Thanks, @AGaliciaMartinez. Also, this is a wonderful suggestion, and it reduces the number of lines of codes by a lot. The only issue that arises is when the points are diagonally opposite but that can be fixed.; > ; > Good point! I did not consider that initially. For this case, since it is not possible to define a single arc but rather there are infinite possibilities, I would suggest to simply raise an exception. What do you think @gaurav-iiser ?. Yes, I think raising an exception is a good idea. > ; > > So, is it okay if I take your code above, modify it for the general scenario, make changes to the add_arc, and push it again?; > ; > I think there is an option somewhere to make someone a coauthor of the code, but do not worry about that, it is not necessary here. You can either push the changes to this pull request or, since this will require significant changes to the code, you could create a new one. I personally prefer creating a new PR since it leaves a cleaner commit history, but both are fine. Thanks again for your advice. :); I will probably create a new PR in a day or two by making respective changes to `add_arc`.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1685#issuecomment-937583899
https://github.com/qutip/qutip/issues/1686#issuecomment-938617719:20,Availability,toler,tolerance,20,"You can control the tolerance of the output of the solvers with the `qutip.Options()` class, in particular the parameters `atol`, `rtol` and `nsteps`. It's highly unlikely that you'll ever get them to be _exactly_ equal due to the realities of floating-point. A more relevant measure is the size of the overlap `r1.overlap(r2)`. Again, this will never be exactly 0, but by setting the tolerances of the solvers suitably, you can bound it to an acceptable value. This is unfortunately just one of the realities of numeric computing - floating-point calculations accumulate error, and it's up to the user to specify what level of error is tolerable.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1686#issuecomment-938617719
https://github.com/qutip/qutip/issues/1686#issuecomment-938617719:385,Availability,toler,tolerances,385,"You can control the tolerance of the output of the solvers with the `qutip.Options()` class, in particular the parameters `atol`, `rtol` and `nsteps`. It's highly unlikely that you'll ever get them to be _exactly_ equal due to the realities of floating-point. A more relevant measure is the size of the overlap `r1.overlap(r2)`. Again, this will never be exactly 0, but by setting the tolerances of the solvers suitably, you can bound it to an acceptable value. This is unfortunately just one of the realities of numeric computing - floating-point calculations accumulate error, and it's up to the user to specify what level of error is tolerable.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1686#issuecomment-938617719
https://github.com/qutip/qutip/issues/1686#issuecomment-938617719:572,Availability,error,error,572,"You can control the tolerance of the output of the solvers with the `qutip.Options()` class, in particular the parameters `atol`, `rtol` and `nsteps`. It's highly unlikely that you'll ever get them to be _exactly_ equal due to the realities of floating-point. A more relevant measure is the size of the overlap `r1.overlap(r2)`. Again, this will never be exactly 0, but by setting the tolerances of the solvers suitably, you can bound it to an acceptable value. This is unfortunately just one of the realities of numeric computing - floating-point calculations accumulate error, and it's up to the user to specify what level of error is tolerable.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1686#issuecomment-938617719
https://github.com/qutip/qutip/issues/1686#issuecomment-938617719:628,Availability,error,error,628,"You can control the tolerance of the output of the solvers with the `qutip.Options()` class, in particular the parameters `atol`, `rtol` and `nsteps`. It's highly unlikely that you'll ever get them to be _exactly_ equal due to the realities of floating-point. A more relevant measure is the size of the overlap `r1.overlap(r2)`. Again, this will never be exactly 0, but by setting the tolerances of the solvers suitably, you can bound it to an acceptable value. This is unfortunately just one of the realities of numeric computing - floating-point calculations accumulate error, and it's up to the user to specify what level of error is tolerable.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1686#issuecomment-938617719
https://github.com/qutip/qutip/issues/1686#issuecomment-938617719:637,Availability,toler,tolerable,637,"You can control the tolerance of the output of the solvers with the `qutip.Options()` class, in particular the parameters `atol`, `rtol` and `nsteps`. It's highly unlikely that you'll ever get them to be _exactly_ equal due to the realities of floating-point. A more relevant measure is the size of the overlap `r1.overlap(r2)`. Again, this will never be exactly 0, but by setting the tolerances of the solvers suitably, you can bound it to an acceptable value. This is unfortunately just one of the realities of numeric computing - floating-point calculations accumulate error, and it's up to the user to specify what level of error is tolerable.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1686#issuecomment-938617719
https://github.com/qutip/qutip/pull/1687#issuecomment-949022910:1933,Deployability,release,release,1933,"@cgranade I'm really liking the overall look of the Instrument class -- it's a much easier way to deal with measurements than calling the measurement operations all the time & of combine measurement operations with other operations on Qobjs. I'm keen to hear feedback from others too, but in the mean time I'm going to note some thoughts here for when I come back to this:. * It would be good to think about how all the operations on Qobj match up with QuTiP version 5 (since this draft is based on v4 currently).; * I'd like to think about removing `Seq` and `Par` and replacing them with some simple rules for sequences, strings and numbers. This would match, e.g., `qutip.ket(""01"")` and `qutip.basis([2, 2], [0, 1])`. `Seq` and `Par` do however make it really clear that in one case measurements follow each other on the same subspaces and in the other they are performed simultaneously on different subspaces, so I'm not quite sure. Maybe there is some middle ground.; * In QuTiP it's more normal to have the helper constructors not on the class as classmethods. I do like secondary constructors as classmethods, but I think in cases like this where there are essentially an infinite number of possible constructors, it makes sense to not ""bless"" any of them by sticking them on the class.; * It would be good to have one really nice use case that we could turn into a guide entry in the documentation. The current small examples are great, but it would be good to add one slightly bigger worked example that did something more ""exciting"".; * I would not push everything into the `qutip` namespace (largely because we would likely not want that in v5, although I should actually check what v5 is doing in `qutip.__init__` these days).; * We should decide whether to target QuTiP 4.7 or 4.7 and 5 for this. Target just v5 means not having to worry about making it nice in both, but will mean it'll be a bit more of a delay before release). Hoping to hear comments from others!",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1687#issuecomment-949022910
https://github.com/qutip/qutip/pull/1687#issuecomment-949022910:865,Performance,perform,performed,865,"@cgranade I'm really liking the overall look of the Instrument class -- it's a much easier way to deal with measurements than calling the measurement operations all the time & of combine measurement operations with other operations on Qobjs. I'm keen to hear feedback from others too, but in the mean time I'm going to note some thoughts here for when I come back to this:. * It would be good to think about how all the operations on Qobj match up with QuTiP version 5 (since this draft is based on v4 currently).; * I'd like to think about removing `Seq` and `Par` and replacing them with some simple rules for sequences, strings and numbers. This would match, e.g., `qutip.ket(""01"")` and `qutip.basis([2, 2], [0, 1])`. `Seq` and `Par` do however make it really clear that in one case measurements follow each other on the same subspaces and in the other they are performed simultaneously on different subspaces, so I'm not quite sure. Maybe there is some middle ground.; * In QuTiP it's more normal to have the helper constructors not on the class as classmethods. I do like secondary constructors as classmethods, but I think in cases like this where there are essentially an infinite number of possible constructors, it makes sense to not ""bless"" any of them by sticking them on the class.; * It would be good to have one really nice use case that we could turn into a guide entry in the documentation. The current small examples are great, but it would be good to add one slightly bigger worked example that did something more ""exciting"".; * I would not push everything into the `qutip` namespace (largely because we would likely not want that in v5, although I should actually check what v5 is doing in `qutip.__init__` these days).; * We should decide whether to target QuTiP 4.7 or 4.7 and 5 for this. Target just v5 means not having to worry about making it nice in both, but will mean it'll be a bit more of a delay before release). Hoping to hear comments from others!",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1687#issuecomment-949022910
https://github.com/qutip/qutip/pull/1687#issuecomment-949022910:259,Usability,feedback,feedback,259,"@cgranade I'm really liking the overall look of the Instrument class -- it's a much easier way to deal with measurements than calling the measurement operations all the time & of combine measurement operations with other operations on Qobjs. I'm keen to hear feedback from others too, but in the mean time I'm going to note some thoughts here for when I come back to this:. * It would be good to think about how all the operations on Qobj match up with QuTiP version 5 (since this draft is based on v4 currently).; * I'd like to think about removing `Seq` and `Par` and replacing them with some simple rules for sequences, strings and numbers. This would match, e.g., `qutip.ket(""01"")` and `qutip.basis([2, 2], [0, 1])`. `Seq` and `Par` do however make it really clear that in one case measurements follow each other on the same subspaces and in the other they are performed simultaneously on different subspaces, so I'm not quite sure. Maybe there is some middle ground.; * In QuTiP it's more normal to have the helper constructors not on the class as classmethods. I do like secondary constructors as classmethods, but I think in cases like this where there are essentially an infinite number of possible constructors, it makes sense to not ""bless"" any of them by sticking them on the class.; * It would be good to have one really nice use case that we could turn into a guide entry in the documentation. The current small examples are great, but it would be good to add one slightly bigger worked example that did something more ""exciting"".; * I would not push everything into the `qutip` namespace (largely because we would likely not want that in v5, although I should actually check what v5 is doing in `qutip.__init__` these days).; * We should decide whether to target QuTiP 4.7 or 4.7 and 5 for this. Target just v5 means not having to worry about making it nice in both, but will mean it'll be a bit more of a delay before release). Hoping to hear comments from others!",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1687#issuecomment-949022910
https://github.com/qutip/qutip/pull/1687#issuecomment-949022910:595,Usability,simpl,simple,595,"@cgranade I'm really liking the overall look of the Instrument class -- it's a much easier way to deal with measurements than calling the measurement operations all the time & of combine measurement operations with other operations on Qobjs. I'm keen to hear feedback from others too, but in the mean time I'm going to note some thoughts here for when I come back to this:. * It would be good to think about how all the operations on Qobj match up with QuTiP version 5 (since this draft is based on v4 currently).; * I'd like to think about removing `Seq` and `Par` and replacing them with some simple rules for sequences, strings and numbers. This would match, e.g., `qutip.ket(""01"")` and `qutip.basis([2, 2], [0, 1])`. `Seq` and `Par` do however make it really clear that in one case measurements follow each other on the same subspaces and in the other they are performed simultaneously on different subspaces, so I'm not quite sure. Maybe there is some middle ground.; * In QuTiP it's more normal to have the helper constructors not on the class as classmethods. I do like secondary constructors as classmethods, but I think in cases like this where there are essentially an infinite number of possible constructors, it makes sense to not ""bless"" any of them by sticking them on the class.; * It would be good to have one really nice use case that we could turn into a guide entry in the documentation. The current small examples are great, but it would be good to add one slightly bigger worked example that did something more ""exciting"".; * I would not push everything into the `qutip` namespace (largely because we would likely not want that in v5, although I should actually check what v5 is doing in `qutip.__init__` these days).; * We should decide whether to target QuTiP 4.7 or 4.7 and 5 for this. Target just v5 means not having to worry about making it nice in both, but will mean it'll be a bit more of a delay before release). Hoping to hear comments from others!",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1687#issuecomment-949022910
https://github.com/qutip/qutip/pull/1687#issuecomment-949022910:763,Usability,clear,clear,763,"@cgranade I'm really liking the overall look of the Instrument class -- it's a much easier way to deal with measurements than calling the measurement operations all the time & of combine measurement operations with other operations on Qobjs. I'm keen to hear feedback from others too, but in the mean time I'm going to note some thoughts here for when I come back to this:. * It would be good to think about how all the operations on Qobj match up with QuTiP version 5 (since this draft is based on v4 currently).; * I'd like to think about removing `Seq` and `Par` and replacing them with some simple rules for sequences, strings and numbers. This would match, e.g., `qutip.ket(""01"")` and `qutip.basis([2, 2], [0, 1])`. `Seq` and `Par` do however make it really clear that in one case measurements follow each other on the same subspaces and in the other they are performed simultaneously on different subspaces, so I'm not quite sure. Maybe there is some middle ground.; * In QuTiP it's more normal to have the helper constructors not on the class as classmethods. I do like secondary constructors as classmethods, but I think in cases like this where there are essentially an infinite number of possible constructors, it makes sense to not ""bless"" any of them by sticking them on the class.; * It would be good to have one really nice use case that we could turn into a guide entry in the documentation. The current small examples are great, but it would be good to add one slightly bigger worked example that did something more ""exciting"".; * I would not push everything into the `qutip` namespace (largely because we would likely not want that in v5, although I should actually check what v5 is doing in `qutip.__init__` these days).; * We should decide whether to target QuTiP 4.7 or 4.7 and 5 for this. Target just v5 means not having to worry about making it nice in both, but will mean it'll be a bit more of a delay before release). Hoping to hear comments from others!",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1687#issuecomment-949022910
https://github.com/qutip/qutip/pull/1687#issuecomment-949022910:1373,Usability,guid,guide,1373,"@cgranade I'm really liking the overall look of the Instrument class -- it's a much easier way to deal with measurements than calling the measurement operations all the time & of combine measurement operations with other operations on Qobjs. I'm keen to hear feedback from others too, but in the mean time I'm going to note some thoughts here for when I come back to this:. * It would be good to think about how all the operations on Qobj match up with QuTiP version 5 (since this draft is based on v4 currently).; * I'd like to think about removing `Seq` and `Par` and replacing them with some simple rules for sequences, strings and numbers. This would match, e.g., `qutip.ket(""01"")` and `qutip.basis([2, 2], [0, 1])`. `Seq` and `Par` do however make it really clear that in one case measurements follow each other on the same subspaces and in the other they are performed simultaneously on different subspaces, so I'm not quite sure. Maybe there is some middle ground.; * In QuTiP it's more normal to have the helper constructors not on the class as classmethods. I do like secondary constructors as classmethods, but I think in cases like this where there are essentially an infinite number of possible constructors, it makes sense to not ""bless"" any of them by sticking them on the class.; * It would be good to have one really nice use case that we could turn into a guide entry in the documentation. The current small examples are great, but it would be good to add one slightly bigger worked example that did something more ""exciting"".; * I would not push everything into the `qutip` namespace (largely because we would likely not want that in v5, although I should actually check what v5 is doing in `qutip.__init__` these days).; * We should decide whether to target QuTiP 4.7 or 4.7 and 5 for this. Target just v5 means not having to worry about making it nice in both, but will mean it'll be a bit more of a delay before release). Hoping to hear comments from others!",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1687#issuecomment-949022910
https://github.com/qutip/qutip/pull/1687#issuecomment-949031114:154,Integrability,rout,route,154,"@cgranade When we initially talked about this, we also spoke about storing Kraus superoperators with it, but it's not completely clear to me whether this route covers that case. ""No"" is fine (we don't have to make this work for everything) but if the answer is ""Yes"" or ""Maybe"", what would that look like?",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1687#issuecomment-949031114
https://github.com/qutip/qutip/pull/1687#issuecomment-949031114:129,Usability,clear,clear,129,"@cgranade When we initially talked about this, we also spoke about storing Kraus superoperators with it, but it's not completely clear to me whether this route covers that case. ""No"" is fine (we don't have to make this work for everything) but if the answer is ""Yes"" or ""Maybe"", what would that look like?",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1687#issuecomment-949031114
https://github.com/qutip/qutip/pull/1687#issuecomment-951352562:934,Availability,mainten,maintenance,934,"> @cgranade I'm really liking the overall look of the Instrument class -- it's a much easier way to deal with measurements than calling the measurement operations all the time & of combine measurement operations with other operations on Qobjs. Thank you for the kind words!. > I'm keen to hear feedback from others too, but in the mean time I'm going to note some thoughts here for when I come back to this:; > ; > * It would be good to think about how all the operations on Qobj match up with QuTiP version 5 (since this draft is based on v4 currently).; > * We should decide whether to target QuTiP 4.7 or 4.7 and 5 for this. Target just v5 means not having to worry about making it nice in both, but will mean it'll be a bit more of a delay before release).; > . I'll admit I've not kept up as much with the 5.0 changes as I should have, but I'm happy either way; I can definitely see the benefit to targeting 5.0 and keeping code maintenance down, or to getting the feature out for folks to use sooner at the cost of more development work. > * I'd like to think about removing `Seq` and `Par` and replacing them with some simple rules for sequences, strings and numbers. Honestly, agreed; I tried a few different designs to try and get rid of those two classes, but they all felt a bit awkward and special-cased. Happy to revise, though, to lower the barrier to using the new feature. > This would match, e.g., `qutip.ket(""01"")` and `qutip.basis([2, 2], [0, 1])`. `Seq` and `Par` do however make it really clear that in one case measurements follow each other on the same subspaces and in the other they are performed simultaneously on different subspaces, so I'm not quite sure. Maybe there is some middle ground. My initial thought was to do something like use tuples instead of `Seq` and lists instead of `Par`, but that then ran into a couple issues. Namely, it wasn't as obvious what each kind of container meant, and it was harder to automatically flatten (e.g.: `Seq(1, Seq(2, 3), 4)` is id",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1687#issuecomment-951352562
https://github.com/qutip/qutip/pull/1687#issuecomment-951352562:946,Availability,down,down,946,"> @cgranade I'm really liking the overall look of the Instrument class -- it's a much easier way to deal with measurements than calling the measurement operations all the time & of combine measurement operations with other operations on Qobjs. Thank you for the kind words!. > I'm keen to hear feedback from others too, but in the mean time I'm going to note some thoughts here for when I come back to this:; > ; > * It would be good to think about how all the operations on Qobj match up with QuTiP version 5 (since this draft is based on v4 currently).; > * We should decide whether to target QuTiP 4.7 or 4.7 and 5 for this. Target just v5 means not having to worry about making it nice in both, but will mean it'll be a bit more of a delay before release).; > . I'll admit I've not kept up as much with the 5.0 changes as I should have, but I'm happy either way; I can definitely see the benefit to targeting 5.0 and keeping code maintenance down, or to getting the feature out for folks to use sooner at the cost of more development work. > * I'd like to think about removing `Seq` and `Par` and replacing them with some simple rules for sequences, strings and numbers. Honestly, agreed; I tried a few different designs to try and get rid of those two classes, but they all felt a bit awkward and special-cased. Happy to revise, though, to lower the barrier to using the new feature. > This would match, e.g., `qutip.ket(""01"")` and `qutip.basis([2, 2], [0, 1])`. `Seq` and `Par` do however make it really clear that in one case measurements follow each other on the same subspaces and in the other they are performed simultaneously on different subspaces, so I'm not quite sure. Maybe there is some middle ground. My initial thought was to do something like use tuples instead of `Seq` and lists instead of `Par`, but that then ran into a couple issues. Namely, it wasn't as obvious what each kind of container meant, and it was harder to automatically flatten (e.g.: `Seq(1, Seq(2, 3), 4)` is id",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1687#issuecomment-951352562
https://github.com/qutip/qutip/pull/1687#issuecomment-951352562:751,Deployability,release,release,751,"> @cgranade I'm really liking the overall look of the Instrument class -- it's a much easier way to deal with measurements than calling the measurement operations all the time & of combine measurement operations with other operations on Qobjs. Thank you for the kind words!. > I'm keen to hear feedback from others too, but in the mean time I'm going to note some thoughts here for when I come back to this:; > ; > * It would be good to think about how all the operations on Qobj match up with QuTiP version 5 (since this draft is based on v4 currently).; > * We should decide whether to target QuTiP 4.7 or 4.7 and 5 for this. Target just v5 means not having to worry about making it nice in both, but will mean it'll be a bit more of a delay before release).; > . I'll admit I've not kept up as much with the 5.0 changes as I should have, but I'm happy either way; I can definitely see the benefit to targeting 5.0 and keeping code maintenance down, or to getting the feature out for folks to use sooner at the cost of more development work. > * I'd like to think about removing `Seq` and `Par` and replacing them with some simple rules for sequences, strings and numbers. Honestly, agreed; I tried a few different designs to try and get rid of those two classes, but they all felt a bit awkward and special-cased. Happy to revise, though, to lower the barrier to using the new feature. > This would match, e.g., `qutip.ket(""01"")` and `qutip.basis([2, 2], [0, 1])`. `Seq` and `Par` do however make it really clear that in one case measurements follow each other on the same subspaces and in the other they are performed simultaneously on different subspaces, so I'm not quite sure. Maybe there is some middle ground. My initial thought was to do something like use tuples instead of `Seq` and lists instead of `Par`, but that then ran into a couple issues. Namely, it wasn't as obvious what each kind of container meant, and it was harder to automatically flatten (e.g.: `Seq(1, Seq(2, 3), 4)` is id",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1687#issuecomment-951352562
https://github.com/qutip/qutip/pull/1687#issuecomment-951352562:1612,Performance,perform,performed,1612,"e whether to target QuTiP 4.7 or 4.7 and 5 for this. Target just v5 means not having to worry about making it nice in both, but will mean it'll be a bit more of a delay before release).; > . I'll admit I've not kept up as much with the 5.0 changes as I should have, but I'm happy either way; I can definitely see the benefit to targeting 5.0 and keeping code maintenance down, or to getting the feature out for folks to use sooner at the cost of more development work. > * I'd like to think about removing `Seq` and `Par` and replacing them with some simple rules for sequences, strings and numbers. Honestly, agreed; I tried a few different designs to try and get rid of those two classes, but they all felt a bit awkward and special-cased. Happy to revise, though, to lower the barrier to using the new feature. > This would match, e.g., `qutip.ket(""01"")` and `qutip.basis([2, 2], [0, 1])`. `Seq` and `Par` do however make it really clear that in one case measurements follow each other on the same subspaces and in the other they are performed simultaneously on different subspaces, so I'm not quite sure. Maybe there is some middle ground. My initial thought was to do something like use tuples instead of `Seq` and lists instead of `Par`, but that then ran into a couple issues. Namely, it wasn't as obvious what each kind of container meant, and it was harder to automatically flatten (e.g.: `Seq(1, Seq(2, 3), 4)` is identical to `Seq(1, 2, 3, 4)` and `Seq(1, Par(2), 3)` is identical to `Seq(1, 2, 3)` but distinct from `Seq(1, Par(2, 3))`). One alternative may be to have a single subclass `Outcome` of `tuple` instead of both, then overload operators like `|` to mean parallel. Internally, could use two subclasses like `Seq` and `Par` but display visually as `Outcome(1, 2 | 3, 4)` instead of `Outcome(1, Par(2, 3), 4)`. > * In QuTiP it's more normal to have the helper constructors not on the class as classmethods. I do like secondary constructors as classmethods, but I think in cases l",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1687#issuecomment-951352562
https://github.com/qutip/qutip/pull/1687#issuecomment-951352562:294,Usability,feedback,feedback,294,"> @cgranade I'm really liking the overall look of the Instrument class -- it's a much easier way to deal with measurements than calling the measurement operations all the time & of combine measurement operations with other operations on Qobjs. Thank you for the kind words!. > I'm keen to hear feedback from others too, but in the mean time I'm going to note some thoughts here for when I come back to this:; > ; > * It would be good to think about how all the operations on Qobj match up with QuTiP version 5 (since this draft is based on v4 currently).; > * We should decide whether to target QuTiP 4.7 or 4.7 and 5 for this. Target just v5 means not having to worry about making it nice in both, but will mean it'll be a bit more of a delay before release).; > . I'll admit I've not kept up as much with the 5.0 changes as I should have, but I'm happy either way; I can definitely see the benefit to targeting 5.0 and keeping code maintenance down, or to getting the feature out for folks to use sooner at the cost of more development work. > * I'd like to think about removing `Seq` and `Par` and replacing them with some simple rules for sequences, strings and numbers. Honestly, agreed; I tried a few different designs to try and get rid of those two classes, but they all felt a bit awkward and special-cased. Happy to revise, though, to lower the barrier to using the new feature. > This would match, e.g., `qutip.ket(""01"")` and `qutip.basis([2, 2], [0, 1])`. `Seq` and `Par` do however make it really clear that in one case measurements follow each other on the same subspaces and in the other they are performed simultaneously on different subspaces, so I'm not quite sure. Maybe there is some middle ground. My initial thought was to do something like use tuples instead of `Seq` and lists instead of `Par`, but that then ran into a couple issues. Namely, it wasn't as obvious what each kind of container meant, and it was harder to automatically flatten (e.g.: `Seq(1, Seq(2, 3), 4)` is id",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1687#issuecomment-951352562
https://github.com/qutip/qutip/pull/1687#issuecomment-951352562:1126,Usability,simpl,simple,1126,"h measurements than calling the measurement operations all the time & of combine measurement operations with other operations on Qobjs. Thank you for the kind words!. > I'm keen to hear feedback from others too, but in the mean time I'm going to note some thoughts here for when I come back to this:; > ; > * It would be good to think about how all the operations on Qobj match up with QuTiP version 5 (since this draft is based on v4 currently).; > * We should decide whether to target QuTiP 4.7 or 4.7 and 5 for this. Target just v5 means not having to worry about making it nice in both, but will mean it'll be a bit more of a delay before release).; > . I'll admit I've not kept up as much with the 5.0 changes as I should have, but I'm happy either way; I can definitely see the benefit to targeting 5.0 and keeping code maintenance down, or to getting the feature out for folks to use sooner at the cost of more development work. > * I'd like to think about removing `Seq` and `Par` and replacing them with some simple rules for sequences, strings and numbers. Honestly, agreed; I tried a few different designs to try and get rid of those two classes, but they all felt a bit awkward and special-cased. Happy to revise, though, to lower the barrier to using the new feature. > This would match, e.g., `qutip.ket(""01"")` and `qutip.basis([2, 2], [0, 1])`. `Seq` and `Par` do however make it really clear that in one case measurements follow each other on the same subspaces and in the other they are performed simultaneously on different subspaces, so I'm not quite sure. Maybe there is some middle ground. My initial thought was to do something like use tuples instead of `Seq` and lists instead of `Par`, but that then ran into a couple issues. Namely, it wasn't as obvious what each kind of container meant, and it was harder to automatically flatten (e.g.: `Seq(1, Seq(2, 3), 4)` is identical to `Seq(1, 2, 3, 4)` and `Seq(1, Par(2), 3)` is identical to `Seq(1, 2, 3)` but distinct from `Seq(1",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1687#issuecomment-951352562
https://github.com/qutip/qutip/pull/1687#issuecomment-951352562:1510,Usability,clear,clear,1510,"e whether to target QuTiP 4.7 or 4.7 and 5 for this. Target just v5 means not having to worry about making it nice in both, but will mean it'll be a bit more of a delay before release).; > . I'll admit I've not kept up as much with the 5.0 changes as I should have, but I'm happy either way; I can definitely see the benefit to targeting 5.0 and keeping code maintenance down, or to getting the feature out for folks to use sooner at the cost of more development work. > * I'd like to think about removing `Seq` and `Par` and replacing them with some simple rules for sequences, strings and numbers. Honestly, agreed; I tried a few different designs to try and get rid of those two classes, but they all felt a bit awkward and special-cased. Happy to revise, though, to lower the barrier to using the new feature. > This would match, e.g., `qutip.ket(""01"")` and `qutip.basis([2, 2], [0, 1])`. `Seq` and `Par` do however make it really clear that in one case measurements follow each other on the same subspaces and in the other they are performed simultaneously on different subspaces, so I'm not quite sure. Maybe there is some middle ground. My initial thought was to do something like use tuples instead of `Seq` and lists instead of `Par`, but that then ran into a couple issues. Namely, it wasn't as obvious what each kind of container meant, and it was harder to automatically flatten (e.g.: `Seq(1, Seq(2, 3), 4)` is identical to `Seq(1, 2, 3, 4)` and `Seq(1, Par(2), 3)` is identical to `Seq(1, 2, 3)` but distinct from `Seq(1, Par(2, 3))`). One alternative may be to have a single subclass `Outcome` of `tuple` instead of both, then overload operators like `|` to mean parallel. Internally, could use two subclasses like `Seq` and `Par` but display visually as `Outcome(1, 2 | 3, 4)` instead of `Outcome(1, Par(2, 3), 4)`. > * In QuTiP it's more normal to have the helper constructors not on the class as classmethods. I do like secondary constructors as classmethods, but I think in cases l",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1687#issuecomment-951352562
https://github.com/qutip/qutip/pull/1687#issuecomment-951352562:2875,Usability,guid,guide,2875,"ng like use tuples instead of `Seq` and lists instead of `Par`, but that then ran into a couple issues. Namely, it wasn't as obvious what each kind of container meant, and it was harder to automatically flatten (e.g.: `Seq(1, Seq(2, 3), 4)` is identical to `Seq(1, 2, 3, 4)` and `Seq(1, Par(2), 3)` is identical to `Seq(1, 2, 3)` but distinct from `Seq(1, Par(2, 3))`). One alternative may be to have a single subclass `Outcome` of `tuple` instead of both, then overload operators like `|` to mean parallel. Internally, could use two subclasses like `Seq` and `Par` but display visually as `Outcome(1, 2 | 3, 4)` instead of `Outcome(1, Par(2, 3), 4)`. > * In QuTiP it's more normal to have the helper constructors not on the class as classmethods. I do like secondary constructors as classmethods, but I think in cases like this where there are essentially an infinite number of possible constructors, it makes sense to not ""bless"" any of them by sticking them on the class. Sounds good, will move those out to be ordinary functions, then. > * It would be good to have one really nice use case that we could turn into a guide entry in the documentation. The current small examples are great, but it would be good to add one slightly bigger worked example that did something more ""exciting"". I've played around with using `if_` to compute the noisy channel one gets for state teleportation when operations are perfect but classical outcomes get scrambled; would that be useful, perhaps?. > * I would not push everything into the `qutip` namespace (largely because we would likely not want that in v5, although I should actually check what v5 is doing in `qutip.__init__` these days). Fair enough, easy to drop that as well. Would you want everything dropped, or would some things like the core type `QInstrument` itself be reasonable to keep in `qutip.__all__`?. > Hoping to hear comments from others!. Thanks for your review, I'll work on addressing, then excited to hear what others think as well! 💕",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1687#issuecomment-951352562
https://github.com/qutip/qutip/pull/1687#issuecomment-951361876:156,Integrability,rout,route,156,"> @cgranade When we initially talked about this, we also spoke about storing Kraus superoperators with it, but it's not completely clear to me whether this route covers that case. ""No"" is fine (we don't have to make this work for everything) but if the answer is ""Yes"" or ""Maybe"", what would that look like?. At the moment, no. Following our discussion, it sounded like separating the two features may make the most sense such that I wanted to focus first on representing instruments. > > I've played around with using if_ to compute the noisy channel one gets for state teleportation when operations are perfect but classical outcomes get scrambled; would that be useful, perhaps?; > ; > That sounds like a great example!. Awesome, I'll go add that as a draft PR to the notebooks repo, then, so as to develop both in parallel. > > Fair enough, easy to drop that as well. Would you want everything dropped, or would some things like the core type QInstrument itself be reasonable to keep in qutip.**all**; > ; > Let's keep QInstrument in since that feels at the same level as Qobj and QobjEvo and we can think about other things on a case by case basis (and see what v5 is doing). Sounds good, will do!",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1687#issuecomment-951361876
https://github.com/qutip/qutip/pull/1687#issuecomment-951361876:131,Usability,clear,clear,131,"> @cgranade When we initially talked about this, we also spoke about storing Kraus superoperators with it, but it's not completely clear to me whether this route covers that case. ""No"" is fine (we don't have to make this work for everything) but if the answer is ""Yes"" or ""Maybe"", what would that look like?. At the moment, no. Following our discussion, it sounded like separating the two features may make the most sense such that I wanted to focus first on representing instruments. > > I've played around with using if_ to compute the noisy channel one gets for state teleportation when operations are perfect but classical outcomes get scrambled; would that be useful, perhaps?; > ; > That sounds like a great example!. Awesome, I'll go add that as a draft PR to the notebooks repo, then, so as to develop both in parallel. > > Fair enough, easy to drop that as well. Would you want everything dropped, or would some things like the core type QInstrument itself be reasonable to keep in qutip.**all**; > ; > Let's keep QInstrument in since that feels at the same level as Qobj and QobjEvo and we can think about other things on a case by case basis (and see what v5 is doing). Sounds good, will do!",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1687#issuecomment-951361876
https://github.com/qutip/qutip/pull/1687#issuecomment-1010581128:679,Testability,test,tests,679,"@hodgestar Apologies for taking as long, but went on and rebased my PR to 5.0 and addressed some of your comments. In particular, factory methods have been moved out into ordinary functions, and I added a simple string-based format for outcome labels (leaving `Seq` and `Par` for more complex cases as needed). For the notebook, I ran into the slight issue that the qutip-notebooks repo uses a more copyleft license, but in the meantime I put together a notebook at https://gist.github.com/cgranade/7c2a5a0827dddc4281666ad45763b1ec that includes a few examples of the API in use, including for modeling a simple teleportation channel. I still need to address PEP8 issues and add tests, but I think it should be a bit further along; thanks for all your help and feedback! 💕",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1687#issuecomment-1010581128
https://github.com/qutip/qutip/pull/1687#issuecomment-1010581128:205,Usability,simpl,simple,205,"@hodgestar Apologies for taking as long, but went on and rebased my PR to 5.0 and addressed some of your comments. In particular, factory methods have been moved out into ordinary functions, and I added a simple string-based format for outcome labels (leaving `Seq` and `Par` for more complex cases as needed). For the notebook, I ran into the slight issue that the qutip-notebooks repo uses a more copyleft license, but in the meantime I put together a notebook at https://gist.github.com/cgranade/7c2a5a0827dddc4281666ad45763b1ec that includes a few examples of the API in use, including for modeling a simple teleportation channel. I still need to address PEP8 issues and add tests, but I think it should be a bit further along; thanks for all your help and feedback! 💕",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1687#issuecomment-1010581128
https://github.com/qutip/qutip/pull/1687#issuecomment-1010581128:605,Usability,simpl,simple,605,"@hodgestar Apologies for taking as long, but went on and rebased my PR to 5.0 and addressed some of your comments. In particular, factory methods have been moved out into ordinary functions, and I added a simple string-based format for outcome labels (leaving `Seq` and `Par` for more complex cases as needed). For the notebook, I ran into the slight issue that the qutip-notebooks repo uses a more copyleft license, but in the meantime I put together a notebook at https://gist.github.com/cgranade/7c2a5a0827dddc4281666ad45763b1ec that includes a few examples of the API in use, including for modeling a simple teleportation channel. I still need to address PEP8 issues and add tests, but I think it should be a bit further along; thanks for all your help and feedback! 💕",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1687#issuecomment-1010581128
https://github.com/qutip/qutip/pull/1687#issuecomment-1010581128:761,Usability,feedback,feedback,761,"@hodgestar Apologies for taking as long, but went on and rebased my PR to 5.0 and addressed some of your comments. In particular, factory methods have been moved out into ordinary functions, and I added a simple string-based format for outcome labels (leaving `Seq` and `Par` for more complex cases as needed). For the notebook, I ran into the slight issue that the qutip-notebooks repo uses a more copyleft license, but in the meantime I put together a notebook at https://gist.github.com/cgranade/7c2a5a0827dddc4281666ad45763b1ec that includes a few examples of the API in use, including for modeling a simple teleportation channel. I still need to address PEP8 issues and add tests, but I think it should be a bit further along; thanks for all your help and feedback! 💕",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1687#issuecomment-1010581128
https://github.com/qutip/qutip/pull/1688#issuecomment-942163402:78,Testability,test,testing,78,> What made you trip over this?. I was using this function with N=13 for some testing code I have and realised it took too long to create the matrix.,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1688#issuecomment-942163402
https://github.com/qutip/qutip/pull/1688#issuecomment-942198552:28,Energy Efficiency,efficient,efficient,28,"As it is quite a short (but efficient!) change, we can keep it both in qutip and in qutip-qip. Also, I remember this function is also used in the control module (also for testing I think). So we need it in qutip anyway. Eventually, I think it is best to keep these commonly used function in `qutip.operator` and import it to qutip-qip",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1688#issuecomment-942198552
https://github.com/qutip/qutip/pull/1688#issuecomment-942198552:171,Testability,test,testing,171,"As it is quite a short (but efficient!) change, we can keep it both in qutip and in qutip-qip. Also, I remember this function is also used in the control module (also for testing I think). So we need it in qutip anyway. Eventually, I think it is best to keep these commonly used function in `qutip.operator` and import it to qutip-qip",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1688#issuecomment-942198552
https://github.com/qutip/qutip/pull/1688#issuecomment-942580997:236,Energy Efficiency,power,powers,236,"There's another interesting technique that's sometimes applicable in these sort of repeating cases. Rather than passing a list of the same elements to `tensor`, you can also consider building up the tensor product manually, going up in powers of two. So you go along with something like:; ```python; out, tmp = H, H; for i in n.bit_length():; tmp = tensor(tmp, tmp); if n & (1 << i):; out = tensor(out, tmp); ```; (very very approximately - I've almost certainly got the indexing wrong). The idea is that you only perform `lg(n)` tensor products. Now, this might not actually give you much of a speed up in this case, because the calculation is still going to be dominated by the final tensor product, since the output matrix keeps getting larger. But in things like integer matrix powers, bigint calculations, or binomial expansions, this type of thing can be super useful! QuTiP 5 uses an algorithm like this for matrix powers. (I imagine SciPy does too, but for all the normal reasons, we don't use their implementation.). *edit*: here it is: https://github.com/qutip/qutip/blob/559387e68eb2b07064d2ae6099fbdc81ea96d67c/qutip/core/data/pow.pyx#L17-L39",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1688#issuecomment-942580997
https://github.com/qutip/qutip/pull/1688#issuecomment-942580997:782,Energy Efficiency,power,powers,782,"There's another interesting technique that's sometimes applicable in these sort of repeating cases. Rather than passing a list of the same elements to `tensor`, you can also consider building up the tensor product manually, going up in powers of two. So you go along with something like:; ```python; out, tmp = H, H; for i in n.bit_length():; tmp = tensor(tmp, tmp); if n & (1 << i):; out = tensor(out, tmp); ```; (very very approximately - I've almost certainly got the indexing wrong). The idea is that you only perform `lg(n)` tensor products. Now, this might not actually give you much of a speed up in this case, because the calculation is still going to be dominated by the final tensor product, since the output matrix keeps getting larger. But in things like integer matrix powers, bigint calculations, or binomial expansions, this type of thing can be super useful! QuTiP 5 uses an algorithm like this for matrix powers. (I imagine SciPy does too, but for all the normal reasons, we don't use their implementation.). *edit*: here it is: https://github.com/qutip/qutip/blob/559387e68eb2b07064d2ae6099fbdc81ea96d67c/qutip/core/data/pow.pyx#L17-L39",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1688#issuecomment-942580997
https://github.com/qutip/qutip/pull/1688#issuecomment-942580997:922,Energy Efficiency,power,powers,922,"There's another interesting technique that's sometimes applicable in these sort of repeating cases. Rather than passing a list of the same elements to `tensor`, you can also consider building up the tensor product manually, going up in powers of two. So you go along with something like:; ```python; out, tmp = H, H; for i in n.bit_length():; tmp = tensor(tmp, tmp); if n & (1 << i):; out = tensor(out, tmp); ```; (very very approximately - I've almost certainly got the indexing wrong). The idea is that you only perform `lg(n)` tensor products. Now, this might not actually give you much of a speed up in this case, because the calculation is still going to be dominated by the final tensor product, since the output matrix keeps getting larger. But in things like integer matrix powers, bigint calculations, or binomial expansions, this type of thing can be super useful! QuTiP 5 uses an algorithm like this for matrix powers. (I imagine SciPy does too, but for all the normal reasons, we don't use their implementation.). *edit*: here it is: https://github.com/qutip/qutip/blob/559387e68eb2b07064d2ae6099fbdc81ea96d67c/qutip/core/data/pow.pyx#L17-L39",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1688#issuecomment-942580997
https://github.com/qutip/qutip/pull/1688#issuecomment-942580997:514,Performance,perform,perform,514,"There's another interesting technique that's sometimes applicable in these sort of repeating cases. Rather than passing a list of the same elements to `tensor`, you can also consider building up the tensor product manually, going up in powers of two. So you go along with something like:; ```python; out, tmp = H, H; for i in n.bit_length():; tmp = tensor(tmp, tmp); if n & (1 << i):; out = tensor(out, tmp); ```; (very very approximately - I've almost certainly got the indexing wrong). The idea is that you only perform `lg(n)` tensor products. Now, this might not actually give you much of a speed up in this case, because the calculation is still going to be dominated by the final tensor product, since the output matrix keeps getting larger. But in things like integer matrix powers, bigint calculations, or binomial expansions, this type of thing can be super useful! QuTiP 5 uses an algorithm like this for matrix powers. (I imagine SciPy does too, but for all the normal reasons, we don't use their implementation.). *edit*: here it is: https://github.com/qutip/qutip/blob/559387e68eb2b07064d2ae6099fbdc81ea96d67c/qutip/core/data/pow.pyx#L17-L39",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1688#issuecomment-942580997
https://github.com/qutip/qutip/pull/1689#issuecomment-943619749:97,Availability,error,error,97,"@hodgestar since yesterday our tests are failing for python3.9 ubuntu, but I can't reproduce the error locally...; I you have time could you take a look.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1689#issuecomment-943619749
https://github.com/qutip/qutip/pull/1689#issuecomment-943619749:31,Testability,test,tests,31,"@hodgestar since yesterday our tests are failing for python3.9 ubuntu, but I can't reproduce the error locally...; I you have time could you take a look.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1689#issuecomment-943619749
https://github.com/qutip/qutip/pull/1689#issuecomment-944354143:99,Availability,error,error,99,"> @hodgestar since yesterday our tests are failing for python3.9 ubuntu, but I can't reproduce the error locally... I you have time could you take a look. I haven't managed to reproduce locally either yet and the test failures are odd. There was an update to `ubuntu-latest` on `11 October 2021` so maybe that is related somehow? See https://github.com/actions/virtual-environments/blob/main/images/linux/Ubuntu2004-README.md. I've also clicked ""rerun"" in case there was some transient error with the roll out of the Ubuntu update to GitHub.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1689#issuecomment-944354143
https://github.com/qutip/qutip/pull/1689#issuecomment-944354143:218,Availability,failure,failures,218,"> @hodgestar since yesterday our tests are failing for python3.9 ubuntu, but I can't reproduce the error locally... I you have time could you take a look. I haven't managed to reproduce locally either yet and the test failures are odd. There was an update to `ubuntu-latest` on `11 October 2021` so maybe that is related somehow? See https://github.com/actions/virtual-environments/blob/main/images/linux/Ubuntu2004-README.md. I've also clicked ""rerun"" in case there was some transient error with the roll out of the Ubuntu update to GitHub.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1689#issuecomment-944354143
https://github.com/qutip/qutip/pull/1689#issuecomment-944354143:486,Availability,error,error,486,"> @hodgestar since yesterday our tests are failing for python3.9 ubuntu, but I can't reproduce the error locally... I you have time could you take a look. I haven't managed to reproduce locally either yet and the test failures are odd. There was an update to `ubuntu-latest` on `11 October 2021` so maybe that is related somehow? See https://github.com/actions/virtual-environments/blob/main/images/linux/Ubuntu2004-README.md. I've also clicked ""rerun"" in case there was some transient error with the roll out of the Ubuntu update to GitHub.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1689#issuecomment-944354143
https://github.com/qutip/qutip/pull/1689#issuecomment-944354143:249,Deployability,update,update,249,"> @hodgestar since yesterday our tests are failing for python3.9 ubuntu, but I can't reproduce the error locally... I you have time could you take a look. I haven't managed to reproduce locally either yet and the test failures are odd. There was an update to `ubuntu-latest` on `11 October 2021` so maybe that is related somehow? See https://github.com/actions/virtual-environments/blob/main/images/linux/Ubuntu2004-README.md. I've also clicked ""rerun"" in case there was some transient error with the roll out of the Ubuntu update to GitHub.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1689#issuecomment-944354143
https://github.com/qutip/qutip/pull/1689#issuecomment-944354143:524,Deployability,update,update,524,"> @hodgestar since yesterday our tests are failing for python3.9 ubuntu, but I can't reproduce the error locally... I you have time could you take a look. I haven't managed to reproduce locally either yet and the test failures are odd. There was an update to `ubuntu-latest` on `11 October 2021` so maybe that is related somehow? See https://github.com/actions/virtual-environments/blob/main/images/linux/Ubuntu2004-README.md. I've also clicked ""rerun"" in case there was some transient error with the roll out of the Ubuntu update to GitHub.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1689#issuecomment-944354143
https://github.com/qutip/qutip/pull/1689#issuecomment-944354143:33,Testability,test,tests,33,"> @hodgestar since yesterday our tests are failing for python3.9 ubuntu, but I can't reproduce the error locally... I you have time could you take a look. I haven't managed to reproduce locally either yet and the test failures are odd. There was an update to `ubuntu-latest` on `11 October 2021` so maybe that is related somehow? See https://github.com/actions/virtual-environments/blob/main/images/linux/Ubuntu2004-README.md. I've also clicked ""rerun"" in case there was some transient error with the roll out of the Ubuntu update to GitHub.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1689#issuecomment-944354143
https://github.com/qutip/qutip/pull/1689#issuecomment-944354143:213,Testability,test,test,213,"> @hodgestar since yesterday our tests are failing for python3.9 ubuntu, but I can't reproduce the error locally... I you have time could you take a look. I haven't managed to reproduce locally either yet and the test failures are odd. There was an update to `ubuntu-latest` on `11 October 2021` so maybe that is related somehow? See https://github.com/actions/virtual-environments/blob/main/images/linux/Ubuntu2004-README.md. I've also clicked ""rerun"" in case there was some transient error with the roll out of the Ubuntu update to GitHub.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1689#issuecomment-944354143
https://github.com/qutip/qutip/pull/1689#issuecomment-944383603:15,Testability,test,test,15,"Looking at the test [history](https://github.com/qutip/qutip/actions/workflows/tests.yml), it started failing on Wednesday. ; Looking at the version it seems that numpy went from 1.20.3 to 1.21.2, but 1.21.2 work fine for me...",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1689#issuecomment-944383603
https://github.com/qutip/qutip/pull/1689#issuecomment-944383603:79,Testability,test,tests,79,"Looking at the test [history](https://github.com/qutip/qutip/actions/workflows/tests.yml), it started failing on Wednesday. ; Looking at the version it seems that numpy went from 1.20.3 to 1.21.2, but 1.21.2 work fine for me...",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1689#issuecomment-944383603
https://github.com/qutip/qutip/pull/1689#issuecomment-947778949:20,Testability,test,test,20,"PR #1692 passed the test suite after updating to the latest master, so I'm not sure what is happening. I will try re-run these tests.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1689#issuecomment-947778949
https://github.com/qutip/qutip/pull/1689#issuecomment-947778949:127,Testability,test,tests,127,"PR #1692 passed the test suite after updating to the latest master, so I'm not sure what is happening. I will try re-run these tests.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1689#issuecomment-947778949
https://github.com/qutip/qutip/pull/1690#issuecomment-945596935:464,Safety,avoid,avoid,464,"> _**Other minor changes**_; > ; > In `def show(self)`, the plot was not being displayed using the previous lines of code in the function, so I have commented them out and changed it to; > ; > ```; > if self.fig:; > plt.show(self.fig); > ```; This is something I have not being able to reproduce. It works fine for me with the unmodified lines of code in `show()`. Could you provide an example of when it stops working? In this way, we can include it in a test to avoid the issue happening again.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1690#issuecomment-945596935
https://github.com/qutip/qutip/pull/1690#issuecomment-945596935:456,Testability,test,test,456,"> _**Other minor changes**_; > ; > In `def show(self)`, the plot was not being displayed using the previous lines of code in the function, so I have commented them out and changed it to; > ; > ```; > if self.fig:; > plt.show(self.fig); > ```; This is something I have not being able to reproduce. It works fine for me with the unmodified lines of code in `show()`. Could you provide an example of when it stops working? In this way, we can include it in a test to avoid the issue happening again.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1690#issuecomment-945596935
https://github.com/qutip/qutip/pull/1690#issuecomment-945609485:474,Safety,avoid,avoid,474,"> > _**Other minor changes**_; > > In `def show(self)`, the plot was not being displayed using the previous lines of code in the function, so I have commented them out and changed it to; > > ```; > > if self.fig:; > > plt.show(self.fig); > > ```; > ; > This is something I have not being able to reproduce. It works fine for me with the unmodified lines of code in `show()`. Could you provide an example of when it stops working? In this way, we can include it in a test to avoid the issue happening again. So, I found that the value of `self._shown` is false when it tries to execute `show()', and therefore, the Bloch sphere is not displayed. ; I use the following code to play around with the Bloch sphere, please let me know if I need to add something:; ```; b= Bloch(fig=None); b.xlabel = ['$\\left|+\\right>$',' ']; b.ylabel = ['$\\left|+i \\right> (r_8)$',' ']; b.xlpos = [1.1,-1.1]; b.zlabel = [' $\\left|0\\right> (r_7)$','$\\left|1\\right> $']; b.zlpos = [1.075,-1.08]. <b.add_other_stuff>. b.view=[-20,20,0]; b.show(); ```",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1690#issuecomment-945609485
https://github.com/qutip/qutip/pull/1690#issuecomment-945609485:466,Testability,test,test,466,"> > _**Other minor changes**_; > > In `def show(self)`, the plot was not being displayed using the previous lines of code in the function, so I have commented them out and changed it to; > > ```; > > if self.fig:; > > plt.show(self.fig); > > ```; > ; > This is something I have not being able to reproduce. It works fine for me with the unmodified lines of code in `show()`. Could you provide an example of when it stops working? In this way, we can include it in a test to avoid the issue happening again. So, I found that the value of `self._shown` is false when it tries to execute `show()', and therefore, the Bloch sphere is not displayed. ; I use the following code to play around with the Bloch sphere, please let me know if I need to add something:; ```; b= Bloch(fig=None); b.xlabel = ['$\\left|+\\right>$',' ']; b.ylabel = ['$\\left|+i \\right> (r_8)$',' ']; b.xlpos = [1.1,-1.1]; b.zlabel = [' $\\left|0\\right> (r_7)$','$\\left|1\\right> $']; b.zlpos = [1.075,-1.08]. <b.add_other_stuff>. b.view=[-20,20,0]; b.show(); ```",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1690#issuecomment-945609485
https://github.com/qutip/qutip/pull/1690#issuecomment-945618059:227,Safety,avoid,avoid,227,"> ; > This is something I have not being able to reproduce. It works fine for me with the unmodified lines of code in `show()`. Could you provide an example of when it stops working? In this way, we can include it in a test to avoid the issue happening again. @AGaliciaMartinez Hey Asier, issue #1616 refers to a similar problem. Following it, I tried `plt.show()` and it works. But `b.show()` doesn't work. So, please suggest what to do? Now that `plt.show()` works, I can remove my minor addition in the `show()`, but still I would like to have `b.show()` working. Looking forward to your response.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1690#issuecomment-945618059
https://github.com/qutip/qutip/pull/1690#issuecomment-945618059:219,Testability,test,test,219,"> ; > This is something I have not being able to reproduce. It works fine for me with the unmodified lines of code in `show()`. Could you provide an example of when it stops working? In this way, we can include it in a test to avoid the issue happening again. @AGaliciaMartinez Hey Asier, issue #1616 refers to a similar problem. Following it, I tried `plt.show()` and it works. But `b.show()` doesn't work. So, please suggest what to do? Now that `plt.show()` works, I can remove my minor addition in the `show()`, but still I would like to have `b.show()` working. Looking forward to your response.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1690#issuecomment-945618059
https://github.com/qutip/qutip/pull/1690#issuecomment-950308746:236,Deployability,update,updated,236,"@gaurav-iiser @AGaliciaMartinez I'm fixing a rendering issues in https://github.com/qutip/qutip/pull/1619. The `.show()` issue encountered here is slightly different, but it's all related to cleaning up when and how the bloch sphere is updated and displayed, so I added a fix for `.show()` there. Let's keep this PR for the shiny new functionality and #1619 for the bug fixing of `.render()` and `.show()`.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1690#issuecomment-950308746
https://github.com/qutip/qutip/pull/1690#issuecomment-950320006:126,Availability,failure,failures,126,"@gaurav-iiser Would you mind also merging the master branch into this one? We recently merged some changes that fixed regular failures in test runs after the new version of numpy broke some tests, and it would be good to have those included in here so that test runs pass.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1690#issuecomment-950320006
https://github.com/qutip/qutip/pull/1690#issuecomment-950320006:138,Testability,test,test,138,"@gaurav-iiser Would you mind also merging the master branch into this one? We recently merged some changes that fixed regular failures in test runs after the new version of numpy broke some tests, and it would be good to have those included in here so that test runs pass.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1690#issuecomment-950320006
https://github.com/qutip/qutip/pull/1690#issuecomment-950320006:190,Testability,test,tests,190,"@gaurav-iiser Would you mind also merging the master branch into this one? We recently merged some changes that fixed regular failures in test runs after the new version of numpy broke some tests, and it would be good to have those included in here so that test runs pass.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1690#issuecomment-950320006
https://github.com/qutip/qutip/pull/1690#issuecomment-950320006:257,Testability,test,test,257,"@gaurav-iiser Would you mind also merging the master branch into this one? We recently merged some changes that fixed regular failures in test runs after the new version of numpy broke some tests, and it would be good to have those included in here so that test runs pass.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1690#issuecomment-950320006
https://github.com/qutip/qutip/pull/1690#issuecomment-952921700:52,Integrability,interface,interface,52,"> I left some suggestions here for the higher-level interface.; > ; > My misgiving about my own suggestions is that they diverges from the interface style used already in the `Bloch` class for plotting colours and styles, but adding all the arrays for colours and styling for the new lines and arcs, or stuffing more things into the list of points seemed worse. :). Thanks, Simon @hodgestar for your review. Will make the respective changes soon.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1690#issuecomment-952921700
https://github.com/qutip/qutip/pull/1690#issuecomment-952921700:139,Integrability,interface,interface,139,"> I left some suggestions here for the higher-level interface.; > ; > My misgiving about my own suggestions is that they diverges from the interface style used already in the `Bloch` class for plotting colours and styles, but adding all the arrays for colours and styling for the new lines and arcs, or stuffing more things into the list of points seemed worse. :). Thanks, Simon @hodgestar for your review. Will make the respective changes soon.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1690#issuecomment-952921700
https://github.com/qutip/qutip/pull/1690#issuecomment-991988829:393,Deployability,update,updated,393,"Dear @hodgestar and @AGaliciaMartinez , I have made the changes as Simon suggested -- modified the `add_arc` and `add_line` function to include `Qobj` inputs. By default, have set the arc to be solid blue and the line segment to be solid black, which the user can change as per their wish. Also, have removed the dependency of `add-arc` on `add_points`. Have also included `plot_arc` and have updated `plot_line`. ; Whenever you guys find time, please review the code. Below, I am attaching an image containing a variety of ways we can now change the appearance of arcs and lines. The code used is:. ```; b = Bloch( fig= None, figsize=[10,10]). ... b.add_line([x,y,z],[z,x,y],'m--') ; b.add_line([x,y,z],[y,z,x],'r') ; b.add_line([z,x,y],[y,z,x]). b.add_arc([0.5,0,0],[0,.5,0]); b.add_arc([1,0,0],[0,1,0],'r'); b.add_arc([0,0,1], [1,0,0],'g:'); b.add_arc([0,1,0],[0,0,1],'y--'). b.add_arc([x,y,z],[z,x,y]) ; b.add_arc([x,y,z],[y,z,x]) ; b.add_arc([z,x,y],[y,z,x]) ; ```; where `[x,y,z] = [1/np.sqrt(2), 1/np.sqrt(2), 0]`; ![qutip_bloch](https://user-images.githubusercontent.com/33507538/145733327-80f71c48-7401-4e06-a55e-9cd0378c66b4.png)",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1690#issuecomment-991988829
https://github.com/qutip/qutip/pull/1690#issuecomment-991988829:313,Integrability,depend,dependency,313,"Dear @hodgestar and @AGaliciaMartinez , I have made the changes as Simon suggested -- modified the `add_arc` and `add_line` function to include `Qobj` inputs. By default, have set the arc to be solid blue and the line segment to be solid black, which the user can change as per their wish. Also, have removed the dependency of `add-arc` on `add_points`. Have also included `plot_arc` and have updated `plot_line`. ; Whenever you guys find time, please review the code. Below, I am attaching an image containing a variety of ways we can now change the appearance of arcs and lines. The code used is:. ```; b = Bloch( fig= None, figsize=[10,10]). ... b.add_line([x,y,z],[z,x,y],'m--') ; b.add_line([x,y,z],[y,z,x],'r') ; b.add_line([z,x,y],[y,z,x]). b.add_arc([0.5,0,0],[0,.5,0]); b.add_arc([1,0,0],[0,1,0],'r'); b.add_arc([0,0,1], [1,0,0],'g:'); b.add_arc([0,1,0],[0,0,1],'y--'). b.add_arc([x,y,z],[z,x,y]) ; b.add_arc([x,y,z],[y,z,x]) ; b.add_arc([z,x,y],[y,z,x]) ; ```; where `[x,y,z] = [1/np.sqrt(2), 1/np.sqrt(2), 0]`; ![qutip_bloch](https://user-images.githubusercontent.com/33507538/145733327-80f71c48-7401-4e06-a55e-9cd0378c66b4.png)",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1690#issuecomment-991988829
https://github.com/qutip/qutip/pull/1690#issuecomment-1057408459:46,Deployability,update,updated,46,"@AGaliciaMartinez I applied your suggestions, updated the docstrings and added some tests. Would you mind having a quick last review?",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1690#issuecomment-1057408459
https://github.com/qutip/qutip/pull/1690#issuecomment-1057408459:84,Testability,test,tests,84,"@AGaliciaMartinez I applied your suggestions, updated the docstrings and added some tests. Would you mind having a quick last review?",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1690#issuecomment-1057408459
https://github.com/qutip/qutip/pull/1690#issuecomment-1058321987:28,Testability,test,tests,28,"> I saw that you added some tests although I must admit I am not sure how useful they will be in the future as they pretty much use the same code to generate the ref figure an the test figure. That being said, I do not know what alternative could be used for testing these cases, so lets just keep them as they are. I agree that the implementations are perhaps a bit too similar, but I'm happy that:. * they show that the code can at least be run, and; * matplotlib saves the plots to `result_images` when the tests are run so that one can look at the output if one wants to, and so; * I am pretty sure the reference implementations look correct and those won't change when the code changes (woot). So if one wants to introduce a bug one will have to change the code, then code change the reference code in the tests and not look at the images matplotlib produces, which is substantially better than the current situation. :)",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1690#issuecomment-1058321987
https://github.com/qutip/qutip/pull/1690#issuecomment-1058321987:180,Testability,test,test,180,"> I saw that you added some tests although I must admit I am not sure how useful they will be in the future as they pretty much use the same code to generate the ref figure an the test figure. That being said, I do not know what alternative could be used for testing these cases, so lets just keep them as they are. I agree that the implementations are perhaps a bit too similar, but I'm happy that:. * they show that the code can at least be run, and; * matplotlib saves the plots to `result_images` when the tests are run so that one can look at the output if one wants to, and so; * I am pretty sure the reference implementations look correct and those won't change when the code changes (woot). So if one wants to introduce a bug one will have to change the code, then code change the reference code in the tests and not look at the images matplotlib produces, which is substantially better than the current situation. :)",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1690#issuecomment-1058321987
https://github.com/qutip/qutip/pull/1690#issuecomment-1058321987:259,Testability,test,testing,259,"> I saw that you added some tests although I must admit I am not sure how useful they will be in the future as they pretty much use the same code to generate the ref figure an the test figure. That being said, I do not know what alternative could be used for testing these cases, so lets just keep them as they are. I agree that the implementations are perhaps a bit too similar, but I'm happy that:. * they show that the code can at least be run, and; * matplotlib saves the plots to `result_images` when the tests are run so that one can look at the output if one wants to, and so; * I am pretty sure the reference implementations look correct and those won't change when the code changes (woot). So if one wants to introduce a bug one will have to change the code, then code change the reference code in the tests and not look at the images matplotlib produces, which is substantially better than the current situation. :)",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1690#issuecomment-1058321987
https://github.com/qutip/qutip/pull/1690#issuecomment-1058321987:510,Testability,test,tests,510,"> I saw that you added some tests although I must admit I am not sure how useful they will be in the future as they pretty much use the same code to generate the ref figure an the test figure. That being said, I do not know what alternative could be used for testing these cases, so lets just keep them as they are. I agree that the implementations are perhaps a bit too similar, but I'm happy that:. * they show that the code can at least be run, and; * matplotlib saves the plots to `result_images` when the tests are run so that one can look at the output if one wants to, and so; * I am pretty sure the reference implementations look correct and those won't change when the code changes (woot). So if one wants to introduce a bug one will have to change the code, then code change the reference code in the tests and not look at the images matplotlib produces, which is substantially better than the current situation. :)",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1690#issuecomment-1058321987
https://github.com/qutip/qutip/pull/1690#issuecomment-1058321987:811,Testability,test,tests,811,"> I saw that you added some tests although I must admit I am not sure how useful they will be in the future as they pretty much use the same code to generate the ref figure an the test figure. That being said, I do not know what alternative could be used for testing these cases, so lets just keep them as they are. I agree that the implementations are perhaps a bit too similar, but I'm happy that:. * they show that the code can at least be run, and; * matplotlib saves the plots to `result_images` when the tests are run so that one can look at the output if one wants to, and so; * I am pretty sure the reference implementations look correct and those won't change when the code changes (woot). So if one wants to introduce a bug one will have to change the code, then code change the reference code in the tests and not look at the images matplotlib produces, which is substantially better than the current situation. :)",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1690#issuecomment-1058321987
https://github.com/qutip/qutip/issues/1691#issuecomment-947512829:114,Testability,test,tests,114,"I attempted to make `qobj` return an scalar for this case, as QuTiP 5 does, but that seems to be a no-go. Tens of tests start failing because QuTiP 4 doing things like:; ```python; (bra*ket).tr(); ```; or ; ```python; (bra*ket).data[0,0]; ```; Even thought fixing this is quite straightforward, I decided not to change it and open a PR to allow scalar-like qobj `**`.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1691#issuecomment-947512829
https://github.com/qutip/qutip/pull/1692#issuecomment-947715265:121,Testability,test,test,121,@AGaliciaMartinez Would you mind updating this branch to the latest master branch? (I am trying to understand the broken test),MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1692#issuecomment-947715265
https://github.com/qutip/qutip/pull/1692#issuecomment-947724957:25,Deployability,update,updated,25,@hodgestar Should be now updated.,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1692#issuecomment-947724957
https://github.com/qutip/qutip/pull/1692#issuecomment-947776584:26,Deployability,update,updated,26,"Since tests pass with the updated branch, I'm going to merge this.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1692#issuecomment-947776584
https://github.com/qutip/qutip/pull/1692#issuecomment-947776584:6,Testability,test,tests,6,"Since tests pass with the updated branch, I'm going to merge this.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1692#issuecomment-947776584
https://github.com/qutip/qutip/pull/1694#issuecomment-948435607:98,Availability,failure,failures,98,@Ericgig I've started this branch specifically to tackle the strange steadystate (and other) test failures.,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1694#issuecomment-948435607
https://github.com/qutip/qutip/pull/1694#issuecomment-948435607:93,Testability,test,test,93,@Ericgig I've started this branch specifically to tackle the strange steadystate (and other) test failures.,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1694#issuecomment-948435607
https://github.com/qutip/qutip/pull/1694#issuecomment-948594430:236,Testability,test,tests,236,[![Coverage Status](https://coveralls.io/builds/43683136/badge)](https://coveralls.io/builds/43683136). Coverage remained the same at 16.832% when pulling **4b027c3c555bacd135e15bd21f842dd5c1962cf1 on hodgestar:fix/failing-steady-state-tests** into **091574d12a27a15f8d4861a6ae9c0c8a560dac42 on qutip:master**.,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1694#issuecomment-948594430
https://github.com/qutip/qutip/pull/1694#issuecomment-948841475:35,Availability,error,error,35,"I think we finally have a concrete error and it's rather mystifying to me how it can happen:; ```; E = spla.expm(A.toarray()); if np.isnan(E).any():; print(""A:"", A); print(""A data:"", A.indices, A.indptr, A.shape); print(""A toarray:"", A.toarray()); print(""E:"", E); > raise RuntimeError(""NaNs generated by sp_expm.""); E RuntimeError: NaNs generated by sp_expm. qutip/sparse.py:408: RuntimeError; ----------------------------- Captured stdout call -----------------------------; A: (0, 1)	(-0.5+0j); (1, 0)	(0.5+0j); (1, 2)	(-0.7071067811865476+0j); (2, 1)	(0.7071067811865476+0j); (2, 3)	(-0.8660254037844386+0j); (3, 2)	(0.8660254037844386+0j); (3, 4)	(-1+0j); (4, 3)	(1+0j); A data: [1 0 2 1 3 2 4 3] [0 1 3 5 7 8] (5, 5); A toarray: [[ 0. +0.j -0.5 +0.j 0. +0.j 0. +0.j; 0. +0.j]; [ 0.5 +0.j 0. +0.j -0.70710678+0.j 0. +0.j; 0. +0.j]; [ 0. +0.j 0.70710678+0.j 0. +0.j -0.8660254 +0.j; 0. +0.j]; [ 0. +0.j 0. +0.j 0.8660254 +0.j 0. +0.j; -1. +0.j]; [ 0. +0.j 0. +0.j 0. +0.j 1. +0.j; 0. +0.j]]; E: [[nan+nanj nan+nanj nan+nanj nan+nanj nan+nanj]; [nan+nanj nan+nanj nan+nanj nan+nanj nan+nanj]; [nan+nanj nan+nanj nan+nanj nan+nanj nan+nanj]; [nan+nanj nan+nanj nan+nanj nan+nanj nan+nanj]; [nan+nanj nan+nanj nan+nanj nan+nanj nan+nanj]]; ```; See https://github.com/qutip/qutip/runs/3966808806?check_suite_focus=true#step:6:1646",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1694#issuecomment-948841475
https://github.com/qutip/qutip/pull/1694#issuecomment-949937189:28,Availability,down,down,28,"@Ericgig tracked this issue down to only occuring on numpy 1.21.X (and not 1.20.X) on CI workers with certain Intel CPUs (8171 and 8272). There are a number of changes in numpy 1.21 which could have caused this, but it might take awhile to track down. The plan from here is to make a small PR for some of the tiny clean-ups from here that seem good to have anyway, and then to create a new PR off of master to try get us back onto 1.21.X somehow (probably this will require a numpy fix, but maybe there is another work around).",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1694#issuecomment-949937189
https://github.com/qutip/qutip/pull/1694#issuecomment-949937189:246,Availability,down,down,246,"@Ericgig tracked this issue down to only occuring on numpy 1.21.X (and not 1.20.X) on CI workers with certain Intel CPUs (8171 and 8272). There are a number of changes in numpy 1.21 which could have caused this, but it might take awhile to track down. The plan from here is to make a small PR for some of the tiny clean-ups from here that seem good to have anyway, and then to create a new PR off of master to try get us back onto 1.21.X somehow (probably this will require a numpy fix, but maybe there is another work around).",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1694#issuecomment-949937189
https://github.com/qutip/qutip/pull/1694#issuecomment-967000449:32,Availability,error,error,32,"Minimal script to reproduce the error that only uses numpy:; ```; # On a CPU with AVX512 extensions and numpy 1.21.2:; # (only tested on Ubuntu); # It works again on numpy 1.21.4 (and maybe 1.21.3 -- I did not check because 1.21.3 was not conda installable). import numpy as np. L = np.diag([1+0j, 1, 1, 1]); b = np.array([1+0j, 0, 0, 0]). # commenting out the line below makes everything work, with it solve returns nans.; np.exp(0); # breakpoint(). v = np.linalg.solve(L, b); np.testing.assert_allclose(v, b); ```",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1694#issuecomment-967000449
https://github.com/qutip/qutip/pull/1694#issuecomment-967000449:245,Deployability,install,installable,245,"Minimal script to reproduce the error that only uses numpy:; ```; # On a CPU with AVX512 extensions and numpy 1.21.2:; # (only tested on Ubuntu); # It works again on numpy 1.21.4 (and maybe 1.21.3 -- I did not check because 1.21.3 was not conda installable). import numpy as np. L = np.diag([1+0j, 1, 1, 1]); b = np.array([1+0j, 0, 0, 0]). # commenting out the line below makes everything work, with it solve returns nans.; np.exp(0); # breakpoint(). v = np.linalg.solve(L, b); np.testing.assert_allclose(v, b); ```",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1694#issuecomment-967000449
https://github.com/qutip/qutip/pull/1694#issuecomment-967000449:127,Testability,test,tested,127,"Minimal script to reproduce the error that only uses numpy:; ```; # On a CPU with AVX512 extensions and numpy 1.21.2:; # (only tested on Ubuntu); # It works again on numpy 1.21.4 (and maybe 1.21.3 -- I did not check because 1.21.3 was not conda installable). import numpy as np. L = np.diag([1+0j, 1, 1, 1]); b = np.array([1+0j, 0, 0, 0]). # commenting out the line below makes everything work, with it solve returns nans.; np.exp(0); # breakpoint(). v = np.linalg.solve(L, b); np.testing.assert_allclose(v, b); ```",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1694#issuecomment-967000449
https://github.com/qutip/qutip/pull/1694#issuecomment-967000449:481,Testability,test,testing,481,"Minimal script to reproduce the error that only uses numpy:; ```; # On a CPU with AVX512 extensions and numpy 1.21.2:; # (only tested on Ubuntu); # It works again on numpy 1.21.4 (and maybe 1.21.3 -- I did not check because 1.21.3 was not conda installable). import numpy as np. L = np.diag([1+0j, 1, 1, 1]); b = np.array([1+0j, 0, 0, 0]). # commenting out the line below makes everything work, with it solve returns nans.; np.exp(0); # breakpoint(). v = np.linalg.solve(L, b); np.testing.assert_allclose(v, b); ```",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1694#issuecomment-967000449
https://github.com/qutip/qutip/pull/1694#issuecomment-979433765:59,Deployability,release,released,59,@Ericgig I'm happy to leave this open until a new numpy is released and we can update the version of numpy used in CI tests. Probably also good to have an issue open in case users encounter this in the wild.,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1694#issuecomment-979433765
https://github.com/qutip/qutip/pull/1694#issuecomment-979433765:79,Deployability,update,update,79,@Ericgig I'm happy to leave this open until a new numpy is released and we can update the version of numpy used in CI tests. Probably also good to have an issue open in case users encounter this in the wild.,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1694#issuecomment-979433765
https://github.com/qutip/qutip/pull/1694#issuecomment-979433765:118,Testability,test,tests,118,@Ericgig I'm happy to leave this open until a new numpy is released and we can update the version of numpy used in CI tests. Probably also good to have an issue open in case users encounter this in the wild.,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1694#issuecomment-979433765
https://github.com/qutip/qutip/pull/1694#issuecomment-990380859:15,Energy Efficiency,schedul,scheduled,15,The bug fix is scheduled to be included in numpy 1.22.0 -- https://github.com/numpy/numpy/milestone/93.,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1694#issuecomment-990380859
https://github.com/qutip/qutip/pull/1696#issuecomment-949498838:215,Testability,test,test-numpy-versions,215,[![Coverage Status](https://coveralls.io/builds/43703453/badge)](https://coveralls.io/builds/43703453). Coverage remained the same at 67.118% when pulling **818214c8e58d17c2f264d28eb8dc361eb0f32c5c on hodgestar:fix/test-numpy-versions** into **a41285691e0f5a276a5ad5e72c4ab6f0a7f4c157 on qutip:master**.,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1696#issuecomment-949498838
https://github.com/qutip/qutip/pull/1696#issuecomment-949676495:0,Testability,Test,Tests,0,Tests all passed. Re-running them again to check that is wasn't just luck.,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1696#issuecomment-949676495
https://github.com/qutip/qutip/pull/1699#issuecomment-951749068:157,Deployability,release,releases,157,@sbisw002 Please also follow the description template (see #1697). The changelog part is especially important because we use that to write the changelog for releases.,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1699#issuecomment-951749068
https://github.com/qutip/qutip/pull/1700#issuecomment-953871052:216,Deployability,integrat,integrator,216,[![Coverage Status](https://coveralls.io/builds/44101627/badge)](https://coveralls.io/builds/44101627). Coverage increased (+0.3%) to 65.437% when pulling **af38507293a5f1465f01682e0c34f1499b21f377 on Ericgig:solver.integrator** into **9395b959fd308afc1bf2087171f3e83f6d3387e4 on qutip:dev.major**.,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1700#issuecomment-953871052
https://github.com/qutip/qutip/pull/1700#issuecomment-953871052:216,Integrability,integrat,integrator,216,[![Coverage Status](https://coveralls.io/builds/44101627/badge)](https://coveralls.io/builds/44101627). Coverage increased (+0.3%) to 65.437% when pulling **af38507293a5f1465f01682e0c34f1499b21f377 on Ericgig:solver.integrator** into **9395b959fd308afc1bf2087171f3e83f6d3387e4 on qutip:dev.major**.,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1700#issuecomment-953871052
https://github.com/qutip/qutip/pull/1702#issuecomment-1058039020:63,Usability,simpl,simpler,63,"@sbisw002 I'm closing this in favour of #1819 which applies my simpler fix from #1697 and also adds the necessary deprecation warnings for QuTiP 5. We should continue the development of qutip.lattice in https://github.com/qutip/qutip-lattice. As a first step, we should apply the same simple fix there.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1702#issuecomment-1058039020
https://github.com/qutip/qutip/pull/1702#issuecomment-1058039020:285,Usability,simpl,simple,285,"@sbisw002 I'm closing this in favour of #1819 which applies my simpler fix from #1697 and also adds the necessary deprecation warnings for QuTiP 5. We should continue the development of qutip.lattice in https://github.com/qutip/qutip-lattice. As a first step, we should apply the same simple fix there.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1702#issuecomment-1058039020
https://github.com/qutip/qutip/issues/1703#issuecomment-957253538:218,Deployability,release,release,218,"@fhopfmueller Thank you for looking into these various issues! PRs would be very much appreciated. Perhaps lets do separate PRs for the tests, then `process_fidelity` and then `average_gate_fidelity`?. I would like to release 4.7 in the not too distance future, so one option is to target dev.major / 5 directly (in which case the tests are already fixed).",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1703#issuecomment-957253538
https://github.com/qutip/qutip/issues/1703#issuecomment-957253538:136,Testability,test,tests,136,"@fhopfmueller Thank you for looking into these various issues! PRs would be very much appreciated. Perhaps lets do separate PRs for the tests, then `process_fidelity` and then `average_gate_fidelity`?. I would like to release 4.7 in the not too distance future, so one option is to target dev.major / 5 directly (in which case the tests are already fixed).",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1703#issuecomment-957253538
https://github.com/qutip/qutip/issues/1703#issuecomment-957253538:331,Testability,test,tests,331,"@fhopfmueller Thank you for looking into these various issues! PRs would be very much appreciated. Perhaps lets do separate PRs for the tests, then `process_fidelity` and then `average_gate_fidelity`?. I would like to release 4.7 in the not too distance future, so one option is to target dev.major / 5 directly (in which case the tests are already fixed).",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1703#issuecomment-957253538
https://github.com/qutip/qutip/issues/1703#issuecomment-958255641:62,Testability,test,tests,62,"Hi @hodgestar , sounds good! I submitted the first PR for the tests.; For the `process_fidelity` and `average_gate_fidelity` PRs, I can definitely send them on the weekend, I can't promise before that unfortunately.; I'm happy to target either version with the other PRs, please let me know what makes more sense!",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1703#issuecomment-958255641
https://github.com/qutip/qutip/issues/1705#issuecomment-959146334:256,Availability,error,error,256,"@shemian29 Did this issue occur after you upgraded QuTiP or one of it's dependencies? And how did you install QuTiP? The IPython kernel crash suggests that maybe the installation is broken somehow (e.g. mismatched C libraries, etc). I can't reproduce your error on my side.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1705#issuecomment-959146334
https://github.com/qutip/qutip/issues/1705#issuecomment-959146334:42,Deployability,upgrade,upgraded,42,"@shemian29 Did this issue occur after you upgraded QuTiP or one of it's dependencies? And how did you install QuTiP? The IPython kernel crash suggests that maybe the installation is broken somehow (e.g. mismatched C libraries, etc). I can't reproduce your error on my side.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1705#issuecomment-959146334
https://github.com/qutip/qutip/issues/1705#issuecomment-959146334:102,Deployability,install,install,102,"@shemian29 Did this issue occur after you upgraded QuTiP or one of it's dependencies? And how did you install QuTiP? The IPython kernel crash suggests that maybe the installation is broken somehow (e.g. mismatched C libraries, etc). I can't reproduce your error on my side.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1705#issuecomment-959146334
https://github.com/qutip/qutip/issues/1705#issuecomment-959146334:166,Deployability,install,installation,166,"@shemian29 Did this issue occur after you upgraded QuTiP or one of it's dependencies? And how did you install QuTiP? The IPython kernel crash suggests that maybe the installation is broken somehow (e.g. mismatched C libraries, etc). I can't reproduce your error on my side.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1705#issuecomment-959146334
https://github.com/qutip/qutip/issues/1705#issuecomment-959146334:72,Integrability,depend,dependencies,72,"@shemian29 Did this issue occur after you upgraded QuTiP or one of it's dependencies? And how did you install QuTiP? The IPython kernel crash suggests that maybe the installation is broken somehow (e.g. mismatched C libraries, etc). I can't reproduce your error on my side.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1705#issuecomment-959146334
https://github.com/qutip/qutip/issues/1705#issuecomment-959451146:105,Deployability,install,installation,105,"I can not reproduce it either. Here is _my_ output from `qutip.about()`. I seem to have a different BLAS installation but I am not sure if it is related. ```; QuTiP: Quantum Toolbox in Python; ================================; Copyright (c) QuTiP team 2011 and later.; Current admin team: Alexander Pitchford, Nathan Shammah, Shahnawaz Ahmed, Neill Lambert, Eric Giguère, Boxi Li, Jake Lishman and Simon Cross.; Board members: Daniel Burgarth, Robert Johansson, Anton F. Kockum, Franco Nori and Will Zeng.; Original developers: R. J. Johansson & P. D. Nation.; Previous lead developers: Chris Granade & A. Grimsmo.; Currently developed through wide collaboration. See https://github.com/qutip for details. QuTiP Version: 4.6.2; Numpy Version: 1.21.3; Scipy Version: 1.7.1; Cython Version: None; Matplotlib Version: None; Python Version: 3.9.5; Number of CPUs: 4; BLAS Info: OPENBLAS; OPENMP Installed: False; INTEL MKL Ext: False; Platform Info: Linux (x86_64); Installation path: /home/kaladin/.virtualenvs/fresh-qutip/lib/python3.9/site-packages/qutip; ================================================================================; Please cite QuTiP in your publication.; ================================================================================; For your convenience a bibtex reference can be easily generated using `qutip.cite()`; ```",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1705#issuecomment-959451146
https://github.com/qutip/qutip/issues/1705#issuecomment-959451146:891,Deployability,Install,Installed,891,"I can not reproduce it either. Here is _my_ output from `qutip.about()`. I seem to have a different BLAS installation but I am not sure if it is related. ```; QuTiP: Quantum Toolbox in Python; ================================; Copyright (c) QuTiP team 2011 and later.; Current admin team: Alexander Pitchford, Nathan Shammah, Shahnawaz Ahmed, Neill Lambert, Eric Giguère, Boxi Li, Jake Lishman and Simon Cross.; Board members: Daniel Burgarth, Robert Johansson, Anton F. Kockum, Franco Nori and Will Zeng.; Original developers: R. J. Johansson & P. D. Nation.; Previous lead developers: Chris Granade & A. Grimsmo.; Currently developed through wide collaboration. See https://github.com/qutip for details. QuTiP Version: 4.6.2; Numpy Version: 1.21.3; Scipy Version: 1.7.1; Cython Version: None; Matplotlib Version: None; Python Version: 3.9.5; Number of CPUs: 4; BLAS Info: OPENBLAS; OPENMP Installed: False; INTEL MKL Ext: False; Platform Info: Linux (x86_64); Installation path: /home/kaladin/.virtualenvs/fresh-qutip/lib/python3.9/site-packages/qutip; ================================================================================; Please cite QuTiP in your publication.; ================================================================================; For your convenience a bibtex reference can be easily generated using `qutip.cite()`; ```",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1705#issuecomment-959451146
https://github.com/qutip/qutip/issues/1705#issuecomment-959451146:962,Deployability,Install,Installation,962,"I can not reproduce it either. Here is _my_ output from `qutip.about()`. I seem to have a different BLAS installation but I am not sure if it is related. ```; QuTiP: Quantum Toolbox in Python; ================================; Copyright (c) QuTiP team 2011 and later.; Current admin team: Alexander Pitchford, Nathan Shammah, Shahnawaz Ahmed, Neill Lambert, Eric Giguère, Boxi Li, Jake Lishman and Simon Cross.; Board members: Daniel Burgarth, Robert Johansson, Anton F. Kockum, Franco Nori and Will Zeng.; Original developers: R. J. Johansson & P. D. Nation.; Previous lead developers: Chris Granade & A. Grimsmo.; Currently developed through wide collaboration. See https://github.com/qutip for details. QuTiP Version: 4.6.2; Numpy Version: 1.21.3; Scipy Version: 1.7.1; Cython Version: None; Matplotlib Version: None; Python Version: 3.9.5; Number of CPUs: 4; BLAS Info: OPENBLAS; OPENMP Installed: False; INTEL MKL Ext: False; Platform Info: Linux (x86_64); Installation path: /home/kaladin/.virtualenvs/fresh-qutip/lib/python3.9/site-packages/qutip; ================================================================================; Please cite QuTiP in your publication.; ================================================================================; For your convenience a bibtex reference can be easily generated using `qutip.cite()`; ```",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1705#issuecomment-959451146
https://github.com/qutip/qutip/issues/1705#issuecomment-1006413111:34,Availability,error,error,34,"@shemian29 It's possible that the error is caused by using numpy 1.21.2 with MKL which triggers this bug -- https://github.com/numpy/numpy/issues/20356 -- on Intel CPUs that support AVX512. If that is the case, it should be fixed by install QuTiP 4.6.3 when it is released (hopefully early next week) and numpy 1.22. P.S. If you like, you could install QuTiP from the master branch and numpy 1.22 now and see if that solves your issue.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1705#issuecomment-1006413111
https://github.com/qutip/qutip/issues/1705#issuecomment-1006413111:233,Deployability,install,install,233,"@shemian29 It's possible that the error is caused by using numpy 1.21.2 with MKL which triggers this bug -- https://github.com/numpy/numpy/issues/20356 -- on Intel CPUs that support AVX512. If that is the case, it should be fixed by install QuTiP 4.6.3 when it is released (hopefully early next week) and numpy 1.22. P.S. If you like, you could install QuTiP from the master branch and numpy 1.22 now and see if that solves your issue.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1705#issuecomment-1006413111
https://github.com/qutip/qutip/issues/1705#issuecomment-1006413111:264,Deployability,release,released,264,"@shemian29 It's possible that the error is caused by using numpy 1.21.2 with MKL which triggers this bug -- https://github.com/numpy/numpy/issues/20356 -- on Intel CPUs that support AVX512. If that is the case, it should be fixed by install QuTiP 4.6.3 when it is released (hopefully early next week) and numpy 1.22. P.S. If you like, you could install QuTiP from the master branch and numpy 1.22 now and see if that solves your issue.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1705#issuecomment-1006413111
https://github.com/qutip/qutip/issues/1705#issuecomment-1006413111:345,Deployability,install,install,345,"@shemian29 It's possible that the error is caused by using numpy 1.21.2 with MKL which triggers this bug -- https://github.com/numpy/numpy/issues/20356 -- on Intel CPUs that support AVX512. If that is the case, it should be fixed by install QuTiP 4.6.3 when it is released (hopefully early next week) and numpy 1.22. P.S. If you like, you could install QuTiP from the master branch and numpy 1.22 now and see if that solves your issue.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1705#issuecomment-1006413111
https://github.com/qutip/qutip/issues/1705#issuecomment-1856852938:19,Deployability,release,released,19,"QuTiP 4.6.3 has be released with the likely fix and we have no more information or ability to reproduce, so closing for now.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1705#issuecomment-1856852938
https://github.com/qutip/qutip/issues/1706#issuecomment-961883532:150,Availability,error,error,150,"Hi Leo-am, ; Thank you for your interest, any help would be greatly appreciated.; `stochastic` documentation is certainly lacking. . If there are any error in the equations, please let me know so I can check that they are not also present in the code.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1706#issuecomment-961883532
https://github.com/qutip/qutip/issues/1706#issuecomment-962765705:76,Availability,error,errors,76,"Hi Eric, . thanks for your eager response.; I'll let you know if I find any errors. Since you mentioned the equations in the code, I believe it would be interesting to add explicitly which equations are solved when the options `method=""homodyne""` and `method=""heterodyne""` are selected. Specifically, I would like to check what are the values of dW_factors in both cases.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1706#issuecomment-962765705
https://github.com/qutip/qutip/issues/1706#issuecomment-963395778:43,Deployability,integrat,integration,43,"I rechecked the equations:; The stochastic integration has the general form:; ![image](https://user-images.githubusercontent.com/17770236/140782543-9d8ff092-b9cb-4b17-98e8-85ab0254b425.png); For `ssesolve`:; ![image](https://user-images.githubusercontent.com/17770236/140783379-72e48698-4f2d-4ebc-bfac-95630e8724b1.png). And for `smesolve`:; ![image](https://user-images.githubusercontent.com/17770236/140784174-e9fdb33b-2fee-4795-a93d-e7d1abe32ddd.png). The liouvillian use both the `sc_ops` and `c_ops` for collapse, but the `d_2` part only use `sc_ops`. In heterodyne detection, each `sc_ops` is split into 2 parts computed individually: ; ![image](https://user-images.githubusercontent.com/17770236/140784227-39e67d38-33bf-47c8-ab57-afd41c23afa6.png). `m_ops` for homodyne:; ![image](https://user-images.githubusercontent.com/17770236/140784715-a7861965-6b30-4a47-a7a6-e19d4dd8b430.png). `m_ops` for heterodyne:; ![image](https://user-images.githubusercontent.com/17770236/140784760-5adb2535-ff63-4b2d-bba8-b10b6422b5db.png). In both case the `dW`'s default is `1`. In the heterodyne case, the `sqrt(2)` is expected to be included inside `dW_factor` when it's length is the same as `m_ops`.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1706#issuecomment-963395778
https://github.com/qutip/qutip/issues/1706#issuecomment-963395778:43,Integrability,integrat,integration,43,"I rechecked the equations:; The stochastic integration has the general form:; ![image](https://user-images.githubusercontent.com/17770236/140782543-9d8ff092-b9cb-4b17-98e8-85ab0254b425.png); For `ssesolve`:; ![image](https://user-images.githubusercontent.com/17770236/140783379-72e48698-4f2d-4ebc-bfac-95630e8724b1.png). And for `smesolve`:; ![image](https://user-images.githubusercontent.com/17770236/140784174-e9fdb33b-2fee-4795-a93d-e7d1abe32ddd.png). The liouvillian use both the `sc_ops` and `c_ops` for collapse, but the `d_2` part only use `sc_ops`. In heterodyne detection, each `sc_ops` is split into 2 parts computed individually: ; ![image](https://user-images.githubusercontent.com/17770236/140784227-39e67d38-33bf-47c8-ab57-afd41c23afa6.png). `m_ops` for homodyne:; ![image](https://user-images.githubusercontent.com/17770236/140784715-a7861965-6b30-4a47-a7a6-e19d4dd8b430.png). `m_ops` for heterodyne:; ![image](https://user-images.githubusercontent.com/17770236/140784760-5adb2535-ff63-4b2d-bba8-b10b6422b5db.png). In both case the `dW`'s default is `1`. In the heterodyne case, the `sqrt(2)` is expected to be included inside `dW_factor` when it's length is the same as `m_ops`.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1706#issuecomment-963395778
https://github.com/qutip/qutip/issues/1706#issuecomment-963395778:571,Safety,detect,detection,571,"I rechecked the equations:; The stochastic integration has the general form:; ![image](https://user-images.githubusercontent.com/17770236/140782543-9d8ff092-b9cb-4b17-98e8-85ab0254b425.png); For `ssesolve`:; ![image](https://user-images.githubusercontent.com/17770236/140783379-72e48698-4f2d-4ebc-bfac-95630e8724b1.png). And for `smesolve`:; ![image](https://user-images.githubusercontent.com/17770236/140784174-e9fdb33b-2fee-4795-a93d-e7d1abe32ddd.png). The liouvillian use both the `sc_ops` and `c_ops` for collapse, but the `d_2` part only use `sc_ops`. In heterodyne detection, each `sc_ops` is split into 2 parts computed individually: ; ![image](https://user-images.githubusercontent.com/17770236/140784227-39e67d38-33bf-47c8-ab57-afd41c23afa6.png). `m_ops` for homodyne:; ![image](https://user-images.githubusercontent.com/17770236/140784715-a7861965-6b30-4a47-a7a6-e19d4dd8b430.png). `m_ops` for heterodyne:; ![image](https://user-images.githubusercontent.com/17770236/140784760-5adb2535-ff63-4b2d-bba8-b10b6422b5db.png). In both case the `dW`'s default is `1`. In the heterodyne case, the `sqrt(2)` is expected to be included inside `dW_factor` when it's length is the same as `m_ops`.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1706#issuecomment-963395778
https://github.com/qutip/qutip/issues/1706#issuecomment-992023974:319,Testability,test,tests,319,"The equation for `d_{2,i}` for `ssesolve` seems to be missing a 1/2 term. I checked two sources: Quantum Measurement and Control, Wiseman and Milburn (equation 4.76, page 162), and [the development notebook for SSE](https://nbviewer.ipython.org/github/qutip/qutip-notebooks/blob/master/development/development-ssesolve-tests.ipynb). In both cases, the expression for d_{2, i} for the SSE is: . <img width=""278"" alt=""Untitled"" src=""https://user-images.githubusercontent.com/39472087/145735966-85d0c932-a247-42e7-91e1-98fc0f6d0c49.png"">. For the stochastic master equation, I also found a different expression for `d_{2,i}`. Both book (equations 4.24 and 4.72 in pages 152 and 161, respectively) and development notebook, state that it should be written:. <img width=""483"" alt=""d2master"" src=""https://user-images.githubusercontent.com/39472087/145737189-9e3996a5-186a-47e3-9e2f-7e365e00e5ea.png"">. To test the current qutip implementation, I tried to replicate the results of both [SSE](https://nbviewer.ipython.org/github/qutip/qutip-notebooks/blob/master/development/development-ssesolve-tests.ipynb) and [SME](https://nbviewer.ipython.org/github/qutip/qutip-notebooks/blob/master/development/development-smesolve-tests.ipynb) development notebooks. The results obtained with QuTiP homodyne and heterodyne methods were similar to the results obtained with the d_1 and d_2 implemented 'by hand' in the notebooks, which used the expressions I listed above. In my tests, I used QuTiP 4.5.2. The equations above are also the current reported equations in the [stochastic solver documentation](https://qutip.org/docs/latest/guide/dynamics/dynamics-stochastic.html).",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1706#issuecomment-992023974
https://github.com/qutip/qutip/issues/1706#issuecomment-992023974:899,Testability,test,test,899,"The equation for `d_{2,i}` for `ssesolve` seems to be missing a 1/2 term. I checked two sources: Quantum Measurement and Control, Wiseman and Milburn (equation 4.76, page 162), and [the development notebook for SSE](https://nbviewer.ipython.org/github/qutip/qutip-notebooks/blob/master/development/development-ssesolve-tests.ipynb). In both cases, the expression for d_{2, i} for the SSE is: . <img width=""278"" alt=""Untitled"" src=""https://user-images.githubusercontent.com/39472087/145735966-85d0c932-a247-42e7-91e1-98fc0f6d0c49.png"">. For the stochastic master equation, I also found a different expression for `d_{2,i}`. Both book (equations 4.24 and 4.72 in pages 152 and 161, respectively) and development notebook, state that it should be written:. <img width=""483"" alt=""d2master"" src=""https://user-images.githubusercontent.com/39472087/145737189-9e3996a5-186a-47e3-9e2f-7e365e00e5ea.png"">. To test the current qutip implementation, I tried to replicate the results of both [SSE](https://nbviewer.ipython.org/github/qutip/qutip-notebooks/blob/master/development/development-ssesolve-tests.ipynb) and [SME](https://nbviewer.ipython.org/github/qutip/qutip-notebooks/blob/master/development/development-smesolve-tests.ipynb) development notebooks. The results obtained with QuTiP homodyne and heterodyne methods were similar to the results obtained with the d_1 and d_2 implemented 'by hand' in the notebooks, which used the expressions I listed above. In my tests, I used QuTiP 4.5.2. The equations above are also the current reported equations in the [stochastic solver documentation](https://qutip.org/docs/latest/guide/dynamics/dynamics-stochastic.html).",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1706#issuecomment-992023974
https://github.com/qutip/qutip/issues/1706#issuecomment-992023974:1088,Testability,test,tests,1088,"The equation for `d_{2,i}` for `ssesolve` seems to be missing a 1/2 term. I checked two sources: Quantum Measurement and Control, Wiseman and Milburn (equation 4.76, page 162), and [the development notebook for SSE](https://nbviewer.ipython.org/github/qutip/qutip-notebooks/blob/master/development/development-ssesolve-tests.ipynb). In both cases, the expression for d_{2, i} for the SSE is: . <img width=""278"" alt=""Untitled"" src=""https://user-images.githubusercontent.com/39472087/145735966-85d0c932-a247-42e7-91e1-98fc0f6d0c49.png"">. For the stochastic master equation, I also found a different expression for `d_{2,i}`. Both book (equations 4.24 and 4.72 in pages 152 and 161, respectively) and development notebook, state that it should be written:. <img width=""483"" alt=""d2master"" src=""https://user-images.githubusercontent.com/39472087/145737189-9e3996a5-186a-47e3-9e2f-7e365e00e5ea.png"">. To test the current qutip implementation, I tried to replicate the results of both [SSE](https://nbviewer.ipython.org/github/qutip/qutip-notebooks/blob/master/development/development-ssesolve-tests.ipynb) and [SME](https://nbviewer.ipython.org/github/qutip/qutip-notebooks/blob/master/development/development-smesolve-tests.ipynb) development notebooks. The results obtained with QuTiP homodyne and heterodyne methods were similar to the results obtained with the d_1 and d_2 implemented 'by hand' in the notebooks, which used the expressions I listed above. In my tests, I used QuTiP 4.5.2. The equations above are also the current reported equations in the [stochastic solver documentation](https://qutip.org/docs/latest/guide/dynamics/dynamics-stochastic.html).",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1706#issuecomment-992023974
https://github.com/qutip/qutip/issues/1706#issuecomment-992023974:1214,Testability,test,tests,1214,"The equation for `d_{2,i}` for `ssesolve` seems to be missing a 1/2 term. I checked two sources: Quantum Measurement and Control, Wiseman and Milburn (equation 4.76, page 162), and [the development notebook for SSE](https://nbviewer.ipython.org/github/qutip/qutip-notebooks/blob/master/development/development-ssesolve-tests.ipynb). In both cases, the expression for d_{2, i} for the SSE is: . <img width=""278"" alt=""Untitled"" src=""https://user-images.githubusercontent.com/39472087/145735966-85d0c932-a247-42e7-91e1-98fc0f6d0c49.png"">. For the stochastic master equation, I also found a different expression for `d_{2,i}`. Both book (equations 4.24 and 4.72 in pages 152 and 161, respectively) and development notebook, state that it should be written:. <img width=""483"" alt=""d2master"" src=""https://user-images.githubusercontent.com/39472087/145737189-9e3996a5-186a-47e3-9e2f-7e365e00e5ea.png"">. To test the current qutip implementation, I tried to replicate the results of both [SSE](https://nbviewer.ipython.org/github/qutip/qutip-notebooks/blob/master/development/development-ssesolve-tests.ipynb) and [SME](https://nbviewer.ipython.org/github/qutip/qutip-notebooks/blob/master/development/development-smesolve-tests.ipynb) development notebooks. The results obtained with QuTiP homodyne and heterodyne methods were similar to the results obtained with the d_1 and d_2 implemented 'by hand' in the notebooks, which used the expressions I listed above. In my tests, I used QuTiP 4.5.2. The equations above are also the current reported equations in the [stochastic solver documentation](https://qutip.org/docs/latest/guide/dynamics/dynamics-stochastic.html).",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1706#issuecomment-992023974
https://github.com/qutip/qutip/issues/1706#issuecomment-992023974:1461,Testability,test,tests,1461,"The equation for `d_{2,i}` for `ssesolve` seems to be missing a 1/2 term. I checked two sources: Quantum Measurement and Control, Wiseman and Milburn (equation 4.76, page 162), and [the development notebook for SSE](https://nbviewer.ipython.org/github/qutip/qutip-notebooks/blob/master/development/development-ssesolve-tests.ipynb). In both cases, the expression for d_{2, i} for the SSE is: . <img width=""278"" alt=""Untitled"" src=""https://user-images.githubusercontent.com/39472087/145735966-85d0c932-a247-42e7-91e1-98fc0f6d0c49.png"">. For the stochastic master equation, I also found a different expression for `d_{2,i}`. Both book (equations 4.24 and 4.72 in pages 152 and 161, respectively) and development notebook, state that it should be written:. <img width=""483"" alt=""d2master"" src=""https://user-images.githubusercontent.com/39472087/145737189-9e3996a5-186a-47e3-9e2f-7e365e00e5ea.png"">. To test the current qutip implementation, I tried to replicate the results of both [SSE](https://nbviewer.ipython.org/github/qutip/qutip-notebooks/blob/master/development/development-ssesolve-tests.ipynb) and [SME](https://nbviewer.ipython.org/github/qutip/qutip-notebooks/blob/master/development/development-smesolve-tests.ipynb) development notebooks. The results obtained with QuTiP homodyne and heterodyne methods were similar to the results obtained with the d_1 and d_2 implemented 'by hand' in the notebooks, which used the expressions I listed above. In my tests, I used QuTiP 4.5.2. The equations above are also the current reported equations in the [stochastic solver documentation](https://qutip.org/docs/latest/guide/dynamics/dynamics-stochastic.html).",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1706#issuecomment-992023974
https://github.com/qutip/qutip/issues/1706#issuecomment-992023974:1619,Usability,guid,guide,1619,"The equation for `d_{2,i}` for `ssesolve` seems to be missing a 1/2 term. I checked two sources: Quantum Measurement and Control, Wiseman and Milburn (equation 4.76, page 162), and [the development notebook for SSE](https://nbviewer.ipython.org/github/qutip/qutip-notebooks/blob/master/development/development-ssesolve-tests.ipynb). In both cases, the expression for d_{2, i} for the SSE is: . <img width=""278"" alt=""Untitled"" src=""https://user-images.githubusercontent.com/39472087/145735966-85d0c932-a247-42e7-91e1-98fc0f6d0c49.png"">. For the stochastic master equation, I also found a different expression for `d_{2,i}`. Both book (equations 4.24 and 4.72 in pages 152 and 161, respectively) and development notebook, state that it should be written:. <img width=""483"" alt=""d2master"" src=""https://user-images.githubusercontent.com/39472087/145737189-9e3996a5-186a-47e3-9e2f-7e365e00e5ea.png"">. To test the current qutip implementation, I tried to replicate the results of both [SSE](https://nbviewer.ipython.org/github/qutip/qutip-notebooks/blob/master/development/development-ssesolve-tests.ipynb) and [SME](https://nbviewer.ipython.org/github/qutip/qutip-notebooks/blob/master/development/development-smesolve-tests.ipynb) development notebooks. The results obtained with QuTiP homodyne and heterodyne methods were similar to the results obtained with the d_1 and d_2 implemented 'by hand' in the notebooks, which used the expressions I listed above. In my tests, I used QuTiP 4.5.2. The equations above are also the current reported equations in the [stochastic solver documentation](https://qutip.org/docs/latest/guide/dynamics/dynamics-stochastic.html).",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1706#issuecomment-992023974
https://github.com/qutip/qutip/issues/1706#issuecomment-995160913:24,Availability,error,error,24,"No, I never got similar error...; You seems to be following the instruction in the doc's readme which usually work well.; Your branch seems to be not up to date with master, maybe if you merge the recent changes and rebuild qutip from source, it would work.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1706#issuecomment-995160913
https://github.com/qutip/qutip/pull/1707#issuecomment-967185365:212,Deployability,hotfix,hotfix,212,[![Coverage Status](https://coveralls.io/builds/45783203/badge)](https://coveralls.io/builds/45783203). Coverage decreased (-0.03%) to 68.295% when pulling **ed351d809c2dc2146aca7ef99779af12a79d98d7 on VolodyaCO:hotfix/volodyaco/title-in-visualization** into **b6b86579d6208fc2df5859059bd1cad18f1db06b on qutip:master**.,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1707#issuecomment-967185365
https://github.com/qutip/qutip/pull/1707#issuecomment-990400800:23,Testability,test,test,23,"@VolodyaCO I'd like to test these changes out locally, but they look good to me now.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1707#issuecomment-990400800
https://github.com/qutip/qutip/pull/1707#issuecomment-1056809216:79,Usability,simpl,simple,79,@VolodyaCO Fix merged. Thank you for contributing it and apologies that such a simple fix took a long time to be merged.,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1707#issuecomment-1056809216
https://github.com/qutip/qutip/pull/1708#issuecomment-965150452:46,Usability,feedback,feedback,46,"Hi Eric,. Thanks for looking at this and your feedback!. Alright, I'll close this PR and submit a new one for `dev.major`, and will split up the function as you suggest.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1708#issuecomment-965150452
https://github.com/qutip/qutip/pull/1710#issuecomment-974028874:326,Availability,Error,Error,326,"I like your work very much!; Especially the additional option to stop the simulation when a certain accuracy of the observables is reached!. However, I have the problem that the option is not known with me. ; ` mcsolve() got an unexpected keyword argument 'target_tol'`.; Possibly there is just a problem with my merge. EDIT: Error found, the import classes changed to:; ```; from qutip.solver.mcsolve import mcsolve, McSolver; from qutip.solver.solver_base import Solver; from qutip.solver.options import SolverOptions; ```. Now all works fine, I would vote up for merging!",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1710#issuecomment-974028874
https://github.com/qutip/qutip/pull/1710#issuecomment-974489887:263,Deployability,release,release,263,@Babalion Thank you for tyring.; Please let us know if you meet any bug. I am keeping both for version of `mcsolve` for now for benchmarks.; The new version has more features but it's slower than the previous.; The new version will replace the main one before we release in v5.,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1710#issuecomment-974489887
https://github.com/qutip/qutip/pull/1710#issuecomment-974489887:128,Testability,benchmark,benchmarks,128,@Babalion Thank you for tyring.; Please let us know if you meet any bug. I am keeping both for version of `mcsolve` for now for benchmarks.; The new version has more features but it's slower than the previous.; The new version will replace the main one before we release in v5.,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1710#issuecomment-974489887
https://github.com/qutip/qutip/pull/1710#issuecomment-1068480013:1067,Integrability,interface,interface,1067,"While you could probably make it work but manually updating the state at each times of `tlist` is certainly not a usage I planned for... If you could use `mesolve` instead of `mcsolve` it would be simpler:; ```; solver = MeSolver(...); solver.start(rho0, t0); for t in tlist[1:]:; rho_t = solver.step(t); solver.start(rho_t @ projection, t); ```. With `mcsolve`, if you use it like this, it would normalize the state at each step possibly breaking the montecarlo part of the evolution. The way I would do it is by making a child class overwriting the step of `McTrajectorySolver`:. ```; class MyMcTrajectorySolver(McTrajectorySolver):; def _step(self, t):; super()._step(t); _, raw_state = self._integrator.get_state() # state not normalized; new_state = _data.matmul(projector, state) # projector is a Data object: Qobj.data; self._integrator.set_state(t, new_state); return _data.mul(new_state, 1 / _data.norm.l2(new_state)). class MyMcSolver(McSolver):; _traj_solver_class = MyMcTrajectorySolver; ```; If done this way, you should be able to use the normal solver interface. This projection should be done once per call of `step` or per time in `tlist`, but I would confirm it before running simulation. `step` does not return the `collapse` part of the results. So if a collapse happen, it will not output it nor the time at which it happen. But the state evolution is done normally, collapse will happen as expected. To get them, you will need to fetch them with `solver.traj_solvers[i].collapse`. Feel free to comment on the new solver interface. If you think that something is missing or confusing, now is a good time to tell us. We should come back on this PR in April.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1710#issuecomment-1068480013
https://github.com/qutip/qutip/pull/1710#issuecomment-1068480013:1542,Integrability,interface,interface,1542,"While you could probably make it work but manually updating the state at each times of `tlist` is certainly not a usage I planned for... If you could use `mesolve` instead of `mcsolve` it would be simpler:; ```; solver = MeSolver(...); solver.start(rho0, t0); for t in tlist[1:]:; rho_t = solver.step(t); solver.start(rho_t @ projection, t); ```. With `mcsolve`, if you use it like this, it would normalize the state at each step possibly breaking the montecarlo part of the evolution. The way I would do it is by making a child class overwriting the step of `McTrajectorySolver`:. ```; class MyMcTrajectorySolver(McTrajectorySolver):; def _step(self, t):; super()._step(t); _, raw_state = self._integrator.get_state() # state not normalized; new_state = _data.matmul(projector, state) # projector is a Data object: Qobj.data; self._integrator.set_state(t, new_state); return _data.mul(new_state, 1 / _data.norm.l2(new_state)). class MyMcSolver(McSolver):; _traj_solver_class = MyMcTrajectorySolver; ```; If done this way, you should be able to use the normal solver interface. This projection should be done once per call of `step` or per time in `tlist`, but I would confirm it before running simulation. `step` does not return the `collapse` part of the results. So if a collapse happen, it will not output it nor the time at which it happen. But the state evolution is done normally, collapse will happen as expected. To get them, you will need to fetch them with `solver.traj_solvers[i].collapse`. Feel free to comment on the new solver interface. If you think that something is missing or confusing, now is a good time to tell us. We should come back on this PR in April.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1710#issuecomment-1068480013
https://github.com/qutip/qutip/pull/1710#issuecomment-1068480013:197,Usability,simpl,simpler,197,"While you could probably make it work but manually updating the state at each times of `tlist` is certainly not a usage I planned for... If you could use `mesolve` instead of `mcsolve` it would be simpler:; ```; solver = MeSolver(...); solver.start(rho0, t0); for t in tlist[1:]:; rho_t = solver.step(t); solver.start(rho_t @ projection, t); ```. With `mcsolve`, if you use it like this, it would normalize the state at each step possibly breaking the montecarlo part of the evolution. The way I would do it is by making a child class overwriting the step of `McTrajectorySolver`:. ```; class MyMcTrajectorySolver(McTrajectorySolver):; def _step(self, t):; super()._step(t); _, raw_state = self._integrator.get_state() # state not normalized; new_state = _data.matmul(projector, state) # projector is a Data object: Qobj.data; self._integrator.set_state(t, new_state); return _data.mul(new_state, 1 / _data.norm.l2(new_state)). class MyMcSolver(McSolver):; _traj_solver_class = MyMcTrajectorySolver; ```; If done this way, you should be able to use the normal solver interface. This projection should be done once per call of `step` or per time in `tlist`, but I would confirm it before running simulation. `step` does not return the `collapse` part of the results. So if a collapse happen, it will not output it nor the time at which it happen. But the state evolution is done normally, collapse will happen as expected. To get them, you will need to fetch them with `solver.traj_solvers[i].collapse`. Feel free to comment on the new solver interface. If you think that something is missing or confusing, now is a good time to tell us. We should come back on this PR in April.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1710#issuecomment-1068480013
https://github.com/qutip/qutip/issues/1711#issuecomment-973002325:880,Deployability,Install,Installed,880,"Hi, thank you for opening an issue. Unfortunately, I have not being able to reproduce it. Here is my `qutip.about()` output:; ```; QuTiP: Quantum Toolbox in Python; ================================; Copyright (c) QuTiP team 2011 and later.; Current admin team: Alexander Pitchford, Nathan Shammah, Shahnawaz Ahmed, Neill Lambert, Eric Giguère, Boxi Li, Jake Lishman and Simon Cross.; Board members: Daniel Burgarth, Robert Johansson, Anton F. Kockum, Franco Nori and Will Zeng.; Original developers: R. J. Johansson & P. D. Nation.; Previous lead developers: Chris Granade & A. Grimsmo.; Currently developed through wide collaboration. See https://github.com/qutip for details. QuTiP Version: 4.7.0.dev0+5c73300; Numpy Version: 1.21.2; Scipy Version: 1.7.1; Cython Version: 0.29.23; Matplotlib Version: 3.3.4; Python Version: 3.9.5; Number of CPUs: 4; BLAS Info: OPENBLAS; OPENMP Installed: False; INTEL MKL Ext: False; Platform Info: Linux (x86_64); Installation path: /home/kaladin/Documents/git/qutip/qutip4/qutip; ================================================================================; Please cite QuTiP in your publication.; ================================================================================; For your convenience a bibtex reference can be easily generated using `qutip.cite()`; ```. Regarding to the tests being slow, I usually run only the test file related to the changes I do. For example, to run tests for qobj it suffices to use `pytest qutip/tests/test_qobj.py` from the command line. I then leave the CI do its job and run all the tests once I submit a pull request. I guess it is desirable to improve the speed of some tests, I do not think is a priority though. Also, it only took me 6 minutes in my local computer (i7-6700 and 16GB RAM)to run all the tests using your script. I wonder if there is something else going wrong. Hope this helps!",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1711#issuecomment-973002325
https://github.com/qutip/qutip/issues/1711#issuecomment-973002325:951,Deployability,Install,Installation,951,"Hi, thank you for opening an issue. Unfortunately, I have not being able to reproduce it. Here is my `qutip.about()` output:; ```; QuTiP: Quantum Toolbox in Python; ================================; Copyright (c) QuTiP team 2011 and later.; Current admin team: Alexander Pitchford, Nathan Shammah, Shahnawaz Ahmed, Neill Lambert, Eric Giguère, Boxi Li, Jake Lishman and Simon Cross.; Board members: Daniel Burgarth, Robert Johansson, Anton F. Kockum, Franco Nori and Will Zeng.; Original developers: R. J. Johansson & P. D. Nation.; Previous lead developers: Chris Granade & A. Grimsmo.; Currently developed through wide collaboration. See https://github.com/qutip for details. QuTiP Version: 4.7.0.dev0+5c73300; Numpy Version: 1.21.2; Scipy Version: 1.7.1; Cython Version: 0.29.23; Matplotlib Version: 3.3.4; Python Version: 3.9.5; Number of CPUs: 4; BLAS Info: OPENBLAS; OPENMP Installed: False; INTEL MKL Ext: False; Platform Info: Linux (x86_64); Installation path: /home/kaladin/Documents/git/qutip/qutip4/qutip; ================================================================================; Please cite QuTiP in your publication.; ================================================================================; For your convenience a bibtex reference can be easily generated using `qutip.cite()`; ```. Regarding to the tests being slow, I usually run only the test file related to the changes I do. For example, to run tests for qobj it suffices to use `pytest qutip/tests/test_qobj.py` from the command line. I then leave the CI do its job and run all the tests once I submit a pull request. I guess it is desirable to improve the speed of some tests, I do not think is a priority though. Also, it only took me 6 minutes in my local computer (i7-6700 and 16GB RAM)to run all the tests using your script. I wonder if there is something else going wrong. Hope this helps!",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1711#issuecomment-973002325
https://github.com/qutip/qutip/issues/1711#issuecomment-973002325:1330,Testability,test,tests,1330,"Hi, thank you for opening an issue. Unfortunately, I have not being able to reproduce it. Here is my `qutip.about()` output:; ```; QuTiP: Quantum Toolbox in Python; ================================; Copyright (c) QuTiP team 2011 and later.; Current admin team: Alexander Pitchford, Nathan Shammah, Shahnawaz Ahmed, Neill Lambert, Eric Giguère, Boxi Li, Jake Lishman and Simon Cross.; Board members: Daniel Burgarth, Robert Johansson, Anton F. Kockum, Franco Nori and Will Zeng.; Original developers: R. J. Johansson & P. D. Nation.; Previous lead developers: Chris Granade & A. Grimsmo.; Currently developed through wide collaboration. See https://github.com/qutip for details. QuTiP Version: 4.7.0.dev0+5c73300; Numpy Version: 1.21.2; Scipy Version: 1.7.1; Cython Version: 0.29.23; Matplotlib Version: 3.3.4; Python Version: 3.9.5; Number of CPUs: 4; BLAS Info: OPENBLAS; OPENMP Installed: False; INTEL MKL Ext: False; Platform Info: Linux (x86_64); Installation path: /home/kaladin/Documents/git/qutip/qutip4/qutip; ================================================================================; Please cite QuTiP in your publication.; ================================================================================; For your convenience a bibtex reference can be easily generated using `qutip.cite()`; ```. Regarding to the tests being slow, I usually run only the test file related to the changes I do. For example, to run tests for qobj it suffices to use `pytest qutip/tests/test_qobj.py` from the command line. I then leave the CI do its job and run all the tests once I submit a pull request. I guess it is desirable to improve the speed of some tests, I do not think is a priority though. Also, it only took me 6 minutes in my local computer (i7-6700 and 16GB RAM)to run all the tests using your script. I wonder if there is something else going wrong. Hope this helps!",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1711#issuecomment-973002325
https://github.com/qutip/qutip/issues/1711#issuecomment-973002325:1371,Testability,test,test,1371,"Hi, thank you for opening an issue. Unfortunately, I have not being able to reproduce it. Here is my `qutip.about()` output:; ```; QuTiP: Quantum Toolbox in Python; ================================; Copyright (c) QuTiP team 2011 and later.; Current admin team: Alexander Pitchford, Nathan Shammah, Shahnawaz Ahmed, Neill Lambert, Eric Giguère, Boxi Li, Jake Lishman and Simon Cross.; Board members: Daniel Burgarth, Robert Johansson, Anton F. Kockum, Franco Nori and Will Zeng.; Original developers: R. J. Johansson & P. D. Nation.; Previous lead developers: Chris Granade & A. Grimsmo.; Currently developed through wide collaboration. See https://github.com/qutip for details. QuTiP Version: 4.7.0.dev0+5c73300; Numpy Version: 1.21.2; Scipy Version: 1.7.1; Cython Version: 0.29.23; Matplotlib Version: 3.3.4; Python Version: 3.9.5; Number of CPUs: 4; BLAS Info: OPENBLAS; OPENMP Installed: False; INTEL MKL Ext: False; Platform Info: Linux (x86_64); Installation path: /home/kaladin/Documents/git/qutip/qutip4/qutip; ================================================================================; Please cite QuTiP in your publication.; ================================================================================; For your convenience a bibtex reference can be easily generated using `qutip.cite()`; ```. Regarding to the tests being slow, I usually run only the test file related to the changes I do. For example, to run tests for qobj it suffices to use `pytest qutip/tests/test_qobj.py` from the command line. I then leave the CI do its job and run all the tests once I submit a pull request. I guess it is desirable to improve the speed of some tests, I do not think is a priority though. Also, it only took me 6 minutes in my local computer (i7-6700 and 16GB RAM)to run all the tests using your script. I wonder if there is something else going wrong. Hope this helps!",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1711#issuecomment-973002325
https://github.com/qutip/qutip/issues/1711#issuecomment-973002325:1430,Testability,test,tests,1430,"Hi, thank you for opening an issue. Unfortunately, I have not being able to reproduce it. Here is my `qutip.about()` output:; ```; QuTiP: Quantum Toolbox in Python; ================================; Copyright (c) QuTiP team 2011 and later.; Current admin team: Alexander Pitchford, Nathan Shammah, Shahnawaz Ahmed, Neill Lambert, Eric Giguère, Boxi Li, Jake Lishman and Simon Cross.; Board members: Daniel Burgarth, Robert Johansson, Anton F. Kockum, Franco Nori and Will Zeng.; Original developers: R. J. Johansson & P. D. Nation.; Previous lead developers: Chris Granade & A. Grimsmo.; Currently developed through wide collaboration. See https://github.com/qutip for details. QuTiP Version: 4.7.0.dev0+5c73300; Numpy Version: 1.21.2; Scipy Version: 1.7.1; Cython Version: 0.29.23; Matplotlib Version: 3.3.4; Python Version: 3.9.5; Number of CPUs: 4; BLAS Info: OPENBLAS; OPENMP Installed: False; INTEL MKL Ext: False; Platform Info: Linux (x86_64); Installation path: /home/kaladin/Documents/git/qutip/qutip4/qutip; ================================================================================; Please cite QuTiP in your publication.; ================================================================================; For your convenience a bibtex reference can be easily generated using `qutip.cite()`; ```. Regarding to the tests being slow, I usually run only the test file related to the changes I do. For example, to run tests for qobj it suffices to use `pytest qutip/tests/test_qobj.py` from the command line. I then leave the CI do its job and run all the tests once I submit a pull request. I guess it is desirable to improve the speed of some tests, I do not think is a priority though. Also, it only took me 6 minutes in my local computer (i7-6700 and 16GB RAM)to run all the tests using your script. I wonder if there is something else going wrong. Hope this helps!",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1711#issuecomment-973002325
https://github.com/qutip/qutip/issues/1711#issuecomment-973002325:1478,Testability,test,tests,1478,"Hi, thank you for opening an issue. Unfortunately, I have not being able to reproduce it. Here is my `qutip.about()` output:; ```; QuTiP: Quantum Toolbox in Python; ================================; Copyright (c) QuTiP team 2011 and later.; Current admin team: Alexander Pitchford, Nathan Shammah, Shahnawaz Ahmed, Neill Lambert, Eric Giguère, Boxi Li, Jake Lishman and Simon Cross.; Board members: Daniel Burgarth, Robert Johansson, Anton F. Kockum, Franco Nori and Will Zeng.; Original developers: R. J. Johansson & P. D. Nation.; Previous lead developers: Chris Granade & A. Grimsmo.; Currently developed through wide collaboration. See https://github.com/qutip for details. QuTiP Version: 4.7.0.dev0+5c73300; Numpy Version: 1.21.2; Scipy Version: 1.7.1; Cython Version: 0.29.23; Matplotlib Version: 3.3.4; Python Version: 3.9.5; Number of CPUs: 4; BLAS Info: OPENBLAS; OPENMP Installed: False; INTEL MKL Ext: False; Platform Info: Linux (x86_64); Installation path: /home/kaladin/Documents/git/qutip/qutip4/qutip; ================================================================================; Please cite QuTiP in your publication.; ================================================================================; For your convenience a bibtex reference can be easily generated using `qutip.cite()`; ```. Regarding to the tests being slow, I usually run only the test file related to the changes I do. For example, to run tests for qobj it suffices to use `pytest qutip/tests/test_qobj.py` from the command line. I then leave the CI do its job and run all the tests once I submit a pull request. I guess it is desirable to improve the speed of some tests, I do not think is a priority though. Also, it only took me 6 minutes in my local computer (i7-6700 and 16GB RAM)to run all the tests using your script. I wonder if there is something else going wrong. Hope this helps!",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1711#issuecomment-973002325
https://github.com/qutip/qutip/issues/1711#issuecomment-973002325:1568,Testability,test,tests,1568,"Hi, thank you for opening an issue. Unfortunately, I have not being able to reproduce it. Here is my `qutip.about()` output:; ```; QuTiP: Quantum Toolbox in Python; ================================; Copyright (c) QuTiP team 2011 and later.; Current admin team: Alexander Pitchford, Nathan Shammah, Shahnawaz Ahmed, Neill Lambert, Eric Giguère, Boxi Li, Jake Lishman and Simon Cross.; Board members: Daniel Burgarth, Robert Johansson, Anton F. Kockum, Franco Nori and Will Zeng.; Original developers: R. J. Johansson & P. D. Nation.; Previous lead developers: Chris Granade & A. Grimsmo.; Currently developed through wide collaboration. See https://github.com/qutip for details. QuTiP Version: 4.7.0.dev0+5c73300; Numpy Version: 1.21.2; Scipy Version: 1.7.1; Cython Version: 0.29.23; Matplotlib Version: 3.3.4; Python Version: 3.9.5; Number of CPUs: 4; BLAS Info: OPENBLAS; OPENMP Installed: False; INTEL MKL Ext: False; Platform Info: Linux (x86_64); Installation path: /home/kaladin/Documents/git/qutip/qutip4/qutip; ================================================================================; Please cite QuTiP in your publication.; ================================================================================; For your convenience a bibtex reference can be easily generated using `qutip.cite()`; ```. Regarding to the tests being slow, I usually run only the test file related to the changes I do. For example, to run tests for qobj it suffices to use `pytest qutip/tests/test_qobj.py` from the command line. I then leave the CI do its job and run all the tests once I submit a pull request. I guess it is desirable to improve the speed of some tests, I do not think is a priority though. Also, it only took me 6 minutes in my local computer (i7-6700 and 16GB RAM)to run all the tests using your script. I wonder if there is something else going wrong. Hope this helps!",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1711#issuecomment-973002325
https://github.com/qutip/qutip/issues/1711#issuecomment-973002325:1657,Testability,test,tests,1657,"Hi, thank you for opening an issue. Unfortunately, I have not being able to reproduce it. Here is my `qutip.about()` output:; ```; QuTiP: Quantum Toolbox in Python; ================================; Copyright (c) QuTiP team 2011 and later.; Current admin team: Alexander Pitchford, Nathan Shammah, Shahnawaz Ahmed, Neill Lambert, Eric Giguère, Boxi Li, Jake Lishman and Simon Cross.; Board members: Daniel Burgarth, Robert Johansson, Anton F. Kockum, Franco Nori and Will Zeng.; Original developers: R. J. Johansson & P. D. Nation.; Previous lead developers: Chris Granade & A. Grimsmo.; Currently developed through wide collaboration. See https://github.com/qutip for details. QuTiP Version: 4.7.0.dev0+5c73300; Numpy Version: 1.21.2; Scipy Version: 1.7.1; Cython Version: 0.29.23; Matplotlib Version: 3.3.4; Python Version: 3.9.5; Number of CPUs: 4; BLAS Info: OPENBLAS; OPENMP Installed: False; INTEL MKL Ext: False; Platform Info: Linux (x86_64); Installation path: /home/kaladin/Documents/git/qutip/qutip4/qutip; ================================================================================; Please cite QuTiP in your publication.; ================================================================================; For your convenience a bibtex reference can be easily generated using `qutip.cite()`; ```. Regarding to the tests being slow, I usually run only the test file related to the changes I do. For example, to run tests for qobj it suffices to use `pytest qutip/tests/test_qobj.py` from the command line. I then leave the CI do its job and run all the tests once I submit a pull request. I guess it is desirable to improve the speed of some tests, I do not think is a priority though. Also, it only took me 6 minutes in my local computer (i7-6700 and 16GB RAM)to run all the tests using your script. I wonder if there is something else going wrong. Hope this helps!",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1711#issuecomment-973002325
https://github.com/qutip/qutip/issues/1711#issuecomment-973002325:1791,Testability,test,tests,1791,"Hi, thank you for opening an issue. Unfortunately, I have not being able to reproduce it. Here is my `qutip.about()` output:; ```; QuTiP: Quantum Toolbox in Python; ================================; Copyright (c) QuTiP team 2011 and later.; Current admin team: Alexander Pitchford, Nathan Shammah, Shahnawaz Ahmed, Neill Lambert, Eric Giguère, Boxi Li, Jake Lishman and Simon Cross.; Board members: Daniel Burgarth, Robert Johansson, Anton F. Kockum, Franco Nori and Will Zeng.; Original developers: R. J. Johansson & P. D. Nation.; Previous lead developers: Chris Granade & A. Grimsmo.; Currently developed through wide collaboration. See https://github.com/qutip for details. QuTiP Version: 4.7.0.dev0+5c73300; Numpy Version: 1.21.2; Scipy Version: 1.7.1; Cython Version: 0.29.23; Matplotlib Version: 3.3.4; Python Version: 3.9.5; Number of CPUs: 4; BLAS Info: OPENBLAS; OPENMP Installed: False; INTEL MKL Ext: False; Platform Info: Linux (x86_64); Installation path: /home/kaladin/Documents/git/qutip/qutip4/qutip; ================================================================================; Please cite QuTiP in your publication.; ================================================================================; For your convenience a bibtex reference can be easily generated using `qutip.cite()`; ```. Regarding to the tests being slow, I usually run only the test file related to the changes I do. For example, to run tests for qobj it suffices to use `pytest qutip/tests/test_qobj.py` from the command line. I then leave the CI do its job and run all the tests once I submit a pull request. I guess it is desirable to improve the speed of some tests, I do not think is a priority though. Also, it only took me 6 minutes in my local computer (i7-6700 and 16GB RAM)to run all the tests using your script. I wonder if there is something else going wrong. Hope this helps!",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1711#issuecomment-973002325
https://github.com/qutip/qutip/issues/1711#issuecomment-975751156:160,Testability,test,tests,160,"Hey @AGaliciaMartinez !. Thanks a lot for the reply. I tried it again on windows, but it didn't work.; In the end I just redid the whole thing with WSL and the tests ran like the wind (12 minutes).; All tests have passed, so that's great. Also, thanks for the tip (running tests on the changed files). That will help a lot. [ Will close this issue now ]",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1711#issuecomment-975751156
https://github.com/qutip/qutip/issues/1711#issuecomment-975751156:203,Testability,test,tests,203,"Hey @AGaliciaMartinez !. Thanks a lot for the reply. I tried it again on windows, but it didn't work.; In the end I just redid the whole thing with WSL and the tests ran like the wind (12 minutes).; All tests have passed, so that's great. Also, thanks for the tip (running tests on the changed files). That will help a lot. [ Will close this issue now ]",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1711#issuecomment-975751156
https://github.com/qutip/qutip/issues/1711#issuecomment-975751156:273,Testability,test,tests,273,"Hey @AGaliciaMartinez !. Thanks a lot for the reply. I tried it again on windows, but it didn't work.; In the end I just redid the whole thing with WSL and the tests ran like the wind (12 minutes).; All tests have passed, so that's great. Also, thanks for the tip (running tests on the changed files). That will help a lot. [ Will close this issue now ]",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1711#issuecomment-975751156
https://github.com/qutip/qutip/issues/1714#issuecomment-972611843:62,Modifiability,enhance,enhancement,62,":thought_balloon: Can you follow [the rationale of the Python enhancement proposal 203](https://www.python.org/dev/peps/pep-0203/#rationale ""Proposal for augmented assignments"") (from 2000-07-13)?",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1714#issuecomment-972611843
https://github.com/qutip/qutip/issues/1714#issuecomment-972675136:720,Performance,perform,perform,720,"A rationale for adding the operators to the language isn't the same as a reason to use them in a particular programme. The compound assignment operators have different semantics, which may change the behaviour of the code. For example,; ```python; >>> import numpy as np; >>> a = np.ones(5, dtype=np.int32); >>> a = a + 2.5; >>> a; array([3.5, 3.5, 3.5, 3.5, 3.5]); >>> b = np.ones(5, dtype=np.int32); >>> b += 2.5; Traceback (most recent call last):; File ""<stdin>"", line 1, in <module>; numpy.core._exceptions.UFuncTypeError: Cannot cast ufunc 'add' output from dtype('float64') to dtype('int32') with casting rule 'same_kind'; ```; Swapping to in-place operations can also mean that certain operations that _need_ to perform a copy no longer do. This can mean that a function or class may start holding a reference to an object that something else holds a reference too, so it might get mutated out from underneath it. We already do use compound assignments in many places where we absolutely want the operation to be in-place. For immutable types on the left, such as `tuple` or `int`, the compound assignment has no difference (other than evaluating subscripts only once). Technical reasons for _not_ doing it aside, it's also just not a good idea to change existing code with no actual measured benefit from an engineering perspective. It just creates churn of the code, and any change can introduce a new bug.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1714#issuecomment-972675136
https://github.com/qutip/qutip/issues/1714#issuecomment-972730767:398,Modifiability,enhance,enhancement,398,"@elfring The first line of the PEP `There are two main reasons for adding this feature to Python: simplicity of expression, and support for in-place operations` and the `in-place operations` mentioned are part of why `a = a + 5` is not equivalent to `a += 5` (as Jake took the time to demonstrate). I'm closing the issue, but feel free to continue the discussion here & thank you for suggesting an enhancement to QuTiP and please feel free to suggest others.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1714#issuecomment-972730767
https://github.com/qutip/qutip/issues/1714#issuecomment-972730767:98,Usability,simpl,simplicity,98,"@elfring The first line of the PEP `There are two main reasons for adding this feature to Python: simplicity of expression, and support for in-place operations` and the `in-place operations` mentioned are part of why `a = a + 5` is not equivalent to `a += 5` (as Jake took the time to demonstrate). I'm closing the issue, but feel free to continue the discussion here & thank you for suggesting an enhancement to QuTiP and please feel free to suggest others.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1714#issuecomment-972730767
https://github.com/qutip/qutip/issues/1714#issuecomment-972776708:425,Performance,perform,perform,425,">The compound assignment operators have different semantics,. I suggest to reconsider such a wording a bit more. :thought_balloon: I imagine that the discussed assignment variants should logically be equivalent. >which may change the behaviour of the code. Some differences are documented. :thought_balloon: Would you find any “effects” on the software run time characteristics desirable?. >… certain operations that need to perform a copy no longer do. How would you like to identify (and eventually mark) the source code places where in-place data modifications should be excluded? :thinking:. >We already do use compound assignments in many places where we absolutely want the operation to be in-place. Thanks for such a background information. >For immutable types on the left, …, the compound assignment has no difference (other than evaluating subscripts only once). :thought_balloon: Can this information trigger any further development considerations?. >…, it's also just not a good idea to change existing code with no actual measured benefit from an engineering perspective. How do you think about to clarify evolving development views any further by corresponding test cases? :thinking:",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1714#issuecomment-972776708
https://github.com/qutip/qutip/issues/1714#issuecomment-972776708:187,Testability,log,logically,187,">The compound assignment operators have different semantics,. I suggest to reconsider such a wording a bit more. :thought_balloon: I imagine that the discussed assignment variants should logically be equivalent. >which may change the behaviour of the code. Some differences are documented. :thought_balloon: Would you find any “effects” on the software run time characteristics desirable?. >… certain operations that need to perform a copy no longer do. How would you like to identify (and eventually mark) the source code places where in-place data modifications should be excluded? :thinking:. >We already do use compound assignments in many places where we absolutely want the operation to be in-place. Thanks for such a background information. >For immutable types on the left, …, the compound assignment has no difference (other than evaluating subscripts only once). :thought_balloon: Can this information trigger any further development considerations?. >…, it's also just not a good idea to change existing code with no actual measured benefit from an engineering perspective. How do you think about to clarify evolving development views any further by corresponding test cases? :thinking:",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1714#issuecomment-972776708
https://github.com/qutip/qutip/issues/1714#issuecomment-972776708:1175,Testability,test,test,1175,">The compound assignment operators have different semantics,. I suggest to reconsider such a wording a bit more. :thought_balloon: I imagine that the discussed assignment variants should logically be equivalent. >which may change the behaviour of the code. Some differences are documented. :thought_balloon: Would you find any “effects” on the software run time characteristics desirable?. >… certain operations that need to perform a copy no longer do. How would you like to identify (and eventually mark) the source code places where in-place data modifications should be excluded? :thinking:. >We already do use compound assignments in many places where we absolutely want the operation to be in-place. Thanks for such a background information. >For immutable types on the left, …, the compound assignment has no difference (other than evaluating subscripts only once). :thought_balloon: Can this information trigger any further development considerations?. >…, it's also just not a good idea to change existing code with no actual measured benefit from an engineering perspective. How do you think about to clarify evolving development views any further by corresponding test cases? :thinking:",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1714#issuecomment-972776708
https://github.com/qutip/qutip/issues/1714#issuecomment-972782201:305,Availability,error,errors,305,"In general, if you think this is something that is worthwhile, we'd ask you to try it yourself, and then show us memory-usage and execution-time benchmark results showing that such a change is warranted. I've given you a few reasons why this sort of ""programming by script"" can be difficult and introduce errors, and why there may be more concerns than you might have thought about. If you can show that such a change has actual tangible benefits with proof, then we would be willing to consider a limited change, but you also need to have verified everything yourself. If it looks like you've done it indiscriminately by script, we would reject the PR, because it would require one of us to go through ourselves line-by-line and check everything, which is something the PR author is meant to do themselves first. We (mostly) do this for free, and we only have a finite amount of time.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1714#issuecomment-972782201
https://github.com/qutip/qutip/issues/1714#issuecomment-972782201:145,Testability,benchmark,benchmark,145,"In general, if you think this is something that is worthwhile, we'd ask you to try it yourself, and then show us memory-usage and execution-time benchmark results showing that such a change is warranted. I've given you a few reasons why this sort of ""programming by script"" can be difficult and introduce errors, and why there may be more concerns than you might have thought about. If you can show that such a change has actual tangible benefits with proof, then we would be willing to consider a limited change, but you also need to have verified everything yourself. If it looks like you've done it indiscriminately by script, we would reject the PR, because it would require one of us to go through ourselves line-by-line and check everything, which is something the PR author is meant to do themselves first. We (mostly) do this for free, and we only have a finite amount of time.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1714#issuecomment-972782201
https://github.com/qutip/qutip/issues/1714#issuecomment-972782553:178,Modifiability,evolve,evolve,178,>… are part of why `a = a + 5` is not equivalent to `a += 5` …. Different development views are involved here for the interpretation of “equivalence”.; How will the design goals evolve further for selected software areas? :thinking:,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1714#issuecomment-972782553
https://github.com/qutip/qutip/issues/1714#issuecomment-974625872:6089,Availability,error,error,6089,"ffset(pulse); ; @@ -1103,7 +1103,7 @@ class PulseGenCrab(PulseGen):; "", hence ignored."".format(self.guess_pulse_action)); ; def guess_pulse_add(self, pulse):; - pulse = pulse + self.guess_pulse; + pulse += self.guess_pulse; return pulse; ; def guess_pulse_modulate(self, pulse):; diff --git a/qutip/cy/codegen.py b/qutip/cy/codegen.py; index e01d57a2..e0964a47 100644; --- a/qutip/cy/codegen.py; +++ b/qutip/cy/codegen.py; @@ -396,7 +396,7 @@ def cython_col_spmv():; row_start = ptr[row]; row_end = ptr[row+1]; for jj in range(row_start,row_end):; - dot = dot + data[jj] * vec[idx[jj]]; + dot += data[jj] * vec[idx[jj]]; out[row] = dot; """"""]; ; diff --git a/qutip/essolve.py b/qutip/essolve.py; index 7320b9ab..304e6ffe 100644; --- a/qutip/essolve.py; +++ b/qutip/essolve.py; @@ -140,7 +140,7 @@ def ode2es(L, rho0):; # check initial state; if isket(rho0):; # Got a wave function as initial state: convert to density matrix.; - rho0 = rho0 * rho0.dag(); + rho0 *= rho0.dag(); # check if state is below error threshold; if abs(rho0.full()).sum() < 1e-10 + 1e-24:; # enforce zero operator; diff --git a/qutip/floquet.py b/qutip/floquet.py; index 92cca493..8640941e 100644; --- a/qutip/floquet.py; +++ b/qutip/floquet.py; @@ -140,7 +140,7 @@ def floquet_modes_t(f_modes_0, f_energies, t, H, T, args=None,; ; """"""; # find t in [0,T] such that t_orig = t + n * T for integer n; - t = t - int(t / T) * T; + t -= int(t / T) * T; f_modes_t = []; ; # get the unitary propagator from 0 to t; diff --git a/qutip/graph.py b/qutip/graph.py; index 8fb0b509..2c9b2293 100644; --- a/qutip/graph.py; +++ b/qutip/graph.py; @@ -143,7 +143,7 @@ def reverse_cuthill_mckee(A, sym=False):; raise TypeError('Input must be CSC or CSR sparse matrix.'); nrows = A.shape[0]; if not sym:; - A = A + A.transpose(); + A += A.transpose(); return _reverse_cuthill_mckee(A.indices, A.indptr, nrows); ; ; diff --git a/qutip/lattice.py b/qutip/lattice.py; index e3937691..7a89b641 100644; --- a/qutip/lattice.py; +++ b/qutip/lattice.py; ",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1714#issuecomment-974625872
https://github.com/qutip/qutip/issues/1714#issuecomment-974625872:12665,Availability,error,error,12665,"rtcol < col_scale:; - A.indices = A.indices + insertcol*ncolin; + A.indices += insertcol*ncolin; else:; raise ValueError(""insertcol must be >= 0 and < col_scale""); ; diff --git a/qutip/orbital.py b/qutip/orbital.py; index bb12b71b..7432144d 100644; --- a/qutip/orbital.py; +++ b/qutip/orbital.py; @@ -59,7 +59,7 @@ def orbital(theta, phi, *args):; np.ones((np.size(phi), np.size(theta)),; dtype=complex) * SPlm[1]; for m in range(-l, 0):; - psi = psi + (fac * kf[l - m, 0]) * \; + psi += (fac * kf[l - m, 0]) * \; np.array([np.exp(1.0j * 1 * phi)]).T * \; np.ones((np.size(phi), np.size(theta)), dtype=complex) * \; SPlm[abs(m)]; diff --git a/qutip/pdpsolve.py b/qutip/pdpsolve.py; index 6e915792..77a7af1b 100644; --- a/qutip/pdpsolve.py; +++ b/qutip/pdpsolve.py; @@ -396,7 +396,7 @@ def _ssepdpsolve_generic(sso, options, progress_bar):; for n in range(len(data.times))]; ; # average; - data.expect = data.expect / nt; + data.expect /= nt; ; # standard error; if nt > 1:; @@ -525,7 +525,7 @@ def _smepdpsolve_generic(sso, options, progress_bar):; for n in range(len(data.times))]; ; # average; - data.expect = data.expect / sso.ntraj; + data.expect /= sso.ntraj; ; # standard error; if nt > 1:; diff --git a/qutip/piqs.py b/qutip/piqs.py; index 83144418..eace5620 100644; --- a/qutip/piqs.py; +++ b/qutip/piqs.py; @@ -193,7 +193,7 @@ def dicke_blocks(rho):; start_m = block_position; end_m = block_position + block_size; square_block = rho[start_m:end_m, start_m:end_m]; - block_position = block_position + block_size; + block_position += block_size; square_blocks.append(square_block); ; return square_blocks; @@ -233,12 +233,12 @@ def dicke_blocks_full(rho):; start_m = block_position; end_m = block_position + block_size; square_block = rho[start_m:end_m, start_m:end_m]; - block_position = block_position + block_size; + block_position += block_size; j = N / 2 - k; djn = state_degeneracy(N, j); for block_counter in range(0, djn):; full_blocks.append(square_block / djn) # preserve trace; - k =",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1714#issuecomment-974625872
https://github.com/qutip/qutip/issues/1714#issuecomment-974625872:12888,Availability,error,error,12888,"tal.py b/qutip/orbital.py; index bb12b71b..7432144d 100644; --- a/qutip/orbital.py; +++ b/qutip/orbital.py; @@ -59,7 +59,7 @@ def orbital(theta, phi, *args):; np.ones((np.size(phi), np.size(theta)),; dtype=complex) * SPlm[1]; for m in range(-l, 0):; - psi = psi + (fac * kf[l - m, 0]) * \; + psi += (fac * kf[l - m, 0]) * \; np.array([np.exp(1.0j * 1 * phi)]).T * \; np.ones((np.size(phi), np.size(theta)), dtype=complex) * \; SPlm[abs(m)]; diff --git a/qutip/pdpsolve.py b/qutip/pdpsolve.py; index 6e915792..77a7af1b 100644; --- a/qutip/pdpsolve.py; +++ b/qutip/pdpsolve.py; @@ -396,7 +396,7 @@ def _ssepdpsolve_generic(sso, options, progress_bar):; for n in range(len(data.times))]; ; # average; - data.expect = data.expect / nt; + data.expect /= nt; ; # standard error; if nt > 1:; @@ -525,7 +525,7 @@ def _smepdpsolve_generic(sso, options, progress_bar):; for n in range(len(data.times))]; ; # average; - data.expect = data.expect / sso.ntraj; + data.expect /= sso.ntraj; ; # standard error; if nt > 1:; diff --git a/qutip/piqs.py b/qutip/piqs.py; index 83144418..eace5620 100644; --- a/qutip/piqs.py; +++ b/qutip/piqs.py; @@ -193,7 +193,7 @@ def dicke_blocks(rho):; start_m = block_position; end_m = block_position + block_size; square_block = rho[start_m:end_m, start_m:end_m]; - block_position = block_position + block_size; + block_position += block_size; square_blocks.append(square_block); ; return square_blocks; @@ -233,12 +233,12 @@ def dicke_blocks_full(rho):; start_m = block_position; end_m = block_position + block_size; square_block = rho[start_m:end_m, start_m:end_m]; - block_position = block_position + block_size; + block_position += block_size; j = N / 2 - k; djn = state_degeneracy(N, j); for block_counter in range(0, djn):; full_blocks.append(square_block / djn) # preserve trace; - k = k + 1; + k += 1; return full_blocks; ; ; @@ -906,7 +906,7 @@ def jspin(N, op=None, basis=""dicke""):; jp_operator[s, s + 1] = ap(j, m - 1); if (s - 1) in range(0, nds):; jm_operator[s, s - 1",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1714#issuecomment-974625872
https://github.com/qutip/qutip/issues/1714#issuecomment-974625872:21128,Availability,error,error,21128,"te(); @@ -901,7 +901,7 @@ def _steadystate_power(L, ss_args):; trow = v[::rhoss.shape[0]+1]; data = v / np.sum(trow); else:; - data = data / la.norm(v); + data /= la.norm(v); ; data = dense2D_to_fastcsr_fmode(vec2mat(data),; rhoss.shape[0],; diff --git a/qutip/stochastic.py b/qutip/stochastic.py; index 49786aca..b9866527 100644; --- a/qutip/stochastic.py; +++ b/qutip/stochastic.py; @@ -1146,7 +1146,7 @@ def general_stochastic(state0, times, d1, d2, e_ops=[], m_ops=[],; if sso.dW_factors is None:; sso.dW_factors = [1.] * len(sso.m_ops); elif len(sso.dW_factors) == 1:; - sso.dW_factors = sso.dW_factors * len(sso.m_ops); + sso.dW_factors *= len(sso.m_ops); elif len(sso.dW_factors) != len(sso.m_ops):; raise ValueError(""The number of dW_factors must fit"" +; "" the number of m_ops.""); @@ -1318,7 +1318,7 @@ def _sesolve_generic(sso, options, progress_bar):; res.states = res.avg_states = avg_states_list; ; # average; - res.expect = res.expect / nt; + res.expect /= nt; ; # standard error; if nt > 1:; diff --git a/qutip/subsystem_apply.py b/qutip/subsystem_apply.py; index ebd81a1b..110f6cca 100644; --- a/qutip/subsystem_apply.py; +++ b/qutip/subsystem_apply.py; @@ -126,7 +126,7 @@ def _one_subsystem_apply(state, channel, idx):; for mul_idx in range(idx):; # print mul_idx; # print subs_dim_ar[mul_idx]; - n_blks = n_blks * subs_dim_ar[mul_idx][0]; + n_blks *= subs_dim_ar[mul_idx][0]; ; blk_sz = state.shape[0] // n_blks; # Apply channel to top subsystem of each block in matrix; @@ -258,5 +258,5 @@ def _subsystem_apply_reference(state, channel, mask):; else qeye(state.dims[0][j]); for j in range(len(state.dims[0]))]; full_oper = tensor(list(map(Qobj, op_iter_list))); - rho_out = rho_out + full_oper * state * full_oper.dag(); + rho_out += full_oper * state * full_oper.dag(); return Qobj(rho_out); diff --git a/qutip/superoperator.py b/qutip/superoperator.py; index dacc0e1e..8d099484 100644; --- a/qutip/superoperator.py; +++ b/qutip/superoperator.py; @@ -112,19 +112,19 @@ def liouvill",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1714#issuecomment-974625872
https://github.com/qutip/qutip/issues/1714#issuecomment-974625872:21697,Availability,mask,mask,21697,"None:; sso.dW_factors = [1.] * len(sso.m_ops); elif len(sso.dW_factors) == 1:; - sso.dW_factors = sso.dW_factors * len(sso.m_ops); + sso.dW_factors *= len(sso.m_ops); elif len(sso.dW_factors) != len(sso.m_ops):; raise ValueError(""The number of dW_factors must fit"" +; "" the number of m_ops.""); @@ -1318,7 +1318,7 @@ def _sesolve_generic(sso, options, progress_bar):; res.states = res.avg_states = avg_states_list; ; # average; - res.expect = res.expect / nt; + res.expect /= nt; ; # standard error; if nt > 1:; diff --git a/qutip/subsystem_apply.py b/qutip/subsystem_apply.py; index ebd81a1b..110f6cca 100644; --- a/qutip/subsystem_apply.py; +++ b/qutip/subsystem_apply.py; @@ -126,7 +126,7 @@ def _one_subsystem_apply(state, channel, idx):; for mul_idx in range(idx):; # print mul_idx; # print subs_dim_ar[mul_idx]; - n_blks = n_blks * subs_dim_ar[mul_idx][0]; + n_blks *= subs_dim_ar[mul_idx][0]; ; blk_sz = state.shape[0] // n_blks; # Apply channel to top subsystem of each block in matrix; @@ -258,5 +258,5 @@ def _subsystem_apply_reference(state, channel, mask):; else qeye(state.dims[0][j]); for j in range(len(state.dims[0]))]; full_oper = tensor(list(map(Qobj, op_iter_list))); - rho_out = rho_out + full_oper * state * full_oper.dag(); + rho_out += full_oper * state * full_oper.dag(); return Qobj(rho_out); diff --git a/qutip/superoperator.py b/qutip/superoperator.py; index dacc0e1e..8d099484 100644; --- a/qutip/superoperator.py; +++ b/qutip/superoperator.py; @@ -112,19 +112,19 @@ def liouvillian(H, c_ops=[], data_only=False, chi=None):; c_ = c_op; ; if c_.issuper:; - data = data + c_.data; + data += c_.data; else:; cd = c_.data.H; c = c_.data; if chi:; - data = data + np.exp(1j * chi[idx]) * \; + data += np.exp(1j * chi[idx]) * \; zcsr_kron(c.conj(), c); else:; - data = data + zcsr_kron(c.conj(), c); + data += zcsr_kron(c.conj(), c); cdc = cd * c; cdct = cdc.T; - data = data - 0.5 * zcsr_kron(spI, cdc); - data = data - 0.5 * zcsr_kron(cdct, spI); + data -= 0.5 * zcsr_kron(spI, ",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1714#issuecomment-974625872
https://github.com/qutip/qutip/issues/1714#issuecomment-974625872:20094,Energy Efficiency,power,power,20094," * all_state[k].dag(); + PsipreX += X * all_state[j] * all_state[k].dag(); ; A = a + a.dag(); L = ((-spre(A * PsipreX)) + (sprepost(A, PsipreX)); diff --git a/qutip/states.py b/qutip/states.py; index 10ac9e32..075eb777 100644; --- a/qutip/states.py; +++ b/qutip/states.py; @@ -405,7 +405,7 @@ shape = [5, 5], type = oper, isHerm = True; if method == 'operator':; beta = np.log(1.0 / n + 1.0); diags = np.exp(-beta * i); - diags = diags / np.sum(diags); + diags /= np.sum(diags); # populates diagonal terms using truncated operator expression; rm = sp.spdiags(diags, 0, N, N, format='csr'); elif method == 'analytic':; diff --git a/qutip/steadystate.py b/qutip/steadystate.py; index 1f60f942..680b04c7 100644; --- a/qutip/steadystate.py; +++ b/qutip/steadystate.py; @@ -873,7 +873,7 @@ def _steadystate_power(L, ss_args):; check)); if check < 0:; raise Exception(""Breakdown in {}"".format(ss_args['method'])); - v = v / la.norm(v, np.inf); + v /= la.norm(v, np.inf); it += 1; if ss_args['method'] == 'power' and ss_args['solver'] == 'mkl':; lu.delete(); @@ -901,7 +901,7 @@ def _steadystate_power(L, ss_args):; trow = v[::rhoss.shape[0]+1]; data = v / np.sum(trow); else:; - data = data / la.norm(v); + data /= la.norm(v); ; data = dense2D_to_fastcsr_fmode(vec2mat(data),; rhoss.shape[0],; diff --git a/qutip/stochastic.py b/qutip/stochastic.py; index 49786aca..b9866527 100644; --- a/qutip/stochastic.py; +++ b/qutip/stochastic.py; @@ -1146,7 +1146,7 @@ def general_stochastic(state0, times, d1, d2, e_ops=[], m_ops=[],; if sso.dW_factors is None:; sso.dW_factors = [1.] * len(sso.m_ops); elif len(sso.dW_factors) == 1:; - sso.dW_factors = sso.dW_factors * len(sso.m_ops); + sso.dW_factors *= len(sso.m_ops); elif len(sso.dW_factors) != len(sso.m_ops):; raise ValueError(""The number of dW_factors must fit"" +; "" the number of m_ops.""); @@ -1318,7 +1318,7 @@ def _sesolve_generic(sso, options, progress_bar):; res.states = res.avg_states = avg_states_list; ; # average; - res.expect = res.expect / nt; +",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1714#issuecomment-974625872
https://github.com/qutip/qutip/issues/1714#issuecomment-974625872:2942,Safety,avoid,avoids,2942," n = dg.data.nnz; @@ -1177,9 +1177,9 @@ class Dynamics(object):; dg = self._drift_dyn_gen; for j in range(self._num_ctrls):; if self.time_depend_ctrl_dyn_gen:; - dg = dg + self.ctrl_amps[k, j]*self._ctrl_dyn_gen[k, j]; + dg += self.ctrl_amps[k, j]*self._ctrl_dyn_gen[k, j]; else:; - dg = dg + self.ctrl_amps[k, j]*self._ctrl_dyn_gen[j]; + dg += self.ctrl_amps[k, j]*self._ctrl_dyn_gen[j]; ; self._dyn_gen[k] = dg; if self.cache_phased_dyn_gen:; diff --git a/qutip/control/fidcomp.py b/qutip/control/fidcomp.py; index bb7a67ef..afa898ad 100644; --- a/qutip/control/fidcomp.py; +++ b/qutip/control/fidcomp.py; @@ -729,7 +729,7 @@ class FidCompTraceDiffApprox(FidCompTraceDiff):; if dyn.oper_dtype == Qobj:; evo_final_eps = fwd_evo*prop_eps; if k+1 < n_ts:; - evo_final_eps = evo_final_eps*dyn._onwd_evo[k+1]; + evo_final_eps *=dyn._onwd_evo[k+1]; evo_f_diff_eps = dyn._target - evo_final_eps; # Note that the value should have not imagnary part, so; # using np.real, just avoids the complex casting warning; diff --git a/qutip/control/pulsegen.py b/qutip/control/pulsegen.py; index ec5ac177..418da1ff 100644; --- a/qutip/control/pulsegen.py; +++ b/qutip/control/pulsegen.py; @@ -283,7 +283,7 @@ class PulseGen(object):; if ramping_pulse is None:; ramping_pulse = self.ramping_pulse; if ramping_pulse is not None:; - pulse = pulse*ramping_pulse; + pulse *= ramping_pulse; ; return pulse; ; @@ -379,7 +379,7 @@ class PulseGenRndFourier(PulseGen):; wl = []; while wavelen > min_wavelen:; wl.append(wavelen); - wavelen = wavelen/2.0; + wavelen /= 2.0; ; num_comp_waves = len(wl); amp_scale = np.sqrt(8)*self.scaling / float(num_comp_waves); @@ -650,7 +650,7 @@ class PulseGenLinear(PulseGen):; for k in range(self.num_tslots):; y = self.gradient*t + self.start_val; pulse[k] = self.scaling*y; - t = t + self.tau[k]; + t += self.tau[k]; ; return self._apply_bounds_and_offset(pulse); ; @@ -745,7 +745,7 @@ class PulseGenSine(PulseGenPeriodic):; for k in range(self.num_tslots):; phase = 2*np.pi*self.freq*t +",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1714#issuecomment-974625872
https://github.com/qutip/qutip/issues/1714#issuecomment-974625872:19468,Testability,log,log,19468,"rcsolve.py b/qutip/rcsolve.py; index 4d537648..6af6cd1b 100644; --- a/qutip/rcsolve.py; +++ b/qutip/rcsolve.py; @@ -104,12 +104,11 @@ def rcsolve(Hsys, psi0, tlist, e_ops, Q, wc, alpha, N, w_th, sparse=False,; (2 * w_th)))) * A); eta = (0.5 * np.pi * gamma *; (all_energy[j] - all_energy[k]) * A); - PsipreX = PsipreX + X * all_state[j] * all_state[k].dag(); - PsipreEta = PsipreEta + (eta * all_state[j]; - * all_state[k].dag()); + PsipreX += X * all_state[j] * all_state[k].dag(); + PsipreEta += eta * all_state[j] * all_state[k].dag(); else:; X = 0.5 * np.pi * gamma * A * 2 * w_th; - PsipreX = PsipreX + X * all_state[j] * all_state[k].dag(); + PsipreX += X * all_state[j] * all_state[k].dag(); ; A = a + a.dag(); L = ((-spre(A * PsipreX)) + (sprepost(A, PsipreX)); diff --git a/qutip/states.py b/qutip/states.py; index 10ac9e32..075eb777 100644; --- a/qutip/states.py; +++ b/qutip/states.py; @@ -405,7 +405,7 @@ shape = [5, 5], type = oper, isHerm = True; if method == 'operator':; beta = np.log(1.0 / n + 1.0); diags = np.exp(-beta * i); - diags = diags / np.sum(diags); + diags /= np.sum(diags); # populates diagonal terms using truncated operator expression; rm = sp.spdiags(diags, 0, N, N, format='csr'); elif method == 'analytic':; diff --git a/qutip/steadystate.py b/qutip/steadystate.py; index 1f60f942..680b04c7 100644; --- a/qutip/steadystate.py; +++ b/qutip/steadystate.py; @@ -873,7 +873,7 @@ def _steadystate_power(L, ss_args):; check)); if check < 0:; raise Exception(""Breakdown in {}"".format(ss_args['method'])); - v = v / la.norm(v, np.inf); + v /= la.norm(v, np.inf); it += 1; if ss_args['method'] == 'power' and ss_args['solver'] == 'mkl':; lu.delete(); @@ -901,7 +901,7 @@ def _steadystate_power(L, ss_args):; trow = v[::rhoss.shape[0]+1]; data = v / np.sum(trow); else:; - data = data / la.norm(v); + data /= la.norm(v); ; data = dense2D_to_fastcsr_fmode(vec2mat(data),; rhoss.shape[0],; diff --git a/qutip/stochastic.py b/qutip/stochastic.py; index 49786aca..b9866527 100644;",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1714#issuecomment-974625872
https://github.com/qutip/qutip/issues/1714#issuecomment-974625872:22729,Testability,test,tests,22729,"):; else qeye(state.dims[0][j]); for j in range(len(state.dims[0]))]; full_oper = tensor(list(map(Qobj, op_iter_list))); - rho_out = rho_out + full_oper * state * full_oper.dag(); + rho_out += full_oper * state * full_oper.dag(); return Qobj(rho_out); diff --git a/qutip/superoperator.py b/qutip/superoperator.py; index dacc0e1e..8d099484 100644; --- a/qutip/superoperator.py; +++ b/qutip/superoperator.py; @@ -112,19 +112,19 @@ def liouvillian(H, c_ops=[], data_only=False, chi=None):; c_ = c_op; ; if c_.issuper:; - data = data + c_.data; + data += c_.data; else:; cd = c_.data.H; c = c_.data; if chi:; - data = data + np.exp(1j * chi[idx]) * \; + data += np.exp(1j * chi[idx]) * \; zcsr_kron(c.conj(), c); else:; - data = data + zcsr_kron(c.conj(), c); + data += zcsr_kron(c.conj(), c); cdc = cd * c; cdct = cdc.T; - data = data - 0.5 * zcsr_kron(spI, cdc); - data = data - 0.5 * zcsr_kron(cdct, spI); + data -= 0.5 * zcsr_kron(spI, cdc); + data -= 0.5 * zcsr_kron(cdct, spI); ; if not td:; if data_only:; diff --git a/qutip/tests/test_expect.py b/qutip/tests/test_expect.py; index 45568110..17491981 100644; --- a/qutip/tests/test_expect.py; +++ b/qutip/tests/test_expect.py; @@ -120,7 +120,7 @@ def test_equivalent_to_matrix_element(hermitian):; state = qutip.rand_ket(dimension, 0.3); op = qutip.rand_herm(dimension, 0.2); if not hermitian:; - op = op + 1j*qutip.rand_herm(dimension, 0.1); + op += 1j * qutip.rand_herm(dimension, 0.1); expected = (state.dag() * op * state).data[0, 0]; assert abs(qutip.expect(op, state) - expected) < 1e-14; ; diff --git a/qutip/tests/test_fileio.py b/qutip/tests/test_fileio.py; index b02e8cb9..db237a41 100644; --- a/qutip/tests/test_fileio.py; +++ b/qutip/tests/test_fileio.py; @@ -22,7 +22,7 @@ class Test_file_data_store_file_data_read:; def case(self, filename, kwargs):; data = 1 - 2*np.random.rand(_dimension, _dimension); if kwargs.get('numtype', 'complex') == 'complex':; - data = data * (0.5*0.5j); + data *= 0.5 * 0.5j; qutip.file_data_store(filena",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1714#issuecomment-974625872
https://github.com/qutip/qutip/issues/1714#issuecomment-974625872:22758,Testability,test,tests,22758,"ms[0]))]; full_oper = tensor(list(map(Qobj, op_iter_list))); - rho_out = rho_out + full_oper * state * full_oper.dag(); + rho_out += full_oper * state * full_oper.dag(); return Qobj(rho_out); diff --git a/qutip/superoperator.py b/qutip/superoperator.py; index dacc0e1e..8d099484 100644; --- a/qutip/superoperator.py; +++ b/qutip/superoperator.py; @@ -112,19 +112,19 @@ def liouvillian(H, c_ops=[], data_only=False, chi=None):; c_ = c_op; ; if c_.issuper:; - data = data + c_.data; + data += c_.data; else:; cd = c_.data.H; c = c_.data; if chi:; - data = data + np.exp(1j * chi[idx]) * \; + data += np.exp(1j * chi[idx]) * \; zcsr_kron(c.conj(), c); else:; - data = data + zcsr_kron(c.conj(), c); + data += zcsr_kron(c.conj(), c); cdc = cd * c; cdct = cdc.T; - data = data - 0.5 * zcsr_kron(spI, cdc); - data = data - 0.5 * zcsr_kron(cdct, spI); + data -= 0.5 * zcsr_kron(spI, cdc); + data -= 0.5 * zcsr_kron(cdct, spI); ; if not td:; if data_only:; diff --git a/qutip/tests/test_expect.py b/qutip/tests/test_expect.py; index 45568110..17491981 100644; --- a/qutip/tests/test_expect.py; +++ b/qutip/tests/test_expect.py; @@ -120,7 +120,7 @@ def test_equivalent_to_matrix_element(hermitian):; state = qutip.rand_ket(dimension, 0.3); op = qutip.rand_herm(dimension, 0.2); if not hermitian:; - op = op + 1j*qutip.rand_herm(dimension, 0.1); + op += 1j * qutip.rand_herm(dimension, 0.1); expected = (state.dag() * op * state).data[0, 0]; assert abs(qutip.expect(op, state) - expected) < 1e-14; ; diff --git a/qutip/tests/test_fileio.py b/qutip/tests/test_fileio.py; index b02e8cb9..db237a41 100644; --- a/qutip/tests/test_fileio.py; +++ b/qutip/tests/test_fileio.py; @@ -22,7 +22,7 @@ class Test_file_data_store_file_data_read:; def case(self, filename, kwargs):; data = 1 - 2*np.random.rand(_dimension, _dimension); if kwargs.get('numtype', 'complex') == 'complex':; - data = data * (0.5*0.5j); + data *= 0.5 * 0.5j; qutip.file_data_store(filename, data, **kwargs); out = qutip.file_data_read(filename); np",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1714#issuecomment-974625872
https://github.com/qutip/qutip/issues/1714#issuecomment-974625872:22825,Testability,test,tests,22825,"); - rho_out = rho_out + full_oper * state * full_oper.dag(); + rho_out += full_oper * state * full_oper.dag(); return Qobj(rho_out); diff --git a/qutip/superoperator.py b/qutip/superoperator.py; index dacc0e1e..8d099484 100644; --- a/qutip/superoperator.py; +++ b/qutip/superoperator.py; @@ -112,19 +112,19 @@ def liouvillian(H, c_ops=[], data_only=False, chi=None):; c_ = c_op; ; if c_.issuper:; - data = data + c_.data; + data += c_.data; else:; cd = c_.data.H; c = c_.data; if chi:; - data = data + np.exp(1j * chi[idx]) * \; + data += np.exp(1j * chi[idx]) * \; zcsr_kron(c.conj(), c); else:; - data = data + zcsr_kron(c.conj(), c); + data += zcsr_kron(c.conj(), c); cdc = cd * c; cdct = cdc.T; - data = data - 0.5 * zcsr_kron(spI, cdc); - data = data - 0.5 * zcsr_kron(cdct, spI); + data -= 0.5 * zcsr_kron(spI, cdc); + data -= 0.5 * zcsr_kron(cdct, spI); ; if not td:; if data_only:; diff --git a/qutip/tests/test_expect.py b/qutip/tests/test_expect.py; index 45568110..17491981 100644; --- a/qutip/tests/test_expect.py; +++ b/qutip/tests/test_expect.py; @@ -120,7 +120,7 @@ def test_equivalent_to_matrix_element(hermitian):; state = qutip.rand_ket(dimension, 0.3); op = qutip.rand_herm(dimension, 0.2); if not hermitian:; - op = op + 1j*qutip.rand_herm(dimension, 0.1); + op += 1j * qutip.rand_herm(dimension, 0.1); expected = (state.dag() * op * state).data[0, 0]; assert abs(qutip.expect(op, state) - expected) < 1e-14; ; diff --git a/qutip/tests/test_fileio.py b/qutip/tests/test_fileio.py; index b02e8cb9..db237a41 100644; --- a/qutip/tests/test_fileio.py; +++ b/qutip/tests/test_fileio.py; @@ -22,7 +22,7 @@ class Test_file_data_store_file_data_read:; def case(self, filename, kwargs):; data = 1 - 2*np.random.rand(_dimension, _dimension); if kwargs.get('numtype', 'complex') == 'complex':; - data = data * (0.5*0.5j); + data *= 0.5 * 0.5j; qutip.file_data_store(filename, data, **kwargs); out = qutip.file_data_read(filename); np.testing.assert_allclose(data, out, atol=1e-8); diff --git",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1714#issuecomment-974625872
https://github.com/qutip/qutip/issues/1714#issuecomment-974625872:22859,Testability,test,tests,22859,"e * full_oper.dag(); + rho_out += full_oper * state * full_oper.dag(); return Qobj(rho_out); diff --git a/qutip/superoperator.py b/qutip/superoperator.py; index dacc0e1e..8d099484 100644; --- a/qutip/superoperator.py; +++ b/qutip/superoperator.py; @@ -112,19 +112,19 @@ def liouvillian(H, c_ops=[], data_only=False, chi=None):; c_ = c_op; ; if c_.issuper:; - data = data + c_.data; + data += c_.data; else:; cd = c_.data.H; c = c_.data; if chi:; - data = data + np.exp(1j * chi[idx]) * \; + data += np.exp(1j * chi[idx]) * \; zcsr_kron(c.conj(), c); else:; - data = data + zcsr_kron(c.conj(), c); + data += zcsr_kron(c.conj(), c); cdc = cd * c; cdct = cdc.T; - data = data - 0.5 * zcsr_kron(spI, cdc); - data = data - 0.5 * zcsr_kron(cdct, spI); + data -= 0.5 * zcsr_kron(spI, cdc); + data -= 0.5 * zcsr_kron(cdct, spI); ; if not td:; if data_only:; diff --git a/qutip/tests/test_expect.py b/qutip/tests/test_expect.py; index 45568110..17491981 100644; --- a/qutip/tests/test_expect.py; +++ b/qutip/tests/test_expect.py; @@ -120,7 +120,7 @@ def test_equivalent_to_matrix_element(hermitian):; state = qutip.rand_ket(dimension, 0.3); op = qutip.rand_herm(dimension, 0.2); if not hermitian:; - op = op + 1j*qutip.rand_herm(dimension, 0.1); + op += 1j * qutip.rand_herm(dimension, 0.1); expected = (state.dag() * op * state).data[0, 0]; assert abs(qutip.expect(op, state) - expected) < 1e-14; ; diff --git a/qutip/tests/test_fileio.py b/qutip/tests/test_fileio.py; index b02e8cb9..db237a41 100644; --- a/qutip/tests/test_fileio.py; +++ b/qutip/tests/test_fileio.py; @@ -22,7 +22,7 @@ class Test_file_data_store_file_data_read:; def case(self, filename, kwargs):; data = 1 - 2*np.random.rand(_dimension, _dimension); if kwargs.get('numtype', 'complex') == 'complex':; - data = data * (0.5*0.5j); + data *= 0.5 * 0.5j; qutip.file_data_store(filename, data, **kwargs); out = qutip.file_data_read(filename); np.testing.assert_allclose(data, out, atol=1e-8); diff --git a/qutip/tests/test_gates.py b/qutip/tes",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1714#issuecomment-974625872
https://github.com/qutip/qutip/issues/1714#issuecomment-974625872:23193,Testability,assert,assert,23193,"op; ; if c_.issuper:; - data = data + c_.data; + data += c_.data; else:; cd = c_.data.H; c = c_.data; if chi:; - data = data + np.exp(1j * chi[idx]) * \; + data += np.exp(1j * chi[idx]) * \; zcsr_kron(c.conj(), c); else:; - data = data + zcsr_kron(c.conj(), c); + data += zcsr_kron(c.conj(), c); cdc = cd * c; cdct = cdc.T; - data = data - 0.5 * zcsr_kron(spI, cdc); - data = data - 0.5 * zcsr_kron(cdct, spI); + data -= 0.5 * zcsr_kron(spI, cdc); + data -= 0.5 * zcsr_kron(cdct, spI); ; if not td:; if data_only:; diff --git a/qutip/tests/test_expect.py b/qutip/tests/test_expect.py; index 45568110..17491981 100644; --- a/qutip/tests/test_expect.py; +++ b/qutip/tests/test_expect.py; @@ -120,7 +120,7 @@ def test_equivalent_to_matrix_element(hermitian):; state = qutip.rand_ket(dimension, 0.3); op = qutip.rand_herm(dimension, 0.2); if not hermitian:; - op = op + 1j*qutip.rand_herm(dimension, 0.1); + op += 1j * qutip.rand_herm(dimension, 0.1); expected = (state.dag() * op * state).data[0, 0]; assert abs(qutip.expect(op, state) - expected) < 1e-14; ; diff --git a/qutip/tests/test_fileio.py b/qutip/tests/test_fileio.py; index b02e8cb9..db237a41 100644; --- a/qutip/tests/test_fileio.py; +++ b/qutip/tests/test_fileio.py; @@ -22,7 +22,7 @@ class Test_file_data_store_file_data_read:; def case(self, filename, kwargs):; data = 1 - 2*np.random.rand(_dimension, _dimension); if kwargs.get('numtype', 'complex') == 'complex':; - data = data * (0.5*0.5j); + data *= 0.5 * 0.5j; qutip.file_data_store(filename, data, **kwargs); out = qutip.file_data_read(filename); np.testing.assert_allclose(data, out, atol=1e-8); diff --git a/qutip/tests/test_gates.py b/qutip/tests/test_gates.py; index d42ba373..0a24b79a 100644; --- a/qutip/tests/test_gates.py; +++ b/qutip/tests/test_gates.py; @@ -24,7 +24,7 @@ def _remove_global_phase(qobj):; for phase in flat:; if phase != 0:; # Fix the gauge for any global phase.; - flat = flat * np.exp(-1j * np.angle(phase)); + flat *= np.exp(-1j * np.angle(phase)); break",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1714#issuecomment-974625872
https://github.com/qutip/qutip/issues/1714#issuecomment-974625872:23270,Testability,test,tests,23270,"+= c_.data; else:; cd = c_.data.H; c = c_.data; if chi:; - data = data + np.exp(1j * chi[idx]) * \; + data += np.exp(1j * chi[idx]) * \; zcsr_kron(c.conj(), c); else:; - data = data + zcsr_kron(c.conj(), c); + data += zcsr_kron(c.conj(), c); cdc = cd * c; cdct = cdc.T; - data = data - 0.5 * zcsr_kron(spI, cdc); - data = data - 0.5 * zcsr_kron(cdct, spI); + data -= 0.5 * zcsr_kron(spI, cdc); + data -= 0.5 * zcsr_kron(cdct, spI); ; if not td:; if data_only:; diff --git a/qutip/tests/test_expect.py b/qutip/tests/test_expect.py; index 45568110..17491981 100644; --- a/qutip/tests/test_expect.py; +++ b/qutip/tests/test_expect.py; @@ -120,7 +120,7 @@ def test_equivalent_to_matrix_element(hermitian):; state = qutip.rand_ket(dimension, 0.3); op = qutip.rand_herm(dimension, 0.2); if not hermitian:; - op = op + 1j*qutip.rand_herm(dimension, 0.1); + op += 1j * qutip.rand_herm(dimension, 0.1); expected = (state.dag() * op * state).data[0, 0]; assert abs(qutip.expect(op, state) - expected) < 1e-14; ; diff --git a/qutip/tests/test_fileio.py b/qutip/tests/test_fileio.py; index b02e8cb9..db237a41 100644; --- a/qutip/tests/test_fileio.py; +++ b/qutip/tests/test_fileio.py; @@ -22,7 +22,7 @@ class Test_file_data_store_file_data_read:; def case(self, filename, kwargs):; data = 1 - 2*np.random.rand(_dimension, _dimension); if kwargs.get('numtype', 'complex') == 'complex':; - data = data * (0.5*0.5j); + data *= 0.5 * 0.5j; qutip.file_data_store(filename, data, **kwargs); out = qutip.file_data_read(filename); np.testing.assert_allclose(data, out, atol=1e-8); diff --git a/qutip/tests/test_gates.py b/qutip/tests/test_gates.py; index d42ba373..0a24b79a 100644; --- a/qutip/tests/test_gates.py; +++ b/qutip/tests/test_gates.py; @@ -24,7 +24,7 @@ def _remove_global_phase(qobj):; for phase in flat:; if phase != 0:; # Fix the gauge for any global phase.; - flat = flat * np.exp(-1j * np.angle(phase)); + flat *= np.exp(-1j * np.angle(phase)); break; return qutip.Qobj(flat.reshape(qobj.shape), dims=qo",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1714#issuecomment-974625872
https://github.com/qutip/qutip/issues/1714#issuecomment-974625872:23299,Testability,test,tests,23299,"i:; - data = data + np.exp(1j * chi[idx]) * \; + data += np.exp(1j * chi[idx]) * \; zcsr_kron(c.conj(), c); else:; - data = data + zcsr_kron(c.conj(), c); + data += zcsr_kron(c.conj(), c); cdc = cd * c; cdct = cdc.T; - data = data - 0.5 * zcsr_kron(spI, cdc); - data = data - 0.5 * zcsr_kron(cdct, spI); + data -= 0.5 * zcsr_kron(spI, cdc); + data -= 0.5 * zcsr_kron(cdct, spI); ; if not td:; if data_only:; diff --git a/qutip/tests/test_expect.py b/qutip/tests/test_expect.py; index 45568110..17491981 100644; --- a/qutip/tests/test_expect.py; +++ b/qutip/tests/test_expect.py; @@ -120,7 +120,7 @@ def test_equivalent_to_matrix_element(hermitian):; state = qutip.rand_ket(dimension, 0.3); op = qutip.rand_herm(dimension, 0.2); if not hermitian:; - op = op + 1j*qutip.rand_herm(dimension, 0.1); + op += 1j * qutip.rand_herm(dimension, 0.1); expected = (state.dag() * op * state).data[0, 0]; assert abs(qutip.expect(op, state) - expected) < 1e-14; ; diff --git a/qutip/tests/test_fileio.py b/qutip/tests/test_fileio.py; index b02e8cb9..db237a41 100644; --- a/qutip/tests/test_fileio.py; +++ b/qutip/tests/test_fileio.py; @@ -22,7 +22,7 @@ class Test_file_data_store_file_data_read:; def case(self, filename, kwargs):; data = 1 - 2*np.random.rand(_dimension, _dimension); if kwargs.get('numtype', 'complex') == 'complex':; - data = data * (0.5*0.5j); + data *= 0.5 * 0.5j; qutip.file_data_store(filename, data, **kwargs); out = qutip.file_data_read(filename); np.testing.assert_allclose(data, out, atol=1e-8); diff --git a/qutip/tests/test_gates.py b/qutip/tests/test_gates.py; index d42ba373..0a24b79a 100644; --- a/qutip/tests/test_gates.py; +++ b/qutip/tests/test_gates.py; @@ -24,7 +24,7 @@ def _remove_global_phase(qobj):; for phase in flat:; if phase != 0:; # Fix the gauge for any global phase.; - flat = flat * np.exp(-1j * np.angle(phase)); + flat *= np.exp(-1j * np.angle(phase)); break; return qutip.Qobj(flat.reshape(qobj.shape), dims=qobj.dims); ; @@ -310,7 +310,7 @@ class Test_expand_oper",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1714#issuecomment-974625872
https://github.com/qutip/qutip/issues/1714#issuecomment-974625872:23366,Testability,test,tests,23366,"p.exp(1j * chi[idx]) * \; zcsr_kron(c.conj(), c); else:; - data = data + zcsr_kron(c.conj(), c); + data += zcsr_kron(c.conj(), c); cdc = cd * c; cdct = cdc.T; - data = data - 0.5 * zcsr_kron(spI, cdc); - data = data - 0.5 * zcsr_kron(cdct, spI); + data -= 0.5 * zcsr_kron(spI, cdc); + data -= 0.5 * zcsr_kron(cdct, spI); ; if not td:; if data_only:; diff --git a/qutip/tests/test_expect.py b/qutip/tests/test_expect.py; index 45568110..17491981 100644; --- a/qutip/tests/test_expect.py; +++ b/qutip/tests/test_expect.py; @@ -120,7 +120,7 @@ def test_equivalent_to_matrix_element(hermitian):; state = qutip.rand_ket(dimension, 0.3); op = qutip.rand_herm(dimension, 0.2); if not hermitian:; - op = op + 1j*qutip.rand_herm(dimension, 0.1); + op += 1j * qutip.rand_herm(dimension, 0.1); expected = (state.dag() * op * state).data[0, 0]; assert abs(qutip.expect(op, state) - expected) < 1e-14; ; diff --git a/qutip/tests/test_fileio.py b/qutip/tests/test_fileio.py; index b02e8cb9..db237a41 100644; --- a/qutip/tests/test_fileio.py; +++ b/qutip/tests/test_fileio.py; @@ -22,7 +22,7 @@ class Test_file_data_store_file_data_read:; def case(self, filename, kwargs):; data = 1 - 2*np.random.rand(_dimension, _dimension); if kwargs.get('numtype', 'complex') == 'complex':; - data = data * (0.5*0.5j); + data *= 0.5 * 0.5j; qutip.file_data_store(filename, data, **kwargs); out = qutip.file_data_read(filename); np.testing.assert_allclose(data, out, atol=1e-8); diff --git a/qutip/tests/test_gates.py b/qutip/tests/test_gates.py; index d42ba373..0a24b79a 100644; --- a/qutip/tests/test_gates.py; +++ b/qutip/tests/test_gates.py; @@ -24,7 +24,7 @@ def _remove_global_phase(qobj):; for phase in flat:; if phase != 0:; # Fix the gauge for any global phase.; - flat = flat * np.exp(-1j * np.angle(phase)); + flat *= np.exp(-1j * np.angle(phase)); break; return qutip.Qobj(flat.reshape(qobj.shape), dims=qobj.dims); ; @@ -310,7 +310,7 @@ class Test_expand_operator:; [ 1, -1, 1, -1, -1, 1, -1, 1],; [ 1, 1, -1, -1, -1,",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1714#issuecomment-974625872
https://github.com/qutip/qutip/issues/1714#issuecomment-974625872:23400,Testability,test,tests,23400,"j(), c); else:; - data = data + zcsr_kron(c.conj(), c); + data += zcsr_kron(c.conj(), c); cdc = cd * c; cdct = cdc.T; - data = data - 0.5 * zcsr_kron(spI, cdc); - data = data - 0.5 * zcsr_kron(cdct, spI); + data -= 0.5 * zcsr_kron(spI, cdc); + data -= 0.5 * zcsr_kron(cdct, spI); ; if not td:; if data_only:; diff --git a/qutip/tests/test_expect.py b/qutip/tests/test_expect.py; index 45568110..17491981 100644; --- a/qutip/tests/test_expect.py; +++ b/qutip/tests/test_expect.py; @@ -120,7 +120,7 @@ def test_equivalent_to_matrix_element(hermitian):; state = qutip.rand_ket(dimension, 0.3); op = qutip.rand_herm(dimension, 0.2); if not hermitian:; - op = op + 1j*qutip.rand_herm(dimension, 0.1); + op += 1j * qutip.rand_herm(dimension, 0.1); expected = (state.dag() * op * state).data[0, 0]; assert abs(qutip.expect(op, state) - expected) < 1e-14; ; diff --git a/qutip/tests/test_fileio.py b/qutip/tests/test_fileio.py; index b02e8cb9..db237a41 100644; --- a/qutip/tests/test_fileio.py; +++ b/qutip/tests/test_fileio.py; @@ -22,7 +22,7 @@ class Test_file_data_store_file_data_read:; def case(self, filename, kwargs):; data = 1 - 2*np.random.rand(_dimension, _dimension); if kwargs.get('numtype', 'complex') == 'complex':; - data = data * (0.5*0.5j); + data *= 0.5 * 0.5j; qutip.file_data_store(filename, data, **kwargs); out = qutip.file_data_read(filename); np.testing.assert_allclose(data, out, atol=1e-8); diff --git a/qutip/tests/test_gates.py b/qutip/tests/test_gates.py; index d42ba373..0a24b79a 100644; --- a/qutip/tests/test_gates.py; +++ b/qutip/tests/test_gates.py; @@ -24,7 +24,7 @@ def _remove_global_phase(qobj):; for phase in flat:; if phase != 0:; # Fix the gauge for any global phase.; - flat = flat * np.exp(-1j * np.angle(phase)); + flat *= np.exp(-1j * np.angle(phase)); break; return qutip.Qobj(flat.reshape(qobj.shape), dims=qobj.dims); ; @@ -310,7 +310,7 @@ class Test_expand_operator:; [ 1, -1, 1, -1, -1, 1, -1, 1],; [ 1, 1, -1, -1, -1, -1, 1, 1],; [ 1, -1, -1, 1, -1, 1, 1, -",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1714#issuecomment-974625872
https://github.com/qutip/qutip/issues/1714#issuecomment-974625872:23763,Testability,test,testing,23763,"t_expect.py; index 45568110..17491981 100644; --- a/qutip/tests/test_expect.py; +++ b/qutip/tests/test_expect.py; @@ -120,7 +120,7 @@ def test_equivalent_to_matrix_element(hermitian):; state = qutip.rand_ket(dimension, 0.3); op = qutip.rand_herm(dimension, 0.2); if not hermitian:; - op = op + 1j*qutip.rand_herm(dimension, 0.1); + op += 1j * qutip.rand_herm(dimension, 0.1); expected = (state.dag() * op * state).data[0, 0]; assert abs(qutip.expect(op, state) - expected) < 1e-14; ; diff --git a/qutip/tests/test_fileio.py b/qutip/tests/test_fileio.py; index b02e8cb9..db237a41 100644; --- a/qutip/tests/test_fileio.py; +++ b/qutip/tests/test_fileio.py; @@ -22,7 +22,7 @@ class Test_file_data_store_file_data_read:; def case(self, filename, kwargs):; data = 1 - 2*np.random.rand(_dimension, _dimension); if kwargs.get('numtype', 'complex') == 'complex':; - data = data * (0.5*0.5j); + data *= 0.5 * 0.5j; qutip.file_data_store(filename, data, **kwargs); out = qutip.file_data_read(filename); np.testing.assert_allclose(data, out, atol=1e-8); diff --git a/qutip/tests/test_gates.py b/qutip/tests/test_gates.py; index d42ba373..0a24b79a 100644; --- a/qutip/tests/test_gates.py; +++ b/qutip/tests/test_gates.py; @@ -24,7 +24,7 @@ def _remove_global_phase(qobj):; for phase in flat:; if phase != 0:; # Fix the gauge for any global phase.; - flat = flat * np.exp(-1j * np.angle(phase)); + flat *= np.exp(-1j * np.angle(phase)); break; return qutip.Qobj(flat.reshape(qobj.shape), dims=qobj.dims); ; @@ -310,7 +310,7 @@ class Test_expand_operator:; [ 1, -1, 1, -1, -1, 1, -1, 1],; [ 1, 1, -1, -1, -1, -1, 1, 1],; [ 1, -1, -1, 1, -1, 1, 1, -1]]); - expected = expected/np.sqrt(8); + expected /=np.sqrt(8); np.testing.assert_allclose(test, expected); ; def test_cyclic_permutation(self):; diff --git a/qutip/tests/test_graph.py b/qutip/tests/test_graph.py; index 23fa6f22..f29c7379 100644; --- a/qutip/tests/test_graph.py; +++ b/qutip/tests/test_graph.py; @@ -70,7 +70,7 @@ def test_graph_rcm_boost():; M[4, ",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1714#issuecomment-974625872
https://github.com/qutip/qutip/issues/1714#issuecomment-974625872:23829,Testability,test,tests,23829,"644; --- a/qutip/tests/test_expect.py; +++ b/qutip/tests/test_expect.py; @@ -120,7 +120,7 @@ def test_equivalent_to_matrix_element(hermitian):; state = qutip.rand_ket(dimension, 0.3); op = qutip.rand_herm(dimension, 0.2); if not hermitian:; - op = op + 1j*qutip.rand_herm(dimension, 0.1); + op += 1j * qutip.rand_herm(dimension, 0.1); expected = (state.dag() * op * state).data[0, 0]; assert abs(qutip.expect(op, state) - expected) < 1e-14; ; diff --git a/qutip/tests/test_fileio.py b/qutip/tests/test_fileio.py; index b02e8cb9..db237a41 100644; --- a/qutip/tests/test_fileio.py; +++ b/qutip/tests/test_fileio.py; @@ -22,7 +22,7 @@ class Test_file_data_store_file_data_read:; def case(self, filename, kwargs):; data = 1 - 2*np.random.rand(_dimension, _dimension); if kwargs.get('numtype', 'complex') == 'complex':; - data = data * (0.5*0.5j); + data *= 0.5 * 0.5j; qutip.file_data_store(filename, data, **kwargs); out = qutip.file_data_read(filename); np.testing.assert_allclose(data, out, atol=1e-8); diff --git a/qutip/tests/test_gates.py b/qutip/tests/test_gates.py; index d42ba373..0a24b79a 100644; --- a/qutip/tests/test_gates.py; +++ b/qutip/tests/test_gates.py; @@ -24,7 +24,7 @@ def _remove_global_phase(qobj):; for phase in flat:; if phase != 0:; # Fix the gauge for any global phase.; - flat = flat * np.exp(-1j * np.angle(phase)); + flat *= np.exp(-1j * np.angle(phase)); break; return qutip.Qobj(flat.reshape(qobj.shape), dims=qobj.dims); ; @@ -310,7 +310,7 @@ class Test_expand_operator:; [ 1, -1, 1, -1, -1, 1, -1, 1],; [ 1, 1, -1, -1, -1, -1, 1, 1],; [ 1, -1, -1, 1, -1, 1, 1, -1]]); - expected = expected/np.sqrt(8); + expected /=np.sqrt(8); np.testing.assert_allclose(test, expected); ; def test_cyclic_permutation(self):; diff --git a/qutip/tests/test_graph.py b/qutip/tests/test_graph.py; index 23fa6f22..f29c7379 100644; --- a/qutip/tests/test_graph.py; +++ b/qutip/tests/test_graph.py; @@ -70,7 +70,7 @@ def test_graph_rcm_boost():; M[4, 6] = 1; M[5, [6, 7]] = 1; M[6, 7] = 1; - M",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1714#issuecomment-974625872
https://github.com/qutip/qutip/issues/1714#issuecomment-974625872:23857,Testability,test,tests,23857,"ests/test_expect.py; @@ -120,7 +120,7 @@ def test_equivalent_to_matrix_element(hermitian):; state = qutip.rand_ket(dimension, 0.3); op = qutip.rand_herm(dimension, 0.2); if not hermitian:; - op = op + 1j*qutip.rand_herm(dimension, 0.1); + op += 1j * qutip.rand_herm(dimension, 0.1); expected = (state.dag() * op * state).data[0, 0]; assert abs(qutip.expect(op, state) - expected) < 1e-14; ; diff --git a/qutip/tests/test_fileio.py b/qutip/tests/test_fileio.py; index b02e8cb9..db237a41 100644; --- a/qutip/tests/test_fileio.py; +++ b/qutip/tests/test_fileio.py; @@ -22,7 +22,7 @@ class Test_file_data_store_file_data_read:; def case(self, filename, kwargs):; data = 1 - 2*np.random.rand(_dimension, _dimension); if kwargs.get('numtype', 'complex') == 'complex':; - data = data * (0.5*0.5j); + data *= 0.5 * 0.5j; qutip.file_data_store(filename, data, **kwargs); out = qutip.file_data_read(filename); np.testing.assert_allclose(data, out, atol=1e-8); diff --git a/qutip/tests/test_gates.py b/qutip/tests/test_gates.py; index d42ba373..0a24b79a 100644; --- a/qutip/tests/test_gates.py; +++ b/qutip/tests/test_gates.py; @@ -24,7 +24,7 @@ def _remove_global_phase(qobj):; for phase in flat:; if phase != 0:; # Fix the gauge for any global phase.; - flat = flat * np.exp(-1j * np.angle(phase)); + flat *= np.exp(-1j * np.angle(phase)); break; return qutip.Qobj(flat.reshape(qobj.shape), dims=qobj.dims); ; @@ -310,7 +310,7 @@ class Test_expand_operator:; [ 1, -1, 1, -1, -1, 1, -1, 1],; [ 1, 1, -1, -1, -1, -1, 1, 1],; [ 1, -1, -1, 1, -1, 1, 1, -1]]); - expected = expected/np.sqrt(8); + expected /=np.sqrt(8); np.testing.assert_allclose(test, expected); ; def test_cyclic_permutation(self):; diff --git a/qutip/tests/test_graph.py b/qutip/tests/test_graph.py; index 23fa6f22..f29c7379 100644; --- a/qutip/tests/test_graph.py; +++ b/qutip/tests/test_graph.py; @@ -70,7 +70,7 @@ def test_graph_rcm_boost():; M[4, 6] = 1; M[5, [6, 7]] = 1; M[6, 7] = 1; - M = M+M.T; + M += M.T; M = sp.csr_matrix(M, dtype=co",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1714#issuecomment-974625872
https://github.com/qutip/qutip/issues/1714#issuecomment-974625872:23923,Testability,test,tests,23923,"ent_to_matrix_element(hermitian):; state = qutip.rand_ket(dimension, 0.3); op = qutip.rand_herm(dimension, 0.2); if not hermitian:; - op = op + 1j*qutip.rand_herm(dimension, 0.1); + op += 1j * qutip.rand_herm(dimension, 0.1); expected = (state.dag() * op * state).data[0, 0]; assert abs(qutip.expect(op, state) - expected) < 1e-14; ; diff --git a/qutip/tests/test_fileio.py b/qutip/tests/test_fileio.py; index b02e8cb9..db237a41 100644; --- a/qutip/tests/test_fileio.py; +++ b/qutip/tests/test_fileio.py; @@ -22,7 +22,7 @@ class Test_file_data_store_file_data_read:; def case(self, filename, kwargs):; data = 1 - 2*np.random.rand(_dimension, _dimension); if kwargs.get('numtype', 'complex') == 'complex':; - data = data * (0.5*0.5j); + data *= 0.5 * 0.5j; qutip.file_data_store(filename, data, **kwargs); out = qutip.file_data_read(filename); np.testing.assert_allclose(data, out, atol=1e-8); diff --git a/qutip/tests/test_gates.py b/qutip/tests/test_gates.py; index d42ba373..0a24b79a 100644; --- a/qutip/tests/test_gates.py; +++ b/qutip/tests/test_gates.py; @@ -24,7 +24,7 @@ def _remove_global_phase(qobj):; for phase in flat:; if phase != 0:; # Fix the gauge for any global phase.; - flat = flat * np.exp(-1j * np.angle(phase)); + flat *= np.exp(-1j * np.angle(phase)); break; return qutip.Qobj(flat.reshape(qobj.shape), dims=qobj.dims); ; @@ -310,7 +310,7 @@ class Test_expand_operator:; [ 1, -1, 1, -1, -1, 1, -1, 1],; [ 1, 1, -1, -1, -1, -1, 1, 1],; [ 1, -1, -1, 1, -1, 1, 1, -1]]); - expected = expected/np.sqrt(8); + expected /=np.sqrt(8); np.testing.assert_allclose(test, expected); ; def test_cyclic_permutation(self):; diff --git a/qutip/tests/test_graph.py b/qutip/tests/test_graph.py; index 23fa6f22..f29c7379 100644; --- a/qutip/tests/test_graph.py; +++ b/qutip/tests/test_graph.py; @@ -70,7 +70,7 @@ def test_graph_rcm_boost():; M[4, 6] = 1; M[5, [6, 7]] = 1; M[6, 7] = 1; - M = M+M.T; + M += M.T; M = sp.csr_matrix(M, dtype=complex); with pytest.deprecated_call():; perm = reverse_cu",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1714#issuecomment-974625872
https://github.com/qutip/qutip/issues/1714#issuecomment-974625872:23956,Testability,test,tests,23956,"e = qutip.rand_ket(dimension, 0.3); op = qutip.rand_herm(dimension, 0.2); if not hermitian:; - op = op + 1j*qutip.rand_herm(dimension, 0.1); + op += 1j * qutip.rand_herm(dimension, 0.1); expected = (state.dag() * op * state).data[0, 0]; assert abs(qutip.expect(op, state) - expected) < 1e-14; ; diff --git a/qutip/tests/test_fileio.py b/qutip/tests/test_fileio.py; index b02e8cb9..db237a41 100644; --- a/qutip/tests/test_fileio.py; +++ b/qutip/tests/test_fileio.py; @@ -22,7 +22,7 @@ class Test_file_data_store_file_data_read:; def case(self, filename, kwargs):; data = 1 - 2*np.random.rand(_dimension, _dimension); if kwargs.get('numtype', 'complex') == 'complex':; - data = data * (0.5*0.5j); + data *= 0.5 * 0.5j; qutip.file_data_store(filename, data, **kwargs); out = qutip.file_data_read(filename); np.testing.assert_allclose(data, out, atol=1e-8); diff --git a/qutip/tests/test_gates.py b/qutip/tests/test_gates.py; index d42ba373..0a24b79a 100644; --- a/qutip/tests/test_gates.py; +++ b/qutip/tests/test_gates.py; @@ -24,7 +24,7 @@ def _remove_global_phase(qobj):; for phase in flat:; if phase != 0:; # Fix the gauge for any global phase.; - flat = flat * np.exp(-1j * np.angle(phase)); + flat *= np.exp(-1j * np.angle(phase)); break; return qutip.Qobj(flat.reshape(qobj.shape), dims=qobj.dims); ; @@ -310,7 +310,7 @@ class Test_expand_operator:; [ 1, -1, 1, -1, -1, 1, -1, 1],; [ 1, 1, -1, -1, -1, -1, 1, 1],; [ 1, -1, -1, 1, -1, 1, 1, -1]]); - expected = expected/np.sqrt(8); + expected /=np.sqrt(8); np.testing.assert_allclose(test, expected); ; def test_cyclic_permutation(self):; diff --git a/qutip/tests/test_graph.py b/qutip/tests/test_graph.py; index 23fa6f22..f29c7379 100644; --- a/qutip/tests/test_graph.py; +++ b/qutip/tests/test_graph.py; @@ -70,7 +70,7 @@ def test_graph_rcm_boost():; M[4, 6] = 1; M[5, [6, 7]] = 1; M[6, 7] = 1; - M = M+M.T; + M += M.T; M = sp.csr_matrix(M, dtype=complex); with pytest.deprecated_call():; perm = reverse_cuthill_mckee(M, 1); @@ -120,7 +120,7 @@ d",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1714#issuecomment-974625872
https://github.com/qutip/qutip/issues/1714#issuecomment-974625872:24469,Testability,test,testing,24469,"ata_read:; def case(self, filename, kwargs):; data = 1 - 2*np.random.rand(_dimension, _dimension); if kwargs.get('numtype', 'complex') == 'complex':; - data = data * (0.5*0.5j); + data *= 0.5 * 0.5j; qutip.file_data_store(filename, data, **kwargs); out = qutip.file_data_read(filename); np.testing.assert_allclose(data, out, atol=1e-8); diff --git a/qutip/tests/test_gates.py b/qutip/tests/test_gates.py; index d42ba373..0a24b79a 100644; --- a/qutip/tests/test_gates.py; +++ b/qutip/tests/test_gates.py; @@ -24,7 +24,7 @@ def _remove_global_phase(qobj):; for phase in flat:; if phase != 0:; # Fix the gauge for any global phase.; - flat = flat * np.exp(-1j * np.angle(phase)); + flat *= np.exp(-1j * np.angle(phase)); break; return qutip.Qobj(flat.reshape(qobj.shape), dims=qobj.dims); ; @@ -310,7 +310,7 @@ class Test_expand_operator:; [ 1, -1, 1, -1, -1, 1, -1, 1],; [ 1, 1, -1, -1, -1, -1, 1, 1],; [ 1, -1, -1, 1, -1, 1, 1, -1]]); - expected = expected/np.sqrt(8); + expected /=np.sqrt(8); np.testing.assert_allclose(test, expected); ; def test_cyclic_permutation(self):; diff --git a/qutip/tests/test_graph.py b/qutip/tests/test_graph.py; index 23fa6f22..f29c7379 100644; --- a/qutip/tests/test_graph.py; +++ b/qutip/tests/test_graph.py; @@ -70,7 +70,7 @@ def test_graph_rcm_boost():; M[4, 6] = 1; M[5, [6, 7]] = 1; M[6, 7] = 1; - M = M+M.T; + M += M.T; M = sp.csr_matrix(M, dtype=complex); with pytest.deprecated_call():; perm = reverse_cuthill_mckee(M, 1); @@ -120,7 +120,7 @@ def test_graph_weighted_matching():; A.data = np.ones(a_len); d = np.arange(0, 25) + 2; B = sp.diags(d, offsets=0, format='csc'); - A = A+B; + A += B; perm = np.random.permutation(25); perm2 = np.random.permutation(25); B = sp_permute(A, perm, perm2); diff --git a/qutip/tests/test_mcsolve.py b/qutip/tests/test_mcsolve.py; index f8567d0e..fe3f264c 100644; --- a/qutip/tests/test_mcsolve.py; +++ b/qutip/tests/test_mcsolve.py; @@ -173,7 +173,7 @@ def test_expectation_dtype(options):; a = qutip.tensor(qutip.destroy(f",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1714#issuecomment-974625872
https://github.com/qutip/qutip/issues/1714#issuecomment-974625872:24493,Testability,test,test,24493,"2*np.random.rand(_dimension, _dimension); if kwargs.get('numtype', 'complex') == 'complex':; - data = data * (0.5*0.5j); + data *= 0.5 * 0.5j; qutip.file_data_store(filename, data, **kwargs); out = qutip.file_data_read(filename); np.testing.assert_allclose(data, out, atol=1e-8); diff --git a/qutip/tests/test_gates.py b/qutip/tests/test_gates.py; index d42ba373..0a24b79a 100644; --- a/qutip/tests/test_gates.py; +++ b/qutip/tests/test_gates.py; @@ -24,7 +24,7 @@ def _remove_global_phase(qobj):; for phase in flat:; if phase != 0:; # Fix the gauge for any global phase.; - flat = flat * np.exp(-1j * np.angle(phase)); + flat *= np.exp(-1j * np.angle(phase)); break; return qutip.Qobj(flat.reshape(qobj.shape), dims=qobj.dims); ; @@ -310,7 +310,7 @@ class Test_expand_operator:; [ 1, -1, 1, -1, -1, 1, -1, 1],; [ 1, 1, -1, -1, -1, -1, 1, 1],; [ 1, -1, -1, 1, -1, 1, 1, -1]]); - expected = expected/np.sqrt(8); + expected /=np.sqrt(8); np.testing.assert_allclose(test, expected); ; def test_cyclic_permutation(self):; diff --git a/qutip/tests/test_graph.py b/qutip/tests/test_graph.py; index 23fa6f22..f29c7379 100644; --- a/qutip/tests/test_graph.py; +++ b/qutip/tests/test_graph.py; @@ -70,7 +70,7 @@ def test_graph_rcm_boost():; M[4, 6] = 1; M[5, [6, 7]] = 1; M[6, 7] = 1; - M = M+M.T; + M += M.T; M = sp.csr_matrix(M, dtype=complex); with pytest.deprecated_call():; perm = reverse_cuthill_mckee(M, 1); @@ -120,7 +120,7 @@ def test_graph_weighted_matching():; A.data = np.ones(a_len); d = np.arange(0, 25) + 2; B = sp.diags(d, offsets=0, format='csc'); - A = A+B; + A += B; perm = np.random.permutation(25); perm2 = np.random.permutation(25); B = sp_permute(A, perm, perm2); diff --git a/qutip/tests/test_mcsolve.py b/qutip/tests/test_mcsolve.py; index f8567d0e..fe3f264c 100644; --- a/qutip/tests/test_mcsolve.py; +++ b/qutip/tests/test_mcsolve.py; @@ -173,7 +173,7 @@ def test_expectation_dtype(options):; a = qutip.tensor(qutip.destroy(focks), qutip.qeye(2)); sm = qutip.tensor(qutip.qeye(focks)",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1714#issuecomment-974625872
https://github.com/qutip/qutip/issues/1714#issuecomment-974625872:24567,Testability,test,tests,24567,"2*np.random.rand(_dimension, _dimension); if kwargs.get('numtype', 'complex') == 'complex':; - data = data * (0.5*0.5j); + data *= 0.5 * 0.5j; qutip.file_data_store(filename, data, **kwargs); out = qutip.file_data_read(filename); np.testing.assert_allclose(data, out, atol=1e-8); diff --git a/qutip/tests/test_gates.py b/qutip/tests/test_gates.py; index d42ba373..0a24b79a 100644; --- a/qutip/tests/test_gates.py; +++ b/qutip/tests/test_gates.py; @@ -24,7 +24,7 @@ def _remove_global_phase(qobj):; for phase in flat:; if phase != 0:; # Fix the gauge for any global phase.; - flat = flat * np.exp(-1j * np.angle(phase)); + flat *= np.exp(-1j * np.angle(phase)); break; return qutip.Qobj(flat.reshape(qobj.shape), dims=qobj.dims); ; @@ -310,7 +310,7 @@ class Test_expand_operator:; [ 1, -1, 1, -1, -1, 1, -1, 1],; [ 1, 1, -1, -1, -1, -1, 1, 1],; [ 1, -1, -1, 1, -1, 1, 1, -1]]); - expected = expected/np.sqrt(8); + expected /=np.sqrt(8); np.testing.assert_allclose(test, expected); ; def test_cyclic_permutation(self):; diff --git a/qutip/tests/test_graph.py b/qutip/tests/test_graph.py; index 23fa6f22..f29c7379 100644; --- a/qutip/tests/test_graph.py; +++ b/qutip/tests/test_graph.py; @@ -70,7 +70,7 @@ def test_graph_rcm_boost():; M[4, 6] = 1; M[5, [6, 7]] = 1; M[6, 7] = 1; - M = M+M.T; + M += M.T; M = sp.csr_matrix(M, dtype=complex); with pytest.deprecated_call():; perm = reverse_cuthill_mckee(M, 1); @@ -120,7 +120,7 @@ def test_graph_weighted_matching():; A.data = np.ones(a_len); d = np.arange(0, 25) + 2; B = sp.diags(d, offsets=0, format='csc'); - A = A+B; + A += B; perm = np.random.permutation(25); perm2 = np.random.permutation(25); B = sp_permute(A, perm, perm2); diff --git a/qutip/tests/test_mcsolve.py b/qutip/tests/test_mcsolve.py; index f8567d0e..fe3f264c 100644; --- a/qutip/tests/test_mcsolve.py; +++ b/qutip/tests/test_mcsolve.py; @@ -173,7 +173,7 @@ def test_expectation_dtype(options):; a = qutip.tensor(qutip.destroy(focks), qutip.qeye(2)); sm = qutip.tensor(qutip.qeye(focks)",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1714#issuecomment-974625872
https://github.com/qutip/qutip/issues/1714#issuecomment-974625872:24595,Testability,test,tests,24595,"complex') == 'complex':; - data = data * (0.5*0.5j); + data *= 0.5 * 0.5j; qutip.file_data_store(filename, data, **kwargs); out = qutip.file_data_read(filename); np.testing.assert_allclose(data, out, atol=1e-8); diff --git a/qutip/tests/test_gates.py b/qutip/tests/test_gates.py; index d42ba373..0a24b79a 100644; --- a/qutip/tests/test_gates.py; +++ b/qutip/tests/test_gates.py; @@ -24,7 +24,7 @@ def _remove_global_phase(qobj):; for phase in flat:; if phase != 0:; # Fix the gauge for any global phase.; - flat = flat * np.exp(-1j * np.angle(phase)); + flat *= np.exp(-1j * np.angle(phase)); break; return qutip.Qobj(flat.reshape(qobj.shape), dims=qobj.dims); ; @@ -310,7 +310,7 @@ class Test_expand_operator:; [ 1, -1, 1, -1, -1, 1, -1, 1],; [ 1, 1, -1, -1, -1, -1, 1, 1],; [ 1, -1, -1, 1, -1, 1, 1, -1]]); - expected = expected/np.sqrt(8); + expected /=np.sqrt(8); np.testing.assert_allclose(test, expected); ; def test_cyclic_permutation(self):; diff --git a/qutip/tests/test_graph.py b/qutip/tests/test_graph.py; index 23fa6f22..f29c7379 100644; --- a/qutip/tests/test_graph.py; +++ b/qutip/tests/test_graph.py; @@ -70,7 +70,7 @@ def test_graph_rcm_boost():; M[4, 6] = 1; M[5, [6, 7]] = 1; M[6, 7] = 1; - M = M+M.T; + M += M.T; M = sp.csr_matrix(M, dtype=complex); with pytest.deprecated_call():; perm = reverse_cuthill_mckee(M, 1); @@ -120,7 +120,7 @@ def test_graph_weighted_matching():; A.data = np.ones(a_len); d = np.arange(0, 25) + 2; B = sp.diags(d, offsets=0, format='csc'); - A = A+B; + A += B; perm = np.random.permutation(25); perm2 = np.random.permutation(25); B = sp_permute(A, perm, perm2); diff --git a/qutip/tests/test_mcsolve.py b/qutip/tests/test_mcsolve.py; index f8567d0e..fe3f264c 100644; --- a/qutip/tests/test_mcsolve.py; +++ b/qutip/tests/test_mcsolve.py; @@ -173,7 +173,7 @@ def test_expectation_dtype(options):; a = qutip.tensor(qutip.destroy(focks), qutip.qeye(2)); sm = qutip.tensor(qutip.qeye(focks), qutip.sigmam()); H = 1j*a.dag()*sm + a; - H = H + H.dag(); + H +=",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1714#issuecomment-974625872
https://github.com/qutip/qutip/issues/1714#issuecomment-974625872:24661,Testability,test,tests,24661,"ta *= 0.5 * 0.5j; qutip.file_data_store(filename, data, **kwargs); out = qutip.file_data_read(filename); np.testing.assert_allclose(data, out, atol=1e-8); diff --git a/qutip/tests/test_gates.py b/qutip/tests/test_gates.py; index d42ba373..0a24b79a 100644; --- a/qutip/tests/test_gates.py; +++ b/qutip/tests/test_gates.py; @@ -24,7 +24,7 @@ def _remove_global_phase(qobj):; for phase in flat:; if phase != 0:; # Fix the gauge for any global phase.; - flat = flat * np.exp(-1j * np.angle(phase)); + flat *= np.exp(-1j * np.angle(phase)); break; return qutip.Qobj(flat.reshape(qobj.shape), dims=qobj.dims); ; @@ -310,7 +310,7 @@ class Test_expand_operator:; [ 1, -1, 1, -1, -1, 1, -1, 1],; [ 1, 1, -1, -1, -1, -1, 1, 1],; [ 1, -1, -1, 1, -1, 1, 1, -1]]); - expected = expected/np.sqrt(8); + expected /=np.sqrt(8); np.testing.assert_allclose(test, expected); ; def test_cyclic_permutation(self):; diff --git a/qutip/tests/test_graph.py b/qutip/tests/test_graph.py; index 23fa6f22..f29c7379 100644; --- a/qutip/tests/test_graph.py; +++ b/qutip/tests/test_graph.py; @@ -70,7 +70,7 @@ def test_graph_rcm_boost():; M[4, 6] = 1; M[5, [6, 7]] = 1; M[6, 7] = 1; - M = M+M.T; + M += M.T; M = sp.csr_matrix(M, dtype=complex); with pytest.deprecated_call():; perm = reverse_cuthill_mckee(M, 1); @@ -120,7 +120,7 @@ def test_graph_weighted_matching():; A.data = np.ones(a_len); d = np.arange(0, 25) + 2; B = sp.diags(d, offsets=0, format='csc'); - A = A+B; + A += B; perm = np.random.permutation(25); perm2 = np.random.permutation(25); B = sp_permute(A, perm, perm2); diff --git a/qutip/tests/test_mcsolve.py b/qutip/tests/test_mcsolve.py; index f8567d0e..fe3f264c 100644; --- a/qutip/tests/test_mcsolve.py; +++ b/qutip/tests/test_mcsolve.py; @@ -173,7 +173,7 @@ def test_expectation_dtype(options):; a = qutip.tensor(qutip.destroy(focks), qutip.qeye(2)); sm = qutip.tensor(qutip.qeye(focks), qutip.sigmam()); H = 1j*a.dag()*sm + a; - H = H + H.dag(); + H += H.dag(); state = qutip.basis([focks, 2], [0, 1]); times ",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1714#issuecomment-974625872
https://github.com/qutip/qutip/issues/1714#issuecomment-974625872:24694,Testability,test,tests,24694,"(filename, data, **kwargs); out = qutip.file_data_read(filename); np.testing.assert_allclose(data, out, atol=1e-8); diff --git a/qutip/tests/test_gates.py b/qutip/tests/test_gates.py; index d42ba373..0a24b79a 100644; --- a/qutip/tests/test_gates.py; +++ b/qutip/tests/test_gates.py; @@ -24,7 +24,7 @@ def _remove_global_phase(qobj):; for phase in flat:; if phase != 0:; # Fix the gauge for any global phase.; - flat = flat * np.exp(-1j * np.angle(phase)); + flat *= np.exp(-1j * np.angle(phase)); break; return qutip.Qobj(flat.reshape(qobj.shape), dims=qobj.dims); ; @@ -310,7 +310,7 @@ class Test_expand_operator:; [ 1, -1, 1, -1, -1, 1, -1, 1],; [ 1, 1, -1, -1, -1, -1, 1, 1],; [ 1, -1, -1, 1, -1, 1, 1, -1]]); - expected = expected/np.sqrt(8); + expected /=np.sqrt(8); np.testing.assert_allclose(test, expected); ; def test_cyclic_permutation(self):; diff --git a/qutip/tests/test_graph.py b/qutip/tests/test_graph.py; index 23fa6f22..f29c7379 100644; --- a/qutip/tests/test_graph.py; +++ b/qutip/tests/test_graph.py; @@ -70,7 +70,7 @@ def test_graph_rcm_boost():; M[4, 6] = 1; M[5, [6, 7]] = 1; M[6, 7] = 1; - M = M+M.T; + M += M.T; M = sp.csr_matrix(M, dtype=complex); with pytest.deprecated_call():; perm = reverse_cuthill_mckee(M, 1); @@ -120,7 +120,7 @@ def test_graph_weighted_matching():; A.data = np.ones(a_len); d = np.arange(0, 25) + 2; B = sp.diags(d, offsets=0, format='csc'); - A = A+B; + A += B; perm = np.random.permutation(25); perm2 = np.random.permutation(25); B = sp_permute(A, perm, perm2); diff --git a/qutip/tests/test_mcsolve.py b/qutip/tests/test_mcsolve.py; index f8567d0e..fe3f264c 100644; --- a/qutip/tests/test_mcsolve.py; +++ b/qutip/tests/test_mcsolve.py; @@ -173,7 +173,7 @@ def test_expectation_dtype(options):; a = qutip.tensor(qutip.destroy(focks), qutip.qeye(2)); sm = qutip.tensor(qutip.qeye(focks), qutip.sigmam()); H = 1j*a.dag()*sm + a; - H = H + H.dag(); + H += H.dag(); state = qutip.basis([focks, 2], [0, 1]); times = np.linspace(0, 10, 5); c_ops = [a, sm]",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1714#issuecomment-974625872
https://github.com/qutip/qutip/issues/1714#issuecomment-974625872:25227,Testability,test,tests,25227,"rn qutip.Qobj(flat.reshape(qobj.shape), dims=qobj.dims); ; @@ -310,7 +310,7 @@ class Test_expand_operator:; [ 1, -1, 1, -1, -1, 1, -1, 1],; [ 1, 1, -1, -1, -1, -1, 1, 1],; [ 1, -1, -1, 1, -1, 1, 1, -1]]); - expected = expected/np.sqrt(8); + expected /=np.sqrt(8); np.testing.assert_allclose(test, expected); ; def test_cyclic_permutation(self):; diff --git a/qutip/tests/test_graph.py b/qutip/tests/test_graph.py; index 23fa6f22..f29c7379 100644; --- a/qutip/tests/test_graph.py; +++ b/qutip/tests/test_graph.py; @@ -70,7 +70,7 @@ def test_graph_rcm_boost():; M[4, 6] = 1; M[5, [6, 7]] = 1; M[6, 7] = 1; - M = M+M.T; + M += M.T; M = sp.csr_matrix(M, dtype=complex); with pytest.deprecated_call():; perm = reverse_cuthill_mckee(M, 1); @@ -120,7 +120,7 @@ def test_graph_weighted_matching():; A.data = np.ones(a_len); d = np.arange(0, 25) + 2; B = sp.diags(d, offsets=0, format='csc'); - A = A+B; + A += B; perm = np.random.permutation(25); perm2 = np.random.permutation(25); B = sp_permute(A, perm, perm2); diff --git a/qutip/tests/test_mcsolve.py b/qutip/tests/test_mcsolve.py; index f8567d0e..fe3f264c 100644; --- a/qutip/tests/test_mcsolve.py; +++ b/qutip/tests/test_mcsolve.py; @@ -173,7 +173,7 @@ def test_expectation_dtype(options):; a = qutip.tensor(qutip.destroy(focks), qutip.qeye(2)); sm = qutip.tensor(qutip.qeye(focks), qutip.sigmam()); H = 1j*a.dag()*sm + a; - H = H + H.dag(); + H += H.dag(); state = qutip.basis([focks, 2], [0, 1]); times = np.linspace(0, 10, 5); c_ops = [a, sm]; diff --git a/qutip/tests/test_mesolve.py b/qutip/tests/test_mesolve.py; index f17115ec..bc6cce59 100644; --- a/qutip/tests/test_mesolve.py; +++ b/qutip/tests/test_mesolve.py; @@ -238,8 +238,8 @@ class TestJCModelEvolution:; nc_ss, na_ss = self.jc_steadystate(; N, wc, wa, g, kappa, gamma, pump, psi0, use_rwa, tlist); ; - nc_ss = nc_ss * np.ones(np.shape(nc)); - na_ss = na_ss * np.ones(np.shape(na)); + nc_ss *= np.ones(np.shape(nc)); + na_ss *= np.ones(np.shape(na)); ; assert_(abs(nc[-1] - nc_ss[-1]) < ",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1714#issuecomment-974625872
https://github.com/qutip/qutip/issues/1714#issuecomment-974625872:25257,Testability,test,tests,25257,"@@ -310,7 +310,7 @@ class Test_expand_operator:; [ 1, -1, 1, -1, -1, 1, -1, 1],; [ 1, 1, -1, -1, -1, -1, 1, 1],; [ 1, -1, -1, 1, -1, 1, 1, -1]]); - expected = expected/np.sqrt(8); + expected /=np.sqrt(8); np.testing.assert_allclose(test, expected); ; def test_cyclic_permutation(self):; diff --git a/qutip/tests/test_graph.py b/qutip/tests/test_graph.py; index 23fa6f22..f29c7379 100644; --- a/qutip/tests/test_graph.py; +++ b/qutip/tests/test_graph.py; @@ -70,7 +70,7 @@ def test_graph_rcm_boost():; M[4, 6] = 1; M[5, [6, 7]] = 1; M[6, 7] = 1; - M = M+M.T; + M += M.T; M = sp.csr_matrix(M, dtype=complex); with pytest.deprecated_call():; perm = reverse_cuthill_mckee(M, 1); @@ -120,7 +120,7 @@ def test_graph_weighted_matching():; A.data = np.ones(a_len); d = np.arange(0, 25) + 2; B = sp.diags(d, offsets=0, format='csc'); - A = A+B; + A += B; perm = np.random.permutation(25); perm2 = np.random.permutation(25); B = sp_permute(A, perm, perm2); diff --git a/qutip/tests/test_mcsolve.py b/qutip/tests/test_mcsolve.py; index f8567d0e..fe3f264c 100644; --- a/qutip/tests/test_mcsolve.py; +++ b/qutip/tests/test_mcsolve.py; @@ -173,7 +173,7 @@ def test_expectation_dtype(options):; a = qutip.tensor(qutip.destroy(focks), qutip.qeye(2)); sm = qutip.tensor(qutip.qeye(focks), qutip.sigmam()); H = 1j*a.dag()*sm + a; - H = H + H.dag(); + H += H.dag(); state = qutip.basis([focks, 2], [0, 1]); times = np.linspace(0, 10, 5); c_ops = [a, sm]; diff --git a/qutip/tests/test_mesolve.py b/qutip/tests/test_mesolve.py; index f17115ec..bc6cce59 100644; --- a/qutip/tests/test_mesolve.py; +++ b/qutip/tests/test_mesolve.py; @@ -238,8 +238,8 @@ class TestJCModelEvolution:; nc_ss, na_ss = self.jc_steadystate(; N, wc, wa, g, kappa, gamma, pump, psi0, use_rwa, tlist); ; - nc_ss = nc_ss * np.ones(np.shape(nc)); - na_ss = na_ss * np.ones(np.shape(na)); + nc_ss *= np.ones(np.shape(nc)); + na_ss *= np.ones(np.shape(na)); ; assert_(abs(nc[-1] - nc_ss[-1]) < 0.005, True); assert_(abs(na[-1] - na_ss[-1]) < 0.005, Tru",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1714#issuecomment-974625872
https://github.com/qutip/qutip/issues/1714#issuecomment-974625872:25325,Testability,test,tests,25325,", -1, -1, 1, -1, 1],; [ 1, 1, -1, -1, -1, -1, 1, 1],; [ 1, -1, -1, 1, -1, 1, 1, -1]]); - expected = expected/np.sqrt(8); + expected /=np.sqrt(8); np.testing.assert_allclose(test, expected); ; def test_cyclic_permutation(self):; diff --git a/qutip/tests/test_graph.py b/qutip/tests/test_graph.py; index 23fa6f22..f29c7379 100644; --- a/qutip/tests/test_graph.py; +++ b/qutip/tests/test_graph.py; @@ -70,7 +70,7 @@ def test_graph_rcm_boost():; M[4, 6] = 1; M[5, [6, 7]] = 1; M[6, 7] = 1; - M = M+M.T; + M += M.T; M = sp.csr_matrix(M, dtype=complex); with pytest.deprecated_call():; perm = reverse_cuthill_mckee(M, 1); @@ -120,7 +120,7 @@ def test_graph_weighted_matching():; A.data = np.ones(a_len); d = np.arange(0, 25) + 2; B = sp.diags(d, offsets=0, format='csc'); - A = A+B; + A += B; perm = np.random.permutation(25); perm2 = np.random.permutation(25); B = sp_permute(A, perm, perm2); diff --git a/qutip/tests/test_mcsolve.py b/qutip/tests/test_mcsolve.py; index f8567d0e..fe3f264c 100644; --- a/qutip/tests/test_mcsolve.py; +++ b/qutip/tests/test_mcsolve.py; @@ -173,7 +173,7 @@ def test_expectation_dtype(options):; a = qutip.tensor(qutip.destroy(focks), qutip.qeye(2)); sm = qutip.tensor(qutip.qeye(focks), qutip.sigmam()); H = 1j*a.dag()*sm + a; - H = H + H.dag(); + H += H.dag(); state = qutip.basis([focks, 2], [0, 1]); times = np.linspace(0, 10, 5); c_ops = [a, sm]; diff --git a/qutip/tests/test_mesolve.py b/qutip/tests/test_mesolve.py; index f17115ec..bc6cce59 100644; --- a/qutip/tests/test_mesolve.py; +++ b/qutip/tests/test_mesolve.py; @@ -238,8 +238,8 @@ class TestJCModelEvolution:; nc_ss, na_ss = self.jc_steadystate(; N, wc, wa, g, kappa, gamma, pump, psi0, use_rwa, tlist); ; - nc_ss = nc_ss * np.ones(np.shape(nc)); - na_ss = na_ss * np.ones(np.shape(na)); + nc_ss *= np.ones(np.shape(nc)); + na_ss *= np.ones(np.shape(na)); ; assert_(abs(nc[-1] - nc_ss[-1]) < 0.005, True); assert_(abs(na[-1] - na_ss[-1]) < 0.005, True); diff --git a/qutip/tests/test_qobj.py b/qutip/tests/tes",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1714#issuecomment-974625872
https://github.com/qutip/qutip/issues/1714#issuecomment-974625872:25360,Testability,test,tests,25360," -1, 1, 1],; [ 1, -1, -1, 1, -1, 1, 1, -1]]); - expected = expected/np.sqrt(8); + expected /=np.sqrt(8); np.testing.assert_allclose(test, expected); ; def test_cyclic_permutation(self):; diff --git a/qutip/tests/test_graph.py b/qutip/tests/test_graph.py; index 23fa6f22..f29c7379 100644; --- a/qutip/tests/test_graph.py; +++ b/qutip/tests/test_graph.py; @@ -70,7 +70,7 @@ def test_graph_rcm_boost():; M[4, 6] = 1; M[5, [6, 7]] = 1; M[6, 7] = 1; - M = M+M.T; + M += M.T; M = sp.csr_matrix(M, dtype=complex); with pytest.deprecated_call():; perm = reverse_cuthill_mckee(M, 1); @@ -120,7 +120,7 @@ def test_graph_weighted_matching():; A.data = np.ones(a_len); d = np.arange(0, 25) + 2; B = sp.diags(d, offsets=0, format='csc'); - A = A+B; + A += B; perm = np.random.permutation(25); perm2 = np.random.permutation(25); B = sp_permute(A, perm, perm2); diff --git a/qutip/tests/test_mcsolve.py b/qutip/tests/test_mcsolve.py; index f8567d0e..fe3f264c 100644; --- a/qutip/tests/test_mcsolve.py; +++ b/qutip/tests/test_mcsolve.py; @@ -173,7 +173,7 @@ def test_expectation_dtype(options):; a = qutip.tensor(qutip.destroy(focks), qutip.qeye(2)); sm = qutip.tensor(qutip.qeye(focks), qutip.sigmam()); H = 1j*a.dag()*sm + a; - H = H + H.dag(); + H += H.dag(); state = qutip.basis([focks, 2], [0, 1]); times = np.linspace(0, 10, 5); c_ops = [a, sm]; diff --git a/qutip/tests/test_mesolve.py b/qutip/tests/test_mesolve.py; index f17115ec..bc6cce59 100644; --- a/qutip/tests/test_mesolve.py; +++ b/qutip/tests/test_mesolve.py; @@ -238,8 +238,8 @@ class TestJCModelEvolution:; nc_ss, na_ss = self.jc_steadystate(; N, wc, wa, g, kappa, gamma, pump, psi0, use_rwa, tlist); ; - nc_ss = nc_ss * np.ones(np.shape(nc)); - na_ss = na_ss * np.ones(np.shape(na)); + nc_ss *= np.ones(np.shape(nc)); + na_ss *= np.ones(np.shape(na)); ; assert_(abs(nc[-1] - nc_ss[-1]) < 0.005, True); assert_(abs(na[-1] - na_ss[-1]) < 0.005, True); diff --git a/qutip/tests/test_qobj.py b/qutip/tests/test_qobj.py; index 11caa048..c875ef3f 100644",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1714#issuecomment-974625872
https://github.com/qutip/qutip/issues/1714#issuecomment-974625872:25716,Testability,test,tests,25716,"ts/test_graph.py; @@ -70,7 +70,7 @@ def test_graph_rcm_boost():; M[4, 6] = 1; M[5, [6, 7]] = 1; M[6, 7] = 1; - M = M+M.T; + M += M.T; M = sp.csr_matrix(M, dtype=complex); with pytest.deprecated_call():; perm = reverse_cuthill_mckee(M, 1); @@ -120,7 +120,7 @@ def test_graph_weighted_matching():; A.data = np.ones(a_len); d = np.arange(0, 25) + 2; B = sp.diags(d, offsets=0, format='csc'); - A = A+B; + A += B; perm = np.random.permutation(25); perm2 = np.random.permutation(25); B = sp_permute(A, perm, perm2); diff --git a/qutip/tests/test_mcsolve.py b/qutip/tests/test_mcsolve.py; index f8567d0e..fe3f264c 100644; --- a/qutip/tests/test_mcsolve.py; +++ b/qutip/tests/test_mcsolve.py; @@ -173,7 +173,7 @@ def test_expectation_dtype(options):; a = qutip.tensor(qutip.destroy(focks), qutip.qeye(2)); sm = qutip.tensor(qutip.qeye(focks), qutip.sigmam()); H = 1j*a.dag()*sm + a; - H = H + H.dag(); + H += H.dag(); state = qutip.basis([focks, 2], [0, 1]); times = np.linspace(0, 10, 5); c_ops = [a, sm]; diff --git a/qutip/tests/test_mesolve.py b/qutip/tests/test_mesolve.py; index f17115ec..bc6cce59 100644; --- a/qutip/tests/test_mesolve.py; +++ b/qutip/tests/test_mesolve.py; @@ -238,8 +238,8 @@ class TestJCModelEvolution:; nc_ss, na_ss = self.jc_steadystate(; N, wc, wa, g, kappa, gamma, pump, psi0, use_rwa, tlist); ; - nc_ss = nc_ss * np.ones(np.shape(nc)); - na_ss = na_ss * np.ones(np.shape(na)); + nc_ss *= np.ones(np.shape(nc)); + na_ss *= np.ones(np.shape(na)); ; assert_(abs(nc[-1] - nc_ss[-1]) < 0.005, True); assert_(abs(na[-1] - na_ss[-1]) < 0.005, True); diff --git a/qutip/tests/test_qobj.py b/qutip/tests/test_qobj.py; index 11caa048..c875ef3f 100644; --- a/qutip/tests/test_qobj.py; +++ b/qutip/tests/test_qobj.py; @@ -244,7 +244,7 @@ def test_QobjAddition():; x1 = q + 5; x2 = 5 + q; ; - data = data + np.eye(5) * 5; + data += np.eye(5) * 5; assert np.all(x1.full() == data); assert np.all(x2.full() == data); ; @@ -298,7 +298,7 @@ def test_QobjDivision():; data = _random_not_singula",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1714#issuecomment-974625872
https://github.com/qutip/qutip/issues/1714#issuecomment-974625872:25746,Testability,test,tests,25746,"m_boost():; M[4, 6] = 1; M[5, [6, 7]] = 1; M[6, 7] = 1; - M = M+M.T; + M += M.T; M = sp.csr_matrix(M, dtype=complex); with pytest.deprecated_call():; perm = reverse_cuthill_mckee(M, 1); @@ -120,7 +120,7 @@ def test_graph_weighted_matching():; A.data = np.ones(a_len); d = np.arange(0, 25) + 2; B = sp.diags(d, offsets=0, format='csc'); - A = A+B; + A += B; perm = np.random.permutation(25); perm2 = np.random.permutation(25); B = sp_permute(A, perm, perm2); diff --git a/qutip/tests/test_mcsolve.py b/qutip/tests/test_mcsolve.py; index f8567d0e..fe3f264c 100644; --- a/qutip/tests/test_mcsolve.py; +++ b/qutip/tests/test_mcsolve.py; @@ -173,7 +173,7 @@ def test_expectation_dtype(options):; a = qutip.tensor(qutip.destroy(focks), qutip.qeye(2)); sm = qutip.tensor(qutip.qeye(focks), qutip.sigmam()); H = 1j*a.dag()*sm + a; - H = H + H.dag(); + H += H.dag(); state = qutip.basis([focks, 2], [0, 1]); times = np.linspace(0, 10, 5); c_ops = [a, sm]; diff --git a/qutip/tests/test_mesolve.py b/qutip/tests/test_mesolve.py; index f17115ec..bc6cce59 100644; --- a/qutip/tests/test_mesolve.py; +++ b/qutip/tests/test_mesolve.py; @@ -238,8 +238,8 @@ class TestJCModelEvolution:; nc_ss, na_ss = self.jc_steadystate(; N, wc, wa, g, kappa, gamma, pump, psi0, use_rwa, tlist); ; - nc_ss = nc_ss * np.ones(np.shape(nc)); - na_ss = na_ss * np.ones(np.shape(na)); + nc_ss *= np.ones(np.shape(nc)); + na_ss *= np.ones(np.shape(na)); ; assert_(abs(nc[-1] - nc_ss[-1]) < 0.005, True); assert_(abs(na[-1] - na_ss[-1]) < 0.005, True); diff --git a/qutip/tests/test_qobj.py b/qutip/tests/test_qobj.py; index 11caa048..c875ef3f 100644; --- a/qutip/tests/test_qobj.py; +++ b/qutip/tests/test_qobj.py; @@ -244,7 +244,7 @@ def test_QobjAddition():; x1 = q + 5; x2 = 5 + q; ; - data = data + np.eye(5) * 5; + data += np.eye(5) * 5; assert np.all(x1.full() == data); assert np.all(x2.full() == data); ; @@ -298,7 +298,7 @@ def test_QobjDivision():; data = _random_not_singular(5); q = Qobj(data); randN = 10 * np.random.random(",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1714#issuecomment-974625872
https://github.com/qutip/qutip/issues/1714#issuecomment-974625872:25814,Testability,test,tests,25814," = M+M.T; + M += M.T; M = sp.csr_matrix(M, dtype=complex); with pytest.deprecated_call():; perm = reverse_cuthill_mckee(M, 1); @@ -120,7 +120,7 @@ def test_graph_weighted_matching():; A.data = np.ones(a_len); d = np.arange(0, 25) + 2; B = sp.diags(d, offsets=0, format='csc'); - A = A+B; + A += B; perm = np.random.permutation(25); perm2 = np.random.permutation(25); B = sp_permute(A, perm, perm2); diff --git a/qutip/tests/test_mcsolve.py b/qutip/tests/test_mcsolve.py; index f8567d0e..fe3f264c 100644; --- a/qutip/tests/test_mcsolve.py; +++ b/qutip/tests/test_mcsolve.py; @@ -173,7 +173,7 @@ def test_expectation_dtype(options):; a = qutip.tensor(qutip.destroy(focks), qutip.qeye(2)); sm = qutip.tensor(qutip.qeye(focks), qutip.sigmam()); H = 1j*a.dag()*sm + a; - H = H + H.dag(); + H += H.dag(); state = qutip.basis([focks, 2], [0, 1]); times = np.linspace(0, 10, 5); c_ops = [a, sm]; diff --git a/qutip/tests/test_mesolve.py b/qutip/tests/test_mesolve.py; index f17115ec..bc6cce59 100644; --- a/qutip/tests/test_mesolve.py; +++ b/qutip/tests/test_mesolve.py; @@ -238,8 +238,8 @@ class TestJCModelEvolution:; nc_ss, na_ss = self.jc_steadystate(; N, wc, wa, g, kappa, gamma, pump, psi0, use_rwa, tlist); ; - nc_ss = nc_ss * np.ones(np.shape(nc)); - na_ss = na_ss * np.ones(np.shape(na)); + nc_ss *= np.ones(np.shape(nc)); + na_ss *= np.ones(np.shape(na)); ; assert_(abs(nc[-1] - nc_ss[-1]) < 0.005, True); assert_(abs(na[-1] - na_ss[-1]) < 0.005, True); diff --git a/qutip/tests/test_qobj.py b/qutip/tests/test_qobj.py; index 11caa048..c875ef3f 100644; --- a/qutip/tests/test_qobj.py; +++ b/qutip/tests/test_qobj.py; @@ -244,7 +244,7 @@ def test_QobjAddition():; x1 = q + 5; x2 = 5 + q; ; - data = data + np.eye(5) * 5; + data += np.eye(5) * 5; assert np.all(x1.full() == data); assert np.all(x2.full() == data); ; @@ -298,7 +298,7 @@ def test_QobjDivision():; data = _random_not_singular(5); q = Qobj(data); randN = 10 * np.random.random(); - q = q / randN; + q /= randN; assert np.allclose(q.full",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1714#issuecomment-974625872
https://github.com/qutip/qutip/issues/1714#issuecomment-974625872:25849,Testability,test,tests,25849,", dtype=complex); with pytest.deprecated_call():; perm = reverse_cuthill_mckee(M, 1); @@ -120,7 +120,7 @@ def test_graph_weighted_matching():; A.data = np.ones(a_len); d = np.arange(0, 25) + 2; B = sp.diags(d, offsets=0, format='csc'); - A = A+B; + A += B; perm = np.random.permutation(25); perm2 = np.random.permutation(25); B = sp_permute(A, perm, perm2); diff --git a/qutip/tests/test_mcsolve.py b/qutip/tests/test_mcsolve.py; index f8567d0e..fe3f264c 100644; --- a/qutip/tests/test_mcsolve.py; +++ b/qutip/tests/test_mcsolve.py; @@ -173,7 +173,7 @@ def test_expectation_dtype(options):; a = qutip.tensor(qutip.destroy(focks), qutip.qeye(2)); sm = qutip.tensor(qutip.qeye(focks), qutip.sigmam()); H = 1j*a.dag()*sm + a; - H = H + H.dag(); + H += H.dag(); state = qutip.basis([focks, 2], [0, 1]); times = np.linspace(0, 10, 5); c_ops = [a, sm]; diff --git a/qutip/tests/test_mesolve.py b/qutip/tests/test_mesolve.py; index f17115ec..bc6cce59 100644; --- a/qutip/tests/test_mesolve.py; +++ b/qutip/tests/test_mesolve.py; @@ -238,8 +238,8 @@ class TestJCModelEvolution:; nc_ss, na_ss = self.jc_steadystate(; N, wc, wa, g, kappa, gamma, pump, psi0, use_rwa, tlist); ; - nc_ss = nc_ss * np.ones(np.shape(nc)); - na_ss = na_ss * np.ones(np.shape(na)); + nc_ss *= np.ones(np.shape(nc)); + na_ss *= np.ones(np.shape(na)); ; assert_(abs(nc[-1] - nc_ss[-1]) < 0.005, True); assert_(abs(na[-1] - na_ss[-1]) < 0.005, True); diff --git a/qutip/tests/test_qobj.py b/qutip/tests/test_qobj.py; index 11caa048..c875ef3f 100644; --- a/qutip/tests/test_qobj.py; +++ b/qutip/tests/test_qobj.py; @@ -244,7 +244,7 @@ def test_QobjAddition():; x1 = q + 5; x2 = 5 + q; ; - data = data + np.eye(5) * 5; + data += np.eye(5) * 5; assert np.all(x1.full() == data); assert np.all(x2.full() == data); ; @@ -298,7 +298,7 @@ def test_QobjDivision():; data = _random_not_singular(5); q = Qobj(data); randN = 10 * np.random.random(); - q = q / randN; + q /= randN; assert np.allclose(q.full(), data / randN); ; ; diff --git a/qutip/",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1714#issuecomment-974625872
https://github.com/qutip/qutip/issues/1714#issuecomment-974625872:25898,Testability,Test,TestJCModelEvolution,25898," = reverse_cuthill_mckee(M, 1); @@ -120,7 +120,7 @@ def test_graph_weighted_matching():; A.data = np.ones(a_len); d = np.arange(0, 25) + 2; B = sp.diags(d, offsets=0, format='csc'); - A = A+B; + A += B; perm = np.random.permutation(25); perm2 = np.random.permutation(25); B = sp_permute(A, perm, perm2); diff --git a/qutip/tests/test_mcsolve.py b/qutip/tests/test_mcsolve.py; index f8567d0e..fe3f264c 100644; --- a/qutip/tests/test_mcsolve.py; +++ b/qutip/tests/test_mcsolve.py; @@ -173,7 +173,7 @@ def test_expectation_dtype(options):; a = qutip.tensor(qutip.destroy(focks), qutip.qeye(2)); sm = qutip.tensor(qutip.qeye(focks), qutip.sigmam()); H = 1j*a.dag()*sm + a; - H = H + H.dag(); + H += H.dag(); state = qutip.basis([focks, 2], [0, 1]); times = np.linspace(0, 10, 5); c_ops = [a, sm]; diff --git a/qutip/tests/test_mesolve.py b/qutip/tests/test_mesolve.py; index f17115ec..bc6cce59 100644; --- a/qutip/tests/test_mesolve.py; +++ b/qutip/tests/test_mesolve.py; @@ -238,8 +238,8 @@ class TestJCModelEvolution:; nc_ss, na_ss = self.jc_steadystate(; N, wc, wa, g, kappa, gamma, pump, psi0, use_rwa, tlist); ; - nc_ss = nc_ss * np.ones(np.shape(nc)); - na_ss = na_ss * np.ones(np.shape(na)); + nc_ss *= np.ones(np.shape(nc)); + na_ss *= np.ones(np.shape(na)); ; assert_(abs(nc[-1] - nc_ss[-1]) < 0.005, True); assert_(abs(na[-1] - na_ss[-1]) < 0.005, True); diff --git a/qutip/tests/test_qobj.py b/qutip/tests/test_qobj.py; index 11caa048..c875ef3f 100644; --- a/qutip/tests/test_qobj.py; +++ b/qutip/tests/test_qobj.py; @@ -244,7 +244,7 @@ def test_QobjAddition():; x1 = q + 5; x2 = 5 + q; ; - data = data + np.eye(5) * 5; + data += np.eye(5) * 5; assert np.all(x1.full() == data); assert np.all(x2.full() == data); ; @@ -298,7 +298,7 @@ def test_QobjDivision():; data = _random_not_singular(5); q = Qobj(data); randN = 10 * np.random.random(); - q = q / randN; + q /= randN; assert np.allclose(q.full(), data / randN); ; ; diff --git a/qutip/visualization.py b/qutip/visualization.py; index 47f40",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1714#issuecomment-974625872
https://github.com/qutip/qutip/issues/1714#issuecomment-974625872:26284,Testability,test,tests,26284,"py; index f8567d0e..fe3f264c 100644; --- a/qutip/tests/test_mcsolve.py; +++ b/qutip/tests/test_mcsolve.py; @@ -173,7 +173,7 @@ def test_expectation_dtype(options):; a = qutip.tensor(qutip.destroy(focks), qutip.qeye(2)); sm = qutip.tensor(qutip.qeye(focks), qutip.sigmam()); H = 1j*a.dag()*sm + a; - H = H + H.dag(); + H += H.dag(); state = qutip.basis([focks, 2], [0, 1]); times = np.linspace(0, 10, 5); c_ops = [a, sm]; diff --git a/qutip/tests/test_mesolve.py b/qutip/tests/test_mesolve.py; index f17115ec..bc6cce59 100644; --- a/qutip/tests/test_mesolve.py; +++ b/qutip/tests/test_mesolve.py; @@ -238,8 +238,8 @@ class TestJCModelEvolution:; nc_ss, na_ss = self.jc_steadystate(; N, wc, wa, g, kappa, gamma, pump, psi0, use_rwa, tlist); ; - nc_ss = nc_ss * np.ones(np.shape(nc)); - na_ss = na_ss * np.ones(np.shape(na)); + nc_ss *= np.ones(np.shape(nc)); + na_ss *= np.ones(np.shape(na)); ; assert_(abs(nc[-1] - nc_ss[-1]) < 0.005, True); assert_(abs(na[-1] - na_ss[-1]) < 0.005, True); diff --git a/qutip/tests/test_qobj.py b/qutip/tests/test_qobj.py; index 11caa048..c875ef3f 100644; --- a/qutip/tests/test_qobj.py; +++ b/qutip/tests/test_qobj.py; @@ -244,7 +244,7 @@ def test_QobjAddition():; x1 = q + 5; x2 = 5 + q; ; - data = data + np.eye(5) * 5; + data += np.eye(5) * 5; assert np.all(x1.full() == data); assert np.all(x2.full() == data); ; @@ -298,7 +298,7 @@ def test_QobjDivision():; data = _random_not_singular(5); q = Qobj(data); randN = 10 * np.random.random(); - q = q / randN; + q /= randN; assert np.allclose(q.full(), data / randN); ; ; diff --git a/qutip/visualization.py b/qutip/visualization.py; index 47f40fc1..21ef765e 100644; --- a/qutip/visualization.py; +++ b/qutip/visualization.py; @@ -416,7 +416,7 @@ def _stick_to_planes(stick, azim, ax, M, spacing):; Stick to xz and yz planes; """"""; if stick is True:; - azim = azim % 360; + azim %= 360; if 0 <= azim <= 90:; ax.set_ylim(1 - .5,); ax.set_xlim(1 - .5,); @@ -879,7 +879,7 @@ def plot_energy_levels(H_list, N=0, labels=Non",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1714#issuecomment-974625872
https://github.com/qutip/qutip/issues/1714#issuecomment-974625872:26311,Testability,test,tests,26311,"--- a/qutip/tests/test_mcsolve.py; +++ b/qutip/tests/test_mcsolve.py; @@ -173,7 +173,7 @@ def test_expectation_dtype(options):; a = qutip.tensor(qutip.destroy(focks), qutip.qeye(2)); sm = qutip.tensor(qutip.qeye(focks), qutip.sigmam()); H = 1j*a.dag()*sm + a; - H = H + H.dag(); + H += H.dag(); state = qutip.basis([focks, 2], [0, 1]); times = np.linspace(0, 10, 5); c_ops = [a, sm]; diff --git a/qutip/tests/test_mesolve.py b/qutip/tests/test_mesolve.py; index f17115ec..bc6cce59 100644; --- a/qutip/tests/test_mesolve.py; +++ b/qutip/tests/test_mesolve.py; @@ -238,8 +238,8 @@ class TestJCModelEvolution:; nc_ss, na_ss = self.jc_steadystate(; N, wc, wa, g, kappa, gamma, pump, psi0, use_rwa, tlist); ; - nc_ss = nc_ss * np.ones(np.shape(nc)); - na_ss = na_ss * np.ones(np.shape(na)); + nc_ss *= np.ones(np.shape(nc)); + na_ss *= np.ones(np.shape(na)); ; assert_(abs(nc[-1] - nc_ss[-1]) < 0.005, True); assert_(abs(na[-1] - na_ss[-1]) < 0.005, True); diff --git a/qutip/tests/test_qobj.py b/qutip/tests/test_qobj.py; index 11caa048..c875ef3f 100644; --- a/qutip/tests/test_qobj.py; +++ b/qutip/tests/test_qobj.py; @@ -244,7 +244,7 @@ def test_QobjAddition():; x1 = q + 5; x2 = 5 + q; ; - data = data + np.eye(5) * 5; + data += np.eye(5) * 5; assert np.all(x1.full() == data); assert np.all(x2.full() == data); ; @@ -298,7 +298,7 @@ def test_QobjDivision():; data = _random_not_singular(5); q = Qobj(data); randN = 10 * np.random.random(); - q = q / randN; + q /= randN; assert np.allclose(q.full(), data / randN); ; ; diff --git a/qutip/visualization.py b/qutip/visualization.py; index 47f40fc1..21ef765e 100644; --- a/qutip/visualization.py; +++ b/qutip/visualization.py; @@ -416,7 +416,7 @@ def _stick_to_planes(stick, azim, ax, M, spacing):; Stick to xz and yz planes; """"""; if stick is True:; - azim = azim % 360; + azim %= 360; if 0 <= azim <= 90:; ax.set_ylim(1 - .5,); ax.set_xlim(1 - .5,); @@ -879,7 +879,7 @@ def plot_energy_levels(H_list, N=0, labels=None, show_ylabels=False,; ; for H1 in H",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1714#issuecomment-974625872
https://github.com/qutip/qutip/issues/1714#issuecomment-974625872:26376,Testability,test,tests,26376,"t_mcsolve.py; @@ -173,7 +173,7 @@ def test_expectation_dtype(options):; a = qutip.tensor(qutip.destroy(focks), qutip.qeye(2)); sm = qutip.tensor(qutip.qeye(focks), qutip.sigmam()); H = 1j*a.dag()*sm + a; - H = H + H.dag(); + H += H.dag(); state = qutip.basis([focks, 2], [0, 1]); times = np.linspace(0, 10, 5); c_ops = [a, sm]; diff --git a/qutip/tests/test_mesolve.py b/qutip/tests/test_mesolve.py; index f17115ec..bc6cce59 100644; --- a/qutip/tests/test_mesolve.py; +++ b/qutip/tests/test_mesolve.py; @@ -238,8 +238,8 @@ class TestJCModelEvolution:; nc_ss, na_ss = self.jc_steadystate(; N, wc, wa, g, kappa, gamma, pump, psi0, use_rwa, tlist); ; - nc_ss = nc_ss * np.ones(np.shape(nc)); - na_ss = na_ss * np.ones(np.shape(na)); + nc_ss *= np.ones(np.shape(nc)); + na_ss *= np.ones(np.shape(na)); ; assert_(abs(nc[-1] - nc_ss[-1]) < 0.005, True); assert_(abs(na[-1] - na_ss[-1]) < 0.005, True); diff --git a/qutip/tests/test_qobj.py b/qutip/tests/test_qobj.py; index 11caa048..c875ef3f 100644; --- a/qutip/tests/test_qobj.py; +++ b/qutip/tests/test_qobj.py; @@ -244,7 +244,7 @@ def test_QobjAddition():; x1 = q + 5; x2 = 5 + q; ; - data = data + np.eye(5) * 5; + data += np.eye(5) * 5; assert np.all(x1.full() == data); assert np.all(x2.full() == data); ; @@ -298,7 +298,7 @@ def test_QobjDivision():; data = _random_not_singular(5); q = Qobj(data); randN = 10 * np.random.random(); - q = q / randN; + q /= randN; assert np.allclose(q.full(), data / randN); ; ; diff --git a/qutip/visualization.py b/qutip/visualization.py; index 47f40fc1..21ef765e 100644; --- a/qutip/visualization.py; +++ b/qutip/visualization.py; @@ -416,7 +416,7 @@ def _stick_to_planes(stick, azim, ax, M, spacing):; Stick to xz and yz planes; """"""; if stick is True:; - azim = azim % 360; + azim %= 360; if 0 <= azim <= 90:; ax.set_ylim(1 - .5,); ax.set_xlim(1 - .5,); @@ -879,7 +879,7 @@ def plot_energy_levels(H_list, N=0, labels=None, show_ylabels=False,; ; for H1 in H_list[1:]:; ; - H = H + H1; + H += H1; evals1 = H.eigene",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1714#issuecomment-974625872
https://github.com/qutip/qutip/issues/1714#issuecomment-974625872:26408,Testability,test,tests,26408,"est_expectation_dtype(options):; a = qutip.tensor(qutip.destroy(focks), qutip.qeye(2)); sm = qutip.tensor(qutip.qeye(focks), qutip.sigmam()); H = 1j*a.dag()*sm + a; - H = H + H.dag(); + H += H.dag(); state = qutip.basis([focks, 2], [0, 1]); times = np.linspace(0, 10, 5); c_ops = [a, sm]; diff --git a/qutip/tests/test_mesolve.py b/qutip/tests/test_mesolve.py; index f17115ec..bc6cce59 100644; --- a/qutip/tests/test_mesolve.py; +++ b/qutip/tests/test_mesolve.py; @@ -238,8 +238,8 @@ class TestJCModelEvolution:; nc_ss, na_ss = self.jc_steadystate(; N, wc, wa, g, kappa, gamma, pump, psi0, use_rwa, tlist); ; - nc_ss = nc_ss * np.ones(np.shape(nc)); - na_ss = na_ss * np.ones(np.shape(na)); + nc_ss *= np.ones(np.shape(nc)); + na_ss *= np.ones(np.shape(na)); ; assert_(abs(nc[-1] - nc_ss[-1]) < 0.005, True); assert_(abs(na[-1] - na_ss[-1]) < 0.005, True); diff --git a/qutip/tests/test_qobj.py b/qutip/tests/test_qobj.py; index 11caa048..c875ef3f 100644; --- a/qutip/tests/test_qobj.py; +++ b/qutip/tests/test_qobj.py; @@ -244,7 +244,7 @@ def test_QobjAddition():; x1 = q + 5; x2 = 5 + q; ; - data = data + np.eye(5) * 5; + data += np.eye(5) * 5; assert np.all(x1.full() == data); assert np.all(x2.full() == data); ; @@ -298,7 +298,7 @@ def test_QobjDivision():; data = _random_not_singular(5); q = Qobj(data); randN = 10 * np.random.random(); - q = q / randN; + q /= randN; assert np.allclose(q.full(), data / randN); ; ; diff --git a/qutip/visualization.py b/qutip/visualization.py; index 47f40fc1..21ef765e 100644; --- a/qutip/visualization.py; +++ b/qutip/visualization.py; @@ -416,7 +416,7 @@ def _stick_to_planes(stick, azim, ax, M, spacing):; Stick to xz and yz planes; """"""; if stick is True:; - azim = azim % 360; + azim %= 360; if 0 <= azim <= 90:; ax.set_ylim(1 - .5,); ax.set_xlim(1 - .5,); @@ -879,7 +879,7 @@ def plot_energy_levels(H_list, N=0, labels=None, show_ylabels=False,; ; for H1 in H_list[1:]:; ; - H = H + H1; + H += H1; evals1 = H.eigenenergies(); ; for e_idx, e in enumerate",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1714#issuecomment-974625872
https://github.com/qutip/qutip/issues/1714#issuecomment-974625872:26556,Testability,assert,assert,26556,"ype(options):; a = qutip.tensor(qutip.destroy(focks), qutip.qeye(2)); sm = qutip.tensor(qutip.qeye(focks), qutip.sigmam()); H = 1j*a.dag()*sm + a; - H = H + H.dag(); + H += H.dag(); state = qutip.basis([focks, 2], [0, 1]); times = np.linspace(0, 10, 5); c_ops = [a, sm]; diff --git a/qutip/tests/test_mesolve.py b/qutip/tests/test_mesolve.py; index f17115ec..bc6cce59 100644; --- a/qutip/tests/test_mesolve.py; +++ b/qutip/tests/test_mesolve.py; @@ -238,8 +238,8 @@ class TestJCModelEvolution:; nc_ss, na_ss = self.jc_steadystate(; N, wc, wa, g, kappa, gamma, pump, psi0, use_rwa, tlist); ; - nc_ss = nc_ss * np.ones(np.shape(nc)); - na_ss = na_ss * np.ones(np.shape(na)); + nc_ss *= np.ones(np.shape(nc)); + na_ss *= np.ones(np.shape(na)); ; assert_(abs(nc[-1] - nc_ss[-1]) < 0.005, True); assert_(abs(na[-1] - na_ss[-1]) < 0.005, True); diff --git a/qutip/tests/test_qobj.py b/qutip/tests/test_qobj.py; index 11caa048..c875ef3f 100644; --- a/qutip/tests/test_qobj.py; +++ b/qutip/tests/test_qobj.py; @@ -244,7 +244,7 @@ def test_QobjAddition():; x1 = q + 5; x2 = 5 + q; ; - data = data + np.eye(5) * 5; + data += np.eye(5) * 5; assert np.all(x1.full() == data); assert np.all(x2.full() == data); ; @@ -298,7 +298,7 @@ def test_QobjDivision():; data = _random_not_singular(5); q = Qobj(data); randN = 10 * np.random.random(); - q = q / randN; + q /= randN; assert np.allclose(q.full(), data / randN); ; ; diff --git a/qutip/visualization.py b/qutip/visualization.py; index 47f40fc1..21ef765e 100644; --- a/qutip/visualization.py; +++ b/qutip/visualization.py; @@ -416,7 +416,7 @@ def _stick_to_planes(stick, azim, ax, M, spacing):; Stick to xz and yz planes; """"""; if stick is True:; - azim = azim % 360; + azim %= 360; if 0 <= azim <= 90:; ax.set_ylim(1 - .5,); ax.set_xlim(1 - .5,); @@ -879,7 +879,7 @@ def plot_energy_levels(H_list, N=0, labels=None, show_ylabels=False,; ; for H1 in H_list[1:]:; ; - H = H + H1; + H += H1; evals1 = H.eigenenergies(); ; for e_idx, e in enumerate(evals1[:N]):; ```",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1714#issuecomment-974625872
https://github.com/qutip/qutip/issues/1714#issuecomment-974625872:26590,Testability,assert,assert,26590,"ype(options):; a = qutip.tensor(qutip.destroy(focks), qutip.qeye(2)); sm = qutip.tensor(qutip.qeye(focks), qutip.sigmam()); H = 1j*a.dag()*sm + a; - H = H + H.dag(); + H += H.dag(); state = qutip.basis([focks, 2], [0, 1]); times = np.linspace(0, 10, 5); c_ops = [a, sm]; diff --git a/qutip/tests/test_mesolve.py b/qutip/tests/test_mesolve.py; index f17115ec..bc6cce59 100644; --- a/qutip/tests/test_mesolve.py; +++ b/qutip/tests/test_mesolve.py; @@ -238,8 +238,8 @@ class TestJCModelEvolution:; nc_ss, na_ss = self.jc_steadystate(; N, wc, wa, g, kappa, gamma, pump, psi0, use_rwa, tlist); ; - nc_ss = nc_ss * np.ones(np.shape(nc)); - na_ss = na_ss * np.ones(np.shape(na)); + nc_ss *= np.ones(np.shape(nc)); + na_ss *= np.ones(np.shape(na)); ; assert_(abs(nc[-1] - nc_ss[-1]) < 0.005, True); assert_(abs(na[-1] - na_ss[-1]) < 0.005, True); diff --git a/qutip/tests/test_qobj.py b/qutip/tests/test_qobj.py; index 11caa048..c875ef3f 100644; --- a/qutip/tests/test_qobj.py; +++ b/qutip/tests/test_qobj.py; @@ -244,7 +244,7 @@ def test_QobjAddition():; x1 = q + 5; x2 = 5 + q; ; - data = data + np.eye(5) * 5; + data += np.eye(5) * 5; assert np.all(x1.full() == data); assert np.all(x2.full() == data); ; @@ -298,7 +298,7 @@ def test_QobjDivision():; data = _random_not_singular(5); q = Qobj(data); randN = 10 * np.random.random(); - q = q / randN; + q /= randN; assert np.allclose(q.full(), data / randN); ; ; diff --git a/qutip/visualization.py b/qutip/visualization.py; index 47f40fc1..21ef765e 100644; --- a/qutip/visualization.py; +++ b/qutip/visualization.py; @@ -416,7 +416,7 @@ def _stick_to_planes(stick, azim, ax, M, spacing):; Stick to xz and yz planes; """"""; if stick is True:; - azim = azim % 360; + azim %= 360; if 0 <= azim <= 90:; ax.set_ylim(1 - .5,); ax.set_xlim(1 - .5,); @@ -879,7 +879,7 @@ def plot_energy_levels(H_list, N=0, labels=None, show_ylabels=False,; ; for H1 in H_list[1:]:; ; - H = H + H1; + H += H1; evals1 = H.eigenenergies(); ; for e_idx, e in enumerate(evals1[:N]):; ```",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1714#issuecomment-974625872
https://github.com/qutip/qutip/issues/1714#issuecomment-974625872:26784,Testability,assert,assert,26784,"ype(options):; a = qutip.tensor(qutip.destroy(focks), qutip.qeye(2)); sm = qutip.tensor(qutip.qeye(focks), qutip.sigmam()); H = 1j*a.dag()*sm + a; - H = H + H.dag(); + H += H.dag(); state = qutip.basis([focks, 2], [0, 1]); times = np.linspace(0, 10, 5); c_ops = [a, sm]; diff --git a/qutip/tests/test_mesolve.py b/qutip/tests/test_mesolve.py; index f17115ec..bc6cce59 100644; --- a/qutip/tests/test_mesolve.py; +++ b/qutip/tests/test_mesolve.py; @@ -238,8 +238,8 @@ class TestJCModelEvolution:; nc_ss, na_ss = self.jc_steadystate(; N, wc, wa, g, kappa, gamma, pump, psi0, use_rwa, tlist); ; - nc_ss = nc_ss * np.ones(np.shape(nc)); - na_ss = na_ss * np.ones(np.shape(na)); + nc_ss *= np.ones(np.shape(nc)); + na_ss *= np.ones(np.shape(na)); ; assert_(abs(nc[-1] - nc_ss[-1]) < 0.005, True); assert_(abs(na[-1] - na_ss[-1]) < 0.005, True); diff --git a/qutip/tests/test_qobj.py b/qutip/tests/test_qobj.py; index 11caa048..c875ef3f 100644; --- a/qutip/tests/test_qobj.py; +++ b/qutip/tests/test_qobj.py; @@ -244,7 +244,7 @@ def test_QobjAddition():; x1 = q + 5; x2 = 5 + q; ; - data = data + np.eye(5) * 5; + data += np.eye(5) * 5; assert np.all(x1.full() == data); assert np.all(x2.full() == data); ; @@ -298,7 +298,7 @@ def test_QobjDivision():; data = _random_not_singular(5); q = Qobj(data); randN = 10 * np.random.random(); - q = q / randN; + q /= randN; assert np.allclose(q.full(), data / randN); ; ; diff --git a/qutip/visualization.py b/qutip/visualization.py; index 47f40fc1..21ef765e 100644; --- a/qutip/visualization.py; +++ b/qutip/visualization.py; @@ -416,7 +416,7 @@ def _stick_to_planes(stick, azim, ax, M, spacing):; Stick to xz and yz planes; """"""; if stick is True:; - azim = azim % 360; + azim %= 360; if 0 <= azim <= 90:; ax.set_ylim(1 - .5,); ax.set_xlim(1 - .5,); @@ -879,7 +879,7 @@ def plot_energy_levels(H_list, N=0, labels=None, show_ylabels=False,; ; for H1 in H_list[1:]:; ; - H = H + H1; + H += H1; evals1 = H.eigenenergies(); ; for e_idx, e in enumerate(evals1[:N]):; ```",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1714#issuecomment-974625872
https://github.com/qutip/qutip/pull/1715#issuecomment-972959530:78,Deployability,install,installation,78,"I realised it was not necessary for me to include setuptools and wheel in the installation. I wonder if this is because setuptools is being taken from the system installation instead of the virtualenv? . Also, I noticed that requirements.txt does not include stuptools nor wheel. Should I include them?",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1715#issuecomment-972959530
https://github.com/qutip/qutip/pull/1715#issuecomment-972959530:162,Deployability,install,installation,162,"I realised it was not necessary for me to include setuptools and wheel in the installation. I wonder if this is because setuptools is being taken from the system installation instead of the virtualenv? . Also, I noticed that requirements.txt does not include stuptools nor wheel. Should I include them?",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1715#issuecomment-972959530
https://github.com/qutip/qutip/pull/1715#issuecomment-973109892:244,Integrability,depend,dependency,244,"`requirements.txt` has no special meaning at all so it doesn't really matter, but typically it's used for runtime, not build time, so it doesn't need `setuptools` or `wheel`. `packaging` is required at both, but I had actually thought it was a dependency of `setuptools`. Still, we use it explicitly, so best add it. The actual main source-of-truth runtime requirements are in `setup.cfg`, and the build requirements are in `pyproject.toml`.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1715#issuecomment-973109892
https://github.com/qutip/qutip/pull/1715#issuecomment-973123214:91,Availability,error,error,91,"Thank you Jake for taking a quick look!; I checked once more and the following produces an error (used in an ""empty"" virtual environment):; ```; > pip install setuptools wheel 'cython>=0.29.20' 'numpy>=1.16.6,<1.20' 'scipy>=1.0'; > python setup.py develop. Traceback (most recent call last):; File ""/home/kaladin/Documents/git/qutip/qutip4/setup.py"", line 13, in <module>; import packaging.version; ModuleNotFoundError: No module named 'packaging'; ```; So I think `packaging` it is not included with `setuptools`. . > `requirements.txt` has no special meaning at all so it doesn't really matter,; Lets not add wheels and setuptools to the requirements then. Updating it with the latest dependency versions in setup.cfg dependencies should be fine though.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1715#issuecomment-973123214
https://github.com/qutip/qutip/pull/1715#issuecomment-973123214:151,Deployability,install,install,151,"Thank you Jake for taking a quick look!; I checked once more and the following produces an error (used in an ""empty"" virtual environment):; ```; > pip install setuptools wheel 'cython>=0.29.20' 'numpy>=1.16.6,<1.20' 'scipy>=1.0'; > python setup.py develop. Traceback (most recent call last):; File ""/home/kaladin/Documents/git/qutip/qutip4/setup.py"", line 13, in <module>; import packaging.version; ModuleNotFoundError: No module named 'packaging'; ```; So I think `packaging` it is not included with `setuptools`. . > `requirements.txt` has no special meaning at all so it doesn't really matter,; Lets not add wheels and setuptools to the requirements then. Updating it with the latest dependency versions in setup.cfg dependencies should be fine though.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1715#issuecomment-973123214
https://github.com/qutip/qutip/pull/1715#issuecomment-973123214:687,Integrability,depend,dependency,687,"Thank you Jake for taking a quick look!; I checked once more and the following produces an error (used in an ""empty"" virtual environment):; ```; > pip install setuptools wheel 'cython>=0.29.20' 'numpy>=1.16.6,<1.20' 'scipy>=1.0'; > python setup.py develop. Traceback (most recent call last):; File ""/home/kaladin/Documents/git/qutip/qutip4/setup.py"", line 13, in <module>; import packaging.version; ModuleNotFoundError: No module named 'packaging'; ```; So I think `packaging` it is not included with `setuptools`. . > `requirements.txt` has no special meaning at all so it doesn't really matter,; Lets not add wheels and setuptools to the requirements then. Updating it with the latest dependency versions in setup.cfg dependencies should be fine though.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1715#issuecomment-973123214
https://github.com/qutip/qutip/pull/1715#issuecomment-973123214:720,Integrability,depend,dependencies,720,"Thank you Jake for taking a quick look!; I checked once more and the following produces an error (used in an ""empty"" virtual environment):; ```; > pip install setuptools wheel 'cython>=0.29.20' 'numpy>=1.16.6,<1.20' 'scipy>=1.0'; > python setup.py develop. Traceback (most recent call last):; File ""/home/kaladin/Documents/git/qutip/qutip4/setup.py"", line 13, in <module>; import packaging.version; ModuleNotFoundError: No module named 'packaging'; ```; So I think `packaging` it is not included with `setuptools`. . > `requirements.txt` has no special meaning at all so it doesn't really matter,; Lets not add wheels and setuptools to the requirements then. Updating it with the latest dependency versions in setup.cfg dependencies should be fine though.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1715#issuecomment-973123214
https://github.com/qutip/qutip/pull/1715#issuecomment-973125463:4,Testability,test,test,4,"The test for python 3.6 seems to fail at coveralls, not sure why though. It may not be related as the rest of the tests do not fail. Could it be rerun?",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1715#issuecomment-973125463
https://github.com/qutip/qutip/pull/1715#issuecomment-973125463:114,Testability,test,tests,114,"The test for python 3.6 seems to fail at coveralls, not sure why though. It may not be related as the rest of the tests do not fail. Could it be rerun?",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1715#issuecomment-973125463
https://github.com/qutip/qutip/pull/1715#issuecomment-973127486:238,Availability,fault,fault,238,"Sounds good to me. Yeah, even if `packaging` _were_ in `setuptools`, it'd still be an explicit dependency of ours, so you're right to put it in, thanks. Yeah, that coveralls thing just looked like a network timeout on their side. Not the fault of this PR.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1715#issuecomment-973127486
https://github.com/qutip/qutip/pull/1715#issuecomment-973127486:95,Integrability,depend,dependency,95,"Sounds good to me. Yeah, even if `packaging` _were_ in `setuptools`, it'd still be an explicit dependency of ours, so you're right to put it in, thanks. Yeah, that coveralls thing just looked like a network timeout on their side. Not the fault of this PR.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1715#issuecomment-973127486
https://github.com/qutip/qutip/pull/1715#issuecomment-973127486:207,Safety,timeout,timeout,207,"Sounds good to me. Yeah, even if `packaging` _were_ in `setuptools`, it'd still be an explicit dependency of ours, so you're right to put it in, thanks. Yeah, that coveralls thing just looked like a network timeout on their side. Not the fault of this PR.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1715#issuecomment-973127486
https://github.com/qutip/qutip/issues/1716#issuecomment-974502454:190,Deployability,release,release,190,"@AGaliciaMartinez @RobHam99 I will put in a small vote that we leave sorting this out for QuTiP 5 (i.e. the dev.major) branch, where I suspect it has been sorted out already. The only QuTiP release it could go into before 5 would be 4.7 and I'd like to avoid doing too many minor clean-ups in 4.7 because I want 4.7 to just work nicely for existing users before the big just to 5. Happy to consider exceptions to that policy on a case by case basis though.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1716#issuecomment-974502454
https://github.com/qutip/qutip/issues/1716#issuecomment-974502454:253,Safety,avoid,avoid,253,"@AGaliciaMartinez @RobHam99 I will put in a small vote that we leave sorting this out for QuTiP 5 (i.e. the dev.major) branch, where I suspect it has been sorted out already. The only QuTiP release it could go into before 5 would be 4.7 and I'd like to avoid doing too many minor clean-ups in 4.7 because I want 4.7 to just work nicely for existing users before the big just to 5. Happy to consider exceptions to that policy on a case by case basis though.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1716#issuecomment-974502454
https://github.com/qutip/qutip/issues/1716#issuecomment-974810877:57,Integrability,message,message,57,"To clarify, you want me to implement something like this message:. ```python; if 'c_ops' in kwargs:; warnings.warn(""please use c_op_list argument in current version. c_op_list will be deprecated in favour of c_ops in future versions.""); c_ops = c_op_list; ```. but not change 'c_op_list' to 'c_ops'? Then you want me to change it in the dev.major branch?. Thanks",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1716#issuecomment-974810877
https://github.com/qutip/qutip/issues/1716#issuecomment-981512742:261,Safety,avoid,avoid,261,"Hey @RobHam99. I have talked today with @hodgestar and we agreed that, since `**kwargs` is only used to pass the argument `num_cpus`, we think it is best to raise an _error_ (`TypeError`) when kwargs contains a key that is not `num_cpus`. This should hopefully avoid the same confusion to happen again with propagator, but we should definitely try to get the naming consistent for the new QuTiP version that is under active development. @RobHam99, are you still interested in opening a Pull Request for this issue?",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1716#issuecomment-981512742
https://github.com/qutip/qutip/issues/1719#issuecomment-979425060:114,Testability,test,tests,114,"The `lindblad_dissipator` not being trace preserving when `b` is supplied is definitively strange and there is no tests for it being right when `a!=b` is certainly worrying. However I was told that it looked right like this, so I am not sure if we should change it...; Maybe removing `b` and letting more complex variant to be constructed manually would result in less problems.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1719#issuecomment-979425060
https://github.com/qutip/qutip/issues/1719#issuecomment-979432001:95,Testability,test,test,95,@jonahpeter Do you perhaps have some specific `a` and `b` in mind that we could use to write a test case?,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1719#issuecomment-979432001
https://github.com/qutip/qutip/issues/1719#issuecomment-1062919358:964,Testability,test,tests,964,"@bopardikarsoham It can definitely still be looked at, but the situation needs to be untangled before any code change is made:. - If one is using Lindblad operators (see the equation with `L_i` on https://en.wikipedia.org/wiki/Lindbladian) then `a` and `b` are the same and the code is currently correct.; - If one is using some other set of basis operators `A_n` for the bounder operators on `H`, then you will need to include terms for both `n, m` and `m, n` and the sum of the those two terms will again be the same for the current code and the proposed change. So the physics will not change from what it is now if we make the proposed change and it appears that how the terms are organized within the larger sum is a convention. So the question is whether there is a standard convention to follow or not, and I don't know the answer. Step 1 is probably to find some textbooks or canonical references which make the choice clear. Step 2 would be to write some tests for the behaviour in the case where `a != b`.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1719#issuecomment-1062919358
https://github.com/qutip/qutip/issues/1719#issuecomment-1062919358:927,Usability,clear,clear,927,"@bopardikarsoham It can definitely still be looked at, but the situation needs to be untangled before any code change is made:. - If one is using Lindblad operators (see the equation with `L_i` on https://en.wikipedia.org/wiki/Lindbladian) then `a` and `b` are the same and the code is currently correct.; - If one is using some other set of basis operators `A_n` for the bounder operators on `H`, then you will need to include terms for both `n, m` and `m, n` and the sum of the those two terms will again be the same for the current code and the proposed change. So the physics will not change from what it is now if we make the proposed change and it appears that how the terms are organized within the larger sum is a convention. So the question is whether there is a standard convention to follow or not, and I don't know the answer. Step 1 is probably to find some textbooks or canonical references which make the choice clear. Step 2 would be to write some tests for the behaviour in the case where `a != b`.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1719#issuecomment-1062919358
https://github.com/qutip/qutip/issues/1720#issuecomment-974827633:58,Testability,test,tests,58,"Incidently, a previously built qutip successfully [passes tests ](https://ci.debian.net/data/autopkgtest/testing/amd64/q/qutip/16842341/log.gz)using numpy 1.21. Should the numpy<1.20 cap just be dropped?",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1720#issuecomment-974827633
https://github.com/qutip/qutip/issues/1720#issuecomment-974827633:105,Testability,test,testing,105,"Incidently, a previously built qutip successfully [passes tests ](https://ci.debian.net/data/autopkgtest/testing/amd64/q/qutip/16842341/log.gz)using numpy 1.21. Should the numpy<1.20 cap just be dropped?",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1720#issuecomment-974827633
https://github.com/qutip/qutip/issues/1720#issuecomment-974827633:136,Testability,log,log,136,"Incidently, a previously built qutip successfully [passes tests ](https://ci.debian.net/data/autopkgtest/testing/amd64/q/qutip/16842341/log.gz)using numpy 1.21. Should the numpy<1.20 cap just be dropped?",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1720#issuecomment-974827633
https://github.com/qutip/qutip/issues/1720#issuecomment-974830497:860,Availability,fail-safe,fail-safe,860,"We can in theory drop that requirement for users - it was there in the immediate aftermath of the Numpy 1.20 release, which broke C-ABI compatibility with previous versions, and we had a couple of problems with people building against Numpy 1.20 but trying to run against a prior version. Our CI and release versions will still all need to be built against Numpy 1.16 (or our minimum supported runtime Numpy) as the lowest common denominator until we drop support for all Numpy releases before 1.20, but we enforce that in our build pipelines anyway. Just to be clear (though I think you knew this):. > Can qutip be updated to run with current versions of Numpy?. QuTiP already runs correctly against Numpy 1.20 and Numpy 1.21, and its runtime requirements on Numpy are uncapped. It's just building from source that'll fail, and that was originally a sort of ""fail-safe"" mechanism. Also `pip install -e .` should automatically do build isolation for you, including installing all the build requirements into a temporary virtual environment, so it should have just worked here. Calling `setup.py develop` directly is kind of out-dated now, though it can still be useful if you're planning on doing Cython development; `pip`'s isolation actually usually means that the Cython compiler can't detect changes any more, so it always needs to rebuild everything. `setup.py develop`, because of its much lower-level status, leaves the source and extension-library files well enough untouched that it can do incremental compilation. If you're not doing Cython development (only Python), `pip install -e .` is much better.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1720#issuecomment-974830497
https://github.com/qutip/qutip/issues/1720#issuecomment-974830497:109,Deployability,release,release,109,"We can in theory drop that requirement for users - it was there in the immediate aftermath of the Numpy 1.20 release, which broke C-ABI compatibility with previous versions, and we had a couple of problems with people building against Numpy 1.20 but trying to run against a prior version. Our CI and release versions will still all need to be built against Numpy 1.16 (or our minimum supported runtime Numpy) as the lowest common denominator until we drop support for all Numpy releases before 1.20, but we enforce that in our build pipelines anyway. Just to be clear (though I think you knew this):. > Can qutip be updated to run with current versions of Numpy?. QuTiP already runs correctly against Numpy 1.20 and Numpy 1.21, and its runtime requirements on Numpy are uncapped. It's just building from source that'll fail, and that was originally a sort of ""fail-safe"" mechanism. Also `pip install -e .` should automatically do build isolation for you, including installing all the build requirements into a temporary virtual environment, so it should have just worked here. Calling `setup.py develop` directly is kind of out-dated now, though it can still be useful if you're planning on doing Cython development; `pip`'s isolation actually usually means that the Cython compiler can't detect changes any more, so it always needs to rebuild everything. `setup.py develop`, because of its much lower-level status, leaves the source and extension-library files well enough untouched that it can do incremental compilation. If you're not doing Cython development (only Python), `pip install -e .` is much better.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1720#issuecomment-974830497
https://github.com/qutip/qutip/issues/1720#issuecomment-974830497:300,Deployability,release,release,300,"We can in theory drop that requirement for users - it was there in the immediate aftermath of the Numpy 1.20 release, which broke C-ABI compatibility with previous versions, and we had a couple of problems with people building against Numpy 1.20 but trying to run against a prior version. Our CI and release versions will still all need to be built against Numpy 1.16 (or our minimum supported runtime Numpy) as the lowest common denominator until we drop support for all Numpy releases before 1.20, but we enforce that in our build pipelines anyway. Just to be clear (though I think you knew this):. > Can qutip be updated to run with current versions of Numpy?. QuTiP already runs correctly against Numpy 1.20 and Numpy 1.21, and its runtime requirements on Numpy are uncapped. It's just building from source that'll fail, and that was originally a sort of ""fail-safe"" mechanism. Also `pip install -e .` should automatically do build isolation for you, including installing all the build requirements into a temporary virtual environment, so it should have just worked here. Calling `setup.py develop` directly is kind of out-dated now, though it can still be useful if you're planning on doing Cython development; `pip`'s isolation actually usually means that the Cython compiler can't detect changes any more, so it always needs to rebuild everything. `setup.py develop`, because of its much lower-level status, leaves the source and extension-library files well enough untouched that it can do incremental compilation. If you're not doing Cython development (only Python), `pip install -e .` is much better.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1720#issuecomment-974830497
https://github.com/qutip/qutip/issues/1720#issuecomment-974830497:478,Deployability,release,releases,478,"We can in theory drop that requirement for users - it was there in the immediate aftermath of the Numpy 1.20 release, which broke C-ABI compatibility with previous versions, and we had a couple of problems with people building against Numpy 1.20 but trying to run against a prior version. Our CI and release versions will still all need to be built against Numpy 1.16 (or our minimum supported runtime Numpy) as the lowest common denominator until we drop support for all Numpy releases before 1.20, but we enforce that in our build pipelines anyway. Just to be clear (though I think you knew this):. > Can qutip be updated to run with current versions of Numpy?. QuTiP already runs correctly against Numpy 1.20 and Numpy 1.21, and its runtime requirements on Numpy are uncapped. It's just building from source that'll fail, and that was originally a sort of ""fail-safe"" mechanism. Also `pip install -e .` should automatically do build isolation for you, including installing all the build requirements into a temporary virtual environment, so it should have just worked here. Calling `setup.py develop` directly is kind of out-dated now, though it can still be useful if you're planning on doing Cython development; `pip`'s isolation actually usually means that the Cython compiler can't detect changes any more, so it always needs to rebuild everything. `setup.py develop`, because of its much lower-level status, leaves the source and extension-library files well enough untouched that it can do incremental compilation. If you're not doing Cython development (only Python), `pip install -e .` is much better.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1720#issuecomment-974830497
https://github.com/qutip/qutip/issues/1720#issuecomment-974830497:533,Deployability,pipeline,pipelines,533,"We can in theory drop that requirement for users - it was there in the immediate aftermath of the Numpy 1.20 release, which broke C-ABI compatibility with previous versions, and we had a couple of problems with people building against Numpy 1.20 but trying to run against a prior version. Our CI and release versions will still all need to be built against Numpy 1.16 (or our minimum supported runtime Numpy) as the lowest common denominator until we drop support for all Numpy releases before 1.20, but we enforce that in our build pipelines anyway. Just to be clear (though I think you knew this):. > Can qutip be updated to run with current versions of Numpy?. QuTiP already runs correctly against Numpy 1.20 and Numpy 1.21, and its runtime requirements on Numpy are uncapped. It's just building from source that'll fail, and that was originally a sort of ""fail-safe"" mechanism. Also `pip install -e .` should automatically do build isolation for you, including installing all the build requirements into a temporary virtual environment, so it should have just worked here. Calling `setup.py develop` directly is kind of out-dated now, though it can still be useful if you're planning on doing Cython development; `pip`'s isolation actually usually means that the Cython compiler can't detect changes any more, so it always needs to rebuild everything. `setup.py develop`, because of its much lower-level status, leaves the source and extension-library files well enough untouched that it can do incremental compilation. If you're not doing Cython development (only Python), `pip install -e .` is much better.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1720#issuecomment-974830497
https://github.com/qutip/qutip/issues/1720#issuecomment-974830497:616,Deployability,update,updated,616,"We can in theory drop that requirement for users - it was there in the immediate aftermath of the Numpy 1.20 release, which broke C-ABI compatibility with previous versions, and we had a couple of problems with people building against Numpy 1.20 but trying to run against a prior version. Our CI and release versions will still all need to be built against Numpy 1.16 (or our minimum supported runtime Numpy) as the lowest common denominator until we drop support for all Numpy releases before 1.20, but we enforce that in our build pipelines anyway. Just to be clear (though I think you knew this):. > Can qutip be updated to run with current versions of Numpy?. QuTiP already runs correctly against Numpy 1.20 and Numpy 1.21, and its runtime requirements on Numpy are uncapped. It's just building from source that'll fail, and that was originally a sort of ""fail-safe"" mechanism. Also `pip install -e .` should automatically do build isolation for you, including installing all the build requirements into a temporary virtual environment, so it should have just worked here. Calling `setup.py develop` directly is kind of out-dated now, though it can still be useful if you're planning on doing Cython development; `pip`'s isolation actually usually means that the Cython compiler can't detect changes any more, so it always needs to rebuild everything. `setup.py develop`, because of its much lower-level status, leaves the source and extension-library files well enough untouched that it can do incremental compilation. If you're not doing Cython development (only Python), `pip install -e .` is much better.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1720#issuecomment-974830497
https://github.com/qutip/qutip/issues/1720#issuecomment-974830497:892,Deployability,install,install,892,"We can in theory drop that requirement for users - it was there in the immediate aftermath of the Numpy 1.20 release, which broke C-ABI compatibility with previous versions, and we had a couple of problems with people building against Numpy 1.20 but trying to run against a prior version. Our CI and release versions will still all need to be built against Numpy 1.16 (or our minimum supported runtime Numpy) as the lowest common denominator until we drop support for all Numpy releases before 1.20, but we enforce that in our build pipelines anyway. Just to be clear (though I think you knew this):. > Can qutip be updated to run with current versions of Numpy?. QuTiP already runs correctly against Numpy 1.20 and Numpy 1.21, and its runtime requirements on Numpy are uncapped. It's just building from source that'll fail, and that was originally a sort of ""fail-safe"" mechanism. Also `pip install -e .` should automatically do build isolation for you, including installing all the build requirements into a temporary virtual environment, so it should have just worked here. Calling `setup.py develop` directly is kind of out-dated now, though it can still be useful if you're planning on doing Cython development; `pip`'s isolation actually usually means that the Cython compiler can't detect changes any more, so it always needs to rebuild everything. `setup.py develop`, because of its much lower-level status, leaves the source and extension-library files well enough untouched that it can do incremental compilation. If you're not doing Cython development (only Python), `pip install -e .` is much better.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1720#issuecomment-974830497
https://github.com/qutip/qutip/issues/1720#issuecomment-974830497:965,Deployability,install,installing,965,"We can in theory drop that requirement for users - it was there in the immediate aftermath of the Numpy 1.20 release, which broke C-ABI compatibility with previous versions, and we had a couple of problems with people building against Numpy 1.20 but trying to run against a prior version. Our CI and release versions will still all need to be built against Numpy 1.16 (or our minimum supported runtime Numpy) as the lowest common denominator until we drop support for all Numpy releases before 1.20, but we enforce that in our build pipelines anyway. Just to be clear (though I think you knew this):. > Can qutip be updated to run with current versions of Numpy?. QuTiP already runs correctly against Numpy 1.20 and Numpy 1.21, and its runtime requirements on Numpy are uncapped. It's just building from source that'll fail, and that was originally a sort of ""fail-safe"" mechanism. Also `pip install -e .` should automatically do build isolation for you, including installing all the build requirements into a temporary virtual environment, so it should have just worked here. Calling `setup.py develop` directly is kind of out-dated now, though it can still be useful if you're planning on doing Cython development; `pip`'s isolation actually usually means that the Cython compiler can't detect changes any more, so it always needs to rebuild everything. `setup.py develop`, because of its much lower-level status, leaves the source and extension-library files well enough untouched that it can do incremental compilation. If you're not doing Cython development (only Python), `pip install -e .` is much better.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1720#issuecomment-974830497
https://github.com/qutip/qutip/issues/1720#issuecomment-974830497:1583,Deployability,install,install,1583,"We can in theory drop that requirement for users - it was there in the immediate aftermath of the Numpy 1.20 release, which broke C-ABI compatibility with previous versions, and we had a couple of problems with people building against Numpy 1.20 but trying to run against a prior version. Our CI and release versions will still all need to be built against Numpy 1.16 (or our minimum supported runtime Numpy) as the lowest common denominator until we drop support for all Numpy releases before 1.20, but we enforce that in our build pipelines anyway. Just to be clear (though I think you knew this):. > Can qutip be updated to run with current versions of Numpy?. QuTiP already runs correctly against Numpy 1.20 and Numpy 1.21, and its runtime requirements on Numpy are uncapped. It's just building from source that'll fail, and that was originally a sort of ""fail-safe"" mechanism. Also `pip install -e .` should automatically do build isolation for you, including installing all the build requirements into a temporary virtual environment, so it should have just worked here. Calling `setup.py develop` directly is kind of out-dated now, though it can still be useful if you're planning on doing Cython development; `pip`'s isolation actually usually means that the Cython compiler can't detect changes any more, so it always needs to rebuild everything. `setup.py develop`, because of its much lower-level status, leaves the source and extension-library files well enough untouched that it can do incremental compilation. If you're not doing Cython development (only Python), `pip install -e .` is much better.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1720#issuecomment-974830497
https://github.com/qutip/qutip/issues/1720#issuecomment-974830497:865,Safety,safe,safe,865,"We can in theory drop that requirement for users - it was there in the immediate aftermath of the Numpy 1.20 release, which broke C-ABI compatibility with previous versions, and we had a couple of problems with people building against Numpy 1.20 but trying to run against a prior version. Our CI and release versions will still all need to be built against Numpy 1.16 (or our minimum supported runtime Numpy) as the lowest common denominator until we drop support for all Numpy releases before 1.20, but we enforce that in our build pipelines anyway. Just to be clear (though I think you knew this):. > Can qutip be updated to run with current versions of Numpy?. QuTiP already runs correctly against Numpy 1.20 and Numpy 1.21, and its runtime requirements on Numpy are uncapped. It's just building from source that'll fail, and that was originally a sort of ""fail-safe"" mechanism. Also `pip install -e .` should automatically do build isolation for you, including installing all the build requirements into a temporary virtual environment, so it should have just worked here. Calling `setup.py develop` directly is kind of out-dated now, though it can still be useful if you're planning on doing Cython development; `pip`'s isolation actually usually means that the Cython compiler can't detect changes any more, so it always needs to rebuild everything. `setup.py develop`, because of its much lower-level status, leaves the source and extension-library files well enough untouched that it can do incremental compilation. If you're not doing Cython development (only Python), `pip install -e .` is much better.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1720#issuecomment-974830497
https://github.com/qutip/qutip/issues/1720#issuecomment-974830497:1289,Safety,detect,detect,1289,"We can in theory drop that requirement for users - it was there in the immediate aftermath of the Numpy 1.20 release, which broke C-ABI compatibility with previous versions, and we had a couple of problems with people building against Numpy 1.20 but trying to run against a prior version. Our CI and release versions will still all need to be built against Numpy 1.16 (or our minimum supported runtime Numpy) as the lowest common denominator until we drop support for all Numpy releases before 1.20, but we enforce that in our build pipelines anyway. Just to be clear (though I think you knew this):. > Can qutip be updated to run with current versions of Numpy?. QuTiP already runs correctly against Numpy 1.20 and Numpy 1.21, and its runtime requirements on Numpy are uncapped. It's just building from source that'll fail, and that was originally a sort of ""fail-safe"" mechanism. Also `pip install -e .` should automatically do build isolation for you, including installing all the build requirements into a temporary virtual environment, so it should have just worked here. Calling `setup.py develop` directly is kind of out-dated now, though it can still be useful if you're planning on doing Cython development; `pip`'s isolation actually usually means that the Cython compiler can't detect changes any more, so it always needs to rebuild everything. `setup.py develop`, because of its much lower-level status, leaves the source and extension-library files well enough untouched that it can do incremental compilation. If you're not doing Cython development (only Python), `pip install -e .` is much better.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1720#issuecomment-974830497
https://github.com/qutip/qutip/issues/1720#issuecomment-974830497:562,Usability,clear,clear,562,"We can in theory drop that requirement for users - it was there in the immediate aftermath of the Numpy 1.20 release, which broke C-ABI compatibility with previous versions, and we had a couple of problems with people building against Numpy 1.20 but trying to run against a prior version. Our CI and release versions will still all need to be built against Numpy 1.16 (or our minimum supported runtime Numpy) as the lowest common denominator until we drop support for all Numpy releases before 1.20, but we enforce that in our build pipelines anyway. Just to be clear (though I think you knew this):. > Can qutip be updated to run with current versions of Numpy?. QuTiP already runs correctly against Numpy 1.20 and Numpy 1.21, and its runtime requirements on Numpy are uncapped. It's just building from source that'll fail, and that was originally a sort of ""fail-safe"" mechanism. Also `pip install -e .` should automatically do build isolation for you, including installing all the build requirements into a temporary virtual environment, so it should have just worked here. Calling `setup.py develop` directly is kind of out-dated now, though it can still be useful if you're planning on doing Cython development; `pip`'s isolation actually usually means that the Cython compiler can't detect changes any more, so it always needs to rebuild everything. `setup.py develop`, because of its much lower-level status, leaves the source and extension-library files well enough untouched that it can do incremental compilation. If you're not doing Cython development (only Python), `pip install -e .` is much better.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1720#issuecomment-974830497
https://github.com/qutip/qutip/issues/1720#issuecomment-974835138:248,Deployability,install,install,248,"Thanks Jake. I've raised the Issue in regards to building deb packages from source (https://bugs.debian.org/cgi-bin/bugreport.cgi?bug=999517), so pip can't be used in that context. The Debian build machinery invokes `python3 setup.py {config,build,install}` not `setup.py develop`, c.f. past build log with numpy 1.19 [here](https://buildd.debian.org/status/fetch.php?pkg=qutip&arch=amd64&ver=4.6.2-2&stamp=1630423818&raw=0).",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1720#issuecomment-974835138
https://github.com/qutip/qutip/issues/1720#issuecomment-974835138:235,Modifiability,config,config,235,"Thanks Jake. I've raised the Issue in regards to building deb packages from source (https://bugs.debian.org/cgi-bin/bugreport.cgi?bug=999517), so pip can't be used in that context. The Debian build machinery invokes `python3 setup.py {config,build,install}` not `setup.py develop`, c.f. past build log with numpy 1.19 [here](https://buildd.debian.org/status/fetch.php?pkg=qutip&arch=amd64&ver=4.6.2-2&stamp=1630423818&raw=0).",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1720#issuecomment-974835138
https://github.com/qutip/qutip/issues/1720#issuecomment-974835138:298,Testability,log,log,298,"Thanks Jake. I've raised the Issue in regards to building deb packages from source (https://bugs.debian.org/cgi-bin/bugreport.cgi?bug=999517), so pip can't be used in that context. The Debian build machinery invokes `python3 setup.py {config,build,install}` not `setup.py develop`, c.f. past build log with numpy 1.19 [here](https://buildd.debian.org/status/fetch.php?pkg=qutip&arch=amd64&ver=4.6.2-2&stamp=1630423818&raw=0).",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1720#issuecomment-974835138
https://github.com/qutip/qutip/issues/1720#issuecomment-976973209:238,Deployability,release,released,238,"Oh, you're right Simon - I think I was just thinking about conda-forge, where we have the pinning files. The build process may need updating a bit now - I pinned cibuildwheel to a pre-2 version, but since I wrote that, cibuildwheel 2 was released, and should generally work fine. You may want to look at things like `CIBW_DEPENDENCY_VERSIONS` to set constraints on the versions of Numpy and Scipy used in the build to maintain compatibility perhaps?. @drew-parsons: will Debian's version requirements recognise that a version of QuTiP built against Numpy 1.20 can no longer support Numpys before 1.20? Anything that compiles C extensions against Numpy will have that potential issue.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1720#issuecomment-976973209
https://github.com/qutip/qutip/issues/1720#issuecomment-977842255:23,Integrability,depend,dependencies,23,We can set up packages dependencies easily enough. It's already done automatically in fact. Our numpy package provides a versioned python3-numpy-abi (currently python3-numpy-abi9) and an debhelper dh_numpy3 tool which sets the versioned dependency for dependent packages at build time,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1720#issuecomment-977842255
https://github.com/qutip/qutip/issues/1720#issuecomment-977842255:237,Integrability,depend,dependency,237,We can set up packages dependencies easily enough. It's already done automatically in fact. Our numpy package provides a versioned python3-numpy-abi (currently python3-numpy-abi9) and an debhelper dh_numpy3 tool which sets the versioned dependency for dependent packages at build time,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1720#issuecomment-977842255
https://github.com/qutip/qutip/issues/1720#issuecomment-977842255:252,Integrability,depend,dependent,252,We can set up packages dependencies easily enough. It's already done automatically in fact. Our numpy package provides a versioned python3-numpy-abi (currently python3-numpy-abi9) and an debhelper dh_numpy3 tool which sets the versioned dependency for dependent packages at build time,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1720#issuecomment-977842255
https://github.com/qutip/qutip/issues/1720#issuecomment-1006101738:22,Deployability,patch,patch,22,"I tested the PR #1747 patch against 4.6.2. It's working fine. Building against numpy 1.21.5, and building and passing tests with python3.10.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1720#issuecomment-1006101738
https://github.com/qutip/qutip/issues/1720#issuecomment-1006101738:2,Testability,test,tested,2,"I tested the PR #1747 patch against 4.6.2. It's working fine. Building against numpy 1.21.5, and building and passing tests with python3.10.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1720#issuecomment-1006101738
https://github.com/qutip/qutip/issues/1720#issuecomment-1006101738:118,Testability,test,tests,118,"I tested the PR #1747 patch against 4.6.2. It's working fine. Building against numpy 1.21.5, and building and passing tests with python3.10.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1720#issuecomment-1006101738
https://github.com/qutip/qutip/issues/1722#issuecomment-979361059:250,Deployability,release,release,250,"Thank you for pointing, these functions were added and modified over years and it would be a good idea to unify the documentation. . However we are short handed, so it will probably wait until we rework the dimension representation in a future major release; ( #1476). We are open to help until then.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1722#issuecomment-979361059
https://github.com/qutip/qutip/issues/1722#issuecomment-1415691098:32,Modifiability,enhance,enhancement,32,@Ericgig I have implemented the enhancement required please have a look.,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1722#issuecomment-1415691098
https://github.com/qutip/qutip/pull/1723#issuecomment-976540355:160,Availability,down,downstream,160,"I'm not at all a fan of making tests part of the public interface like this. It's something that we make absolutely no stability guarantees about, and coupling downstream packages to our own tests just sounds like a recipe for disaster - if we find a bug in main QuTiP and need to change tests or add methods (which we should be able to do completely freely), we're going to inject a ton of extra code into downstream packages, and may completely break them. To be honest, I'm not even wild about how we distribute our tests as part of the module code at all, but that's what we've got. It _could_ be ok if you import the test case base, and redefine your tests from there. We still don't make any stability guarantees about that, but it's conceivable that we could (though of course, the problem of ""what if we need to add methods"" persists). That would also solve your problems about saying you can't import individual tests. You can import individual tests anyway, you just need to rename them to things like `_TestAdd`, or use one of the pytest hooks in your local `conftest.py` to reject tests whose `__module__` isn't your local module, or do one of the other methods of filtering.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1723#issuecomment-976540355
https://github.com/qutip/qutip/pull/1723#issuecomment-976540355:407,Availability,down,downstream,407,"I'm not at all a fan of making tests part of the public interface like this. It's something that we make absolutely no stability guarantees about, and coupling downstream packages to our own tests just sounds like a recipe for disaster - if we find a bug in main QuTiP and need to change tests or add methods (which we should be able to do completely freely), we're going to inject a ton of extra code into downstream packages, and may completely break them. To be honest, I'm not even wild about how we distribute our tests as part of the module code at all, but that's what we've got. It _could_ be ok if you import the test case base, and redefine your tests from there. We still don't make any stability guarantees about that, but it's conceivable that we could (though of course, the problem of ""what if we need to add methods"" persists). That would also solve your problems about saying you can't import individual tests. You can import individual tests anyway, you just need to rename them to things like `_TestAdd`, or use one of the pytest hooks in your local `conftest.py` to reject tests whose `__module__` isn't your local module, or do one of the other methods of filtering.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1723#issuecomment-976540355
https://github.com/qutip/qutip/pull/1723#issuecomment-976540355:56,Integrability,interface,interface,56,"I'm not at all a fan of making tests part of the public interface like this. It's something that we make absolutely no stability guarantees about, and coupling downstream packages to our own tests just sounds like a recipe for disaster - if we find a bug in main QuTiP and need to change tests or add methods (which we should be able to do completely freely), we're going to inject a ton of extra code into downstream packages, and may completely break them. To be honest, I'm not even wild about how we distribute our tests as part of the module code at all, but that's what we've got. It _could_ be ok if you import the test case base, and redefine your tests from there. We still don't make any stability guarantees about that, but it's conceivable that we could (though of course, the problem of ""what if we need to add methods"" persists). That would also solve your problems about saying you can't import individual tests. You can import individual tests anyway, you just need to rename them to things like `_TestAdd`, or use one of the pytest hooks in your local `conftest.py` to reject tests whose `__module__` isn't your local module, or do one of the other methods of filtering.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1723#issuecomment-976540355
https://github.com/qutip/qutip/pull/1723#issuecomment-976540355:375,Integrability,inject,inject,375,"I'm not at all a fan of making tests part of the public interface like this. It's something that we make absolutely no stability guarantees about, and coupling downstream packages to our own tests just sounds like a recipe for disaster - if we find a bug in main QuTiP and need to change tests or add methods (which we should be able to do completely freely), we're going to inject a ton of extra code into downstream packages, and may completely break them. To be honest, I'm not even wild about how we distribute our tests as part of the module code at all, but that's what we've got. It _could_ be ok if you import the test case base, and redefine your tests from there. We still don't make any stability guarantees about that, but it's conceivable that we could (though of course, the problem of ""what if we need to add methods"" persists). That would also solve your problems about saying you can't import individual tests. You can import individual tests anyway, you just need to rename them to things like `_TestAdd`, or use one of the pytest hooks in your local `conftest.py` to reject tests whose `__module__` isn't your local module, or do one of the other methods of filtering.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1723#issuecomment-976540355
https://github.com/qutip/qutip/pull/1723#issuecomment-976540355:151,Modifiability,coupling,coupling,151,"I'm not at all a fan of making tests part of the public interface like this. It's something that we make absolutely no stability guarantees about, and coupling downstream packages to our own tests just sounds like a recipe for disaster - if we find a bug in main QuTiP and need to change tests or add methods (which we should be able to do completely freely), we're going to inject a ton of extra code into downstream packages, and may completely break them. To be honest, I'm not even wild about how we distribute our tests as part of the module code at all, but that's what we've got. It _could_ be ok if you import the test case base, and redefine your tests from there. We still don't make any stability guarantees about that, but it's conceivable that we could (though of course, the problem of ""what if we need to add methods"" persists). That would also solve your problems about saying you can't import individual tests. You can import individual tests anyway, you just need to rename them to things like `_TestAdd`, or use one of the pytest hooks in your local `conftest.py` to reject tests whose `__module__` isn't your local module, or do one of the other methods of filtering.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1723#issuecomment-976540355
https://github.com/qutip/qutip/pull/1723#issuecomment-976540355:375,Security,inject,inject,375,"I'm not at all a fan of making tests part of the public interface like this. It's something that we make absolutely no stability guarantees about, and coupling downstream packages to our own tests just sounds like a recipe for disaster - if we find a bug in main QuTiP and need to change tests or add methods (which we should be able to do completely freely), we're going to inject a ton of extra code into downstream packages, and may completely break them. To be honest, I'm not even wild about how we distribute our tests as part of the module code at all, but that's what we've got. It _could_ be ok if you import the test case base, and redefine your tests from there. We still don't make any stability guarantees about that, but it's conceivable that we could (though of course, the problem of ""what if we need to add methods"" persists). That would also solve your problems about saying you can't import individual tests. You can import individual tests anyway, you just need to rename them to things like `_TestAdd`, or use one of the pytest hooks in your local `conftest.py` to reject tests whose `__module__` isn't your local module, or do one of the other methods of filtering.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1723#issuecomment-976540355
https://github.com/qutip/qutip/pull/1723#issuecomment-976540355:31,Testability,test,tests,31,"I'm not at all a fan of making tests part of the public interface like this. It's something that we make absolutely no stability guarantees about, and coupling downstream packages to our own tests just sounds like a recipe for disaster - if we find a bug in main QuTiP and need to change tests or add methods (which we should be able to do completely freely), we're going to inject a ton of extra code into downstream packages, and may completely break them. To be honest, I'm not even wild about how we distribute our tests as part of the module code at all, but that's what we've got. It _could_ be ok if you import the test case base, and redefine your tests from there. We still don't make any stability guarantees about that, but it's conceivable that we could (though of course, the problem of ""what if we need to add methods"" persists). That would also solve your problems about saying you can't import individual tests. You can import individual tests anyway, you just need to rename them to things like `_TestAdd`, or use one of the pytest hooks in your local `conftest.py` to reject tests whose `__module__` isn't your local module, or do one of the other methods of filtering.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1723#issuecomment-976540355
https://github.com/qutip/qutip/pull/1723#issuecomment-976540355:191,Testability,test,tests,191,"I'm not at all a fan of making tests part of the public interface like this. It's something that we make absolutely no stability guarantees about, and coupling downstream packages to our own tests just sounds like a recipe for disaster - if we find a bug in main QuTiP and need to change tests or add methods (which we should be able to do completely freely), we're going to inject a ton of extra code into downstream packages, and may completely break them. To be honest, I'm not even wild about how we distribute our tests as part of the module code at all, but that's what we've got. It _could_ be ok if you import the test case base, and redefine your tests from there. We still don't make any stability guarantees about that, but it's conceivable that we could (though of course, the problem of ""what if we need to add methods"" persists). That would also solve your problems about saying you can't import individual tests. You can import individual tests anyway, you just need to rename them to things like `_TestAdd`, or use one of the pytest hooks in your local `conftest.py` to reject tests whose `__module__` isn't your local module, or do one of the other methods of filtering.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1723#issuecomment-976540355
https://github.com/qutip/qutip/pull/1723#issuecomment-976540355:288,Testability,test,tests,288,"I'm not at all a fan of making tests part of the public interface like this. It's something that we make absolutely no stability guarantees about, and coupling downstream packages to our own tests just sounds like a recipe for disaster - if we find a bug in main QuTiP and need to change tests or add methods (which we should be able to do completely freely), we're going to inject a ton of extra code into downstream packages, and may completely break them. To be honest, I'm not even wild about how we distribute our tests as part of the module code at all, but that's what we've got. It _could_ be ok if you import the test case base, and redefine your tests from there. We still don't make any stability guarantees about that, but it's conceivable that we could (though of course, the problem of ""what if we need to add methods"" persists). That would also solve your problems about saying you can't import individual tests. You can import individual tests anyway, you just need to rename them to things like `_TestAdd`, or use one of the pytest hooks in your local `conftest.py` to reject tests whose `__module__` isn't your local module, or do one of the other methods of filtering.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1723#issuecomment-976540355
https://github.com/qutip/qutip/pull/1723#issuecomment-976540355:519,Testability,test,tests,519,"I'm not at all a fan of making tests part of the public interface like this. It's something that we make absolutely no stability guarantees about, and coupling downstream packages to our own tests just sounds like a recipe for disaster - if we find a bug in main QuTiP and need to change tests or add methods (which we should be able to do completely freely), we're going to inject a ton of extra code into downstream packages, and may completely break them. To be honest, I'm not even wild about how we distribute our tests as part of the module code at all, but that's what we've got. It _could_ be ok if you import the test case base, and redefine your tests from there. We still don't make any stability guarantees about that, but it's conceivable that we could (though of course, the problem of ""what if we need to add methods"" persists). That would also solve your problems about saying you can't import individual tests. You can import individual tests anyway, you just need to rename them to things like `_TestAdd`, or use one of the pytest hooks in your local `conftest.py` to reject tests whose `__module__` isn't your local module, or do one of the other methods of filtering.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1723#issuecomment-976540355
https://github.com/qutip/qutip/pull/1723#issuecomment-976540355:622,Testability,test,test,622,"I'm not at all a fan of making tests part of the public interface like this. It's something that we make absolutely no stability guarantees about, and coupling downstream packages to our own tests just sounds like a recipe for disaster - if we find a bug in main QuTiP and need to change tests or add methods (which we should be able to do completely freely), we're going to inject a ton of extra code into downstream packages, and may completely break them. To be honest, I'm not even wild about how we distribute our tests as part of the module code at all, but that's what we've got. It _could_ be ok if you import the test case base, and redefine your tests from there. We still don't make any stability guarantees about that, but it's conceivable that we could (though of course, the problem of ""what if we need to add methods"" persists). That would also solve your problems about saying you can't import individual tests. You can import individual tests anyway, you just need to rename them to things like `_TestAdd`, or use one of the pytest hooks in your local `conftest.py` to reject tests whose `__module__` isn't your local module, or do one of the other methods of filtering.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1723#issuecomment-976540355
https://github.com/qutip/qutip/pull/1723#issuecomment-976540355:656,Testability,test,tests,656,"I'm not at all a fan of making tests part of the public interface like this. It's something that we make absolutely no stability guarantees about, and coupling downstream packages to our own tests just sounds like a recipe for disaster - if we find a bug in main QuTiP and need to change tests or add methods (which we should be able to do completely freely), we're going to inject a ton of extra code into downstream packages, and may completely break them. To be honest, I'm not even wild about how we distribute our tests as part of the module code at all, but that's what we've got. It _could_ be ok if you import the test case base, and redefine your tests from there. We still don't make any stability guarantees about that, but it's conceivable that we could (though of course, the problem of ""what if we need to add methods"" persists). That would also solve your problems about saying you can't import individual tests. You can import individual tests anyway, you just need to rename them to things like `_TestAdd`, or use one of the pytest hooks in your local `conftest.py` to reject tests whose `__module__` isn't your local module, or do one of the other methods of filtering.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1723#issuecomment-976540355
https://github.com/qutip/qutip/pull/1723#issuecomment-976540355:921,Testability,test,tests,921,"I'm not at all a fan of making tests part of the public interface like this. It's something that we make absolutely no stability guarantees about, and coupling downstream packages to our own tests just sounds like a recipe for disaster - if we find a bug in main QuTiP and need to change tests or add methods (which we should be able to do completely freely), we're going to inject a ton of extra code into downstream packages, and may completely break them. To be honest, I'm not even wild about how we distribute our tests as part of the module code at all, but that's what we've got. It _could_ be ok if you import the test case base, and redefine your tests from there. We still don't make any stability guarantees about that, but it's conceivable that we could (though of course, the problem of ""what if we need to add methods"" persists). That would also solve your problems about saying you can't import individual tests. You can import individual tests anyway, you just need to rename them to things like `_TestAdd`, or use one of the pytest hooks in your local `conftest.py` to reject tests whose `__module__` isn't your local module, or do one of the other methods of filtering.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1723#issuecomment-976540355
https://github.com/qutip/qutip/pull/1723#issuecomment-976540355:954,Testability,test,tests,954,"I'm not at all a fan of making tests part of the public interface like this. It's something that we make absolutely no stability guarantees about, and coupling downstream packages to our own tests just sounds like a recipe for disaster - if we find a bug in main QuTiP and need to change tests or add methods (which we should be able to do completely freely), we're going to inject a ton of extra code into downstream packages, and may completely break them. To be honest, I'm not even wild about how we distribute our tests as part of the module code at all, but that's what we've got. It _could_ be ok if you import the test case base, and redefine your tests from there. We still don't make any stability guarantees about that, but it's conceivable that we could (though of course, the problem of ""what if we need to add methods"" persists). That would also solve your problems about saying you can't import individual tests. You can import individual tests anyway, you just need to rename them to things like `_TestAdd`, or use one of the pytest hooks in your local `conftest.py` to reject tests whose `__module__` isn't your local module, or do one of the other methods of filtering.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1723#issuecomment-976540355
https://github.com/qutip/qutip/pull/1723#issuecomment-976540355:1093,Testability,test,tests,1093,"I'm not at all a fan of making tests part of the public interface like this. It's something that we make absolutely no stability guarantees about, and coupling downstream packages to our own tests just sounds like a recipe for disaster - if we find a bug in main QuTiP and need to change tests or add methods (which we should be able to do completely freely), we're going to inject a ton of extra code into downstream packages, and may completely break them. To be honest, I'm not even wild about how we distribute our tests as part of the module code at all, but that's what we've got. It _could_ be ok if you import the test case base, and redefine your tests from there. We still don't make any stability guarantees about that, but it's conceivable that we could (though of course, the problem of ""what if we need to add methods"" persists). That would also solve your problems about saying you can't import individual tests. You can import individual tests anyway, you just need to rename them to things like `_TestAdd`, or use one of the pytest hooks in your local `conftest.py` to reject tests whose `__module__` isn't your local module, or do one of the other methods of filtering.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1723#issuecomment-976540355
https://github.com/qutip/qutip/pull/1723#issuecomment-976543231:41,Testability,test,tests,41,"Also, this change will duplicate all the tests in QuTiP for the same reason that you originally said you didn't want to import individual tests.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1723#issuecomment-976543231
https://github.com/qutip/qutip/pull/1723#issuecomment-976543231:138,Testability,test,tests,138,"Also, this change will duplicate all the tests in QuTiP for the same reason that you originally said you didn't want to import individual tests.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1723#issuecomment-976543231
https://github.com/qutip/qutip/pull/1723#issuecomment-979884874:905,Integrability,interface,interface,905,I agree with @jakelishman's general principle (and maybe we should even move the tests out of the `qutip` package for v5 still) but it's also really important to have an easy way for data layer implementations to run a comprehensive test suite *that is defined by the data layer*. I suspect that if anyone is running tests against master (i.e. what is currently dev.major) they will *want* tests to break if we add new methods. I have a slightly different proposal:. What if we create `qutip.core.data.testing` which is an explicitly exported suite of pytest classes that we intentionally expose for data layers to use? Initially the file can just import test classes from `qutip.tests.core.data`. I would also not use `__all__` in the individual test packages but instead import the test classes explicitly in `qutip.core.data.testing` so that it's 100% clear by reading just that file what the exported interface is (and adding new tests requires explicitly adding them into the exposed package).,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1723#issuecomment-979884874
https://github.com/qutip/qutip/pull/1723#issuecomment-979884874:605,Modifiability,layers,layers,605,I agree with @jakelishman's general principle (and maybe we should even move the tests out of the `qutip` package for v5 still) but it's also really important to have an easy way for data layer implementations to run a comprehensive test suite *that is defined by the data layer*. I suspect that if anyone is running tests against master (i.e. what is currently dev.major) they will *want* tests to break if we add new methods. I have a slightly different proposal:. What if we create `qutip.core.data.testing` which is an explicitly exported suite of pytest classes that we intentionally expose for data layers to use? Initially the file can just import test classes from `qutip.tests.core.data`. I would also not use `__all__` in the individual test packages but instead import the test classes explicitly in `qutip.core.data.testing` so that it's 100% clear by reading just that file what the exported interface is (and adding new tests requires explicitly adding them into the exposed package).,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1723#issuecomment-979884874
https://github.com/qutip/qutip/pull/1723#issuecomment-979884874:589,Security,expose,expose,589,I agree with @jakelishman's general principle (and maybe we should even move the tests out of the `qutip` package for v5 still) but it's also really important to have an easy way for data layer implementations to run a comprehensive test suite *that is defined by the data layer*. I suspect that if anyone is running tests against master (i.e. what is currently dev.major) they will *want* tests to break if we add new methods. I have a slightly different proposal:. What if we create `qutip.core.data.testing` which is an explicitly exported suite of pytest classes that we intentionally expose for data layers to use? Initially the file can just import test classes from `qutip.tests.core.data`. I would also not use `__all__` in the individual test packages but instead import the test classes explicitly in `qutip.core.data.testing` so that it's 100% clear by reading just that file what the exported interface is (and adding new tests requires explicitly adding them into the exposed package).,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1723#issuecomment-979884874
https://github.com/qutip/qutip/pull/1723#issuecomment-979884874:981,Security,expose,exposed,981,I agree with @jakelishman's general principle (and maybe we should even move the tests out of the `qutip` package for v5 still) but it's also really important to have an easy way for data layer implementations to run a comprehensive test suite *that is defined by the data layer*. I suspect that if anyone is running tests against master (i.e. what is currently dev.major) they will *want* tests to break if we add new methods. I have a slightly different proposal:. What if we create `qutip.core.data.testing` which is an explicitly exported suite of pytest classes that we intentionally expose for data layers to use? Initially the file can just import test classes from `qutip.tests.core.data`. I would also not use `__all__` in the individual test packages but instead import the test classes explicitly in `qutip.core.data.testing` so that it's 100% clear by reading just that file what the exported interface is (and adding new tests requires explicitly adding them into the exposed package).,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1723#issuecomment-979884874
https://github.com/qutip/qutip/pull/1723#issuecomment-979884874:81,Testability,test,tests,81,I agree with @jakelishman's general principle (and maybe we should even move the tests out of the `qutip` package for v5 still) but it's also really important to have an easy way for data layer implementations to run a comprehensive test suite *that is defined by the data layer*. I suspect that if anyone is running tests against master (i.e. what is currently dev.major) they will *want* tests to break if we add new methods. I have a slightly different proposal:. What if we create `qutip.core.data.testing` which is an explicitly exported suite of pytest classes that we intentionally expose for data layers to use? Initially the file can just import test classes from `qutip.tests.core.data`. I would also not use `__all__` in the individual test packages but instead import the test classes explicitly in `qutip.core.data.testing` so that it's 100% clear by reading just that file what the exported interface is (and adding new tests requires explicitly adding them into the exposed package).,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1723#issuecomment-979884874
https://github.com/qutip/qutip/pull/1723#issuecomment-979884874:233,Testability,test,test,233,I agree with @jakelishman's general principle (and maybe we should even move the tests out of the `qutip` package for v5 still) but it's also really important to have an easy way for data layer implementations to run a comprehensive test suite *that is defined by the data layer*. I suspect that if anyone is running tests against master (i.e. what is currently dev.major) they will *want* tests to break if we add new methods. I have a slightly different proposal:. What if we create `qutip.core.data.testing` which is an explicitly exported suite of pytest classes that we intentionally expose for data layers to use? Initially the file can just import test classes from `qutip.tests.core.data`. I would also not use `__all__` in the individual test packages but instead import the test classes explicitly in `qutip.core.data.testing` so that it's 100% clear by reading just that file what the exported interface is (and adding new tests requires explicitly adding them into the exposed package).,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1723#issuecomment-979884874
https://github.com/qutip/qutip/pull/1723#issuecomment-979884874:317,Testability,test,tests,317,I agree with @jakelishman's general principle (and maybe we should even move the tests out of the `qutip` package for v5 still) but it's also really important to have an easy way for data layer implementations to run a comprehensive test suite *that is defined by the data layer*. I suspect that if anyone is running tests against master (i.e. what is currently dev.major) they will *want* tests to break if we add new methods. I have a slightly different proposal:. What if we create `qutip.core.data.testing` which is an explicitly exported suite of pytest classes that we intentionally expose for data layers to use? Initially the file can just import test classes from `qutip.tests.core.data`. I would also not use `__all__` in the individual test packages but instead import the test classes explicitly in `qutip.core.data.testing` so that it's 100% clear by reading just that file what the exported interface is (and adding new tests requires explicitly adding them into the exposed package).,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1723#issuecomment-979884874
https://github.com/qutip/qutip/pull/1723#issuecomment-979884874:390,Testability,test,tests,390,I agree with @jakelishman's general principle (and maybe we should even move the tests out of the `qutip` package for v5 still) but it's also really important to have an easy way for data layer implementations to run a comprehensive test suite *that is defined by the data layer*. I suspect that if anyone is running tests against master (i.e. what is currently dev.major) they will *want* tests to break if we add new methods. I have a slightly different proposal:. What if we create `qutip.core.data.testing` which is an explicitly exported suite of pytest classes that we intentionally expose for data layers to use? Initially the file can just import test classes from `qutip.tests.core.data`. I would also not use `__all__` in the individual test packages but instead import the test classes explicitly in `qutip.core.data.testing` so that it's 100% clear by reading just that file what the exported interface is (and adding new tests requires explicitly adding them into the exposed package).,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1723#issuecomment-979884874
https://github.com/qutip/qutip/pull/1723#issuecomment-979884874:502,Testability,test,testing,502,I agree with @jakelishman's general principle (and maybe we should even move the tests out of the `qutip` package for v5 still) but it's also really important to have an easy way for data layer implementations to run a comprehensive test suite *that is defined by the data layer*. I suspect that if anyone is running tests against master (i.e. what is currently dev.major) they will *want* tests to break if we add new methods. I have a slightly different proposal:. What if we create `qutip.core.data.testing` which is an explicitly exported suite of pytest classes that we intentionally expose for data layers to use? Initially the file can just import test classes from `qutip.tests.core.data`. I would also not use `__all__` in the individual test packages but instead import the test classes explicitly in `qutip.core.data.testing` so that it's 100% clear by reading just that file what the exported interface is (and adding new tests requires explicitly adding them into the exposed package).,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1723#issuecomment-979884874
https://github.com/qutip/qutip/pull/1723#issuecomment-979884874:655,Testability,test,test,655,I agree with @jakelishman's general principle (and maybe we should even move the tests out of the `qutip` package for v5 still) but it's also really important to have an easy way for data layer implementations to run a comprehensive test suite *that is defined by the data layer*. I suspect that if anyone is running tests against master (i.e. what is currently dev.major) they will *want* tests to break if we add new methods. I have a slightly different proposal:. What if we create `qutip.core.data.testing` which is an explicitly exported suite of pytest classes that we intentionally expose for data layers to use? Initially the file can just import test classes from `qutip.tests.core.data`. I would also not use `__all__` in the individual test packages but instead import the test classes explicitly in `qutip.core.data.testing` so that it's 100% clear by reading just that file what the exported interface is (and adding new tests requires explicitly adding them into the exposed package).,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1723#issuecomment-979884874
https://github.com/qutip/qutip/pull/1723#issuecomment-979884874:680,Testability,test,tests,680,I agree with @jakelishman's general principle (and maybe we should even move the tests out of the `qutip` package for v5 still) but it's also really important to have an easy way for data layer implementations to run a comprehensive test suite *that is defined by the data layer*. I suspect that if anyone is running tests against master (i.e. what is currently dev.major) they will *want* tests to break if we add new methods. I have a slightly different proposal:. What if we create `qutip.core.data.testing` which is an explicitly exported suite of pytest classes that we intentionally expose for data layers to use? Initially the file can just import test classes from `qutip.tests.core.data`. I would also not use `__all__` in the individual test packages but instead import the test classes explicitly in `qutip.core.data.testing` so that it's 100% clear by reading just that file what the exported interface is (and adding new tests requires explicitly adding them into the exposed package).,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1723#issuecomment-979884874
https://github.com/qutip/qutip/pull/1723#issuecomment-979884874:747,Testability,test,test,747,I agree with @jakelishman's general principle (and maybe we should even move the tests out of the `qutip` package for v5 still) but it's also really important to have an easy way for data layer implementations to run a comprehensive test suite *that is defined by the data layer*. I suspect that if anyone is running tests against master (i.e. what is currently dev.major) they will *want* tests to break if we add new methods. I have a slightly different proposal:. What if we create `qutip.core.data.testing` which is an explicitly exported suite of pytest classes that we intentionally expose for data layers to use? Initially the file can just import test classes from `qutip.tests.core.data`. I would also not use `__all__` in the individual test packages but instead import the test classes explicitly in `qutip.core.data.testing` so that it's 100% clear by reading just that file what the exported interface is (and adding new tests requires explicitly adding them into the exposed package).,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1723#issuecomment-979884874
https://github.com/qutip/qutip/pull/1723#issuecomment-979884874:784,Testability,test,test,784,I agree with @jakelishman's general principle (and maybe we should even move the tests out of the `qutip` package for v5 still) but it's also really important to have an easy way for data layer implementations to run a comprehensive test suite *that is defined by the data layer*. I suspect that if anyone is running tests against master (i.e. what is currently dev.major) they will *want* tests to break if we add new methods. I have a slightly different proposal:. What if we create `qutip.core.data.testing` which is an explicitly exported suite of pytest classes that we intentionally expose for data layers to use? Initially the file can just import test classes from `qutip.tests.core.data`. I would also not use `__all__` in the individual test packages but instead import the test classes explicitly in `qutip.core.data.testing` so that it's 100% clear by reading just that file what the exported interface is (and adding new tests requires explicitly adding them into the exposed package).,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1723#issuecomment-979884874
https://github.com/qutip/qutip/pull/1723#issuecomment-979884874:828,Testability,test,testing,828,I agree with @jakelishman's general principle (and maybe we should even move the tests out of the `qutip` package for v5 still) but it's also really important to have an easy way for data layer implementations to run a comprehensive test suite *that is defined by the data layer*. I suspect that if anyone is running tests against master (i.e. what is currently dev.major) they will *want* tests to break if we add new methods. I have a slightly different proposal:. What if we create `qutip.core.data.testing` which is an explicitly exported suite of pytest classes that we intentionally expose for data layers to use? Initially the file can just import test classes from `qutip.tests.core.data`. I would also not use `__all__` in the individual test packages but instead import the test classes explicitly in `qutip.core.data.testing` so that it's 100% clear by reading just that file what the exported interface is (and adding new tests requires explicitly adding them into the exposed package).,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1723#issuecomment-979884874
https://github.com/qutip/qutip/pull/1723#issuecomment-979884874:934,Testability,test,tests,934,I agree with @jakelishman's general principle (and maybe we should even move the tests out of the `qutip` package for v5 still) but it's also really important to have an easy way for data layer implementations to run a comprehensive test suite *that is defined by the data layer*. I suspect that if anyone is running tests against master (i.e. what is currently dev.major) they will *want* tests to break if we add new methods. I have a slightly different proposal:. What if we create `qutip.core.data.testing` which is an explicitly exported suite of pytest classes that we intentionally expose for data layers to use? Initially the file can just import test classes from `qutip.tests.core.data`. I would also not use `__all__` in the individual test packages but instead import the test classes explicitly in `qutip.core.data.testing` so that it's 100% clear by reading just that file what the exported interface is (and adding new tests requires explicitly adding them into the exposed package).,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1723#issuecomment-979884874
https://github.com/qutip/qutip/pull/1723#issuecomment-979884874:855,Usability,clear,clear,855,I agree with @jakelishman's general principle (and maybe we should even move the tests out of the `qutip` package for v5 still) but it's also really important to have an easy way for data layer implementations to run a comprehensive test suite *that is defined by the data layer*. I suspect that if anyone is running tests against master (i.e. what is currently dev.major) they will *want* tests to break if we add new methods. I have a slightly different proposal:. What if we create `qutip.core.data.testing` which is an explicitly exported suite of pytest classes that we intentionally expose for data layers to use? Initially the file can just import test classes from `qutip.tests.core.data`. I would also not use `__all__` in the individual test packages but instead import the test classes explicitly in `qutip.core.data.testing` so that it's 100% clear by reading just that file what the exported interface is (and adding new tests requires explicitly adding them into the exposed package).,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1723#issuecomment-979884874
https://github.com/qutip/qutip/pull/1723#issuecomment-979917075:1458,Availability,down,downstream,1458," `/qutip/tests` (I originally didn't like it, but I now see more and more benefits of the `/src` (or `/lib`) convention in Python projects).; - the current `qutip/tests` should entirely become `/test/qutip`; - a new `/src/qutip/test` becomes a fully-supported _public_ module, including base classes (such as the data-layer mixins) and things like that. We'd need to be careful, because reducing your possibilities for flexibility in testing generally sounds like a bad idea to me, but if we take care to be very limited, it could work. I suspect you won't be able to import the test suite from inside `qutip.core.data` because of cyclical dependencies, which is probably a good thing - it'll force us to put the structure the right way round immediately. For an idea pretty far out of left field:; - the data layer tests should really _discover_ the specialisations rather than us needing to specify them (this is true regardless of this PR); - if so, in the new form, we _could_ directly export this part of the test suite from `qutip.test` (our test suite would import this as well), and add a little bit of logic to allow filtering of which tests need to be run (class decorators, probably); - downstream packages could then test just by importing our classes and disabling any specialisations that are only on internal data-layer objects. I'm not 100% sure how I feel about this, but it's plausible - we'd still be able to add extra methods in our own test suite if we wanted them, because we could just derive from the classes, rather than defining the names into the test suite in those cases. ---. About us breaking downstream CI: having been a maintainer of QuTiP and now Qiskit, I have a deep-rooted hatred for any upstream package that forces CI failures on its dependents, because it _requires_ the lower packages to move ""fix CI"" way up to the top of their priority list; you can't merge _anything_ until CI is running again, which is very frustrating. It messes with all your workflows.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1723#issuecomment-979917075
https://github.com/qutip/qutip/pull/1723#issuecomment-979917075:1884,Availability,down,downstream,1884," `/qutip/tests` (I originally didn't like it, but I now see more and more benefits of the `/src` (or `/lib`) convention in Python projects).; - the current `qutip/tests` should entirely become `/test/qutip`; - a new `/src/qutip/test` becomes a fully-supported _public_ module, including base classes (such as the data-layer mixins) and things like that. We'd need to be careful, because reducing your possibilities for flexibility in testing generally sounds like a bad idea to me, but if we take care to be very limited, it could work. I suspect you won't be able to import the test suite from inside `qutip.core.data` because of cyclical dependencies, which is probably a good thing - it'll force us to put the structure the right way round immediately. For an idea pretty far out of left field:; - the data layer tests should really _discover_ the specialisations rather than us needing to specify them (this is true regardless of this PR); - if so, in the new form, we _could_ directly export this part of the test suite from `qutip.test` (our test suite would import this as well), and add a little bit of logic to allow filtering of which tests need to be run (class decorators, probably); - downstream packages could then test just by importing our classes and disabling any specialisations that are only on internal data-layer objects. I'm not 100% sure how I feel about this, but it's plausible - we'd still be able to add extra methods in our own test suite if we wanted them, because we could just derive from the classes, rather than defining the names into the test suite in those cases. ---. About us breaking downstream CI: having been a maintainer of QuTiP and now Qiskit, I have a deep-rooted hatred for any upstream package that forces CI failures on its dependents, because it _requires_ the lower packages to move ""fix CI"" way up to the top of their priority list; you can't merge _anything_ until CI is running again, which is very frustrating. It messes with all your workflows.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1723#issuecomment-979917075
https://github.com/qutip/qutip/pull/1723#issuecomment-979917075:2017,Availability,failure,failures,2017," `/qutip/tests` (I originally didn't like it, but I now see more and more benefits of the `/src` (or `/lib`) convention in Python projects).; - the current `qutip/tests` should entirely become `/test/qutip`; - a new `/src/qutip/test` becomes a fully-supported _public_ module, including base classes (such as the data-layer mixins) and things like that. We'd need to be careful, because reducing your possibilities for flexibility in testing generally sounds like a bad idea to me, but if we take care to be very limited, it could work. I suspect you won't be able to import the test suite from inside `qutip.core.data` because of cyclical dependencies, which is probably a good thing - it'll force us to put the structure the right way round immediately. For an idea pretty far out of left field:; - the data layer tests should really _discover_ the specialisations rather than us needing to specify them (this is true regardless of this PR); - if so, in the new form, we _could_ directly export this part of the test suite from `qutip.test` (our test suite would import this as well), and add a little bit of logic to allow filtering of which tests need to be run (class decorators, probably); - downstream packages could then test just by importing our classes and disabling any specialisations that are only on internal data-layer objects. I'm not 100% sure how I feel about this, but it's plausible - we'd still be able to add extra methods in our own test suite if we wanted them, because we could just derive from the classes, rather than defining the names into the test suite in those cases. ---. About us breaking downstream CI: having been a maintainer of QuTiP and now Qiskit, I have a deep-rooted hatred for any upstream package that forces CI failures on its dependents, because it _requires_ the lower packages to move ""fix CI"" way up to the top of their priority list; you can't merge _anything_ until CI is running again, which is very frustrating. It messes with all your workflows.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1723#issuecomment-979917075
https://github.com/qutip/qutip/pull/1723#issuecomment-979917075:900,Integrability,depend,dependencies,900,"If it's something we want to support, we'll need a bit of a rewrite of the data-layer testing infrastructure, but nothing too major. I'd be in favour of a bit of a larger restructure:; - rearrange the repo root to have `/src/qutip` and `/test/qutip` instead of `/qutip/tests` (I originally didn't like it, but I now see more and more benefits of the `/src` (or `/lib`) convention in Python projects).; - the current `qutip/tests` should entirely become `/test/qutip`; - a new `/src/qutip/test` becomes a fully-supported _public_ module, including base classes (such as the data-layer mixins) and things like that. We'd need to be careful, because reducing your possibilities for flexibility in testing generally sounds like a bad idea to me, but if we take care to be very limited, it could work. I suspect you won't be able to import the test suite from inside `qutip.core.data` because of cyclical dependencies, which is probably a good thing - it'll force us to put the structure the right way round immediately. For an idea pretty far out of left field:; - the data layer tests should really _discover_ the specialisations rather than us needing to specify them (this is true regardless of this PR); - if so, in the new form, we _could_ directly export this part of the test suite from `qutip.test` (our test suite would import this as well), and add a little bit of logic to allow filtering of which tests need to be run (class decorators, probably); - downstream packages could then test just by importing our classes and disabling any specialisations that are only on internal data-layer objects. I'm not 100% sure how I feel about this, but it's plausible - we'd still be able to add extra methods in our own test suite if we wanted them, because we could just derive from the classes, rather than defining the names into the test suite in those cases. ---. About us breaking downstream CI: having been a maintainer of QuTiP and now Qiskit, I have a deep-rooted hatred for any upstream package",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1723#issuecomment-979917075
https://github.com/qutip/qutip/pull/1723#issuecomment-979917075:2033,Integrability,depend,dependents,2033," `/qutip/tests` (I originally didn't like it, but I now see more and more benefits of the `/src` (or `/lib`) convention in Python projects).; - the current `qutip/tests` should entirely become `/test/qutip`; - a new `/src/qutip/test` becomes a fully-supported _public_ module, including base classes (such as the data-layer mixins) and things like that. We'd need to be careful, because reducing your possibilities for flexibility in testing generally sounds like a bad idea to me, but if we take care to be very limited, it could work. I suspect you won't be able to import the test suite from inside `qutip.core.data` because of cyclical dependencies, which is probably a good thing - it'll force us to put the structure the right way round immediately. For an idea pretty far out of left field:; - the data layer tests should really _discover_ the specialisations rather than us needing to specify them (this is true regardless of this PR); - if so, in the new form, we _could_ directly export this part of the test suite from `qutip.test` (our test suite would import this as well), and add a little bit of logic to allow filtering of which tests need to be run (class decorators, probably); - downstream packages could then test just by importing our classes and disabling any specialisations that are only on internal data-layer objects. I'm not 100% sure how I feel about this, but it's plausible - we'd still be able to add extra methods in our own test suite if we wanted them, because we could just derive from the classes, rather than defining the names into the test suite in those cases. ---. About us breaking downstream CI: having been a maintainer of QuTiP and now Qiskit, I have a deep-rooted hatred for any upstream package that forces CI failures on its dependents, because it _requires_ the lower packages to move ""fix CI"" way up to the top of their priority list; you can't merge _anything_ until CI is running again, which is very frustrating. It messes with all your workflows.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1723#issuecomment-979917075
https://github.com/qutip/qutip/pull/1723#issuecomment-979917075:60,Modifiability,rewrite,rewrite,60,"If it's something we want to support, we'll need a bit of a rewrite of the data-layer testing infrastructure, but nothing too major. I'd be in favour of a bit of a larger restructure:; - rearrange the repo root to have `/src/qutip` and `/test/qutip` instead of `/qutip/tests` (I originally didn't like it, but I now see more and more benefits of the `/src` (or `/lib`) convention in Python projects).; - the current `qutip/tests` should entirely become `/test/qutip`; - a new `/src/qutip/test` becomes a fully-supported _public_ module, including base classes (such as the data-layer mixins) and things like that. We'd need to be careful, because reducing your possibilities for flexibility in testing generally sounds like a bad idea to me, but if we take care to be very limited, it could work. I suspect you won't be able to import the test suite from inside `qutip.core.data` because of cyclical dependencies, which is probably a good thing - it'll force us to put the structure the right way round immediately. For an idea pretty far out of left field:; - the data layer tests should really _discover_ the specialisations rather than us needing to specify them (this is true regardless of this PR); - if so, in the new form, we _could_ directly export this part of the test suite from `qutip.test` (our test suite would import this as well), and add a little bit of logic to allow filtering of which tests need to be run (class decorators, probably); - downstream packages could then test just by importing our classes and disabling any specialisations that are only on internal data-layer objects. I'm not 100% sure how I feel about this, but it's plausible - we'd still be able to add extra methods in our own test suite if we wanted them, because we could just derive from the classes, rather than defining the names into the test suite in those cases. ---. About us breaking downstream CI: having been a maintainer of QuTiP and now Qiskit, I have a deep-rooted hatred for any upstream package",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1723#issuecomment-979917075
https://github.com/qutip/qutip/pull/1723#issuecomment-979917075:86,Testability,test,testing,86,"If it's something we want to support, we'll need a bit of a rewrite of the data-layer testing infrastructure, but nothing too major. I'd be in favour of a bit of a larger restructure:; - rearrange the repo root to have `/src/qutip` and `/test/qutip` instead of `/qutip/tests` (I originally didn't like it, but I now see more and more benefits of the `/src` (or `/lib`) convention in Python projects).; - the current `qutip/tests` should entirely become `/test/qutip`; - a new `/src/qutip/test` becomes a fully-supported _public_ module, including base classes (such as the data-layer mixins) and things like that. We'd need to be careful, because reducing your possibilities for flexibility in testing generally sounds like a bad idea to me, but if we take care to be very limited, it could work. I suspect you won't be able to import the test suite from inside `qutip.core.data` because of cyclical dependencies, which is probably a good thing - it'll force us to put the structure the right way round immediately. For an idea pretty far out of left field:; - the data layer tests should really _discover_ the specialisations rather than us needing to specify them (this is true regardless of this PR); - if so, in the new form, we _could_ directly export this part of the test suite from `qutip.test` (our test suite would import this as well), and add a little bit of logic to allow filtering of which tests need to be run (class decorators, probably); - downstream packages could then test just by importing our classes and disabling any specialisations that are only on internal data-layer objects. I'm not 100% sure how I feel about this, but it's plausible - we'd still be able to add extra methods in our own test suite if we wanted them, because we could just derive from the classes, rather than defining the names into the test suite in those cases. ---. About us breaking downstream CI: having been a maintainer of QuTiP and now Qiskit, I have a deep-rooted hatred for any upstream package",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1723#issuecomment-979917075
https://github.com/qutip/qutip/pull/1723#issuecomment-979917075:238,Testability,test,test,238,"If it's something we want to support, we'll need a bit of a rewrite of the data-layer testing infrastructure, but nothing too major. I'd be in favour of a bit of a larger restructure:; - rearrange the repo root to have `/src/qutip` and `/test/qutip` instead of `/qutip/tests` (I originally didn't like it, but I now see more and more benefits of the `/src` (or `/lib`) convention in Python projects).; - the current `qutip/tests` should entirely become `/test/qutip`; - a new `/src/qutip/test` becomes a fully-supported _public_ module, including base classes (such as the data-layer mixins) and things like that. We'd need to be careful, because reducing your possibilities for flexibility in testing generally sounds like a bad idea to me, but if we take care to be very limited, it could work. I suspect you won't be able to import the test suite from inside `qutip.core.data` because of cyclical dependencies, which is probably a good thing - it'll force us to put the structure the right way round immediately. For an idea pretty far out of left field:; - the data layer tests should really _discover_ the specialisations rather than us needing to specify them (this is true regardless of this PR); - if so, in the new form, we _could_ directly export this part of the test suite from `qutip.test` (our test suite would import this as well), and add a little bit of logic to allow filtering of which tests need to be run (class decorators, probably); - downstream packages could then test just by importing our classes and disabling any specialisations that are only on internal data-layer objects. I'm not 100% sure how I feel about this, but it's plausible - we'd still be able to add extra methods in our own test suite if we wanted them, because we could just derive from the classes, rather than defining the names into the test suite in those cases. ---. About us breaking downstream CI: having been a maintainer of QuTiP and now Qiskit, I have a deep-rooted hatred for any upstream package",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1723#issuecomment-979917075
https://github.com/qutip/qutip/pull/1723#issuecomment-979917075:269,Testability,test,tests,269,"If it's something we want to support, we'll need a bit of a rewrite of the data-layer testing infrastructure, but nothing too major. I'd be in favour of a bit of a larger restructure:; - rearrange the repo root to have `/src/qutip` and `/test/qutip` instead of `/qutip/tests` (I originally didn't like it, but I now see more and more benefits of the `/src` (or `/lib`) convention in Python projects).; - the current `qutip/tests` should entirely become `/test/qutip`; - a new `/src/qutip/test` becomes a fully-supported _public_ module, including base classes (such as the data-layer mixins) and things like that. We'd need to be careful, because reducing your possibilities for flexibility in testing generally sounds like a bad idea to me, but if we take care to be very limited, it could work. I suspect you won't be able to import the test suite from inside `qutip.core.data` because of cyclical dependencies, which is probably a good thing - it'll force us to put the structure the right way round immediately. For an idea pretty far out of left field:; - the data layer tests should really _discover_ the specialisations rather than us needing to specify them (this is true regardless of this PR); - if so, in the new form, we _could_ directly export this part of the test suite from `qutip.test` (our test suite would import this as well), and add a little bit of logic to allow filtering of which tests need to be run (class decorators, probably); - downstream packages could then test just by importing our classes and disabling any specialisations that are only on internal data-layer objects. I'm not 100% sure how I feel about this, but it's plausible - we'd still be able to add extra methods in our own test suite if we wanted them, because we could just derive from the classes, rather than defining the names into the test suite in those cases. ---. About us breaking downstream CI: having been a maintainer of QuTiP and now Qiskit, I have a deep-rooted hatred for any upstream package",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1723#issuecomment-979917075
https://github.com/qutip/qutip/pull/1723#issuecomment-979917075:423,Testability,test,tests,423,"If it's something we want to support, we'll need a bit of a rewrite of the data-layer testing infrastructure, but nothing too major. I'd be in favour of a bit of a larger restructure:; - rearrange the repo root to have `/src/qutip` and `/test/qutip` instead of `/qutip/tests` (I originally didn't like it, but I now see more and more benefits of the `/src` (or `/lib`) convention in Python projects).; - the current `qutip/tests` should entirely become `/test/qutip`; - a new `/src/qutip/test` becomes a fully-supported _public_ module, including base classes (such as the data-layer mixins) and things like that. We'd need to be careful, because reducing your possibilities for flexibility in testing generally sounds like a bad idea to me, but if we take care to be very limited, it could work. I suspect you won't be able to import the test suite from inside `qutip.core.data` because of cyclical dependencies, which is probably a good thing - it'll force us to put the structure the right way round immediately. For an idea pretty far out of left field:; - the data layer tests should really _discover_ the specialisations rather than us needing to specify them (this is true regardless of this PR); - if so, in the new form, we _could_ directly export this part of the test suite from `qutip.test` (our test suite would import this as well), and add a little bit of logic to allow filtering of which tests need to be run (class decorators, probably); - downstream packages could then test just by importing our classes and disabling any specialisations that are only on internal data-layer objects. I'm not 100% sure how I feel about this, but it's plausible - we'd still be able to add extra methods in our own test suite if we wanted them, because we could just derive from the classes, rather than defining the names into the test suite in those cases. ---. About us breaking downstream CI: having been a maintainer of QuTiP and now Qiskit, I have a deep-rooted hatred for any upstream package",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1723#issuecomment-979917075
https://github.com/qutip/qutip/pull/1723#issuecomment-979917075:455,Testability,test,test,455,"If it's something we want to support, we'll need a bit of a rewrite of the data-layer testing infrastructure, but nothing too major. I'd be in favour of a bit of a larger restructure:; - rearrange the repo root to have `/src/qutip` and `/test/qutip` instead of `/qutip/tests` (I originally didn't like it, but I now see more and more benefits of the `/src` (or `/lib`) convention in Python projects).; - the current `qutip/tests` should entirely become `/test/qutip`; - a new `/src/qutip/test` becomes a fully-supported _public_ module, including base classes (such as the data-layer mixins) and things like that. We'd need to be careful, because reducing your possibilities for flexibility in testing generally sounds like a bad idea to me, but if we take care to be very limited, it could work. I suspect you won't be able to import the test suite from inside `qutip.core.data` because of cyclical dependencies, which is probably a good thing - it'll force us to put the structure the right way round immediately. For an idea pretty far out of left field:; - the data layer tests should really _discover_ the specialisations rather than us needing to specify them (this is true regardless of this PR); - if so, in the new form, we _could_ directly export this part of the test suite from `qutip.test` (our test suite would import this as well), and add a little bit of logic to allow filtering of which tests need to be run (class decorators, probably); - downstream packages could then test just by importing our classes and disabling any specialisations that are only on internal data-layer objects. I'm not 100% sure how I feel about this, but it's plausible - we'd still be able to add extra methods in our own test suite if we wanted them, because we could just derive from the classes, rather than defining the names into the test suite in those cases. ---. About us breaking downstream CI: having been a maintainer of QuTiP and now Qiskit, I have a deep-rooted hatred for any upstream package",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1723#issuecomment-979917075
https://github.com/qutip/qutip/pull/1723#issuecomment-979917075:488,Testability,test,test,488,"If it's something we want to support, we'll need a bit of a rewrite of the data-layer testing infrastructure, but nothing too major. I'd be in favour of a bit of a larger restructure:; - rearrange the repo root to have `/src/qutip` and `/test/qutip` instead of `/qutip/tests` (I originally didn't like it, but I now see more and more benefits of the `/src` (or `/lib`) convention in Python projects).; - the current `qutip/tests` should entirely become `/test/qutip`; - a new `/src/qutip/test` becomes a fully-supported _public_ module, including base classes (such as the data-layer mixins) and things like that. We'd need to be careful, because reducing your possibilities for flexibility in testing generally sounds like a bad idea to me, but if we take care to be very limited, it could work. I suspect you won't be able to import the test suite from inside `qutip.core.data` because of cyclical dependencies, which is probably a good thing - it'll force us to put the structure the right way round immediately. For an idea pretty far out of left field:; - the data layer tests should really _discover_ the specialisations rather than us needing to specify them (this is true regardless of this PR); - if so, in the new form, we _could_ directly export this part of the test suite from `qutip.test` (our test suite would import this as well), and add a little bit of logic to allow filtering of which tests need to be run (class decorators, probably); - downstream packages could then test just by importing our classes and disabling any specialisations that are only on internal data-layer objects. I'm not 100% sure how I feel about this, but it's plausible - we'd still be able to add extra methods in our own test suite if we wanted them, because we could just derive from the classes, rather than defining the names into the test suite in those cases. ---. About us breaking downstream CI: having been a maintainer of QuTiP and now Qiskit, I have a deep-rooted hatred for any upstream package",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1723#issuecomment-979917075
https://github.com/qutip/qutip/pull/1723#issuecomment-979917075:694,Testability,test,testing,694,"If it's something we want to support, we'll need a bit of a rewrite of the data-layer testing infrastructure, but nothing too major. I'd be in favour of a bit of a larger restructure:; - rearrange the repo root to have `/src/qutip` and `/test/qutip` instead of `/qutip/tests` (I originally didn't like it, but I now see more and more benefits of the `/src` (or `/lib`) convention in Python projects).; - the current `qutip/tests` should entirely become `/test/qutip`; - a new `/src/qutip/test` becomes a fully-supported _public_ module, including base classes (such as the data-layer mixins) and things like that. We'd need to be careful, because reducing your possibilities for flexibility in testing generally sounds like a bad idea to me, but if we take care to be very limited, it could work. I suspect you won't be able to import the test suite from inside `qutip.core.data` because of cyclical dependencies, which is probably a good thing - it'll force us to put the structure the right way round immediately. For an idea pretty far out of left field:; - the data layer tests should really _discover_ the specialisations rather than us needing to specify them (this is true regardless of this PR); - if so, in the new form, we _could_ directly export this part of the test suite from `qutip.test` (our test suite would import this as well), and add a little bit of logic to allow filtering of which tests need to be run (class decorators, probably); - downstream packages could then test just by importing our classes and disabling any specialisations that are only on internal data-layer objects. I'm not 100% sure how I feel about this, but it's plausible - we'd still be able to add extra methods in our own test suite if we wanted them, because we could just derive from the classes, rather than defining the names into the test suite in those cases. ---. About us breaking downstream CI: having been a maintainer of QuTiP and now Qiskit, I have a deep-rooted hatred for any upstream package",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1723#issuecomment-979917075
https://github.com/qutip/qutip/pull/1723#issuecomment-979917075:839,Testability,test,test,839,"If it's something we want to support, we'll need a bit of a rewrite of the data-layer testing infrastructure, but nothing too major. I'd be in favour of a bit of a larger restructure:; - rearrange the repo root to have `/src/qutip` and `/test/qutip` instead of `/qutip/tests` (I originally didn't like it, but I now see more and more benefits of the `/src` (or `/lib`) convention in Python projects).; - the current `qutip/tests` should entirely become `/test/qutip`; - a new `/src/qutip/test` becomes a fully-supported _public_ module, including base classes (such as the data-layer mixins) and things like that. We'd need to be careful, because reducing your possibilities for flexibility in testing generally sounds like a bad idea to me, but if we take care to be very limited, it could work. I suspect you won't be able to import the test suite from inside `qutip.core.data` because of cyclical dependencies, which is probably a good thing - it'll force us to put the structure the right way round immediately. For an idea pretty far out of left field:; - the data layer tests should really _discover_ the specialisations rather than us needing to specify them (this is true regardless of this PR); - if so, in the new form, we _could_ directly export this part of the test suite from `qutip.test` (our test suite would import this as well), and add a little bit of logic to allow filtering of which tests need to be run (class decorators, probably); - downstream packages could then test just by importing our classes and disabling any specialisations that are only on internal data-layer objects. I'm not 100% sure how I feel about this, but it's plausible - we'd still be able to add extra methods in our own test suite if we wanted them, because we could just derive from the classes, rather than defining the names into the test suite in those cases. ---. About us breaking downstream CI: having been a maintainer of QuTiP and now Qiskit, I have a deep-rooted hatred for any upstream package",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1723#issuecomment-979917075
https://github.com/qutip/qutip/pull/1723#issuecomment-979917075:1076,Testability,test,tests,1076,"it of a larger restructure:; - rearrange the repo root to have `/src/qutip` and `/test/qutip` instead of `/qutip/tests` (I originally didn't like it, but I now see more and more benefits of the `/src` (or `/lib`) convention in Python projects).; - the current `qutip/tests` should entirely become `/test/qutip`; - a new `/src/qutip/test` becomes a fully-supported _public_ module, including base classes (such as the data-layer mixins) and things like that. We'd need to be careful, because reducing your possibilities for flexibility in testing generally sounds like a bad idea to me, but if we take care to be very limited, it could work. I suspect you won't be able to import the test suite from inside `qutip.core.data` because of cyclical dependencies, which is probably a good thing - it'll force us to put the structure the right way round immediately. For an idea pretty far out of left field:; - the data layer tests should really _discover_ the specialisations rather than us needing to specify them (this is true regardless of this PR); - if so, in the new form, we _could_ directly export this part of the test suite from `qutip.test` (our test suite would import this as well), and add a little bit of logic to allow filtering of which tests need to be run (class decorators, probably); - downstream packages could then test just by importing our classes and disabling any specialisations that are only on internal data-layer objects. I'm not 100% sure how I feel about this, but it's plausible - we'd still be able to add extra methods in our own test suite if we wanted them, because we could just derive from the classes, rather than defining the names into the test suite in those cases. ---. About us breaking downstream CI: having been a maintainer of QuTiP and now Qiskit, I have a deep-rooted hatred for any upstream package that forces CI failures on its dependents, because it _requires_ the lower packages to move ""fix CI"" way up to the top of their priority list; you can't m",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1723#issuecomment-979917075
https://github.com/qutip/qutip/pull/1723#issuecomment-979917075:1274,Testability,test,test,1274,"it of a larger restructure:; - rearrange the repo root to have `/src/qutip` and `/test/qutip` instead of `/qutip/tests` (I originally didn't like it, but I now see more and more benefits of the `/src` (or `/lib`) convention in Python projects).; - the current `qutip/tests` should entirely become `/test/qutip`; - a new `/src/qutip/test` becomes a fully-supported _public_ module, including base classes (such as the data-layer mixins) and things like that. We'd need to be careful, because reducing your possibilities for flexibility in testing generally sounds like a bad idea to me, but if we take care to be very limited, it could work. I suspect you won't be able to import the test suite from inside `qutip.core.data` because of cyclical dependencies, which is probably a good thing - it'll force us to put the structure the right way round immediately. For an idea pretty far out of left field:; - the data layer tests should really _discover_ the specialisations rather than us needing to specify them (this is true regardless of this PR); - if so, in the new form, we _could_ directly export this part of the test suite from `qutip.test` (our test suite would import this as well), and add a little bit of logic to allow filtering of which tests need to be run (class decorators, probably); - downstream packages could then test just by importing our classes and disabling any specialisations that are only on internal data-layer objects. I'm not 100% sure how I feel about this, but it's plausible - we'd still be able to add extra methods in our own test suite if we wanted them, because we could just derive from the classes, rather than defining the names into the test suite in those cases. ---. About us breaking downstream CI: having been a maintainer of QuTiP and now Qiskit, I have a deep-rooted hatred for any upstream package that forces CI failures on its dependents, because it _requires_ the lower packages to move ""fix CI"" way up to the top of their priority list; you can't m",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1723#issuecomment-979917075
https://github.com/qutip/qutip/pull/1723#issuecomment-979917075:1297,Testability,test,test,1297," `/qutip/tests` (I originally didn't like it, but I now see more and more benefits of the `/src` (or `/lib`) convention in Python projects).; - the current `qutip/tests` should entirely become `/test/qutip`; - a new `/src/qutip/test` becomes a fully-supported _public_ module, including base classes (such as the data-layer mixins) and things like that. We'd need to be careful, because reducing your possibilities for flexibility in testing generally sounds like a bad idea to me, but if we take care to be very limited, it could work. I suspect you won't be able to import the test suite from inside `qutip.core.data` because of cyclical dependencies, which is probably a good thing - it'll force us to put the structure the right way round immediately. For an idea pretty far out of left field:; - the data layer tests should really _discover_ the specialisations rather than us needing to specify them (this is true regardless of this PR); - if so, in the new form, we _could_ directly export this part of the test suite from `qutip.test` (our test suite would import this as well), and add a little bit of logic to allow filtering of which tests need to be run (class decorators, probably); - downstream packages could then test just by importing our classes and disabling any specialisations that are only on internal data-layer objects. I'm not 100% sure how I feel about this, but it's plausible - we'd still be able to add extra methods in our own test suite if we wanted them, because we could just derive from the classes, rather than defining the names into the test suite in those cases. ---. About us breaking downstream CI: having been a maintainer of QuTiP and now Qiskit, I have a deep-rooted hatred for any upstream package that forces CI failures on its dependents, because it _requires_ the lower packages to move ""fix CI"" way up to the top of their priority list; you can't merge _anything_ until CI is running again, which is very frustrating. It messes with all your workflows.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1723#issuecomment-979917075
https://github.com/qutip/qutip/pull/1723#issuecomment-979917075:1308,Testability,test,test,1308," `/qutip/tests` (I originally didn't like it, but I now see more and more benefits of the `/src` (or `/lib`) convention in Python projects).; - the current `qutip/tests` should entirely become `/test/qutip`; - a new `/src/qutip/test` becomes a fully-supported _public_ module, including base classes (such as the data-layer mixins) and things like that. We'd need to be careful, because reducing your possibilities for flexibility in testing generally sounds like a bad idea to me, but if we take care to be very limited, it could work. I suspect you won't be able to import the test suite from inside `qutip.core.data` because of cyclical dependencies, which is probably a good thing - it'll force us to put the structure the right way round immediately. For an idea pretty far out of left field:; - the data layer tests should really _discover_ the specialisations rather than us needing to specify them (this is true regardless of this PR); - if so, in the new form, we _could_ directly export this part of the test suite from `qutip.test` (our test suite would import this as well), and add a little bit of logic to allow filtering of which tests need to be run (class decorators, probably); - downstream packages could then test just by importing our classes and disabling any specialisations that are only on internal data-layer objects. I'm not 100% sure how I feel about this, but it's plausible - we'd still be able to add extra methods in our own test suite if we wanted them, because we could just derive from the classes, rather than defining the names into the test suite in those cases. ---. About us breaking downstream CI: having been a maintainer of QuTiP and now Qiskit, I have a deep-rooted hatred for any upstream package that forces CI failures on its dependents, because it _requires_ the lower packages to move ""fix CI"" way up to the top of their priority list; you can't merge _anything_ until CI is running again, which is very frustrating. It messes with all your workflows.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1723#issuecomment-979917075
https://github.com/qutip/qutip/pull/1723#issuecomment-979917075:1371,Testability,log,logic,1371," `/qutip/tests` (I originally didn't like it, but I now see more and more benefits of the `/src` (or `/lib`) convention in Python projects).; - the current `qutip/tests` should entirely become `/test/qutip`; - a new `/src/qutip/test` becomes a fully-supported _public_ module, including base classes (such as the data-layer mixins) and things like that. We'd need to be careful, because reducing your possibilities for flexibility in testing generally sounds like a bad idea to me, but if we take care to be very limited, it could work. I suspect you won't be able to import the test suite from inside `qutip.core.data` because of cyclical dependencies, which is probably a good thing - it'll force us to put the structure the right way round immediately. For an idea pretty far out of left field:; - the data layer tests should really _discover_ the specialisations rather than us needing to specify them (this is true regardless of this PR); - if so, in the new form, we _could_ directly export this part of the test suite from `qutip.test` (our test suite would import this as well), and add a little bit of logic to allow filtering of which tests need to be run (class decorators, probably); - downstream packages could then test just by importing our classes and disabling any specialisations that are only on internal data-layer objects. I'm not 100% sure how I feel about this, but it's plausible - we'd still be able to add extra methods in our own test suite if we wanted them, because we could just derive from the classes, rather than defining the names into the test suite in those cases. ---. About us breaking downstream CI: having been a maintainer of QuTiP and now Qiskit, I have a deep-rooted hatred for any upstream package that forces CI failures on its dependents, because it _requires_ the lower packages to move ""fix CI"" way up to the top of their priority list; you can't merge _anything_ until CI is running again, which is very frustrating. It messes with all your workflows.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1723#issuecomment-979917075
https://github.com/qutip/qutip/pull/1723#issuecomment-979917075:1405,Testability,test,tests,1405," `/qutip/tests` (I originally didn't like it, but I now see more and more benefits of the `/src` (or `/lib`) convention in Python projects).; - the current `qutip/tests` should entirely become `/test/qutip`; - a new `/src/qutip/test` becomes a fully-supported _public_ module, including base classes (such as the data-layer mixins) and things like that. We'd need to be careful, because reducing your possibilities for flexibility in testing generally sounds like a bad idea to me, but if we take care to be very limited, it could work. I suspect you won't be able to import the test suite from inside `qutip.core.data` because of cyclical dependencies, which is probably a good thing - it'll force us to put the structure the right way round immediately. For an idea pretty far out of left field:; - the data layer tests should really _discover_ the specialisations rather than us needing to specify them (this is true regardless of this PR); - if so, in the new form, we _could_ directly export this part of the test suite from `qutip.test` (our test suite would import this as well), and add a little bit of logic to allow filtering of which tests need to be run (class decorators, probably); - downstream packages could then test just by importing our classes and disabling any specialisations that are only on internal data-layer objects. I'm not 100% sure how I feel about this, but it's plausible - we'd still be able to add extra methods in our own test suite if we wanted them, because we could just derive from the classes, rather than defining the names into the test suite in those cases. ---. About us breaking downstream CI: having been a maintainer of QuTiP and now Qiskit, I have a deep-rooted hatred for any upstream package that forces CI failures on its dependents, because it _requires_ the lower packages to move ""fix CI"" way up to the top of their priority list; you can't merge _anything_ until CI is running again, which is very frustrating. It messes with all your workflows.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1723#issuecomment-979917075
https://github.com/qutip/qutip/pull/1723#issuecomment-979917075:1489,Testability,test,test,1489," `/qutip/tests` (I originally didn't like it, but I now see more and more benefits of the `/src` (or `/lib`) convention in Python projects).; - the current `qutip/tests` should entirely become `/test/qutip`; - a new `/src/qutip/test` becomes a fully-supported _public_ module, including base classes (such as the data-layer mixins) and things like that. We'd need to be careful, because reducing your possibilities for flexibility in testing generally sounds like a bad idea to me, but if we take care to be very limited, it could work. I suspect you won't be able to import the test suite from inside `qutip.core.data` because of cyclical dependencies, which is probably a good thing - it'll force us to put the structure the right way round immediately. For an idea pretty far out of left field:; - the data layer tests should really _discover_ the specialisations rather than us needing to specify them (this is true regardless of this PR); - if so, in the new form, we _could_ directly export this part of the test suite from `qutip.test` (our test suite would import this as well), and add a little bit of logic to allow filtering of which tests need to be run (class decorators, probably); - downstream packages could then test just by importing our classes and disabling any specialisations that are only on internal data-layer objects. I'm not 100% sure how I feel about this, but it's plausible - we'd still be able to add extra methods in our own test suite if we wanted them, because we could just derive from the classes, rather than defining the names into the test suite in those cases. ---. About us breaking downstream CI: having been a maintainer of QuTiP and now Qiskit, I have a deep-rooted hatred for any upstream package that forces CI failures on its dependents, because it _requires_ the lower packages to move ""fix CI"" way up to the top of their priority list; you can't merge _anything_ until CI is running again, which is very frustrating. It messes with all your workflows.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1723#issuecomment-979917075
https://github.com/qutip/qutip/pull/1723#issuecomment-979917075:1717,Testability,test,test,1717," `/qutip/tests` (I originally didn't like it, but I now see more and more benefits of the `/src` (or `/lib`) convention in Python projects).; - the current `qutip/tests` should entirely become `/test/qutip`; - a new `/src/qutip/test` becomes a fully-supported _public_ module, including base classes (such as the data-layer mixins) and things like that. We'd need to be careful, because reducing your possibilities for flexibility in testing generally sounds like a bad idea to me, but if we take care to be very limited, it could work. I suspect you won't be able to import the test suite from inside `qutip.core.data` because of cyclical dependencies, which is probably a good thing - it'll force us to put the structure the right way round immediately. For an idea pretty far out of left field:; - the data layer tests should really _discover_ the specialisations rather than us needing to specify them (this is true regardless of this PR); - if so, in the new form, we _could_ directly export this part of the test suite from `qutip.test` (our test suite would import this as well), and add a little bit of logic to allow filtering of which tests need to be run (class decorators, probably); - downstream packages could then test just by importing our classes and disabling any specialisations that are only on internal data-layer objects. I'm not 100% sure how I feel about this, but it's plausible - we'd still be able to add extra methods in our own test suite if we wanted them, because we could just derive from the classes, rather than defining the names into the test suite in those cases. ---. About us breaking downstream CI: having been a maintainer of QuTiP and now Qiskit, I have a deep-rooted hatred for any upstream package that forces CI failures on its dependents, because it _requires_ the lower packages to move ""fix CI"" way up to the top of their priority list; you can't merge _anything_ until CI is running again, which is very frustrating. It messes with all your workflows.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1723#issuecomment-979917075
https://github.com/qutip/qutip/pull/1723#issuecomment-979917075:1834,Testability,test,test,1834," `/qutip/tests` (I originally didn't like it, but I now see more and more benefits of the `/src` (or `/lib`) convention in Python projects).; - the current `qutip/tests` should entirely become `/test/qutip`; - a new `/src/qutip/test` becomes a fully-supported _public_ module, including base classes (such as the data-layer mixins) and things like that. We'd need to be careful, because reducing your possibilities for flexibility in testing generally sounds like a bad idea to me, but if we take care to be very limited, it could work. I suspect you won't be able to import the test suite from inside `qutip.core.data` because of cyclical dependencies, which is probably a good thing - it'll force us to put the structure the right way round immediately. For an idea pretty far out of left field:; - the data layer tests should really _discover_ the specialisations rather than us needing to specify them (this is true regardless of this PR); - if so, in the new form, we _could_ directly export this part of the test suite from `qutip.test` (our test suite would import this as well), and add a little bit of logic to allow filtering of which tests need to be run (class decorators, probably); - downstream packages could then test just by importing our classes and disabling any specialisations that are only on internal data-layer objects. I'm not 100% sure how I feel about this, but it's plausible - we'd still be able to add extra methods in our own test suite if we wanted them, because we could just derive from the classes, rather than defining the names into the test suite in those cases. ---. About us breaking downstream CI: having been a maintainer of QuTiP and now Qiskit, I have a deep-rooted hatred for any upstream package that forces CI failures on its dependents, because it _requires_ the lower packages to move ""fix CI"" way up to the top of their priority list; you can't merge _anything_ until CI is running again, which is very frustrating. It messes with all your workflows.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1723#issuecomment-979917075
https://github.com/qutip/qutip/pull/1723#issuecomment-981550356:770,Availability,down,downstream,770,"Thanks both @jakelishman and @hodgestar for your comments! I agree that I may be depending too much on the classes in `qutip.tests.core.data` to do the testing both in qutip-tensorflow and qutip-tensornetwork. I myself was worried of ""who is going to tests the tests"" if this trend continued with other packages. Reusing the `qutip.tests.core.data`'s code though helps to speed things up in the development process and also allows QuTiP to strictly define what each specialisation is meant to do. . As you mentioned above, I think it would be best to create a `qutip.core.data.testing` module where all the classes for testing are implemented. Then these classes could be tested to ensure that the proper tests are created and these classes ca be used by both QuTiP and downstream packages. I do not have time for this now but I will come to this later, so lets keep this PR open to discuss any ideas!. ----. > the data layer tests should really discover the specialisations rather than us needing to specify them (this is true regardless of this PR). I am not sure about this one. Automatic discovery of tests for specialisations seems to lead to very restricted flexibility in how tests are parametrized. For instance, I needed to change the `rtol` to accommodate the tests for the complex64 data layer in qutip-tensorflow and I am not sure how this could be added automatically. . Also, as @hodgestar mentioned today, you probably want to be explicit on adding tests so that you are confident that those tests are running. Otherwise you need to constantly check the log to ensure the proper tests are running. . Another thing is that by being explicit on what is tested, you could assert if the tested specialisation has not been registered (which actually happened to both qutip-cupy and qutip-tensorflow before: specialisations where being tested but, surprisingly, they were not registered).",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1723#issuecomment-981550356
https://github.com/qutip/qutip/pull/1723#issuecomment-981550356:81,Integrability,depend,depending,81,"Thanks both @jakelishman and @hodgestar for your comments! I agree that I may be depending too much on the classes in `qutip.tests.core.data` to do the testing both in qutip-tensorflow and qutip-tensornetwork. I myself was worried of ""who is going to tests the tests"" if this trend continued with other packages. Reusing the `qutip.tests.core.data`'s code though helps to speed things up in the development process and also allows QuTiP to strictly define what each specialisation is meant to do. . As you mentioned above, I think it would be best to create a `qutip.core.data.testing` module where all the classes for testing are implemented. Then these classes could be tested to ensure that the proper tests are created and these classes ca be used by both QuTiP and downstream packages. I do not have time for this now but I will come to this later, so lets keep this PR open to discuss any ideas!. ----. > the data layer tests should really discover the specialisations rather than us needing to specify them (this is true regardless of this PR). I am not sure about this one. Automatic discovery of tests for specialisations seems to lead to very restricted flexibility in how tests are parametrized. For instance, I needed to change the `rtol` to accommodate the tests for the complex64 data layer in qutip-tensorflow and I am not sure how this could be added automatically. . Also, as @hodgestar mentioned today, you probably want to be explicit on adding tests so that you are confident that those tests are running. Otherwise you need to constantly check the log to ensure the proper tests are running. . Another thing is that by being explicit on what is tested, you could assert if the tested specialisation has not been registered (which actually happened to both qutip-cupy and qutip-tensorflow before: specialisations where being tested but, surprisingly, they were not registered).",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1723#issuecomment-981550356
https://github.com/qutip/qutip/pull/1723#issuecomment-981550356:125,Testability,test,tests,125,"Thanks both @jakelishman and @hodgestar for your comments! I agree that I may be depending too much on the classes in `qutip.tests.core.data` to do the testing both in qutip-tensorflow and qutip-tensornetwork. I myself was worried of ""who is going to tests the tests"" if this trend continued with other packages. Reusing the `qutip.tests.core.data`'s code though helps to speed things up in the development process and also allows QuTiP to strictly define what each specialisation is meant to do. . As you mentioned above, I think it would be best to create a `qutip.core.data.testing` module where all the classes for testing are implemented. Then these classes could be tested to ensure that the proper tests are created and these classes ca be used by both QuTiP and downstream packages. I do not have time for this now but I will come to this later, so lets keep this PR open to discuss any ideas!. ----. > the data layer tests should really discover the specialisations rather than us needing to specify them (this is true regardless of this PR). I am not sure about this one. Automatic discovery of tests for specialisations seems to lead to very restricted flexibility in how tests are parametrized. For instance, I needed to change the `rtol` to accommodate the tests for the complex64 data layer in qutip-tensorflow and I am not sure how this could be added automatically. . Also, as @hodgestar mentioned today, you probably want to be explicit on adding tests so that you are confident that those tests are running. Otherwise you need to constantly check the log to ensure the proper tests are running. . Another thing is that by being explicit on what is tested, you could assert if the tested specialisation has not been registered (which actually happened to both qutip-cupy and qutip-tensorflow before: specialisations where being tested but, surprisingly, they were not registered).",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1723#issuecomment-981550356
https://github.com/qutip/qutip/pull/1723#issuecomment-981550356:152,Testability,test,testing,152,"Thanks both @jakelishman and @hodgestar for your comments! I agree that I may be depending too much on the classes in `qutip.tests.core.data` to do the testing both in qutip-tensorflow and qutip-tensornetwork. I myself was worried of ""who is going to tests the tests"" if this trend continued with other packages. Reusing the `qutip.tests.core.data`'s code though helps to speed things up in the development process and also allows QuTiP to strictly define what each specialisation is meant to do. . As you mentioned above, I think it would be best to create a `qutip.core.data.testing` module where all the classes for testing are implemented. Then these classes could be tested to ensure that the proper tests are created and these classes ca be used by both QuTiP and downstream packages. I do not have time for this now but I will come to this later, so lets keep this PR open to discuss any ideas!. ----. > the data layer tests should really discover the specialisations rather than us needing to specify them (this is true regardless of this PR). I am not sure about this one. Automatic discovery of tests for specialisations seems to lead to very restricted flexibility in how tests are parametrized. For instance, I needed to change the `rtol` to accommodate the tests for the complex64 data layer in qutip-tensorflow and I am not sure how this could be added automatically. . Also, as @hodgestar mentioned today, you probably want to be explicit on adding tests so that you are confident that those tests are running. Otherwise you need to constantly check the log to ensure the proper tests are running. . Another thing is that by being explicit on what is tested, you could assert if the tested specialisation has not been registered (which actually happened to both qutip-cupy and qutip-tensorflow before: specialisations where being tested but, surprisingly, they were not registered).",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1723#issuecomment-981550356
https://github.com/qutip/qutip/pull/1723#issuecomment-981550356:251,Testability,test,tests,251,"Thanks both @jakelishman and @hodgestar for your comments! I agree that I may be depending too much on the classes in `qutip.tests.core.data` to do the testing both in qutip-tensorflow and qutip-tensornetwork. I myself was worried of ""who is going to tests the tests"" if this trend continued with other packages. Reusing the `qutip.tests.core.data`'s code though helps to speed things up in the development process and also allows QuTiP to strictly define what each specialisation is meant to do. . As you mentioned above, I think it would be best to create a `qutip.core.data.testing` module where all the classes for testing are implemented. Then these classes could be tested to ensure that the proper tests are created and these classes ca be used by both QuTiP and downstream packages. I do not have time for this now but I will come to this later, so lets keep this PR open to discuss any ideas!. ----. > the data layer tests should really discover the specialisations rather than us needing to specify them (this is true regardless of this PR). I am not sure about this one. Automatic discovery of tests for specialisations seems to lead to very restricted flexibility in how tests are parametrized. For instance, I needed to change the `rtol` to accommodate the tests for the complex64 data layer in qutip-tensorflow and I am not sure how this could be added automatically. . Also, as @hodgestar mentioned today, you probably want to be explicit on adding tests so that you are confident that those tests are running. Otherwise you need to constantly check the log to ensure the proper tests are running. . Another thing is that by being explicit on what is tested, you could assert if the tested specialisation has not been registered (which actually happened to both qutip-cupy and qutip-tensorflow before: specialisations where being tested but, surprisingly, they were not registered).",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1723#issuecomment-981550356
https://github.com/qutip/qutip/pull/1723#issuecomment-981550356:261,Testability,test,tests,261,"Thanks both @jakelishman and @hodgestar for your comments! I agree that I may be depending too much on the classes in `qutip.tests.core.data` to do the testing both in qutip-tensorflow and qutip-tensornetwork. I myself was worried of ""who is going to tests the tests"" if this trend continued with other packages. Reusing the `qutip.tests.core.data`'s code though helps to speed things up in the development process and also allows QuTiP to strictly define what each specialisation is meant to do. . As you mentioned above, I think it would be best to create a `qutip.core.data.testing` module where all the classes for testing are implemented. Then these classes could be tested to ensure that the proper tests are created and these classes ca be used by both QuTiP and downstream packages. I do not have time for this now but I will come to this later, so lets keep this PR open to discuss any ideas!. ----. > the data layer tests should really discover the specialisations rather than us needing to specify them (this is true regardless of this PR). I am not sure about this one. Automatic discovery of tests for specialisations seems to lead to very restricted flexibility in how tests are parametrized. For instance, I needed to change the `rtol` to accommodate the tests for the complex64 data layer in qutip-tensorflow and I am not sure how this could be added automatically. . Also, as @hodgestar mentioned today, you probably want to be explicit on adding tests so that you are confident that those tests are running. Otherwise you need to constantly check the log to ensure the proper tests are running. . Another thing is that by being explicit on what is tested, you could assert if the tested specialisation has not been registered (which actually happened to both qutip-cupy and qutip-tensorflow before: specialisations where being tested but, surprisingly, they were not registered).",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1723#issuecomment-981550356
https://github.com/qutip/qutip/pull/1723#issuecomment-981550356:332,Testability,test,tests,332,"Thanks both @jakelishman and @hodgestar for your comments! I agree that I may be depending too much on the classes in `qutip.tests.core.data` to do the testing both in qutip-tensorflow and qutip-tensornetwork. I myself was worried of ""who is going to tests the tests"" if this trend continued with other packages. Reusing the `qutip.tests.core.data`'s code though helps to speed things up in the development process and also allows QuTiP to strictly define what each specialisation is meant to do. . As you mentioned above, I think it would be best to create a `qutip.core.data.testing` module where all the classes for testing are implemented. Then these classes could be tested to ensure that the proper tests are created and these classes ca be used by both QuTiP and downstream packages. I do not have time for this now but I will come to this later, so lets keep this PR open to discuss any ideas!. ----. > the data layer tests should really discover the specialisations rather than us needing to specify them (this is true regardless of this PR). I am not sure about this one. Automatic discovery of tests for specialisations seems to lead to very restricted flexibility in how tests are parametrized. For instance, I needed to change the `rtol` to accommodate the tests for the complex64 data layer in qutip-tensorflow and I am not sure how this could be added automatically. . Also, as @hodgestar mentioned today, you probably want to be explicit on adding tests so that you are confident that those tests are running. Otherwise you need to constantly check the log to ensure the proper tests are running. . Another thing is that by being explicit on what is tested, you could assert if the tested specialisation has not been registered (which actually happened to both qutip-cupy and qutip-tensorflow before: specialisations where being tested but, surprisingly, they were not registered).",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1723#issuecomment-981550356
https://github.com/qutip/qutip/pull/1723#issuecomment-981550356:577,Testability,test,testing,577,"Thanks both @jakelishman and @hodgestar for your comments! I agree that I may be depending too much on the classes in `qutip.tests.core.data` to do the testing both in qutip-tensorflow and qutip-tensornetwork. I myself was worried of ""who is going to tests the tests"" if this trend continued with other packages. Reusing the `qutip.tests.core.data`'s code though helps to speed things up in the development process and also allows QuTiP to strictly define what each specialisation is meant to do. . As you mentioned above, I think it would be best to create a `qutip.core.data.testing` module where all the classes for testing are implemented. Then these classes could be tested to ensure that the proper tests are created and these classes ca be used by both QuTiP and downstream packages. I do not have time for this now but I will come to this later, so lets keep this PR open to discuss any ideas!. ----. > the data layer tests should really discover the specialisations rather than us needing to specify them (this is true regardless of this PR). I am not sure about this one. Automatic discovery of tests for specialisations seems to lead to very restricted flexibility in how tests are parametrized. For instance, I needed to change the `rtol` to accommodate the tests for the complex64 data layer in qutip-tensorflow and I am not sure how this could be added automatically. . Also, as @hodgestar mentioned today, you probably want to be explicit on adding tests so that you are confident that those tests are running. Otherwise you need to constantly check the log to ensure the proper tests are running. . Another thing is that by being explicit on what is tested, you could assert if the tested specialisation has not been registered (which actually happened to both qutip-cupy and qutip-tensorflow before: specialisations where being tested but, surprisingly, they were not registered).",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1723#issuecomment-981550356
https://github.com/qutip/qutip/pull/1723#issuecomment-981550356:619,Testability,test,testing,619,"Thanks both @jakelishman and @hodgestar for your comments! I agree that I may be depending too much on the classes in `qutip.tests.core.data` to do the testing both in qutip-tensorflow and qutip-tensornetwork. I myself was worried of ""who is going to tests the tests"" if this trend continued with other packages. Reusing the `qutip.tests.core.data`'s code though helps to speed things up in the development process and also allows QuTiP to strictly define what each specialisation is meant to do. . As you mentioned above, I think it would be best to create a `qutip.core.data.testing` module where all the classes for testing are implemented. Then these classes could be tested to ensure that the proper tests are created and these classes ca be used by both QuTiP and downstream packages. I do not have time for this now but I will come to this later, so lets keep this PR open to discuss any ideas!. ----. > the data layer tests should really discover the specialisations rather than us needing to specify them (this is true regardless of this PR). I am not sure about this one. Automatic discovery of tests for specialisations seems to lead to very restricted flexibility in how tests are parametrized. For instance, I needed to change the `rtol` to accommodate the tests for the complex64 data layer in qutip-tensorflow and I am not sure how this could be added automatically. . Also, as @hodgestar mentioned today, you probably want to be explicit on adding tests so that you are confident that those tests are running. Otherwise you need to constantly check the log to ensure the proper tests are running. . Another thing is that by being explicit on what is tested, you could assert if the tested specialisation has not been registered (which actually happened to both qutip-cupy and qutip-tensorflow before: specialisations where being tested but, surprisingly, they were not registered).",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1723#issuecomment-981550356
https://github.com/qutip/qutip/pull/1723#issuecomment-981550356:672,Testability,test,tested,672,"Thanks both @jakelishman and @hodgestar for your comments! I agree that I may be depending too much on the classes in `qutip.tests.core.data` to do the testing both in qutip-tensorflow and qutip-tensornetwork. I myself was worried of ""who is going to tests the tests"" if this trend continued with other packages. Reusing the `qutip.tests.core.data`'s code though helps to speed things up in the development process and also allows QuTiP to strictly define what each specialisation is meant to do. . As you mentioned above, I think it would be best to create a `qutip.core.data.testing` module where all the classes for testing are implemented. Then these classes could be tested to ensure that the proper tests are created and these classes ca be used by both QuTiP and downstream packages. I do not have time for this now but I will come to this later, so lets keep this PR open to discuss any ideas!. ----. > the data layer tests should really discover the specialisations rather than us needing to specify them (this is true regardless of this PR). I am not sure about this one. Automatic discovery of tests for specialisations seems to lead to very restricted flexibility in how tests are parametrized. For instance, I needed to change the `rtol` to accommodate the tests for the complex64 data layer in qutip-tensorflow and I am not sure how this could be added automatically. . Also, as @hodgestar mentioned today, you probably want to be explicit on adding tests so that you are confident that those tests are running. Otherwise you need to constantly check the log to ensure the proper tests are running. . Another thing is that by being explicit on what is tested, you could assert if the tested specialisation has not been registered (which actually happened to both qutip-cupy and qutip-tensorflow before: specialisations where being tested but, surprisingly, they were not registered).",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1723#issuecomment-981550356
https://github.com/qutip/qutip/pull/1723#issuecomment-981550356:705,Testability,test,tests,705,"Thanks both @jakelishman and @hodgestar for your comments! I agree that I may be depending too much on the classes in `qutip.tests.core.data` to do the testing both in qutip-tensorflow and qutip-tensornetwork. I myself was worried of ""who is going to tests the tests"" if this trend continued with other packages. Reusing the `qutip.tests.core.data`'s code though helps to speed things up in the development process and also allows QuTiP to strictly define what each specialisation is meant to do. . As you mentioned above, I think it would be best to create a `qutip.core.data.testing` module where all the classes for testing are implemented. Then these classes could be tested to ensure that the proper tests are created and these classes ca be used by both QuTiP and downstream packages. I do not have time for this now but I will come to this later, so lets keep this PR open to discuss any ideas!. ----. > the data layer tests should really discover the specialisations rather than us needing to specify them (this is true regardless of this PR). I am not sure about this one. Automatic discovery of tests for specialisations seems to lead to very restricted flexibility in how tests are parametrized. For instance, I needed to change the `rtol` to accommodate the tests for the complex64 data layer in qutip-tensorflow and I am not sure how this could be added automatically. . Also, as @hodgestar mentioned today, you probably want to be explicit on adding tests so that you are confident that those tests are running. Otherwise you need to constantly check the log to ensure the proper tests are running. . Another thing is that by being explicit on what is tested, you could assert if the tested specialisation has not been registered (which actually happened to both qutip-cupy and qutip-tensorflow before: specialisations where being tested but, surprisingly, they were not registered).",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1723#issuecomment-981550356
https://github.com/qutip/qutip/pull/1723#issuecomment-981550356:926,Testability,test,tests,926,"Thanks both @jakelishman and @hodgestar for your comments! I agree that I may be depending too much on the classes in `qutip.tests.core.data` to do the testing both in qutip-tensorflow and qutip-tensornetwork. I myself was worried of ""who is going to tests the tests"" if this trend continued with other packages. Reusing the `qutip.tests.core.data`'s code though helps to speed things up in the development process and also allows QuTiP to strictly define what each specialisation is meant to do. . As you mentioned above, I think it would be best to create a `qutip.core.data.testing` module where all the classes for testing are implemented. Then these classes could be tested to ensure that the proper tests are created and these classes ca be used by both QuTiP and downstream packages. I do not have time for this now but I will come to this later, so lets keep this PR open to discuss any ideas!. ----. > the data layer tests should really discover the specialisations rather than us needing to specify them (this is true regardless of this PR). I am not sure about this one. Automatic discovery of tests for specialisations seems to lead to very restricted flexibility in how tests are parametrized. For instance, I needed to change the `rtol` to accommodate the tests for the complex64 data layer in qutip-tensorflow and I am not sure how this could be added automatically. . Also, as @hodgestar mentioned today, you probably want to be explicit on adding tests so that you are confident that those tests are running. Otherwise you need to constantly check the log to ensure the proper tests are running. . Another thing is that by being explicit on what is tested, you could assert if the tested specialisation has not been registered (which actually happened to both qutip-cupy and qutip-tensorflow before: specialisations where being tested but, surprisingly, they were not registered).",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1723#issuecomment-981550356
https://github.com/qutip/qutip/pull/1723#issuecomment-981550356:1105,Testability,test,tests,1105,"Thanks both @jakelishman and @hodgestar for your comments! I agree that I may be depending too much on the classes in `qutip.tests.core.data` to do the testing both in qutip-tensorflow and qutip-tensornetwork. I myself was worried of ""who is going to tests the tests"" if this trend continued with other packages. Reusing the `qutip.tests.core.data`'s code though helps to speed things up in the development process and also allows QuTiP to strictly define what each specialisation is meant to do. . As you mentioned above, I think it would be best to create a `qutip.core.data.testing` module where all the classes for testing are implemented. Then these classes could be tested to ensure that the proper tests are created and these classes ca be used by both QuTiP and downstream packages. I do not have time for this now but I will come to this later, so lets keep this PR open to discuss any ideas!. ----. > the data layer tests should really discover the specialisations rather than us needing to specify them (this is true regardless of this PR). I am not sure about this one. Automatic discovery of tests for specialisations seems to lead to very restricted flexibility in how tests are parametrized. For instance, I needed to change the `rtol` to accommodate the tests for the complex64 data layer in qutip-tensorflow and I am not sure how this could be added automatically. . Also, as @hodgestar mentioned today, you probably want to be explicit on adding tests so that you are confident that those tests are running. Otherwise you need to constantly check the log to ensure the proper tests are running. . Another thing is that by being explicit on what is tested, you could assert if the tested specialisation has not been registered (which actually happened to both qutip-cupy and qutip-tensorflow before: specialisations where being tested but, surprisingly, they were not registered).",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1723#issuecomment-981550356
https://github.com/qutip/qutip/pull/1723#issuecomment-981550356:1183,Testability,test,tests,1183,"Thanks both @jakelishman and @hodgestar for your comments! I agree that I may be depending too much on the classes in `qutip.tests.core.data` to do the testing both in qutip-tensorflow and qutip-tensornetwork. I myself was worried of ""who is going to tests the tests"" if this trend continued with other packages. Reusing the `qutip.tests.core.data`'s code though helps to speed things up in the development process and also allows QuTiP to strictly define what each specialisation is meant to do. . As you mentioned above, I think it would be best to create a `qutip.core.data.testing` module where all the classes for testing are implemented. Then these classes could be tested to ensure that the proper tests are created and these classes ca be used by both QuTiP and downstream packages. I do not have time for this now but I will come to this later, so lets keep this PR open to discuss any ideas!. ----. > the data layer tests should really discover the specialisations rather than us needing to specify them (this is true regardless of this PR). I am not sure about this one. Automatic discovery of tests for specialisations seems to lead to very restricted flexibility in how tests are parametrized. For instance, I needed to change the `rtol` to accommodate the tests for the complex64 data layer in qutip-tensorflow and I am not sure how this could be added automatically. . Also, as @hodgestar mentioned today, you probably want to be explicit on adding tests so that you are confident that those tests are running. Otherwise you need to constantly check the log to ensure the proper tests are running. . Another thing is that by being explicit on what is tested, you could assert if the tested specialisation has not been registered (which actually happened to both qutip-cupy and qutip-tensorflow before: specialisations where being tested but, surprisingly, they were not registered).",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1723#issuecomment-981550356
https://github.com/qutip/qutip/pull/1723#issuecomment-981550356:1270,Testability,test,tests,1270,"Thanks both @jakelishman and @hodgestar for your comments! I agree that I may be depending too much on the classes in `qutip.tests.core.data` to do the testing both in qutip-tensorflow and qutip-tensornetwork. I myself was worried of ""who is going to tests the tests"" if this trend continued with other packages. Reusing the `qutip.tests.core.data`'s code though helps to speed things up in the development process and also allows QuTiP to strictly define what each specialisation is meant to do. . As you mentioned above, I think it would be best to create a `qutip.core.data.testing` module where all the classes for testing are implemented. Then these classes could be tested to ensure that the proper tests are created and these classes ca be used by both QuTiP and downstream packages. I do not have time for this now but I will come to this later, so lets keep this PR open to discuss any ideas!. ----. > the data layer tests should really discover the specialisations rather than us needing to specify them (this is true regardless of this PR). I am not sure about this one. Automatic discovery of tests for specialisations seems to lead to very restricted flexibility in how tests are parametrized. For instance, I needed to change the `rtol` to accommodate the tests for the complex64 data layer in qutip-tensorflow and I am not sure how this could be added automatically. . Also, as @hodgestar mentioned today, you probably want to be explicit on adding tests so that you are confident that those tests are running. Otherwise you need to constantly check the log to ensure the proper tests are running. . Another thing is that by being explicit on what is tested, you could assert if the tested specialisation has not been registered (which actually happened to both qutip-cupy and qutip-tensorflow before: specialisations where being tested but, surprisingly, they were not registered).",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1723#issuecomment-981550356
https://github.com/qutip/qutip/pull/1723#issuecomment-981550356:1464,Testability,test,tests,1464,"Thanks both @jakelishman and @hodgestar for your comments! I agree that I may be depending too much on the classes in `qutip.tests.core.data` to do the testing both in qutip-tensorflow and qutip-tensornetwork. I myself was worried of ""who is going to tests the tests"" if this trend continued with other packages. Reusing the `qutip.tests.core.data`'s code though helps to speed things up in the development process and also allows QuTiP to strictly define what each specialisation is meant to do. . As you mentioned above, I think it would be best to create a `qutip.core.data.testing` module where all the classes for testing are implemented. Then these classes could be tested to ensure that the proper tests are created and these classes ca be used by both QuTiP and downstream packages. I do not have time for this now but I will come to this later, so lets keep this PR open to discuss any ideas!. ----. > the data layer tests should really discover the specialisations rather than us needing to specify them (this is true regardless of this PR). I am not sure about this one. Automatic discovery of tests for specialisations seems to lead to very restricted flexibility in how tests are parametrized. For instance, I needed to change the `rtol` to accommodate the tests for the complex64 data layer in qutip-tensorflow and I am not sure how this could be added automatically. . Also, as @hodgestar mentioned today, you probably want to be explicit on adding tests so that you are confident that those tests are running. Otherwise you need to constantly check the log to ensure the proper tests are running. . Another thing is that by being explicit on what is tested, you could assert if the tested specialisation has not been registered (which actually happened to both qutip-cupy and qutip-tensorflow before: specialisations where being tested but, surprisingly, they were not registered).",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1723#issuecomment-981550356
https://github.com/qutip/qutip/pull/1723#issuecomment-981550356:1507,Testability,test,tests,1507,"Thanks both @jakelishman and @hodgestar for your comments! I agree that I may be depending too much on the classes in `qutip.tests.core.data` to do the testing both in qutip-tensorflow and qutip-tensornetwork. I myself was worried of ""who is going to tests the tests"" if this trend continued with other packages. Reusing the `qutip.tests.core.data`'s code though helps to speed things up in the development process and also allows QuTiP to strictly define what each specialisation is meant to do. . As you mentioned above, I think it would be best to create a `qutip.core.data.testing` module where all the classes for testing are implemented. Then these classes could be tested to ensure that the proper tests are created and these classes ca be used by both QuTiP and downstream packages. I do not have time for this now but I will come to this later, so lets keep this PR open to discuss any ideas!. ----. > the data layer tests should really discover the specialisations rather than us needing to specify them (this is true regardless of this PR). I am not sure about this one. Automatic discovery of tests for specialisations seems to lead to very restricted flexibility in how tests are parametrized. For instance, I needed to change the `rtol` to accommodate the tests for the complex64 data layer in qutip-tensorflow and I am not sure how this could be added automatically. . Also, as @hodgestar mentioned today, you probably want to be explicit on adding tests so that you are confident that those tests are running. Otherwise you need to constantly check the log to ensure the proper tests are running. . Another thing is that by being explicit on what is tested, you could assert if the tested specialisation has not been registered (which actually happened to both qutip-cupy and qutip-tensorflow before: specialisations where being tested but, surprisingly, they were not registered).",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1723#issuecomment-981550356
https://github.com/qutip/qutip/pull/1723#issuecomment-981550356:1569,Testability,log,log,1569,"Thanks both @jakelishman and @hodgestar for your comments! I agree that I may be depending too much on the classes in `qutip.tests.core.data` to do the testing both in qutip-tensorflow and qutip-tensornetwork. I myself was worried of ""who is going to tests the tests"" if this trend continued with other packages. Reusing the `qutip.tests.core.data`'s code though helps to speed things up in the development process and also allows QuTiP to strictly define what each specialisation is meant to do. . As you mentioned above, I think it would be best to create a `qutip.core.data.testing` module where all the classes for testing are implemented. Then these classes could be tested to ensure that the proper tests are created and these classes ca be used by both QuTiP and downstream packages. I do not have time for this now but I will come to this later, so lets keep this PR open to discuss any ideas!. ----. > the data layer tests should really discover the specialisations rather than us needing to specify them (this is true regardless of this PR). I am not sure about this one. Automatic discovery of tests for specialisations seems to lead to very restricted flexibility in how tests are parametrized. For instance, I needed to change the `rtol` to accommodate the tests for the complex64 data layer in qutip-tensorflow and I am not sure how this could be added automatically. . Also, as @hodgestar mentioned today, you probably want to be explicit on adding tests so that you are confident that those tests are running. Otherwise you need to constantly check the log to ensure the proper tests are running. . Another thing is that by being explicit on what is tested, you could assert if the tested specialisation has not been registered (which actually happened to both qutip-cupy and qutip-tensorflow before: specialisations where being tested but, surprisingly, they were not registered).",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1723#issuecomment-981550356
https://github.com/qutip/qutip/pull/1723#issuecomment-981550356:1594,Testability,test,tests,1594,"Thanks both @jakelishman and @hodgestar for your comments! I agree that I may be depending too much on the classes in `qutip.tests.core.data` to do the testing both in qutip-tensorflow and qutip-tensornetwork. I myself was worried of ""who is going to tests the tests"" if this trend continued with other packages. Reusing the `qutip.tests.core.data`'s code though helps to speed things up in the development process and also allows QuTiP to strictly define what each specialisation is meant to do. . As you mentioned above, I think it would be best to create a `qutip.core.data.testing` module where all the classes for testing are implemented. Then these classes could be tested to ensure that the proper tests are created and these classes ca be used by both QuTiP and downstream packages. I do not have time for this now but I will come to this later, so lets keep this PR open to discuss any ideas!. ----. > the data layer tests should really discover the specialisations rather than us needing to specify them (this is true regardless of this PR). I am not sure about this one. Automatic discovery of tests for specialisations seems to lead to very restricted flexibility in how tests are parametrized. For instance, I needed to change the `rtol` to accommodate the tests for the complex64 data layer in qutip-tensorflow and I am not sure how this could be added automatically. . Also, as @hodgestar mentioned today, you probably want to be explicit on adding tests so that you are confident that those tests are running. Otherwise you need to constantly check the log to ensure the proper tests are running. . Another thing is that by being explicit on what is tested, you could assert if the tested specialisation has not been registered (which actually happened to both qutip-cupy and qutip-tensorflow before: specialisations where being tested but, surprisingly, they were not registered).",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1723#issuecomment-981550356
https://github.com/qutip/qutip/pull/1723#issuecomment-981550356:1666,Testability,test,tested,1666,"Thanks both @jakelishman and @hodgestar for your comments! I agree that I may be depending too much on the classes in `qutip.tests.core.data` to do the testing both in qutip-tensorflow and qutip-tensornetwork. I myself was worried of ""who is going to tests the tests"" if this trend continued with other packages. Reusing the `qutip.tests.core.data`'s code though helps to speed things up in the development process and also allows QuTiP to strictly define what each specialisation is meant to do. . As you mentioned above, I think it would be best to create a `qutip.core.data.testing` module where all the classes for testing are implemented. Then these classes could be tested to ensure that the proper tests are created and these classes ca be used by both QuTiP and downstream packages. I do not have time for this now but I will come to this later, so lets keep this PR open to discuss any ideas!. ----. > the data layer tests should really discover the specialisations rather than us needing to specify them (this is true regardless of this PR). I am not sure about this one. Automatic discovery of tests for specialisations seems to lead to very restricted flexibility in how tests are parametrized. For instance, I needed to change the `rtol` to accommodate the tests for the complex64 data layer in qutip-tensorflow and I am not sure how this could be added automatically. . Also, as @hodgestar mentioned today, you probably want to be explicit on adding tests so that you are confident that those tests are running. Otherwise you need to constantly check the log to ensure the proper tests are running. . Another thing is that by being explicit on what is tested, you could assert if the tested specialisation has not been registered (which actually happened to both qutip-cupy and qutip-tensorflow before: specialisations where being tested but, surprisingly, they were not registered).",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1723#issuecomment-981550356
https://github.com/qutip/qutip/pull/1723#issuecomment-981550356:1684,Testability,assert,assert,1684,"Thanks both @jakelishman and @hodgestar for your comments! I agree that I may be depending too much on the classes in `qutip.tests.core.data` to do the testing both in qutip-tensorflow and qutip-tensornetwork. I myself was worried of ""who is going to tests the tests"" if this trend continued with other packages. Reusing the `qutip.tests.core.data`'s code though helps to speed things up in the development process and also allows QuTiP to strictly define what each specialisation is meant to do. . As you mentioned above, I think it would be best to create a `qutip.core.data.testing` module where all the classes for testing are implemented. Then these classes could be tested to ensure that the proper tests are created and these classes ca be used by both QuTiP and downstream packages. I do not have time for this now but I will come to this later, so lets keep this PR open to discuss any ideas!. ----. > the data layer tests should really discover the specialisations rather than us needing to specify them (this is true regardless of this PR). I am not sure about this one. Automatic discovery of tests for specialisations seems to lead to very restricted flexibility in how tests are parametrized. For instance, I needed to change the `rtol` to accommodate the tests for the complex64 data layer in qutip-tensorflow and I am not sure how this could be added automatically. . Also, as @hodgestar mentioned today, you probably want to be explicit on adding tests so that you are confident that those tests are running. Otherwise you need to constantly check the log to ensure the proper tests are running. . Another thing is that by being explicit on what is tested, you could assert if the tested specialisation has not been registered (which actually happened to both qutip-cupy and qutip-tensorflow before: specialisations where being tested but, surprisingly, they were not registered).",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1723#issuecomment-981550356
https://github.com/qutip/qutip/pull/1723#issuecomment-981550356:1698,Testability,test,tested,1698,"Thanks both @jakelishman and @hodgestar for your comments! I agree that I may be depending too much on the classes in `qutip.tests.core.data` to do the testing both in qutip-tensorflow and qutip-tensornetwork. I myself was worried of ""who is going to tests the tests"" if this trend continued with other packages. Reusing the `qutip.tests.core.data`'s code though helps to speed things up in the development process and also allows QuTiP to strictly define what each specialisation is meant to do. . As you mentioned above, I think it would be best to create a `qutip.core.data.testing` module where all the classes for testing are implemented. Then these classes could be tested to ensure that the proper tests are created and these classes ca be used by both QuTiP and downstream packages. I do not have time for this now but I will come to this later, so lets keep this PR open to discuss any ideas!. ----. > the data layer tests should really discover the specialisations rather than us needing to specify them (this is true regardless of this PR). I am not sure about this one. Automatic discovery of tests for specialisations seems to lead to very restricted flexibility in how tests are parametrized. For instance, I needed to change the `rtol` to accommodate the tests for the complex64 data layer in qutip-tensorflow and I am not sure how this could be added automatically. . Also, as @hodgestar mentioned today, you probably want to be explicit on adding tests so that you are confident that those tests are running. Otherwise you need to constantly check the log to ensure the proper tests are running. . Another thing is that by being explicit on what is tested, you could assert if the tested specialisation has not been registered (which actually happened to both qutip-cupy and qutip-tensorflow before: specialisations where being tested but, surprisingly, they were not registered).",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1723#issuecomment-981550356
https://github.com/qutip/qutip/pull/1723#issuecomment-981550356:1845,Testability,test,tested,1845,"Thanks both @jakelishman and @hodgestar for your comments! I agree that I may be depending too much on the classes in `qutip.tests.core.data` to do the testing both in qutip-tensorflow and qutip-tensornetwork. I myself was worried of ""who is going to tests the tests"" if this trend continued with other packages. Reusing the `qutip.tests.core.data`'s code though helps to speed things up in the development process and also allows QuTiP to strictly define what each specialisation is meant to do. . As you mentioned above, I think it would be best to create a `qutip.core.data.testing` module where all the classes for testing are implemented. Then these classes could be tested to ensure that the proper tests are created and these classes ca be used by both QuTiP and downstream packages. I do not have time for this now but I will come to this later, so lets keep this PR open to discuss any ideas!. ----. > the data layer tests should really discover the specialisations rather than us needing to specify them (this is true regardless of this PR). I am not sure about this one. Automatic discovery of tests for specialisations seems to lead to very restricted flexibility in how tests are parametrized. For instance, I needed to change the `rtol` to accommodate the tests for the complex64 data layer in qutip-tensorflow and I am not sure how this could be added automatically. . Also, as @hodgestar mentioned today, you probably want to be explicit on adding tests so that you are confident that those tests are running. Otherwise you need to constantly check the log to ensure the proper tests are running. . Another thing is that by being explicit on what is tested, you could assert if the tested specialisation has not been registered (which actually happened to both qutip-cupy and qutip-tensorflow before: specialisations where being tested but, surprisingly, they were not registered).",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1723#issuecomment-981550356
https://github.com/qutip/qutip/pull/1723#issuecomment-981562735:1004,Availability,toler,tolerances,1004,"I think the module should really be `qutip.testing` (or `qutip.test` if the name's already taken), not `qutip.core.data.testing`, if you're going to add one. It's very likely to be the case in the future (if it isn't already) that you'll need additional dependencies to define the tests, and you don't want to force _all_ runtime users to have them to install QuTiP. If you put the package in a separate top-level module, it's _far_ easier to separate out all the code, and have `qutip/__init__.py` not import `qutip.testing`, so things won't break. Also, tests generally need to work with a fully imported version of the module. If we start putting testing infrastructure in the core, we're going to encode a whole lot of cyclical dependencies right away, or end up with `testing` modules scattered all across the codebase, for no real gain. For discovery: that would only happen during test generation, which comes after importing the modules and defining the classes, so you'd still be able to define tolerances and influence how the tests ran. The problem with _not_ having discovery is that it becomes very easy to forget to test a function, and with so much of the machinery automated, it's also easy to forget it when reviewing a PR. That's particularly true once you have external contributors writing these sorts of things - we have it in Qiskit, where people add things to our ""standard equivalence library"", and new contributors and new reviewers don't know where all the different tests are, so our discovery tests have helped catch bugs. That happens even with super experienced team members. I'd argue that code coverage metrics are possibly a better way of detecting missing tests - that fails safe if you add broken code and forget to test it, whereas having to specify the tests explicitly means you can accidentally add broken code to a dispatcher and not know, if you forgot to add the test.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1723#issuecomment-981562735
https://github.com/qutip/qutip/pull/1723#issuecomment-981562735:352,Deployability,install,install,352,"I think the module should really be `qutip.testing` (or `qutip.test` if the name's already taken), not `qutip.core.data.testing`, if you're going to add one. It's very likely to be the case in the future (if it isn't already) that you'll need additional dependencies to define the tests, and you don't want to force _all_ runtime users to have them to install QuTiP. If you put the package in a separate top-level module, it's _far_ easier to separate out all the code, and have `qutip/__init__.py` not import `qutip.testing`, so things won't break. Also, tests generally need to work with a fully imported version of the module. If we start putting testing infrastructure in the core, we're going to encode a whole lot of cyclical dependencies right away, or end up with `testing` modules scattered all across the codebase, for no real gain. For discovery: that would only happen during test generation, which comes after importing the modules and defining the classes, so you'd still be able to define tolerances and influence how the tests ran. The problem with _not_ having discovery is that it becomes very easy to forget to test a function, and with so much of the machinery automated, it's also easy to forget it when reviewing a PR. That's particularly true once you have external contributors writing these sorts of things - we have it in Qiskit, where people add things to our ""standard equivalence library"", and new contributors and new reviewers don't know where all the different tests are, so our discovery tests have helped catch bugs. That happens even with super experienced team members. I'd argue that code coverage metrics are possibly a better way of detecting missing tests - that fails safe if you add broken code and forget to test it, whereas having to specify the tests explicitly means you can accidentally add broken code to a dispatcher and not know, if you forgot to add the test.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1723#issuecomment-981562735
https://github.com/qutip/qutip/pull/1723#issuecomment-981562735:254,Integrability,depend,dependencies,254,"I think the module should really be `qutip.testing` (or `qutip.test` if the name's already taken), not `qutip.core.data.testing`, if you're going to add one. It's very likely to be the case in the future (if it isn't already) that you'll need additional dependencies to define the tests, and you don't want to force _all_ runtime users to have them to install QuTiP. If you put the package in a separate top-level module, it's _far_ easier to separate out all the code, and have `qutip/__init__.py` not import `qutip.testing`, so things won't break. Also, tests generally need to work with a fully imported version of the module. If we start putting testing infrastructure in the core, we're going to encode a whole lot of cyclical dependencies right away, or end up with `testing` modules scattered all across the codebase, for no real gain. For discovery: that would only happen during test generation, which comes after importing the modules and defining the classes, so you'd still be able to define tolerances and influence how the tests ran. The problem with _not_ having discovery is that it becomes very easy to forget to test a function, and with so much of the machinery automated, it's also easy to forget it when reviewing a PR. That's particularly true once you have external contributors writing these sorts of things - we have it in Qiskit, where people add things to our ""standard equivalence library"", and new contributors and new reviewers don't know where all the different tests are, so our discovery tests have helped catch bugs. That happens even with super experienced team members. I'd argue that code coverage metrics are possibly a better way of detecting missing tests - that fails safe if you add broken code and forget to test it, whereas having to specify the tests explicitly means you can accidentally add broken code to a dispatcher and not know, if you forgot to add the test.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1723#issuecomment-981562735
https://github.com/qutip/qutip/pull/1723#issuecomment-981562735:732,Integrability,depend,dependencies,732,"I think the module should really be `qutip.testing` (or `qutip.test` if the name's already taken), not `qutip.core.data.testing`, if you're going to add one. It's very likely to be the case in the future (if it isn't already) that you'll need additional dependencies to define the tests, and you don't want to force _all_ runtime users to have them to install QuTiP. If you put the package in a separate top-level module, it's _far_ easier to separate out all the code, and have `qutip/__init__.py` not import `qutip.testing`, so things won't break. Also, tests generally need to work with a fully imported version of the module. If we start putting testing infrastructure in the core, we're going to encode a whole lot of cyclical dependencies right away, or end up with `testing` modules scattered all across the codebase, for no real gain. For discovery: that would only happen during test generation, which comes after importing the modules and defining the classes, so you'd still be able to define tolerances and influence how the tests ran. The problem with _not_ having discovery is that it becomes very easy to forget to test a function, and with so much of the machinery automated, it's also easy to forget it when reviewing a PR. That's particularly true once you have external contributors writing these sorts of things - we have it in Qiskit, where people add things to our ""standard equivalence library"", and new contributors and new reviewers don't know where all the different tests are, so our discovery tests have helped catch bugs. That happens even with super experienced team members. I'd argue that code coverage metrics are possibly a better way of detecting missing tests - that fails safe if you add broken code and forget to test it, whereas having to specify the tests explicitly means you can accidentally add broken code to a dispatcher and not know, if you forgot to add the test.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1723#issuecomment-981562735
https://github.com/qutip/qutip/pull/1723#issuecomment-981562735:1672,Safety,detect,detecting,1672,"I think the module should really be `qutip.testing` (or `qutip.test` if the name's already taken), not `qutip.core.data.testing`, if you're going to add one. It's very likely to be the case in the future (if it isn't already) that you'll need additional dependencies to define the tests, and you don't want to force _all_ runtime users to have them to install QuTiP. If you put the package in a separate top-level module, it's _far_ easier to separate out all the code, and have `qutip/__init__.py` not import `qutip.testing`, so things won't break. Also, tests generally need to work with a fully imported version of the module. If we start putting testing infrastructure in the core, we're going to encode a whole lot of cyclical dependencies right away, or end up with `testing` modules scattered all across the codebase, for no real gain. For discovery: that would only happen during test generation, which comes after importing the modules and defining the classes, so you'd still be able to define tolerances and influence how the tests ran. The problem with _not_ having discovery is that it becomes very easy to forget to test a function, and with so much of the machinery automated, it's also easy to forget it when reviewing a PR. That's particularly true once you have external contributors writing these sorts of things - we have it in Qiskit, where people add things to our ""standard equivalence library"", and new contributors and new reviewers don't know where all the different tests are, so our discovery tests have helped catch bugs. That happens even with super experienced team members. I'd argue that code coverage metrics are possibly a better way of detecting missing tests - that fails safe if you add broken code and forget to test it, whereas having to specify the tests explicitly means you can accidentally add broken code to a dispatcher and not know, if you forgot to add the test.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1723#issuecomment-981562735
https://github.com/qutip/qutip/pull/1723#issuecomment-981562735:1709,Safety,safe,safe,1709,"I think the module should really be `qutip.testing` (or `qutip.test` if the name's already taken), not `qutip.core.data.testing`, if you're going to add one. It's very likely to be the case in the future (if it isn't already) that you'll need additional dependencies to define the tests, and you don't want to force _all_ runtime users to have them to install QuTiP. If you put the package in a separate top-level module, it's _far_ easier to separate out all the code, and have `qutip/__init__.py` not import `qutip.testing`, so things won't break. Also, tests generally need to work with a fully imported version of the module. If we start putting testing infrastructure in the core, we're going to encode a whole lot of cyclical dependencies right away, or end up with `testing` modules scattered all across the codebase, for no real gain. For discovery: that would only happen during test generation, which comes after importing the modules and defining the classes, so you'd still be able to define tolerances and influence how the tests ran. The problem with _not_ having discovery is that it becomes very easy to forget to test a function, and with so much of the machinery automated, it's also easy to forget it when reviewing a PR. That's particularly true once you have external contributors writing these sorts of things - we have it in Qiskit, where people add things to our ""standard equivalence library"", and new contributors and new reviewers don't know where all the different tests are, so our discovery tests have helped catch bugs. That happens even with super experienced team members. I'd argue that code coverage metrics are possibly a better way of detecting missing tests - that fails safe if you add broken code and forget to test it, whereas having to specify the tests explicitly means you can accidentally add broken code to a dispatcher and not know, if you forgot to add the test.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1723#issuecomment-981562735
https://github.com/qutip/qutip/pull/1723#issuecomment-981562735:43,Testability,test,testing,43,"I think the module should really be `qutip.testing` (or `qutip.test` if the name's already taken), not `qutip.core.data.testing`, if you're going to add one. It's very likely to be the case in the future (if it isn't already) that you'll need additional dependencies to define the tests, and you don't want to force _all_ runtime users to have them to install QuTiP. If you put the package in a separate top-level module, it's _far_ easier to separate out all the code, and have `qutip/__init__.py` not import `qutip.testing`, so things won't break. Also, tests generally need to work with a fully imported version of the module. If we start putting testing infrastructure in the core, we're going to encode a whole lot of cyclical dependencies right away, or end up with `testing` modules scattered all across the codebase, for no real gain. For discovery: that would only happen during test generation, which comes after importing the modules and defining the classes, so you'd still be able to define tolerances and influence how the tests ran. The problem with _not_ having discovery is that it becomes very easy to forget to test a function, and with so much of the machinery automated, it's also easy to forget it when reviewing a PR. That's particularly true once you have external contributors writing these sorts of things - we have it in Qiskit, where people add things to our ""standard equivalence library"", and new contributors and new reviewers don't know where all the different tests are, so our discovery tests have helped catch bugs. That happens even with super experienced team members. I'd argue that code coverage metrics are possibly a better way of detecting missing tests - that fails safe if you add broken code and forget to test it, whereas having to specify the tests explicitly means you can accidentally add broken code to a dispatcher and not know, if you forgot to add the test.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1723#issuecomment-981562735
https://github.com/qutip/qutip/pull/1723#issuecomment-981562735:63,Testability,test,test,63,"I think the module should really be `qutip.testing` (or `qutip.test` if the name's already taken), not `qutip.core.data.testing`, if you're going to add one. It's very likely to be the case in the future (if it isn't already) that you'll need additional dependencies to define the tests, and you don't want to force _all_ runtime users to have them to install QuTiP. If you put the package in a separate top-level module, it's _far_ easier to separate out all the code, and have `qutip/__init__.py` not import `qutip.testing`, so things won't break. Also, tests generally need to work with a fully imported version of the module. If we start putting testing infrastructure in the core, we're going to encode a whole lot of cyclical dependencies right away, or end up with `testing` modules scattered all across the codebase, for no real gain. For discovery: that would only happen during test generation, which comes after importing the modules and defining the classes, so you'd still be able to define tolerances and influence how the tests ran. The problem with _not_ having discovery is that it becomes very easy to forget to test a function, and with so much of the machinery automated, it's also easy to forget it when reviewing a PR. That's particularly true once you have external contributors writing these sorts of things - we have it in Qiskit, where people add things to our ""standard equivalence library"", and new contributors and new reviewers don't know where all the different tests are, so our discovery tests have helped catch bugs. That happens even with super experienced team members. I'd argue that code coverage metrics are possibly a better way of detecting missing tests - that fails safe if you add broken code and forget to test it, whereas having to specify the tests explicitly means you can accidentally add broken code to a dispatcher and not know, if you forgot to add the test.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1723#issuecomment-981562735
https://github.com/qutip/qutip/pull/1723#issuecomment-981562735:120,Testability,test,testing,120,"I think the module should really be `qutip.testing` (or `qutip.test` if the name's already taken), not `qutip.core.data.testing`, if you're going to add one. It's very likely to be the case in the future (if it isn't already) that you'll need additional dependencies to define the tests, and you don't want to force _all_ runtime users to have them to install QuTiP. If you put the package in a separate top-level module, it's _far_ easier to separate out all the code, and have `qutip/__init__.py` not import `qutip.testing`, so things won't break. Also, tests generally need to work with a fully imported version of the module. If we start putting testing infrastructure in the core, we're going to encode a whole lot of cyclical dependencies right away, or end up with `testing` modules scattered all across the codebase, for no real gain. For discovery: that would only happen during test generation, which comes after importing the modules and defining the classes, so you'd still be able to define tolerances and influence how the tests ran. The problem with _not_ having discovery is that it becomes very easy to forget to test a function, and with so much of the machinery automated, it's also easy to forget it when reviewing a PR. That's particularly true once you have external contributors writing these sorts of things - we have it in Qiskit, where people add things to our ""standard equivalence library"", and new contributors and new reviewers don't know where all the different tests are, so our discovery tests have helped catch bugs. That happens even with super experienced team members. I'd argue that code coverage metrics are possibly a better way of detecting missing tests - that fails safe if you add broken code and forget to test it, whereas having to specify the tests explicitly means you can accidentally add broken code to a dispatcher and not know, if you forgot to add the test.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1723#issuecomment-981562735
https://github.com/qutip/qutip/pull/1723#issuecomment-981562735:281,Testability,test,tests,281,"I think the module should really be `qutip.testing` (or `qutip.test` if the name's already taken), not `qutip.core.data.testing`, if you're going to add one. It's very likely to be the case in the future (if it isn't already) that you'll need additional dependencies to define the tests, and you don't want to force _all_ runtime users to have them to install QuTiP. If you put the package in a separate top-level module, it's _far_ easier to separate out all the code, and have `qutip/__init__.py` not import `qutip.testing`, so things won't break. Also, tests generally need to work with a fully imported version of the module. If we start putting testing infrastructure in the core, we're going to encode a whole lot of cyclical dependencies right away, or end up with `testing` modules scattered all across the codebase, for no real gain. For discovery: that would only happen during test generation, which comes after importing the modules and defining the classes, so you'd still be able to define tolerances and influence how the tests ran. The problem with _not_ having discovery is that it becomes very easy to forget to test a function, and with so much of the machinery automated, it's also easy to forget it when reviewing a PR. That's particularly true once you have external contributors writing these sorts of things - we have it in Qiskit, where people add things to our ""standard equivalence library"", and new contributors and new reviewers don't know where all the different tests are, so our discovery tests have helped catch bugs. That happens even with super experienced team members. I'd argue that code coverage metrics are possibly a better way of detecting missing tests - that fails safe if you add broken code and forget to test it, whereas having to specify the tests explicitly means you can accidentally add broken code to a dispatcher and not know, if you forgot to add the test.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1723#issuecomment-981562735
https://github.com/qutip/qutip/pull/1723#issuecomment-981562735:517,Testability,test,testing,517,"I think the module should really be `qutip.testing` (or `qutip.test` if the name's already taken), not `qutip.core.data.testing`, if you're going to add one. It's very likely to be the case in the future (if it isn't already) that you'll need additional dependencies to define the tests, and you don't want to force _all_ runtime users to have them to install QuTiP. If you put the package in a separate top-level module, it's _far_ easier to separate out all the code, and have `qutip/__init__.py` not import `qutip.testing`, so things won't break. Also, tests generally need to work with a fully imported version of the module. If we start putting testing infrastructure in the core, we're going to encode a whole lot of cyclical dependencies right away, or end up with `testing` modules scattered all across the codebase, for no real gain. For discovery: that would only happen during test generation, which comes after importing the modules and defining the classes, so you'd still be able to define tolerances and influence how the tests ran. The problem with _not_ having discovery is that it becomes very easy to forget to test a function, and with so much of the machinery automated, it's also easy to forget it when reviewing a PR. That's particularly true once you have external contributors writing these sorts of things - we have it in Qiskit, where people add things to our ""standard equivalence library"", and new contributors and new reviewers don't know where all the different tests are, so our discovery tests have helped catch bugs. That happens even with super experienced team members. I'd argue that code coverage metrics are possibly a better way of detecting missing tests - that fails safe if you add broken code and forget to test it, whereas having to specify the tests explicitly means you can accidentally add broken code to a dispatcher and not know, if you forgot to add the test.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1723#issuecomment-981562735
https://github.com/qutip/qutip/pull/1723#issuecomment-981562735:556,Testability,test,tests,556,"I think the module should really be `qutip.testing` (or `qutip.test` if the name's already taken), not `qutip.core.data.testing`, if you're going to add one. It's very likely to be the case in the future (if it isn't already) that you'll need additional dependencies to define the tests, and you don't want to force _all_ runtime users to have them to install QuTiP. If you put the package in a separate top-level module, it's _far_ easier to separate out all the code, and have `qutip/__init__.py` not import `qutip.testing`, so things won't break. Also, tests generally need to work with a fully imported version of the module. If we start putting testing infrastructure in the core, we're going to encode a whole lot of cyclical dependencies right away, or end up with `testing` modules scattered all across the codebase, for no real gain. For discovery: that would only happen during test generation, which comes after importing the modules and defining the classes, so you'd still be able to define tolerances and influence how the tests ran. The problem with _not_ having discovery is that it becomes very easy to forget to test a function, and with so much of the machinery automated, it's also easy to forget it when reviewing a PR. That's particularly true once you have external contributors writing these sorts of things - we have it in Qiskit, where people add things to our ""standard equivalence library"", and new contributors and new reviewers don't know where all the different tests are, so our discovery tests have helped catch bugs. That happens even with super experienced team members. I'd argue that code coverage metrics are possibly a better way of detecting missing tests - that fails safe if you add broken code and forget to test it, whereas having to specify the tests explicitly means you can accidentally add broken code to a dispatcher and not know, if you forgot to add the test.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1723#issuecomment-981562735
https://github.com/qutip/qutip/pull/1723#issuecomment-981562735:650,Testability,test,testing,650,"I think the module should really be `qutip.testing` (or `qutip.test` if the name's already taken), not `qutip.core.data.testing`, if you're going to add one. It's very likely to be the case in the future (if it isn't already) that you'll need additional dependencies to define the tests, and you don't want to force _all_ runtime users to have them to install QuTiP. If you put the package in a separate top-level module, it's _far_ easier to separate out all the code, and have `qutip/__init__.py` not import `qutip.testing`, so things won't break. Also, tests generally need to work with a fully imported version of the module. If we start putting testing infrastructure in the core, we're going to encode a whole lot of cyclical dependencies right away, or end up with `testing` modules scattered all across the codebase, for no real gain. For discovery: that would only happen during test generation, which comes after importing the modules and defining the classes, so you'd still be able to define tolerances and influence how the tests ran. The problem with _not_ having discovery is that it becomes very easy to forget to test a function, and with so much of the machinery automated, it's also easy to forget it when reviewing a PR. That's particularly true once you have external contributors writing these sorts of things - we have it in Qiskit, where people add things to our ""standard equivalence library"", and new contributors and new reviewers don't know where all the different tests are, so our discovery tests have helped catch bugs. That happens even with super experienced team members. I'd argue that code coverage metrics are possibly a better way of detecting missing tests - that fails safe if you add broken code and forget to test it, whereas having to specify the tests explicitly means you can accidentally add broken code to a dispatcher and not know, if you forgot to add the test.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1723#issuecomment-981562735
https://github.com/qutip/qutip/pull/1723#issuecomment-981562735:773,Testability,test,testing,773,"I think the module should really be `qutip.testing` (or `qutip.test` if the name's already taken), not `qutip.core.data.testing`, if you're going to add one. It's very likely to be the case in the future (if it isn't already) that you'll need additional dependencies to define the tests, and you don't want to force _all_ runtime users to have them to install QuTiP. If you put the package in a separate top-level module, it's _far_ easier to separate out all the code, and have `qutip/__init__.py` not import `qutip.testing`, so things won't break. Also, tests generally need to work with a fully imported version of the module. If we start putting testing infrastructure in the core, we're going to encode a whole lot of cyclical dependencies right away, or end up with `testing` modules scattered all across the codebase, for no real gain. For discovery: that would only happen during test generation, which comes after importing the modules and defining the classes, so you'd still be able to define tolerances and influence how the tests ran. The problem with _not_ having discovery is that it becomes very easy to forget to test a function, and with so much of the machinery automated, it's also easy to forget it when reviewing a PR. That's particularly true once you have external contributors writing these sorts of things - we have it in Qiskit, where people add things to our ""standard equivalence library"", and new contributors and new reviewers don't know where all the different tests are, so our discovery tests have helped catch bugs. That happens even with super experienced team members. I'd argue that code coverage metrics are possibly a better way of detecting missing tests - that fails safe if you add broken code and forget to test it, whereas having to specify the tests explicitly means you can accidentally add broken code to a dispatcher and not know, if you forgot to add the test.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1723#issuecomment-981562735
https://github.com/qutip/qutip/pull/1723#issuecomment-981562735:888,Testability,test,test,888,"I think the module should really be `qutip.testing` (or `qutip.test` if the name's already taken), not `qutip.core.data.testing`, if you're going to add one. It's very likely to be the case in the future (if it isn't already) that you'll need additional dependencies to define the tests, and you don't want to force _all_ runtime users to have them to install QuTiP. If you put the package in a separate top-level module, it's _far_ easier to separate out all the code, and have `qutip/__init__.py` not import `qutip.testing`, so things won't break. Also, tests generally need to work with a fully imported version of the module. If we start putting testing infrastructure in the core, we're going to encode a whole lot of cyclical dependencies right away, or end up with `testing` modules scattered all across the codebase, for no real gain. For discovery: that would only happen during test generation, which comes after importing the modules and defining the classes, so you'd still be able to define tolerances and influence how the tests ran. The problem with _not_ having discovery is that it becomes very easy to forget to test a function, and with so much of the machinery automated, it's also easy to forget it when reviewing a PR. That's particularly true once you have external contributors writing these sorts of things - we have it in Qiskit, where people add things to our ""standard equivalence library"", and new contributors and new reviewers don't know where all the different tests are, so our discovery tests have helped catch bugs. That happens even with super experienced team members. I'd argue that code coverage metrics are possibly a better way of detecting missing tests - that fails safe if you add broken code and forget to test it, whereas having to specify the tests explicitly means you can accidentally add broken code to a dispatcher and not know, if you forgot to add the test.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1723#issuecomment-981562735
https://github.com/qutip/qutip/pull/1723#issuecomment-981562735:1037,Testability,test,tests,1037,"I think the module should really be `qutip.testing` (or `qutip.test` if the name's already taken), not `qutip.core.data.testing`, if you're going to add one. It's very likely to be the case in the future (if it isn't already) that you'll need additional dependencies to define the tests, and you don't want to force _all_ runtime users to have them to install QuTiP. If you put the package in a separate top-level module, it's _far_ easier to separate out all the code, and have `qutip/__init__.py` not import `qutip.testing`, so things won't break. Also, tests generally need to work with a fully imported version of the module. If we start putting testing infrastructure in the core, we're going to encode a whole lot of cyclical dependencies right away, or end up with `testing` modules scattered all across the codebase, for no real gain. For discovery: that would only happen during test generation, which comes after importing the modules and defining the classes, so you'd still be able to define tolerances and influence how the tests ran. The problem with _not_ having discovery is that it becomes very easy to forget to test a function, and with so much of the machinery automated, it's also easy to forget it when reviewing a PR. That's particularly true once you have external contributors writing these sorts of things - we have it in Qiskit, where people add things to our ""standard equivalence library"", and new contributors and new reviewers don't know where all the different tests are, so our discovery tests have helped catch bugs. That happens even with super experienced team members. I'd argue that code coverage metrics are possibly a better way of detecting missing tests - that fails safe if you add broken code and forget to test it, whereas having to specify the tests explicitly means you can accidentally add broken code to a dispatcher and not know, if you forgot to add the test.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1723#issuecomment-981562735
https://github.com/qutip/qutip/pull/1723#issuecomment-981562735:1130,Testability,test,test,1130,"I think the module should really be `qutip.testing` (or `qutip.test` if the name's already taken), not `qutip.core.data.testing`, if you're going to add one. It's very likely to be the case in the future (if it isn't already) that you'll need additional dependencies to define the tests, and you don't want to force _all_ runtime users to have them to install QuTiP. If you put the package in a separate top-level module, it's _far_ easier to separate out all the code, and have `qutip/__init__.py` not import `qutip.testing`, so things won't break. Also, tests generally need to work with a fully imported version of the module. If we start putting testing infrastructure in the core, we're going to encode a whole lot of cyclical dependencies right away, or end up with `testing` modules scattered all across the codebase, for no real gain. For discovery: that would only happen during test generation, which comes after importing the modules and defining the classes, so you'd still be able to define tolerances and influence how the tests ran. The problem with _not_ having discovery is that it becomes very easy to forget to test a function, and with so much of the machinery automated, it's also easy to forget it when reviewing a PR. That's particularly true once you have external contributors writing these sorts of things - we have it in Qiskit, where people add things to our ""standard equivalence library"", and new contributors and new reviewers don't know where all the different tests are, so our discovery tests have helped catch bugs. That happens even with super experienced team members. I'd argue that code coverage metrics are possibly a better way of detecting missing tests - that fails safe if you add broken code and forget to test it, whereas having to specify the tests explicitly means you can accidentally add broken code to a dispatcher and not know, if you forgot to add the test.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1723#issuecomment-981562735
https://github.com/qutip/qutip/pull/1723#issuecomment-981562735:1493,Testability,test,tests,1493,"I think the module should really be `qutip.testing` (or `qutip.test` if the name's already taken), not `qutip.core.data.testing`, if you're going to add one. It's very likely to be the case in the future (if it isn't already) that you'll need additional dependencies to define the tests, and you don't want to force _all_ runtime users to have them to install QuTiP. If you put the package in a separate top-level module, it's _far_ easier to separate out all the code, and have `qutip/__init__.py` not import `qutip.testing`, so things won't break. Also, tests generally need to work with a fully imported version of the module. If we start putting testing infrastructure in the core, we're going to encode a whole lot of cyclical dependencies right away, or end up with `testing` modules scattered all across the codebase, for no real gain. For discovery: that would only happen during test generation, which comes after importing the modules and defining the classes, so you'd still be able to define tolerances and influence how the tests ran. The problem with _not_ having discovery is that it becomes very easy to forget to test a function, and with so much of the machinery automated, it's also easy to forget it when reviewing a PR. That's particularly true once you have external contributors writing these sorts of things - we have it in Qiskit, where people add things to our ""standard equivalence library"", and new contributors and new reviewers don't know where all the different tests are, so our discovery tests have helped catch bugs. That happens even with super experienced team members. I'd argue that code coverage metrics are possibly a better way of detecting missing tests - that fails safe if you add broken code and forget to test it, whereas having to specify the tests explicitly means you can accidentally add broken code to a dispatcher and not know, if you forgot to add the test.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1723#issuecomment-981562735
https://github.com/qutip/qutip/pull/1723#issuecomment-981562735:1521,Testability,test,tests,1521,"I think the module should really be `qutip.testing` (or `qutip.test` if the name's already taken), not `qutip.core.data.testing`, if you're going to add one. It's very likely to be the case in the future (if it isn't already) that you'll need additional dependencies to define the tests, and you don't want to force _all_ runtime users to have them to install QuTiP. If you put the package in a separate top-level module, it's _far_ easier to separate out all the code, and have `qutip/__init__.py` not import `qutip.testing`, so things won't break. Also, tests generally need to work with a fully imported version of the module. If we start putting testing infrastructure in the core, we're going to encode a whole lot of cyclical dependencies right away, or end up with `testing` modules scattered all across the codebase, for no real gain. For discovery: that would only happen during test generation, which comes after importing the modules and defining the classes, so you'd still be able to define tolerances and influence how the tests ran. The problem with _not_ having discovery is that it becomes very easy to forget to test a function, and with so much of the machinery automated, it's also easy to forget it when reviewing a PR. That's particularly true once you have external contributors writing these sorts of things - we have it in Qiskit, where people add things to our ""standard equivalence library"", and new contributors and new reviewers don't know where all the different tests are, so our discovery tests have helped catch bugs. That happens even with super experienced team members. I'd argue that code coverage metrics are possibly a better way of detecting missing tests - that fails safe if you add broken code and forget to test it, whereas having to specify the tests explicitly means you can accidentally add broken code to a dispatcher and not know, if you forgot to add the test.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1723#issuecomment-981562735
https://github.com/qutip/qutip/pull/1723#issuecomment-981562735:1690,Testability,test,tests,1690,"I think the module should really be `qutip.testing` (or `qutip.test` if the name's already taken), not `qutip.core.data.testing`, if you're going to add one. It's very likely to be the case in the future (if it isn't already) that you'll need additional dependencies to define the tests, and you don't want to force _all_ runtime users to have them to install QuTiP. If you put the package in a separate top-level module, it's _far_ easier to separate out all the code, and have `qutip/__init__.py` not import `qutip.testing`, so things won't break. Also, tests generally need to work with a fully imported version of the module. If we start putting testing infrastructure in the core, we're going to encode a whole lot of cyclical dependencies right away, or end up with `testing` modules scattered all across the codebase, for no real gain. For discovery: that would only happen during test generation, which comes after importing the modules and defining the classes, so you'd still be able to define tolerances and influence how the tests ran. The problem with _not_ having discovery is that it becomes very easy to forget to test a function, and with so much of the machinery automated, it's also easy to forget it when reviewing a PR. That's particularly true once you have external contributors writing these sorts of things - we have it in Qiskit, where people add things to our ""standard equivalence library"", and new contributors and new reviewers don't know where all the different tests are, so our discovery tests have helped catch bugs. That happens even with super experienced team members. I'd argue that code coverage metrics are possibly a better way of detecting missing tests - that fails safe if you add broken code and forget to test it, whereas having to specify the tests explicitly means you can accidentally add broken code to a dispatcher and not know, if you forgot to add the test.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1723#issuecomment-981562735
https://github.com/qutip/qutip/pull/1723#issuecomment-981562735:1751,Testability,test,test,1751,"I think the module should really be `qutip.testing` (or `qutip.test` if the name's already taken), not `qutip.core.data.testing`, if you're going to add one. It's very likely to be the case in the future (if it isn't already) that you'll need additional dependencies to define the tests, and you don't want to force _all_ runtime users to have them to install QuTiP. If you put the package in a separate top-level module, it's _far_ easier to separate out all the code, and have `qutip/__init__.py` not import `qutip.testing`, so things won't break. Also, tests generally need to work with a fully imported version of the module. If we start putting testing infrastructure in the core, we're going to encode a whole lot of cyclical dependencies right away, or end up with `testing` modules scattered all across the codebase, for no real gain. For discovery: that would only happen during test generation, which comes after importing the modules and defining the classes, so you'd still be able to define tolerances and influence how the tests ran. The problem with _not_ having discovery is that it becomes very easy to forget to test a function, and with so much of the machinery automated, it's also easy to forget it when reviewing a PR. That's particularly true once you have external contributors writing these sorts of things - we have it in Qiskit, where people add things to our ""standard equivalence library"", and new contributors and new reviewers don't know where all the different tests are, so our discovery tests have helped catch bugs. That happens even with super experienced team members. I'd argue that code coverage metrics are possibly a better way of detecting missing tests - that fails safe if you add broken code and forget to test it, whereas having to specify the tests explicitly means you can accidentally add broken code to a dispatcher and not know, if you forgot to add the test.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1723#issuecomment-981562735
https://github.com/qutip/qutip/pull/1723#issuecomment-981562735:1790,Testability,test,tests,1790,"I think the module should really be `qutip.testing` (or `qutip.test` if the name's already taken), not `qutip.core.data.testing`, if you're going to add one. It's very likely to be the case in the future (if it isn't already) that you'll need additional dependencies to define the tests, and you don't want to force _all_ runtime users to have them to install QuTiP. If you put the package in a separate top-level module, it's _far_ easier to separate out all the code, and have `qutip/__init__.py` not import `qutip.testing`, so things won't break. Also, tests generally need to work with a fully imported version of the module. If we start putting testing infrastructure in the core, we're going to encode a whole lot of cyclical dependencies right away, or end up with `testing` modules scattered all across the codebase, for no real gain. For discovery: that would only happen during test generation, which comes after importing the modules and defining the classes, so you'd still be able to define tolerances and influence how the tests ran. The problem with _not_ having discovery is that it becomes very easy to forget to test a function, and with so much of the machinery automated, it's also easy to forget it when reviewing a PR. That's particularly true once you have external contributors writing these sorts of things - we have it in Qiskit, where people add things to our ""standard equivalence library"", and new contributors and new reviewers don't know where all the different tests are, so our discovery tests have helped catch bugs. That happens even with super experienced team members. I'd argue that code coverage metrics are possibly a better way of detecting missing tests - that fails safe if you add broken code and forget to test it, whereas having to specify the tests explicitly means you can accidentally add broken code to a dispatcher and not know, if you forgot to add the test.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1723#issuecomment-981562735
https://github.com/qutip/qutip/pull/1723#issuecomment-981562735:1905,Testability,test,test,1905,"I think the module should really be `qutip.testing` (or `qutip.test` if the name's already taken), not `qutip.core.data.testing`, if you're going to add one. It's very likely to be the case in the future (if it isn't already) that you'll need additional dependencies to define the tests, and you don't want to force _all_ runtime users to have them to install QuTiP. If you put the package in a separate top-level module, it's _far_ easier to separate out all the code, and have `qutip/__init__.py` not import `qutip.testing`, so things won't break. Also, tests generally need to work with a fully imported version of the module. If we start putting testing infrastructure in the core, we're going to encode a whole lot of cyclical dependencies right away, or end up with `testing` modules scattered all across the codebase, for no real gain. For discovery: that would only happen during test generation, which comes after importing the modules and defining the classes, so you'd still be able to define tolerances and influence how the tests ran. The problem with _not_ having discovery is that it becomes very easy to forget to test a function, and with so much of the machinery automated, it's also easy to forget it when reviewing a PR. That's particularly true once you have external contributors writing these sorts of things - we have it in Qiskit, where people add things to our ""standard equivalence library"", and new contributors and new reviewers don't know where all the different tests are, so our discovery tests have helped catch bugs. That happens even with super experienced team members. I'd argue that code coverage metrics are possibly a better way of detecting missing tests - that fails safe if you add broken code and forget to test it, whereas having to specify the tests explicitly means you can accidentally add broken code to a dispatcher and not know, if you forgot to add the test.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1723#issuecomment-981562735
https://github.com/qutip/qutip/pull/1726#issuecomment-987532370:337,Deployability,continuous,continuously,337,"The fermionic stuff looks to me! For the change in the terminator, I see the logic I guess. Also makes it easier for the user to include it or not, without remaking the bath. I have some reservations about it just because I can imagine someone following the examples and using jupyter notebook rerunning the same cell multiple times and continuously modifying their Hsys or something? But that can just be made clear in the examples so lets go ahead and merge this.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1726#issuecomment-987532370
https://github.com/qutip/qutip/pull/1726#issuecomment-987532370:77,Testability,log,logic,77,"The fermionic stuff looks to me! For the change in the terminator, I see the logic I guess. Also makes it easier for the user to include it or not, without remaking the bath. I have some reservations about it just because I can imagine someone following the examples and using jupyter notebook rerunning the same cell multiple times and continuously modifying their Hsys or something? But that can just be made clear in the examples so lets go ahead and merge this.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1726#issuecomment-987532370
https://github.com/qutip/qutip/pull/1726#issuecomment-987532370:411,Usability,clear,clear,411,"The fermionic stuff looks to me! For the change in the terminator, I see the logic I guess. Also makes it easier for the user to include it or not, without remaking the bath. I have some reservations about it just because I can imagine someone following the examples and using jupyter notebook rerunning the same cell multiple times and continuously modifying their Hsys or something? But that can just be made clear in the examples so lets go ahead and merge this.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1726#issuecomment-987532370
https://github.com/qutip/qutip/pull/1727#issuecomment-979886946:170,Testability,test,tested,170,"But also, yeah, this is exactly the change I meant when I wrote that comment in the other issue. Unless something's broken in the interrim, it definitely works because I tested the swap fairly heavily when I wrote it, which is also why there's some particularly weird templated code in `core/data/src/matmul_csr_vector.{hpp,cpp}`: https://github.com/qutip/qutip/blob/fbb7fad5bc205910228db622d90601c82db45e4b/qutip/core/data/src/matmul_csr_vector.cpp#L114-L148",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1727#issuecomment-979886946
https://github.com/qutip/qutip/pull/1727#issuecomment-980007660:17,Availability,failure,failures,17,"The current test failures can probably be fixed by merging #1651, so I should review that.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1727#issuecomment-980007660
https://github.com/qutip/qutip/pull/1727#issuecomment-980007660:12,Testability,test,test,12,"The current test failures can probably be fixed by merging #1651, so I should review that.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1727#issuecomment-980007660
https://github.com/qutip/qutip/pull/1727#issuecomment-980026178:20,Integrability,depend,dependent,20,"#1651 create a time-dependent bloch redfield tensor, but do not create a new `brmesolve` using it and remove the `br_codegen.py` etc. that uses it. So it won't solve it yet.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1727#issuecomment-980026178
https://github.com/qutip/qutip/pull/1727#issuecomment-980042116:22,Integrability,depend,dependent,22,"> #1651 create a time-dependent bloch redfield tensor, but do not create a new `brmesolve` using it and remove the `br_codegen.py` etc. that uses it. So it won't solve it yet. I don't think we need to rush -- we can finish #1651 and then do the next one, and then hopefully come back to this one. At least coefficients seem to work now, so hopefully people who are keen can try out this branch in the mean time if they want to.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1727#issuecomment-980042116
https://github.com/qutip/qutip/pull/1727#issuecomment-1017280259:81,Testability,Test,Tests,81,"#1651 has been merged into dev.major and I've merged that back into this branch. Tests should still fail, but this branch is at least up to date again.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1727#issuecomment-1017280259
https://github.com/qutip/qutip/pull/1727#issuecomment-1050000793:123,Availability,failure,failure,123,Confirming that the only tests that are failing currently are the `brmesolve` related tests. The previous commit fixed one failure in the coefficient tests.,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1727#issuecomment-1050000793
https://github.com/qutip/qutip/pull/1727#issuecomment-1050000793:25,Testability,test,tests,25,Confirming that the only tests that are failing currently are the `brmesolve` related tests. The previous commit fixed one failure in the coefficient tests.,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1727#issuecomment-1050000793
https://github.com/qutip/qutip/pull/1727#issuecomment-1050000793:86,Testability,test,tests,86,Confirming that the only tests that are failing currently are the `brmesolve` related tests. The previous commit fixed one failure in the coefficient tests.,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1727#issuecomment-1050000793
https://github.com/qutip/qutip/pull/1727#issuecomment-1050000793:150,Testability,test,tests,150,Confirming that the only tests that are failing currently are the `brmesolve` related tests. The previous commit fixed one failure in the coefficient tests.,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1727#issuecomment-1050000793
https://github.com/qutip/qutip/pull/1727#issuecomment-1103686513:6,Testability,Test,Tests,6,Oooh. Tests pass. Perhaps we can merge the branch?. @Ericgig Would you mind reviewing?,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1727#issuecomment-1103686513
https://github.com/qutip/qutip/pull/1727#issuecomment-1104573990:121,Deployability,release,release,121,"If we look at https://github.com/cython/cython/issues/4310, they plan to deprecate the compilation time `IF` in a future release.; They suggest using cmacro or code generation to replace this. I suggest to take more time thinking about this and use those method instead. As it is, we would have to set a compilation environment variable each time something want to `cimport Data`, even from outside qutip...",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1727#issuecomment-1104573990
https://github.com/qutip/qutip/pull/1727#issuecomment-1104573990:328,Modifiability,variab,variable,328,"If we look at https://github.com/cython/cython/issues/4310, they plan to deprecate the compilation time `IF` in a future release.; They suggest using cmacro or code generation to replace this. I suggest to take more time thinking about this and use those method instead. As it is, we would have to set a compilation environment variable each time something want to `cimport Data`, even from outside qutip...",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1727#issuecomment-1104573990
https://github.com/qutip/qutip/pull/1727#issuecomment-1104929052:521,Security,expose,expose,521,"@Ericgig I think it's unavoidable to have some sort of global state that tells the C compiler which type to choose, and I think passing it as a compilation option is a simple and straight forward solution. Using macros won't change the need for a compilation flag and will make fetching the correct numpy type trickier. If cython does eventually provide a nicer option, I am happy to use it, but they are still having long discussions about the right direction to take. One thing that would make things nicer would be to expose the compilation options used in, for example, `qutip.utilities` so that compilation becomes `compile_time_env=qutip.utilities.compile_time_env()`.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1727#issuecomment-1104929052
https://github.com/qutip/qutip/pull/1727#issuecomment-1104929052:168,Usability,simpl,simple,168,"@Ericgig I think it's unavoidable to have some sort of global state that tells the C compiler which type to choose, and I think passing it as a compilation option is a simple and straight forward solution. Using macros won't change the need for a compilation flag and will make fetching the correct numpy type trickier. If cython does eventually provide a nicer option, I am happy to use it, but they are still having long discussions about the right direction to take. One thing that would make things nicer would be to expose the compilation options used in, for example, `qutip.utilities` so that compilation becomes `compile_time_env=qutip.utilities.compile_time_env()`.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1727#issuecomment-1104929052
https://github.com/qutip/qutip/pull/1728#issuecomment-981885178:146,Testability,test,test,146,"Hello @BoxiLi , @jakelishman . I implemented the issue forms for Bug Reports, Feature Requests and Other Issues.; Please check them out!. You can test them if you want over here: [test issue forms](https://github.com/Chasmiccoder/Algos-for-Amigos/issues/new/choose)",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1728#issuecomment-981885178
https://github.com/qutip/qutip/pull/1728#issuecomment-981885178:180,Testability,test,test,180,"Hello @BoxiLi , @jakelishman . I implemented the issue forms for Bug Reports, Feature Requests and Other Issues.; Please check them out!. You can test them if you want over here: [test issue forms](https://github.com/Chasmiccoder/Algos-for-Amigos/issues/new/choose)",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1728#issuecomment-981885178
https://github.com/qutip/qutip/issues/1729#issuecomment-982408393:319,Modifiability,refactor,refactoring,319,"Hi @Chasmiccoder, indeed the qutip source code is not yet fully pep8 compatible, although we are pushing towards it. In general, we try to avoid large-scale PR that only fix style issues like running `pycodestyle`, because it may introduce lots of conflicts if someone else is also working on the same code. That said, refactoring code for better maintainability is of course helpful in the long run. It would be good to check the development version. I believe we are doing a better job there. The newest version of `qutip` can be found on the `dev.major` branch of qutip https://github.com/qutip/qutip/tree/dev.major. And the master branch of `qutip-qip` https://github.com/qutip/qutip-qip. The package `qutip-qip` is a separate repository that serves as a replacement of the module `qutip.qip`, because the module will be removed in qutip-v5 (`dev.major`). The duplication you mentioned should already be fixed there. But of course there are still other imperfections if you are interested.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1729#issuecomment-982408393
https://github.com/qutip/qutip/issues/1729#issuecomment-982408393:347,Modifiability,maintainab,maintainability,347,"Hi @Chasmiccoder, indeed the qutip source code is not yet fully pep8 compatible, although we are pushing towards it. In general, we try to avoid large-scale PR that only fix style issues like running `pycodestyle`, because it may introduce lots of conflicts if someone else is also working on the same code. That said, refactoring code for better maintainability is of course helpful in the long run. It would be good to check the development version. I believe we are doing a better job there. The newest version of `qutip` can be found on the `dev.major` branch of qutip https://github.com/qutip/qutip/tree/dev.major. And the master branch of `qutip-qip` https://github.com/qutip/qutip-qip. The package `qutip-qip` is a separate repository that serves as a replacement of the module `qutip.qip`, because the module will be removed in qutip-v5 (`dev.major`). The duplication you mentioned should already be fixed there. But of course there are still other imperfections if you are interested.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1729#issuecomment-982408393
https://github.com/qutip/qutip/issues/1729#issuecomment-982408393:139,Safety,avoid,avoid,139,"Hi @Chasmiccoder, indeed the qutip source code is not yet fully pep8 compatible, although we are pushing towards it. In general, we try to avoid large-scale PR that only fix style issues like running `pycodestyle`, because it may introduce lots of conflicts if someone else is also working on the same code. That said, refactoring code for better maintainability is of course helpful in the long run. It would be good to check the development version. I believe we are doing a better job there. The newest version of `qutip` can be found on the `dev.major` branch of qutip https://github.com/qutip/qutip/tree/dev.major. And the master branch of `qutip-qip` https://github.com/qutip/qutip-qip. The package `qutip-qip` is a separate repository that serves as a replacement of the module `qutip.qip`, because the module will be removed in qutip-v5 (`dev.major`). The duplication you mentioned should already be fixed there. But of course there are still other imperfections if you are interested.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1729#issuecomment-982408393
https://github.com/qutip/qutip/issues/1729#issuecomment-982600604:112,Deployability,release,releases,112,"@Chasmiccoder I agree with @BoxiLi that we don't want to do a big refactor, especially of the older 4.6 and 4.7 releases. I would like to add some code style checkers like `pyflakes` , `black` (or `blue`) and `isort` to our CI system on the `dev.major` branch, initially excluding all the files and then slowly including more and more files in the checks as we fix them. I'm going to close this issue for now, but if you would like to tackle adding, e.g., `pyflakes` to `dev.major` that would be awesome.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1729#issuecomment-982600604
https://github.com/qutip/qutip/issues/1729#issuecomment-982600604:66,Modifiability,refactor,refactor,66,"@Chasmiccoder I agree with @BoxiLi that we don't want to do a big refactor, especially of the older 4.6 and 4.7 releases. I would like to add some code style checkers like `pyflakes` , `black` (or `blue`) and `isort` to our CI system on the `dev.major` branch, initially excluding all the files and then slowly including more and more files in the checks as we fix them. I'm going to close this issue for now, but if you would like to tackle adding, e.g., `pyflakes` to `dev.major` that would be awesome.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1729#issuecomment-982600604
https://github.com/qutip/qutip/issues/1732#issuecomment-983781212:167,Energy Efficiency,consumption,consumption,167,"It's related to #1720 - only Numpy 1.21 has cp310 wheels, but the build system currently requires Numpy <1.20 to build, because when we build QuTiP wheels for general consumption, we need to use Numpy pre-1.20 in order to have runtime support for a range of Numpys (the C ABI changed in 1.20, but they keep it forwards compatible, so things built against older Numpys will work with newer ones). As a quick fix for this issue with 3.10 only, you should be able to changes these lines in `setup.cfg` and `pyproject.toml`:; ```; setup_requires =; numpy>=1.16.6,<1.20; scipy>=1.0; cython>=0.29.20; packaging; ```; to; ```; setup_requires =; numpy>=1.16.6,<1.20 ; python_version<3.10; numpy>=1.21 ; python_version>=3.10; scipy>=1.0; cython>=0.29.20; packaging; ```; (or something like that - I forget the exact syntax). That should let you build on 3.10 (where pre-1.20 Numpy versions aren't an issue), but it doesn't solve the general problem of #1720.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1732#issuecomment-983781212
https://github.com/qutip/qutip/issues/1733#issuecomment-986660625:96,Deployability,update,updated,96,Thanks for the comment and sorry for the typo. I corrected it. The issue still persists. I also updated [the question](https://quantumcomputing.stackexchange.com/questions/22187/qutip-vs-rk45-which-one-gives-the-correct-results-for-time-dependent-systems) on stack exchange.,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1733#issuecomment-986660625
https://github.com/qutip/qutip/issues/1733#issuecomment-986660625:237,Integrability,depend,dependent-systems,237,Thanks for the comment and sorry for the typo. I corrected it. The issue still persists. I also updated [the question](https://quantumcomputing.stackexchange.com/questions/22187/qutip-vs-rk45-which-one-gives-the-correct-results-for-time-dependent-systems) on stack exchange.,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1733#issuecomment-986660625
https://github.com/qutip/qutip/issues/1733#issuecomment-986661136:193,Availability,toler,tolerance,193,"Assuming Simon's point isn't just a complete answer to your question: in the general case, this is an impossible question to answer - it touches on many parts of numerical integration, such as tolerance limits and adaptive step-size methods. When you're dealing with completely arbitrary time-dependence, there's not really any one-size-fits-all approach that'll work (despite how RK45 is often taught as a magic bullet in physics courses). Here, you will likely find that your RK45 results depend strongly on how many intermediate timesteps you use, whereas QuTiP's results will be (marginally) more stable. This is because QuTiP will internally subdivide the timesteps more to achieve internal precision goals, but then only returns the results at the time points you ask for. You can increase the maximum number of allowed subdivisions by increasing the `nsteps` parameter in a `qutip.Options` object, and with the `options` keyword argument.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1733#issuecomment-986661136
https://github.com/qutip/qutip/issues/1733#issuecomment-986661136:172,Deployability,integrat,integration,172,"Assuming Simon's point isn't just a complete answer to your question: in the general case, this is an impossible question to answer - it touches on many parts of numerical integration, such as tolerance limits and adaptive step-size methods. When you're dealing with completely arbitrary time-dependence, there's not really any one-size-fits-all approach that'll work (despite how RK45 is often taught as a magic bullet in physics courses). Here, you will likely find that your RK45 results depend strongly on how many intermediate timesteps you use, whereas QuTiP's results will be (marginally) more stable. This is because QuTiP will internally subdivide the timesteps more to achieve internal precision goals, but then only returns the results at the time points you ask for. You can increase the maximum number of allowed subdivisions by increasing the `nsteps` parameter in a `qutip.Options` object, and with the `options` keyword argument.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1733#issuecomment-986661136
https://github.com/qutip/qutip/issues/1733#issuecomment-986661136:214,Energy Efficiency,adapt,adaptive,214,"Assuming Simon's point isn't just a complete answer to your question: in the general case, this is an impossible question to answer - it touches on many parts of numerical integration, such as tolerance limits and adaptive step-size methods. When you're dealing with completely arbitrary time-dependence, there's not really any one-size-fits-all approach that'll work (despite how RK45 is often taught as a magic bullet in physics courses). Here, you will likely find that your RK45 results depend strongly on how many intermediate timesteps you use, whereas QuTiP's results will be (marginally) more stable. This is because QuTiP will internally subdivide the timesteps more to achieve internal precision goals, but then only returns the results at the time points you ask for. You can increase the maximum number of allowed subdivisions by increasing the `nsteps` parameter in a `qutip.Options` object, and with the `options` keyword argument.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1733#issuecomment-986661136
https://github.com/qutip/qutip/issues/1733#issuecomment-986661136:172,Integrability,integrat,integration,172,"Assuming Simon's point isn't just a complete answer to your question: in the general case, this is an impossible question to answer - it touches on many parts of numerical integration, such as tolerance limits and adaptive step-size methods. When you're dealing with completely arbitrary time-dependence, there's not really any one-size-fits-all approach that'll work (despite how RK45 is often taught as a magic bullet in physics courses). Here, you will likely find that your RK45 results depend strongly on how many intermediate timesteps you use, whereas QuTiP's results will be (marginally) more stable. This is because QuTiP will internally subdivide the timesteps more to achieve internal precision goals, but then only returns the results at the time points you ask for. You can increase the maximum number of allowed subdivisions by increasing the `nsteps` parameter in a `qutip.Options` object, and with the `options` keyword argument.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1733#issuecomment-986661136
https://github.com/qutip/qutip/issues/1733#issuecomment-986661136:293,Integrability,depend,dependence,293,"Assuming Simon's point isn't just a complete answer to your question: in the general case, this is an impossible question to answer - it touches on many parts of numerical integration, such as tolerance limits and adaptive step-size methods. When you're dealing with completely arbitrary time-dependence, there's not really any one-size-fits-all approach that'll work (despite how RK45 is often taught as a magic bullet in physics courses). Here, you will likely find that your RK45 results depend strongly on how many intermediate timesteps you use, whereas QuTiP's results will be (marginally) more stable. This is because QuTiP will internally subdivide the timesteps more to achieve internal precision goals, but then only returns the results at the time points you ask for. You can increase the maximum number of allowed subdivisions by increasing the `nsteps` parameter in a `qutip.Options` object, and with the `options` keyword argument.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1733#issuecomment-986661136
https://github.com/qutip/qutip/issues/1733#issuecomment-986661136:491,Integrability,depend,depend,491,"Assuming Simon's point isn't just a complete answer to your question: in the general case, this is an impossible question to answer - it touches on many parts of numerical integration, such as tolerance limits and adaptive step-size methods. When you're dealing with completely arbitrary time-dependence, there's not really any one-size-fits-all approach that'll work (despite how RK45 is often taught as a magic bullet in physics courses). Here, you will likely find that your RK45 results depend strongly on how many intermediate timesteps you use, whereas QuTiP's results will be (marginally) more stable. This is because QuTiP will internally subdivide the timesteps more to achieve internal precision goals, but then only returns the results at the time points you ask for. You can increase the maximum number of allowed subdivisions by increasing the `nsteps` parameter in a `qutip.Options` object, and with the `options` keyword argument.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1733#issuecomment-986661136
https://github.com/qutip/qutip/issues/1733#issuecomment-986661136:214,Modifiability,adapt,adaptive,214,"Assuming Simon's point isn't just a complete answer to your question: in the general case, this is an impossible question to answer - it touches on many parts of numerical integration, such as tolerance limits and adaptive step-size methods. When you're dealing with completely arbitrary time-dependence, there's not really any one-size-fits-all approach that'll work (despite how RK45 is often taught as a magic bullet in physics courses). Here, you will likely find that your RK45 results depend strongly on how many intermediate timesteps you use, whereas QuTiP's results will be (marginally) more stable. This is because QuTiP will internally subdivide the timesteps more to achieve internal precision goals, but then only returns the results at the time points you ask for. You can increase the maximum number of allowed subdivisions by increasing the `nsteps` parameter in a `qutip.Options` object, and with the `options` keyword argument.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1733#issuecomment-986661136
https://github.com/qutip/qutip/issues/1733#issuecomment-986665248:195,Availability,toler,tolerance,195,"> Assuming Simon's point isn't just a complete answer to your question: in the general case, this is an impossible question to answer - it touches on many parts of numerical integration, such as tolerance limits and adaptive step-size methods. When you're dealing with completely arbitrary time-dependence, there's not really any one-size-fits-all approach that'll work (despite how RK45 is often taught as a magic bullet in physics courses).; > ; > Here, you will likely find that your RK45 results depend strongly on how many intermediate timesteps you use, whereas QuTiP's results will be (marginally) more stable. This is because QuTiP will internally subdivide the timesteps more to achieve internal precision goals, but then only returns the results at the time points you ask for. You can increase the maximum number of allowed subdivisions by increasing the `nsteps` parameter in a `qutip.Options` object, and with the `options` keyword argument. I addressed Simon's question. Also, I tried different solver options in mesolve including solver type, nsteps, relative and absolute tolerence, etc ... Also for RK45 I tried to change the parameters in order to see if the solutions coincide. They didn't. I don't know if there exists an analytically solvable problem in which both Hamiltonian and dissipation operators are time dependent, but if there is such a problem, then I can use it as a benchmark in order to compare QuTiP and RK45.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1733#issuecomment-986665248
https://github.com/qutip/qutip/issues/1733#issuecomment-986665248:1088,Availability,toler,tolerence,1088,"> Assuming Simon's point isn't just a complete answer to your question: in the general case, this is an impossible question to answer - it touches on many parts of numerical integration, such as tolerance limits and adaptive step-size methods. When you're dealing with completely arbitrary time-dependence, there's not really any one-size-fits-all approach that'll work (despite how RK45 is often taught as a magic bullet in physics courses).; > ; > Here, you will likely find that your RK45 results depend strongly on how many intermediate timesteps you use, whereas QuTiP's results will be (marginally) more stable. This is because QuTiP will internally subdivide the timesteps more to achieve internal precision goals, but then only returns the results at the time points you ask for. You can increase the maximum number of allowed subdivisions by increasing the `nsteps` parameter in a `qutip.Options` object, and with the `options` keyword argument. I addressed Simon's question. Also, I tried different solver options in mesolve including solver type, nsteps, relative and absolute tolerence, etc ... Also for RK45 I tried to change the parameters in order to see if the solutions coincide. They didn't. I don't know if there exists an analytically solvable problem in which both Hamiltonian and dissipation operators are time dependent, but if there is such a problem, then I can use it as a benchmark in order to compare QuTiP and RK45.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1733#issuecomment-986665248
https://github.com/qutip/qutip/issues/1733#issuecomment-986665248:174,Deployability,integrat,integration,174,"> Assuming Simon's point isn't just a complete answer to your question: in the general case, this is an impossible question to answer - it touches on many parts of numerical integration, such as tolerance limits and adaptive step-size methods. When you're dealing with completely arbitrary time-dependence, there's not really any one-size-fits-all approach that'll work (despite how RK45 is often taught as a magic bullet in physics courses).; > ; > Here, you will likely find that your RK45 results depend strongly on how many intermediate timesteps you use, whereas QuTiP's results will be (marginally) more stable. This is because QuTiP will internally subdivide the timesteps more to achieve internal precision goals, but then only returns the results at the time points you ask for. You can increase the maximum number of allowed subdivisions by increasing the `nsteps` parameter in a `qutip.Options` object, and with the `options` keyword argument. I addressed Simon's question. Also, I tried different solver options in mesolve including solver type, nsteps, relative and absolute tolerence, etc ... Also for RK45 I tried to change the parameters in order to see if the solutions coincide. They didn't. I don't know if there exists an analytically solvable problem in which both Hamiltonian and dissipation operators are time dependent, but if there is such a problem, then I can use it as a benchmark in order to compare QuTiP and RK45.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1733#issuecomment-986665248
https://github.com/qutip/qutip/issues/1733#issuecomment-986665248:216,Energy Efficiency,adapt,adaptive,216,"> Assuming Simon's point isn't just a complete answer to your question: in the general case, this is an impossible question to answer - it touches on many parts of numerical integration, such as tolerance limits and adaptive step-size methods. When you're dealing with completely arbitrary time-dependence, there's not really any one-size-fits-all approach that'll work (despite how RK45 is often taught as a magic bullet in physics courses).; > ; > Here, you will likely find that your RK45 results depend strongly on how many intermediate timesteps you use, whereas QuTiP's results will be (marginally) more stable. This is because QuTiP will internally subdivide the timesteps more to achieve internal precision goals, but then only returns the results at the time points you ask for. You can increase the maximum number of allowed subdivisions by increasing the `nsteps` parameter in a `qutip.Options` object, and with the `options` keyword argument. I addressed Simon's question. Also, I tried different solver options in mesolve including solver type, nsteps, relative and absolute tolerence, etc ... Also for RK45 I tried to change the parameters in order to see if the solutions coincide. They didn't. I don't know if there exists an analytically solvable problem in which both Hamiltonian and dissipation operators are time dependent, but if there is such a problem, then I can use it as a benchmark in order to compare QuTiP and RK45.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1733#issuecomment-986665248
https://github.com/qutip/qutip/issues/1733#issuecomment-986665248:174,Integrability,integrat,integration,174,"> Assuming Simon's point isn't just a complete answer to your question: in the general case, this is an impossible question to answer - it touches on many parts of numerical integration, such as tolerance limits and adaptive step-size methods. When you're dealing with completely arbitrary time-dependence, there's not really any one-size-fits-all approach that'll work (despite how RK45 is often taught as a magic bullet in physics courses).; > ; > Here, you will likely find that your RK45 results depend strongly on how many intermediate timesteps you use, whereas QuTiP's results will be (marginally) more stable. This is because QuTiP will internally subdivide the timesteps more to achieve internal precision goals, but then only returns the results at the time points you ask for. You can increase the maximum number of allowed subdivisions by increasing the `nsteps` parameter in a `qutip.Options` object, and with the `options` keyword argument. I addressed Simon's question. Also, I tried different solver options in mesolve including solver type, nsteps, relative and absolute tolerence, etc ... Also for RK45 I tried to change the parameters in order to see if the solutions coincide. They didn't. I don't know if there exists an analytically solvable problem in which both Hamiltonian and dissipation operators are time dependent, but if there is such a problem, then I can use it as a benchmark in order to compare QuTiP and RK45.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1733#issuecomment-986665248
https://github.com/qutip/qutip/issues/1733#issuecomment-986665248:295,Integrability,depend,dependence,295,"> Assuming Simon's point isn't just a complete answer to your question: in the general case, this is an impossible question to answer - it touches on many parts of numerical integration, such as tolerance limits and adaptive step-size methods. When you're dealing with completely arbitrary time-dependence, there's not really any one-size-fits-all approach that'll work (despite how RK45 is often taught as a magic bullet in physics courses).; > ; > Here, you will likely find that your RK45 results depend strongly on how many intermediate timesteps you use, whereas QuTiP's results will be (marginally) more stable. This is because QuTiP will internally subdivide the timesteps more to achieve internal precision goals, but then only returns the results at the time points you ask for. You can increase the maximum number of allowed subdivisions by increasing the `nsteps` parameter in a `qutip.Options` object, and with the `options` keyword argument. I addressed Simon's question. Also, I tried different solver options in mesolve including solver type, nsteps, relative and absolute tolerence, etc ... Also for RK45 I tried to change the parameters in order to see if the solutions coincide. They didn't. I don't know if there exists an analytically solvable problem in which both Hamiltonian and dissipation operators are time dependent, but if there is such a problem, then I can use it as a benchmark in order to compare QuTiP and RK45.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1733#issuecomment-986665248
https://github.com/qutip/qutip/issues/1733#issuecomment-986665248:500,Integrability,depend,depend,500,"> Assuming Simon's point isn't just a complete answer to your question: in the general case, this is an impossible question to answer - it touches on many parts of numerical integration, such as tolerance limits and adaptive step-size methods. When you're dealing with completely arbitrary time-dependence, there's not really any one-size-fits-all approach that'll work (despite how RK45 is often taught as a magic bullet in physics courses).; > ; > Here, you will likely find that your RK45 results depend strongly on how many intermediate timesteps you use, whereas QuTiP's results will be (marginally) more stable. This is because QuTiP will internally subdivide the timesteps more to achieve internal precision goals, but then only returns the results at the time points you ask for. You can increase the maximum number of allowed subdivisions by increasing the `nsteps` parameter in a `qutip.Options` object, and with the `options` keyword argument. I addressed Simon's question. Also, I tried different solver options in mesolve including solver type, nsteps, relative and absolute tolerence, etc ... Also for RK45 I tried to change the parameters in order to see if the solutions coincide. They didn't. I don't know if there exists an analytically solvable problem in which both Hamiltonian and dissipation operators are time dependent, but if there is such a problem, then I can use it as a benchmark in order to compare QuTiP and RK45.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1733#issuecomment-986665248
https://github.com/qutip/qutip/issues/1733#issuecomment-986665248:1333,Integrability,depend,dependent,1333,"> Assuming Simon's point isn't just a complete answer to your question: in the general case, this is an impossible question to answer - it touches on many parts of numerical integration, such as tolerance limits and adaptive step-size methods. When you're dealing with completely arbitrary time-dependence, there's not really any one-size-fits-all approach that'll work (despite how RK45 is often taught as a magic bullet in physics courses).; > ; > Here, you will likely find that your RK45 results depend strongly on how many intermediate timesteps you use, whereas QuTiP's results will be (marginally) more stable. This is because QuTiP will internally subdivide the timesteps more to achieve internal precision goals, but then only returns the results at the time points you ask for. You can increase the maximum number of allowed subdivisions by increasing the `nsteps` parameter in a `qutip.Options` object, and with the `options` keyword argument. I addressed Simon's question. Also, I tried different solver options in mesolve including solver type, nsteps, relative and absolute tolerence, etc ... Also for RK45 I tried to change the parameters in order to see if the solutions coincide. They didn't. I don't know if there exists an analytically solvable problem in which both Hamiltonian and dissipation operators are time dependent, but if there is such a problem, then I can use it as a benchmark in order to compare QuTiP and RK45.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1733#issuecomment-986665248
https://github.com/qutip/qutip/issues/1733#issuecomment-986665248:216,Modifiability,adapt,adaptive,216,"> Assuming Simon's point isn't just a complete answer to your question: in the general case, this is an impossible question to answer - it touches on many parts of numerical integration, such as tolerance limits and adaptive step-size methods. When you're dealing with completely arbitrary time-dependence, there's not really any one-size-fits-all approach that'll work (despite how RK45 is often taught as a magic bullet in physics courses).; > ; > Here, you will likely find that your RK45 results depend strongly on how many intermediate timesteps you use, whereas QuTiP's results will be (marginally) more stable. This is because QuTiP will internally subdivide the timesteps more to achieve internal precision goals, but then only returns the results at the time points you ask for. You can increase the maximum number of allowed subdivisions by increasing the `nsteps` parameter in a `qutip.Options` object, and with the `options` keyword argument. I addressed Simon's question. Also, I tried different solver options in mesolve including solver type, nsteps, relative and absolute tolerence, etc ... Also for RK45 I tried to change the parameters in order to see if the solutions coincide. They didn't. I don't know if there exists an analytically solvable problem in which both Hamiltonian and dissipation operators are time dependent, but if there is such a problem, then I can use it as a benchmark in order to compare QuTiP and RK45.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1733#issuecomment-986665248
https://github.com/qutip/qutip/issues/1733#issuecomment-986665248:1399,Testability,benchmark,benchmark,1399,"> Assuming Simon's point isn't just a complete answer to your question: in the general case, this is an impossible question to answer - it touches on many parts of numerical integration, such as tolerance limits and adaptive step-size methods. When you're dealing with completely arbitrary time-dependence, there's not really any one-size-fits-all approach that'll work (despite how RK45 is often taught as a magic bullet in physics courses).; > ; > Here, you will likely find that your RK45 results depend strongly on how many intermediate timesteps you use, whereas QuTiP's results will be (marginally) more stable. This is because QuTiP will internally subdivide the timesteps more to achieve internal precision goals, but then only returns the results at the time points you ask for. You can increase the maximum number of allowed subdivisions by increasing the `nsteps` parameter in a `qutip.Options` object, and with the `options` keyword argument. I addressed Simon's question. Also, I tried different solver options in mesolve including solver type, nsteps, relative and absolute tolerence, etc ... Also for RK45 I tried to change the parameters in order to see if the solutions coincide. They didn't. I don't know if there exists an analytically solvable problem in which both Hamiltonian and dissipation operators are time dependent, but if there is such a problem, then I can use it as a benchmark in order to compare QuTiP and RK45.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1733#issuecomment-986665248
https://github.com/qutip/qutip/issues/1733#issuecomment-986683310:709,Integrability,depend,dependent-systems,709,"> I don't want to straight up say ""QuTiP is correct"", because as I mentioned, the field of numerical computing is incredibly tricky, but it _probably_ is more accurate in this situation. I just tried doing what I suggested in my previous post (increase the number of time-steps), and found QuTiP was stable, but your RK45 implementation started differing. This is strongly suggestive that your RK45 isn't fully converging for this problem. I don't think you are right. As I mentioned I also did the same but the results are stable. I edited [my question on quantum computing stack exchange](https://quantumcomputing.stackexchange.com/questions/22187/qutip-vs-rk45-which-one-gives-the-correct-results-for-time-dependent-systems) if you are interested. There is no convergence issue. And I don't think it is ""impossible"" to figure out what is causing this difference or to understand which one is closer to the actual answer. If there exists a system with time-dependent Hamiltonian under a time-dependent dissipation which is analytically solvable, we can compare these two methods. I am not aware of such a problem.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1733#issuecomment-986683310
https://github.com/qutip/qutip/issues/1733#issuecomment-986683310:959,Integrability,depend,dependent,959,"> I don't want to straight up say ""QuTiP is correct"", because as I mentioned, the field of numerical computing is incredibly tricky, but it _probably_ is more accurate in this situation. I just tried doing what I suggested in my previous post (increase the number of time-steps), and found QuTiP was stable, but your RK45 implementation started differing. This is strongly suggestive that your RK45 isn't fully converging for this problem. I don't think you are right. As I mentioned I also did the same but the results are stable. I edited [my question on quantum computing stack exchange](https://quantumcomputing.stackexchange.com/questions/22187/qutip-vs-rk45-which-one-gives-the-correct-results-for-time-dependent-systems) if you are interested. There is no convergence issue. And I don't think it is ""impossible"" to figure out what is causing this difference or to understand which one is closer to the actual answer. If there exists a system with time-dependent Hamiltonian under a time-dependent dissipation which is analytically solvable, we can compare these two methods. I am not aware of such a problem.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1733#issuecomment-986683310
https://github.com/qutip/qutip/issues/1733#issuecomment-986683310:994,Integrability,depend,dependent,994,"> I don't want to straight up say ""QuTiP is correct"", because as I mentioned, the field of numerical computing is incredibly tricky, but it _probably_ is more accurate in this situation. I just tried doing what I suggested in my previous post (increase the number of time-steps), and found QuTiP was stable, but your RK45 implementation started differing. This is strongly suggestive that your RK45 isn't fully converging for this problem. I don't think you are right. As I mentioned I also did the same but the results are stable. I edited [my question on quantum computing stack exchange](https://quantumcomputing.stackexchange.com/questions/22187/qutip-vs-rk45-which-one-gives-the-correct-results-for-time-dependent-systems) if you are interested. There is no convergence issue. And I don't think it is ""impossible"" to figure out what is causing this difference or to understand which one is closer to the actual answer. If there exists a system with time-dependent Hamiltonian under a time-dependent dissipation which is analytically solvable, we can compare these two methods. I am not aware of such a problem.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1733#issuecomment-986683310
https://github.com/qutip/qutip/issues/1733#issuecomment-986722508:36,Availability,error,error,36,"The RK45 code here has no notion of error associated with it; you have no way of saying whether a particular step size `dt` is actually good. It ideally should converge to something as the step size goes to zero. QuTiP has an adaptive solver that modifies the step size to keep the error below the supplied tolerances. For time-dependent problems one could run into issues with very narrow pulses, but that is not the case here. Writing ones own ODE solver is not really the best thing to do outside of a learning exercise for reasons along these lines.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1733#issuecomment-986722508
https://github.com/qutip/qutip/issues/1733#issuecomment-986722508:282,Availability,error,error,282,"The RK45 code here has no notion of error associated with it; you have no way of saying whether a particular step size `dt` is actually good. It ideally should converge to something as the step size goes to zero. QuTiP has an adaptive solver that modifies the step size to keep the error below the supplied tolerances. For time-dependent problems one could run into issues with very narrow pulses, but that is not the case here. Writing ones own ODE solver is not really the best thing to do outside of a learning exercise for reasons along these lines.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1733#issuecomment-986722508
https://github.com/qutip/qutip/issues/1733#issuecomment-986722508:307,Availability,toler,tolerances,307,"The RK45 code here has no notion of error associated with it; you have no way of saying whether a particular step size `dt` is actually good. It ideally should converge to something as the step size goes to zero. QuTiP has an adaptive solver that modifies the step size to keep the error below the supplied tolerances. For time-dependent problems one could run into issues with very narrow pulses, but that is not the case here. Writing ones own ODE solver is not really the best thing to do outside of a learning exercise for reasons along these lines.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1733#issuecomment-986722508
https://github.com/qutip/qutip/issues/1733#issuecomment-986722508:226,Energy Efficiency,adapt,adaptive,226,"The RK45 code here has no notion of error associated with it; you have no way of saying whether a particular step size `dt` is actually good. It ideally should converge to something as the step size goes to zero. QuTiP has an adaptive solver that modifies the step size to keep the error below the supplied tolerances. For time-dependent problems one could run into issues with very narrow pulses, but that is not the case here. Writing ones own ODE solver is not really the best thing to do outside of a learning exercise for reasons along these lines.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1733#issuecomment-986722508
https://github.com/qutip/qutip/issues/1733#issuecomment-986722508:328,Integrability,depend,dependent,328,"The RK45 code here has no notion of error associated with it; you have no way of saying whether a particular step size `dt` is actually good. It ideally should converge to something as the step size goes to zero. QuTiP has an adaptive solver that modifies the step size to keep the error below the supplied tolerances. For time-dependent problems one could run into issues with very narrow pulses, but that is not the case here. Writing ones own ODE solver is not really the best thing to do outside of a learning exercise for reasons along these lines.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1733#issuecomment-986722508
https://github.com/qutip/qutip/issues/1733#issuecomment-986722508:226,Modifiability,adapt,adaptive,226,"The RK45 code here has no notion of error associated with it; you have no way of saying whether a particular step size `dt` is actually good. It ideally should converge to something as the step size goes to zero. QuTiP has an adaptive solver that modifies the step size to keep the error below the supplied tolerances. For time-dependent problems one could run into issues with very narrow pulses, but that is not the case here. Writing ones own ODE solver is not really the best thing to do outside of a learning exercise for reasons along these lines.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1733#issuecomment-986722508
https://github.com/qutip/qutip/issues/1733#issuecomment-986722508:505,Usability,learn,learning,505,"The RK45 code here has no notion of error associated with it; you have no way of saying whether a particular step size `dt` is actually good. It ideally should converge to something as the step size goes to zero. QuTiP has an adaptive solver that modifies the step size to keep the error below the supplied tolerances. For time-dependent problems one could run into issues with very narrow pulses, but that is not the case here. Writing ones own ODE solver is not really the best thing to do outside of a learning exercise for reasons along these lines.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1733#issuecomment-986722508
https://github.com/qutip/qutip/issues/1733#issuecomment-986723762:268,Availability,toler,tolerance,268,"For clarity: I ran your code with 1,000 timesteps and 10,000 timesteps and found a linalg norm difference in the outputs of 4.4e-4 (compared to QuTiP's 6.5e-8), which is what I meant. I considered that difference ""not fully convergent"" in part because QuTiP's default tolerance goals have an absolute tolerance of ~1e-8 (that's per-element, not the full norm). Here's a couple more things to look at:; - if you're using QuTiP objects without our solvers like this, we tidy up sparse matrices at every operation. You probably don't want that - you might get different results if you convert your RK method to work on raw Numpy arrays.; - your RHS isn't accurate - it takes `sqrt(gamma)`, but your time-dependent function already does that. This is perhaps a mistake, and very likely the source of the discrepancy? Also, while it's irrelevant here, your Lindbladian has `c_op * c_op.dag() * rho` as the last term, but it should be `c_op.dag() * c_op * rho`.; - your RK method isn't using updated versions of the Hamiltonian or the collapse operator at the intermediate timesteps.; - you say you're using RK45, but you've only got 4 different evaluations? That looks like an RK4 method to me (not that it should matter).",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1733#issuecomment-986723762
https://github.com/qutip/qutip/issues/1733#issuecomment-986723762:301,Availability,toler,tolerance,301,"For clarity: I ran your code with 1,000 timesteps and 10,000 timesteps and found a linalg norm difference in the outputs of 4.4e-4 (compared to QuTiP's 6.5e-8), which is what I meant. I considered that difference ""not fully convergent"" in part because QuTiP's default tolerance goals have an absolute tolerance of ~1e-8 (that's per-element, not the full norm). Here's a couple more things to look at:; - if you're using QuTiP objects without our solvers like this, we tidy up sparse matrices at every operation. You probably don't want that - you might get different results if you convert your RK method to work on raw Numpy arrays.; - your RHS isn't accurate - it takes `sqrt(gamma)`, but your time-dependent function already does that. This is perhaps a mistake, and very likely the source of the discrepancy? Also, while it's irrelevant here, your Lindbladian has `c_op * c_op.dag() * rho` as the last term, but it should be `c_op.dag() * c_op * rho`.; - your RK method isn't using updated versions of the Hamiltonian or the collapse operator at the intermediate timesteps.; - you say you're using RK45, but you've only got 4 different evaluations? That looks like an RK4 method to me (not that it should matter).",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1733#issuecomment-986723762
https://github.com/qutip/qutip/issues/1733#issuecomment-986723762:986,Deployability,update,updated,986,"For clarity: I ran your code with 1,000 timesteps and 10,000 timesteps and found a linalg norm difference in the outputs of 4.4e-4 (compared to QuTiP's 6.5e-8), which is what I meant. I considered that difference ""not fully convergent"" in part because QuTiP's default tolerance goals have an absolute tolerance of ~1e-8 (that's per-element, not the full norm). Here's a couple more things to look at:; - if you're using QuTiP objects without our solvers like this, we tidy up sparse matrices at every operation. You probably don't want that - you might get different results if you convert your RK method to work on raw Numpy arrays.; - your RHS isn't accurate - it takes `sqrt(gamma)`, but your time-dependent function already does that. This is perhaps a mistake, and very likely the source of the discrepancy? Also, while it's irrelevant here, your Lindbladian has `c_op * c_op.dag() * rho` as the last term, but it should be `c_op.dag() * c_op * rho`.; - your RK method isn't using updated versions of the Hamiltonian or the collapse operator at the intermediate timesteps.; - you say you're using RK45, but you've only got 4 different evaluations? That looks like an RK4 method to me (not that it should matter).",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1733#issuecomment-986723762
https://github.com/qutip/qutip/issues/1733#issuecomment-986723762:701,Integrability,depend,dependent,701,"For clarity: I ran your code with 1,000 timesteps and 10,000 timesteps and found a linalg norm difference in the outputs of 4.4e-4 (compared to QuTiP's 6.5e-8), which is what I meant. I considered that difference ""not fully convergent"" in part because QuTiP's default tolerance goals have an absolute tolerance of ~1e-8 (that's per-element, not the full norm). Here's a couple more things to look at:; - if you're using QuTiP objects without our solvers like this, we tidy up sparse matrices at every operation. You probably don't want that - you might get different results if you convert your RK method to work on raw Numpy arrays.; - your RHS isn't accurate - it takes `sqrt(gamma)`, but your time-dependent function already does that. This is perhaps a mistake, and very likely the source of the discrepancy? Also, while it's irrelevant here, your Lindbladian has `c_op * c_op.dag() * rho` as the last term, but it should be `c_op.dag() * c_op * rho`.; - your RK method isn't using updated versions of the Hamiltonian or the collapse operator at the intermediate timesteps.; - you say you're using RK45, but you've only got 4 different evaluations? That looks like an RK4 method to me (not that it should matter).",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1733#issuecomment-986723762
https://github.com/qutip/qutip/issues/1733#issuecomment-1005605164:301,Energy Efficiency,adapt,adaptive,301,"@alipedram01 It looks like we've understood the cause of the issue -- i.e. your RK45 solver just doesn't converge for this problem. That's probably not unexpected -- I see to remember reading on Wikipedia that the implicit Runga-Kutta methods have small regions of convergence relative to explicit or adaptive methods. Closing this for now, but thank you for taking a look and please feel free to continue the discussion if needed.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1733#issuecomment-1005605164
https://github.com/qutip/qutip/issues/1733#issuecomment-1005605164:301,Modifiability,adapt,adaptive,301,"@alipedram01 It looks like we've understood the cause of the issue -- i.e. your RK45 solver just doesn't converge for this problem. That's probably not unexpected -- I see to remember reading on Wikipedia that the implicit Runga-Kutta methods have small regions of convergence relative to explicit or adaptive methods. Closing this for now, but thank you for taking a look and please feel free to continue the discussion if needed.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1733#issuecomment-1005605164
https://github.com/qutip/qutip/pull/1734#issuecomment-989070040:214,Deployability,integrat,integrator,214,[![Coverage Status](https://coveralls.io/builds/44887329/badge)](https://coveralls.io/builds/44887329). Coverage remained the same at 65.525% when pulling **d3a5c6e3ebb43afa0c2eb7b2456c886cb9651bd1 on Ericgig:safe.integrator** into **298316b4f034f467788943015b3277bf88f3fc9b on qutip:dev.major**.,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1734#issuecomment-989070040
https://github.com/qutip/qutip/pull/1734#issuecomment-989070040:214,Integrability,integrat,integrator,214,[![Coverage Status](https://coveralls.io/builds/44887329/badge)](https://coveralls.io/builds/44887329). Coverage remained the same at 65.525% when pulling **d3a5c6e3ebb43afa0c2eb7b2456c886cb9651bd1 on Ericgig:safe.integrator** into **298316b4f034f467788943015b3277bf88f3fc9b on qutip:dev.major**.,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1734#issuecomment-989070040
https://github.com/qutip/qutip/pull/1734#issuecomment-989070040:209,Safety,safe,safe,209,[![Coverage Status](https://coveralls.io/builds/44887329/badge)](https://coveralls.io/builds/44887329). Coverage remained the same at 65.525% when pulling **d3a5c6e3ebb43afa0c2eb7b2456c886cb9651bd1 on Ericgig:safe.integrator** into **298316b4f034f467788943015b3277bf88f3fc9b on qutip:dev.major**.,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1734#issuecomment-989070040
https://github.com/qutip/qutip/pull/1735#issuecomment-989766192:248,Deployability,install,installed,248,"I suspect that because of pip's isolated builds, we have to specify `oldest-supported-numpy` in our `[build-system]` requirements (otherwise the isolated pip will do the wrong thing and build against the latest numpy, which might be newer than the installed numpy) but this prevents building with a different version of numpy installed. :/. **Update**: I'm not sure if the above is correct, but documentation builds are failing with `ValueError: numpy.ndarray size changed`.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1735#issuecomment-989766192
https://github.com/qutip/qutip/pull/1735#issuecomment-989766192:326,Deployability,install,installed,326,"I suspect that because of pip's isolated builds, we have to specify `oldest-supported-numpy` in our `[build-system]` requirements (otherwise the isolated pip will do the wrong thing and build against the latest numpy, which might be newer than the installed numpy) but this prevents building with a different version of numpy installed. :/. **Update**: I'm not sure if the above is correct, but documentation builds are failing with `ValueError: numpy.ndarray size changed`.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1735#issuecomment-989766192
https://github.com/qutip/qutip/pull/1735#issuecomment-989766192:343,Deployability,Update,Update,343,"I suspect that because of pip's isolated builds, we have to specify `oldest-supported-numpy` in our `[build-system]` requirements (otherwise the isolated pip will do the wrong thing and build against the latest numpy, which might be newer than the installed numpy) but this prevents building with a different version of numpy installed. :/. **Update**: I'm not sure if the above is correct, but documentation builds are failing with `ValueError: numpy.ndarray size changed`.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1735#issuecomment-989766192
https://github.com/qutip/qutip/pull/1735#issuecomment-989840346:320,Deployability,update,update,320,"Looking at the docs `requirements.txt`, it looks like the docs build failing is an indication that your build process isn't correct. The docs requirements is a pinning file that's now quite old, so it still has Numpy 1.19. That fails, which indicates your build is using a too-new version of Numpy. You probably want to update the docs requirements pins, but equally you probably want to add a CI test case that deliberately uses Numpy <1.20 on Python 3.7 or 3.8 to ensure that your build is correct.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1735#issuecomment-989840346
https://github.com/qutip/qutip/pull/1735#issuecomment-989840346:397,Testability,test,test,397,"Looking at the docs `requirements.txt`, it looks like the docs build failing is an indication that your build process isn't correct. The docs requirements is a pinning file that's now quite old, so it still has Numpy 1.19. That fails, which indicates your build is using a too-new version of Numpy. You probably want to update the docs requirements pins, but equally you probably want to add a CI test case that deliberately uses Numpy <1.20 on Python 3.7 or 3.8 to ensure that your build is correct.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1735#issuecomment-989840346
https://github.com/qutip/qutip/pull/1735#issuecomment-989884557:29,Usability,learn,learned,29,"@jakelishman Given what I've learned in this issue, I suspect our PyPI wheels were all build with `numpy == 1.19.5`. Does that sound right to you? If it is, I guess I should build all the new wheels with 1.19.5 too? Or should I ""fix"" things and go back to 1.16.6 or oldest-supported-numpy if that is more recent?",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1735#issuecomment-989884557
https://github.com/qutip/qutip/pull/1735#issuecomment-989950888:611,Availability,failure,failures,611,"> Please just use a single pyproject.toml with oldest-supported-numpy. You don't need to copy them around, the build you get is fine for docs & users. You can disable build isolation if you need to have a special newer NumPy for the compile (which is very rare). Thank you for taking a look here. As I explained before, we can't just use oldest-supported-numpy directly because we also require numpy >= 1.16.6 for our own code. The pypi-pyproject.toml file contains a copy of oldest-supported-numpy but with everything less that 1.16.6 replaced with 1.16.6. Overly specific build-system.requires can also cause failures with conda-forges build system -- e.g. this one for building this project with Python 3.10 on Windows 64 -- https://dev.azure.com/conda-forge/feedstock-builds/_build/results?buildId=407213&view=logs&jobId=00f5923e-fdef-5026-5091-0d5a0b3d5a2c&j=00f5923e-fdef-5026-5091-0d5a0b3d5a2c&t=3cc4a9ed-60e1-5810-6eb3-5f9cd4a26dba (maybe there is some separate way around that).",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1735#issuecomment-989950888
https://github.com/qutip/qutip/pull/1735#issuecomment-989950888:814,Testability,log,logs,814,"> Please just use a single pyproject.toml with oldest-supported-numpy. You don't need to copy them around, the build you get is fine for docs & users. You can disable build isolation if you need to have a special newer NumPy for the compile (which is very rare). Thank you for taking a look here. As I explained before, we can't just use oldest-supported-numpy directly because we also require numpy >= 1.16.6 for our own code. The pypi-pyproject.toml file contains a copy of oldest-supported-numpy but with everything less that 1.16.6 replaced with 1.16.6. Overly specific build-system.requires can also cause failures with conda-forges build system -- e.g. this one for building this project with Python 3.10 on Windows 64 -- https://dev.azure.com/conda-forge/feedstock-builds/_build/results?buildId=407213&view=logs&jobId=00f5923e-fdef-5026-5091-0d5a0b3d5a2c&j=00f5923e-fdef-5026-5091-0d5a0b3d5a2c&t=3cc4a9ed-60e1-5810-6eb3-5f9cd4a26dba (maybe there is some separate way around that).",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1735#issuecomment-989950888
https://github.com/qutip/qutip/pull/1735#issuecomment-989955502:55,Availability,failure,failures,55,"> Overly specific build-system.requires can also cause failures with conda-forges build system. Conda-forge does not and cannot use `build-system.requires`; those are PyPI packages and they might not even have the same name in Conda. Conda always sets PIP_NO_BUILD_ISOLATION to avoid this. This (the linked log) is tripping up on setup_requires, which is deprecated and I don't think you have it set up correctly anyway; if you ask for `Cython` but don't `install_requires` Cython, Cython will not be installed before running the setup.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1735#issuecomment-989955502
https://github.com/qutip/qutip/pull/1735#issuecomment-989955502:501,Deployability,install,installed,501,"> Overly specific build-system.requires can also cause failures with conda-forges build system. Conda-forge does not and cannot use `build-system.requires`; those are PyPI packages and they might not even have the same name in Conda. Conda always sets PIP_NO_BUILD_ISOLATION to avoid this. This (the linked log) is tripping up on setup_requires, which is deprecated and I don't think you have it set up correctly anyway; if you ask for `Cython` but don't `install_requires` Cython, Cython will not be installed before running the setup.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1735#issuecomment-989955502
https://github.com/qutip/qutip/pull/1735#issuecomment-989955502:278,Safety,avoid,avoid,278,"> Overly specific build-system.requires can also cause failures with conda-forges build system. Conda-forge does not and cannot use `build-system.requires`; those are PyPI packages and they might not even have the same name in Conda. Conda always sets PIP_NO_BUILD_ISOLATION to avoid this. This (the linked log) is tripping up on setup_requires, which is deprecated and I don't think you have it set up correctly anyway; if you ask for `Cython` but don't `install_requires` Cython, Cython will not be installed before running the setup.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1735#issuecomment-989955502
https://github.com/qutip/qutip/pull/1735#issuecomment-989955502:307,Testability,log,log,307,"> Overly specific build-system.requires can also cause failures with conda-forges build system. Conda-forge does not and cannot use `build-system.requires`; those are PyPI packages and they might not even have the same name in Conda. Conda always sets PIP_NO_BUILD_ISOLATION to avoid this. This (the linked log) is tripping up on setup_requires, which is deprecated and I don't think you have it set up correctly anyway; if you ask for `Cython` but don't `install_requires` Cython, Cython will not be installed before running the setup.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1735#issuecomment-989955502
https://github.com/qutip/qutip/pull/1735#issuecomment-989966457:577,Usability,simpl,simple,577,"```; ""minimum_supported_numpy; python_version>='3.8' or platform_machine=='aarch64' or platform_system=='AIX' or platform_python_implementation=='PyPy'""; ""numpy==1.16.6; python_version=='3.6' and platform_machine!='aarch64' and platform_system!='AIX' and platform_python_implementation != 'PyPy'"",; ""numpy==1.16.6; python_version=='3.7' and platform_machine!='aarch64' and platform_system!='AIX' and platform_python_implementation != 'PyPy'"",; ```. Also, you have the wrong setting for 3.8 above, there are no binaries for the one you incorrectly selected. But please, try the simple thing first. Quoting the documentation:. > ### Can I use this if my package requires a recent version of Numpy?; > In many cases, even though your package may require a version of Numpy that is more recent than the pinned versions here, this is often a runtime requirement, i.e. for running (rather than building) your package. In many cases, unless you use recent features of the Numpy C API, you will still be able to build your package with an older version of Numpy and therefore you will still be able to use `oldest-supported-numpy`. You can still impose a more recent Numpy requirement in `install_requires`.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1735#issuecomment-989966457
https://github.com/qutip/qutip/pull/1735#issuecomment-990032654:213,Deployability,install,installed,213,"> This (the linked log) is tripping up on setup_requires, which is deprecated and I don't think you have it set up correctly anyway; if you ask for `Cython` but don't `install_requires` Cython, Cython will not be installed before running the setup. This is intentional -- we want to support installing from pre-built packages without a compiler or Cython installed.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1735#issuecomment-990032654
https://github.com/qutip/qutip/pull/1735#issuecomment-990032654:291,Deployability,install,installing,291,"> This (the linked log) is tripping up on setup_requires, which is deprecated and I don't think you have it set up correctly anyway; if you ask for `Cython` but don't `install_requires` Cython, Cython will not be installed before running the setup. This is intentional -- we want to support installing from pre-built packages without a compiler or Cython installed.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1735#issuecomment-990032654
https://github.com/qutip/qutip/pull/1735#issuecomment-990032654:355,Deployability,install,installed,355,"> This (the linked log) is tripping up on setup_requires, which is deprecated and I don't think you have it set up correctly anyway; if you ask for `Cython` but don't `install_requires` Cython, Cython will not be installed before running the setup. This is intentional -- we want to support installing from pre-built packages without a compiler or Cython installed.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1735#issuecomment-990032654
https://github.com/qutip/qutip/pull/1735#issuecomment-990032654:19,Testability,log,log,19,"> This (the linked log) is tripping up on setup_requires, which is deprecated and I don't think you have it set up correctly anyway; if you ask for `Cython` but don't `install_requires` Cython, Cython will not be installed before running the setup. This is intentional -- we want to support installing from pre-built packages without a compiler or Cython installed.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1735#issuecomment-990032654
https://github.com/qutip/qutip/pull/1735#issuecomment-990081489:14,Availability,error,error,14,Bleh -- build error: `ERROR: Some build dependencies for file:///project conflict with the backend dependencies: numpy==1.13.3 is incompatible with numpy>=1.16.6.`; Probably I need to loosen the build dependencies in setup_requires.,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1735#issuecomment-990081489
https://github.com/qutip/qutip/pull/1735#issuecomment-990081489:22,Availability,ERROR,ERROR,22,Bleh -- build error: `ERROR: Some build dependencies for file:///project conflict with the backend dependencies: numpy==1.13.3 is incompatible with numpy>=1.16.6.`; Probably I need to loosen the build dependencies in setup_requires.,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1735#issuecomment-990081489
https://github.com/qutip/qutip/pull/1735#issuecomment-990081489:40,Integrability,depend,dependencies,40,Bleh -- build error: `ERROR: Some build dependencies for file:///project conflict with the backend dependencies: numpy==1.13.3 is incompatible with numpy>=1.16.6.`; Probably I need to loosen the build dependencies in setup_requires.,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1735#issuecomment-990081489
https://github.com/qutip/qutip/pull/1735#issuecomment-990081489:99,Integrability,depend,dependencies,99,Bleh -- build error: `ERROR: Some build dependencies for file:///project conflict with the backend dependencies: numpy==1.13.3 is incompatible with numpy>=1.16.6.`; Probably I need to loosen the build dependencies in setup_requires.,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1735#issuecomment-990081489
https://github.com/qutip/qutip/pull/1735#issuecomment-990081489:201,Integrability,depend,dependencies,201,Bleh -- build error: `ERROR: Some build dependencies for file:///project conflict with the backend dependencies: numpy==1.13.3 is incompatible with numpy>=1.16.6.`; Probably I need to loosen the build dependencies in setup_requires.,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1735#issuecomment-990081489
https://github.com/qutip/qutip/issues/1737#issuecomment-990055735:279,Availability,down,down,279,"Internally all `Qobj` use sparse matrices, no matter what type of data you give them. Whether your density matrix stays sparse during the time evolution depends on the Hamiltonian. In general, especially if there's any environmental interaction, it likely won't, but that's just down to the physics.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1737#issuecomment-990055735
https://github.com/qutip/qutip/issues/1737#issuecomment-990055735:153,Integrability,depend,depends,153,"Internally all `Qobj` use sparse matrices, no matter what type of data you give them. Whether your density matrix stays sparse during the time evolution depends on the Hamiltonian. In general, especially if there's any environmental interaction, it likely won't, but that's just down to the physics.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1737#issuecomment-990055735
https://github.com/qutip/qutip/pull/1738#issuecomment-990015553:247,Deployability,install,install,247,"@henryiii Thank you for taking the time to make this much nicer looking PR. It does look much better, I just have to try convince myself everything will work now. It looks like the build is currently failing because `--no-build-isolation` doesn't install the build depedencies so we'll need to install them manually. I wonder what the best way to support that is (since users would likely have to do it themselves regularly too).",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1738#issuecomment-990015553
https://github.com/qutip/qutip/pull/1738#issuecomment-990015553:294,Deployability,install,install,294,"@henryiii Thank you for taking the time to make this much nicer looking PR. It does look much better, I just have to try convince myself everything will work now. It looks like the build is currently failing because `--no-build-isolation` doesn't install the build depedencies so we'll need to install them manually. I wonder what the best way to support that is (since users would likely have to do it themselves regularly too).",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1738#issuecomment-990015553
https://github.com/qutip/qutip/pull/1738#issuecomment-990018307:20,Deployability,install,installing,20,"Users should not be installing pip dependencies into a conda environment. They should be using conda, not pip. You are only running into this because you are using pip inside a conda environment, and yes, you'll need the dependencies (with their proper conda names) in that environment. (And, since wheels work inside conda, `pip install cutip` should work inside a conda env, even if they should be using conda - it's only because you are building inside it, which is very much not supported for normal users)",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1738#issuecomment-990018307
https://github.com/qutip/qutip/pull/1738#issuecomment-990018307:330,Deployability,install,install,330,"Users should not be installing pip dependencies into a conda environment. They should be using conda, not pip. You are only running into this because you are using pip inside a conda environment, and yes, you'll need the dependencies (with their proper conda names) in that environment. (And, since wheels work inside conda, `pip install cutip` should work inside a conda env, even if they should be using conda - it's only because you are building inside it, which is very much not supported for normal users)",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1738#issuecomment-990018307
https://github.com/qutip/qutip/pull/1738#issuecomment-990018307:35,Integrability,depend,dependencies,35,"Users should not be installing pip dependencies into a conda environment. They should be using conda, not pip. You are only running into this because you are using pip inside a conda environment, and yes, you'll need the dependencies (with their proper conda names) in that environment. (And, since wheels work inside conda, `pip install cutip` should work inside a conda env, even if they should be using conda - it's only because you are building inside it, which is very much not supported for normal users)",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1738#issuecomment-990018307
https://github.com/qutip/qutip/pull/1738#issuecomment-990018307:221,Integrability,depend,dependencies,221,"Users should not be installing pip dependencies into a conda environment. They should be using conda, not pip. You are only running into this because you are using pip inside a conda environment, and yes, you'll need the dependencies (with their proper conda names) in that environment. (And, since wheels work inside conda, `pip install cutip` should work inside a conda env, even if they should be using conda - it's only because you are building inside it, which is very much not supported for normal users)",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1738#issuecomment-990018307
https://github.com/qutip/qutip/pull/1738#issuecomment-990098258:211,Deployability,patch,patch-,211,[![Coverage Status](https://coveralls.io/builds/44890781/badge)](https://coveralls.io/builds/44890781). Coverage decreased (-0.02%) to 68.272% when pulling **351a56170119246c77692112d6b46d21a75410a3 on henryiii:patch-1** into **9c2c08b82040c2c47fe8290bc23ecf6047e00bc5 on qutip:master**.,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1738#issuecomment-990098258
https://github.com/qutip/qutip/pull/1739#issuecomment-992488933:100,Energy Efficiency,reduce,reduced,100,"Hello Nathan, in a couple of hours we will perform the final minor docstring improvements, since we reduced the Cognitive Complexity. Tomorrow is finally ready!",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1739#issuecomment-992488933
https://github.com/qutip/qutip/pull/1739#issuecomment-992488933:43,Performance,perform,perform,43,"Hello Nathan, in a couple of hours we will perform the final minor docstring improvements, since we reduced the Cognitive Complexity. Tomorrow is finally ready!",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1739#issuecomment-992488933
https://github.com/qutip/qutip/pull/1739#issuecomment-1033971350:70,Deployability,release,release,70,@emilianomfortes Hello! I would like to include this in the QuTiP 4.7 release. Do you have time to incorporate or respond to @Ericgig's suggestions?,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1739#issuecomment-1033971350
https://github.com/qutip/qutip/pull/1739#issuecomment-1039192650:602,Availability,toler,tolerance,602,"Hello @hodgestar, we missed your last comment, but Nathan just notified us. We will get it all sorted out by wednesday at most. I leave a todolist to keep track of everything that @Ericgig mentioned. To-do. * [x] Include some tests like test_sesolve.py --> **Included tests with random Hamiltonian, ising transverse field and SHO. Both for states and expectation values. Lacking a testing example for callable e_ops**. * [x] Why <code>krylov_dim=30?</code> ? --> **There was a subtle physical reason, but we conclude its better to leave it as a free input without a predefined variable.**. * [x] <code>tolerance</code>, <code>store_states</code> and <code>store_final_state</code> --> **Changed as an Options qutip class, now tolerance is <code>Options.atol</code> property**. * [x] <code>e_ops</code> should also take a callable or list of mixed function and <code>Qobj</code> --> **Added support**. * [x] Remove support for <code>np.ndarray</code> --> **Removed for qutip cleanliness**. * [x] Assertion errors to specififc errors --> **Modified.**. * [x] Check that psi0 is a ket --> **Added**. * [x] If both <code>store_states</code> and <code>store_final_state</code> are True there is a small bug --> **Fixed the store twice problem**. * [x] Infinite loop at stagnant =0 --> **Added a raise ValueError if its <0.**. * [x] __all__ should be defined to filter functions seen by the user --> **set to =<code>krylovsolve</code> and <code>lanczos_algorithm</code>**. * [x] Why not call <code>_make_partitions</code> directly instead of having this method --> **Removed when deprecating <code>KSolve</code> class**. * [x] tlist is already stored, are those needed? (lines 152-155) --> **Removed when deprecating <code>KSolve</code> class**; * [x] The Result has a tag to the solver that created it --> **Added**; * [x] If tlist is empty, you can just return the empty results. --> **Now it returns an empty <code>Results()</code> instance.**; * [x] Can you use the <code>eigh</code> in <code>qutip.spar",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1739#issuecomment-1039192650
https://github.com/qutip/qutip/pull/1739#issuecomment-1039192650:726,Availability,toler,tolerance,726,"Hello @hodgestar, we missed your last comment, but Nathan just notified us. We will get it all sorted out by wednesday at most. I leave a todolist to keep track of everything that @Ericgig mentioned. To-do. * [x] Include some tests like test_sesolve.py --> **Included tests with random Hamiltonian, ising transverse field and SHO. Both for states and expectation values. Lacking a testing example for callable e_ops**. * [x] Why <code>krylov_dim=30?</code> ? --> **There was a subtle physical reason, but we conclude its better to leave it as a free input without a predefined variable.**. * [x] <code>tolerance</code>, <code>store_states</code> and <code>store_final_state</code> --> **Changed as an Options qutip class, now tolerance is <code>Options.atol</code> property**. * [x] <code>e_ops</code> should also take a callable or list of mixed function and <code>Qobj</code> --> **Added support**. * [x] Remove support for <code>np.ndarray</code> --> **Removed for qutip cleanliness**. * [x] Assertion errors to specififc errors --> **Modified.**. * [x] Check that psi0 is a ket --> **Added**. * [x] If both <code>store_states</code> and <code>store_final_state</code> are True there is a small bug --> **Fixed the store twice problem**. * [x] Infinite loop at stagnant =0 --> **Added a raise ValueError if its <0.**. * [x] __all__ should be defined to filter functions seen by the user --> **set to =<code>krylovsolve</code> and <code>lanczos_algorithm</code>**. * [x] Why not call <code>_make_partitions</code> directly instead of having this method --> **Removed when deprecating <code>KSolve</code> class**. * [x] tlist is already stored, are those needed? (lines 152-155) --> **Removed when deprecating <code>KSolve</code> class**; * [x] The Result has a tag to the solver that created it --> **Added**; * [x] If tlist is empty, you can just return the empty results. --> **Now it returns an empty <code>Results()</code> instance.**; * [x] Can you use the <code>eigh</code> in <code>qutip.spar",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1739#issuecomment-1039192650
https://github.com/qutip/qutip/pull/1739#issuecomment-1039192650:1005,Availability,error,errors,1005," we missed your last comment, but Nathan just notified us. We will get it all sorted out by wednesday at most. I leave a todolist to keep track of everything that @Ericgig mentioned. To-do. * [x] Include some tests like test_sesolve.py --> **Included tests with random Hamiltonian, ising transverse field and SHO. Both for states and expectation values. Lacking a testing example for callable e_ops**. * [x] Why <code>krylov_dim=30?</code> ? --> **There was a subtle physical reason, but we conclude its better to leave it as a free input without a predefined variable.**. * [x] <code>tolerance</code>, <code>store_states</code> and <code>store_final_state</code> --> **Changed as an Options qutip class, now tolerance is <code>Options.atol</code> property**. * [x] <code>e_ops</code> should also take a callable or list of mixed function and <code>Qobj</code> --> **Added support**. * [x] Remove support for <code>np.ndarray</code> --> **Removed for qutip cleanliness**. * [x] Assertion errors to specififc errors --> **Modified.**. * [x] Check that psi0 is a ket --> **Added**. * [x] If both <code>store_states</code> and <code>store_final_state</code> are True there is a small bug --> **Fixed the store twice problem**. * [x] Infinite loop at stagnant =0 --> **Added a raise ValueError if its <0.**. * [x] __all__ should be defined to filter functions seen by the user --> **set to =<code>krylovsolve</code> and <code>lanczos_algorithm</code>**. * [x] Why not call <code>_make_partitions</code> directly instead of having this method --> **Removed when deprecating <code>KSolve</code> class**. * [x] tlist is already stored, are those needed? (lines 152-155) --> **Removed when deprecating <code>KSolve</code> class**; * [x] The Result has a tag to the solver that created it --> **Added**; * [x] If tlist is empty, you can just return the empty results. --> **Now it returns an empty <code>Results()</code> instance.**; * [x] Can you use the <code>eigh</code> in <code>qutip.sparse</code> . There",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1739#issuecomment-1039192650
https://github.com/qutip/qutip/pull/1739#issuecomment-1039192650:1025,Availability,error,errors,1025," we missed your last comment, but Nathan just notified us. We will get it all sorted out by wednesday at most. I leave a todolist to keep track of everything that @Ericgig mentioned. To-do. * [x] Include some tests like test_sesolve.py --> **Included tests with random Hamiltonian, ising transverse field and SHO. Both for states and expectation values. Lacking a testing example for callable e_ops**. * [x] Why <code>krylov_dim=30?</code> ? --> **There was a subtle physical reason, but we conclude its better to leave it as a free input without a predefined variable.**. * [x] <code>tolerance</code>, <code>store_states</code> and <code>store_final_state</code> --> **Changed as an Options qutip class, now tolerance is <code>Options.atol</code> property**. * [x] <code>e_ops</code> should also take a callable or list of mixed function and <code>Qobj</code> --> **Added support**. * [x] Remove support for <code>np.ndarray</code> --> **Removed for qutip cleanliness**. * [x] Assertion errors to specififc errors --> **Modified.**. * [x] Check that psi0 is a ket --> **Added**. * [x] If both <code>store_states</code> and <code>store_final_state</code> are True there is a small bug --> **Fixed the store twice problem**. * [x] Infinite loop at stagnant =0 --> **Added a raise ValueError if its <0.**. * [x] __all__ should be defined to filter functions seen by the user --> **set to =<code>krylovsolve</code> and <code>lanczos_algorithm</code>**. * [x] Why not call <code>_make_partitions</code> directly instead of having this method --> **Removed when deprecating <code>KSolve</code> class**. * [x] tlist is already stored, are those needed? (lines 152-155) --> **Removed when deprecating <code>KSolve</code> class**; * [x] The Result has a tag to the solver that created it --> **Added**; * [x] If tlist is empty, you can just return the empty results. --> **Now it returns an empty <code>Results()</code> instance.**; * [x] Can you use the <code>eigh</code> in <code>qutip.sparse</code> . There",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1739#issuecomment-1039192650
https://github.com/qutip/qutip/pull/1739#issuecomment-1039192650:577,Modifiability,variab,variable,577,"Hello @hodgestar, we missed your last comment, but Nathan just notified us. We will get it all sorted out by wednesday at most. I leave a todolist to keep track of everything that @Ericgig mentioned. To-do. * [x] Include some tests like test_sesolve.py --> **Included tests with random Hamiltonian, ising transverse field and SHO. Both for states and expectation values. Lacking a testing example for callable e_ops**. * [x] Why <code>krylov_dim=30?</code> ? --> **There was a subtle physical reason, but we conclude its better to leave it as a free input without a predefined variable.**. * [x] <code>tolerance</code>, <code>store_states</code> and <code>store_final_state</code> --> **Changed as an Options qutip class, now tolerance is <code>Options.atol</code> property**. * [x] <code>e_ops</code> should also take a callable or list of mixed function and <code>Qobj</code> --> **Added support**. * [x] Remove support for <code>np.ndarray</code> --> **Removed for qutip cleanliness**. * [x] Assertion errors to specififc errors --> **Modified.**. * [x] Check that psi0 is a ket --> **Added**. * [x] If both <code>store_states</code> and <code>store_final_state</code> are True there is a small bug --> **Fixed the store twice problem**. * [x] Infinite loop at stagnant =0 --> **Added a raise ValueError if its <0.**. * [x] __all__ should be defined to filter functions seen by the user --> **set to =<code>krylovsolve</code> and <code>lanczos_algorithm</code>**. * [x] Why not call <code>_make_partitions</code> directly instead of having this method --> **Removed when deprecating <code>KSolve</code> class**. * [x] tlist is already stored, are those needed? (lines 152-155) --> **Removed when deprecating <code>KSolve</code> class**; * [x] The Result has a tag to the solver that created it --> **Added**; * [x] If tlist is empty, you can just return the empty results. --> **Now it returns an empty <code>Results()</code> instance.**; * [x] Can you use the <code>eigh</code> in <code>qutip.spar",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1739#issuecomment-1039192650
https://github.com/qutip/qutip/pull/1739#issuecomment-1039192650:3580,Modifiability,evolve,evolved,3580,"reated it --> **Added**; * [x] If tlist is empty, you can just return the empty results. --> **Now it returns an empty <code>Results()</code> instance.**; * [x] Can you use the <code>eigh</code> in <code>qutip.sparse</code> . There is a bug in eigh on mac with openblas. --> **Switched to <code>qutip.sparse.eigh</code>**; * [x] What does this <code>optimizer</code> function optimize? Could you add a simple description. --> **This functions finds the optimal number of Lanczos algorithm iterations inside Krylov, added as small description**; * [x] <code>_estimate_norm</code> is nerver used. --> **Removed**; * [x] Why is tlist here and not in solve? It seems strange that you can reuse one instance for multiple H and psi0, but you cannot change tlist. --> **Removed when deprecating <code>KSolve</code> class**; * [x] Why do you need KSolve? --> **It was a workaround to the cognitive complexity check of github. But we decided to revert back to a non Class solver, as it adds another type of complexity.**; * [x] Increasing pdx here when it is already controlled by enumerate is strange. The best would be to include the first partition here too. Otherwise using update_progress_bar(pdx + 1) is clearer. --> **Changed ""pdx"" into ""idx"". Added the first lazy iteration inside the loop, now it is more clear with <code>update_progress_bar(idx)</code>.**; * [x] There is no work done between update_progress_bar(0) and update_progress_bar(1). Did you start it? --> **Fixed simultaneously by the previous change.**; * [x] Shouldn't this also double the last element? prepare_next_step remove the first and last so the last state is not stored. --> **Good catch, it was a bug. Fixed.**; * [x] <code>_happy_breadkown</code> never used... --> **Should be fixed, performing extra checks**; * [x] evolved states It should keep the input state dims. --> **Checked all situations that came to mind and output dimensions seem to be working properly.**; * [x] Why import <code>mcsolve</code>? --> **Removed**",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1739#issuecomment-1039192650
https://github.com/qutip/qutip/pull/1739#issuecomment-1039192650:2137,Performance,optimiz,optimizer,2137,"e_final_state</code> are True there is a small bug --> **Fixed the store twice problem**. * [x] Infinite loop at stagnant =0 --> **Added a raise ValueError if its <0.**. * [x] __all__ should be defined to filter functions seen by the user --> **set to =<code>krylovsolve</code> and <code>lanczos_algorithm</code>**. * [x] Why not call <code>_make_partitions</code> directly instead of having this method --> **Removed when deprecating <code>KSolve</code> class**. * [x] tlist is already stored, are those needed? (lines 152-155) --> **Removed when deprecating <code>KSolve</code> class**; * [x] The Result has a tag to the solver that created it --> **Added**; * [x] If tlist is empty, you can just return the empty results. --> **Now it returns an empty <code>Results()</code> instance.**; * [x] Can you use the <code>eigh</code> in <code>qutip.sparse</code> . There is a bug in eigh on mac with openblas. --> **Switched to <code>qutip.sparse.eigh</code>**; * [x] What does this <code>optimizer</code> function optimize? Could you add a simple description. --> **This functions finds the optimal number of Lanczos algorithm iterations inside Krylov, added as small description**; * [x] <code>_estimate_norm</code> is nerver used. --> **Removed**; * [x] Why is tlist here and not in solve? It seems strange that you can reuse one instance for multiple H and psi0, but you cannot change tlist. --> **Removed when deprecating <code>KSolve</code> class**; * [x] Why do you need KSolve? --> **It was a workaround to the cognitive complexity check of github. But we decided to revert back to a non Class solver, as it adds another type of complexity.**; * [x] Increasing pdx here when it is already controlled by enumerate is strange. The best would be to include the first partition here too. Otherwise using update_progress_bar(pdx + 1) is clearer. --> **Changed ""pdx"" into ""idx"". Added the first lazy iteration inside the loop, now it is more clear with <code>update_progress_bar(idx)</code>.**; * [x] T",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1739#issuecomment-1039192650
https://github.com/qutip/qutip/pull/1739#issuecomment-1039192650:2163,Performance,optimiz,optimize,2163,"e_final_state</code> are True there is a small bug --> **Fixed the store twice problem**. * [x] Infinite loop at stagnant =0 --> **Added a raise ValueError if its <0.**. * [x] __all__ should be defined to filter functions seen by the user --> **set to =<code>krylovsolve</code> and <code>lanczos_algorithm</code>**. * [x] Why not call <code>_make_partitions</code> directly instead of having this method --> **Removed when deprecating <code>KSolve</code> class**. * [x] tlist is already stored, are those needed? (lines 152-155) --> **Removed when deprecating <code>KSolve</code> class**; * [x] The Result has a tag to the solver that created it --> **Added**; * [x] If tlist is empty, you can just return the empty results. --> **Now it returns an empty <code>Results()</code> instance.**; * [x] Can you use the <code>eigh</code> in <code>qutip.sparse</code> . There is a bug in eigh on mac with openblas. --> **Switched to <code>qutip.sparse.eigh</code>**; * [x] What does this <code>optimizer</code> function optimize? Could you add a simple description. --> **This functions finds the optimal number of Lanczos algorithm iterations inside Krylov, added as small description**; * [x] <code>_estimate_norm</code> is nerver used. --> **Removed**; * [x] Why is tlist here and not in solve? It seems strange that you can reuse one instance for multiple H and psi0, but you cannot change tlist. --> **Removed when deprecating <code>KSolve</code> class**; * [x] Why do you need KSolve? --> **It was a workaround to the cognitive complexity check of github. But we decided to revert back to a non Class solver, as it adds another type of complexity.**; * [x] Increasing pdx here when it is already controlled by enumerate is strange. The best would be to include the first partition here too. Otherwise using update_progress_bar(pdx + 1) is clearer. --> **Changed ""pdx"" into ""idx"". Added the first lazy iteration inside the loop, now it is more clear with <code>update_progress_bar(idx)</code>.**; * [x] T",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1739#issuecomment-1039192650
https://github.com/qutip/qutip/pull/1739#issuecomment-1039192650:3547,Performance,perform,performing,3547,"reated it --> **Added**; * [x] If tlist is empty, you can just return the empty results. --> **Now it returns an empty <code>Results()</code> instance.**; * [x] Can you use the <code>eigh</code> in <code>qutip.sparse</code> . There is a bug in eigh on mac with openblas. --> **Switched to <code>qutip.sparse.eigh</code>**; * [x] What does this <code>optimizer</code> function optimize? Could you add a simple description. --> **This functions finds the optimal number of Lanczos algorithm iterations inside Krylov, added as small description**; * [x] <code>_estimate_norm</code> is nerver used. --> **Removed**; * [x] Why is tlist here and not in solve? It seems strange that you can reuse one instance for multiple H and psi0, but you cannot change tlist. --> **Removed when deprecating <code>KSolve</code> class**; * [x] Why do you need KSolve? --> **It was a workaround to the cognitive complexity check of github. But we decided to revert back to a non Class solver, as it adds another type of complexity.**; * [x] Increasing pdx here when it is already controlled by enumerate is strange. The best would be to include the first partition here too. Otherwise using update_progress_bar(pdx + 1) is clearer. --> **Changed ""pdx"" into ""idx"". Added the first lazy iteration inside the loop, now it is more clear with <code>update_progress_bar(idx)</code>.**; * [x] There is no work done between update_progress_bar(0) and update_progress_bar(1). Did you start it? --> **Fixed simultaneously by the previous change.**; * [x] Shouldn't this also double the last element? prepare_next_step remove the first and last so the last state is not stored. --> **Good catch, it was a bug. Fixed.**; * [x] <code>_happy_breadkown</code> never used... --> **Should be fixed, performing extra checks**; * [x] evolved states It should keep the input state dims. --> **Checked all situations that came to mind and output dimensions seem to be working properly.**; * [x] Why import <code>mcsolve</code>? --> **Removed**",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1739#issuecomment-1039192650
https://github.com/qutip/qutip/pull/1739#issuecomment-1039192650:226,Testability,test,tests,226,"Hello @hodgestar, we missed your last comment, but Nathan just notified us. We will get it all sorted out by wednesday at most. I leave a todolist to keep track of everything that @Ericgig mentioned. To-do. * [x] Include some tests like test_sesolve.py --> **Included tests with random Hamiltonian, ising transverse field and SHO. Both for states and expectation values. Lacking a testing example for callable e_ops**. * [x] Why <code>krylov_dim=30?</code> ? --> **There was a subtle physical reason, but we conclude its better to leave it as a free input without a predefined variable.**. * [x] <code>tolerance</code>, <code>store_states</code> and <code>store_final_state</code> --> **Changed as an Options qutip class, now tolerance is <code>Options.atol</code> property**. * [x] <code>e_ops</code> should also take a callable or list of mixed function and <code>Qobj</code> --> **Added support**. * [x] Remove support for <code>np.ndarray</code> --> **Removed for qutip cleanliness**. * [x] Assertion errors to specififc errors --> **Modified.**. * [x] Check that psi0 is a ket --> **Added**. * [x] If both <code>store_states</code> and <code>store_final_state</code> are True there is a small bug --> **Fixed the store twice problem**. * [x] Infinite loop at stagnant =0 --> **Added a raise ValueError if its <0.**. * [x] __all__ should be defined to filter functions seen by the user --> **set to =<code>krylovsolve</code> and <code>lanczos_algorithm</code>**. * [x] Why not call <code>_make_partitions</code> directly instead of having this method --> **Removed when deprecating <code>KSolve</code> class**. * [x] tlist is already stored, are those needed? (lines 152-155) --> **Removed when deprecating <code>KSolve</code> class**; * [x] The Result has a tag to the solver that created it --> **Added**; * [x] If tlist is empty, you can just return the empty results. --> **Now it returns an empty <code>Results()</code> instance.**; * [x] Can you use the <code>eigh</code> in <code>qutip.spar",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1739#issuecomment-1039192650
https://github.com/qutip/qutip/pull/1739#issuecomment-1039192650:268,Testability,test,tests,268,"Hello @hodgestar, we missed your last comment, but Nathan just notified us. We will get it all sorted out by wednesday at most. I leave a todolist to keep track of everything that @Ericgig mentioned. To-do. * [x] Include some tests like test_sesolve.py --> **Included tests with random Hamiltonian, ising transverse field and SHO. Both for states and expectation values. Lacking a testing example for callable e_ops**. * [x] Why <code>krylov_dim=30?</code> ? --> **There was a subtle physical reason, but we conclude its better to leave it as a free input without a predefined variable.**. * [x] <code>tolerance</code>, <code>store_states</code> and <code>store_final_state</code> --> **Changed as an Options qutip class, now tolerance is <code>Options.atol</code> property**. * [x] <code>e_ops</code> should also take a callable or list of mixed function and <code>Qobj</code> --> **Added support**. * [x] Remove support for <code>np.ndarray</code> --> **Removed for qutip cleanliness**. * [x] Assertion errors to specififc errors --> **Modified.**. * [x] Check that psi0 is a ket --> **Added**. * [x] If both <code>store_states</code> and <code>store_final_state</code> are True there is a small bug --> **Fixed the store twice problem**. * [x] Infinite loop at stagnant =0 --> **Added a raise ValueError if its <0.**. * [x] __all__ should be defined to filter functions seen by the user --> **set to =<code>krylovsolve</code> and <code>lanczos_algorithm</code>**. * [x] Why not call <code>_make_partitions</code> directly instead of having this method --> **Removed when deprecating <code>KSolve</code> class**. * [x] tlist is already stored, are those needed? (lines 152-155) --> **Removed when deprecating <code>KSolve</code> class**; * [x] The Result has a tag to the solver that created it --> **Added**; * [x] If tlist is empty, you can just return the empty results. --> **Now it returns an empty <code>Results()</code> instance.**; * [x] Can you use the <code>eigh</code> in <code>qutip.spar",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1739#issuecomment-1039192650
https://github.com/qutip/qutip/pull/1739#issuecomment-1039192650:381,Testability,test,testing,381,"Hello @hodgestar, we missed your last comment, but Nathan just notified us. We will get it all sorted out by wednesday at most. I leave a todolist to keep track of everything that @Ericgig mentioned. To-do. * [x] Include some tests like test_sesolve.py --> **Included tests with random Hamiltonian, ising transverse field and SHO. Both for states and expectation values. Lacking a testing example for callable e_ops**. * [x] Why <code>krylov_dim=30?</code> ? --> **There was a subtle physical reason, but we conclude its better to leave it as a free input without a predefined variable.**. * [x] <code>tolerance</code>, <code>store_states</code> and <code>store_final_state</code> --> **Changed as an Options qutip class, now tolerance is <code>Options.atol</code> property**. * [x] <code>e_ops</code> should also take a callable or list of mixed function and <code>Qobj</code> --> **Added support**. * [x] Remove support for <code>np.ndarray</code> --> **Removed for qutip cleanliness**. * [x] Assertion errors to specififc errors --> **Modified.**. * [x] Check that psi0 is a ket --> **Added**. * [x] If both <code>store_states</code> and <code>store_final_state</code> are True there is a small bug --> **Fixed the store twice problem**. * [x] Infinite loop at stagnant =0 --> **Added a raise ValueError if its <0.**. * [x] __all__ should be defined to filter functions seen by the user --> **set to =<code>krylovsolve</code> and <code>lanczos_algorithm</code>**. * [x] Why not call <code>_make_partitions</code> directly instead of having this method --> **Removed when deprecating <code>KSolve</code> class**. * [x] tlist is already stored, are those needed? (lines 152-155) --> **Removed when deprecating <code>KSolve</code> class**; * [x] The Result has a tag to the solver that created it --> **Added**; * [x] If tlist is empty, you can just return the empty results. --> **Now it returns an empty <code>Results()</code> instance.**; * [x] Can you use the <code>eigh</code> in <code>qutip.spar",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1739#issuecomment-1039192650
https://github.com/qutip/qutip/pull/1739#issuecomment-1039192650:995,Testability,Assert,Assertion,995," we missed your last comment, but Nathan just notified us. We will get it all sorted out by wednesday at most. I leave a todolist to keep track of everything that @Ericgig mentioned. To-do. * [x] Include some tests like test_sesolve.py --> **Included tests with random Hamiltonian, ising transverse field and SHO. Both for states and expectation values. Lacking a testing example for callable e_ops**. * [x] Why <code>krylov_dim=30?</code> ? --> **There was a subtle physical reason, but we conclude its better to leave it as a free input without a predefined variable.**. * [x] <code>tolerance</code>, <code>store_states</code> and <code>store_final_state</code> --> **Changed as an Options qutip class, now tolerance is <code>Options.atol</code> property**. * [x] <code>e_ops</code> should also take a callable or list of mixed function and <code>Qobj</code> --> **Added support**. * [x] Remove support for <code>np.ndarray</code> --> **Removed for qutip cleanliness**. * [x] Assertion errors to specififc errors --> **Modified.**. * [x] Check that psi0 is a ket --> **Added**. * [x] If both <code>store_states</code> and <code>store_final_state</code> are True there is a small bug --> **Fixed the store twice problem**. * [x] Infinite loop at stagnant =0 --> **Added a raise ValueError if its <0.**. * [x] __all__ should be defined to filter functions seen by the user --> **set to =<code>krylovsolve</code> and <code>lanczos_algorithm</code>**. * [x] Why not call <code>_make_partitions</code> directly instead of having this method --> **Removed when deprecating <code>KSolve</code> class**. * [x] tlist is already stored, are those needed? (lines 152-155) --> **Removed when deprecating <code>KSolve</code> class**; * [x] The Result has a tag to the solver that created it --> **Added**; * [x] If tlist is empty, you can just return the empty results. --> **Now it returns an empty <code>Results()</code> instance.**; * [x] Can you use the <code>eigh</code> in <code>qutip.sparse</code> . There",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1739#issuecomment-1039192650
https://github.com/qutip/qutip/pull/1739#issuecomment-1039192650:2189,Usability,simpl,simple,2189,"e_final_state</code> are True there is a small bug --> **Fixed the store twice problem**. * [x] Infinite loop at stagnant =0 --> **Added a raise ValueError if its <0.**. * [x] __all__ should be defined to filter functions seen by the user --> **set to =<code>krylovsolve</code> and <code>lanczos_algorithm</code>**. * [x] Why not call <code>_make_partitions</code> directly instead of having this method --> **Removed when deprecating <code>KSolve</code> class**. * [x] tlist is already stored, are those needed? (lines 152-155) --> **Removed when deprecating <code>KSolve</code> class**; * [x] The Result has a tag to the solver that created it --> **Added**; * [x] If tlist is empty, you can just return the empty results. --> **Now it returns an empty <code>Results()</code> instance.**; * [x] Can you use the <code>eigh</code> in <code>qutip.sparse</code> . There is a bug in eigh on mac with openblas. --> **Switched to <code>qutip.sparse.eigh</code>**; * [x] What does this <code>optimizer</code> function optimize? Could you add a simple description. --> **This functions finds the optimal number of Lanczos algorithm iterations inside Krylov, added as small description**; * [x] <code>_estimate_norm</code> is nerver used. --> **Removed**; * [x] Why is tlist here and not in solve? It seems strange that you can reuse one instance for multiple H and psi0, but you cannot change tlist. --> **Removed when deprecating <code>KSolve</code> class**; * [x] Why do you need KSolve? --> **It was a workaround to the cognitive complexity check of github. But we decided to revert back to a non Class solver, as it adds another type of complexity.**; * [x] Increasing pdx here when it is already controlled by enumerate is strange. The best would be to include the first partition here too. Otherwise using update_progress_bar(pdx + 1) is clearer. --> **Changed ""pdx"" into ""idx"". Added the first lazy iteration inside the loop, now it is more clear with <code>update_progress_bar(idx)</code>.**; * [x] T",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1739#issuecomment-1039192650
https://github.com/qutip/qutip/pull/1739#issuecomment-1039192650:2988,Usability,clear,clearer,2988,"reated it --> **Added**; * [x] If tlist is empty, you can just return the empty results. --> **Now it returns an empty <code>Results()</code> instance.**; * [x] Can you use the <code>eigh</code> in <code>qutip.sparse</code> . There is a bug in eigh on mac with openblas. --> **Switched to <code>qutip.sparse.eigh</code>**; * [x] What does this <code>optimizer</code> function optimize? Could you add a simple description. --> **This functions finds the optimal number of Lanczos algorithm iterations inside Krylov, added as small description**; * [x] <code>_estimate_norm</code> is nerver used. --> **Removed**; * [x] Why is tlist here and not in solve? It seems strange that you can reuse one instance for multiple H and psi0, but you cannot change tlist. --> **Removed when deprecating <code>KSolve</code> class**; * [x] Why do you need KSolve? --> **It was a workaround to the cognitive complexity check of github. But we decided to revert back to a non Class solver, as it adds another type of complexity.**; * [x] Increasing pdx here when it is already controlled by enumerate is strange. The best would be to include the first partition here too. Otherwise using update_progress_bar(pdx + 1) is clearer. --> **Changed ""pdx"" into ""idx"". Added the first lazy iteration inside the loop, now it is more clear with <code>update_progress_bar(idx)</code>.**; * [x] There is no work done between update_progress_bar(0) and update_progress_bar(1). Did you start it? --> **Fixed simultaneously by the previous change.**; * [x] Shouldn't this also double the last element? prepare_next_step remove the first and last so the last state is not stored. --> **Good catch, it was a bug. Fixed.**; * [x] <code>_happy_breadkown</code> never used... --> **Should be fixed, performing extra checks**; * [x] evolved states It should keep the input state dims. --> **Checked all situations that came to mind and output dimensions seem to be working properly.**; * [x] Why import <code>mcsolve</code>? --> **Removed**",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1739#issuecomment-1039192650
https://github.com/qutip/qutip/pull/1739#issuecomment-1039192650:3092,Usability,clear,clear,3092,"reated it --> **Added**; * [x] If tlist is empty, you can just return the empty results. --> **Now it returns an empty <code>Results()</code> instance.**; * [x] Can you use the <code>eigh</code> in <code>qutip.sparse</code> . There is a bug in eigh on mac with openblas. --> **Switched to <code>qutip.sparse.eigh</code>**; * [x] What does this <code>optimizer</code> function optimize? Could you add a simple description. --> **This functions finds the optimal number of Lanczos algorithm iterations inside Krylov, added as small description**; * [x] <code>_estimate_norm</code> is nerver used. --> **Removed**; * [x] Why is tlist here and not in solve? It seems strange that you can reuse one instance for multiple H and psi0, but you cannot change tlist. --> **Removed when deprecating <code>KSolve</code> class**; * [x] Why do you need KSolve? --> **It was a workaround to the cognitive complexity check of github. But we decided to revert back to a non Class solver, as it adds another type of complexity.**; * [x] Increasing pdx here when it is already controlled by enumerate is strange. The best would be to include the first partition here too. Otherwise using update_progress_bar(pdx + 1) is clearer. --> **Changed ""pdx"" into ""idx"". Added the first lazy iteration inside the loop, now it is more clear with <code>update_progress_bar(idx)</code>.**; * [x] There is no work done between update_progress_bar(0) and update_progress_bar(1). Did you start it? --> **Fixed simultaneously by the previous change.**; * [x] Shouldn't this also double the last element? prepare_next_step remove the first and last so the last state is not stored. --> **Good catch, it was a bug. Fixed.**; * [x] <code>_happy_breadkown</code> never used... --> **Should be fixed, performing extra checks**; * [x] evolved states It should keep the input state dims. --> **Checked all situations that came to mind and output dimensions seem to be working properly.**; * [x] Why import <code>mcsolve</code>? --> **Removed**",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1739#issuecomment-1039192650
https://github.com/qutip/qutip/pull/1739#issuecomment-1041914233:1614,Availability,error,error,1614,"st_sesolve.py**; * [x] Why not simply compare to <code>sesolve</code> ? --> **Is easier, so we swap it.**; * [x] Naming this fidelity feels wrong with the <code>1-...</code>. Also make Qobj and array conversions more efficiently with Naming this fidelity feels wrong with the <code>1-....</code>; You don't need to work go back and forth between <code>Qobj</code> and array. Also make things more efficiently with <code>1 - np.abs(psi_exact.overlap(psi_k))**2</code>. --> **Corrected.**; * [x] More efficiently <code>psi0=qutip.rand_ket(dim)</code>. --> **Corrected.**; * [x] Why compute 3 expectation values if only one is tested?; Also please use the normal <code>assert</code> instead of numpy's <code>assert_</code>. We are slowly removing them since we migrated from unitest to pytest. --> **Now all of them are checked and using <code>asset</code>**. #### <code>krylovsolve.py</code>. * [x] <code>isinstance</code> should be tested first since if it isn't, <code>psi0.isket</code> will raise an error before reaching it. It should raise a <code>TypeError</code>.; * [x] Please raise an error instead of using <code>assert</code>, since it can be suppressed.; * [x] Testing for dims instead of shape would be better. --> **Done.**; * [x] Empty progress bars can be ignored.; * [x] Improve the print at <code>particular_tlist</code> using <code>warnings.warn</code>. Properly describe the warning.; * [x] Swap illinois algorithm with a root finder from scipy. --> **Now using <code>scipy.optimize.root_finder</code>**.; * [x] <code>n_iterations</code> become <code>delta_t</code> when <code>optimizer</code> is called. It does not seems to be an integer so isn't <code>delta_t</code> a better name here? --> **Renamed to <code>delta_t</code>.**; * [x] <code>bound_function</code> seems very generic. Same with <code>optimizer</code>. --> **Renamed to <code>_lanczos_error_equation_to_optimize_delta_t</code> and <code>_optimize_lanczos_timestep_size</code>.**; * [x] numpy's array have a <code>do",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1739#issuecomment-1041914233
https://github.com/qutip/qutip/pull/1739#issuecomment-1041914233:1705,Availability,error,error,1705,"ming this fidelity feels wrong with the <code>1-...</code>. Also make Qobj and array conversions more efficiently with Naming this fidelity feels wrong with the <code>1-....</code>; You don't need to work go back and forth between <code>Qobj</code> and array. Also make things more efficiently with <code>1 - np.abs(psi_exact.overlap(psi_k))**2</code>. --> **Corrected.**; * [x] More efficiently <code>psi0=qutip.rand_ket(dim)</code>. --> **Corrected.**; * [x] Why compute 3 expectation values if only one is tested?; Also please use the normal <code>assert</code> instead of numpy's <code>assert_</code>. We are slowly removing them since we migrated from unitest to pytest. --> **Now all of them are checked and using <code>asset</code>**. #### <code>krylovsolve.py</code>. * [x] <code>isinstance</code> should be tested first since if it isn't, <code>psi0.isket</code> will raise an error before reaching it. It should raise a <code>TypeError</code>.; * [x] Please raise an error instead of using <code>assert</code>, since it can be suppressed.; * [x] Testing for dims instead of shape would be better. --> **Done.**; * [x] Empty progress bars can be ignored.; * [x] Improve the print at <code>particular_tlist</code> using <code>warnings.warn</code>. Properly describe the warning.; * [x] Swap illinois algorithm with a root finder from scipy. --> **Now using <code>scipy.optimize.root_finder</code>**.; * [x] <code>n_iterations</code> become <code>delta_t</code> when <code>optimizer</code> is called. It does not seems to be an integer so isn't <code>delta_t</code> a better name here? --> **Renamed to <code>delta_t</code>.**; * [x] <code>bound_function</code> seems very generic. Same with <code>optimizer</code>. --> **Renamed to <code>_lanczos_error_equation_to_optimize_delta_t</code> and <code>_optimize_lanczos_timestep_size</code>.**; * [x] numpy's array have a <code>dot</code> method that act the same a sparse array's one. This is not needed.; * [x] The <code>dims</code> of the outp",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1739#issuecomment-1041914233
https://github.com/qutip/qutip/pull/1739#issuecomment-1041914233:830,Energy Efficiency,efficient,efficiently,830,"### New changelog. #### <code>test_krylovsolve.py</code>. * [x] We have <code>qutip.rand_herm</code> for a random hamiltonian. --> **Changed**; * [x] Isn't <code>h_sho</code> equivalent to <code>U=qutip.rand_unitary_haar(dim) \ return U* (qutip.num(dim)+0.5)*U.dag()</code> ? --> **We can test it with that one**.; * [x] Clean imports on <code>test_krylovsolve</code>; <code>qeye</code> imported twice, <code>run_module_suite</code> never used, etc.; * [x] Header no longer used. --> **Removed.**; * [x] Why is <code>os.environ['QUTIP_GRAPHICS'] = ""NO""</code> needed? --> **Remained from the original copy from test_sesolve.py**; * [x] Why not simply compare to <code>sesolve</code> ? --> **Is easier, so we swap it.**; * [x] Naming this fidelity feels wrong with the <code>1-...</code>. Also make Qobj and array conversions more efficiently with Naming this fidelity feels wrong with the <code>1-....</code>; You don't need to work go back and forth between <code>Qobj</code> and array. Also make things more efficiently with <code>1 - np.abs(psi_exact.overlap(psi_k))**2</code>. --> **Corrected.**; * [x] More efficiently <code>psi0=qutip.rand_ket(dim)</code>. --> **Corrected.**; * [x] Why compute 3 expectation values if only one is tested?; Also please use the normal <code>assert</code> instead of numpy's <code>assert_</code>. We are slowly removing them since we migrated from unitest to pytest. --> **Now all of them are checked and using <code>asset</code>**. #### <code>krylovsolve.py</code>. * [x] <code>isinstance</code> should be tested first since if it isn't, <code>psi0.isket</code> will raise an error before reaching it. It should raise a <code>TypeError</code>.; * [x] Please raise an error instead of using <code>assert</code>, since it can be suppressed.; * [x] Testing for dims instead of shape would be better. --> **Done.**; * [x] Empty progress bars can be ignored.; * [x] Improve the print at <code>particular_tlist</code> using <code>warnings.warn</code>. Properly describe",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1739#issuecomment-1041914233
https://github.com/qutip/qutip/pull/1739#issuecomment-1041914233:1010,Energy Efficiency,efficient,efficiently,1010,"elog. #### <code>test_krylovsolve.py</code>. * [x] We have <code>qutip.rand_herm</code> for a random hamiltonian. --> **Changed**; * [x] Isn't <code>h_sho</code> equivalent to <code>U=qutip.rand_unitary_haar(dim) \ return U* (qutip.num(dim)+0.5)*U.dag()</code> ? --> **We can test it with that one**.; * [x] Clean imports on <code>test_krylovsolve</code>; <code>qeye</code> imported twice, <code>run_module_suite</code> never used, etc.; * [x] Header no longer used. --> **Removed.**; * [x] Why is <code>os.environ['QUTIP_GRAPHICS'] = ""NO""</code> needed? --> **Remained from the original copy from test_sesolve.py**; * [x] Why not simply compare to <code>sesolve</code> ? --> **Is easier, so we swap it.**; * [x] Naming this fidelity feels wrong with the <code>1-...</code>. Also make Qobj and array conversions more efficiently with Naming this fidelity feels wrong with the <code>1-....</code>; You don't need to work go back and forth between <code>Qobj</code> and array. Also make things more efficiently with <code>1 - np.abs(psi_exact.overlap(psi_k))**2</code>. --> **Corrected.**; * [x] More efficiently <code>psi0=qutip.rand_ket(dim)</code>. --> **Corrected.**; * [x] Why compute 3 expectation values if only one is tested?; Also please use the normal <code>assert</code> instead of numpy's <code>assert_</code>. We are slowly removing them since we migrated from unitest to pytest. --> **Now all of them are checked and using <code>asset</code>**. #### <code>krylovsolve.py</code>. * [x] <code>isinstance</code> should be tested first since if it isn't, <code>psi0.isket</code> will raise an error before reaching it. It should raise a <code>TypeError</code>.; * [x] Please raise an error instead of using <code>assert</code>, since it can be suppressed.; * [x] Testing for dims instead of shape would be better. --> **Done.**; * [x] Empty progress bars can be ignored.; * [x] Improve the print at <code>particular_tlist</code> using <code>warnings.warn</code>. Properly describe the warning.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1739#issuecomment-1041914233
https://github.com/qutip/qutip/pull/1739#issuecomment-1041914233:1112,Energy Efficiency,efficient,efficiently,1112,"tonian. --> **Changed**; * [x] Isn't <code>h_sho</code> equivalent to <code>U=qutip.rand_unitary_haar(dim) \ return U* (qutip.num(dim)+0.5)*U.dag()</code> ? --> **We can test it with that one**.; * [x] Clean imports on <code>test_krylovsolve</code>; <code>qeye</code> imported twice, <code>run_module_suite</code> never used, etc.; * [x] Header no longer used. --> **Removed.**; * [x] Why is <code>os.environ['QUTIP_GRAPHICS'] = ""NO""</code> needed? --> **Remained from the original copy from test_sesolve.py**; * [x] Why not simply compare to <code>sesolve</code> ? --> **Is easier, so we swap it.**; * [x] Naming this fidelity feels wrong with the <code>1-...</code>. Also make Qobj and array conversions more efficiently with Naming this fidelity feels wrong with the <code>1-....</code>; You don't need to work go back and forth between <code>Qobj</code> and array. Also make things more efficiently with <code>1 - np.abs(psi_exact.overlap(psi_k))**2</code>. --> **Corrected.**; * [x] More efficiently <code>psi0=qutip.rand_ket(dim)</code>. --> **Corrected.**; * [x] Why compute 3 expectation values if only one is tested?; Also please use the normal <code>assert</code> instead of numpy's <code>assert_</code>. We are slowly removing them since we migrated from unitest to pytest. --> **Now all of them are checked and using <code>asset</code>**. #### <code>krylovsolve.py</code>. * [x] <code>isinstance</code> should be tested first since if it isn't, <code>psi0.isket</code> will raise an error before reaching it. It should raise a <code>TypeError</code>.; * [x] Please raise an error instead of using <code>assert</code>, since it can be suppressed.; * [x] Testing for dims instead of shape would be better. --> **Done.**; * [x] Empty progress bars can be ignored.; * [x] Improve the print at <code>particular_tlist</code> using <code>warnings.warn</code>. Properly describe the warning.; * [x] Swap illinois algorithm with a root finder from scipy. --> **Now using <code>scipy.optimize.root_",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1739#issuecomment-1041914233
https://github.com/qutip/qutip/pull/1739#issuecomment-1041914233:2946,Integrability,interface,interface,2946,"ray. Also make things more efficiently with <code>1 - np.abs(psi_exact.overlap(psi_k))**2</code>. --> **Corrected.**; * [x] More efficiently <code>psi0=qutip.rand_ket(dim)</code>. --> **Corrected.**; * [x] Why compute 3 expectation values if only one is tested?; Also please use the normal <code>assert</code> instead of numpy's <code>assert_</code>. We are slowly removing them since we migrated from unitest to pytest. --> **Now all of them are checked and using <code>asset</code>**. #### <code>krylovsolve.py</code>. * [x] <code>isinstance</code> should be tested first since if it isn't, <code>psi0.isket</code> will raise an error before reaching it. It should raise a <code>TypeError</code>.; * [x] Please raise an error instead of using <code>assert</code>, since it can be suppressed.; * [x] Testing for dims instead of shape would be better. --> **Done.**; * [x] Empty progress bars can be ignored.; * [x] Improve the print at <code>particular_tlist</code> using <code>warnings.warn</code>. Properly describe the warning.; * [x] Swap illinois algorithm with a root finder from scipy. --> **Now using <code>scipy.optimize.root_finder</code>**.; * [x] <code>n_iterations</code> become <code>delta_t</code> when <code>optimizer</code> is called. It does not seems to be an integer so isn't <code>delta_t</code> a better name here? --> **Renamed to <code>delta_t</code>.**; * [x] <code>bound_function</code> seems very generic. Same with <code>optimizer</code>. --> **Renamed to <code>_lanczos_error_equation_to_optimize_delta_t</code> and <code>_optimize_lanczos_timestep_size</code>.**; * [x] numpy's array have a <code>dot</code> method that act the same a sparse array's one. This is not needed.; * [x] The <code>dims</code> of the output are not kept at <code>evolved_states = map(Qobj, evolved_states[1:-1]</code> --> **Separated into two variables. Now dimensions are also be kept.**; * [x] Why make <code>lanczos_algorithm</code> part of the public interface? --> **Mistake; corrected**",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1739#issuecomment-1041914233
https://github.com/qutip/qutip/pull/1739#issuecomment-1041914233:2834,Modifiability,variab,variables,2834,"ray. Also make things more efficiently with <code>1 - np.abs(psi_exact.overlap(psi_k))**2</code>. --> **Corrected.**; * [x] More efficiently <code>psi0=qutip.rand_ket(dim)</code>. --> **Corrected.**; * [x] Why compute 3 expectation values if only one is tested?; Also please use the normal <code>assert</code> instead of numpy's <code>assert_</code>. We are slowly removing them since we migrated from unitest to pytest. --> **Now all of them are checked and using <code>asset</code>**. #### <code>krylovsolve.py</code>. * [x] <code>isinstance</code> should be tested first since if it isn't, <code>psi0.isket</code> will raise an error before reaching it. It should raise a <code>TypeError</code>.; * [x] Please raise an error instead of using <code>assert</code>, since it can be suppressed.; * [x] Testing for dims instead of shape would be better. --> **Done.**; * [x] Empty progress bars can be ignored.; * [x] Improve the print at <code>particular_tlist</code> using <code>warnings.warn</code>. Properly describe the warning.; * [x] Swap illinois algorithm with a root finder from scipy. --> **Now using <code>scipy.optimize.root_finder</code>**.; * [x] <code>n_iterations</code> become <code>delta_t</code> when <code>optimizer</code> is called. It does not seems to be an integer so isn't <code>delta_t</code> a better name here? --> **Renamed to <code>delta_t</code>.**; * [x] <code>bound_function</code> seems very generic. Same with <code>optimizer</code>. --> **Renamed to <code>_lanczos_error_equation_to_optimize_delta_t</code> and <code>_optimize_lanczos_timestep_size</code>.**; * [x] numpy's array have a <code>dot</code> method that act the same a sparse array's one. This is not needed.; * [x] The <code>dims</code> of the output are not kept at <code>evolved_states = map(Qobj, evolved_states[1:-1]</code> --> **Separated into two variables. Now dimensions are also be kept.**; * [x] Why make <code>lanczos_algorithm</code> part of the public interface? --> **Mistake; corrected**",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1739#issuecomment-1041914233
https://github.com/qutip/qutip/pull/1739#issuecomment-1041914233:2105,Performance,optimiz,optimize,2105,"ray. Also make things more efficiently with <code>1 - np.abs(psi_exact.overlap(psi_k))**2</code>. --> **Corrected.**; * [x] More efficiently <code>psi0=qutip.rand_ket(dim)</code>. --> **Corrected.**; * [x] Why compute 3 expectation values if only one is tested?; Also please use the normal <code>assert</code> instead of numpy's <code>assert_</code>. We are slowly removing them since we migrated from unitest to pytest. --> **Now all of them are checked and using <code>asset</code>**. #### <code>krylovsolve.py</code>. * [x] <code>isinstance</code> should be tested first since if it isn't, <code>psi0.isket</code> will raise an error before reaching it. It should raise a <code>TypeError</code>.; * [x] Please raise an error instead of using <code>assert</code>, since it can be suppressed.; * [x] Testing for dims instead of shape would be better. --> **Done.**; * [x] Empty progress bars can be ignored.; * [x] Improve the print at <code>particular_tlist</code> using <code>warnings.warn</code>. Properly describe the warning.; * [x] Swap illinois algorithm with a root finder from scipy. --> **Now using <code>scipy.optimize.root_finder</code>**.; * [x] <code>n_iterations</code> become <code>delta_t</code> when <code>optimizer</code> is called. It does not seems to be an integer so isn't <code>delta_t</code> a better name here? --> **Renamed to <code>delta_t</code>.**; * [x] <code>bound_function</code> seems very generic. Same with <code>optimizer</code>. --> **Renamed to <code>_lanczos_error_equation_to_optimize_delta_t</code> and <code>_optimize_lanczos_timestep_size</code>.**; * [x] numpy's array have a <code>dot</code> method that act the same a sparse array's one. This is not needed.; * [x] The <code>dims</code> of the output are not kept at <code>evolved_states = map(Qobj, evolved_states[1:-1]</code> --> **Separated into two variables. Now dimensions are also be kept.**; * [x] Why make <code>lanczos_algorithm</code> part of the public interface? --> **Mistake; corrected**",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1739#issuecomment-1041914233
https://github.com/qutip/qutip/pull/1739#issuecomment-1041914233:2208,Performance,optimiz,optimizer,2208,"ray. Also make things more efficiently with <code>1 - np.abs(psi_exact.overlap(psi_k))**2</code>. --> **Corrected.**; * [x] More efficiently <code>psi0=qutip.rand_ket(dim)</code>. --> **Corrected.**; * [x] Why compute 3 expectation values if only one is tested?; Also please use the normal <code>assert</code> instead of numpy's <code>assert_</code>. We are slowly removing them since we migrated from unitest to pytest. --> **Now all of them are checked and using <code>asset</code>**. #### <code>krylovsolve.py</code>. * [x] <code>isinstance</code> should be tested first since if it isn't, <code>psi0.isket</code> will raise an error before reaching it. It should raise a <code>TypeError</code>.; * [x] Please raise an error instead of using <code>assert</code>, since it can be suppressed.; * [x] Testing for dims instead of shape would be better. --> **Done.**; * [x] Empty progress bars can be ignored.; * [x] Improve the print at <code>particular_tlist</code> using <code>warnings.warn</code>. Properly describe the warning.; * [x] Swap illinois algorithm with a root finder from scipy. --> **Now using <code>scipy.optimize.root_finder</code>**.; * [x] <code>n_iterations</code> become <code>delta_t</code> when <code>optimizer</code> is called. It does not seems to be an integer so isn't <code>delta_t</code> a better name here? --> **Renamed to <code>delta_t</code>.**; * [x] <code>bound_function</code> seems very generic. Same with <code>optimizer</code>. --> **Renamed to <code>_lanczos_error_equation_to_optimize_delta_t</code> and <code>_optimize_lanczos_timestep_size</code>.**; * [x] numpy's array have a <code>dot</code> method that act the same a sparse array's one. This is not needed.; * [x] The <code>dims</code> of the output are not kept at <code>evolved_states = map(Qobj, evolved_states[1:-1]</code> --> **Separated into two variables. Now dimensions are also be kept.**; * [x] Why make <code>lanczos_algorithm</code> part of the public interface? --> **Mistake; corrected**",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1739#issuecomment-1041914233
https://github.com/qutip/qutip/pull/1739#issuecomment-1041914233:2433,Performance,optimiz,optimizer,2433,"ray. Also make things more efficiently with <code>1 - np.abs(psi_exact.overlap(psi_k))**2</code>. --> **Corrected.**; * [x] More efficiently <code>psi0=qutip.rand_ket(dim)</code>. --> **Corrected.**; * [x] Why compute 3 expectation values if only one is tested?; Also please use the normal <code>assert</code> instead of numpy's <code>assert_</code>. We are slowly removing them since we migrated from unitest to pytest. --> **Now all of them are checked and using <code>asset</code>**. #### <code>krylovsolve.py</code>. * [x] <code>isinstance</code> should be tested first since if it isn't, <code>psi0.isket</code> will raise an error before reaching it. It should raise a <code>TypeError</code>.; * [x] Please raise an error instead of using <code>assert</code>, since it can be suppressed.; * [x] Testing for dims instead of shape would be better. --> **Done.**; * [x] Empty progress bars can be ignored.; * [x] Improve the print at <code>particular_tlist</code> using <code>warnings.warn</code>. Properly describe the warning.; * [x] Swap illinois algorithm with a root finder from scipy. --> **Now using <code>scipy.optimize.root_finder</code>**.; * [x] <code>n_iterations</code> become <code>delta_t</code> when <code>optimizer</code> is called. It does not seems to be an integer so isn't <code>delta_t</code> a better name here? --> **Renamed to <code>delta_t</code>.**; * [x] <code>bound_function</code> seems very generic. Same with <code>optimizer</code>. --> **Renamed to <code>_lanczos_error_equation_to_optimize_delta_t</code> and <code>_optimize_lanczos_timestep_size</code>.**; * [x] numpy's array have a <code>dot</code> method that act the same a sparse array's one. This is not needed.; * [x] The <code>dims</code> of the output are not kept at <code>evolved_states = map(Qobj, evolved_states[1:-1]</code> --> **Separated into two variables. Now dimensions are also be kept.**; * [x] Why make <code>lanczos_algorithm</code> part of the public interface? --> **Mistake; corrected**",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1739#issuecomment-1041914233
https://github.com/qutip/qutip/pull/1739#issuecomment-1041914233:289,Testability,test,test,289,"### New changelog. #### <code>test_krylovsolve.py</code>. * [x] We have <code>qutip.rand_herm</code> for a random hamiltonian. --> **Changed**; * [x] Isn't <code>h_sho</code> equivalent to <code>U=qutip.rand_unitary_haar(dim) \ return U* (qutip.num(dim)+0.5)*U.dag()</code> ? --> **We can test it with that one**.; * [x] Clean imports on <code>test_krylovsolve</code>; <code>qeye</code> imported twice, <code>run_module_suite</code> never used, etc.; * [x] Header no longer used. --> **Removed.**; * [x] Why is <code>os.environ['QUTIP_GRAPHICS'] = ""NO""</code> needed? --> **Remained from the original copy from test_sesolve.py**; * [x] Why not simply compare to <code>sesolve</code> ? --> **Is easier, so we swap it.**; * [x] Naming this fidelity feels wrong with the <code>1-...</code>. Also make Qobj and array conversions more efficiently with Naming this fidelity feels wrong with the <code>1-....</code>; You don't need to work go back and forth between <code>Qobj</code> and array. Also make things more efficiently with <code>1 - np.abs(psi_exact.overlap(psi_k))**2</code>. --> **Corrected.**; * [x] More efficiently <code>psi0=qutip.rand_ket(dim)</code>. --> **Corrected.**; * [x] Why compute 3 expectation values if only one is tested?; Also please use the normal <code>assert</code> instead of numpy's <code>assert_</code>. We are slowly removing them since we migrated from unitest to pytest. --> **Now all of them are checked and using <code>asset</code>**. #### <code>krylovsolve.py</code>. * [x] <code>isinstance</code> should be tested first since if it isn't, <code>psi0.isket</code> will raise an error before reaching it. It should raise a <code>TypeError</code>.; * [x] Please raise an error instead of using <code>assert</code>, since it can be suppressed.; * [x] Testing for dims instead of shape would be better. --> **Done.**; * [x] Empty progress bars can be ignored.; * [x] Improve the print at <code>particular_tlist</code> using <code>warnings.warn</code>. Properly describe",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1739#issuecomment-1041914233
https://github.com/qutip/qutip/pull/1739#issuecomment-1041914233:1237,Testability,test,tested,1237,"5)*U.dag()</code> ? --> **We can test it with that one**.; * [x] Clean imports on <code>test_krylovsolve</code>; <code>qeye</code> imported twice, <code>run_module_suite</code> never used, etc.; * [x] Header no longer used. --> **Removed.**; * [x] Why is <code>os.environ['QUTIP_GRAPHICS'] = ""NO""</code> needed? --> **Remained from the original copy from test_sesolve.py**; * [x] Why not simply compare to <code>sesolve</code> ? --> **Is easier, so we swap it.**; * [x] Naming this fidelity feels wrong with the <code>1-...</code>. Also make Qobj and array conversions more efficiently with Naming this fidelity feels wrong with the <code>1-....</code>; You don't need to work go back and forth between <code>Qobj</code> and array. Also make things more efficiently with <code>1 - np.abs(psi_exact.overlap(psi_k))**2</code>. --> **Corrected.**; * [x] More efficiently <code>psi0=qutip.rand_ket(dim)</code>. --> **Corrected.**; * [x] Why compute 3 expectation values if only one is tested?; Also please use the normal <code>assert</code> instead of numpy's <code>assert_</code>. We are slowly removing them since we migrated from unitest to pytest. --> **Now all of them are checked and using <code>asset</code>**. #### <code>krylovsolve.py</code>. * [x] <code>isinstance</code> should be tested first since if it isn't, <code>psi0.isket</code> will raise an error before reaching it. It should raise a <code>TypeError</code>.; * [x] Please raise an error instead of using <code>assert</code>, since it can be suppressed.; * [x] Testing for dims instead of shape would be better. --> **Done.**; * [x] Empty progress bars can be ignored.; * [x] Improve the print at <code>particular_tlist</code> using <code>warnings.warn</code>. Properly describe the warning.; * [x] Swap illinois algorithm with a root finder from scipy. --> **Now using <code>scipy.optimize.root_finder</code>**.; * [x] <code>n_iterations</code> become <code>delta_t</code> when <code>optimizer</code> is called. It does not seems to",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1739#issuecomment-1041914233
https://github.com/qutip/qutip/pull/1739#issuecomment-1041914233:1279,Testability,assert,assert,1279,"5)*U.dag()</code> ? --> **We can test it with that one**.; * [x] Clean imports on <code>test_krylovsolve</code>; <code>qeye</code> imported twice, <code>run_module_suite</code> never used, etc.; * [x] Header no longer used. --> **Removed.**; * [x] Why is <code>os.environ['QUTIP_GRAPHICS'] = ""NO""</code> needed? --> **Remained from the original copy from test_sesolve.py**; * [x] Why not simply compare to <code>sesolve</code> ? --> **Is easier, so we swap it.**; * [x] Naming this fidelity feels wrong with the <code>1-...</code>. Also make Qobj and array conversions more efficiently with Naming this fidelity feels wrong with the <code>1-....</code>; You don't need to work go back and forth between <code>Qobj</code> and array. Also make things more efficiently with <code>1 - np.abs(psi_exact.overlap(psi_k))**2</code>. --> **Corrected.**; * [x] More efficiently <code>psi0=qutip.rand_ket(dim)</code>. --> **Corrected.**; * [x] Why compute 3 expectation values if only one is tested?; Also please use the normal <code>assert</code> instead of numpy's <code>assert_</code>. We are slowly removing them since we migrated from unitest to pytest. --> **Now all of them are checked and using <code>asset</code>**. #### <code>krylovsolve.py</code>. * [x] <code>isinstance</code> should be tested first since if it isn't, <code>psi0.isket</code> will raise an error before reaching it. It should raise a <code>TypeError</code>.; * [x] Please raise an error instead of using <code>assert</code>, since it can be suppressed.; * [x] Testing for dims instead of shape would be better. --> **Done.**; * [x] Empty progress bars can be ignored.; * [x] Improve the print at <code>particular_tlist</code> using <code>warnings.warn</code>. Properly describe the warning.; * [x] Swap illinois algorithm with a root finder from scipy. --> **Now using <code>scipy.optimize.root_finder</code>**.; * [x] <code>n_iterations</code> become <code>delta_t</code> when <code>optimizer</code> is called. It does not seems to",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1739#issuecomment-1041914233
https://github.com/qutip/qutip/pull/1739#issuecomment-1041914233:1544,Testability,test,tested,1544," = ""NO""</code> needed? --> **Remained from the original copy from test_sesolve.py**; * [x] Why not simply compare to <code>sesolve</code> ? --> **Is easier, so we swap it.**; * [x] Naming this fidelity feels wrong with the <code>1-...</code>. Also make Qobj and array conversions more efficiently with Naming this fidelity feels wrong with the <code>1-....</code>; You don't need to work go back and forth between <code>Qobj</code> and array. Also make things more efficiently with <code>1 - np.abs(psi_exact.overlap(psi_k))**2</code>. --> **Corrected.**; * [x] More efficiently <code>psi0=qutip.rand_ket(dim)</code>. --> **Corrected.**; * [x] Why compute 3 expectation values if only one is tested?; Also please use the normal <code>assert</code> instead of numpy's <code>assert_</code>. We are slowly removing them since we migrated from unitest to pytest. --> **Now all of them are checked and using <code>asset</code>**. #### <code>krylovsolve.py</code>. * [x] <code>isinstance</code> should be tested first since if it isn't, <code>psi0.isket</code> will raise an error before reaching it. It should raise a <code>TypeError</code>.; * [x] Please raise an error instead of using <code>assert</code>, since it can be suppressed.; * [x] Testing for dims instead of shape would be better. --> **Done.**; * [x] Empty progress bars can be ignored.; * [x] Improve the print at <code>particular_tlist</code> using <code>warnings.warn</code>. Properly describe the warning.; * [x] Swap illinois algorithm with a root finder from scipy. --> **Now using <code>scipy.optimize.root_finder</code>**.; * [x] <code>n_iterations</code> become <code>delta_t</code> when <code>optimizer</code> is called. It does not seems to be an integer so isn't <code>delta_t</code> a better name here? --> **Renamed to <code>delta_t</code>.**; * [x] <code>bound_function</code> seems very generic. Same with <code>optimizer</code>. --> **Renamed to <code>_lanczos_error_equation_to_optimize_delta_t</code> and <code>_optimize_",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1739#issuecomment-1041914233
https://github.com/qutip/qutip/pull/1739#issuecomment-1041914233:1734,Testability,assert,assert,1734,"ming this fidelity feels wrong with the <code>1-...</code>. Also make Qobj and array conversions more efficiently with Naming this fidelity feels wrong with the <code>1-....</code>; You don't need to work go back and forth between <code>Qobj</code> and array. Also make things more efficiently with <code>1 - np.abs(psi_exact.overlap(psi_k))**2</code>. --> **Corrected.**; * [x] More efficiently <code>psi0=qutip.rand_ket(dim)</code>. --> **Corrected.**; * [x] Why compute 3 expectation values if only one is tested?; Also please use the normal <code>assert</code> instead of numpy's <code>assert_</code>. We are slowly removing them since we migrated from unitest to pytest. --> **Now all of them are checked and using <code>asset</code>**. #### <code>krylovsolve.py</code>. * [x] <code>isinstance</code> should be tested first since if it isn't, <code>psi0.isket</code> will raise an error before reaching it. It should raise a <code>TypeError</code>.; * [x] Please raise an error instead of using <code>assert</code>, since it can be suppressed.; * [x] Testing for dims instead of shape would be better. --> **Done.**; * [x] Empty progress bars can be ignored.; * [x] Improve the print at <code>particular_tlist</code> using <code>warnings.warn</code>. Properly describe the warning.; * [x] Swap illinois algorithm with a root finder from scipy. --> **Now using <code>scipy.optimize.root_finder</code>**.; * [x] <code>n_iterations</code> become <code>delta_t</code> when <code>optimizer</code> is called. It does not seems to be an integer so isn't <code>delta_t</code> a better name here? --> **Renamed to <code>delta_t</code>.**; * [x] <code>bound_function</code> seems very generic. Same with <code>optimizer</code>. --> **Renamed to <code>_lanczos_error_equation_to_optimize_delta_t</code> and <code>_optimize_lanczos_timestep_size</code>.**; * [x] numpy's array have a <code>dot</code> method that act the same a sparse array's one. This is not needed.; * [x] The <code>dims</code> of the outp",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1739#issuecomment-1041914233
https://github.com/qutip/qutip/pull/1739#issuecomment-1041914233:1784,Testability,Test,Testing,1784,"d array conversions more efficiently with Naming this fidelity feels wrong with the <code>1-....</code>; You don't need to work go back and forth between <code>Qobj</code> and array. Also make things more efficiently with <code>1 - np.abs(psi_exact.overlap(psi_k))**2</code>. --> **Corrected.**; * [x] More efficiently <code>psi0=qutip.rand_ket(dim)</code>. --> **Corrected.**; * [x] Why compute 3 expectation values if only one is tested?; Also please use the normal <code>assert</code> instead of numpy's <code>assert_</code>. We are slowly removing them since we migrated from unitest to pytest. --> **Now all of them are checked and using <code>asset</code>**. #### <code>krylovsolve.py</code>. * [x] <code>isinstance</code> should be tested first since if it isn't, <code>psi0.isket</code> will raise an error before reaching it. It should raise a <code>TypeError</code>.; * [x] Please raise an error instead of using <code>assert</code>, since it can be suppressed.; * [x] Testing for dims instead of shape would be better. --> **Done.**; * [x] Empty progress bars can be ignored.; * [x] Improve the print at <code>particular_tlist</code> using <code>warnings.warn</code>. Properly describe the warning.; * [x] Swap illinois algorithm with a root finder from scipy. --> **Now using <code>scipy.optimize.root_finder</code>**.; * [x] <code>n_iterations</code> become <code>delta_t</code> when <code>optimizer</code> is called. It does not seems to be an integer so isn't <code>delta_t</code> a better name here? --> **Renamed to <code>delta_t</code>.**; * [x] <code>bound_function</code> seems very generic. Same with <code>optimizer</code>. --> **Renamed to <code>_lanczos_error_equation_to_optimize_delta_t</code> and <code>_optimize_lanczos_timestep_size</code>.**; * [x] numpy's array have a <code>dot</code> method that act the same a sparse array's one. This is not needed.; * [x] The <code>dims</code> of the output are not kept at <code>evolved_states = map(Qobj, evolved_states[1:-1]</co",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1739#issuecomment-1041914233
https://github.com/qutip/qutip/pull/1739#issuecomment-1041914233:644,Usability,simpl,simply,644,"### New changelog. #### <code>test_krylovsolve.py</code>. * [x] We have <code>qutip.rand_herm</code> for a random hamiltonian. --> **Changed**; * [x] Isn't <code>h_sho</code> equivalent to <code>U=qutip.rand_unitary_haar(dim) \ return U* (qutip.num(dim)+0.5)*U.dag()</code> ? --> **We can test it with that one**.; * [x] Clean imports on <code>test_krylovsolve</code>; <code>qeye</code> imported twice, <code>run_module_suite</code> never used, etc.; * [x] Header no longer used. --> **Removed.**; * [x] Why is <code>os.environ['QUTIP_GRAPHICS'] = ""NO""</code> needed? --> **Remained from the original copy from test_sesolve.py**; * [x] Why not simply compare to <code>sesolve</code> ? --> **Is easier, so we swap it.**; * [x] Naming this fidelity feels wrong with the <code>1-...</code>. Also make Qobj and array conversions more efficiently with Naming this fidelity feels wrong with the <code>1-....</code>; You don't need to work go back and forth between <code>Qobj</code> and array. Also make things more efficiently with <code>1 - np.abs(psi_exact.overlap(psi_k))**2</code>. --> **Corrected.**; * [x] More efficiently <code>psi0=qutip.rand_ket(dim)</code>. --> **Corrected.**; * [x] Why compute 3 expectation values if only one is tested?; Also please use the normal <code>assert</code> instead of numpy's <code>assert_</code>. We are slowly removing them since we migrated from unitest to pytest. --> **Now all of them are checked and using <code>asset</code>**. #### <code>krylovsolve.py</code>. * [x] <code>isinstance</code> should be tested first since if it isn't, <code>psi0.isket</code> will raise an error before reaching it. It should raise a <code>TypeError</code>.; * [x] Please raise an error instead of using <code>assert</code>, since it can be suppressed.; * [x] Testing for dims instead of shape would be better. --> **Done.**; * [x] Empty progress bars can be ignored.; * [x] Improve the print at <code>particular_tlist</code> using <code>warnings.warn</code>. Properly describe",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1739#issuecomment-1041914233
https://github.com/qutip/qutip/pull/1739#issuecomment-1041914233:1862,Usability,progress bar,progress bars,1862,"feels wrong with the <code>1-....</code>; You don't need to work go back and forth between <code>Qobj</code> and array. Also make things more efficiently with <code>1 - np.abs(psi_exact.overlap(psi_k))**2</code>. --> **Corrected.**; * [x] More efficiently <code>psi0=qutip.rand_ket(dim)</code>. --> **Corrected.**; * [x] Why compute 3 expectation values if only one is tested?; Also please use the normal <code>assert</code> instead of numpy's <code>assert_</code>. We are slowly removing them since we migrated from unitest to pytest. --> **Now all of them are checked and using <code>asset</code>**. #### <code>krylovsolve.py</code>. * [x] <code>isinstance</code> should be tested first since if it isn't, <code>psi0.isket</code> will raise an error before reaching it. It should raise a <code>TypeError</code>.; * [x] Please raise an error instead of using <code>assert</code>, since it can be suppressed.; * [x] Testing for dims instead of shape would be better. --> **Done.**; * [x] Empty progress bars can be ignored.; * [x] Improve the print at <code>particular_tlist</code> using <code>warnings.warn</code>. Properly describe the warning.; * [x] Swap illinois algorithm with a root finder from scipy. --> **Now using <code>scipy.optimize.root_finder</code>**.; * [x] <code>n_iterations</code> become <code>delta_t</code> when <code>optimizer</code> is called. It does not seems to be an integer so isn't <code>delta_t</code> a better name here? --> **Renamed to <code>delta_t</code>.**; * [x] <code>bound_function</code> seems very generic. Same with <code>optimizer</code>. --> **Renamed to <code>_lanczos_error_equation_to_optimize_delta_t</code> and <code>_optimize_lanczos_timestep_size</code>.**; * [x] numpy's array have a <code>dot</code> method that act the same a sparse array's one. This is not needed.; * [x] The <code>dims</code> of the output are not kept at <code>evolved_states = map(Qobj, evolved_states[1:-1]</code> --> **Separated into two variables. Now dimensions are also ",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1739#issuecomment-1041914233
https://github.com/qutip/qutip/pull/1739#issuecomment-1043000945:455,Availability,error,error,455,"Hello @Ericgig, thanks a lot for your comments, it has been very instructive for me. I've solved most of the things, and I'm working with the tests your proposed and any other that comes to mind. . I have a question. When trying a test with <code>sesolve</code> and <code>e_ops=[lambda t, psi: qutip.expect(qutip.num(dim), psi)]</code> I get an <code>AttributeError</code> (krylovsolve seems to be working fine, however). It works if its not a list. This error comes from sesolve check of <code>op.isherm</code>:. ```python; elif isinstance(e_ops, list):; n_expt_op = len(e_ops); expt_callback = False; output.num_expect = n_expt_op; if n_expt_op == 0:; # fallback on storing states; opt.store_states = True; else:; for op in e_ops:; if op.isherm:; AttributeError: 'function' object has no attribute 'isherm'; ```. Im using qutip 4.6.3. Should I not compare to qutip solvers for this functionality?. Here is a running example:. ```python; from qutip import rand_herm, rand_ket, sesolve, expect, num, jmat, krylovsolve; import numpy as np. dim = 100; psi0 = rand_ket(dim); H = rand_herm(dim); tlist = np.linspace(0, 1, 100). e_op = lambda t, psi: expect(num(dim), psi). try:; out = sesolve(H, psi0, tlist, e_ops=e_op); except AttributeError:; print(""first one didn't work""); try:; out2 = sesolve(H, psi0, tlist, e_ops=[e_op]); except AttributeError:; print(""second one didn't work""); ```",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1739#issuecomment-1043000945
https://github.com/qutip/qutip/pull/1739#issuecomment-1043000945:142,Testability,test,tests,142,"Hello @Ericgig, thanks a lot for your comments, it has been very instructive for me. I've solved most of the things, and I'm working with the tests your proposed and any other that comes to mind. . I have a question. When trying a test with <code>sesolve</code> and <code>e_ops=[lambda t, psi: qutip.expect(qutip.num(dim), psi)]</code> I get an <code>AttributeError</code> (krylovsolve seems to be working fine, however). It works if its not a list. This error comes from sesolve check of <code>op.isherm</code>:. ```python; elif isinstance(e_ops, list):; n_expt_op = len(e_ops); expt_callback = False; output.num_expect = n_expt_op; if n_expt_op == 0:; # fallback on storing states; opt.store_states = True; else:; for op in e_ops:; if op.isherm:; AttributeError: 'function' object has no attribute 'isherm'; ```. Im using qutip 4.6.3. Should I not compare to qutip solvers for this functionality?. Here is a running example:. ```python; from qutip import rand_herm, rand_ket, sesolve, expect, num, jmat, krylovsolve; import numpy as np. dim = 100; psi0 = rand_ket(dim); H = rand_herm(dim); tlist = np.linspace(0, 1, 100). e_op = lambda t, psi: expect(num(dim), psi). try:; out = sesolve(H, psi0, tlist, e_ops=e_op); except AttributeError:; print(""first one didn't work""); try:; out2 = sesolve(H, psi0, tlist, e_ops=[e_op]); except AttributeError:; print(""second one didn't work""); ```",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1739#issuecomment-1043000945
https://github.com/qutip/qutip/pull/1739#issuecomment-1043000945:231,Testability,test,test,231,"Hello @Ericgig, thanks a lot for your comments, it has been very instructive for me. I've solved most of the things, and I'm working with the tests your proposed and any other that comes to mind. . I have a question. When trying a test with <code>sesolve</code> and <code>e_ops=[lambda t, psi: qutip.expect(qutip.num(dim), psi)]</code> I get an <code>AttributeError</code> (krylovsolve seems to be working fine, however). It works if its not a list. This error comes from sesolve check of <code>op.isherm</code>:. ```python; elif isinstance(e_ops, list):; n_expt_op = len(e_ops); expt_callback = False; output.num_expect = n_expt_op; if n_expt_op == 0:; # fallback on storing states; opt.store_states = True; else:; for op in e_ops:; if op.isherm:; AttributeError: 'function' object has no attribute 'isherm'; ```. Im using qutip 4.6.3. Should I not compare to qutip solvers for this functionality?. Here is a running example:. ```python; from qutip import rand_herm, rand_ket, sesolve, expect, num, jmat, krylovsolve; import numpy as np. dim = 100; psi0 = rand_ket(dim); H = rand_herm(dim); tlist = np.linspace(0, 1, 100). e_op = lambda t, psi: expect(num(dim), psi). try:; out = sesolve(H, psi0, tlist, e_ops=e_op); except AttributeError:; print(""first one didn't work""); try:; out2 = sesolve(H, psi0, tlist, e_ops=[e_op]); except AttributeError:; print(""second one didn't work""); ```",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1739#issuecomment-1043000945
https://github.com/qutip/qutip/pull/1739#issuecomment-1044755417:87,Performance,perform,performing,87,"Not extremely familiar with pytest parametrizations, but I've just been reading it and performing some changes. Will keep doing it with the new suggestions. I'll add a couple of tests for bad instances of inputs just in case. . I agree with the with the bound functions part. I'll try to perform as many improvements as possible today. And thanks a lot for all of these <code>sx_list[i] == x_gate(N, i)</code> code improvements.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1739#issuecomment-1044755417
https://github.com/qutip/qutip/pull/1739#issuecomment-1044755417:288,Performance,perform,perform,288,"Not extremely familiar with pytest parametrizations, but I've just been reading it and performing some changes. Will keep doing it with the new suggestions. I'll add a couple of tests for bad instances of inputs just in case. . I agree with the with the bound functions part. I'll try to perform as many improvements as possible today. And thanks a lot for all of these <code>sx_list[i] == x_gate(N, i)</code> code improvements.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1739#issuecomment-1044755417
https://github.com/qutip/qutip/pull/1739#issuecomment-1044755417:178,Testability,test,tests,178,"Not extremely familiar with pytest parametrizations, but I've just been reading it and performing some changes. Will keep doing it with the new suggestions. I'll add a couple of tests for bad instances of inputs just in case. . I agree with the with the bound functions part. I'll try to perform as many improvements as possible today. And thanks a lot for all of these <code>sx_list[i] == x_gate(N, i)</code> code improvements.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1739#issuecomment-1044755417
https://github.com/qutip/qutip/pull/1739#issuecomment-1045180425:152,Testability,test,test,152,"New changelog. * removed dummy <code>if progress_bar:</code> instances.; * small bug fix on bad tlist, now it should work perfect.; * added new general test to check all instances of types of <code>e_ops</code> and <code>tlist</code>.; * general improvements in auxiliar functions such as the use of gate operators, ket, etc.; * some tests merged. There is still work that to be done with the tidyness of the tests, but generally speaking everything should be ready to be used. I can keep working on those during the weekend.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1739#issuecomment-1045180425
https://github.com/qutip/qutip/pull/1739#issuecomment-1045180425:334,Testability,test,tests,334,"New changelog. * removed dummy <code>if progress_bar:</code> instances.; * small bug fix on bad tlist, now it should work perfect.; * added new general test to check all instances of types of <code>e_ops</code> and <code>tlist</code>.; * general improvements in auxiliar functions such as the use of gate operators, ket, etc.; * some tests merged. There is still work that to be done with the tidyness of the tests, but generally speaking everything should be ready to be used. I can keep working on those during the weekend.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1739#issuecomment-1045180425
https://github.com/qutip/qutip/pull/1739#issuecomment-1045180425:409,Testability,test,tests,409,"New changelog. * removed dummy <code>if progress_bar:</code> instances.; * small bug fix on bad tlist, now it should work perfect.; * added new general test to check all instances of types of <code>e_ops</code> and <code>tlist</code>.; * general improvements in auxiliar functions such as the use of gate operators, ket, etc.; * some tests merged. There is still work that to be done with the tidyness of the tests, but generally speaking everything should be ready to be used. I can keep working on those during the weekend.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1739#issuecomment-1045180425
https://github.com/qutip/qutip/pull/1739#issuecomment-1045249945:19,Deployability,continuous,continuous,19,Thank you for your continuous improvement. I will take a look at it next week.,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1739#issuecomment-1045249945
https://github.com/qutip/qutip/pull/1739#issuecomment-1081244591:117,Testability,test,tests,117,"It's been a while... but I am finally able to continue. I've cleand a lot, theres probably minor typing fixes in the tests, but I got rid of the general check. Now tests are mostly separated and, although a bit extensive, most things should be covered.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1739#issuecomment-1081244591
https://github.com/qutip/qutip/pull/1739#issuecomment-1081244591:164,Testability,test,tests,164,"It's been a while... but I am finally able to continue. I've cleand a lot, theres probably minor typing fixes in the tests, but I got rid of the general check. Now tests are mostly separated and, although a bit extensive, most things should be covered.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1739#issuecomment-1081244591
https://github.com/qutip/qutip/pull/1739#issuecomment-1082333157:165,Energy Efficiency,efficient,efficient,165,"@Ericgig . - docstrings should be fixed. - coveraged increased with . `e_ops = [callable, qobj]; e_ops = [callable, callable]; e_ops = [qobj, qobj]`. - added a more efficient and clear pytest parametrization; - fixed the repeated sparse test",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1739#issuecomment-1082333157
https://github.com/qutip/qutip/pull/1739#issuecomment-1082333157:237,Testability,test,test,237,"@Ericgig . - docstrings should be fixed. - coveraged increased with . `e_ops = [callable, qobj]; e_ops = [callable, callable]; e_ops = [qobj, qobj]`. - added a more efficient and clear pytest parametrization; - fixed the repeated sparse test",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1739#issuecomment-1082333157
https://github.com/qutip/qutip/pull/1739#issuecomment-1082333157:179,Usability,clear,clear,179,"@Ericgig . - docstrings should be fixed. - coveraged increased with . `e_ops = [callable, qobj]; e_ops = [callable, callable]; e_ops = [qobj, qobj]`. - added a more efficient and clear pytest parametrization; - fixed the repeated sparse test",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1739#issuecomment-1082333157
https://github.com/qutip/qutip/pull/1739#issuecomment-1083545784:18,Usability,learn,learned,18,"Thanks Eric, I've learned so much from your comments.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1739#issuecomment-1083545784
https://github.com/qutip/qutip/pull/1739#issuecomment-1084513982:61,Availability,error,error,61,"A check on macOS wasn’t successful, but I don’t see how that error message could have any relation with krylovsolve",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1739#issuecomment-1084513982
https://github.com/qutip/qutip/pull/1739#issuecomment-1084513982:67,Integrability,message,message,67,"A check on macOS wasn’t successful, but I don’t see how that error message could have any relation with krylovsolve",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1739#issuecomment-1084513982
https://github.com/qutip/qutip/issues/1740#issuecomment-992382799:13,Deployability,install,install,13,"I managed to install it on my M1, using Miniforge.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1740#issuecomment-992382799
https://github.com/qutip/qutip/issues/1740#issuecomment-992405042:52,Deployability,install,installation,52,@matteoacrossi I use miniforge but for me the numpy installation just worked. I dont think I changed anything prior to installing numpy etc.,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1740#issuecomment-992405042
https://github.com/qutip/qutip/issues/1740#issuecomment-992405042:119,Deployability,install,installing,119,@matteoacrossi I use miniforge but for me the numpy installation just worked. I dont think I changed anything prior to installing numpy etc.,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1740#issuecomment-992405042
https://github.com/qutip/qutip/issues/1740#issuecomment-1006415107:114,Deployability,release,release,114,@matteoacrossi Thank you for reporting back. Progress at least. I've flagged #1606 as a requirement for the 4.6.3 release.,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1740#issuecomment-1006415107
https://github.com/qutip/qutip/issues/1740#issuecomment-1640803583:379,Availability,error,error,379,"And for those who are not using Conda? ; ```; In file included from qutip/cy/sparse_utils.cpp:1134:; In file included from /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/c++/v1/complex:235:; /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/c++/v1/cmath:642:26: error: no template named 'numeric_limits'; bool _FloatBigger = (numeric_limits<_FloatT>::digits > numeric_limits<_IntT>::digits),; ^; /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/c++/v1/cmath:642:60: error: no template named 'numeric_limits'; bool _FloatBigger = (numeric_limits<_FloatT>::digits > numeric_limits<_IntT>::digits),; ^; /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/c++/v1/cmath:643:18: error: no template named 'numeric_limits'; int _Bits = (numeric_limits<_IntT>::digits - numeric_limits<_FloatT>::digits)>; ^; /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/c++/v1/cmath:643:50: error: no template named 'numeric_limits'; int _Bits = (numeric_limits<_IntT>::digits - numeric_limits<_FloatT>::digits)>; ^; /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/c++/v1/cmath:648:17: error: no template named 'numeric_limits'; static_assert(numeric_limits<_FloatT>::radix == 2, ""FloatT has incorrect radix"");; ^; /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/c++/v1/cmath:651:25: error: no template named 'numeric_limits'; return _FloatBigger ? numeric_limits<_IntT>::max() : (numeric_limits<_IntT>::max() >> _Bits << _Bits);; ^; /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/c++/v1/cmath:651:58: error: no template named 'numeric_limits'; return _Floa",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1740#issuecomment-1640803583
https://github.com/qutip/qutip/issues/1740#issuecomment-1640803583:641,Availability,error,error,641,"And for those who are not using Conda? ; ```; In file included from qutip/cy/sparse_utils.cpp:1134:; In file included from /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/c++/v1/complex:235:; /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/c++/v1/cmath:642:26: error: no template named 'numeric_limits'; bool _FloatBigger = (numeric_limits<_FloatT>::digits > numeric_limits<_IntT>::digits),; ^; /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/c++/v1/cmath:642:60: error: no template named 'numeric_limits'; bool _FloatBigger = (numeric_limits<_FloatT>::digits > numeric_limits<_IntT>::digits),; ^; /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/c++/v1/cmath:643:18: error: no template named 'numeric_limits'; int _Bits = (numeric_limits<_IntT>::digits - numeric_limits<_FloatT>::digits)>; ^; /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/c++/v1/cmath:643:50: error: no template named 'numeric_limits'; int _Bits = (numeric_limits<_IntT>::digits - numeric_limits<_FloatT>::digits)>; ^; /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/c++/v1/cmath:648:17: error: no template named 'numeric_limits'; static_assert(numeric_limits<_FloatT>::radix == 2, ""FloatT has incorrect radix"");; ^; /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/c++/v1/cmath:651:25: error: no template named 'numeric_limits'; return _FloatBigger ? numeric_limits<_IntT>::max() : (numeric_limits<_IntT>::max() >> _Bits << _Bits);; ^; /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/c++/v1/cmath:651:58: error: no template named 'numeric_limits'; return _Floa",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1740#issuecomment-1640803583
https://github.com/qutip/qutip/issues/1740#issuecomment-1640803583:903,Availability,error,error,903,"And for those who are not using Conda? ; ```; In file included from qutip/cy/sparse_utils.cpp:1134:; In file included from /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/c++/v1/complex:235:; /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/c++/v1/cmath:642:26: error: no template named 'numeric_limits'; bool _FloatBigger = (numeric_limits<_FloatT>::digits > numeric_limits<_IntT>::digits),; ^; /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/c++/v1/cmath:642:60: error: no template named 'numeric_limits'; bool _FloatBigger = (numeric_limits<_FloatT>::digits > numeric_limits<_IntT>::digits),; ^; /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/c++/v1/cmath:643:18: error: no template named 'numeric_limits'; int _Bits = (numeric_limits<_IntT>::digits - numeric_limits<_FloatT>::digits)>; ^; /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/c++/v1/cmath:643:50: error: no template named 'numeric_limits'; int _Bits = (numeric_limits<_IntT>::digits - numeric_limits<_FloatT>::digits)>; ^; /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/c++/v1/cmath:648:17: error: no template named 'numeric_limits'; static_assert(numeric_limits<_FloatT>::radix == 2, ""FloatT has incorrect radix"");; ^; /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/c++/v1/cmath:651:25: error: no template named 'numeric_limits'; return _FloatBigger ? numeric_limits<_IntT>::max() : (numeric_limits<_IntT>::max() >> _Bits << _Bits);; ^; /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/c++/v1/cmath:651:58: error: no template named 'numeric_limits'; return _Floa",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1740#issuecomment-1640803583
https://github.com/qutip/qutip/issues/1740#issuecomment-1640803583:1157,Availability,error,error,1157,"SX.sdk/usr/include/c++/v1/complex:235:; /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/c++/v1/cmath:642:26: error: no template named 'numeric_limits'; bool _FloatBigger = (numeric_limits<_FloatT>::digits > numeric_limits<_IntT>::digits),; ^; /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/c++/v1/cmath:642:60: error: no template named 'numeric_limits'; bool _FloatBigger = (numeric_limits<_FloatT>::digits > numeric_limits<_IntT>::digits),; ^; /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/c++/v1/cmath:643:18: error: no template named 'numeric_limits'; int _Bits = (numeric_limits<_IntT>::digits - numeric_limits<_FloatT>::digits)>; ^; /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/c++/v1/cmath:643:50: error: no template named 'numeric_limits'; int _Bits = (numeric_limits<_IntT>::digits - numeric_limits<_FloatT>::digits)>; ^; /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/c++/v1/cmath:648:17: error: no template named 'numeric_limits'; static_assert(numeric_limits<_FloatT>::radix == 2, ""FloatT has incorrect radix"");; ^; /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/c++/v1/cmath:651:25: error: no template named 'numeric_limits'; return _FloatBigger ? numeric_limits<_IntT>::max() : (numeric_limits<_IntT>::max() >> _Bits << _Bits);; ^; /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/c++/v1/cmath:651:58: error: no template named 'numeric_limits'; return _FloatBigger ? numeric_limits<_IntT>::max() : (numeric_limits<_IntT>::max() >> _Bits << _Bits);; ^; /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/c++/v1/cm",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1740#issuecomment-1640803583
https://github.com/qutip/qutip/issues/1740#issuecomment-1640803583:1411,Availability,error,error,1411,":digits > numeric_limits<_IntT>::digits),; ^; /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/c++/v1/cmath:642:60: error: no template named 'numeric_limits'; bool _FloatBigger = (numeric_limits<_FloatT>::digits > numeric_limits<_IntT>::digits),; ^; /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/c++/v1/cmath:643:18: error: no template named 'numeric_limits'; int _Bits = (numeric_limits<_IntT>::digits - numeric_limits<_FloatT>::digits)>; ^; /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/c++/v1/cmath:643:50: error: no template named 'numeric_limits'; int _Bits = (numeric_limits<_IntT>::digits - numeric_limits<_FloatT>::digits)>; ^; /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/c++/v1/cmath:648:17: error: no template named 'numeric_limits'; static_assert(numeric_limits<_FloatT>::radix == 2, ""FloatT has incorrect radix"");; ^; /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/c++/v1/cmath:651:25: error: no template named 'numeric_limits'; return _FloatBigger ? numeric_limits<_IntT>::max() : (numeric_limits<_IntT>::max() >> _Bits << _Bits);; ^; /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/c++/v1/cmath:651:58: error: no template named 'numeric_limits'; return _FloatBigger ? numeric_limits<_IntT>::max() : (numeric_limits<_IntT>::max() >> _Bits << _Bits);; ^; /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/c++/v1/cmath:661:16: error: no template named 'numeric_limits'; using _Lim = numeric_limits<_IntT>;; ^; /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/c++/v1/cmath:664:12: error: use of undeclared identif",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1740#issuecomment-1640803583
https://github.com/qutip/qutip/issues/1740#issuecomment-1640803583:1668,Availability,error,error,1668,"ts > numeric_limits<_IntT>::digits),; ^; /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/c++/v1/cmath:643:18: error: no template named 'numeric_limits'; int _Bits = (numeric_limits<_IntT>::digits - numeric_limits<_FloatT>::digits)>; ^; /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/c++/v1/cmath:643:50: error: no template named 'numeric_limits'; int _Bits = (numeric_limits<_IntT>::digits - numeric_limits<_FloatT>::digits)>; ^; /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/c++/v1/cmath:648:17: error: no template named 'numeric_limits'; static_assert(numeric_limits<_FloatT>::radix == 2, ""FloatT has incorrect radix"");; ^; /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/c++/v1/cmath:651:25: error: no template named 'numeric_limits'; return _FloatBigger ? numeric_limits<_IntT>::max() : (numeric_limits<_IntT>::max() >> _Bits << _Bits);; ^; /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/c++/v1/cmath:651:58: error: no template named 'numeric_limits'; return _FloatBigger ? numeric_limits<_IntT>::max() : (numeric_limits<_IntT>::max() >> _Bits << _Bits);; ^; /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/c++/v1/cmath:661:16: error: no template named 'numeric_limits'; using _Lim = numeric_limits<_IntT>;; ^; /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/c++/v1/cmath:664:12: error: use of undeclared identifier '_Lim'; return _Lim::max();; ^; /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/c++/v1/cmath:665:21: error: use of undeclared identifier '_Lim'; } else if (__r <= _Lim::lowest()) {; ^; /Applications/Xcode.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1740#issuecomment-1640803583
https://github.com/qutip/qutip/issues/1740#issuecomment-1640803583:1946,Availability,error,error,1946,"T>::digits)>; ^; /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/c++/v1/cmath:643:50: error: no template named 'numeric_limits'; int _Bits = (numeric_limits<_IntT>::digits - numeric_limits<_FloatT>::digits)>; ^; /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/c++/v1/cmath:648:17: error: no template named 'numeric_limits'; static_assert(numeric_limits<_FloatT>::radix == 2, ""FloatT has incorrect radix"");; ^; /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/c++/v1/cmath:651:25: error: no template named 'numeric_limits'; return _FloatBigger ? numeric_limits<_IntT>::max() : (numeric_limits<_IntT>::max() >> _Bits << _Bits);; ^; /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/c++/v1/cmath:651:58: error: no template named 'numeric_limits'; return _FloatBigger ? numeric_limits<_IntT>::max() : (numeric_limits<_IntT>::max() >> _Bits << _Bits);; ^; /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/c++/v1/cmath:661:16: error: no template named 'numeric_limits'; using _Lim = numeric_limits<_IntT>;; ^; /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/c++/v1/cmath:664:12: error: use of undeclared identifier '_Lim'; return _Lim::max();; ^; /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/c++/v1/cmath:665:21: error: use of undeclared identifier '_Lim'; } else if (__r <= _Lim::lowest()) {; ^; /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/c++/v1/cmath:666:12: error: use of undeclared identifier '_Lim'; return _Lim::min();; ^; 11 errors generated.; error: command '/usr/bin/clang' failed with exit code 1; [end of output]; ; note",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1740#issuecomment-1640803583
https://github.com/qutip/qutip/issues/1740#issuecomment-1640803583:2224,Availability,error,error,2224,"ts<_FloatT>::digits)>; ^; /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/c++/v1/cmath:648:17: error: no template named 'numeric_limits'; static_assert(numeric_limits<_FloatT>::radix == 2, ""FloatT has incorrect radix"");; ^; /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/c++/v1/cmath:651:25: error: no template named 'numeric_limits'; return _FloatBigger ? numeric_limits<_IntT>::max() : (numeric_limits<_IntT>::max() >> _Bits << _Bits);; ^; /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/c++/v1/cmath:651:58: error: no template named 'numeric_limits'; return _FloatBigger ? numeric_limits<_IntT>::max() : (numeric_limits<_IntT>::max() >> _Bits << _Bits);; ^; /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/c++/v1/cmath:661:16: error: no template named 'numeric_limits'; using _Lim = numeric_limits<_IntT>;; ^; /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/c++/v1/cmath:664:12: error: use of undeclared identifier '_Lim'; return _Lim::max();; ^; /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/c++/v1/cmath:665:21: error: use of undeclared identifier '_Lim'; } else if (__r <= _Lim::lowest()) {; ^; /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/c++/v1/cmath:666:12: error: use of undeclared identifier '_Lim'; return _Lim::min();; ^; 11 errors generated.; error: command '/usr/bin/clang' failed with exit code 1; [end of output]; ; note: This error originates from a subprocess, and is likely not a problem with pip.; ERROR: Failed building wheel for qutip; Failed to build qutip; ERROR: Could not build wheels for qutip, which is required to install pyproject.toml-based projects",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1740#issuecomment-1640803583
https://github.com/qutip/qutip/issues/1740#issuecomment-1640803583:2435,Availability,error,error,2435,"digits)>; ^; /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/c++/v1/cmath:648:17: error: no template named 'numeric_limits'; static_assert(numeric_limits<_FloatT>::radix == 2, ""FloatT has incorrect radix"");; ^; /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/c++/v1/cmath:651:25: error: no template named 'numeric_limits'; return _FloatBigger ? numeric_limits<_IntT>::max() : (numeric_limits<_IntT>::max() >> _Bits << _Bits);; ^; /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/c++/v1/cmath:651:58: error: no template named 'numeric_limits'; return _FloatBigger ? numeric_limits<_IntT>::max() : (numeric_limits<_IntT>::max() >> _Bits << _Bits);; ^; /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/c++/v1/cmath:661:16: error: no template named 'numeric_limits'; using _Lim = numeric_limits<_IntT>;; ^; /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/c++/v1/cmath:664:12: error: use of undeclared identifier '_Lim'; return _Lim::max();; ^; /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/c++/v1/cmath:665:21: error: use of undeclared identifier '_Lim'; } else if (__r <= _Lim::lowest()) {; ^; /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/c++/v1/cmath:666:12: error: use of undeclared identifier '_Lim'; return _Lim::min();; ^; 11 errors generated.; error: command '/usr/bin/clang' failed with exit code 1; [end of output]; ; note: This error originates from a subprocess, and is likely not a problem with pip.; ERROR: Failed building wheel for qutip; Failed to build qutip; ERROR: Could not build wheels for qutip, which is required to install pyproject.toml-based projects. ```; Thanks",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1740#issuecomment-1640803583
https://github.com/qutip/qutip/issues/1740#issuecomment-1640803583:2631,Availability,error,error,2631,"digits)>; ^; /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/c++/v1/cmath:648:17: error: no template named 'numeric_limits'; static_assert(numeric_limits<_FloatT>::radix == 2, ""FloatT has incorrect radix"");; ^; /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/c++/v1/cmath:651:25: error: no template named 'numeric_limits'; return _FloatBigger ? numeric_limits<_IntT>::max() : (numeric_limits<_IntT>::max() >> _Bits << _Bits);; ^; /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/c++/v1/cmath:651:58: error: no template named 'numeric_limits'; return _FloatBigger ? numeric_limits<_IntT>::max() : (numeric_limits<_IntT>::max() >> _Bits << _Bits);; ^; /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/c++/v1/cmath:661:16: error: no template named 'numeric_limits'; using _Lim = numeric_limits<_IntT>;; ^; /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/c++/v1/cmath:664:12: error: use of undeclared identifier '_Lim'; return _Lim::max();; ^; /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/c++/v1/cmath:665:21: error: use of undeclared identifier '_Lim'; } else if (__r <= _Lim::lowest()) {; ^; /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/c++/v1/cmath:666:12: error: use of undeclared identifier '_Lim'; return _Lim::min();; ^; 11 errors generated.; error: command '/usr/bin/clang' failed with exit code 1; [end of output]; ; note: This error originates from a subprocess, and is likely not a problem with pip.; ERROR: Failed building wheel for qutip; Failed to build qutip; ERROR: Could not build wheels for qutip, which is required to install pyproject.toml-based projects. ```; Thanks",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1740#issuecomment-1640803583
https://github.com/qutip/qutip/issues/1740#issuecomment-1640803583:2843,Availability,error,error,2843,"digits)>; ^; /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/c++/v1/cmath:648:17: error: no template named 'numeric_limits'; static_assert(numeric_limits<_FloatT>::radix == 2, ""FloatT has incorrect radix"");; ^; /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/c++/v1/cmath:651:25: error: no template named 'numeric_limits'; return _FloatBigger ? numeric_limits<_IntT>::max() : (numeric_limits<_IntT>::max() >> _Bits << _Bits);; ^; /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/c++/v1/cmath:651:58: error: no template named 'numeric_limits'; return _FloatBigger ? numeric_limits<_IntT>::max() : (numeric_limits<_IntT>::max() >> _Bits << _Bits);; ^; /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/c++/v1/cmath:661:16: error: no template named 'numeric_limits'; using _Lim = numeric_limits<_IntT>;; ^; /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/c++/v1/cmath:664:12: error: use of undeclared identifier '_Lim'; return _Lim::max();; ^; /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/c++/v1/cmath:665:21: error: use of undeclared identifier '_Lim'; } else if (__r <= _Lim::lowest()) {; ^; /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/c++/v1/cmath:666:12: error: use of undeclared identifier '_Lim'; return _Lim::min();; ^; 11 errors generated.; error: command '/usr/bin/clang' failed with exit code 1; [end of output]; ; note: This error originates from a subprocess, and is likely not a problem with pip.; ERROR: Failed building wheel for qutip; Failed to build qutip; ERROR: Could not build wheels for qutip, which is required to install pyproject.toml-based projects. ```; Thanks",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1740#issuecomment-1640803583
https://github.com/qutip/qutip/issues/1740#issuecomment-1640803583:2914,Availability,error,errors,2914,"digits)>; ^; /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/c++/v1/cmath:648:17: error: no template named 'numeric_limits'; static_assert(numeric_limits<_FloatT>::radix == 2, ""FloatT has incorrect radix"");; ^; /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/c++/v1/cmath:651:25: error: no template named 'numeric_limits'; return _FloatBigger ? numeric_limits<_IntT>::max() : (numeric_limits<_IntT>::max() >> _Bits << _Bits);; ^; /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/c++/v1/cmath:651:58: error: no template named 'numeric_limits'; return _FloatBigger ? numeric_limits<_IntT>::max() : (numeric_limits<_IntT>::max() >> _Bits << _Bits);; ^; /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/c++/v1/cmath:661:16: error: no template named 'numeric_limits'; using _Lim = numeric_limits<_IntT>;; ^; /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/c++/v1/cmath:664:12: error: use of undeclared identifier '_Lim'; return _Lim::max();; ^; /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/c++/v1/cmath:665:21: error: use of undeclared identifier '_Lim'; } else if (__r <= _Lim::lowest()) {; ^; /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/c++/v1/cmath:666:12: error: use of undeclared identifier '_Lim'; return _Lim::min();; ^; 11 errors generated.; error: command '/usr/bin/clang' failed with exit code 1; [end of output]; ; note: This error originates from a subprocess, and is likely not a problem with pip.; ERROR: Failed building wheel for qutip; Failed to build qutip; ERROR: Could not build wheels for qutip, which is required to install pyproject.toml-based projects. ```; Thanks",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1740#issuecomment-1640803583
https://github.com/qutip/qutip/issues/1740#issuecomment-1640803583:2933,Availability,error,error,2933,"digits)>; ^; /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/c++/v1/cmath:648:17: error: no template named 'numeric_limits'; static_assert(numeric_limits<_FloatT>::radix == 2, ""FloatT has incorrect radix"");; ^; /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/c++/v1/cmath:651:25: error: no template named 'numeric_limits'; return _FloatBigger ? numeric_limits<_IntT>::max() : (numeric_limits<_IntT>::max() >> _Bits << _Bits);; ^; /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/c++/v1/cmath:651:58: error: no template named 'numeric_limits'; return _FloatBigger ? numeric_limits<_IntT>::max() : (numeric_limits<_IntT>::max() >> _Bits << _Bits);; ^; /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/c++/v1/cmath:661:16: error: no template named 'numeric_limits'; using _Lim = numeric_limits<_IntT>;; ^; /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/c++/v1/cmath:664:12: error: use of undeclared identifier '_Lim'; return _Lim::max();; ^; /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/c++/v1/cmath:665:21: error: use of undeclared identifier '_Lim'; } else if (__r <= _Lim::lowest()) {; ^; /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/c++/v1/cmath:666:12: error: use of undeclared identifier '_Lim'; return _Lim::min();; ^; 11 errors generated.; error: command '/usr/bin/clang' failed with exit code 1; [end of output]; ; note: This error originates from a subprocess, and is likely not a problem with pip.; ERROR: Failed building wheel for qutip; Failed to build qutip; ERROR: Could not build wheels for qutip, which is required to install pyproject.toml-based projects. ```; Thanks",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1740#issuecomment-1640803583
https://github.com/qutip/qutip/issues/1740#issuecomment-1640803583:3020,Availability,error,error,3020,"digits)>; ^; /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/c++/v1/cmath:648:17: error: no template named 'numeric_limits'; static_assert(numeric_limits<_FloatT>::radix == 2, ""FloatT has incorrect radix"");; ^; /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/c++/v1/cmath:651:25: error: no template named 'numeric_limits'; return _FloatBigger ? numeric_limits<_IntT>::max() : (numeric_limits<_IntT>::max() >> _Bits << _Bits);; ^; /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/c++/v1/cmath:651:58: error: no template named 'numeric_limits'; return _FloatBigger ? numeric_limits<_IntT>::max() : (numeric_limits<_IntT>::max() >> _Bits << _Bits);; ^; /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/c++/v1/cmath:661:16: error: no template named 'numeric_limits'; using _Lim = numeric_limits<_IntT>;; ^; /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/c++/v1/cmath:664:12: error: use of undeclared identifier '_Lim'; return _Lim::max();; ^; /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/c++/v1/cmath:665:21: error: use of undeclared identifier '_Lim'; } else if (__r <= _Lim::lowest()) {; ^; /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/c++/v1/cmath:666:12: error: use of undeclared identifier '_Lim'; return _Lim::min();; ^; 11 errors generated.; error: command '/usr/bin/clang' failed with exit code 1; [end of output]; ; note: This error originates from a subprocess, and is likely not a problem with pip.; ERROR: Failed building wheel for qutip; Failed to build qutip; ERROR: Could not build wheels for qutip, which is required to install pyproject.toml-based projects. ```; Thanks",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1740#issuecomment-1640803583
https://github.com/qutip/qutip/issues/1740#issuecomment-1640803583:3095,Availability,ERROR,ERROR,3095,"digits)>; ^; /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/c++/v1/cmath:648:17: error: no template named 'numeric_limits'; static_assert(numeric_limits<_FloatT>::radix == 2, ""FloatT has incorrect radix"");; ^; /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/c++/v1/cmath:651:25: error: no template named 'numeric_limits'; return _FloatBigger ? numeric_limits<_IntT>::max() : (numeric_limits<_IntT>::max() >> _Bits << _Bits);; ^; /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/c++/v1/cmath:651:58: error: no template named 'numeric_limits'; return _FloatBigger ? numeric_limits<_IntT>::max() : (numeric_limits<_IntT>::max() >> _Bits << _Bits);; ^; /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/c++/v1/cmath:661:16: error: no template named 'numeric_limits'; using _Lim = numeric_limits<_IntT>;; ^; /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/c++/v1/cmath:664:12: error: use of undeclared identifier '_Lim'; return _Lim::max();; ^; /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/c++/v1/cmath:665:21: error: use of undeclared identifier '_Lim'; } else if (__r <= _Lim::lowest()) {; ^; /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/c++/v1/cmath:666:12: error: use of undeclared identifier '_Lim'; return _Lim::min();; ^; 11 errors generated.; error: command '/usr/bin/clang' failed with exit code 1; [end of output]; ; note: This error originates from a subprocess, and is likely not a problem with pip.; ERROR: Failed building wheel for qutip; Failed to build qutip; ERROR: Could not build wheels for qutip, which is required to install pyproject.toml-based projects. ```; Thanks",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1740#issuecomment-1640803583
https://github.com/qutip/qutip/issues/1740#issuecomment-1640803583:3158,Availability,ERROR,ERROR,3158,"digits)>; ^; /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/c++/v1/cmath:648:17: error: no template named 'numeric_limits'; static_assert(numeric_limits<_FloatT>::radix == 2, ""FloatT has incorrect radix"");; ^; /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/c++/v1/cmath:651:25: error: no template named 'numeric_limits'; return _FloatBigger ? numeric_limits<_IntT>::max() : (numeric_limits<_IntT>::max() >> _Bits << _Bits);; ^; /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/c++/v1/cmath:651:58: error: no template named 'numeric_limits'; return _FloatBigger ? numeric_limits<_IntT>::max() : (numeric_limits<_IntT>::max() >> _Bits << _Bits);; ^; /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/c++/v1/cmath:661:16: error: no template named 'numeric_limits'; using _Lim = numeric_limits<_IntT>;; ^; /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/c++/v1/cmath:664:12: error: use of undeclared identifier '_Lim'; return _Lim::max();; ^; /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/c++/v1/cmath:665:21: error: use of undeclared identifier '_Lim'; } else if (__r <= _Lim::lowest()) {; ^; /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/c++/v1/cmath:666:12: error: use of undeclared identifier '_Lim'; return _Lim::min();; ^; 11 errors generated.; error: command '/usr/bin/clang' failed with exit code 1; [end of output]; ; note: This error originates from a subprocess, and is likely not a problem with pip.; ERROR: Failed building wheel for qutip; Failed to build qutip; ERROR: Could not build wheels for qutip, which is required to install pyproject.toml-based projects. ```; Thanks",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1740#issuecomment-1640803583
https://github.com/qutip/qutip/issues/1740#issuecomment-1640803583:3220,Deployability,install,install,3220,"digits)>; ^; /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/c++/v1/cmath:648:17: error: no template named 'numeric_limits'; static_assert(numeric_limits<_FloatT>::radix == 2, ""FloatT has incorrect radix"");; ^; /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/c++/v1/cmath:651:25: error: no template named 'numeric_limits'; return _FloatBigger ? numeric_limits<_IntT>::max() : (numeric_limits<_IntT>::max() >> _Bits << _Bits);; ^; /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/c++/v1/cmath:651:58: error: no template named 'numeric_limits'; return _FloatBigger ? numeric_limits<_IntT>::max() : (numeric_limits<_IntT>::max() >> _Bits << _Bits);; ^; /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/c++/v1/cmath:661:16: error: no template named 'numeric_limits'; using _Lim = numeric_limits<_IntT>;; ^; /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/c++/v1/cmath:664:12: error: use of undeclared identifier '_Lim'; return _Lim::max();; ^; /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/c++/v1/cmath:665:21: error: use of undeclared identifier '_Lim'; } else if (__r <= _Lim::lowest()) {; ^; /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/c++/v1/cmath:666:12: error: use of undeclared identifier '_Lim'; return _Lim::min();; ^; 11 errors generated.; error: command '/usr/bin/clang' failed with exit code 1; [end of output]; ; note: This error originates from a subprocess, and is likely not a problem with pip.; ERROR: Failed building wheel for qutip; Failed to build qutip; ERROR: Could not build wheels for qutip, which is required to install pyproject.toml-based projects. ```; Thanks",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1740#issuecomment-1640803583
https://github.com/qutip/qutip/pull/1741#issuecomment-993797670:222,Availability,error,error-if-offset-nonzero-is-used-with-meth-operator-in-coherent,222,[![Coverage Status](https://coveralls.io/builds/44999770/badge)](https://coveralls.io/builds/44999770). Coverage increased (+0.02%) to 68.347% when pulling **c5e0aeeef46ed1f4074e0698634ebd0a656087d2 on hodgestar:fix/raise-error-if-offset-nonzero-is-used-with-meth-operator-in-coherent** into **9b859e82b89d3ccec39603ed3bb70c4af819e4bc on qutip:master**.,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1741#issuecomment-993797670
https://github.com/qutip/qutip/issues/1742#issuecomment-1001477467:243,Modifiability,plugin,plugin,243,"I would rather have the styling checks part of CI than pre-commit. Pre-commit hooks are a nice way to automate repetitive tasks, but for coding conventions, each developer tends to have their own setup (e.g. I would run black or pyflakes as a plugin in my editor, so that I get immediate feedback or fixes long before making a commit). Pre-commit hooks are also a poor choice for checking that coding style is followed, because developers will have different operating systems, difference versions of Python, black, pyflakes, etc, etc and so there are certain to be differences between what is considered correct by the scripts run by different developers. Finally, there are many valid reasons to commit broken code into branches, and I would not want to prevent that.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1742#issuecomment-1001477467
https://github.com/qutip/qutip/issues/1742#issuecomment-1001477467:288,Usability,feedback,feedback,288,"I would rather have the styling checks part of CI than pre-commit. Pre-commit hooks are a nice way to automate repetitive tasks, but for coding conventions, each developer tends to have their own setup (e.g. I would run black or pyflakes as a plugin in my editor, so that I get immediate feedback or fixes long before making a commit). Pre-commit hooks are also a poor choice for checking that coding style is followed, because developers will have different operating systems, difference versions of Python, black, pyflakes, etc, etc and so there are certain to be differences between what is considered correct by the scripts run by different developers. Finally, there are many valid reasons to commit broken code into branches, and I would not want to prevent that.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1742#issuecomment-1001477467
https://github.com/qutip/qutip/pull/1747#issuecomment-1002526242:232,Deployability,install,install,232,"@jakelishman @Ericgig Reviews would be very much appreciated since this is a somewhat complicated problem space and affects everyone. I am trying to decide whether to add some documentation explaining that one might want to do `pip install -e . --no-build-isolation` when developing locally, but our documentation still recommends `python setup.py develop` and I don't want to add a complicated explanation to the docs just yet (I'd rather see what people get stuck on in practice first) because this part of pip has only stabilized fairly recently (and maybe not even yet).",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1747#issuecomment-1002526242
https://github.com/qutip/qutip/pull/1747#issuecomment-1005593804:66,Testability,test,test,66,"@jakelishman @Ericgig I'm going to merge this so that I can run a test build easily and so that people who were experiencing issues on 3.10 can try it out easily. If you'd like changes, I can address them in a follow up PR. Hope you are both enjoying your holidays!",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1747#issuecomment-1005593804
https://github.com/qutip/qutip/pull/1747#issuecomment-1005718437:30,Availability,error,error,30,I've created #1751 to fix the error in the cibuildwheel overrides syntax and made it a qutip branch so that I can run the build CI before merging.,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1747#issuecomment-1005718437
https://github.com/qutip/qutip/pull/1748#issuecomment-1003775123:226,Modifiability,refactor,refactor-process-fidelity,226,[![Coverage Status](https://coveralls.io/builds/45388930/badge)](https://coveralls.io/builds/45388930). Coverage increased (+0.007%) to 65.527% when pulling **6ec2612fbcd8f832dcba64ea5dbc6adeff8bd480 on fhopfmueller:dev.major-refactor-process-fidelity** into **6287bd37f3446110af82e2a038fdb3bd336268db on qutip:dev.major**.,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1748#issuecomment-1003775123
https://github.com/qutip/qutip/issues/1750#issuecomment-1005689691:160,Deployability,install,install,160,"Hello! Thank you for reporting the bug. This looks like it is the same bug posted to the mailing list, so let's combine discussion here. Running the same conda install and Python commands works for me, so we will need to dig a bit more. If you're using MKL and numpy 1.21.X it's possible that you're encountering this numpy bug https://github.com/numpy/numpy/issues/20356. It only occurs on certain Intel CPUs (those with AVX512 CPU extensions). I believe it is fixed in numpy 1.22, but I haven't had a chance to confirm that yet. If so, a quick solution is to try ""conda install nomkl qutip"" and confirm that that installs a no-MKL Blas and that the tests pass afterwards. If not, could you post the output of `qutip.abut()` in a comment here and I can try make some more suggestions.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1750#issuecomment-1005689691
https://github.com/qutip/qutip/issues/1750#issuecomment-1005689691:572,Deployability,install,install,572,"Hello! Thank you for reporting the bug. This looks like it is the same bug posted to the mailing list, so let's combine discussion here. Running the same conda install and Python commands works for me, so we will need to dig a bit more. If you're using MKL and numpy 1.21.X it's possible that you're encountering this numpy bug https://github.com/numpy/numpy/issues/20356. It only occurs on certain Intel CPUs (those with AVX512 CPU extensions). I believe it is fixed in numpy 1.22, but I haven't had a chance to confirm that yet. If so, a quick solution is to try ""conda install nomkl qutip"" and confirm that that installs a no-MKL Blas and that the tests pass afterwards. If not, could you post the output of `qutip.abut()` in a comment here and I can try make some more suggestions.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1750#issuecomment-1005689691
https://github.com/qutip/qutip/issues/1750#issuecomment-1005689691:615,Deployability,install,installs,615,"Hello! Thank you for reporting the bug. This looks like it is the same bug posted to the mailing list, so let's combine discussion here. Running the same conda install and Python commands works for me, so we will need to dig a bit more. If you're using MKL and numpy 1.21.X it's possible that you're encountering this numpy bug https://github.com/numpy/numpy/issues/20356. It only occurs on certain Intel CPUs (those with AVX512 CPU extensions). I believe it is fixed in numpy 1.22, but I haven't had a chance to confirm that yet. If so, a quick solution is to try ""conda install nomkl qutip"" and confirm that that installs a no-MKL Blas and that the tests pass afterwards. If not, could you post the output of `qutip.abut()` in a comment here and I can try make some more suggestions.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1750#issuecomment-1005689691
https://github.com/qutip/qutip/issues/1750#issuecomment-1005689691:651,Testability,test,tests,651,"Hello! Thank you for reporting the bug. This looks like it is the same bug posted to the mailing list, so let's combine discussion here. Running the same conda install and Python commands works for me, so we will need to dig a bit more. If you're using MKL and numpy 1.21.X it's possible that you're encountering this numpy bug https://github.com/numpy/numpy/issues/20356. It only occurs on certain Intel CPUs (those with AVX512 CPU extensions). I believe it is fixed in numpy 1.22, but I haven't had a chance to confirm that yet. If so, a quick solution is to try ""conda install nomkl qutip"" and confirm that that installs a no-MKL Blas and that the tests pass afterwards. If not, could you post the output of `qutip.abut()` in a comment here and I can try make some more suggestions.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1750#issuecomment-1005689691
https://github.com/qutip/qutip/issues/1750#issuecomment-1005729943:27,Deployability,install,install,27,Hi! I tried running `conda install nomkl qutip` and then ran the test. I can confirm it solved the issue. I doubt it is a good permanent solution though. Would you recommend reverting back to MKL and upgrading numpy to 1.22?,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1750#issuecomment-1005729943
https://github.com/qutip/qutip/issues/1750#issuecomment-1005729943:65,Testability,test,test,65,Hi! I tried running `conda install nomkl qutip` and then ran the test. I can confirm it solved the issue. I doubt it is a good permanent solution though. Would you recommend reverting back to MKL and upgrading numpy to 1.22?,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1750#issuecomment-1005729943
https://github.com/qutip/qutip/issues/1750#issuecomment-1005733376:148,Testability,test,tests,148,"Running without MKL will be a bit slower in many cases but should otherwise work fine. If you can try upgrading to numpy 1.22 and checking that the tests pass for you, that would be great!",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1750#issuecomment-1005733376
https://github.com/qutip/qutip/issues/1750#issuecomment-1005741549:1057,Deployability,Install,Installed,1057,"Thank you for looking into this issue. I tried doing as instructed but it doesn't seem to be able to execute the command succesfully. This has been running for 30min now:; ![imagen](https://user-images.githubusercontent.com/85493516/148235603-f69bf0f7-6f69-4eac-8479-863ab7aa3872.png). Below here my qutip.about(). ```; QuTiP: Quantum Toolbox in Python; ================================; Copyright (c) QuTiP team 2011 and later.; Current admin team: Alexander Pitchford, Nathan Shammah, Shahnawaz Ahmed, Neill Lambert, Eric Giguère, Boxi Li, Jake Lishman and Simon Cross.; Board members: Daniel Burgarth, Robert Johansson, Anton F. Kockum, Franco Nori and Will Zeng.; Original developers: R. J. Johansson & P. D. Nation.; Previous lead developers: Chris Granade & A. Grimsmo.; Currently developed through wide collaboration. See https://github.com/qutip for details. QuTiP Version: 4.6.2; Numpy Version: 1.20.3; Scipy Version: 1.7.1; Cython Version: 0.29.24; Matplotlib Version: 3.4.3; Python Version: 3.9.7; Number of CPUs: 2; BLAS Info: INTEL MKL; OPENMP Installed: False; INTEL MKL Ext: False; Platform Info: Windows (AMD64); Installation path: C:\Users\Stela Kusar\anaconda3\lib\site-packages\qutip; ```",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1750#issuecomment-1005741549
https://github.com/qutip/qutip/issues/1750#issuecomment-1005741549:1129,Deployability,Install,Installation,1129,"Thank you for looking into this issue. I tried doing as instructed but it doesn't seem to be able to execute the command succesfully. This has been running for 30min now:; ![imagen](https://user-images.githubusercontent.com/85493516/148235603-f69bf0f7-6f69-4eac-8479-863ab7aa3872.png). Below here my qutip.about(). ```; QuTiP: Quantum Toolbox in Python; ================================; Copyright (c) QuTiP team 2011 and later.; Current admin team: Alexander Pitchford, Nathan Shammah, Shahnawaz Ahmed, Neill Lambert, Eric Giguère, Boxi Li, Jake Lishman and Simon Cross.; Board members: Daniel Burgarth, Robert Johansson, Anton F. Kockum, Franco Nori and Will Zeng.; Original developers: R. J. Johansson & P. D. Nation.; Previous lead developers: Chris Granade & A. Grimsmo.; Currently developed through wide collaboration. See https://github.com/qutip for details. QuTiP Version: 4.6.2; Numpy Version: 1.20.3; Scipy Version: 1.7.1; Cython Version: 0.29.24; Matplotlib Version: 3.4.3; Python Version: 3.9.7; Number of CPUs: 2; BLAS Info: INTEL MKL; OPENMP Installed: False; INTEL MKL Ext: False; Platform Info: Windows (AMD64); Installation path: C:\Users\Stela Kusar\anaconda3\lib\site-packages\qutip; ```",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1750#issuecomment-1005741549
https://github.com/qutip/qutip/issues/1750#issuecomment-1005876725:103,Availability,error,error,103,"I reactivated MKL, updated numpy to 1.22.0 and when running `import qutip.testing` I get the following error:. `Traceback (most recent call last):; File ""<stdin>"", line 1, in <module>; File ""C:\ProgramData\Miniconda3\lib\site-packages\qutip\__init__.py"", line 73, in <module>; (_blas_info() == ""OPENBLAS"" and platform.system() == 'Darwin'); File ""C:\ProgramData\Miniconda3\lib\site-packages\qutip\utilities.py"", line 430, in _blas_info; blas_info = config.blas_opt_info; AttributeError: module 'numpy.__config__' has no attribute 'blas_opt_info'`. Then as I wanted to provide my config I typed `import qutip` but it yielded the exact same error so I reverted it back to 1.20.3. QuTiP Version: 4.6.2; Numpy Version: 1.20.3; Scipy Version: 1.7.1; Cython Version: 0.29.25; Matplotlib Version: 3.5.0; Python Version: 3.9.5; Number of CPUs: 4; BLAS Info: OPENBLAS; OPENMP Installed: False; INTEL MKL Ext: False; Platform Info: Windows (AMD64); Installation path: C:\ProgramData\Miniconda3\lib\site-packages\qutip. Why is it on OPENBLAS now?",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1750#issuecomment-1005876725
https://github.com/qutip/qutip/issues/1750#issuecomment-1005876725:639,Availability,error,error,639,"I reactivated MKL, updated numpy to 1.22.0 and when running `import qutip.testing` I get the following error:. `Traceback (most recent call last):; File ""<stdin>"", line 1, in <module>; File ""C:\ProgramData\Miniconda3\lib\site-packages\qutip\__init__.py"", line 73, in <module>; (_blas_info() == ""OPENBLAS"" and platform.system() == 'Darwin'); File ""C:\ProgramData\Miniconda3\lib\site-packages\qutip\utilities.py"", line 430, in _blas_info; blas_info = config.blas_opt_info; AttributeError: module 'numpy.__config__' has no attribute 'blas_opt_info'`. Then as I wanted to provide my config I typed `import qutip` but it yielded the exact same error so I reverted it back to 1.20.3. QuTiP Version: 4.6.2; Numpy Version: 1.20.3; Scipy Version: 1.7.1; Cython Version: 0.29.25; Matplotlib Version: 3.5.0; Python Version: 3.9.5; Number of CPUs: 4; BLAS Info: OPENBLAS; OPENMP Installed: False; INTEL MKL Ext: False; Platform Info: Windows (AMD64); Installation path: C:\ProgramData\Miniconda3\lib\site-packages\qutip. Why is it on OPENBLAS now?",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1750#issuecomment-1005876725
https://github.com/qutip/qutip/issues/1750#issuecomment-1005876725:19,Deployability,update,updated,19,"I reactivated MKL, updated numpy to 1.22.0 and when running `import qutip.testing` I get the following error:. `Traceback (most recent call last):; File ""<stdin>"", line 1, in <module>; File ""C:\ProgramData\Miniconda3\lib\site-packages\qutip\__init__.py"", line 73, in <module>; (_blas_info() == ""OPENBLAS"" and platform.system() == 'Darwin'); File ""C:\ProgramData\Miniconda3\lib\site-packages\qutip\utilities.py"", line 430, in _blas_info; blas_info = config.blas_opt_info; AttributeError: module 'numpy.__config__' has no attribute 'blas_opt_info'`. Then as I wanted to provide my config I typed `import qutip` but it yielded the exact same error so I reverted it back to 1.20.3. QuTiP Version: 4.6.2; Numpy Version: 1.20.3; Scipy Version: 1.7.1; Cython Version: 0.29.25; Matplotlib Version: 3.5.0; Python Version: 3.9.5; Number of CPUs: 4; BLAS Info: OPENBLAS; OPENMP Installed: False; INTEL MKL Ext: False; Platform Info: Windows (AMD64); Installation path: C:\ProgramData\Miniconda3\lib\site-packages\qutip. Why is it on OPENBLAS now?",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1750#issuecomment-1005876725
https://github.com/qutip/qutip/issues/1750#issuecomment-1005876725:867,Deployability,Install,Installed,867,"I reactivated MKL, updated numpy to 1.22.0 and when running `import qutip.testing` I get the following error:. `Traceback (most recent call last):; File ""<stdin>"", line 1, in <module>; File ""C:\ProgramData\Miniconda3\lib\site-packages\qutip\__init__.py"", line 73, in <module>; (_blas_info() == ""OPENBLAS"" and platform.system() == 'Darwin'); File ""C:\ProgramData\Miniconda3\lib\site-packages\qutip\utilities.py"", line 430, in _blas_info; blas_info = config.blas_opt_info; AttributeError: module 'numpy.__config__' has no attribute 'blas_opt_info'`. Then as I wanted to provide my config I typed `import qutip` but it yielded the exact same error so I reverted it back to 1.20.3. QuTiP Version: 4.6.2; Numpy Version: 1.20.3; Scipy Version: 1.7.1; Cython Version: 0.29.25; Matplotlib Version: 3.5.0; Python Version: 3.9.5; Number of CPUs: 4; BLAS Info: OPENBLAS; OPENMP Installed: False; INTEL MKL Ext: False; Platform Info: Windows (AMD64); Installation path: C:\ProgramData\Miniconda3\lib\site-packages\qutip. Why is it on OPENBLAS now?",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1750#issuecomment-1005876725
https://github.com/qutip/qutip/issues/1750#issuecomment-1005876725:939,Deployability,Install,Installation,939,"I reactivated MKL, updated numpy to 1.22.0 and when running `import qutip.testing` I get the following error:. `Traceback (most recent call last):; File ""<stdin>"", line 1, in <module>; File ""C:\ProgramData\Miniconda3\lib\site-packages\qutip\__init__.py"", line 73, in <module>; (_blas_info() == ""OPENBLAS"" and platform.system() == 'Darwin'); File ""C:\ProgramData\Miniconda3\lib\site-packages\qutip\utilities.py"", line 430, in _blas_info; blas_info = config.blas_opt_info; AttributeError: module 'numpy.__config__' has no attribute 'blas_opt_info'`. Then as I wanted to provide my config I typed `import qutip` but it yielded the exact same error so I reverted it back to 1.20.3. QuTiP Version: 4.6.2; Numpy Version: 1.20.3; Scipy Version: 1.7.1; Cython Version: 0.29.25; Matplotlib Version: 3.5.0; Python Version: 3.9.5; Number of CPUs: 4; BLAS Info: OPENBLAS; OPENMP Installed: False; INTEL MKL Ext: False; Platform Info: Windows (AMD64); Installation path: C:\ProgramData\Miniconda3\lib\site-packages\qutip. Why is it on OPENBLAS now?",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1750#issuecomment-1005876725
https://github.com/qutip/qutip/issues/1750#issuecomment-1005876725:449,Modifiability,config,config,449,"I reactivated MKL, updated numpy to 1.22.0 and when running `import qutip.testing` I get the following error:. `Traceback (most recent call last):; File ""<stdin>"", line 1, in <module>; File ""C:\ProgramData\Miniconda3\lib\site-packages\qutip\__init__.py"", line 73, in <module>; (_blas_info() == ""OPENBLAS"" and platform.system() == 'Darwin'); File ""C:\ProgramData\Miniconda3\lib\site-packages\qutip\utilities.py"", line 430, in _blas_info; blas_info = config.blas_opt_info; AttributeError: module 'numpy.__config__' has no attribute 'blas_opt_info'`. Then as I wanted to provide my config I typed `import qutip` but it yielded the exact same error so I reverted it back to 1.20.3. QuTiP Version: 4.6.2; Numpy Version: 1.20.3; Scipy Version: 1.7.1; Cython Version: 0.29.25; Matplotlib Version: 3.5.0; Python Version: 3.9.5; Number of CPUs: 4; BLAS Info: OPENBLAS; OPENMP Installed: False; INTEL MKL Ext: False; Platform Info: Windows (AMD64); Installation path: C:\ProgramData\Miniconda3\lib\site-packages\qutip. Why is it on OPENBLAS now?",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1750#issuecomment-1005876725
https://github.com/qutip/qutip/issues/1750#issuecomment-1005876725:579,Modifiability,config,config,579,"I reactivated MKL, updated numpy to 1.22.0 and when running `import qutip.testing` I get the following error:. `Traceback (most recent call last):; File ""<stdin>"", line 1, in <module>; File ""C:\ProgramData\Miniconda3\lib\site-packages\qutip\__init__.py"", line 73, in <module>; (_blas_info() == ""OPENBLAS"" and platform.system() == 'Darwin'); File ""C:\ProgramData\Miniconda3\lib\site-packages\qutip\utilities.py"", line 430, in _blas_info; blas_info = config.blas_opt_info; AttributeError: module 'numpy.__config__' has no attribute 'blas_opt_info'`. Then as I wanted to provide my config I typed `import qutip` but it yielded the exact same error so I reverted it back to 1.20.3. QuTiP Version: 4.6.2; Numpy Version: 1.20.3; Scipy Version: 1.7.1; Cython Version: 0.29.25; Matplotlib Version: 3.5.0; Python Version: 3.9.5; Number of CPUs: 4; BLAS Info: OPENBLAS; OPENMP Installed: False; INTEL MKL Ext: False; Platform Info: Windows (AMD64); Installation path: C:\ProgramData\Miniconda3\lib\site-packages\qutip. Why is it on OPENBLAS now?",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1750#issuecomment-1005876725
https://github.com/qutip/qutip/issues/1750#issuecomment-1005876725:74,Testability,test,testing,74,"I reactivated MKL, updated numpy to 1.22.0 and when running `import qutip.testing` I get the following error:. `Traceback (most recent call last):; File ""<stdin>"", line 1, in <module>; File ""C:\ProgramData\Miniconda3\lib\site-packages\qutip\__init__.py"", line 73, in <module>; (_blas_info() == ""OPENBLAS"" and platform.system() == 'Darwin'); File ""C:\ProgramData\Miniconda3\lib\site-packages\qutip\utilities.py"", line 430, in _blas_info; blas_info = config.blas_opt_info; AttributeError: module 'numpy.__config__' has no attribute 'blas_opt_info'`. Then as I wanted to provide my config I typed `import qutip` but it yielded the exact same error so I reverted it back to 1.20.3. QuTiP Version: 4.6.2; Numpy Version: 1.20.3; Scipy Version: 1.7.1; Cython Version: 0.29.25; Matplotlib Version: 3.5.0; Python Version: 3.9.5; Number of CPUs: 4; BLAS Info: OPENBLAS; OPENMP Installed: False; INTEL MKL Ext: False; Platform Info: Windows (AMD64); Installation path: C:\ProgramData\Miniconda3\lib\site-packages\qutip. Why is it on OPENBLAS now?",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1750#issuecomment-1005876725
https://github.com/qutip/qutip/issues/1750#issuecomment-1006031950:45,Availability,error,error,45,"@Gerb0ise The `no attribute 'blas_opt_info'` error is from a change in numpy 1.22 the broke qutip. After you found it it was also reported in #1753 and fixed in #1752. It will be released in 4.6.3 but that will likely only be next week, so for now reverting to numpy 1.20.3 might be the correct solution. BLAS is OPENBLAS now because of the `nomkl` used previously. You can switch blas implementations back to MKL with `conda install ""libblas=*=*mkl""` (see https://conda-forge.org/docs/maintainer/knowledge_base.html#switching-blas-implementation).",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1750#issuecomment-1006031950
https://github.com/qutip/qutip/issues/1750#issuecomment-1006031950:179,Deployability,release,released,179,"@Gerb0ise The `no attribute 'blas_opt_info'` error is from a change in numpy 1.22 the broke qutip. After you found it it was also reported in #1753 and fixed in #1752. It will be released in 4.6.3 but that will likely only be next week, so for now reverting to numpy 1.20.3 might be the correct solution. BLAS is OPENBLAS now because of the `nomkl` used previously. You can switch blas implementations back to MKL with `conda install ""libblas=*=*mkl""` (see https://conda-forge.org/docs/maintainer/knowledge_base.html#switching-blas-implementation).",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1750#issuecomment-1006031950
https://github.com/qutip/qutip/issues/1750#issuecomment-1006031950:426,Deployability,install,install,426,"@Gerb0ise The `no attribute 'blas_opt_info'` error is from a change in numpy 1.22 the broke qutip. After you found it it was also reported in #1753 and fixed in #1752. It will be released in 4.6.3 but that will likely only be next week, so for now reverting to numpy 1.20.3 might be the correct solution. BLAS is OPENBLAS now because of the `nomkl` used previously. You can switch blas implementations back to MKL with `conda install ""libblas=*=*mkl""` (see https://conda-forge.org/docs/maintainer/knowledge_base.html#switching-blas-implementation).",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1750#issuecomment-1006031950
https://github.com/qutip/qutip/issues/1750#issuecomment-1006037619:159,Availability,down,downgrade,159,@stelakus It's odd that `conda install nomkl qutip` is hanging when `conda install qutip` succeeded. I don't use Windows much myself. Other options are to try downgrade numpy to 1.20.3 perhaps. Or to see what other BLAS implementations are supported in your conda environment and try explicitly install one of those. If you can get more information on why the install is hanging (maybe with `conda install -vvv ...`) I might be able to make more suggestions. Aside: You seem to be running in your `base` conda environment. That is probably not a good idea -- create a new environment for each project you work on so that the `base` environment remains pristine.,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1750#issuecomment-1006037619
https://github.com/qutip/qutip/issues/1750#issuecomment-1006037619:31,Deployability,install,install,31,@stelakus It's odd that `conda install nomkl qutip` is hanging when `conda install qutip` succeeded. I don't use Windows much myself. Other options are to try downgrade numpy to 1.20.3 perhaps. Or to see what other BLAS implementations are supported in your conda environment and try explicitly install one of those. If you can get more information on why the install is hanging (maybe with `conda install -vvv ...`) I might be able to make more suggestions. Aside: You seem to be running in your `base` conda environment. That is probably not a good idea -- create a new environment for each project you work on so that the `base` environment remains pristine.,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1750#issuecomment-1006037619
https://github.com/qutip/qutip/issues/1750#issuecomment-1006037619:75,Deployability,install,install,75,@stelakus It's odd that `conda install nomkl qutip` is hanging when `conda install qutip` succeeded. I don't use Windows much myself. Other options are to try downgrade numpy to 1.20.3 perhaps. Or to see what other BLAS implementations are supported in your conda environment and try explicitly install one of those. If you can get more information on why the install is hanging (maybe with `conda install -vvv ...`) I might be able to make more suggestions. Aside: You seem to be running in your `base` conda environment. That is probably not a good idea -- create a new environment for each project you work on so that the `base` environment remains pristine.,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1750#issuecomment-1006037619
https://github.com/qutip/qutip/issues/1750#issuecomment-1006037619:295,Deployability,install,install,295,@stelakus It's odd that `conda install nomkl qutip` is hanging when `conda install qutip` succeeded. I don't use Windows much myself. Other options are to try downgrade numpy to 1.20.3 perhaps. Or to see what other BLAS implementations are supported in your conda environment and try explicitly install one of those. If you can get more information on why the install is hanging (maybe with `conda install -vvv ...`) I might be able to make more suggestions. Aside: You seem to be running in your `base` conda environment. That is probably not a good idea -- create a new environment for each project you work on so that the `base` environment remains pristine.,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1750#issuecomment-1006037619
https://github.com/qutip/qutip/issues/1750#issuecomment-1006037619:360,Deployability,install,install,360,@stelakus It's odd that `conda install nomkl qutip` is hanging when `conda install qutip` succeeded. I don't use Windows much myself. Other options are to try downgrade numpy to 1.20.3 perhaps. Or to see what other BLAS implementations are supported in your conda environment and try explicitly install one of those. If you can get more information on why the install is hanging (maybe with `conda install -vvv ...`) I might be able to make more suggestions. Aside: You seem to be running in your `base` conda environment. That is probably not a good idea -- create a new environment for each project you work on so that the `base` environment remains pristine.,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1750#issuecomment-1006037619
https://github.com/qutip/qutip/issues/1750#issuecomment-1006037619:398,Deployability,install,install,398,@stelakus It's odd that `conda install nomkl qutip` is hanging when `conda install qutip` succeeded. I don't use Windows much myself. Other options are to try downgrade numpy to 1.20.3 perhaps. Or to see what other BLAS implementations are supported in your conda environment and try explicitly install one of those. If you can get more information on why the install is hanging (maybe with `conda install -vvv ...`) I might be able to make more suggestions. Aside: You seem to be running in your `base` conda environment. That is probably not a good idea -- create a new environment for each project you work on so that the `base` environment remains pristine.,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1750#issuecomment-1006037619
https://github.com/qutip/qutip/issues/1750#issuecomment-1006378710:110,Deployability,install,install,110,Thank you for all the info @hodgestar! I reinstalled qutip in a new environment as you advise and then `conda install nomkl qutip` worked as expected. It resulted now in passing all tests (skipping a few) so I think it's best to leave it as it is for now since @Gerb0ise did not have more success upgrading numpy separately.; This is my current `qutip.about()`; ```; QuTiP Version: 4.6.2; Numpy Version: 1.22.0; Scipy Version: 1.7.3; Cython Version: 0.29.25; Matplotlib Version: 3.5.0; Python Version: 3.9.7; Number of CPUs: 4; BLAS Info: Generic; OPENMP Installed: False; INTEL MKL Ext: False; Platform Info: Windows (AMD64); Installation path: C:\Users\Stela Kusar\anaconda3\envs\qutip-env\lib\site-packages\qutip; ```,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1750#issuecomment-1006378710
https://github.com/qutip/qutip/issues/1750#issuecomment-1006378710:555,Deployability,Install,Installed,555,Thank you for all the info @hodgestar! I reinstalled qutip in a new environment as you advise and then `conda install nomkl qutip` worked as expected. It resulted now in passing all tests (skipping a few) so I think it's best to leave it as it is for now since @Gerb0ise did not have more success upgrading numpy separately.; This is my current `qutip.about()`; ```; QuTiP Version: 4.6.2; Numpy Version: 1.22.0; Scipy Version: 1.7.3; Cython Version: 0.29.25; Matplotlib Version: 3.5.0; Python Version: 3.9.7; Number of CPUs: 4; BLAS Info: Generic; OPENMP Installed: False; INTEL MKL Ext: False; Platform Info: Windows (AMD64); Installation path: C:\Users\Stela Kusar\anaconda3\envs\qutip-env\lib\site-packages\qutip; ```,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1750#issuecomment-1006378710
https://github.com/qutip/qutip/issues/1750#issuecomment-1006378710:627,Deployability,Install,Installation,627,Thank you for all the info @hodgestar! I reinstalled qutip in a new environment as you advise and then `conda install nomkl qutip` worked as expected. It resulted now in passing all tests (skipping a few) so I think it's best to leave it as it is for now since @Gerb0ise did not have more success upgrading numpy separately.; This is my current `qutip.about()`; ```; QuTiP Version: 4.6.2; Numpy Version: 1.22.0; Scipy Version: 1.7.3; Cython Version: 0.29.25; Matplotlib Version: 3.5.0; Python Version: 3.9.7; Number of CPUs: 4; BLAS Info: Generic; OPENMP Installed: False; INTEL MKL Ext: False; Platform Info: Windows (AMD64); Installation path: C:\Users\Stela Kusar\anaconda3\envs\qutip-env\lib\site-packages\qutip; ```,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1750#issuecomment-1006378710
https://github.com/qutip/qutip/issues/1750#issuecomment-1006378710:182,Testability,test,tests,182,Thank you for all the info @hodgestar! I reinstalled qutip in a new environment as you advise and then `conda install nomkl qutip` worked as expected. It resulted now in passing all tests (skipping a few) so I think it's best to leave it as it is for now since @Gerb0ise did not have more success upgrading numpy separately.; This is my current `qutip.about()`; ```; QuTiP Version: 4.6.2; Numpy Version: 1.22.0; Scipy Version: 1.7.3; Cython Version: 0.29.25; Matplotlib Version: 3.5.0; Python Version: 3.9.7; Number of CPUs: 4; BLAS Info: Generic; OPENMP Installed: False; INTEL MKL Ext: False; Platform Info: Windows (AMD64); Installation path: C:\Users\Stela Kusar\anaconda3\envs\qutip-env\lib\site-packages\qutip; ```,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1750#issuecomment-1006378710
https://github.com/qutip/qutip/issues/1750#issuecomment-1006410989:128,Deployability,release,released,128,@stelakus Thank you for reporting back & really glad everything is working now. I'm going to leave this bug open until 4.6.3 is released so that anyone else who is tripped up by these issues can find the workarounds here.,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1750#issuecomment-1006410989
https://github.com/qutip/qutip/issues/1750#issuecomment-1856865560:21,Deployability,release,released,21,QuTiP 4.6.3 has been released some time ago. :),MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1750#issuecomment-1856865560
https://github.com/qutip/qutip/pull/1752#issuecomment-1005999347:75,Availability,error,error,75,Thank you for the fix! I tested it locally and I was able to reproduce the error in #1753 and confirm it is fixed with this PR. `qutip.about()` also returns same message locally (not sure where it is tested if it is tested). It seems that CI was not complaining because we do not test for numpy 1.22 yet (although build requirements do install latest numpy version) but I think @hodgestar plans to include numpy 1.22 in the CI soon (see comments in #1747). I hope this PR can be merged soon as tests in PR qutip/qutip-tensornetwork#10 are failing due to `qutip.about()` not working with numpy 1.22.,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1752#issuecomment-1005999347
https://github.com/qutip/qutip/pull/1752#issuecomment-1005999347:336,Deployability,install,install,336,Thank you for the fix! I tested it locally and I was able to reproduce the error in #1753 and confirm it is fixed with this PR. `qutip.about()` also returns same message locally (not sure where it is tested if it is tested). It seems that CI was not complaining because we do not test for numpy 1.22 yet (although build requirements do install latest numpy version) but I think @hodgestar plans to include numpy 1.22 in the CI soon (see comments in #1747). I hope this PR can be merged soon as tests in PR qutip/qutip-tensornetwork#10 are failing due to `qutip.about()` not working with numpy 1.22.,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1752#issuecomment-1005999347
https://github.com/qutip/qutip/pull/1752#issuecomment-1005999347:162,Integrability,message,message,162,Thank you for the fix! I tested it locally and I was able to reproduce the error in #1753 and confirm it is fixed with this PR. `qutip.about()` also returns same message locally (not sure where it is tested if it is tested). It seems that CI was not complaining because we do not test for numpy 1.22 yet (although build requirements do install latest numpy version) but I think @hodgestar plans to include numpy 1.22 in the CI soon (see comments in #1747). I hope this PR can be merged soon as tests in PR qutip/qutip-tensornetwork#10 are failing due to `qutip.about()` not working with numpy 1.22.,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1752#issuecomment-1005999347
https://github.com/qutip/qutip/pull/1752#issuecomment-1005999347:25,Testability,test,tested,25,Thank you for the fix! I tested it locally and I was able to reproduce the error in #1753 and confirm it is fixed with this PR. `qutip.about()` also returns same message locally (not sure where it is tested if it is tested). It seems that CI was not complaining because we do not test for numpy 1.22 yet (although build requirements do install latest numpy version) but I think @hodgestar plans to include numpy 1.22 in the CI soon (see comments in #1747). I hope this PR can be merged soon as tests in PR qutip/qutip-tensornetwork#10 are failing due to `qutip.about()` not working with numpy 1.22.,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1752#issuecomment-1005999347
https://github.com/qutip/qutip/pull/1752#issuecomment-1005999347:200,Testability,test,tested,200,Thank you for the fix! I tested it locally and I was able to reproduce the error in #1753 and confirm it is fixed with this PR. `qutip.about()` also returns same message locally (not sure where it is tested if it is tested). It seems that CI was not complaining because we do not test for numpy 1.22 yet (although build requirements do install latest numpy version) but I think @hodgestar plans to include numpy 1.22 in the CI soon (see comments in #1747). I hope this PR can be merged soon as tests in PR qutip/qutip-tensornetwork#10 are failing due to `qutip.about()` not working with numpy 1.22.,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1752#issuecomment-1005999347
https://github.com/qutip/qutip/pull/1752#issuecomment-1005999347:216,Testability,test,tested,216,Thank you for the fix! I tested it locally and I was able to reproduce the error in #1753 and confirm it is fixed with this PR. `qutip.about()` also returns same message locally (not sure where it is tested if it is tested). It seems that CI was not complaining because we do not test for numpy 1.22 yet (although build requirements do install latest numpy version) but I think @hodgestar plans to include numpy 1.22 in the CI soon (see comments in #1747). I hope this PR can be merged soon as tests in PR qutip/qutip-tensornetwork#10 are failing due to `qutip.about()` not working with numpy 1.22.,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1752#issuecomment-1005999347
https://github.com/qutip/qutip/pull/1752#issuecomment-1005999347:280,Testability,test,test,280,Thank you for the fix! I tested it locally and I was able to reproduce the error in #1753 and confirm it is fixed with this PR. `qutip.about()` also returns same message locally (not sure where it is tested if it is tested). It seems that CI was not complaining because we do not test for numpy 1.22 yet (although build requirements do install latest numpy version) but I think @hodgestar plans to include numpy 1.22 in the CI soon (see comments in #1747). I hope this PR can be merged soon as tests in PR qutip/qutip-tensornetwork#10 are failing due to `qutip.about()` not working with numpy 1.22.,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1752#issuecomment-1005999347
https://github.com/qutip/qutip/pull/1752#issuecomment-1005999347:494,Testability,test,tests,494,Thank you for the fix! I tested it locally and I was able to reproduce the error in #1753 and confirm it is fixed with this PR. `qutip.about()` also returns same message locally (not sure where it is tested if it is tested). It seems that CI was not complaining because we do not test for numpy 1.22 yet (although build requirements do install latest numpy version) but I think @hodgestar plans to include numpy 1.22 in the CI soon (see comments in #1747). I hope this PR can be merged soon as tests in PR qutip/qutip-tensornetwork#10 are failing due to `qutip.about()` not working with numpy 1.22.,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1752#issuecomment-1005999347
https://github.com/qutip/qutip/pull/1752#issuecomment-1006011287:186,Testability,test,test,186,@mtreinish Thank you for the fix!; @AGaliciaMartinez Thank you for trying it out. I'll merge this now so that master isn't broken for numpy 1.22 and then we can add numpy 1.22 to the CI test matrix in a follow up PR.,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1752#issuecomment-1006011287
https://github.com/qutip/qutip/issues/1753#issuecomment-1006012360:64,Deployability,release,release,64,I've merged #1752 and scheduled this for inclusion in the 4.6.3 release. Thank you again for reporting this @goerz!,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1753#issuecomment-1006012360
https://github.com/qutip/qutip/issues/1753#issuecomment-1006012360:22,Energy Efficiency,schedul,scheduled,22,I've merged #1752 and scheduled this for inclusion in the 4.6.3 release. Thank you again for reporting this @goerz!,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1753#issuecomment-1006012360
https://github.com/qutip/qutip/pull/1754#issuecomment-1006439720:55,Testability,test,test,55,@ozbenh @michkern @matteoacrossi I don't have an M1 to test with. Would you mind trying this out and letting me know if it works?,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1754#issuecomment-1006439720
https://github.com/qutip/qutip/pull/1754#issuecomment-1006612560:218,Testability,test,tests,218,@matteoacrossi Thank you for checking! The value is meant to be in GHz (e.g. on my Linux machine QuTiP returns 4.8) but on Mac OS for some unknown reason the value was truncated by calling `int` on it. I've added some tests so that hopefully these sorts of issues are picked up by our robots in future.,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1754#issuecomment-1006612560
https://github.com/qutip/qutip/pull/1754#issuecomment-1006747537:122,Deployability,release,release,122,"@Ericgig I'm going to merge this so that people with M1s can hopefully try out the `master` branch a bit before the 4.6.3 release, but please have a brief look when you get back. Happy to get a review from anyone else reading this too.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1754#issuecomment-1006747537
https://github.com/qutip/qutip/pull/1754#issuecomment-1008344027:308,Usability,simpl,simple,308,"@hodgestar. > I don't know what this measures exactly (e.g. is there clock scaling of some sort so that the measured CPU frequency might not be the maximum CPU frequency?) and it seems a lot of work to get a piece of information that isn't used directly by QuTiP, ... My code implementation is actually very simple. The [script](https://github.com/BitesPotatoBacks/osx-cpufreq/blob/main/osx-cpufreq/main.m) works by measuring the time it takes to execute a decrementing loop (the loop will take a certain amount of CPU cycles to complete based on the CPUs frequency). The loop is executed using inline assembly. The assembly is `volatile` to prevent the loop from being moved and reprioritized by the system (This increases accuracy). Then we do some calculations with some very special numbers and voila -- we've found our CPUs current frequency. I've gotten this trick to work on x86 now as well. > ... so I just fixed the result to 3.2 GHz for now (which according to Wikipedia is the clock speed for current M1s). I believe it would be best to refrain from setting a fixed value of 3.2 Ghz, because this may create issues for future machines with newer silicon that (may) run at higher or lower frequencies. On Apple Silicon, if you _must_ use sysctl, use `sysctl hw.tbfrequency`. This is basically Apple Silicon's version of `sysctl hw.cpufrequency`. The value it returns is still not very accurate, but it varies based on the system silicon, so it will be better than setting a static value. 👍",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1754#issuecomment-1008344027
https://github.com/qutip/qutip/pull/1754#issuecomment-1008912273:665,Energy Efficiency,power,powermetrics,665,"From [this page](https://wiki.freepascal.org/Accessing_macOS_System_Information) it seems that it is mostly used for timing services, so perhaps it is not so relevant here:. ```; hw.tbfrequency - This gives the time base frequency used by the OS and is the basis of all timing services.; In general is is better to use mach's or higher level timing services, but this value; is needed to convert the PPC Time Base registers to real time.; ```. @hodgestar can I ask what the `cpu_freq` is used for in qutip? If it is just for reporting purposes, wouldn't it make sense to put a None or ""N/A""? . A command that somehow gives info on cpu frequencies is `sudo /usr/bin/powermetrics -s cpu_power -n 1`, which gives something like this:. ```; Machine model: MacBookPro18,3; OS version: 21C52; Boot arguments: ; Boot time: Sun Jan 9 11:12:24 2022. *** Sampled system activity (Mon Jan 10 16:05:18 2022 +0200) (5003.97ms elapsed) ***. **** Processor usage ****. E-Cluster Power: 39 mW; E-Cluster HW active frequency: 1027 MHz; E-Cluster HW active residency: 20.50% (600 MHz: 0% 972 MHz: 92% 1332 MHz: 3.1% 1704 MHz: 1.5% 2064 MHz: 3.1%); E-Cluster idle residency: 79.50%; E-Cluster instructions retired: 1.39695e+09; E-Cluster instructions per clock: 0.908186; CPU 0 frequency: 1115 MHz; CPU 0 idle residency: 86.38%; CPU 0 active residency: 13.62% (600 MHz: 0% 972 MHz: 11% 1332 MHz: .78% 1704 MHz: .59% 2064 MHz: 1.1%); CPU 1 frequency: 1103 MHz; CPU 1 idle residency: 86.02%; CPU 1 active residency: 13.98% (600 MHz: 0% 972 MHz: 12% 1332 MHz: .81% 1704 MHz: .77% 2064 MHz: .89%). P0-Cluster Power: 68 mW; P0-Cluster HW active frequency: 680 MHz; P0-Cluster HW active residency: 2.92% (600 MHz: 94% 828 MHz: .04% 1056 MHz: 1.7% 1296 MHz: .24% 1524 MHz: 1.0% 1752 MHz: .32% 1980 MHz: .24% 2208 MHz: .47% 2448 MHz: .35% 2676 MHz: .35% 2904 MHz: .24% 3036 MHz: .11% 3132 MHz: .07% 3168 MHz: .07% 3228 MHz: .81%); P0-Cluster idle residency: 97.08%; P0-Cluster instructions retired: 1.06724e+09; P0-Cluster instr",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1754#issuecomment-1008912273
https://github.com/qutip/qutip/pull/1754#issuecomment-1008912273:964,Energy Efficiency,Power,Power,964,"m [this page](https://wiki.freepascal.org/Accessing_macOS_System_Information) it seems that it is mostly used for timing services, so perhaps it is not so relevant here:. ```; hw.tbfrequency - This gives the time base frequency used by the OS and is the basis of all timing services.; In general is is better to use mach's or higher level timing services, but this value; is needed to convert the PPC Time Base registers to real time.; ```. @hodgestar can I ask what the `cpu_freq` is used for in qutip? If it is just for reporting purposes, wouldn't it make sense to put a None or ""N/A""? . A command that somehow gives info on cpu frequencies is `sudo /usr/bin/powermetrics -s cpu_power -n 1`, which gives something like this:. ```; Machine model: MacBookPro18,3; OS version: 21C52; Boot arguments: ; Boot time: Sun Jan 9 11:12:24 2022. *** Sampled system activity (Mon Jan 10 16:05:18 2022 +0200) (5003.97ms elapsed) ***. **** Processor usage ****. E-Cluster Power: 39 mW; E-Cluster HW active frequency: 1027 MHz; E-Cluster HW active residency: 20.50% (600 MHz: 0% 972 MHz: 92% 1332 MHz: 3.1% 1704 MHz: 1.5% 2064 MHz: 3.1%); E-Cluster idle residency: 79.50%; E-Cluster instructions retired: 1.39695e+09; E-Cluster instructions per clock: 0.908186; CPU 0 frequency: 1115 MHz; CPU 0 idle residency: 86.38%; CPU 0 active residency: 13.62% (600 MHz: 0% 972 MHz: 11% 1332 MHz: .78% 1704 MHz: .59% 2064 MHz: 1.1%); CPU 1 frequency: 1103 MHz; CPU 1 idle residency: 86.02%; CPU 1 active residency: 13.98% (600 MHz: 0% 972 MHz: 12% 1332 MHz: .81% 1704 MHz: .77% 2064 MHz: .89%). P0-Cluster Power: 68 mW; P0-Cluster HW active frequency: 680 MHz; P0-Cluster HW active residency: 2.92% (600 MHz: 94% 828 MHz: .04% 1056 MHz: 1.7% 1296 MHz: .24% 1524 MHz: 1.0% 1752 MHz: .32% 1980 MHz: .24% 2208 MHz: .47% 2448 MHz: .35% 2676 MHz: .35% 2904 MHz: .24% 3036 MHz: .11% 3132 MHz: .07% 3168 MHz: .07% 3228 MHz: .81%); P0-Cluster idle residency: 97.08%; P0-Cluster instructions retired: 1.06724e+09; P0-Cluster instruc",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1754#issuecomment-1008912273
https://github.com/qutip/qutip/pull/1754#issuecomment-1008912273:1586,Energy Efficiency,Power,Power,1586,"rs to real time.; ```. @hodgestar can I ask what the `cpu_freq` is used for in qutip? If it is just for reporting purposes, wouldn't it make sense to put a None or ""N/A""? . A command that somehow gives info on cpu frequencies is `sudo /usr/bin/powermetrics -s cpu_power -n 1`, which gives something like this:. ```; Machine model: MacBookPro18,3; OS version: 21C52; Boot arguments: ; Boot time: Sun Jan 9 11:12:24 2022. *** Sampled system activity (Mon Jan 10 16:05:18 2022 +0200) (5003.97ms elapsed) ***. **** Processor usage ****. E-Cluster Power: 39 mW; E-Cluster HW active frequency: 1027 MHz; E-Cluster HW active residency: 20.50% (600 MHz: 0% 972 MHz: 92% 1332 MHz: 3.1% 1704 MHz: 1.5% 2064 MHz: 3.1%); E-Cluster idle residency: 79.50%; E-Cluster instructions retired: 1.39695e+09; E-Cluster instructions per clock: 0.908186; CPU 0 frequency: 1115 MHz; CPU 0 idle residency: 86.38%; CPU 0 active residency: 13.62% (600 MHz: 0% 972 MHz: 11% 1332 MHz: .78% 1704 MHz: .59% 2064 MHz: 1.1%); CPU 1 frequency: 1103 MHz; CPU 1 idle residency: 86.02%; CPU 1 active residency: 13.98% (600 MHz: 0% 972 MHz: 12% 1332 MHz: .81% 1704 MHz: .77% 2064 MHz: .89%). P0-Cluster Power: 68 mW; P0-Cluster HW active frequency: 680 MHz; P0-Cluster HW active residency: 2.92% (600 MHz: 94% 828 MHz: .04% 1056 MHz: 1.7% 1296 MHz: .24% 1524 MHz: 1.0% 1752 MHz: .32% 1980 MHz: .24% 2208 MHz: .47% 2448 MHz: .35% 2676 MHz: .35% 2904 MHz: .24% 3036 MHz: .11% 3132 MHz: .07% 3168 MHz: .07% 3228 MHz: .81%); P0-Cluster idle residency: 97.08%; P0-Cluster instructions retired: 1.06724e+09; P0-Cluster instructions per clock: 3.04315; CPU 2 frequency: 2166 MHz; CPU 2 idle residency: 97.99%; CPU 2 active residency: 2.01% (600 MHz: .02% 828 MHz: 0% 1056 MHz: .29% 1296 MHz: .10% 1524 MHz: .33% 1752 MHz: .10% 1980 MHz: .08% 2208 MHz: .12% 2448 MHz: .12% 2676 MHz: .30% 2904 MHz: .18% 3036 MHz: .08% 3132 MHz: .04% 3168 MHz: .07% 3228 MHz: .20%); ...; ```. But it requires `sudo` and is a bit messy to parse the max frequencies.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1754#issuecomment-1008912273
https://github.com/qutip/qutip/pull/1754#issuecomment-1009099408:288,Energy Efficiency,power,powermetrics,288,"@hodgestar. yes my script returns the _current_ cpu frequency....I currently am unaware how to get the maximum on Apple silicon. I'll do some research and test some code to see what I can figure out. @matteoacrossi. > A command that somehow gives info on cpu frequencies is sudo /usr/bin/powermetrics -s cpu_power -n 1 ... Powermetrics does seem to be doing some weird trickery. I'm currently trying to reverse engineer it...I've found a bit of interesting things in the assembly but I'm still not fully sure how it's pulling what it does. > But it requires sudo and is a bit messy to parse the max frequencies. I'm pretty sure powermetrics is accessing some private APIs, which is why it requires `sudo`, which is quite unfortunate. I doesn't seem like powermetrics returns any maximum frequencies, though. It only returns _current_ frequencies.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1754#issuecomment-1009099408
https://github.com/qutip/qutip/pull/1754#issuecomment-1009099408:323,Energy Efficiency,Power,Powermetrics,323,"@hodgestar. yes my script returns the _current_ cpu frequency....I currently am unaware how to get the maximum on Apple silicon. I'll do some research and test some code to see what I can figure out. @matteoacrossi. > A command that somehow gives info on cpu frequencies is sudo /usr/bin/powermetrics -s cpu_power -n 1 ... Powermetrics does seem to be doing some weird trickery. I'm currently trying to reverse engineer it...I've found a bit of interesting things in the assembly but I'm still not fully sure how it's pulling what it does. > But it requires sudo and is a bit messy to parse the max frequencies. I'm pretty sure powermetrics is accessing some private APIs, which is why it requires `sudo`, which is quite unfortunate. I doesn't seem like powermetrics returns any maximum frequencies, though. It only returns _current_ frequencies.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1754#issuecomment-1009099408
https://github.com/qutip/qutip/pull/1754#issuecomment-1009099408:628,Energy Efficiency,power,powermetrics,628,"@hodgestar. yes my script returns the _current_ cpu frequency....I currently am unaware how to get the maximum on Apple silicon. I'll do some research and test some code to see what I can figure out. @matteoacrossi. > A command that somehow gives info on cpu frequencies is sudo /usr/bin/powermetrics -s cpu_power -n 1 ... Powermetrics does seem to be doing some weird trickery. I'm currently trying to reverse engineer it...I've found a bit of interesting things in the assembly but I'm still not fully sure how it's pulling what it does. > But it requires sudo and is a bit messy to parse the max frequencies. I'm pretty sure powermetrics is accessing some private APIs, which is why it requires `sudo`, which is quite unfortunate. I doesn't seem like powermetrics returns any maximum frequencies, though. It only returns _current_ frequencies.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1754#issuecomment-1009099408
https://github.com/qutip/qutip/pull/1754#issuecomment-1009099408:754,Energy Efficiency,power,powermetrics,754,"@hodgestar. yes my script returns the _current_ cpu frequency....I currently am unaware how to get the maximum on Apple silicon. I'll do some research and test some code to see what I can figure out. @matteoacrossi. > A command that somehow gives info on cpu frequencies is sudo /usr/bin/powermetrics -s cpu_power -n 1 ... Powermetrics does seem to be doing some weird trickery. I'm currently trying to reverse engineer it...I've found a bit of interesting things in the assembly but I'm still not fully sure how it's pulling what it does. > But it requires sudo and is a bit messy to parse the max frequencies. I'm pretty sure powermetrics is accessing some private APIs, which is why it requires `sudo`, which is quite unfortunate. I doesn't seem like powermetrics returns any maximum frequencies, though. It only returns _current_ frequencies.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1754#issuecomment-1009099408
https://github.com/qutip/qutip/pull/1754#issuecomment-1009099408:644,Security,access,accessing,644,"@hodgestar. yes my script returns the _current_ cpu frequency....I currently am unaware how to get the maximum on Apple silicon. I'll do some research and test some code to see what I can figure out. @matteoacrossi. > A command that somehow gives info on cpu frequencies is sudo /usr/bin/powermetrics -s cpu_power -n 1 ... Powermetrics does seem to be doing some weird trickery. I'm currently trying to reverse engineer it...I've found a bit of interesting things in the assembly but I'm still not fully sure how it's pulling what it does. > But it requires sudo and is a bit messy to parse the max frequencies. I'm pretty sure powermetrics is accessing some private APIs, which is why it requires `sudo`, which is quite unfortunate. I doesn't seem like powermetrics returns any maximum frequencies, though. It only returns _current_ frequencies.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1754#issuecomment-1009099408
https://github.com/qutip/qutip/pull/1754#issuecomment-1009099408:155,Testability,test,test,155,"@hodgestar. yes my script returns the _current_ cpu frequency....I currently am unaware how to get the maximum on Apple silicon. I'll do some research and test some code to see what I can figure out. @matteoacrossi. > A command that somehow gives info on cpu frequencies is sudo /usr/bin/powermetrics -s cpu_power -n 1 ... Powermetrics does seem to be doing some weird trickery. I'm currently trying to reverse engineer it...I've found a bit of interesting things in the assembly but I'm still not fully sure how it's pulling what it does. > But it requires sudo and is a bit messy to parse the max frequencies. I'm pretty sure powermetrics is accessing some private APIs, which is why it requires `sudo`, which is quite unfortunate. I doesn't seem like powermetrics returns any maximum frequencies, though. It only returns _current_ frequencies.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1754#issuecomment-1009099408
https://github.com/qutip/qutip/pull/1754#issuecomment-1009287596:42,Energy Efficiency,power,powermetrics,42,"@BitesPotatoBacks . > I doesn't seem like powermetrics returns any maximum frequencies, though. It only returns _current_ frequencies. Maybe the maximum frequency can be parsed from the last entry in lines like this one:. ```; P0-Cluster HW active residency: 2.92% (600 MHz: 94% 828 MHz: .04% 1056 MHz: 1.7% 1296 MHz: .24% 1524 MHz: 1.0% 1752 MHz: .32% 1980 MHz: .24% 2208 MHz: .47% 2448 MHz: .35% 2676 MHz: .35% 2904 MHz: .24% 3036 MHz: .11% 3132 MHz: .07% 3168 MHz: .07% 3228 MHz: .81%); ```. but like I said it is cumbersome, plus there is the `sudo` issue...",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1754#issuecomment-1009287596
https://github.com/qutip/qutip/pull/1754#issuecomment-1009327416:142,Energy Efficiency,power,powermetrics,142,@matteoacrossi Oh! I didn't even notice that last entry. :laughing: Good eye. I'll continue my reverse engineering to see if I can find where powermetrics is pulling those values from.,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1754#issuecomment-1009327416
https://github.com/qutip/qutip/pull/1754#issuecomment-1010398434:1184,Deployability,release,releases,1184,"@hodgestar okay so I figured out some code. It's VERY close to getting the max frequency, but it's not perfect. . The method I'm using is very similar to how I pull the current frequency, but it's just different enough that it gives a different output. Basically what I'm doing is executing a bunch of `add` instructions through inline assembly multiple times (which will take it's sweet time based on CPU cycles), measuring the time it takes to finish, and doing some fun maths. The problem is that the output it still variates just a little bit. On my M1 Mac mini, 85% of the time I get `2.8 GHz`, and 15% of the time I get `3.1 GHz`...Still needs some fine tuning, but it's better than using `sysctl hw.tbfrequency` or a fixed value. The function is [here](https://github.com/BitesPotatoBacks/osx-cpufreq/blob/4590c2ef6080466df4bda18771f02dd1d2c2c1fd/osx-cpufreq/main.m#L53-L85), and the assembly it uses is [here](https://github.com/BitesPotatoBacks/osx-cpufreq/blob/4590c2ef6080466df4bda18771f02dd1d2c2c1fd/osx-cpufreq/main.m#L19). If anyone else with an Apple Silicon machine wants to test this new trick out, my binary is [here](https://github.com/BitesPotatoBacks/osx-cpufreq/releases) (follow preparation and usage instructions from the projects readme, and make sure to run the binary with option `-x`).",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1754#issuecomment-1010398434
https://github.com/qutip/qutip/pull/1754#issuecomment-1010398434:1091,Testability,test,test,1091,"@hodgestar okay so I figured out some code. It's VERY close to getting the max frequency, but it's not perfect. . The method I'm using is very similar to how I pull the current frequency, but it's just different enough that it gives a different output. Basically what I'm doing is executing a bunch of `add` instructions through inline assembly multiple times (which will take it's sweet time based on CPU cycles), measuring the time it takes to finish, and doing some fun maths. The problem is that the output it still variates just a little bit. On my M1 Mac mini, 85% of the time I get `2.8 GHz`, and 15% of the time I get `3.1 GHz`...Still needs some fine tuning, but it's better than using `sysctl hw.tbfrequency` or a fixed value. The function is [here](https://github.com/BitesPotatoBacks/osx-cpufreq/blob/4590c2ef6080466df4bda18771f02dd1d2c2c1fd/osx-cpufreq/main.m#L53-L85), and the assembly it uses is [here](https://github.com/BitesPotatoBacks/osx-cpufreq/blob/4590c2ef6080466df4bda18771f02dd1d2c2c1fd/osx-cpufreq/main.m#L19). If anyone else with an Apple Silicon machine wants to test this new trick out, my binary is [here](https://github.com/BitesPotatoBacks/osx-cpufreq/releases) (follow preparation and usage instructions from the projects readme, and make sure to run the binary with option `-x`).",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1754#issuecomment-1010398434
https://github.com/qutip/qutip/issues/1755#issuecomment-1007278696:41,Testability,test,tests,41,"@matteoacrossi Thank you for running the tests and reporting these. I'm glad there are only four failing. I can't immediately guess the cause of any of them, so some digging is needed. If you're up to digging into them I'm happy to review and merge PRs. If not, no worries -- I will try think of another plan.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1755#issuecomment-1007278696
https://github.com/qutip/qutip/issues/1755#issuecomment-1007285325:782,Availability,error,error,782,"@matteoacrossi Thanks! I don't know that I have much particular advice, other than ""let's try debug the failing tests one at a time"". Maybe pick one of the `test_driven_cavity` ones, because I'm not quite sure how `ValueError: Invalid preconditioning method` can get raised when it succeeds on other platforms. Maybe it is a bug that isn't completely related to the M1?. Are you familiar with pdb? Running just the one test using pytest and `pytest --pdb` will allow to explore the stack trace and see the values of variables in each stack frame, and hopefully figure out what went wrong. Another first step is just to fix the line `raise ValueError(""Invalid preconditioning method."")` to be `raise ValueError(f""Invalid preconditioning method: {ss_args['method']!r}."")` so that the error messages gives more of a hint of what the invalid method name was.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1755#issuecomment-1007285325
https://github.com/qutip/qutip/issues/1755#issuecomment-1007285325:788,Integrability,message,messages,788,"@matteoacrossi Thanks! I don't know that I have much particular advice, other than ""let's try debug the failing tests one at a time"". Maybe pick one of the `test_driven_cavity` ones, because I'm not quite sure how `ValueError: Invalid preconditioning method` can get raised when it succeeds on other platforms. Maybe it is a bug that isn't completely related to the M1?. Are you familiar with pdb? Running just the one test using pytest and `pytest --pdb` will allow to explore the stack trace and see the values of variables in each stack frame, and hopefully figure out what went wrong. Another first step is just to fix the line `raise ValueError(""Invalid preconditioning method."")` to be `raise ValueError(f""Invalid preconditioning method: {ss_args['method']!r}."")` so that the error messages gives more of a hint of what the invalid method name was.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1755#issuecomment-1007285325
https://github.com/qutip/qutip/issues/1755#issuecomment-1007285325:516,Modifiability,variab,variables,516,"@matteoacrossi Thanks! I don't know that I have much particular advice, other than ""let's try debug the failing tests one at a time"". Maybe pick one of the `test_driven_cavity` ones, because I'm not quite sure how `ValueError: Invalid preconditioning method` can get raised when it succeeds on other platforms. Maybe it is a bug that isn't completely related to the M1?. Are you familiar with pdb? Running just the one test using pytest and `pytest --pdb` will allow to explore the stack trace and see the values of variables in each stack frame, and hopefully figure out what went wrong. Another first step is just to fix the line `raise ValueError(""Invalid preconditioning method."")` to be `raise ValueError(f""Invalid preconditioning method: {ss_args['method']!r}."")` so that the error messages gives more of a hint of what the invalid method name was.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1755#issuecomment-1007285325
https://github.com/qutip/qutip/issues/1755#issuecomment-1007285325:112,Testability,test,tests,112,"@matteoacrossi Thanks! I don't know that I have much particular advice, other than ""let's try debug the failing tests one at a time"". Maybe pick one of the `test_driven_cavity` ones, because I'm not quite sure how `ValueError: Invalid preconditioning method` can get raised when it succeeds on other platforms. Maybe it is a bug that isn't completely related to the M1?. Are you familiar with pdb? Running just the one test using pytest and `pytest --pdb` will allow to explore the stack trace and see the values of variables in each stack frame, and hopefully figure out what went wrong. Another first step is just to fix the line `raise ValueError(""Invalid preconditioning method."")` to be `raise ValueError(f""Invalid preconditioning method: {ss_args['method']!r}."")` so that the error messages gives more of a hint of what the invalid method name was.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1755#issuecomment-1007285325
https://github.com/qutip/qutip/issues/1755#issuecomment-1007285325:419,Testability,test,test,419,"@matteoacrossi Thanks! I don't know that I have much particular advice, other than ""let's try debug the failing tests one at a time"". Maybe pick one of the `test_driven_cavity` ones, because I'm not quite sure how `ValueError: Invalid preconditioning method` can get raised when it succeeds on other platforms. Maybe it is a bug that isn't completely related to the M1?. Are you familiar with pdb? Running just the one test using pytest and `pytest --pdb` will allow to explore the stack trace and see the values of variables in each stack frame, and hopefully figure out what went wrong. Another first step is just to fix the line `raise ValueError(""Invalid preconditioning method."")` to be `raise ValueError(f""Invalid preconditioning method: {ss_args['method']!r}."")` so that the error messages gives more of a hint of what the invalid method name was.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1755#issuecomment-1007285325
https://github.com/qutip/qutip/issues/1755#issuecomment-1007367078:121,Integrability,depend,dependent,121,"I'm very surprised to see that there is a failing test on qutip.qip, which is pure python and is unlikely to be platform dependent. I have a guess that this one may have something to do with pytest parameterization. I had a problem with that on Mac OS (not M1) before, which I still don't fully understand and I left a comment back then:; https://github.com/qutip/qutip/blob/3ff3f42d2cd950c99af8936b12d9221ed79de5e3/qutip/tests/test_scheduler.py#L92-L94; If I split the test and run them (`test_scheduling_gates2` and `test_scheduling_gates3`) one by one, it is fine. But if I use pytest parameterization to initialize several of them, it fails. And now this time it happens at exactly the same place. If you would like to, you can copy that failing test and run it (without using pytest parameterization but giving the input explicitly) in a Python console. If it works well, then my guess should be right. But it doesn't apply to all other failing tests I think.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1755#issuecomment-1007367078
https://github.com/qutip/qutip/issues/1755#issuecomment-1007367078:198,Modifiability,parameteriz,parameterization,198,"I'm very surprised to see that there is a failing test on qutip.qip, which is pure python and is unlikely to be platform dependent. I have a guess that this one may have something to do with pytest parameterization. I had a problem with that on Mac OS (not M1) before, which I still don't fully understand and I left a comment back then:; https://github.com/qutip/qutip/blob/3ff3f42d2cd950c99af8936b12d9221ed79de5e3/qutip/tests/test_scheduler.py#L92-L94; If I split the test and run them (`test_scheduling_gates2` and `test_scheduling_gates3`) one by one, it is fine. But if I use pytest parameterization to initialize several of them, it fails. And now this time it happens at exactly the same place. If you would like to, you can copy that failing test and run it (without using pytest parameterization but giving the input explicitly) in a Python console. If it works well, then my guess should be right. But it doesn't apply to all other failing tests I think.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1755#issuecomment-1007367078
https://github.com/qutip/qutip/issues/1755#issuecomment-1007367078:588,Modifiability,parameteriz,parameterization,588,"I'm very surprised to see that there is a failing test on qutip.qip, which is pure python and is unlikely to be platform dependent. I have a guess that this one may have something to do with pytest parameterization. I had a problem with that on Mac OS (not M1) before, which I still don't fully understand and I left a comment back then:; https://github.com/qutip/qutip/blob/3ff3f42d2cd950c99af8936b12d9221ed79de5e3/qutip/tests/test_scheduler.py#L92-L94; If I split the test and run them (`test_scheduling_gates2` and `test_scheduling_gates3`) one by one, it is fine. But if I use pytest parameterization to initialize several of them, it fails. And now this time it happens at exactly the same place. If you would like to, you can copy that failing test and run it (without using pytest parameterization but giving the input explicitly) in a Python console. If it works well, then my guess should be right. But it doesn't apply to all other failing tests I think.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1755#issuecomment-1007367078
https://github.com/qutip/qutip/issues/1755#issuecomment-1007367078:788,Modifiability,parameteriz,parameterization,788,"I'm very surprised to see that there is a failing test on qutip.qip, which is pure python and is unlikely to be platform dependent. I have a guess that this one may have something to do with pytest parameterization. I had a problem with that on Mac OS (not M1) before, which I still don't fully understand and I left a comment back then:; https://github.com/qutip/qutip/blob/3ff3f42d2cd950c99af8936b12d9221ed79de5e3/qutip/tests/test_scheduler.py#L92-L94; If I split the test and run them (`test_scheduling_gates2` and `test_scheduling_gates3`) one by one, it is fine. But if I use pytest parameterization to initialize several of them, it fails. And now this time it happens at exactly the same place. If you would like to, you can copy that failing test and run it (without using pytest parameterization but giving the input explicitly) in a Python console. If it works well, then my guess should be right. But it doesn't apply to all other failing tests I think.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1755#issuecomment-1007367078
https://github.com/qutip/qutip/issues/1755#issuecomment-1007367078:50,Testability,test,test,50,"I'm very surprised to see that there is a failing test on qutip.qip, which is pure python and is unlikely to be platform dependent. I have a guess that this one may have something to do with pytest parameterization. I had a problem with that on Mac OS (not M1) before, which I still don't fully understand and I left a comment back then:; https://github.com/qutip/qutip/blob/3ff3f42d2cd950c99af8936b12d9221ed79de5e3/qutip/tests/test_scheduler.py#L92-L94; If I split the test and run them (`test_scheduling_gates2` and `test_scheduling_gates3`) one by one, it is fine. But if I use pytest parameterization to initialize several of them, it fails. And now this time it happens at exactly the same place. If you would like to, you can copy that failing test and run it (without using pytest parameterization but giving the input explicitly) in a Python console. If it works well, then my guess should be right. But it doesn't apply to all other failing tests I think.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1755#issuecomment-1007367078
https://github.com/qutip/qutip/issues/1755#issuecomment-1007367078:422,Testability,test,tests,422,"I'm very surprised to see that there is a failing test on qutip.qip, which is pure python and is unlikely to be platform dependent. I have a guess that this one may have something to do with pytest parameterization. I had a problem with that on Mac OS (not M1) before, which I still don't fully understand and I left a comment back then:; https://github.com/qutip/qutip/blob/3ff3f42d2cd950c99af8936b12d9221ed79de5e3/qutip/tests/test_scheduler.py#L92-L94; If I split the test and run them (`test_scheduling_gates2` and `test_scheduling_gates3`) one by one, it is fine. But if I use pytest parameterization to initialize several of them, it fails. And now this time it happens at exactly the same place. If you would like to, you can copy that failing test and run it (without using pytest parameterization but giving the input explicitly) in a Python console. If it works well, then my guess should be right. But it doesn't apply to all other failing tests I think.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1755#issuecomment-1007367078
https://github.com/qutip/qutip/issues/1755#issuecomment-1007367078:470,Testability,test,test,470,"I'm very surprised to see that there is a failing test on qutip.qip, which is pure python and is unlikely to be platform dependent. I have a guess that this one may have something to do with pytest parameterization. I had a problem with that on Mac OS (not M1) before, which I still don't fully understand and I left a comment back then:; https://github.com/qutip/qutip/blob/3ff3f42d2cd950c99af8936b12d9221ed79de5e3/qutip/tests/test_scheduler.py#L92-L94; If I split the test and run them (`test_scheduling_gates2` and `test_scheduling_gates3`) one by one, it is fine. But if I use pytest parameterization to initialize several of them, it fails. And now this time it happens at exactly the same place. If you would like to, you can copy that failing test and run it (without using pytest parameterization but giving the input explicitly) in a Python console. If it works well, then my guess should be right. But it doesn't apply to all other failing tests I think.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1755#issuecomment-1007367078
https://github.com/qutip/qutip/issues/1755#issuecomment-1007367078:750,Testability,test,test,750,"I'm very surprised to see that there is a failing test on qutip.qip, which is pure python and is unlikely to be platform dependent. I have a guess that this one may have something to do with pytest parameterization. I had a problem with that on Mac OS (not M1) before, which I still don't fully understand and I left a comment back then:; https://github.com/qutip/qutip/blob/3ff3f42d2cd950c99af8936b12d9221ed79de5e3/qutip/tests/test_scheduler.py#L92-L94; If I split the test and run them (`test_scheduling_gates2` and `test_scheduling_gates3`) one by one, it is fine. But if I use pytest parameterization to initialize several of them, it fails. And now this time it happens at exactly the same place. If you would like to, you can copy that failing test and run it (without using pytest parameterization but giving the input explicitly) in a Python console. If it works well, then my guess should be right. But it doesn't apply to all other failing tests I think.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1755#issuecomment-1007367078
https://github.com/qutip/qutip/issues/1755#issuecomment-1007367078:950,Testability,test,tests,950,"I'm very surprised to see that there is a failing test on qutip.qip, which is pure python and is unlikely to be platform dependent. I have a guess that this one may have something to do with pytest parameterization. I had a problem with that on Mac OS (not M1) before, which I still don't fully understand and I left a comment back then:; https://github.com/qutip/qutip/blob/3ff3f42d2cd950c99af8936b12d9221ed79de5e3/qutip/tests/test_scheduler.py#L92-L94; If I split the test and run them (`test_scheduling_gates2` and `test_scheduling_gates3`) one by one, it is fine. But if I use pytest parameterization to initialize several of them, it fails. And now this time it happens at exactly the same place. If you would like to, you can copy that failing test and run it (without using pytest parameterization but giving the input explicitly) in a Python console. If it works well, then my guess should be right. But it doesn't apply to all other failing tests I think.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1755#issuecomment-1007367078
https://github.com/qutip/qutip/issues/1755#issuecomment-1007372190:53,Testability,test,tests,53,"Indeed if I run the following. ```python; from qutip.tests.test_scheduler import *; from qutip.tests.test_scheduler import _circuit2. test_scheduling_gates2(deepcopy(_circuit2()), ""ALAP"", 5, False, False); ```. It seems to be working.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1755#issuecomment-1007372190
https://github.com/qutip/qutip/issues/1755#issuecomment-1007372190:95,Testability,test,tests,95,"Indeed if I run the following. ```python; from qutip.tests.test_scheduler import *; from qutip.tests.test_scheduler import _circuit2. test_scheduling_gates2(deepcopy(_circuit2()), ""ALAP"", 5, False, False); ```. It seems to be working.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1755#issuecomment-1007372190
https://github.com/qutip/qutip/issues/1755#issuecomment-1007381880:37,Modifiability,parameteriz,parameterization,37,"Ah great! Thanks! So I probably used parameterization with the circuit in a non-recommended way. The source code is correct, there is just something wrong with the test. I'll try coming up with a solution for that test later.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1755#issuecomment-1007381880
https://github.com/qutip/qutip/issues/1755#issuecomment-1007381880:164,Testability,test,test,164,"Ah great! Thanks! So I probably used parameterization with the circuit in a non-recommended way. The source code is correct, there is just something wrong with the test. I'll try coming up with a solution for that test later.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1755#issuecomment-1007381880
https://github.com/qutip/qutip/issues/1755#issuecomment-1007381880:214,Testability,test,test,214,"Ah great! Thanks! So I probably used parameterization with the circuit in a non-recommended way. The source code is correct, there is just something wrong with the test. I'll try coming up with a solution for that test later.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1755#issuecomment-1007381880
https://github.com/qutip/qutip/issues/1755#issuecomment-1007387315:52,Testability,test,tests,52,"@BoxiLi also, quite interestingly it seems that the tests don't fail all the times. This is another run of the tests:. ```; FAILED tests/test_countstat.py::test_dqd_current - AssertionError: ; ======================================================== 1 failed, 2872 passed, 119 skipped, 67 deselected, 67 warnings in 132.32s (0:02:12) ========================================================; ```. I actually think it only happens if I use `qutip.testing.run()` more than once in the same python shell. And by running pytest directly they don't seem to fail. . `test_countstat.py::test_dqd_current` is the only one that fails consistently.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1755#issuecomment-1007387315
https://github.com/qutip/qutip/issues/1755#issuecomment-1007387315:111,Testability,test,tests,111,"@BoxiLi also, quite interestingly it seems that the tests don't fail all the times. This is another run of the tests:. ```; FAILED tests/test_countstat.py::test_dqd_current - AssertionError: ; ======================================================== 1 failed, 2872 passed, 119 skipped, 67 deselected, 67 warnings in 132.32s (0:02:12) ========================================================; ```. I actually think it only happens if I use `qutip.testing.run()` more than once in the same python shell. And by running pytest directly they don't seem to fail. . `test_countstat.py::test_dqd_current` is the only one that fails consistently.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1755#issuecomment-1007387315
https://github.com/qutip/qutip/issues/1755#issuecomment-1007387315:131,Testability,test,tests,131,"@BoxiLi also, quite interestingly it seems that the tests don't fail all the times. This is another run of the tests:. ```; FAILED tests/test_countstat.py::test_dqd_current - AssertionError: ; ======================================================== 1 failed, 2872 passed, 119 skipped, 67 deselected, 67 warnings in 132.32s (0:02:12) ========================================================; ```. I actually think it only happens if I use `qutip.testing.run()` more than once in the same python shell. And by running pytest directly they don't seem to fail. . `test_countstat.py::test_dqd_current` is the only one that fails consistently.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1755#issuecomment-1007387315
https://github.com/qutip/qutip/issues/1755#issuecomment-1007387315:175,Testability,Assert,AssertionError,175,"@BoxiLi also, quite interestingly it seems that the tests don't fail all the times. This is another run of the tests:. ```; FAILED tests/test_countstat.py::test_dqd_current - AssertionError: ; ======================================================== 1 failed, 2872 passed, 119 skipped, 67 deselected, 67 warnings in 132.32s (0:02:12) ========================================================; ```. I actually think it only happens if I use `qutip.testing.run()` more than once in the same python shell. And by running pytest directly they don't seem to fail. . `test_countstat.py::test_dqd_current` is the only one that fails consistently.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1755#issuecomment-1007387315
https://github.com/qutip/qutip/issues/1755#issuecomment-1007387315:446,Testability,test,testing,446,"@BoxiLi also, quite interestingly it seems that the tests don't fail all the times. This is another run of the tests:. ```; FAILED tests/test_countstat.py::test_dqd_current - AssertionError: ; ======================================================== 1 failed, 2872 passed, 119 skipped, 67 deselected, 67 warnings in 132.32s (0:02:12) ========================================================; ```. I actually think it only happens if I use `qutip.testing.run()` more than once in the same python shell. And by running pytest directly they don't seem to fail. . `test_countstat.py::test_dqd_current` is the only one that fails consistently.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1755#issuecomment-1007387315
https://github.com/qutip/qutip/issues/1755#issuecomment-1007395135:124,Modifiability,parameteriz,parameterization,124,"Interesting, sounds like some cached values of the previous test corrupted the next one. Since the other two tests also use parameterization, the reason might even be the same, except for `test_countstat.py::test_dqd_current`, which looks like numerical instability.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1755#issuecomment-1007395135
https://github.com/qutip/qutip/issues/1755#issuecomment-1007395135:30,Performance,cache,cached,30,"Interesting, sounds like some cached values of the previous test corrupted the next one. Since the other two tests also use parameterization, the reason might even be the same, except for `test_countstat.py::test_dqd_current`, which looks like numerical instability.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1755#issuecomment-1007395135
https://github.com/qutip/qutip/issues/1755#issuecomment-1007395135:60,Testability,test,test,60,"Interesting, sounds like some cached values of the previous test corrupted the next one. Since the other two tests also use parameterization, the reason might even be the same, except for `test_countstat.py::test_dqd_current`, which looks like numerical instability.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1755#issuecomment-1007395135
https://github.com/qutip/qutip/issues/1755#issuecomment-1007395135:109,Testability,test,tests,109,"Interesting, sounds like some cached values of the previous test corrupted the next one. Since the other two tests also use parameterization, the reason might even be the same, except for `test_countstat.py::test_dqd_current`, which looks like numerical instability.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1755#issuecomment-1007395135
https://github.com/qutip/qutip/issues/1755#issuecomment-1008864494:28,Testability,test,test,28,"On the `test_dqd_current()` test: it appears that the problem is with the element 14 in the `eps_vec`. I did some more checking with different values for `eps_vec`, and there are other values which give problems, you can see the code below. . I defined a function that returns the values for a given value of `eps`:. ```python; def current_noise_eps(eps):; H = (eps/2 * sz + tc * sx); L = qutip.liouvillian(H, c_ops); rhoss = qutip.steadystate(L); current, noise = qutip.countstat_current_noise(L, [],; rhoss=rhoss,; J_ops=J_ops). current2 = qutip.countstat_current(L, rhoss=rhoss, J_ops=J_ops); assert abs(current - current2) < 1e-8. current2 = qutip.countstat_current(L, c_ops, J_ops=J_ops); assert abs(current - current2) < 1e-8. current_target = (tc**2 * GammaR; / (tc**2 * (2+GammaR/GammaL) + GammaR**2/4 + eps**2)); noise_target = current_target * (; 1 - (8*GammaL*tc**2*(4 * eps**2 * (GammaR - GammaL); + GammaR*(3*GammaL*GammaR + GammaR**2 + 8*tc**2)); / (4*tc**2*(2*GammaL + GammaR) + GammaL*GammaR**2; + 4*eps**2*GammaL)**2); ). return current.flatten()[0], current_target, noise.flatten()[0], noise_target, rhoss; ```. Now I have the following:. ```; >>> res = current_noise_eps(1.04); >>> print(res[2:4]); (0.06374906663351243, 0.0011104778081249154); ```. So the `noise` is quite different from `noise_target`. But if I increment `eps` by `1e-15` then everything is fine. ```; >>> res1 = current_noise_eps(1.04+1e-15); >>> print(res1); (0.0011104778081249132, 0.0011104778081249143); ```. Comparing `rhoss` in the two cases gives differences that are of the order of the increment in `eps`:. ```; >>> print(res[-1].data.todense() - res1[-1].data.todense()); [[ 1.11022302e-16+0.00000000e+00j 0.00000000e+00+0.00000000e+00j; 0.00000000e+00+0.00000000e+00j]; [ 0.00000000e+00+0.00000000e+00j -5.55111512e-16+0.00000000e+00j; -1.11022302e-16+8.67361738e-19j]; [ 0.00000000e+00+0.00000000e+00j -1.11022302e-16-8.67361738e-19j; 2.22044605e-16+0.00000000e+00j]]; ```. So I think the problem is ",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1755#issuecomment-1008864494
https://github.com/qutip/qutip/issues/1755#issuecomment-1008864494:596,Testability,assert,assert,596,"On the `test_dqd_current()` test: it appears that the problem is with the element 14 in the `eps_vec`. I did some more checking with different values for `eps_vec`, and there are other values which give problems, you can see the code below. . I defined a function that returns the values for a given value of `eps`:. ```python; def current_noise_eps(eps):; H = (eps/2 * sz + tc * sx); L = qutip.liouvillian(H, c_ops); rhoss = qutip.steadystate(L); current, noise = qutip.countstat_current_noise(L, [],; rhoss=rhoss,; J_ops=J_ops). current2 = qutip.countstat_current(L, rhoss=rhoss, J_ops=J_ops); assert abs(current - current2) < 1e-8. current2 = qutip.countstat_current(L, c_ops, J_ops=J_ops); assert abs(current - current2) < 1e-8. current_target = (tc**2 * GammaR; / (tc**2 * (2+GammaR/GammaL) + GammaR**2/4 + eps**2)); noise_target = current_target * (; 1 - (8*GammaL*tc**2*(4 * eps**2 * (GammaR - GammaL); + GammaR*(3*GammaL*GammaR + GammaR**2 + 8*tc**2)); / (4*tc**2*(2*GammaL + GammaR) + GammaL*GammaR**2; + 4*eps**2*GammaL)**2); ). return current.flatten()[0], current_target, noise.flatten()[0], noise_target, rhoss; ```. Now I have the following:. ```; >>> res = current_noise_eps(1.04); >>> print(res[2:4]); (0.06374906663351243, 0.0011104778081249154); ```. So the `noise` is quite different from `noise_target`. But if I increment `eps` by `1e-15` then everything is fine. ```; >>> res1 = current_noise_eps(1.04+1e-15); >>> print(res1); (0.0011104778081249132, 0.0011104778081249143); ```. Comparing `rhoss` in the two cases gives differences that are of the order of the increment in `eps`:. ```; >>> print(res[-1].data.todense() - res1[-1].data.todense()); [[ 1.11022302e-16+0.00000000e+00j 0.00000000e+00+0.00000000e+00j; 0.00000000e+00+0.00000000e+00j]; [ 0.00000000e+00+0.00000000e+00j -5.55111512e-16+0.00000000e+00j; -1.11022302e-16+8.67361738e-19j]; [ 0.00000000e+00+0.00000000e+00j -1.11022302e-16-8.67361738e-19j; 2.22044605e-16+0.00000000e+00j]]; ```. So I think the problem is ",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1755#issuecomment-1008864494
https://github.com/qutip/qutip/issues/1755#issuecomment-1008864494:694,Testability,assert,assert,694,"On the `test_dqd_current()` test: it appears that the problem is with the element 14 in the `eps_vec`. I did some more checking with different values for `eps_vec`, and there are other values which give problems, you can see the code below. . I defined a function that returns the values for a given value of `eps`:. ```python; def current_noise_eps(eps):; H = (eps/2 * sz + tc * sx); L = qutip.liouvillian(H, c_ops); rhoss = qutip.steadystate(L); current, noise = qutip.countstat_current_noise(L, [],; rhoss=rhoss,; J_ops=J_ops). current2 = qutip.countstat_current(L, rhoss=rhoss, J_ops=J_ops); assert abs(current - current2) < 1e-8. current2 = qutip.countstat_current(L, c_ops, J_ops=J_ops); assert abs(current - current2) < 1e-8. current_target = (tc**2 * GammaR; / (tc**2 * (2+GammaR/GammaL) + GammaR**2/4 + eps**2)); noise_target = current_target * (; 1 - (8*GammaL*tc**2*(4 * eps**2 * (GammaR - GammaL); + GammaR*(3*GammaL*GammaR + GammaR**2 + 8*tc**2)); / (4*tc**2*(2*GammaL + GammaR) + GammaL*GammaR**2; + 4*eps**2*GammaL)**2); ). return current.flatten()[0], current_target, noise.flatten()[0], noise_target, rhoss; ```. Now I have the following:. ```; >>> res = current_noise_eps(1.04); >>> print(res[2:4]); (0.06374906663351243, 0.0011104778081249154); ```. So the `noise` is quite different from `noise_target`. But if I increment `eps` by `1e-15` then everything is fine. ```; >>> res1 = current_noise_eps(1.04+1e-15); >>> print(res1); (0.0011104778081249132, 0.0011104778081249143); ```. Comparing `rhoss` in the two cases gives differences that are of the order of the increment in `eps`:. ```; >>> print(res[-1].data.todense() - res1[-1].data.todense()); [[ 1.11022302e-16+0.00000000e+00j 0.00000000e+00+0.00000000e+00j; 0.00000000e+00+0.00000000e+00j]; [ 0.00000000e+00+0.00000000e+00j -5.55111512e-16+0.00000000e+00j; -1.11022302e-16+8.67361738e-19j]; [ 0.00000000e+00+0.00000000e+00j -1.11022302e-16-8.67361738e-19j; 2.22044605e-16+0.00000000e+00j]]; ```. So I think the problem is ",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1755#issuecomment-1008864494
https://github.com/qutip/qutip/issues/1755#issuecomment-1993817100:30,Testability,test,test,30,"> On the `test_dqd_current()` test: it appears that the problem is with the element 14 in the `eps_vec`. I did some more checking with different values for `eps_vec`, and there are other values which give problems, you can see the code below.; > ; > I defined a function that returns the values for a given value of `eps`:; > ; > ```python; > def current_noise_eps(eps):; > H = (eps/2 * sz + tc * sx); > L = qutip.liouvillian(H, c_ops); > rhoss = qutip.steadystate(L); > current, noise = qutip.countstat_current_noise(L, [],; > rhoss=rhoss,; > J_ops=J_ops); > ; > current2 = qutip.countstat_current(L, rhoss=rhoss, J_ops=J_ops); > assert abs(current - current2) < 1e-8; > ; > current2 = qutip.countstat_current(L, c_ops, J_ops=J_ops); > assert abs(current - current2) < 1e-8; > ; > current_target = (tc**2 * GammaR; > / (tc**2 * (2+GammaR/GammaL) + GammaR**2/4 + eps**2)); > noise_target = current_target * (; > 1 - (8*GammaL*tc**2*(4 * eps**2 * (GammaR - GammaL); > + GammaR*(3*GammaL*GammaR + GammaR**2 + 8*tc**2)); > / (4*tc**2*(2*GammaL + GammaR) + GammaL*GammaR**2; > + 4*eps**2*GammaL)**2); > ); > ; > return current.flatten()[0], current_target, noise.flatten()[0], noise_target, rhoss; > ```; > ; > Now I have the following:; > ; > ```; > >>> res = current_noise_eps(1.04); > >>> print(res[2:4]); > (0.06374906663351243, 0.0011104778081249154); > ```; > ; > So the `noise` is quite different from `noise_target`.; > ; > But if I increment `eps` by `1e-15` then everything is fine.; > ; > ```; > >>> res1 = current_noise_eps(1.04+1e-15); > >>> print(res1); > (0.0011104778081249132, 0.0011104778081249143); > ```; > ; > Comparing `rhoss` in the two cases gives differences that are of the order of the increment in `eps`:; > ; > ```; > >>> print(res[-1].data.todense() - res1[-1].data.todense()); > [[ 1.11022302e-16+0.00000000e+00j 0.00000000e+00+0.00000000e+00j; > 0.00000000e+00+0.00000000e+00j]; > [ 0.00000000e+00+0.00000000e+00j -5.55111512e-16+0.00000000e+00j; > -1.11022302e-16+8.673617",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1755#issuecomment-1993817100
https://github.com/qutip/qutip/issues/1755#issuecomment-1993817100:631,Testability,assert,assert,631,"> On the `test_dqd_current()` test: it appears that the problem is with the element 14 in the `eps_vec`. I did some more checking with different values for `eps_vec`, and there are other values which give problems, you can see the code below.; > ; > I defined a function that returns the values for a given value of `eps`:; > ; > ```python; > def current_noise_eps(eps):; > H = (eps/2 * sz + tc * sx); > L = qutip.liouvillian(H, c_ops); > rhoss = qutip.steadystate(L); > current, noise = qutip.countstat_current_noise(L, [],; > rhoss=rhoss,; > J_ops=J_ops); > ; > current2 = qutip.countstat_current(L, rhoss=rhoss, J_ops=J_ops); > assert abs(current - current2) < 1e-8; > ; > current2 = qutip.countstat_current(L, c_ops, J_ops=J_ops); > assert abs(current - current2) < 1e-8; > ; > current_target = (tc**2 * GammaR; > / (tc**2 * (2+GammaR/GammaL) + GammaR**2/4 + eps**2)); > noise_target = current_target * (; > 1 - (8*GammaL*tc**2*(4 * eps**2 * (GammaR - GammaL); > + GammaR*(3*GammaL*GammaR + GammaR**2 + 8*tc**2)); > / (4*tc**2*(2*GammaL + GammaR) + GammaL*GammaR**2; > + 4*eps**2*GammaL)**2); > ); > ; > return current.flatten()[0], current_target, noise.flatten()[0], noise_target, rhoss; > ```; > ; > Now I have the following:; > ; > ```; > >>> res = current_noise_eps(1.04); > >>> print(res[2:4]); > (0.06374906663351243, 0.0011104778081249154); > ```; > ; > So the `noise` is quite different from `noise_target`.; > ; > But if I increment `eps` by `1e-15` then everything is fine.; > ; > ```; > >>> res1 = current_noise_eps(1.04+1e-15); > >>> print(res1); > (0.0011104778081249132, 0.0011104778081249143); > ```; > ; > Comparing `rhoss` in the two cases gives differences that are of the order of the increment in `eps`:; > ; > ```; > >>> print(res[-1].data.todense() - res1[-1].data.todense()); > [[ 1.11022302e-16+0.00000000e+00j 0.00000000e+00+0.00000000e+00j; > 0.00000000e+00+0.00000000e+00j]; > [ 0.00000000e+00+0.00000000e+00j -5.55111512e-16+0.00000000e+00j; > -1.11022302e-16+8.673617",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1755#issuecomment-1993817100
https://github.com/qutip/qutip/issues/1755#issuecomment-1993817100:737,Testability,assert,assert,737,"> On the `test_dqd_current()` test: it appears that the problem is with the element 14 in the `eps_vec`. I did some more checking with different values for `eps_vec`, and there are other values which give problems, you can see the code below.; > ; > I defined a function that returns the values for a given value of `eps`:; > ; > ```python; > def current_noise_eps(eps):; > H = (eps/2 * sz + tc * sx); > L = qutip.liouvillian(H, c_ops); > rhoss = qutip.steadystate(L); > current, noise = qutip.countstat_current_noise(L, [],; > rhoss=rhoss,; > J_ops=J_ops); > ; > current2 = qutip.countstat_current(L, rhoss=rhoss, J_ops=J_ops); > assert abs(current - current2) < 1e-8; > ; > current2 = qutip.countstat_current(L, c_ops, J_ops=J_ops); > assert abs(current - current2) < 1e-8; > ; > current_target = (tc**2 * GammaR; > / (tc**2 * (2+GammaR/GammaL) + GammaR**2/4 + eps**2)); > noise_target = current_target * (; > 1 - (8*GammaL*tc**2*(4 * eps**2 * (GammaR - GammaL); > + GammaR*(3*GammaL*GammaR + GammaR**2 + 8*tc**2)); > / (4*tc**2*(2*GammaL + GammaR) + GammaL*GammaR**2; > + 4*eps**2*GammaL)**2); > ); > ; > return current.flatten()[0], current_target, noise.flatten()[0], noise_target, rhoss; > ```; > ; > Now I have the following:; > ; > ```; > >>> res = current_noise_eps(1.04); > >>> print(res[2:4]); > (0.06374906663351243, 0.0011104778081249154); > ```; > ; > So the `noise` is quite different from `noise_target`.; > ; > But if I increment `eps` by `1e-15` then everything is fine.; > ; > ```; > >>> res1 = current_noise_eps(1.04+1e-15); > >>> print(res1); > (0.0011104778081249132, 0.0011104778081249143); > ```; > ; > Comparing `rhoss` in the two cases gives differences that are of the order of the increment in `eps`:; > ; > ```; > >>> print(res[-1].data.todense() - res1[-1].data.todense()); > [[ 1.11022302e-16+0.00000000e+00j 0.00000000e+00+0.00000000e+00j; > 0.00000000e+00+0.00000000e+00j]; > [ 0.00000000e+00+0.00000000e+00j -5.55111512e-16+0.00000000e+00j; > -1.11022302e-16+8.673617",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1755#issuecomment-1993817100
https://github.com/qutip/qutip/issues/1755#issuecomment-1993817100:2323,Testability,test,test,2323,"; > L = qutip.liouvillian(H, c_ops); > rhoss = qutip.steadystate(L); > current, noise = qutip.countstat_current_noise(L, [],; > rhoss=rhoss,; > J_ops=J_ops); > ; > current2 = qutip.countstat_current(L, rhoss=rhoss, J_ops=J_ops); > assert abs(current - current2) < 1e-8; > ; > current2 = qutip.countstat_current(L, c_ops, J_ops=J_ops); > assert abs(current - current2) < 1e-8; > ; > current_target = (tc**2 * GammaR; > / (tc**2 * (2+GammaR/GammaL) + GammaR**2/4 + eps**2)); > noise_target = current_target * (; > 1 - (8*GammaL*tc**2*(4 * eps**2 * (GammaR - GammaL); > + GammaR*(3*GammaL*GammaR + GammaR**2 + 8*tc**2)); > / (4*tc**2*(2*GammaL + GammaR) + GammaL*GammaR**2; > + 4*eps**2*GammaL)**2); > ); > ; > return current.flatten()[0], current_target, noise.flatten()[0], noise_target, rhoss; > ```; > ; > Now I have the following:; > ; > ```; > >>> res = current_noise_eps(1.04); > >>> print(res[2:4]); > (0.06374906663351243, 0.0011104778081249154); > ```; > ; > So the `noise` is quite different from `noise_target`.; > ; > But if I increment `eps` by `1e-15` then everything is fine.; > ; > ```; > >>> res1 = current_noise_eps(1.04+1e-15); > >>> print(res1); > (0.0011104778081249132, 0.0011104778081249143); > ```; > ; > Comparing `rhoss` in the two cases gives differences that are of the order of the increment in `eps`:; > ; > ```; > >>> print(res[-1].data.todense() - res1[-1].data.todense()); > [[ 1.11022302e-16+0.00000000e+00j 0.00000000e+00+0.00000000e+00j; > 0.00000000e+00+0.00000000e+00j]; > [ 0.00000000e+00+0.00000000e+00j -5.55111512e-16+0.00000000e+00j; > -1.11022302e-16+8.67361738e-19j]; > [ 0.00000000e+00+0.00000000e+00j -1.11022302e-16-8.67361738e-19j; > 2.22044605e-16+0.00000000e+00j]]; > ```; > ; > So I think the problem is not in the `steadystate` function but it must be in `countstat_current_noise`. Can someone tell me how to fix this? because I am also using mac M1, and this is the only test that keeps failing: test_countstat.py::test_dqd_current - AssertionError",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1755#issuecomment-1993817100
https://github.com/qutip/qutip/issues/1755#issuecomment-1993817100:2386,Testability,Assert,AssertionError,2386,"; > L = qutip.liouvillian(H, c_ops); > rhoss = qutip.steadystate(L); > current, noise = qutip.countstat_current_noise(L, [],; > rhoss=rhoss,; > J_ops=J_ops); > ; > current2 = qutip.countstat_current(L, rhoss=rhoss, J_ops=J_ops); > assert abs(current - current2) < 1e-8; > ; > current2 = qutip.countstat_current(L, c_ops, J_ops=J_ops); > assert abs(current - current2) < 1e-8; > ; > current_target = (tc**2 * GammaR; > / (tc**2 * (2+GammaR/GammaL) + GammaR**2/4 + eps**2)); > noise_target = current_target * (; > 1 - (8*GammaL*tc**2*(4 * eps**2 * (GammaR - GammaL); > + GammaR*(3*GammaL*GammaR + GammaR**2 + 8*tc**2)); > / (4*tc**2*(2*GammaL + GammaR) + GammaL*GammaR**2; > + 4*eps**2*GammaL)**2); > ); > ; > return current.flatten()[0], current_target, noise.flatten()[0], noise_target, rhoss; > ```; > ; > Now I have the following:; > ; > ```; > >>> res = current_noise_eps(1.04); > >>> print(res[2:4]); > (0.06374906663351243, 0.0011104778081249154); > ```; > ; > So the `noise` is quite different from `noise_target`.; > ; > But if I increment `eps` by `1e-15` then everything is fine.; > ; > ```; > >>> res1 = current_noise_eps(1.04+1e-15); > >>> print(res1); > (0.0011104778081249132, 0.0011104778081249143); > ```; > ; > Comparing `rhoss` in the two cases gives differences that are of the order of the increment in `eps`:; > ; > ```; > >>> print(res[-1].data.todense() - res1[-1].data.todense()); > [[ 1.11022302e-16+0.00000000e+00j 0.00000000e+00+0.00000000e+00j; > 0.00000000e+00+0.00000000e+00j]; > [ 0.00000000e+00+0.00000000e+00j -5.55111512e-16+0.00000000e+00j; > -1.11022302e-16+8.67361738e-19j]; > [ 0.00000000e+00+0.00000000e+00j -1.11022302e-16-8.67361738e-19j; > 2.22044605e-16+0.00000000e+00j]]; > ```; > ; > So I think the problem is not in the `steadystate` function but it must be in `countstat_current_noise`. Can someone tell me how to fix this? because I am also using mac M1, and this is the only test that keeps failing: test_countstat.py::test_dqd_current - AssertionError",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1755#issuecomment-1993817100
https://github.com/qutip/qutip/issues/1755#issuecomment-1994342977:147,Deployability,release,released,147,"@asma2farhat; If you don't use `countstat`, you can safely ignore this.; Otherwise it should be fixed in the `qutip-4.7.X` branch with #2323, (not released yet, coming in 4.7.6):; `pip install git+https://github.com/qutip/qutip@qutip-4.7.X`; It should also be fixed in v5 that is in beta `pip install qutip --pre`.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1755#issuecomment-1994342977
https://github.com/qutip/qutip/issues/1755#issuecomment-1994342977:185,Deployability,install,install,185,"@asma2farhat; If you don't use `countstat`, you can safely ignore this.; Otherwise it should be fixed in the `qutip-4.7.X` branch with #2323, (not released yet, coming in 4.7.6):; `pip install git+https://github.com/qutip/qutip@qutip-4.7.X`; It should also be fixed in v5 that is in beta `pip install qutip --pre`.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1755#issuecomment-1994342977
https://github.com/qutip/qutip/issues/1755#issuecomment-1994342977:293,Deployability,install,install,293,"@asma2farhat; If you don't use `countstat`, you can safely ignore this.; Otherwise it should be fixed in the `qutip-4.7.X` branch with #2323, (not released yet, coming in 4.7.6):; `pip install git+https://github.com/qutip/qutip@qutip-4.7.X`; It should also be fixed in v5 that is in beta `pip install qutip --pre`.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1755#issuecomment-1994342977
https://github.com/qutip/qutip/issues/1755#issuecomment-1994342977:52,Safety,safe,safely,52,"@asma2farhat; If you don't use `countstat`, you can safely ignore this.; Otherwise it should be fixed in the `qutip-4.7.X` branch with #2323, (not released yet, coming in 4.7.6):; `pip install git+https://github.com/qutip/qutip@qutip-4.7.X`; It should also be fixed in v5 that is in beta `pip install qutip --pre`.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1755#issuecomment-1994342977
https://github.com/qutip/qutip/issues/1755#issuecomment-2029108115:14,Deployability,release,release,14,Fixed with v5 release.,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1755#issuecomment-2029108115
https://github.com/qutip/qutip/pull/1758#issuecomment-1015544419:111,Safety,safe,safer,111,"It feels more 4.6.3 since it's not a new feature but removing unused code in `__init__`, making qutip's import safer. So it looks more like a bug fix to me. Is there any specific reason to wait for 4.7?",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1758#issuecomment-1015544419
https://github.com/qutip/qutip/pull/1758#issuecomment-1015547699:113,Safety,safe,safer,113,"> It feels more 4.6.3 since it's not a new feature but removing unused code in `__init__`, making qutip's import safer. So it looks more like a bug fix to me. Is there any specific reason to wait for 4.7?. I was thinking that we're removing functions that users might be using in their own code. On the other hand it is functionality that is untested and breaks on many modern machines, so I am not completely against adding this to 4.6.3.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1758#issuecomment-1015547699
https://github.com/qutip/qutip/issues/1759#issuecomment-1104512322:145,Availability,error,errors,145,"Hi Anna, thank you for replying can you please give some more information about which particular part/s of the user guides you are finding these errors?",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1759#issuecomment-1104512322
https://github.com/qutip/qutip/issues/1759#issuecomment-1104512322:116,Usability,guid,guides,116,"Hi Anna, thank you for replying can you please give some more information about which particular part/s of the user guides you are finding these errors?",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1759#issuecomment-1104512322
https://github.com/qutip/qutip/issues/1759#issuecomment-1104665213:423,Availability,error,errors,423,"I closed the issue; it is too vague, sorry about that. From: hrahman12 ***@***.***>; Sent: Wednesday, April 20, 2022 5:16 PM; To: qutip/qutip ***@***.***>; Cc: Anna Naden ***@***.***>; Author ***@***.***>; Subject: Re: [qutip/qutip] Details of QuTiP user's guide (Issue #1759). Hi Anna, thank you for replying can you please give some more information about which particular part/s of the user guides you are finding these errors?. —; Reply to this email directly, view it on GitHub<https://github.com/qutip/qutip/issues/1759#issuecomment-1104512322>, or unsubscribe<https://github.com/notifications/unsubscribe-auth/AN2AJU6X7MKML5BRRV4IWHLVGB62PANCNFSM5LYUHNQA>.; You are receiving this because you authored the thread.Message ID: ***@***.******@***.***>>",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1759#issuecomment-1104665213
https://github.com/qutip/qutip/issues/1759#issuecomment-1104665213:720,Integrability,Message,Message,720,"I closed the issue; it is too vague, sorry about that. From: hrahman12 ***@***.***>; Sent: Wednesday, April 20, 2022 5:16 PM; To: qutip/qutip ***@***.***>; Cc: Anna Naden ***@***.***>; Author ***@***.***>; Subject: Re: [qutip/qutip] Details of QuTiP user's guide (Issue #1759). Hi Anna, thank you for replying can you please give some more information about which particular part/s of the user guides you are finding these errors?. —; Reply to this email directly, view it on GitHub<https://github.com/qutip/qutip/issues/1759#issuecomment-1104512322>, or unsubscribe<https://github.com/notifications/unsubscribe-auth/AN2AJU6X7MKML5BRRV4IWHLVGB62PANCNFSM5LYUHNQA>.; You are receiving this because you authored the thread.Message ID: ***@***.******@***.***>>",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1759#issuecomment-1104665213
https://github.com/qutip/qutip/issues/1759#issuecomment-1104665213:257,Usability,guid,guide,257,"I closed the issue; it is too vague, sorry about that. From: hrahman12 ***@***.***>; Sent: Wednesday, April 20, 2022 5:16 PM; To: qutip/qutip ***@***.***>; Cc: Anna Naden ***@***.***>; Author ***@***.***>; Subject: Re: [qutip/qutip] Details of QuTiP user's guide (Issue #1759). Hi Anna, thank you for replying can you please give some more information about which particular part/s of the user guides you are finding these errors?. —; Reply to this email directly, view it on GitHub<https://github.com/qutip/qutip/issues/1759#issuecomment-1104512322>, or unsubscribe<https://github.com/notifications/unsubscribe-auth/AN2AJU6X7MKML5BRRV4IWHLVGB62PANCNFSM5LYUHNQA>.; You are receiving this because you authored the thread.Message ID: ***@***.******@***.***>>",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1759#issuecomment-1104665213
https://github.com/qutip/qutip/issues/1759#issuecomment-1104665213:394,Usability,guid,guides,394,"I closed the issue; it is too vague, sorry about that. From: hrahman12 ***@***.***>; Sent: Wednesday, April 20, 2022 5:16 PM; To: qutip/qutip ***@***.***>; Cc: Anna Naden ***@***.***>; Author ***@***.***>; Subject: Re: [qutip/qutip] Details of QuTiP user's guide (Issue #1759). Hi Anna, thank you for replying can you please give some more information about which particular part/s of the user guides you are finding these errors?. —; Reply to this email directly, view it on GitHub<https://github.com/qutip/qutip/issues/1759#issuecomment-1104512322>, or unsubscribe<https://github.com/notifications/unsubscribe-auth/AN2AJU6X7MKML5BRRV4IWHLVGB62PANCNFSM5LYUHNQA>.; You are receiving this because you authored the thread.Message ID: ***@***.******@***.***>>",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1759#issuecomment-1104665213
https://github.com/qutip/qutip/pull/1760#issuecomment-1011788891:202,Integrability,depend,dependabot,202,[![Coverage Status](https://coveralls.io/builds/45587435/badge)](https://coveralls.io/builds/45587435). Coverage increased (+0.03%) to 68.299% when pulling **40b7e86b40587898a89fc9ea58804b9795170954 on dependabot/pip/doc/pillow-9.0.0** into **52d01da181a21b810c3407812c670f35fdc647e8 on master**.,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1760#issuecomment-1011788891
https://github.com/qutip/qutip/pull/1761#issuecomment-1014771546:48,Usability,guid,guide,48,"Here too, branches are mixed. Changes from `doc/guide/guide-states.rst` etc. are included and it will probably have a conflict with #1762.; This PR should only have the changes from dynamics. If you can remove that conflict, it would be great.; If easier, you can also restart with `qutip/master` and cherry pick the changes to dynamics in a new PR. That said, adding an overview file to introduce the diverse dynamic function is nice. I will review it once the PR is cleaned, in case you choose to open a new one.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1761#issuecomment-1014771546
https://github.com/qutip/qutip/pull/1761#issuecomment-1014771546:54,Usability,guid,guide-states,54,"Here too, branches are mixed. Changes from `doc/guide/guide-states.rst` etc. are included and it will probably have a conflict with #1762.; This PR should only have the changes from dynamics. If you can remove that conflict, it would be great.; If easier, you can also restart with `qutip/master` and cherry pick the changes to dynamics in a new PR. That said, adding an overview file to introduce the diverse dynamic function is nice. I will review it once the PR is cleaned, in case you choose to open a new one.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1761#issuecomment-1014771546
https://github.com/qutip/qutip/pull/1761#issuecomment-1014788646:213,Usability,guid,guide-dynamics-intro,213,[![Coverage Status](https://coveralls.io/builds/45690186/badge)](https://coveralls.io/builds/45690186). Coverage increased (+0.05%) to 68.312% when pulling **24ef99d8392bf5c88e5ceccac26ac3dac18e7249 on anna-naden:guide-dynamics-intro** into **52d01da181a21b810c3407812c670f35fdc647e8 on qutip:master**.,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1761#issuecomment-1014788646
https://github.com/qutip/qutip/pull/1762#issuecomment-1014771366:312,Usability,guid,guide,312,"Hi @anna-naden, thank you for the correction. But the branches and PR are mixed. This PR correct issues in your first one, (#1757). Normally fixes of a PR should be done in the same PR.; So having the fixes here cause confusion and I would like to close either #1757 or this one. This one have the fixes in `doc/guide/guide-basics.rst`, but does not include the changes in `doc/guide/guide-states.rst`.; Which one do you want to keep?",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1762#issuecomment-1014771366
https://github.com/qutip/qutip/pull/1762#issuecomment-1014771366:318,Usability,guid,guide-basics,318,"Hi @anna-naden, thank you for the correction. But the branches and PR are mixed. This PR correct issues in your first one, (#1757). Normally fixes of a PR should be done in the same PR.; So having the fixes here cause confusion and I would like to close either #1757 or this one. This one have the fixes in `doc/guide/guide-basics.rst`, but does not include the changes in `doc/guide/guide-states.rst`.; Which one do you want to keep?",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1762#issuecomment-1014771366
https://github.com/qutip/qutip/pull/1762#issuecomment-1014771366:378,Usability,guid,guide,378,"Hi @anna-naden, thank you for the correction. But the branches and PR are mixed. This PR correct issues in your first one, (#1757). Normally fixes of a PR should be done in the same PR.; So having the fixes here cause confusion and I would like to close either #1757 or this one. This one have the fixes in `doc/guide/guide-basics.rst`, but does not include the changes in `doc/guide/guide-states.rst`.; Which one do you want to keep?",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1762#issuecomment-1014771366
https://github.com/qutip/qutip/pull/1762#issuecomment-1014771366:384,Usability,guid,guide-states,384,"Hi @anna-naden, thank you for the correction. But the branches and PR are mixed. This PR correct issues in your first one, (#1757). Normally fixes of a PR should be done in the same PR.; So having the fixes here cause confusion and I would like to close either #1757 or this one. This one have the fixes in `doc/guide/guide-basics.rst`, but does not include the changes in `doc/guide/guide-states.rst`.; Which one do you want to keep?",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1762#issuecomment-1014771366
https://github.com/qutip/qutip/pull/1762#issuecomment-1015168857:84,Usability,guid,guidance,84,"I think the first PR, 1757, was done on master rather than a branch, and I received guidance that this was not a good idea. So let's close 1757.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1762#issuecomment-1015168857
https://github.com/qutip/qutip/pull/1762#issuecomment-1015728713:5,Usability,guid,guide-basics,5,"For `guide-basics.rst` and `guide-overview.rst`, we will keep #1768 where Asier did a review.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1762#issuecomment-1015728713
https://github.com/qutip/qutip/pull/1762#issuecomment-1015728713:28,Usability,guid,guide-overview,28,"For `guide-basics.rst` and `guide-overview.rst`, we will keep #1768 where Asier did a review.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1762#issuecomment-1015728713
https://github.com/qutip/qutip/issues/1763#issuecomment-1014882006:231,Deployability,install,install,231,"The requirements are described in the pyproject.toml file (which seems to be considered the current ""best practice"" for Python projects) and the setup.cfg file (which is an older best practice). Typically for development one would install with either `python setup.py develop` or `pip install -e '.[full]'` both of which should read the dependencies from the pyproject.toml file. Closing this for now but happy to help more if needed.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1763#issuecomment-1014882006
https://github.com/qutip/qutip/issues/1763#issuecomment-1014882006:285,Deployability,install,install,285,"The requirements are described in the pyproject.toml file (which seems to be considered the current ""best practice"" for Python projects) and the setup.cfg file (which is an older best practice). Typically for development one would install with either `python setup.py develop` or `pip install -e '.[full]'` both of which should read the dependencies from the pyproject.toml file. Closing this for now but happy to help more if needed.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1763#issuecomment-1014882006
https://github.com/qutip/qutip/issues/1763#issuecomment-1014882006:337,Integrability,depend,dependencies,337,"The requirements are described in the pyproject.toml file (which seems to be considered the current ""best practice"" for Python projects) and the setup.cfg file (which is an older best practice). Typically for development one would install with either `python setup.py develop` or `pip install -e '.[full]'` both of which should read the dependencies from the pyproject.toml file. Closing this for now but happy to help more if needed.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1763#issuecomment-1014882006
https://github.com/qutip/qutip/pull/1764#issuecomment-1014778988:51,Availability,redundant,redundant,51,"I am closing this: change to the documentation are redundant to previous PRs. The `requirements.txt` file refers to the packages needed to use qutip, which we keep to a minimum. Modules required to build the documentation are in `doc/requirements.txt`.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1764#issuecomment-1014778988
https://github.com/qutip/qutip/pull/1764#issuecomment-1014778988:51,Safety,redund,redundant,51,"I am closing this: change to the documentation are redundant to previous PRs. The `requirements.txt` file refers to the packages needed to use qutip, which we keep to a minimum. Modules required to build the documentation are in `doc/requirements.txt`.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1764#issuecomment-1014778988
https://github.com/qutip/qutip/issues/1765#issuecomment-1013528199:140,Deployability,release,release,140,"A `QobjEvo` contain only one `args` dictionary, thus it cannot handle overlapping names. ; There are plans to change this in the next major release (already changed in dev.major), but not in v4.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1765#issuecomment-1013528199
https://github.com/qutip/qutip/issues/1766#issuecomment-1014616780:37,Deployability,patch,patch,37,It's fixed in `master` with #1752. A patch should be released soon.,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1766#issuecomment-1014616780
https://github.com/qutip/qutip/issues/1766#issuecomment-1014616780:53,Deployability,release,released,53,It's fixed in `master` with #1752. A patch should be released soon.,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1766#issuecomment-1014616780
https://github.com/qutip/qutip/issues/1766#issuecomment-1018630360:10,Deployability,release,release,10,We should release the patch soon. @hodgestar Let me know if you need any help with the release.,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1766#issuecomment-1018630360
https://github.com/qutip/qutip/issues/1766#issuecomment-1018630360:22,Deployability,patch,patch,22,We should release the patch soon. @hodgestar Let me know if you need any help with the release.,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1766#issuecomment-1018630360
https://github.com/qutip/qutip/issues/1766#issuecomment-1018630360:87,Deployability,release,release,87,We should release the patch soon. @hodgestar Let me know if you need any help with the release.,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1766#issuecomment-1018630360
https://github.com/qutip/qutip/issues/1766#issuecomment-1030351261:39,Deployability,patch,patch,39,> It's fixed in `master` with #1752. A patch should be released soon. Please do release that patch! 😉,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1766#issuecomment-1030351261
https://github.com/qutip/qutip/issues/1766#issuecomment-1030351261:55,Deployability,release,released,55,> It's fixed in `master` with #1752. A patch should be released soon. Please do release that patch! 😉,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1766#issuecomment-1030351261
https://github.com/qutip/qutip/issues/1766#issuecomment-1030351261:80,Deployability,release,release,80,> It's fixed in `master` with #1752. A patch should be released soon. Please do release that patch! 😉,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1766#issuecomment-1030351261
https://github.com/qutip/qutip/issues/1766#issuecomment-1030351261:93,Deployability,patch,patch,93,> It's fixed in `master` with #1752. A patch should be released soon. Please do release that patch! 😉,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1766#issuecomment-1030351261
https://github.com/qutip/qutip/issues/1766#issuecomment-1030356669:23,Deployability,release,release,23,I'm working on a 4.6.3 release at the moment.,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1766#issuecomment-1030356669
https://github.com/qutip/qutip/issues/1766#issuecomment-1097186602:15,Deployability,release,released,15,4.6.3 has been released.,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1766#issuecomment-1097186602
https://github.com/qutip/qutip/pull/1767#issuecomment-1014718223:202,Integrability,depend,dependabot,202,[![Coverage Status](https://coveralls.io/builds/45687437/badge)](https://coveralls.io/builds/45687437). Coverage increased (+0.01%) to 68.312% when pulling **6c252fbd33c8d7bad1816b72174c68dc9754e72e on dependabot/pip/doc/numpy-1.21.0** into **0ecb9612299c0c5105bf09972279efa7cb9c41be on master**.,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1767#issuecomment-1014718223
https://github.com/qutip/qutip/pull/1767#issuecomment-1016299366:44,Integrability,depend,dependabot,44,Documentation builds looks good. Thank you @dependabot. *botsnack*,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1767#issuecomment-1016299366
https://github.com/qutip/qutip/pull/1768#issuecomment-1016782971:213,Usability,guid,guide-,213,[![Coverage Status](https://coveralls.io/builds/45761876/badge)](https://coveralls.io/builds/45761876). Coverage increased (+0.04%) to 68.336% when pulling **82bc31a6417feb578e904d1087f46eb095d18658 on anna-naden:guide-basics2** into **0ecb9612299c0c5105bf09972279efa7cb9c41be on qutip:master**.,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1768#issuecomment-1016782971
https://github.com/qutip/qutip/pull/1769#issuecomment-1015730642:0,Availability,Redundant,Redundant,0,"Redundant to #1768, we will keep that one for those 2 files.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1769#issuecomment-1015730642
https://github.com/qutip/qutip/pull/1769#issuecomment-1015730642:0,Safety,Redund,Redundant,0,"Redundant to #1768, we will keep that one for those 2 files.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1769#issuecomment-1015730642
https://github.com/qutip/qutip/pull/1771#issuecomment-1016792190:214,Usability,guid,guide-,214,[![Coverage Status](https://coveralls.io/builds/45762014/badge)](https://coveralls.io/builds/45762014). Coverage decreased (-0.008%) to 68.291% when pulling **4aa3ff0524812c04b5520c01d64a3c6bcaeef476 on anna-naden:guide-states2** into **0ecb9612299c0c5105bf09972279efa7cb9c41be on qutip:master**.,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1771#issuecomment-1016792190
https://github.com/qutip/qutip/pull/1773#issuecomment-1016783921:213,Usability,guid,guide-dynamics-data,213,[![Coverage Status](https://coveralls.io/builds/45761775/badge)](https://coveralls.io/builds/45761775). Coverage increased (+0.03%) to 68.324% when pulling **59adcd370f89dda99afc1efb4eb33452522fe3d6 on anna-naden:guide-dynamics-data** into **0ecb9612299c0c5105bf09972279efa7cb9c41be on qutip:master**.,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1773#issuecomment-1016783921
https://github.com/qutip/qutip/pull/1773#issuecomment-1027766437:57,Usability,guid,guide-basics,57,@anna-naden This PR also seems to include the changes to guide-basics.rst that were in the PR I rejected. Could you remove those changes from here and then I can review the rest?,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1773#issuecomment-1027766437
https://github.com/qutip/qutip/pull/1773#issuecomment-1168805739:109,Deployability,update,update,109,This PR mainly reformats some line lengths. I'm going to reject it for now in favour of a more comprehensive update of this documentation for QuTiP 5 at some point.,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1773#issuecomment-1168805739
https://github.com/qutip/qutip/pull/1775#issuecomment-1016784522:212,Usability,guid,guide-dynamics-,212,[![Coverage Status](https://coveralls.io/builds/45761898/badge)](https://coveralls.io/builds/45761898). Coverage increased (+0.02%) to 68.32% when pulling **6cd3b626ff1470cbb8e0073815f3a8d4c2d9d31f on anna-naden:guide-dynamics-intro2** into **0ecb9612299c0c5105bf09972279efa7cb9c41be on qutip:master**.,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1775#issuecomment-1016784522
https://github.com/qutip/qutip/issues/1776#issuecomment-1017465570:1502,Deployability,Install,Installed,1502,"I tried to run the code posted by @jkochNU, and it runs successfully in my machine. Though, the result is that the expectation value is a array of zeros. Given that the initial state is the eigenvalue of the Hamiltonian, we should expect it to be all ones instead of all zeros. ```; In [5]: sol.expect[0]; Out[5]:; array([0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0.,; 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0.,; 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0.,; 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0.,; 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0.,; 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0.]); ``` ; Here is my qutip.about:; ```; QuTiP: Quantum Toolbox in Python; ================================; Copyright (c) QuTiP team 2011 and later.; Current admin team: Alexander Pitchford, Nathan Shammah, Shahnawaz Ahmed, Neill Lambert, Eric Giguère, Boxi Li, Jak; e Lishman and Simon Cross.; Board members: Daniel Burgarth, Robert Johansson, Anton F. Kockum, Franco Nori and Will Zeng.; Original developers: R. J. Johansson & P. D. Nation.; Previous lead developers: Chris Granade & A. Grimsmo.; Currently developed through wide collaboration. See https://github.com/qutip for details. QuTiP Version: 4.6.2; Numpy Version: 1.22.0; Scipy Version: 1.7.3; Cython Version: 0.29.26; Matplotlib Version: 3.5.1; Python Version: 3.9.9; Number of CPUs: 6; BLAS Info: Generic; OPENMP Installed: False; INTEL MKL Ext: False; Platform Info: Linux (x86_64); Installation path: /home/saipavanchitta/miniconda3/envs/sai/lib/python3.9/site-packages/qutip; ================================================================================; Please cite QuTiP in your publication.; ================================================================================; For your convenience a bibtex reference can be easily generated using `qutip.cite()`; ```",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1776#issuecomment-1017465570
https://github.com/qutip/qutip/issues/1776#issuecomment-1017465570:1573,Deployability,Install,Installation,1573,"I tried to run the code posted by @jkochNU, and it runs successfully in my machine. Though, the result is that the expectation value is a array of zeros. Given that the initial state is the eigenvalue of the Hamiltonian, we should expect it to be all ones instead of all zeros. ```; In [5]: sol.expect[0]; Out[5]:; array([0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0.,; 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0.,; 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0.,; 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0.,; 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0.,; 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0.]); ``` ; Here is my qutip.about:; ```; QuTiP: Quantum Toolbox in Python; ================================; Copyright (c) QuTiP team 2011 and later.; Current admin team: Alexander Pitchford, Nathan Shammah, Shahnawaz Ahmed, Neill Lambert, Eric Giguère, Boxi Li, Jak; e Lishman and Simon Cross.; Board members: Daniel Burgarth, Robert Johansson, Anton F. Kockum, Franco Nori and Will Zeng.; Original developers: R. J. Johansson & P. D. Nation.; Previous lead developers: Chris Granade & A. Grimsmo.; Currently developed through wide collaboration. See https://github.com/qutip for details. QuTiP Version: 4.6.2; Numpy Version: 1.22.0; Scipy Version: 1.7.3; Cython Version: 0.29.26; Matplotlib Version: 3.5.1; Python Version: 3.9.9; Number of CPUs: 6; BLAS Info: Generic; OPENMP Installed: False; INTEL MKL Ext: False; Platform Info: Linux (x86_64); Installation path: /home/saipavanchitta/miniconda3/envs/sai/lib/python3.9/site-packages/qutip; ================================================================================; Please cite QuTiP in your publication.; ================================================================================; For your convenience a bibtex reference can be easily generated using `qutip.cite()`; ```",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1776#issuecomment-1017465570
https://github.com/qutip/qutip/pull/1777#issuecomment-1016882453:219,Testability,test,test-numpy-,219,[![Coverage Status](https://coveralls.io/builds/46127930/badge)](https://coveralls.io/builds/46127930). Coverage remained the same at 68.408% when pulling **c45199ec874076cff819b29adbdbdf7ade3290f5 on hodgestar:feature/test-numpy-122-in-ci** into **51443081561cce79660aa34646c715b1932eebb5 on qutip:master**.,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1777#issuecomment-1016882453
https://github.com/qutip/qutip/pull/1778#issuecomment-1017814632:59,Availability,error,error,59,"@hodgestar, I fixed the codeclimat issues and improved the error message. If your still fine with it, let's merge.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1778#issuecomment-1017814632
https://github.com/qutip/qutip/pull/1778#issuecomment-1017814632:65,Integrability,message,message,65,"@hodgestar, I fixed the codeclimat issues and improved the error message. If your still fine with it, let's merge.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1778#issuecomment-1017814632
https://github.com/qutip/qutip/pull/1778#issuecomment-1017835823:52,Testability,test,tests,52,@Ericgig Happy for this to be merged as soon as the tests finish.,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1778#issuecomment-1017835823
https://github.com/qutip/qutip/pull/1780#issuecomment-1018846737:203,Integrability,depend,dependabot,203,[![Coverage Status](https://coveralls.io/builds/45840885/badge)](https://coveralls.io/builds/45840885). Coverage decreased (-0.008%) to 68.361% when pulling **7f3841f1f2d48cdfe7c7453eec6f966be8efc07d on dependabot/pip/doc/ipython-7.31.1** into **d4013031734790bac919344bcb8c1d462e364ea8 on master**.,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1780#issuecomment-1018846737
https://github.com/qutip/qutip/pull/1781#issuecomment-1028904411:109,Deployability,release,release,109,Thanks @cgranade. @BoxiLi what's the timeline to remove `qip` from `qutip/qutip`? Are we waiting the QuTiP 5 release?,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1781#issuecomment-1028904411
https://github.com/qutip/qutip/pull/1781#issuecomment-1029021859:111,Deployability,release,release,111,"> Thanks @cgranade. @BoxiLi what's the timeline to remove `qip` from `qutip/qutip`? Are we waiting the QuTiP 5 release?. Yes. `qutip.qip` will still be included in QuTiP 4.7, but for QuTiP 5, qutip-qip will need to be installed separately.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1781#issuecomment-1029021859
https://github.com/qutip/qutip/pull/1781#issuecomment-1029021859:218,Deployability,install,installed,218,"> Thanks @cgranade. @BoxiLi what's the timeline to remove `qip` from `qutip/qutip`? Are we waiting the QuTiP 5 release?. Yes. `qutip.qip` will still be included in QuTiP 4.7, but for QuTiP 5, qutip-qip will need to be installed separately.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1781#issuecomment-1029021859
https://github.com/qutip/qutip/issues/1782#issuecomment-1021275291:655,Deployability,patch,patch,655,"@Lala5th Thank you for reporting this. It looks like the issue is just hat `mesolve` calculates the `size` variable incorrectly for a flat array and the following diff removes the segfault for me:. ```diff; diff --git a/qutip/mesolve.py b/qutip/mesolve.py; index f6527299..25e9f3cd 100644; --- a/qutip/mesolve.py; +++ b/qutip/mesolve.py; @@ -435,6 +435,8 @@ def _generic_ode_solve(func, ode_args, rho0, tlist, e_ops, opt,; output.solver = ""mesolve""; output.times = tlist; size = rho0.shape[0]; + if rho0.shape[1] == 1:; + size = int(np.sqrt(size)); ; initial_vector = rho0.full().ravel('F'); ```. I agree that we should not segfault. Probably the minimal patch is to raise an exception if `rho0.shape[0] != rho0.shape[1]`. If you agree, I can open a small PR (or you can if you would like to).",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1782#issuecomment-1021275291
https://github.com/qutip/qutip/issues/1782#issuecomment-1021275291:107,Modifiability,variab,variable,107,"@Lala5th Thank you for reporting this. It looks like the issue is just hat `mesolve` calculates the `size` variable incorrectly for a flat array and the following diff removes the segfault for me:. ```diff; diff --git a/qutip/mesolve.py b/qutip/mesolve.py; index f6527299..25e9f3cd 100644; --- a/qutip/mesolve.py; +++ b/qutip/mesolve.py; @@ -435,6 +435,8 @@ def _generic_ode_solve(func, ode_args, rho0, tlist, e_ops, opt,; output.solver = ""mesolve""; output.times = tlist; size = rho0.shape[0]; + if rho0.shape[1] == 1:; + size = int(np.sqrt(size)); ; initial_vector = rho0.full().ravel('F'); ```. I agree that we should not segfault. Probably the minimal patch is to raise an exception if `rho0.shape[0] != rho0.shape[1]`. If you agree, I can open a small PR (or you can if you would like to).",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1782#issuecomment-1021275291
https://github.com/qutip/qutip/issues/1782#issuecomment-1021398103:373,Safety,safe,safer,373,"I think the bug is bigger than that. `Qobj` never ensure that the shape and dims match but in many places, solver check only the dims and not the shape. Here `rho` is shaped as an `operator-ket` but with `oper` dims, so it slip through the dims check. I wouldn't be surprised that we can cause other segfault with `Qobj` where the shape and dims don't match. . It would be safer to add a check when entering cython code.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1782#issuecomment-1021398103
https://github.com/qutip/qutip/issues/1782#issuecomment-1021447683:84,Safety,avoid,avoid,84,"@Ericgig That is true. Possibly a check in `Qobj` constructor, would be the best to avoid mismatched `Qobj`s to be created in the first place. A rudimentary fix might be something like:. ```diff; diff --git a/qutip/qobj.py b/qutip/qobj.py; index bf82a4a6..6c7c630d 100644; --- a/qutip/qobj.py; +++ b/qutip/qobj.py; @@ -310,6 +310,11 @@ class Qobj(object):; ); self.dims = [[int(inpt.shape[0])], [int(inpt.shape[1])]]; ; + if self._data.shape[0] != np.prod(self.dims[0]) or \; + self._data.shape[1] != np.prod(self.dims[1]):; + raise ValueError(f""Qobj has mismatched dims {self.dims} "" +\; + f""and shape {self._data.shape}""); +; if type == 'super':; # Type is not super, i.e. dims not explicitly passed, but oper-like; # shape.; ```; If you think this would be a good fix I can open a PR.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1782#issuecomment-1021447683
https://github.com/qutip/qutip/pull/1783#issuecomment-1027885014:61,Testability,test,test,61,@Lala5th Would you mind merging master into this so that the test suite can run again (I had to pin coverage to version 6.2 while coverage 6.3 is being fixed).,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1783#issuecomment-1027885014
https://github.com/qutip/qutip/pull/1783#issuecomment-1028022762:18,Testability,test,test,18,"I fixed the BoFiN test, but I'm a little bit worried that it might be common for people to accidentally write `dims=[2, 2]` instead of `dims=[[2], [2]]`, for example, and that with the call to `np.hstack(dims[0])` this will now raise a TypeError, because `np.hstack` must be called with a list. I.e. we are also forcing `dims[0]` and `dims[1]` to be lists, which is not something we checked before.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1783#issuecomment-1028022762
https://github.com/qutip/qutip/pull/1783#issuecomment-1028044366:91,Availability,error,error,91,"Every `Qobj` created by qutip have `dims[0]` and `dims[1]` being list. `dims=[2, 2]` is an error that we should catch. The main issue is that there is no clear documentation or tests that clearly says what is a valid dims format. . There are some strange dimension that are produced by our function that would raise an error with `np.stack` like; `tensor(operator_to_vector(oper), oper)` but I don't think we should accept these kind of `Qobj` in the first place, so I am fine failing there.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1783#issuecomment-1028044366
https://github.com/qutip/qutip/pull/1783#issuecomment-1028044366:319,Availability,error,error,319,"Every `Qobj` created by qutip have `dims[0]` and `dims[1]` being list. `dims=[2, 2]` is an error that we should catch. The main issue is that there is no clear documentation or tests that clearly says what is a valid dims format. . There are some strange dimension that are produced by our function that would raise an error with `np.stack` like; `tensor(operator_to_vector(oper), oper)` but I don't think we should accept these kind of `Qobj` in the first place, so I am fine failing there.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1783#issuecomment-1028044366
https://github.com/qutip/qutip/pull/1783#issuecomment-1028044366:177,Testability,test,tests,177,"Every `Qobj` created by qutip have `dims[0]` and `dims[1]` being list. `dims=[2, 2]` is an error that we should catch. The main issue is that there is no clear documentation or tests that clearly says what is a valid dims format. . There are some strange dimension that are produced by our function that would raise an error with `np.stack` like; `tensor(operator_to_vector(oper), oper)` but I don't think we should accept these kind of `Qobj` in the first place, so I am fine failing there.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1783#issuecomment-1028044366
https://github.com/qutip/qutip/pull/1783#issuecomment-1028044366:154,Usability,clear,clear,154,"Every `Qobj` created by qutip have `dims[0]` and `dims[1]` being list. `dims=[2, 2]` is an error that we should catch. The main issue is that there is no clear documentation or tests that clearly says what is a valid dims format. . There are some strange dimension that are produced by our function that would raise an error with `np.stack` like; `tensor(operator_to_vector(oper), oper)` but I don't think we should accept these kind of `Qobj` in the first place, so I am fine failing there.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1783#issuecomment-1028044366
https://github.com/qutip/qutip/pull/1783#issuecomment-1028044366:188,Usability,clear,clearly,188,"Every `Qobj` created by qutip have `dims[0]` and `dims[1]` being list. `dims=[2, 2]` is an error that we should catch. The main issue is that there is no clear documentation or tests that clearly says what is a valid dims format. . There are some strange dimension that are produced by our function that would raise an error with `np.stack` like; `tensor(operator_to_vector(oper), oper)` but I don't think we should accept these kind of `Qobj` in the first place, so I am fine failing there.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1783#issuecomment-1028044366
https://github.com/qutip/qutip/pull/1783#issuecomment-1028128787:169,Deployability,release,release,169,"Given that this likely prevents many mistakes, I'm okay with merging it as is and if things break too badly for many users, we can revert or fix part of it and do a new release.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1783#issuecomment-1028128787
https://github.com/qutip/qutip/pull/1784#issuecomment-1027982472:79,Integrability,interface,interface,79,"I think the renaming is fine for 4.6.3, it is called by `expect` of the python interface, but the cython interface is not expected to be used by the users.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1784#issuecomment-1027982472
https://github.com/qutip/qutip/pull/1784#issuecomment-1027982472:105,Integrability,interface,interface,105,"I think the renaming is fine for 4.6.3, it is called by `expect` of the python interface, but the cython interface is not expected to be used by the users.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1784#issuecomment-1027982472
https://github.com/qutip/qutip/pull/1785#issuecomment-1027853795:27,Testability,test,test,27,@Lala5th Thank you for the test fix.,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1785#issuecomment-1027853795
https://github.com/qutip/qutip/pull/1787#issuecomment-1023376091:45,Availability,outage,outage,45,The timeouts are because of a GitHub actions outage. It appears to have been resolved earlier today -- https://www.githubstatus.com/incidents/29xnrws671f0.,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1787#issuecomment-1023376091
https://github.com/qutip/qutip/pull/1787#issuecomment-1023376091:4,Safety,timeout,timeouts,4,The timeouts are because of a GitHub actions outage. It appears to have been resolved earlier today -- https://www.githubstatus.com/incidents/29xnrws671f0.,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1787#issuecomment-1023376091
https://github.com/qutip/qutip/pull/1787#issuecomment-1023383098:67,Safety,safe,safety,67,On the other hand I'm not completely against just having this as a safety net for wonky tests anyway.,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1787#issuecomment-1023383098
https://github.com/qutip/qutip/pull/1787#issuecomment-1023383098:88,Testability,test,tests,88,On the other hand I'm not completely against just having this as a safety net for wonky tests anyway.,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1787#issuecomment-1023383098
https://github.com/qutip/qutip/pull/1787#issuecomment-1023399263:20,Safety,timeout,timeout,20,"This run will still timeout, as it was started before the fix.; Hopefully it will work on a rerun.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1787#issuecomment-1023399263
https://github.com/qutip/qutip/pull/1787#issuecomment-1028431140:36,Safety,timeout,timeout,36,Maybe macos needs a slightly longer timeout? It is a bit slow.,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1787#issuecomment-1028431140
https://github.com/qutip/qutip/pull/1787#issuecomment-1028481056:217,Safety,timeout,timeout,217,[![Coverage Status](https://coveralls.io/builds/46207692/badge)](https://coveralls.io/builds/46207692). Coverage decreased (-0.04%) to 68.373% when pulling **70743870eae1ee47e1f3229d846b99a51c0a708e on Ericgig:pytest.timeout** into **97f668227f35ab0a97dcb1ca5fbc14c060e7ac6a on qutip:master**.,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1787#issuecomment-1028481056
https://github.com/qutip/qutip/pull/1788#issuecomment-1172777496:253,Modifiability,refactor,refactoring,253,"Thanks a lot for awakening this PR from its slumber @hodgestar !. All the decorator `avg_gate_fidelity_test` does is to skip the decorated test on Mac. Looks like it has been removed in the following commit which is included in your merge, in favour of refactoring the AGF tests into a class and skipping the whole class on Mac: https://github.com/qutip/qutip/commit/99ce2d5c511e2487505a79455c9b53f7676a5731#diff-a9cd5a7620c34d60ffb61360a78bab270214a212c997e0c2cf5a6617443a90ab; (The decorator was originally introduced in https://github.com/qutip/qutip/pull/1034. The underlying issue https://github.com/qutip/qutip/issues/963 seems to be resolved, so maybe skipping the tests on Mac isn't necessary any more?). The only test that is included in my original PR, but not after your merge, is `test_average_gate_fidelity_against_legacy_implementation` at https://github.com/fhopfmueller/qutip/blob/74080688cbece61a3d095fa6fc9dd347114b6152/qutip/tests/core/test_metrics.py#L443. Would you like to include that test? On the one hand, it contains copy-pasted code from the previous implementation, so the test isn't exactly elegant. On the other hand, it ensures that the new implementation of this PR gives the same result as the previous correct implementation. I'd favor including it.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1788#issuecomment-1172777496
https://github.com/qutip/qutip/pull/1788#issuecomment-1172777496:139,Testability,test,test,139,"Thanks a lot for awakening this PR from its slumber @hodgestar !. All the decorator `avg_gate_fidelity_test` does is to skip the decorated test on Mac. Looks like it has been removed in the following commit which is included in your merge, in favour of refactoring the AGF tests into a class and skipping the whole class on Mac: https://github.com/qutip/qutip/commit/99ce2d5c511e2487505a79455c9b53f7676a5731#diff-a9cd5a7620c34d60ffb61360a78bab270214a212c997e0c2cf5a6617443a90ab; (The decorator was originally introduced in https://github.com/qutip/qutip/pull/1034. The underlying issue https://github.com/qutip/qutip/issues/963 seems to be resolved, so maybe skipping the tests on Mac isn't necessary any more?). The only test that is included in my original PR, but not after your merge, is `test_average_gate_fidelity_against_legacy_implementation` at https://github.com/fhopfmueller/qutip/blob/74080688cbece61a3d095fa6fc9dd347114b6152/qutip/tests/core/test_metrics.py#L443. Would you like to include that test? On the one hand, it contains copy-pasted code from the previous implementation, so the test isn't exactly elegant. On the other hand, it ensures that the new implementation of this PR gives the same result as the previous correct implementation. I'd favor including it.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1788#issuecomment-1172777496
https://github.com/qutip/qutip/pull/1788#issuecomment-1172777496:273,Testability,test,tests,273,"Thanks a lot for awakening this PR from its slumber @hodgestar !. All the decorator `avg_gate_fidelity_test` does is to skip the decorated test on Mac. Looks like it has been removed in the following commit which is included in your merge, in favour of refactoring the AGF tests into a class and skipping the whole class on Mac: https://github.com/qutip/qutip/commit/99ce2d5c511e2487505a79455c9b53f7676a5731#diff-a9cd5a7620c34d60ffb61360a78bab270214a212c997e0c2cf5a6617443a90ab; (The decorator was originally introduced in https://github.com/qutip/qutip/pull/1034. The underlying issue https://github.com/qutip/qutip/issues/963 seems to be resolved, so maybe skipping the tests on Mac isn't necessary any more?). The only test that is included in my original PR, but not after your merge, is `test_average_gate_fidelity_against_legacy_implementation` at https://github.com/fhopfmueller/qutip/blob/74080688cbece61a3d095fa6fc9dd347114b6152/qutip/tests/core/test_metrics.py#L443. Would you like to include that test? On the one hand, it contains copy-pasted code from the previous implementation, so the test isn't exactly elegant. On the other hand, it ensures that the new implementation of this PR gives the same result as the previous correct implementation. I'd favor including it.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1788#issuecomment-1172777496
https://github.com/qutip/qutip/pull/1788#issuecomment-1172777496:672,Testability,test,tests,672,"Thanks a lot for awakening this PR from its slumber @hodgestar !. All the decorator `avg_gate_fidelity_test` does is to skip the decorated test on Mac. Looks like it has been removed in the following commit which is included in your merge, in favour of refactoring the AGF tests into a class and skipping the whole class on Mac: https://github.com/qutip/qutip/commit/99ce2d5c511e2487505a79455c9b53f7676a5731#diff-a9cd5a7620c34d60ffb61360a78bab270214a212c997e0c2cf5a6617443a90ab; (The decorator was originally introduced in https://github.com/qutip/qutip/pull/1034. The underlying issue https://github.com/qutip/qutip/issues/963 seems to be resolved, so maybe skipping the tests on Mac isn't necessary any more?). The only test that is included in my original PR, but not after your merge, is `test_average_gate_fidelity_against_legacy_implementation` at https://github.com/fhopfmueller/qutip/blob/74080688cbece61a3d095fa6fc9dd347114b6152/qutip/tests/core/test_metrics.py#L443. Would you like to include that test? On the one hand, it contains copy-pasted code from the previous implementation, so the test isn't exactly elegant. On the other hand, it ensures that the new implementation of this PR gives the same result as the previous correct implementation. I'd favor including it.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1788#issuecomment-1172777496
https://github.com/qutip/qutip/pull/1788#issuecomment-1172777496:722,Testability,test,test,722,"Thanks a lot for awakening this PR from its slumber @hodgestar !. All the decorator `avg_gate_fidelity_test` does is to skip the decorated test on Mac. Looks like it has been removed in the following commit which is included in your merge, in favour of refactoring the AGF tests into a class and skipping the whole class on Mac: https://github.com/qutip/qutip/commit/99ce2d5c511e2487505a79455c9b53f7676a5731#diff-a9cd5a7620c34d60ffb61360a78bab270214a212c997e0c2cf5a6617443a90ab; (The decorator was originally introduced in https://github.com/qutip/qutip/pull/1034. The underlying issue https://github.com/qutip/qutip/issues/963 seems to be resolved, so maybe skipping the tests on Mac isn't necessary any more?). The only test that is included in my original PR, but not after your merge, is `test_average_gate_fidelity_against_legacy_implementation` at https://github.com/fhopfmueller/qutip/blob/74080688cbece61a3d095fa6fc9dd347114b6152/qutip/tests/core/test_metrics.py#L443. Would you like to include that test? On the one hand, it contains copy-pasted code from the previous implementation, so the test isn't exactly elegant. On the other hand, it ensures that the new implementation of this PR gives the same result as the previous correct implementation. I'd favor including it.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1788#issuecomment-1172777496
https://github.com/qutip/qutip/pull/1788#issuecomment-1172777496:944,Testability,test,tests,944,"Thanks a lot for awakening this PR from its slumber @hodgestar !. All the decorator `avg_gate_fidelity_test` does is to skip the decorated test on Mac. Looks like it has been removed in the following commit which is included in your merge, in favour of refactoring the AGF tests into a class and skipping the whole class on Mac: https://github.com/qutip/qutip/commit/99ce2d5c511e2487505a79455c9b53f7676a5731#diff-a9cd5a7620c34d60ffb61360a78bab270214a212c997e0c2cf5a6617443a90ab; (The decorator was originally introduced in https://github.com/qutip/qutip/pull/1034. The underlying issue https://github.com/qutip/qutip/issues/963 seems to be resolved, so maybe skipping the tests on Mac isn't necessary any more?). The only test that is included in my original PR, but not after your merge, is `test_average_gate_fidelity_against_legacy_implementation` at https://github.com/fhopfmueller/qutip/blob/74080688cbece61a3d095fa6fc9dd347114b6152/qutip/tests/core/test_metrics.py#L443. Would you like to include that test? On the one hand, it contains copy-pasted code from the previous implementation, so the test isn't exactly elegant. On the other hand, it ensures that the new implementation of this PR gives the same result as the previous correct implementation. I'd favor including it.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1788#issuecomment-1172777496
https://github.com/qutip/qutip/pull/1788#issuecomment-1172777496:1008,Testability,test,test,1008,"Thanks a lot for awakening this PR from its slumber @hodgestar !. All the decorator `avg_gate_fidelity_test` does is to skip the decorated test on Mac. Looks like it has been removed in the following commit which is included in your merge, in favour of refactoring the AGF tests into a class and skipping the whole class on Mac: https://github.com/qutip/qutip/commit/99ce2d5c511e2487505a79455c9b53f7676a5731#diff-a9cd5a7620c34d60ffb61360a78bab270214a212c997e0c2cf5a6617443a90ab; (The decorator was originally introduced in https://github.com/qutip/qutip/pull/1034. The underlying issue https://github.com/qutip/qutip/issues/963 seems to be resolved, so maybe skipping the tests on Mac isn't necessary any more?). The only test that is included in my original PR, but not after your merge, is `test_average_gate_fidelity_against_legacy_implementation` at https://github.com/fhopfmueller/qutip/blob/74080688cbece61a3d095fa6fc9dd347114b6152/qutip/tests/core/test_metrics.py#L443. Would you like to include that test? On the one hand, it contains copy-pasted code from the previous implementation, so the test isn't exactly elegant. On the other hand, it ensures that the new implementation of this PR gives the same result as the previous correct implementation. I'd favor including it.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1788#issuecomment-1172777496
https://github.com/qutip/qutip/pull/1788#issuecomment-1172777496:1101,Testability,test,test,1101,"Thanks a lot for awakening this PR from its slumber @hodgestar !. All the decorator `avg_gate_fidelity_test` does is to skip the decorated test on Mac. Looks like it has been removed in the following commit which is included in your merge, in favour of refactoring the AGF tests into a class and skipping the whole class on Mac: https://github.com/qutip/qutip/commit/99ce2d5c511e2487505a79455c9b53f7676a5731#diff-a9cd5a7620c34d60ffb61360a78bab270214a212c997e0c2cf5a6617443a90ab; (The decorator was originally introduced in https://github.com/qutip/qutip/pull/1034. The underlying issue https://github.com/qutip/qutip/issues/963 seems to be resolved, so maybe skipping the tests on Mac isn't necessary any more?). The only test that is included in my original PR, but not after your merge, is `test_average_gate_fidelity_against_legacy_implementation` at https://github.com/fhopfmueller/qutip/blob/74080688cbece61a3d095fa6fc9dd347114b6152/qutip/tests/core/test_metrics.py#L443. Would you like to include that test? On the one hand, it contains copy-pasted code from the previous implementation, so the test isn't exactly elegant. On the other hand, it ensures that the new implementation of this PR gives the same result as the previous correct implementation. I'd favor including it.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1788#issuecomment-1172777496
https://github.com/qutip/qutip/pull/1788#issuecomment-1172916163:55,Testability,test,test,55,@fhopfmueller Thanks for the help! I've added back the test. I also made a separate commit to remove skipping the tests on Mac OS. Let's see what happens.,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1788#issuecomment-1172916163
https://github.com/qutip/qutip/pull/1788#issuecomment-1172916163:114,Testability,test,tests,114,@fhopfmueller Thanks for the help! I've added back the test. I also made a separate commit to remove skipping the tests on Mac OS. Let's see what happens.,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1788#issuecomment-1172916163
https://github.com/qutip/qutip/pull/1788#issuecomment-1172958557:0,Testability,Test,Tests,0,Tests all pass on Mac OS now & the changes look good. Merging. Thanks @fhopfmueller.,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1788#issuecomment-1172958557
https://github.com/qutip/qutip/pull/1791#issuecomment-1028090347:12,Testability,test,test,12,"The failing test is a niche feature in coefficient compilation for which I expect very few users to want it (I used it for debugging /timing, but I can't think of any general use). I will look into it, it means that something changed with cython usage in python 3.10. But we can just remove it if it cause any problem.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1791#issuecomment-1028090347
https://github.com/qutip/qutip/pull/1791#issuecomment-1028096571:4,Availability,failure,failure,4,"The failure is because Python 3.10 started warning when importers like PyxImporter don't implement .find_spec. Maybe it is possible to work around it somehow. There is a `-W ignore::ImportWarning` that we add on Python 3.10 for this case, but for some reason it doesn't catch the warning here.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1791#issuecomment-1028096571
https://github.com/qutip/qutip/pull/1791#issuecomment-1028153738:216,Deployability,update,update-dev-major-ci-tests,216,[![Coverage Status](https://coveralls.io/builds/46168599/badge)](https://coveralls.io/builds/46168599). Coverage increased (+0.07%) to 65.687% when pulling **299f22bc6d2d57f572db0948fa1f0fbff32b8ed6 on hodgestar:fix/update-dev-major-ci-tests** into **0503eb03e2f1a53e747c21b99221d1d4adc1b833 on qutip:dev.major**.,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1791#issuecomment-1028153738
https://github.com/qutip/qutip/pull/1791#issuecomment-1028153738:236,Testability,test,tests,236,[![Coverage Status](https://coveralls.io/builds/46168599/badge)](https://coveralls.io/builds/46168599). Coverage increased (+0.07%) to 65.687% when pulling **299f22bc6d2d57f572db0948fa1f0fbff32b8ed6 on hodgestar:fix/update-dev-major-ci-tests** into **0503eb03e2f1a53e747c21b99221d1d4adc1b833 on qutip:dev.major**.,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1791#issuecomment-1028153738
https://github.com/qutip/qutip/pull/1793#issuecomment-1032599050:141,Deployability,release,release,141,"@Ericgig Contributors added!. Once this is merged, I can merge the commit into the 4.6.3 preparation branch and then I think we are ready to release.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1793#issuecomment-1032599050
https://github.com/qutip/qutip/pull/1797#issuecomment-1031669297:166,Availability,avail,available,166,"> Why is scipy 1.8 only used by the py3.10? I expected python3.9 defaults to use the latest scipy. Because only the 3.10 build uses conda-forge (i.e. SciPy 1.8 isn't available in the base anaconda repositories yet). > Doing it like this, the deprecation warning will be visible to the users, so we may have issues complaining about it but since 4.7 is coming soon, I think it's fine. Python runs with deprecation warnings ignored by default unless one specifies `-X dev` or similar. They only show up here because we run pytest with `-W error`.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1797#issuecomment-1031669297
https://github.com/qutip/qutip/pull/1797#issuecomment-1031669297:537,Availability,error,error,537,"> Why is scipy 1.8 only used by the py3.10? I expected python3.9 defaults to use the latest scipy. Because only the 3.10 build uses conda-forge (i.e. SciPy 1.8 isn't available in the base anaconda repositories yet). > Doing it like this, the deprecation warning will be visible to the users, so we may have issues complaining about it but since 4.7 is coming soon, I think it's fine. Python runs with deprecation warnings ignored by default unless one specifies `-X dev` or similar. They only show up here because we run pytest with `-W error`.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1797#issuecomment-1031669297
https://github.com/qutip/qutip/issues/1799#issuecomment-1035841538:11,Deployability,update,update,11,any answer/update?; Thanks,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1799#issuecomment-1035841538
https://github.com/qutip/qutip/issues/1800#issuecomment-1103429187:100,Availability,error,errors,100,"Yeah, I would think so too. Most of the times the energy gap is quite large compared to calculation errors.; But I'm really a newbie, so I'm not sure what the day-to-day users need. It would be great if a contributor could pitch in if this is a good idea.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1800#issuecomment-1103429187
https://github.com/qutip/qutip/issues/1800#issuecomment-1103429187:50,Energy Efficiency,energy,energy,50,"Yeah, I would think so too. Most of the times the energy gap is quite large compared to calculation errors.; But I'm really a newbie, so I'm not sure what the day-to-day users need. It would be great if a contributor could pitch in if this is a good idea.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1800#issuecomment-1103429187
https://github.com/qutip/qutip/issues/1801#issuecomment-1034893883:73,Integrability,depend,dependant,73,"Not in list format, but some solvers (`sesolve`, `mesolve` ) accept time-dependant Hamiltonian as a function returning a `Qobj`:; ```; H = lambda t, args: qutip.Qobj(my_array(t)); qutip.mesolve(H, ...); ```",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1801#issuecomment-1034893883
https://github.com/qutip/qutip/pull/1802#issuecomment-1035153689:238,Testability,assert,assertions,238,"> A possible addition could be to check the trace condition of the steady-state solution and throw a warning if it is violated more than some epsilon. But for now, everything looks good. @davidschlegel That's a good idea, so I added some assertions to all the tests where it was simple to do so.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1802#issuecomment-1035153689
https://github.com/qutip/qutip/pull/1802#issuecomment-1035153689:260,Testability,test,tests,260,"> A possible addition could be to check the trace condition of the steady-state solution and throw a warning if it is violated more than some epsilon. But for now, everything looks good. @davidschlegel That's a good idea, so I added some assertions to all the tests where it was simple to do so.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1802#issuecomment-1035153689
https://github.com/qutip/qutip/pull/1802#issuecomment-1035153689:279,Usability,simpl,simple,279,"> A possible addition could be to check the trace condition of the steady-state solution and throw a warning if it is violated more than some epsilon. But for now, everything looks good. @davidschlegel That's a good idea, so I added some assertions to all the tests where it was simple to do so.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1802#issuecomment-1035153689
https://github.com/qutip/qutip/issues/1803#issuecomment-1038576371:317,Availability,error,error,317,"@hodgestar Thanks for you help!. However, If I set `dims=[4, 4, 4]`, an issue with the initial state arises. I'm setting an initial state by converting from a regular array to a Qobj:. `psi_zero=Qobj(psi_initial,dims=[4,4,4],type='ket')`. If I set `dims=[4, 4, 4]` instead of ` [[4, 4, 4], [1, 1, 1]]`, I will get an error for the ket:. ```; File ""C:\Users\OlekAdmin\anaconda3\lib\site-packages\IPython\core\formatters.py"", line 345, in __call__; return method(). File ""C:\Users\OlekAdmin\anaconda3\lib\site-packages\qutip\qobj.py"", line 831, in _repr_latex_; t = self.type. File ""C:\Users\OlekAdmin\anaconda3\lib\site-packages\qutip\qobj.py"", line 2058, in type; self._type = type_from_dims(self.dims). File ""C:\Users\OlekAdmin\anaconda3\lib\site-packages\qutip\dimensions.py"", line 65, in type_from_dims; bra_like, ket_like = map(is_scalar, dims). ValueError: too many values to unpack (expected 2); ```. It seems that qutip requires dims to be a list of two lists, giving two dimensions for each particle.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1803#issuecomment-1038576371
https://github.com/qutip/qutip/issues/1803#issuecomment-1039340372:78,Availability,error,error,78,"Hi @BoxiLi . If I mix dimensions like that, I can add the gates, but I get an error about wrong dimensions when trying to run the circuit:. `psi_final_Q=qc.run(state=psi_zero)`. ```; Traceback (most recent call last):. File ""C:\Users\OlekAdmin\Documents\GitHub\NATS\ManojExperiment\Huse\David\RUC_David_comm.py"", line 461, in <module>; psi_final=qc.run(state=psi_zero). File ""C:\Users\OlekAdmin\anaconda3\lib\site-packages\qutip\qip\circuit.py"", line 1182, in run; sim = CircuitSimulator(self, state, cbits, U_list, measure_results,. File ""C:\Users\OlekAdmin\anaconda3\lib\site-packages\qutip\qip\circuit.py"", line 2004, in __init__; self.initialize(state, cbits, measure_results). File ""C:\Users\OlekAdmin\anaconda3\lib\site-packages\qutip\qip\circuit.py"", line 2114, in initialize; raise ValueError(""dimension of state is incorrect""). ValueError: dimension of state is incorrect; ```. PS This all works fine when state dimension is 2 instead of 4. PPS I can sidestep this error by manually constructing my 2-qudit gate as a 3-qudit (N-qudit in general) operator by tensoring it with the appropriate identity, and then applying this operator on my initial ket, but I'm afraid I'm losing a lot of efficiency by not using the quantum circuit functionality.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1803#issuecomment-1039340372
https://github.com/qutip/qutip/issues/1803#issuecomment-1039340372:974,Availability,error,error,974,"Hi @BoxiLi . If I mix dimensions like that, I can add the gates, but I get an error about wrong dimensions when trying to run the circuit:. `psi_final_Q=qc.run(state=psi_zero)`. ```; Traceback (most recent call last):. File ""C:\Users\OlekAdmin\Documents\GitHub\NATS\ManojExperiment\Huse\David\RUC_David_comm.py"", line 461, in <module>; psi_final=qc.run(state=psi_zero). File ""C:\Users\OlekAdmin\anaconda3\lib\site-packages\qutip\qip\circuit.py"", line 1182, in run; sim = CircuitSimulator(self, state, cbits, U_list, measure_results,. File ""C:\Users\OlekAdmin\anaconda3\lib\site-packages\qutip\qip\circuit.py"", line 2004, in __init__; self.initialize(state, cbits, measure_results). File ""C:\Users\OlekAdmin\anaconda3\lib\site-packages\qutip\qip\circuit.py"", line 2114, in initialize; raise ValueError(""dimension of state is incorrect""). ValueError: dimension of state is incorrect; ```. PS This all works fine when state dimension is 2 instead of 4. PPS I can sidestep this error by manually constructing my 2-qudit gate as a 3-qudit (N-qudit in general) operator by tensoring it with the appropriate identity, and then applying this operator on my initial ket, but I'm afraid I'm losing a lot of efficiency by not using the quantum circuit functionality.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1803#issuecomment-1039340372
https://github.com/qutip/qutip/issues/1803#issuecomment-1039660650:50,Availability,error,error,50,"Hi @ALasek . You are right, there is a bug in the error handling.; ```; File ""C:\Users\OlekAdmin\anaconda3\lib\site-packages\qutip\qip\circuit.py"", line 2114, in initialize; raise ValueError(""dimension of state is incorrect""); ```; This check is wrong. It assumes that the state is a qubits state. Our test didn't cover the `run` method with multi-level systems. Here are the ways around:; - If you know how to hack the package, you can simply find the file and delete this error handling (lines 2113 and 2114).; - If you don't know how to do that, you can also use; ```; gate_sequence_product(qc.propagators()); ```; to compute the unitary representation of the circuit first and then apply it to the input state. I'll make a bug fix soon. But the next release may still take a while. Using `QubitCirucuit` for qutrits and qudits should be fine, it is rarely used though. So there might be bugs that are uncovered by our test. If you encounter any further questions, feel free to ask!",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1803#issuecomment-1039660650
https://github.com/qutip/qutip/issues/1803#issuecomment-1039660650:474,Availability,error,error,474,"Hi @ALasek . You are right, there is a bug in the error handling.; ```; File ""C:\Users\OlekAdmin\anaconda3\lib\site-packages\qutip\qip\circuit.py"", line 2114, in initialize; raise ValueError(""dimension of state is incorrect""); ```; This check is wrong. It assumes that the state is a qubits state. Our test didn't cover the `run` method with multi-level systems. Here are the ways around:; - If you know how to hack the package, you can simply find the file and delete this error handling (lines 2113 and 2114).; - If you don't know how to do that, you can also use; ```; gate_sequence_product(qc.propagators()); ```; to compute the unitary representation of the circuit first and then apply it to the input state. I'll make a bug fix soon. But the next release may still take a while. Using `QubitCirucuit` for qutrits and qudits should be fine, it is rarely used though. So there might be bugs that are uncovered by our test. If you encounter any further questions, feel free to ask!",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1803#issuecomment-1039660650
https://github.com/qutip/qutip/issues/1803#issuecomment-1039660650:754,Deployability,release,release,754,"Hi @ALasek . You are right, there is a bug in the error handling.; ```; File ""C:\Users\OlekAdmin\anaconda3\lib\site-packages\qutip\qip\circuit.py"", line 2114, in initialize; raise ValueError(""dimension of state is incorrect""); ```; This check is wrong. It assumes that the state is a qubits state. Our test didn't cover the `run` method with multi-level systems. Here are the ways around:; - If you know how to hack the package, you can simply find the file and delete this error handling (lines 2113 and 2114).; - If you don't know how to do that, you can also use; ```; gate_sequence_product(qc.propagators()); ```; to compute the unitary representation of the circuit first and then apply it to the input state. I'll make a bug fix soon. But the next release may still take a while. Using `QubitCirucuit` for qutrits and qudits should be fine, it is rarely used though. So there might be bugs that are uncovered by our test. If you encounter any further questions, feel free to ask!",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1803#issuecomment-1039660650
https://github.com/qutip/qutip/issues/1803#issuecomment-1039660650:302,Testability,test,test,302,"Hi @ALasek . You are right, there is a bug in the error handling.; ```; File ""C:\Users\OlekAdmin\anaconda3\lib\site-packages\qutip\qip\circuit.py"", line 2114, in initialize; raise ValueError(""dimension of state is incorrect""); ```; This check is wrong. It assumes that the state is a qubits state. Our test didn't cover the `run` method with multi-level systems. Here are the ways around:; - If you know how to hack the package, you can simply find the file and delete this error handling (lines 2113 and 2114).; - If you don't know how to do that, you can also use; ```; gate_sequence_product(qc.propagators()); ```; to compute the unitary representation of the circuit first and then apply it to the input state. I'll make a bug fix soon. But the next release may still take a while. Using `QubitCirucuit` for qutrits and qudits should be fine, it is rarely used though. So there might be bugs that are uncovered by our test. If you encounter any further questions, feel free to ask!",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1803#issuecomment-1039660650
https://github.com/qutip/qutip/issues/1803#issuecomment-1039660650:922,Testability,test,test,922,"Hi @ALasek . You are right, there is a bug in the error handling.; ```; File ""C:\Users\OlekAdmin\anaconda3\lib\site-packages\qutip\qip\circuit.py"", line 2114, in initialize; raise ValueError(""dimension of state is incorrect""); ```; This check is wrong. It assumes that the state is a qubits state. Our test didn't cover the `run` method with multi-level systems. Here are the ways around:; - If you know how to hack the package, you can simply find the file and delete this error handling (lines 2113 and 2114).; - If you don't know how to do that, you can also use; ```; gate_sequence_product(qc.propagators()); ```; to compute the unitary representation of the circuit first and then apply it to the input state. I'll make a bug fix soon. But the next release may still take a while. Using `QubitCirucuit` for qutrits and qudits should be fine, it is rarely used though. So there might be bugs that are uncovered by our test. If you encounter any further questions, feel free to ask!",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1803#issuecomment-1039660650
https://github.com/qutip/qutip/issues/1803#issuecomment-1039660650:437,Usability,simpl,simply,437,"Hi @ALasek . You are right, there is a bug in the error handling.; ```; File ""C:\Users\OlekAdmin\anaconda3\lib\site-packages\qutip\qip\circuit.py"", line 2114, in initialize; raise ValueError(""dimension of state is incorrect""); ```; This check is wrong. It assumes that the state is a qubits state. Our test didn't cover the `run` method with multi-level systems. Here are the ways around:; - If you know how to hack the package, you can simply find the file and delete this error handling (lines 2113 and 2114).; - If you don't know how to do that, you can also use; ```; gate_sequence_product(qc.propagators()); ```; to compute the unitary representation of the circuit first and then apply it to the input state. I'll make a bug fix soon. But the next release may still take a while. Using `QubitCirucuit` for qutrits and qudits should be fine, it is rarely used though. So there might be bugs that are uncovered by our test. If you encounter any further questions, feel free to ask!",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1803#issuecomment-1039660650
https://github.com/qutip/qutip/issues/1803#issuecomment-1040626038:38,Availability,error,error,38,"@BoxiLi . Thanks, I've commented this error check out of circuit.py, and am able to run my program now!",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1803#issuecomment-1040626038
https://github.com/qutip/qutip/issues/1804#issuecomment-1041471668:313,Modifiability,variab,variable,313,"It would be (for now):; ```; options = qt.solver.options.SolverOptions(store_states=True); solver = MeSolver(H, options=options); ```; `SolverResultsOptions` is not used directly but is contained in `SolverOptions`. While I expect verner method to work with tensorflow, there is still no way to pass a tensorflow variable as a coefficient in a QobjEvo yet, so autodiff will not work.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1804#issuecomment-1041471668
https://github.com/qutip/qutip/pull/1805#issuecomment-1042865561:51,Testability,test,tests,51,I am happy to merge it as it is but note that _the tests do not serve to catch the bug!_ I am not sure how to test it properly though.,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1805#issuecomment-1042865561
https://github.com/qutip/qutip/pull/1805#issuecomment-1042865561:110,Testability,test,test,110,I am happy to merge it as it is but note that _the tests do not serve to catch the bug!_ I am not sure how to test it properly though.,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1805#issuecomment-1042865561
https://github.com/qutip/qutip/issues/1806#issuecomment-1042493241:414,Usability,guid,guide,414,"hi amrit,. correlation_2op_1t() calculates the correlation function based on the steady-state of the Hamiltonian+collapse operators you provide, it doesn't take an initial condition as input (the steady-state will the the same irrespective of the initial condition of the qubit). For non-steady state correlations and spectrum, I think what is described here might be what you need:; https://qutip.org/docs/latest/guide/guide-correlation.html#non-steadystate-correlation-function. This kind of question is probably better to ask in the QuTiP mailing list, https://groups.google.com/g/qutip; you will receive a wider range of responses there, so I am going to close this issue. If you find some problem with the above approach that you think is a code bug, feel free to reopen it.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1806#issuecomment-1042493241
https://github.com/qutip/qutip/issues/1806#issuecomment-1042493241:420,Usability,guid,guide-correlation,420,"hi amrit,. correlation_2op_1t() calculates the correlation function based on the steady-state of the Hamiltonian+collapse operators you provide, it doesn't take an initial condition as input (the steady-state will the the same irrespective of the initial condition of the qubit). For non-steady state correlations and spectrum, I think what is described here might be what you need:; https://qutip.org/docs/latest/guide/guide-correlation.html#non-steadystate-correlation-function. This kind of question is probably better to ask in the QuTiP mailing list, https://groups.google.com/g/qutip; you will receive a wider range of responses there, so I am going to close this issue. If you find some problem with the above approach that you think is a code bug, feel free to reopen it.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1806#issuecomment-1042493241
https://github.com/qutip/qutip/issues/1808#issuecomment-1146815109:123,Testability,test,tests,123,Hello @Ericgig. I'm participating in the unitary hack. This looks like a good issue to start in qutip. Is necessary to add tests for `correalation.py ` once the function ` correlation_me_2t` has been changed? . Thanks!,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1808#issuecomment-1146815109
https://github.com/qutip/qutip/issues/1808#issuecomment-1147521055:158,Testability,test,test,158,"Hi @victor-onofre, I don't think that this issue has a bounty for the unitary hack, but we would be grateful if you want to tackle it.; Yes, if you can add a test that would have failed but is now passing, it would be great. Also, I believe the same bug can be found in `_correlation_me_2t`, which should also be fixed.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1808#issuecomment-1147521055
https://github.com/qutip/qutip/issues/1808#issuecomment-1147586148:136,Testability,test,test,136,"Hi @victor-onofre @Ericgig . As far as I understand it, the only change needed is a single line in correlation_me_2t, as shown above. A test to show what the function should do, and how it currently does not work correctly, is shown in the code above. I've not attempted to 'solve' this issue further myself for the following 2 reasons:. 1) I'm not a theorist. I've discussed this with colleagues (as also mentioned above) but I'd like to have someone check this proposed change makes sense, preferably someone who knows why the code currently is what it is, maybe there is a reason for it?. 2) I'm unfamiliar with how github works, I've only used it for version control on private projects, so I actually don't know what to do to 'merge' the proposed changes into the code. On the other hand, I have been using qutip with the change suggested above, and as far as I can tell, for my use case, it works well.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1808#issuecomment-1147586148
https://github.com/qutip/qutip/issues/1808#issuecomment-1148761424:189,Integrability,depend,dependent,189,"This is definitely a bug. Looking at correlation.py it looks like _transform_L_t_shift_new() and _args[""_t0""] = tlist[t_idx] are supposed to take care of this, but it seems broken for time-dependent collapse operators for two reasons. 1) _args[""_t0""] = tlist[t_idx] is only set if H is time-dependent, not if the c_ops are. 2) The parsing of the c_ops list in _transform_shift_one_op() is a bit broken (it seems to expect [[c,func]] to be one list deeper or something like that?). I am wondering if the above proposed fix of just shifting tlist in the mesolve() call might clash with (potentially) working code for time-dependent Hamiltonians and introduce a new bug in that case? It could perhaps better to fix the existing functionality by fixing the two issues above. On the other hand, that existing functionality is fairly clunky..... any reason not just to ditch it all and have the shifted tlist in mesolve for all cases?",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1808#issuecomment-1148761424
https://github.com/qutip/qutip/issues/1808#issuecomment-1148761424:291,Integrability,depend,dependent,291,"This is definitely a bug. Looking at correlation.py it looks like _transform_L_t_shift_new() and _args[""_t0""] = tlist[t_idx] are supposed to take care of this, but it seems broken for time-dependent collapse operators for two reasons. 1) _args[""_t0""] = tlist[t_idx] is only set if H is time-dependent, not if the c_ops are. 2) The parsing of the c_ops list in _transform_shift_one_op() is a bit broken (it seems to expect [[c,func]] to be one list deeper or something like that?). I am wondering if the above proposed fix of just shifting tlist in the mesolve() call might clash with (potentially) working code for time-dependent Hamiltonians and introduce a new bug in that case? It could perhaps better to fix the existing functionality by fixing the two issues above. On the other hand, that existing functionality is fairly clunky..... any reason not just to ditch it all and have the shifted tlist in mesolve for all cases?",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1808#issuecomment-1148761424
https://github.com/qutip/qutip/issues/1808#issuecomment-1148761424:620,Integrability,depend,dependent,620,"This is definitely a bug. Looking at correlation.py it looks like _transform_L_t_shift_new() and _args[""_t0""] = tlist[t_idx] are supposed to take care of this, but it seems broken for time-dependent collapse operators for two reasons. 1) _args[""_t0""] = tlist[t_idx] is only set if H is time-dependent, not if the c_ops are. 2) The parsing of the c_ops list in _transform_shift_one_op() is a bit broken (it seems to expect [[c,func]] to be one list deeper or something like that?). I am wondering if the above proposed fix of just shifting tlist in the mesolve() call might clash with (potentially) working code for time-dependent Hamiltonians and introduce a new bug in that case? It could perhaps better to fix the existing functionality by fixing the two issues above. On the other hand, that existing functionality is fairly clunky..... any reason not just to ditch it all and have the shifted tlist in mesolve for all cases?",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1808#issuecomment-1148761424
https://github.com/qutip/qutip/issues/1808#issuecomment-1149861067:164,Availability,down,down,164,"Hi @Ericgig, @AFvanloo, and @nwlambert, this bug has become more interested. Thanks for all the comments and suggestions. I will be busy this week, but I will dive down into the functions and propose a good solution during the weekend. It looks that the solution @nwlambert is proposing is the best one but I want to check if there is something else to do here. . Thanks!",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1808#issuecomment-1149861067
https://github.com/qutip/qutip/issues/1809#issuecomment-1043028427:237,Availability,down,downgrading,237,"I think that the rendering is executed through the Visual Studio extension called ""[Jupyter Notebook Renderers](https://marketplace.visualstudio.com/items?itemName=ms-toolsai.jupyter-renderers)"". I apparently solved this issue by simply downgrading the version of this extension, since I read in the changelog of the latest version ""Removed rendering of text/latex in favor of built-in support."". Thus the problem was in the Visual Studio part, however it still remain opened in the case one decide to install the latest version of this extension. Thank you.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1809#issuecomment-1043028427
https://github.com/qutip/qutip/issues/1809#issuecomment-1043028427:502,Deployability,install,install,502,"I think that the rendering is executed through the Visual Studio extension called ""[Jupyter Notebook Renderers](https://marketplace.visualstudio.com/items?itemName=ms-toolsai.jupyter-renderers)"". I apparently solved this issue by simply downgrading the version of this extension, since I read in the changelog of the latest version ""Removed rendering of text/latex in favor of built-in support."". Thus the problem was in the Visual Studio part, however it still remain opened in the case one decide to install the latest version of this extension. Thank you.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1809#issuecomment-1043028427
https://github.com/qutip/qutip/issues/1809#issuecomment-1043028427:230,Usability,simpl,simply,230,"I think that the rendering is executed through the Visual Studio extension called ""[Jupyter Notebook Renderers](https://marketplace.visualstudio.com/items?itemName=ms-toolsai.jupyter-renderers)"". I apparently solved this issue by simply downgrading the version of this extension, since I read in the changelog of the latest version ""Removed rendering of text/latex in favor of built-in support."". Thus the problem was in the Visual Studio part, however it still remain opened in the case one decide to install the latest version of this extension. Thank you.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1809#issuecomment-1043028427
https://github.com/qutip/qutip/issues/1809#issuecomment-1043051695:139,Availability,avail,available,139,"@albertomercurio Do you know if there is documentation of how the built-in support works somewhere? Perhaps the ""built-in"" support is only available in some newer version of Visual Studio? Or it has a bug? Or just works a bit differently?. Thank you for filing this issue -- I'm sure other Visual Studio users will encounter it too and hopefully this discussion will help even if the fix ends up being elsewhere.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1809#issuecomment-1043051695
https://github.com/qutip/qutip/issues/1809#issuecomment-1633135302:246,Availability,down,downgrading,246,"> I think that the rendering is executed through the Visual Studio extension called ""[Jupyter Notebook Renderers](https://marketplace.visualstudio.com/items?itemName=ms-toolsai.jupyter-renderers)"".; > ; > I apparently solved this issue by simply downgrading the version of this extension, since I read in the changelog of the latest version ""Removed rendering of text/latex in favor of built-in support."". Thus the problem was in the Visual Studio part, however it still remain opened in the case one decide to install the latest version of this extension.; > ; > Thank you. Thank you so much for sharing this!. The cell outputs that included Qobj with Latex code wasn't rendering properly for me just like your issue (although Latex code in the Markdown cells was rendering correctly). I spent hours and tried countless online suggestions to fix the issue with no success, until I re-installed the the 'Jupyter Notebook 'Renderers' extension to the old version (v1.0.4) before it removed the latex support. Now I have the option to 'change presentation' of the output cells so it uses the old version of the extension, and now it finally displays the output with the Latex rendered correctly!. Thank you again for suggesting the only solution that worked for me.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1809#issuecomment-1633135302
https://github.com/qutip/qutip/issues/1809#issuecomment-1633135302:511,Deployability,install,install,511,"> I think that the rendering is executed through the Visual Studio extension called ""[Jupyter Notebook Renderers](https://marketplace.visualstudio.com/items?itemName=ms-toolsai.jupyter-renderers)"".; > ; > I apparently solved this issue by simply downgrading the version of this extension, since I read in the changelog of the latest version ""Removed rendering of text/latex in favor of built-in support."". Thus the problem was in the Visual Studio part, however it still remain opened in the case one decide to install the latest version of this extension.; > ; > Thank you. Thank you so much for sharing this!. The cell outputs that included Qobj with Latex code wasn't rendering properly for me just like your issue (although Latex code in the Markdown cells was rendering correctly). I spent hours and tried countless online suggestions to fix the issue with no success, until I re-installed the the 'Jupyter Notebook 'Renderers' extension to the old version (v1.0.4) before it removed the latex support. Now I have the option to 'change presentation' of the output cells so it uses the old version of the extension, and now it finally displays the output with the Latex rendered correctly!. Thank you again for suggesting the only solution that worked for me.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1809#issuecomment-1633135302
https://github.com/qutip/qutip/issues/1809#issuecomment-1633135302:885,Deployability,install,installed,885,"> I think that the rendering is executed through the Visual Studio extension called ""[Jupyter Notebook Renderers](https://marketplace.visualstudio.com/items?itemName=ms-toolsai.jupyter-renderers)"".; > ; > I apparently solved this issue by simply downgrading the version of this extension, since I read in the changelog of the latest version ""Removed rendering of text/latex in favor of built-in support."". Thus the problem was in the Visual Studio part, however it still remain opened in the case one decide to install the latest version of this extension.; > ; > Thank you. Thank you so much for sharing this!. The cell outputs that included Qobj with Latex code wasn't rendering properly for me just like your issue (although Latex code in the Markdown cells was rendering correctly). I spent hours and tried countless online suggestions to fix the issue with no success, until I re-installed the the 'Jupyter Notebook 'Renderers' extension to the old version (v1.0.4) before it removed the latex support. Now I have the option to 'change presentation' of the output cells so it uses the old version of the extension, and now it finally displays the output with the Latex rendered correctly!. Thank you again for suggesting the only solution that worked for me.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1809#issuecomment-1633135302
https://github.com/qutip/qutip/issues/1809#issuecomment-1633135302:239,Usability,simpl,simply,239,"> I think that the rendering is executed through the Visual Studio extension called ""[Jupyter Notebook Renderers](https://marketplace.visualstudio.com/items?itemName=ms-toolsai.jupyter-renderers)"".; > ; > I apparently solved this issue by simply downgrading the version of this extension, since I read in the changelog of the latest version ""Removed rendering of text/latex in favor of built-in support."". Thus the problem was in the Visual Studio part, however it still remain opened in the case one decide to install the latest version of this extension.; > ; > Thank you. Thank you so much for sharing this!. The cell outputs that included Qobj with Latex code wasn't rendering properly for me just like your issue (although Latex code in the Markdown cells was rendering correctly). I spent hours and tried countless online suggestions to fix the issue with no success, until I re-installed the the 'Jupyter Notebook 'Renderers' extension to the old version (v1.0.4) before it removed the latex support. Now I have the option to 'change presentation' of the output cells so it uses the old version of the extension, and now it finally displays the output with the Latex rendered correctly!. Thank you again for suggesting the only solution that worked for me.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1809#issuecomment-1633135302
https://github.com/qutip/qutip/issues/1810#issuecomment-1043525004:66,Availability,error,error,66,"@AFvanloo Could you explain a little more what you are doing? The error appears to have been generated by an attempt to recompile `qutip.cy.openmp.parfuncs` without openmp installed, which is unlikely to have happened unless something is attempting to rebuild every cython or cpp file and ignoring qutip's `setup.py`. I also see `pyrex` in your path. The last stable release of `pyrex` was in 2010 and as far as I know it is still inactive. I am not sure what advice to give yet, but I am curious about what is going on. :)",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1810#issuecomment-1043525004
https://github.com/qutip/qutip/issues/1810#issuecomment-1043525004:172,Deployability,install,installed,172,"@AFvanloo Could you explain a little more what you are doing? The error appears to have been generated by an attempt to recompile `qutip.cy.openmp.parfuncs` without openmp installed, which is unlikely to have happened unless something is attempting to rebuild every cython or cpp file and ignoring qutip's `setup.py`. I also see `pyrex` in your path. The last stable release of `pyrex` was in 2010 and as far as I know it is still inactive. I am not sure what advice to give yet, but I am curious about what is going on. :)",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1810#issuecomment-1043525004
https://github.com/qutip/qutip/issues/1810#issuecomment-1043525004:367,Deployability,release,release,367,"@AFvanloo Could you explain a little more what you are doing? The error appears to have been generated by an attempt to recompile `qutip.cy.openmp.parfuncs` without openmp installed, which is unlikely to have happened unless something is attempting to rebuild every cython or cpp file and ignoring qutip's `setup.py`. I also see `pyrex` in your path. The last stable release of `pyrex` was in 2010 and as far as I know it is still inactive. I am not sure what advice to give yet, but I am curious about what is going on. :)",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1810#issuecomment-1043525004
https://github.com/qutip/qutip/issues/1810#issuecomment-1044657281:85,Availability,error,error,85,"I'll try to explain as much as I can, but I'm not sure exactly what is going on. The error might have been there for quite a while, it was not until I recently tried to modify qutip regarding the other issue I raised that I noticed that changes I made had no effect because qutip was not compiling. Earlier today I did manage to get changes to qutip to register and work, but I still get this error on reload. Maybe it no longer matters. While pyrex is in the path, it seems to not be installed. (I cannot import or uninstall it). I can also not remember installing openMP, although I'm not sure if openMP capability comes with gcc by default. . This issue is likely something strange with my exact installation. What has me confused is that re-installing the packages does not seem to solve anything. Apologies for the unclear explanation. If there is any specific information I can add, please tell me what I can do. My qutip.about() is:. QuTiP Version: 4.6.3; Numpy Version: 1.22.2; Scipy Version: 1.8.0; Cython Version: 0.29.27; Matplotlib Version: 3.5.1; Python Version: 3.8.10; Number of CPUs: 8; BLAS Info: OPENBLAS; OPENMP Installed: False; INTEL MKL Ext: False; Platform Info: Linux (x86_64)",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1810#issuecomment-1044657281
https://github.com/qutip/qutip/issues/1810#issuecomment-1044657281:393,Availability,error,error,393,"I'll try to explain as much as I can, but I'm not sure exactly what is going on. The error might have been there for quite a while, it was not until I recently tried to modify qutip regarding the other issue I raised that I noticed that changes I made had no effect because qutip was not compiling. Earlier today I did manage to get changes to qutip to register and work, but I still get this error on reload. Maybe it no longer matters. While pyrex is in the path, it seems to not be installed. (I cannot import or uninstall it). I can also not remember installing openMP, although I'm not sure if openMP capability comes with gcc by default. . This issue is likely something strange with my exact installation. What has me confused is that re-installing the packages does not seem to solve anything. Apologies for the unclear explanation. If there is any specific information I can add, please tell me what I can do. My qutip.about() is:. QuTiP Version: 4.6.3; Numpy Version: 1.22.2; Scipy Version: 1.8.0; Cython Version: 0.29.27; Matplotlib Version: 3.5.1; Python Version: 3.8.10; Number of CPUs: 8; BLAS Info: OPENBLAS; OPENMP Installed: False; INTEL MKL Ext: False; Platform Info: Linux (x86_64)",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1810#issuecomment-1044657281
https://github.com/qutip/qutip/issues/1810#issuecomment-1044657281:485,Deployability,install,installed,485,"I'll try to explain as much as I can, but I'm not sure exactly what is going on. The error might have been there for quite a while, it was not until I recently tried to modify qutip regarding the other issue I raised that I noticed that changes I made had no effect because qutip was not compiling. Earlier today I did manage to get changes to qutip to register and work, but I still get this error on reload. Maybe it no longer matters. While pyrex is in the path, it seems to not be installed. (I cannot import or uninstall it). I can also not remember installing openMP, although I'm not sure if openMP capability comes with gcc by default. . This issue is likely something strange with my exact installation. What has me confused is that re-installing the packages does not seem to solve anything. Apologies for the unclear explanation. If there is any specific information I can add, please tell me what I can do. My qutip.about() is:. QuTiP Version: 4.6.3; Numpy Version: 1.22.2; Scipy Version: 1.8.0; Cython Version: 0.29.27; Matplotlib Version: 3.5.1; Python Version: 3.8.10; Number of CPUs: 8; BLAS Info: OPENBLAS; OPENMP Installed: False; INTEL MKL Ext: False; Platform Info: Linux (x86_64)",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1810#issuecomment-1044657281
https://github.com/qutip/qutip/issues/1810#issuecomment-1044657281:555,Deployability,install,installing,555,"I'll try to explain as much as I can, but I'm not sure exactly what is going on. The error might have been there for quite a while, it was not until I recently tried to modify qutip regarding the other issue I raised that I noticed that changes I made had no effect because qutip was not compiling. Earlier today I did manage to get changes to qutip to register and work, but I still get this error on reload. Maybe it no longer matters. While pyrex is in the path, it seems to not be installed. (I cannot import or uninstall it). I can also not remember installing openMP, although I'm not sure if openMP capability comes with gcc by default. . This issue is likely something strange with my exact installation. What has me confused is that re-installing the packages does not seem to solve anything. Apologies for the unclear explanation. If there is any specific information I can add, please tell me what I can do. My qutip.about() is:. QuTiP Version: 4.6.3; Numpy Version: 1.22.2; Scipy Version: 1.8.0; Cython Version: 0.29.27; Matplotlib Version: 3.5.1; Python Version: 3.8.10; Number of CPUs: 8; BLAS Info: OPENBLAS; OPENMP Installed: False; INTEL MKL Ext: False; Platform Info: Linux (x86_64)",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1810#issuecomment-1044657281
https://github.com/qutip/qutip/issues/1810#issuecomment-1044657281:699,Deployability,install,installation,699,"I'll try to explain as much as I can, but I'm not sure exactly what is going on. The error might have been there for quite a while, it was not until I recently tried to modify qutip regarding the other issue I raised that I noticed that changes I made had no effect because qutip was not compiling. Earlier today I did manage to get changes to qutip to register and work, but I still get this error on reload. Maybe it no longer matters. While pyrex is in the path, it seems to not be installed. (I cannot import or uninstall it). I can also not remember installing openMP, although I'm not sure if openMP capability comes with gcc by default. . This issue is likely something strange with my exact installation. What has me confused is that re-installing the packages does not seem to solve anything. Apologies for the unclear explanation. If there is any specific information I can add, please tell me what I can do. My qutip.about() is:. QuTiP Version: 4.6.3; Numpy Version: 1.22.2; Scipy Version: 1.8.0; Cython Version: 0.29.27; Matplotlib Version: 3.5.1; Python Version: 3.8.10; Number of CPUs: 8; BLAS Info: OPENBLAS; OPENMP Installed: False; INTEL MKL Ext: False; Platform Info: Linux (x86_64)",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1810#issuecomment-1044657281
https://github.com/qutip/qutip/issues/1810#issuecomment-1044657281:745,Deployability,install,installing,745,"I'll try to explain as much as I can, but I'm not sure exactly what is going on. The error might have been there for quite a while, it was not until I recently tried to modify qutip regarding the other issue I raised that I noticed that changes I made had no effect because qutip was not compiling. Earlier today I did manage to get changes to qutip to register and work, but I still get this error on reload. Maybe it no longer matters. While pyrex is in the path, it seems to not be installed. (I cannot import or uninstall it). I can also not remember installing openMP, although I'm not sure if openMP capability comes with gcc by default. . This issue is likely something strange with my exact installation. What has me confused is that re-installing the packages does not seem to solve anything. Apologies for the unclear explanation. If there is any specific information I can add, please tell me what I can do. My qutip.about() is:. QuTiP Version: 4.6.3; Numpy Version: 1.22.2; Scipy Version: 1.8.0; Cython Version: 0.29.27; Matplotlib Version: 3.5.1; Python Version: 3.8.10; Number of CPUs: 8; BLAS Info: OPENBLAS; OPENMP Installed: False; INTEL MKL Ext: False; Platform Info: Linux (x86_64)",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1810#issuecomment-1044657281
https://github.com/qutip/qutip/issues/1810#issuecomment-1044657281:1131,Deployability,Install,Installed,1131,"I'll try to explain as much as I can, but I'm not sure exactly what is going on. The error might have been there for quite a while, it was not until I recently tried to modify qutip regarding the other issue I raised that I noticed that changes I made had no effect because qutip was not compiling. Earlier today I did manage to get changes to qutip to register and work, but I still get this error on reload. Maybe it no longer matters. While pyrex is in the path, it seems to not be installed. (I cannot import or uninstall it). I can also not remember installing openMP, although I'm not sure if openMP capability comes with gcc by default. . This issue is likely something strange with my exact installation. What has me confused is that re-installing the packages does not seem to solve anything. Apologies for the unclear explanation. If there is any specific information I can add, please tell me what I can do. My qutip.about() is:. QuTiP Version: 4.6.3; Numpy Version: 1.22.2; Scipy Version: 1.8.0; Cython Version: 0.29.27; Matplotlib Version: 3.5.1; Python Version: 3.8.10; Number of CPUs: 8; BLAS Info: OPENBLAS; OPENMP Installed: False; INTEL MKL Ext: False; Platform Info: Linux (x86_64)",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1810#issuecomment-1044657281
https://github.com/qutip/qutip/issues/1810#issuecomment-1046868194:402,Deployability,install,installation,402,"@AFvanloo My wild guess about what has happened is:. 1. You modified QuTiP's source files.; 2. When the files are modified, the `reload` functionality you are using attempts to recompile the Cython files in a strange way. There is nothing wrong with modifying QuTiP, but I would suggest first trying to compile an unmodified QuTiP in the ordinary way -- e.g. by following https://qutip.org/docs/latest/installation.html#installing-from-source. Then, once that is working, you can modify the source code and recompile in the same way. I'm going to close this issue for now since it doesn't seem like a bug, but please feel free to keep asking questions in this issue or on the mailing list. If you have an new feature you'd like to add, you can also open an issue specifically for it and we can discuss that separately (and if you like you can submit a pull request with the change you want).",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1810#issuecomment-1046868194
https://github.com/qutip/qutip/issues/1810#issuecomment-1046868194:420,Deployability,install,installing-from-source,420,"@AFvanloo My wild guess about what has happened is:. 1. You modified QuTiP's source files.; 2. When the files are modified, the `reload` functionality you are using attempts to recompile the Cython files in a strange way. There is nothing wrong with modifying QuTiP, but I would suggest first trying to compile an unmodified QuTiP in the ordinary way -- e.g. by following https://qutip.org/docs/latest/installation.html#installing-from-source. Then, once that is working, you can modify the source code and recompile in the same way. I'm going to close this issue for now since it doesn't seem like a bug, but please feel free to keep asking questions in this issue or on the mailing list. If you have an new feature you'd like to add, you can also open an issue specifically for it and we can discuss that separately (and if you like you can submit a pull request with the change you want).",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1810#issuecomment-1046868194
https://github.com/qutip/qutip/issues/1810#issuecomment-1046958786:196,Availability,error,error,196,"It was during fixing/changing the behaviour shown in 1808 that I first saw the issue. It seems now that I can change the qutip code, and to some degree at least it does compile, but the mentioned error still shows up in the terminal on running reload(qutip). Its likely that the error was there before I started modifying any files, and that I did not happen to spot it between all the lines jupyter tends to print in the terminal. It also shows up on my system after I force a fresh installation of qutip with no changes. It does not currently seem to stop me from doing anything, but I don't know what causes it.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1810#issuecomment-1046958786
https://github.com/qutip/qutip/issues/1810#issuecomment-1046958786:279,Availability,error,error,279,"It was during fixing/changing the behaviour shown in 1808 that I first saw the issue. It seems now that I can change the qutip code, and to some degree at least it does compile, but the mentioned error still shows up in the terminal on running reload(qutip). Its likely that the error was there before I started modifying any files, and that I did not happen to spot it between all the lines jupyter tends to print in the terminal. It also shows up on my system after I force a fresh installation of qutip with no changes. It does not currently seem to stop me from doing anything, but I don't know what causes it.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1810#issuecomment-1046958786
https://github.com/qutip/qutip/issues/1810#issuecomment-1046958786:484,Deployability,install,installation,484,"It was during fixing/changing the behaviour shown in 1808 that I first saw the issue. It seems now that I can change the qutip code, and to some degree at least it does compile, but the mentioned error still shows up in the terminal on running reload(qutip). Its likely that the error was there before I started modifying any files, and that I did not happen to spot it between all the lines jupyter tends to print in the terminal. It also shows up on my system after I force a fresh installation of qutip with no changes. It does not currently seem to stop me from doing anything, but I don't know what causes it.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1810#issuecomment-1046958786
https://github.com/qutip/qutip/issues/1811#issuecomment-1044365324:113,Deployability,update,updated,113,"A pull request would be most welcome. There are also two other functions in qutip.fileio that should probably be updated at the same time. Instead of using an if statement, I would write code like:; ```python; p = pathlib.Path(""filename""); ... # append suffix here; with p.open(...):; ... # load or save here; ```",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1811#issuecomment-1044365324
https://github.com/qutip/qutip/issues/1811#issuecomment-1044365324:291,Performance,load,load,291,"A pull request would be most welcome. There are also two other functions in qutip.fileio that should probably be updated at the same time. Instead of using an if statement, I would write code like:; ```python; p = pathlib.Path(""filename""); ... # append suffix here; with p.open(...):; ... # load or save here; ```",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1811#issuecomment-1044365324
https://github.com/qutip/qutip/issues/1811#issuecomment-1044402997:179,Performance,load,loading,179,"Nice, I will do it in the following days. On a side note, I'd propose to make the printing optional in `qload` with a `debug` flag for instance. As it is a bit messy when you are loading a lot of objects.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1811#issuecomment-1044402997
https://github.com/qutip/qutip/issues/1811#issuecomment-1044423457:148,Performance,load,loaded,148,+1 on getting rid of the print statements. I think we can just drop them entirely -- users can just print their object if they want to see what was loaded.,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1811#issuecomment-1044423457
https://github.com/qutip/qutip/issues/1811#issuecomment-1103663641:16,Deployability,release,released,16,Fixed #1813 and released in QuTiP 4.7.,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1811#issuecomment-1103663641
https://github.com/qutip/qutip/pull/1813#issuecomment-1047587729:104,Testability,test,test,104,@labay11 Thank you! I've approved the changes and marked them for inclusion in 4.7. I'll merge once the test runs have succeeded.,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1813#issuecomment-1047587729
https://github.com/qutip/qutip/issues/1815#issuecomment-1050747285:180,Deployability,update,update,180,"@henrykironde Eep. Thank you for wrangling all the projects. Our ideas list already lists sizes for all project ideas, so 1 & 2 are covered. I am double checking 3 now. I'll check update the numfocus issue and close this one once I'm done.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1815#issuecomment-1050747285
https://github.com/qutip/qutip/issues/1817#issuecomment-1057931568:362,Deployability,release,released,362,"@tomohiro-soejima Thank you for a very well organized bug report and for suggesting a fix. I've opened PR #1818 that applies your suggestion and adds tests. The PR is a continuation of #1690 because I didn't want to generate merge conflicts, so it can only be easily reviewed and merged once #1690 lands. I've marked the fix for inclusion in 4.7 which should be released in the next couple of weeks.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1817#issuecomment-1057931568
https://github.com/qutip/qutip/issues/1817#issuecomment-1057931568:150,Testability,test,tests,150,"@tomohiro-soejima Thank you for a very well organized bug report and for suggesting a fix. I've opened PR #1818 that applies your suggestion and adds tests. The PR is a continuation of #1690 because I didn't want to generate merge conflicts, so it can only be easily reviewed and merged once #1690 lands. I've marked the fix for inclusion in 4.7 which should be released in the next couple of weeks.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/issues/1817#issuecomment-1057931568
https://github.com/qutip/qutip/pull/1818#issuecomment-1060998181:103,Testability,test,tests,103,@AGaliciaMartinez Thanks for the review and the good suggestions. I've applied them so I'll merge once tests pass.,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1818#issuecomment-1060998181
https://github.com/qutip/qutip/pull/1819#issuecomment-1059196652:129,Deployability,update,updated,129,"Note to self: After discussion with @Ericgig, I'm going to remove the deprecation warning for now since qutip-lattice is not yet updated and published to PyPI. qutip-lattice is still where future development should happen.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://qutip.org,https://github.com/qutip/qutip/pull/1819#issuecomment-1059196652
