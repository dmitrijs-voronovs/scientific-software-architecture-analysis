id,quality_attribute,keyword,matched_word,match_idx,sentence,source,filename,author,repo,version,wiki,url
https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:6878,Modifiability,config,config,6878,"s: dictionary; Optional keyword arguments to the map_func function. Returns; -------; results : :class:`qutip.solver.Result`; Object storing all results from the simulation. .. note::. It is possible to reuse the random number seeds from a previous run; of the mcsolver by passing the output Result object seeds via the; Options class, i.e. Options(seeds=prev_result.seeds).; """""". if debug:; print(inspect.stack()[0][3]); ; if isinstance(c_ops, Qobj):; c_ops = [c_ops]. if isinstance(e_ops, Qobj):; e_ops = [e_ops]. if isinstance(e_ops, dict):; e_ops_dict = e_ops; e_ops = [e for e in e_ops.values()]; else:; e_ops_dict = None; ; if _safe_mode:; _solver_safety_check(H, psi0, c_ops, e_ops, args); ; if options is None:; options = Options(). if ntraj is None:; ntraj = options.ntraj. config.map_func = map_func if map_func is not None else parallel_map; config.map_kwargs = map_kwargs if map_kwargs is not None else {}. if not psi0.isket:; raise Exception(""Initial state must be a state vector.""). config.options = options. if progress_bar:; if progress_bar is True:; config.progress_bar = TextProgressBar(); else:; config.progress_bar = progress_bar; else:; config.progress_bar = BaseProgressBar(). # set num_cpus to the value given in qutip.settings if none in Options; if not config.options.num_cpus:; config.options.num_cpus = qutip.settings.num_cpus; if config.options.num_cpus == 1:; # fallback on serial_map if num_cpu == 1, since there is no; # benefit of starting multiprocessing in this case; config.map_func = serial_map. # set initial value data; if options.tidy:; config.psi0 = psi0.tidyup(options.atol).full().ravel(); else:; config.psi0 = psi0.full().ravel(). config.psi0_dims = psi0.dims; config.psi0_shape = psi0.shape. # set options on ouput states; if config.options.steady_state_average:; config.options.average_states = True. # set general items; config.tlist = tlist; if isinstance(ntraj, (list, np.ndarray)):; config.ntraj = np.sort(ntraj)[-1]; else:; config.ntraj = ntraj. # se",MatchSource.WIKI,docs/4.2/modules/qutip/mcsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html
https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:6948,Modifiability,config,config,6948," map_func function. Returns; -------; results : :class:`qutip.solver.Result`; Object storing all results from the simulation. .. note::. It is possible to reuse the random number seeds from a previous run; of the mcsolver by passing the output Result object seeds via the; Options class, i.e. Options(seeds=prev_result.seeds).; """""". if debug:; print(inspect.stack()[0][3]); ; if isinstance(c_ops, Qobj):; c_ops = [c_ops]. if isinstance(e_ops, Qobj):; e_ops = [e_ops]. if isinstance(e_ops, dict):; e_ops_dict = e_ops; e_ops = [e for e in e_ops.values()]; else:; e_ops_dict = None; ; if _safe_mode:; _solver_safety_check(H, psi0, c_ops, e_ops, args); ; if options is None:; options = Options(). if ntraj is None:; ntraj = options.ntraj. config.map_func = map_func if map_func is not None else parallel_map; config.map_kwargs = map_kwargs if map_kwargs is not None else {}. if not psi0.isket:; raise Exception(""Initial state must be a state vector.""). config.options = options. if progress_bar:; if progress_bar is True:; config.progress_bar = TextProgressBar(); else:; config.progress_bar = progress_bar; else:; config.progress_bar = BaseProgressBar(). # set num_cpus to the value given in qutip.settings if none in Options; if not config.options.num_cpus:; config.options.num_cpus = qutip.settings.num_cpus; if config.options.num_cpus == 1:; # fallback on serial_map if num_cpu == 1, since there is no; # benefit of starting multiprocessing in this case; config.map_func = serial_map. # set initial value data; if options.tidy:; config.psi0 = psi0.tidyup(options.atol).full().ravel(); else:; config.psi0 = psi0.full().ravel(). config.psi0_dims = psi0.dims; config.psi0_shape = psi0.shape. # set options on ouput states; if config.options.steady_state_average:; config.options.average_states = True. # set general items; config.tlist = tlist; if isinstance(ntraj, (list, np.ndarray)):; config.ntraj = np.sort(ntraj)[-1]; else:; config.ntraj = ntraj. # set norm finding constants; config.norm_tol = opti",MatchSource.WIKI,docs/4.2/modules/qutip/mcsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html
https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:6996,Modifiability,config,config,6996,"lass:`qutip.solver.Result`; Object storing all results from the simulation. .. note::. It is possible to reuse the random number seeds from a previous run; of the mcsolver by passing the output Result object seeds via the; Options class, i.e. Options(seeds=prev_result.seeds).; """""". if debug:; print(inspect.stack()[0][3]); ; if isinstance(c_ops, Qobj):; c_ops = [c_ops]. if isinstance(e_ops, Qobj):; e_ops = [e_ops]. if isinstance(e_ops, dict):; e_ops_dict = e_ops; e_ops = [e for e in e_ops.values()]; else:; e_ops_dict = None; ; if _safe_mode:; _solver_safety_check(H, psi0, c_ops, e_ops, args); ; if options is None:; options = Options(). if ntraj is None:; ntraj = options.ntraj. config.map_func = map_func if map_func is not None else parallel_map; config.map_kwargs = map_kwargs if map_kwargs is not None else {}. if not psi0.isket:; raise Exception(""Initial state must be a state vector.""). config.options = options. if progress_bar:; if progress_bar is True:; config.progress_bar = TextProgressBar(); else:; config.progress_bar = progress_bar; else:; config.progress_bar = BaseProgressBar(). # set num_cpus to the value given in qutip.settings if none in Options; if not config.options.num_cpus:; config.options.num_cpus = qutip.settings.num_cpus; if config.options.num_cpus == 1:; # fallback on serial_map if num_cpu == 1, since there is no; # benefit of starting multiprocessing in this case; config.map_func = serial_map. # set initial value data; if options.tidy:; config.psi0 = psi0.tidyup(options.atol).full().ravel(); else:; config.psi0 = psi0.full().ravel(). config.psi0_dims = psi0.dims; config.psi0_shape = psi0.shape. # set options on ouput states; if config.options.steady_state_average:; config.options.average_states = True. # set general items; config.tlist = tlist; if isinstance(ntraj, (list, np.ndarray)):; config.ntraj = np.sort(ntraj)[-1]; else:; config.ntraj = ntraj. # set norm finding constants; config.norm_tol = options.norm_tol; config.norm_steps = options.norm_ste",MatchSource.WIKI,docs/4.2/modules/qutip/mcsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html
https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:7039,Modifiability,config,config,7039,"l results from the simulation. .. note::. It is possible to reuse the random number seeds from a previous run; of the mcsolver by passing the output Result object seeds via the; Options class, i.e. Options(seeds=prev_result.seeds).; """""". if debug:; print(inspect.stack()[0][3]); ; if isinstance(c_ops, Qobj):; c_ops = [c_ops]. if isinstance(e_ops, Qobj):; e_ops = [e_ops]. if isinstance(e_ops, dict):; e_ops_dict = e_ops; e_ops = [e for e in e_ops.values()]; else:; e_ops_dict = None; ; if _safe_mode:; _solver_safety_check(H, psi0, c_ops, e_ops, args); ; if options is None:; options = Options(). if ntraj is None:; ntraj = options.ntraj. config.map_func = map_func if map_func is not None else parallel_map; config.map_kwargs = map_kwargs if map_kwargs is not None else {}. if not psi0.isket:; raise Exception(""Initial state must be a state vector.""). config.options = options. if progress_bar:; if progress_bar is True:; config.progress_bar = TextProgressBar(); else:; config.progress_bar = progress_bar; else:; config.progress_bar = BaseProgressBar(). # set num_cpus to the value given in qutip.settings if none in Options; if not config.options.num_cpus:; config.options.num_cpus = qutip.settings.num_cpus; if config.options.num_cpus == 1:; # fallback on serial_map if num_cpu == 1, since there is no; # benefit of starting multiprocessing in this case; config.map_func = serial_map. # set initial value data; if options.tidy:; config.psi0 = psi0.tidyup(options.atol).full().ravel(); else:; config.psi0 = psi0.full().ravel(). config.psi0_dims = psi0.dims; config.psi0_shape = psi0.shape. # set options on ouput states; if config.options.steady_state_average:; config.options.average_states = True. # set general items; config.tlist = tlist; if isinstance(ntraj, (list, np.ndarray)):; config.ntraj = np.sort(ntraj)[-1]; else:; config.ntraj = ntraj. # set norm finding constants; config.norm_tol = options.norm_tol; config.norm_steps = options.norm_steps. # convert array based time-dependence to s",MatchSource.WIKI,docs/4.2/modules/qutip/mcsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html
https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:7159,Modifiability,config,config,7159,"solver by passing the output Result object seeds via the; Options class, i.e. Options(seeds=prev_result.seeds).; """""". if debug:; print(inspect.stack()[0][3]); ; if isinstance(c_ops, Qobj):; c_ops = [c_ops]. if isinstance(e_ops, Qobj):; e_ops = [e_ops]. if isinstance(e_ops, dict):; e_ops_dict = e_ops; e_ops = [e for e in e_ops.values()]; else:; e_ops_dict = None; ; if _safe_mode:; _solver_safety_check(H, psi0, c_ops, e_ops, args); ; if options is None:; options = Options(). if ntraj is None:; ntraj = options.ntraj. config.map_func = map_func if map_func is not None else parallel_map; config.map_kwargs = map_kwargs if map_kwargs is not None else {}. if not psi0.isket:; raise Exception(""Initial state must be a state vector.""). config.options = options. if progress_bar:; if progress_bar is True:; config.progress_bar = TextProgressBar(); else:; config.progress_bar = progress_bar; else:; config.progress_bar = BaseProgressBar(). # set num_cpus to the value given in qutip.settings if none in Options; if not config.options.num_cpus:; config.options.num_cpus = qutip.settings.num_cpus; if config.options.num_cpus == 1:; # fallback on serial_map if num_cpu == 1, since there is no; # benefit of starting multiprocessing in this case; config.map_func = serial_map. # set initial value data; if options.tidy:; config.psi0 = psi0.tidyup(options.atol).full().ravel(); else:; config.psi0 = psi0.full().ravel(). config.psi0_dims = psi0.dims; config.psi0_shape = psi0.shape. # set options on ouput states; if config.options.steady_state_average:; config.options.average_states = True. # set general items; config.tlist = tlist; if isinstance(ntraj, (list, np.ndarray)):; config.ntraj = np.sort(ntraj)[-1]; else:; config.ntraj = ntraj. # set norm finding constants; config.norm_tol = options.norm_tol; config.norm_steps = options.norm_steps. # convert array based time-dependence to string format; H, c_ops, args = _td_wrap_array_str(H, c_ops, args, tlist). # SETUP ODE DATA IF NONE EXISTS OR NOT REUSING",MatchSource.WIKI,docs/4.2/modules/qutip/mcsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html
https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:7185,Modifiability,config,config,7185,"ect seeds via the; Options class, i.e. Options(seeds=prev_result.seeds).; """""". if debug:; print(inspect.stack()[0][3]); ; if isinstance(c_ops, Qobj):; c_ops = [c_ops]. if isinstance(e_ops, Qobj):; e_ops = [e_ops]. if isinstance(e_ops, dict):; e_ops_dict = e_ops; e_ops = [e for e in e_ops.values()]; else:; e_ops_dict = None; ; if _safe_mode:; _solver_safety_check(H, psi0, c_ops, e_ops, args); ; if options is None:; options = Options(). if ntraj is None:; ntraj = options.ntraj. config.map_func = map_func if map_func is not None else parallel_map; config.map_kwargs = map_kwargs if map_kwargs is not None else {}. if not psi0.isket:; raise Exception(""Initial state must be a state vector.""). config.options = options. if progress_bar:; if progress_bar is True:; config.progress_bar = TextProgressBar(); else:; config.progress_bar = progress_bar; else:; config.progress_bar = BaseProgressBar(). # set num_cpus to the value given in qutip.settings if none in Options; if not config.options.num_cpus:; config.options.num_cpus = qutip.settings.num_cpus; if config.options.num_cpus == 1:; # fallback on serial_map if num_cpu == 1, since there is no; # benefit of starting multiprocessing in this case; config.map_func = serial_map. # set initial value data; if options.tidy:; config.psi0 = psi0.tidyup(options.atol).full().ravel(); else:; config.psi0 = psi0.full().ravel(). config.psi0_dims = psi0.dims; config.psi0_shape = psi0.shape. # set options on ouput states; if config.options.steady_state_average:; config.options.average_states = True. # set general items; config.tlist = tlist; if isinstance(ntraj, (list, np.ndarray)):; config.ntraj = np.sort(ntraj)[-1]; else:; config.ntraj = ntraj. # set norm finding constants; config.norm_tol = options.norm_tol; config.norm_steps = options.norm_steps. # convert array based time-dependence to string format; H, c_ops, args = _td_wrap_array_str(H, c_ops, args, tlist). # SETUP ODE DATA IF NONE EXISTS OR NOT REUSING; # ----------------------------------",MatchSource.WIKI,docs/4.2/modules/qutip/mcsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html
https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:7239,Modifiability,config,config,7239,"prev_result.seeds).; """""". if debug:; print(inspect.stack()[0][3]); ; if isinstance(c_ops, Qobj):; c_ops = [c_ops]. if isinstance(e_ops, Qobj):; e_ops = [e_ops]. if isinstance(e_ops, dict):; e_ops_dict = e_ops; e_ops = [e for e in e_ops.values()]; else:; e_ops_dict = None; ; if _safe_mode:; _solver_safety_check(H, psi0, c_ops, e_ops, args); ; if options is None:; options = Options(). if ntraj is None:; ntraj = options.ntraj. config.map_func = map_func if map_func is not None else parallel_map; config.map_kwargs = map_kwargs if map_kwargs is not None else {}. if not psi0.isket:; raise Exception(""Initial state must be a state vector.""). config.options = options. if progress_bar:; if progress_bar is True:; config.progress_bar = TextProgressBar(); else:; config.progress_bar = progress_bar; else:; config.progress_bar = BaseProgressBar(). # set num_cpus to the value given in qutip.settings if none in Options; if not config.options.num_cpus:; config.options.num_cpus = qutip.settings.num_cpus; if config.options.num_cpus == 1:; # fallback on serial_map if num_cpu == 1, since there is no; # benefit of starting multiprocessing in this case; config.map_func = serial_map. # set initial value data; if options.tidy:; config.psi0 = psi0.tidyup(options.atol).full().ravel(); else:; config.psi0 = psi0.full().ravel(). config.psi0_dims = psi0.dims; config.psi0_shape = psi0.shape. # set options on ouput states; if config.options.steady_state_average:; config.options.average_states = True. # set general items; config.tlist = tlist; if isinstance(ntraj, (list, np.ndarray)):; config.ntraj = np.sort(ntraj)[-1]; else:; config.ntraj = ntraj. # set norm finding constants; config.norm_tol = options.norm_tol; config.norm_steps = options.norm_steps. # convert array based time-dependence to string format; H, c_ops, args = _td_wrap_array_str(H, c_ops, args, tlist). # SETUP ODE DATA IF NONE EXISTS OR NOT REUSING; # --------------------------------------------; if not options.rhs_reuse or not config.td",MatchSource.WIKI,docs/4.2/modules/qutip/mcsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html
https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:7383,Modifiability,config,config,7383,"ps, Qobj):; c_ops = [c_ops]. if isinstance(e_ops, Qobj):; e_ops = [e_ops]. if isinstance(e_ops, dict):; e_ops_dict = e_ops; e_ops = [e for e in e_ops.values()]; else:; e_ops_dict = None; ; if _safe_mode:; _solver_safety_check(H, psi0, c_ops, e_ops, args); ; if options is None:; options = Options(). if ntraj is None:; ntraj = options.ntraj. config.map_func = map_func if map_func is not None else parallel_map; config.map_kwargs = map_kwargs if map_kwargs is not None else {}. if not psi0.isket:; raise Exception(""Initial state must be a state vector.""). config.options = options. if progress_bar:; if progress_bar is True:; config.progress_bar = TextProgressBar(); else:; config.progress_bar = progress_bar; else:; config.progress_bar = BaseProgressBar(). # set num_cpus to the value given in qutip.settings if none in Options; if not config.options.num_cpus:; config.options.num_cpus = qutip.settings.num_cpus; if config.options.num_cpus == 1:; # fallback on serial_map if num_cpu == 1, since there is no; # benefit of starting multiprocessing in this case; config.map_func = serial_map. # set initial value data; if options.tidy:; config.psi0 = psi0.tidyup(options.atol).full().ravel(); else:; config.psi0 = psi0.full().ravel(). config.psi0_dims = psi0.dims; config.psi0_shape = psi0.shape. # set options on ouput states; if config.options.steady_state_average:; config.options.average_states = True. # set general items; config.tlist = tlist; if isinstance(ntraj, (list, np.ndarray)):; config.ntraj = np.sort(ntraj)[-1]; else:; config.ntraj = ntraj. # set norm finding constants; config.norm_tol = options.norm_tol; config.norm_steps = options.norm_steps. # convert array based time-dependence to string format; H, c_ops, args = _td_wrap_array_str(H, c_ops, args, tlist). # SETUP ODE DATA IF NONE EXISTS OR NOT REUSING; # --------------------------------------------; if not options.rhs_reuse or not config.tdfunc:; # reset config collapse and time-dependence flags to default values; config.sof",MatchSource.WIKI,docs/4.2/modules/qutip/mcsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html
https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:7457,Modifiability,config,config,7457,"for e in e_ops.values()]; else:; e_ops_dict = None; ; if _safe_mode:; _solver_safety_check(H, psi0, c_ops, e_ops, args); ; if options is None:; options = Options(). if ntraj is None:; ntraj = options.ntraj. config.map_func = map_func if map_func is not None else parallel_map; config.map_kwargs = map_kwargs if map_kwargs is not None else {}. if not psi0.isket:; raise Exception(""Initial state must be a state vector.""). config.options = options. if progress_bar:; if progress_bar is True:; config.progress_bar = TextProgressBar(); else:; config.progress_bar = progress_bar; else:; config.progress_bar = BaseProgressBar(). # set num_cpus to the value given in qutip.settings if none in Options; if not config.options.num_cpus:; config.options.num_cpus = qutip.settings.num_cpus; if config.options.num_cpus == 1:; # fallback on serial_map if num_cpu == 1, since there is no; # benefit of starting multiprocessing in this case; config.map_func = serial_map. # set initial value data; if options.tidy:; config.psi0 = psi0.tidyup(options.atol).full().ravel(); else:; config.psi0 = psi0.full().ravel(). config.psi0_dims = psi0.dims; config.psi0_shape = psi0.shape. # set options on ouput states; if config.options.steady_state_average:; config.options.average_states = True. # set general items; config.tlist = tlist; if isinstance(ntraj, (list, np.ndarray)):; config.ntraj = np.sort(ntraj)[-1]; else:; config.ntraj = ntraj. # set norm finding constants; config.norm_tol = options.norm_tol; config.norm_steps = options.norm_steps. # convert array based time-dependence to string format; H, c_ops, args = _td_wrap_array_str(H, c_ops, args, tlist). # SETUP ODE DATA IF NONE EXISTS OR NOT REUSING; # --------------------------------------------; if not options.rhs_reuse or not config.tdfunc:; # reset config collapse and time-dependence flags to default values; config.soft_reset(). # check for type of time-dependence (if any); time_type, h_stuff, c_stuff = _td_format_check(H, c_ops, 'mc'); c_terms = len(",MatchSource.WIKI,docs/4.2/modules/qutip/mcsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html
https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:7520,Modifiability,config,config,7520,"safe_mode:; _solver_safety_check(H, psi0, c_ops, e_ops, args); ; if options is None:; options = Options(). if ntraj is None:; ntraj = options.ntraj. config.map_func = map_func if map_func is not None else parallel_map; config.map_kwargs = map_kwargs if map_kwargs is not None else {}. if not psi0.isket:; raise Exception(""Initial state must be a state vector.""). config.options = options. if progress_bar:; if progress_bar is True:; config.progress_bar = TextProgressBar(); else:; config.progress_bar = progress_bar; else:; config.progress_bar = BaseProgressBar(). # set num_cpus to the value given in qutip.settings if none in Options; if not config.options.num_cpus:; config.options.num_cpus = qutip.settings.num_cpus; if config.options.num_cpus == 1:; # fallback on serial_map if num_cpu == 1, since there is no; # benefit of starting multiprocessing in this case; config.map_func = serial_map. # set initial value data; if options.tidy:; config.psi0 = psi0.tidyup(options.atol).full().ravel(); else:; config.psi0 = psi0.full().ravel(). config.psi0_dims = psi0.dims; config.psi0_shape = psi0.shape. # set options on ouput states; if config.options.steady_state_average:; config.options.average_states = True. # set general items; config.tlist = tlist; if isinstance(ntraj, (list, np.ndarray)):; config.ntraj = np.sort(ntraj)[-1]; else:; config.ntraj = ntraj. # set norm finding constants; config.norm_tol = options.norm_tol; config.norm_steps = options.norm_steps. # convert array based time-dependence to string format; H, c_ops, args = _td_wrap_array_str(H, c_ops, args, tlist). # SETUP ODE DATA IF NONE EXISTS OR NOT REUSING; # --------------------------------------------; if not options.rhs_reuse or not config.tdfunc:; # reset config collapse and time-dependence flags to default values; config.soft_reset(). # check for type of time-dependence (if any); time_type, h_stuff, c_stuff = _td_format_check(H, c_ops, 'mc'); c_terms = len(c_stuff[0]) + len(c_stuff[1]) + len(c_stuff[2]); # set time",MatchSource.WIKI,docs/4.2/modules/qutip/mcsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html
https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:7555,Modifiability,config,config,7555,"_ops, e_ops, args); ; if options is None:; options = Options(). if ntraj is None:; ntraj = options.ntraj. config.map_func = map_func if map_func is not None else parallel_map; config.map_kwargs = map_kwargs if map_kwargs is not None else {}. if not psi0.isket:; raise Exception(""Initial state must be a state vector.""). config.options = options. if progress_bar:; if progress_bar is True:; config.progress_bar = TextProgressBar(); else:; config.progress_bar = progress_bar; else:; config.progress_bar = BaseProgressBar(). # set num_cpus to the value given in qutip.settings if none in Options; if not config.options.num_cpus:; config.options.num_cpus = qutip.settings.num_cpus; if config.options.num_cpus == 1:; # fallback on serial_map if num_cpu == 1, since there is no; # benefit of starting multiprocessing in this case; config.map_func = serial_map. # set initial value data; if options.tidy:; config.psi0 = psi0.tidyup(options.atol).full().ravel(); else:; config.psi0 = psi0.full().ravel(). config.psi0_dims = psi0.dims; config.psi0_shape = psi0.shape. # set options on ouput states; if config.options.steady_state_average:; config.options.average_states = True. # set general items; config.tlist = tlist; if isinstance(ntraj, (list, np.ndarray)):; config.ntraj = np.sort(ntraj)[-1]; else:; config.ntraj = ntraj. # set norm finding constants; config.norm_tol = options.norm_tol; config.norm_steps = options.norm_steps. # convert array based time-dependence to string format; H, c_ops, args = _td_wrap_array_str(H, c_ops, args, tlist). # SETUP ODE DATA IF NONE EXISTS OR NOT REUSING; # --------------------------------------------; if not options.rhs_reuse or not config.tdfunc:; # reset config collapse and time-dependence flags to default values; config.soft_reset(). # check for type of time-dependence (if any); time_type, h_stuff, c_stuff = _td_format_check(H, c_ops, 'mc'); c_terms = len(c_stuff[0]) + len(c_stuff[1]) + len(c_stuff[2]); # set time_type for use in multiprocessing; config.t",MatchSource.WIKI,docs/4.2/modules/qutip/mcsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html
https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:7585,Modifiability,config,config,7585,"tions is None:; options = Options(). if ntraj is None:; ntraj = options.ntraj. config.map_func = map_func if map_func is not None else parallel_map; config.map_kwargs = map_kwargs if map_kwargs is not None else {}. if not psi0.isket:; raise Exception(""Initial state must be a state vector.""). config.options = options. if progress_bar:; if progress_bar is True:; config.progress_bar = TextProgressBar(); else:; config.progress_bar = progress_bar; else:; config.progress_bar = BaseProgressBar(). # set num_cpus to the value given in qutip.settings if none in Options; if not config.options.num_cpus:; config.options.num_cpus = qutip.settings.num_cpus; if config.options.num_cpus == 1:; # fallback on serial_map if num_cpu == 1, since there is no; # benefit of starting multiprocessing in this case; config.map_func = serial_map. # set initial value data; if options.tidy:; config.psi0 = psi0.tidyup(options.atol).full().ravel(); else:; config.psi0 = psi0.full().ravel(). config.psi0_dims = psi0.dims; config.psi0_shape = psi0.shape. # set options on ouput states; if config.options.steady_state_average:; config.options.average_states = True. # set general items; config.tlist = tlist; if isinstance(ntraj, (list, np.ndarray)):; config.ntraj = np.sort(ntraj)[-1]; else:; config.ntraj = ntraj. # set norm finding constants; config.norm_tol = options.norm_tol; config.norm_steps = options.norm_steps. # convert array based time-dependence to string format; H, c_ops, args = _td_wrap_array_str(H, c_ops, args, tlist). # SETUP ODE DATA IF NONE EXISTS OR NOT REUSING; # --------------------------------------------; if not options.rhs_reuse or not config.tdfunc:; # reset config collapse and time-dependence flags to default values; config.soft_reset(). # check for type of time-dependence (if any); time_type, h_stuff, c_stuff = _td_format_check(H, c_ops, 'mc'); c_terms = len(c_stuff[0]) + len(c_stuff[1]) + len(c_stuff[2]); # set time_type for use in multiprocessing; config.tflag = time_type. # check fo",MatchSource.WIKI,docs/4.2/modules/qutip/mcsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html
https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:7651,Modifiability,config,config,7651,"e:; ntraj = options.ntraj. config.map_func = map_func if map_func is not None else parallel_map; config.map_kwargs = map_kwargs if map_kwargs is not None else {}. if not psi0.isket:; raise Exception(""Initial state must be a state vector.""). config.options = options. if progress_bar:; if progress_bar is True:; config.progress_bar = TextProgressBar(); else:; config.progress_bar = progress_bar; else:; config.progress_bar = BaseProgressBar(). # set num_cpus to the value given in qutip.settings if none in Options; if not config.options.num_cpus:; config.options.num_cpus = qutip.settings.num_cpus; if config.options.num_cpus == 1:; # fallback on serial_map if num_cpu == 1, since there is no; # benefit of starting multiprocessing in this case; config.map_func = serial_map. # set initial value data; if options.tidy:; config.psi0 = psi0.tidyup(options.atol).full().ravel(); else:; config.psi0 = psi0.full().ravel(). config.psi0_dims = psi0.dims; config.psi0_shape = psi0.shape. # set options on ouput states; if config.options.steady_state_average:; config.options.average_states = True. # set general items; config.tlist = tlist; if isinstance(ntraj, (list, np.ndarray)):; config.ntraj = np.sort(ntraj)[-1]; else:; config.ntraj = ntraj. # set norm finding constants; config.norm_tol = options.norm_tol; config.norm_steps = options.norm_steps. # convert array based time-dependence to string format; H, c_ops, args = _td_wrap_array_str(H, c_ops, args, tlist). # SETUP ODE DATA IF NONE EXISTS OR NOT REUSING; # --------------------------------------------; if not options.rhs_reuse or not config.tdfunc:; # reset config collapse and time-dependence flags to default values; config.soft_reset(). # check for type of time-dependence (if any); time_type, h_stuff, c_stuff = _td_format_check(H, c_ops, 'mc'); c_terms = len(c_stuff[0]) + len(c_stuff[1]) + len(c_stuff[2]); # set time_type for use in multiprocessing; config.tflag = time_type. # check for collapse operators; if c_terms > 0:; config.cflag",MatchSource.WIKI,docs/4.2/modules/qutip/mcsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html
https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:7689,Modifiability,config,config,7689," map_func if map_func is not None else parallel_map; config.map_kwargs = map_kwargs if map_kwargs is not None else {}. if not psi0.isket:; raise Exception(""Initial state must be a state vector.""). config.options = options. if progress_bar:; if progress_bar is True:; config.progress_bar = TextProgressBar(); else:; config.progress_bar = progress_bar; else:; config.progress_bar = BaseProgressBar(). # set num_cpus to the value given in qutip.settings if none in Options; if not config.options.num_cpus:; config.options.num_cpus = qutip.settings.num_cpus; if config.options.num_cpus == 1:; # fallback on serial_map if num_cpu == 1, since there is no; # benefit of starting multiprocessing in this case; config.map_func = serial_map. # set initial value data; if options.tidy:; config.psi0 = psi0.tidyup(options.atol).full().ravel(); else:; config.psi0 = psi0.full().ravel(). config.psi0_dims = psi0.dims; config.psi0_shape = psi0.shape. # set options on ouput states; if config.options.steady_state_average:; config.options.average_states = True. # set general items; config.tlist = tlist; if isinstance(ntraj, (list, np.ndarray)):; config.ntraj = np.sort(ntraj)[-1]; else:; config.ntraj = ntraj. # set norm finding constants; config.norm_tol = options.norm_tol; config.norm_steps = options.norm_steps. # convert array based time-dependence to string format; H, c_ops, args = _td_wrap_array_str(H, c_ops, args, tlist). # SETUP ODE DATA IF NONE EXISTS OR NOT REUSING; # --------------------------------------------; if not options.rhs_reuse or not config.tdfunc:; # reset config collapse and time-dependence flags to default values; config.soft_reset(). # check for type of time-dependence (if any); time_type, h_stuff, c_stuff = _td_format_check(H, c_ops, 'mc'); c_terms = len(c_stuff[0]) + len(c_stuff[1]) + len(c_stuff[2]); # set time_type for use in multiprocessing; config.tflag = time_type. # check for collapse operators; if c_terms > 0:; config.cflag = 1; else:; config.cflag = 0. # Configure d",MatchSource.WIKI,docs/4.2/modules/qutip/mcsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html
https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:7748,Modifiability,config,config,7748,".map_kwargs = map_kwargs if map_kwargs is not None else {}. if not psi0.isket:; raise Exception(""Initial state must be a state vector.""). config.options = options. if progress_bar:; if progress_bar is True:; config.progress_bar = TextProgressBar(); else:; config.progress_bar = progress_bar; else:; config.progress_bar = BaseProgressBar(). # set num_cpus to the value given in qutip.settings if none in Options; if not config.options.num_cpus:; config.options.num_cpus = qutip.settings.num_cpus; if config.options.num_cpus == 1:; # fallback on serial_map if num_cpu == 1, since there is no; # benefit of starting multiprocessing in this case; config.map_func = serial_map. # set initial value data; if options.tidy:; config.psi0 = psi0.tidyup(options.atol).full().ravel(); else:; config.psi0 = psi0.full().ravel(). config.psi0_dims = psi0.dims; config.psi0_shape = psi0.shape. # set options on ouput states; if config.options.steady_state_average:; config.options.average_states = True. # set general items; config.tlist = tlist; if isinstance(ntraj, (list, np.ndarray)):; config.ntraj = np.sort(ntraj)[-1]; else:; config.ntraj = ntraj. # set norm finding constants; config.norm_tol = options.norm_tol; config.norm_steps = options.norm_steps. # convert array based time-dependence to string format; H, c_ops, args = _td_wrap_array_str(H, c_ops, args, tlist). # SETUP ODE DATA IF NONE EXISTS OR NOT REUSING; # --------------------------------------------; if not options.rhs_reuse or not config.tdfunc:; # reset config collapse and time-dependence flags to default values; config.soft_reset(). # check for type of time-dependence (if any); time_type, h_stuff, c_stuff = _td_format_check(H, c_ops, 'mc'); c_terms = len(c_stuff[0]) + len(c_stuff[1]) + len(c_stuff[2]); # set time_type for use in multiprocessing; config.tflag = time_type. # check for collapse operators; if c_terms > 0:; config.cflag = 1; else:; config.cflag = 0. # Configure data; _mc_data_config(H, psi0, h_stuff, c_ops, c_stuff, args,",MatchSource.WIKI,docs/4.2/modules/qutip/mcsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html
https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:7813,Modifiability,config,config,7813,"0.isket:; raise Exception(""Initial state must be a state vector.""). config.options = options. if progress_bar:; if progress_bar is True:; config.progress_bar = TextProgressBar(); else:; config.progress_bar = progress_bar; else:; config.progress_bar = BaseProgressBar(). # set num_cpus to the value given in qutip.settings if none in Options; if not config.options.num_cpus:; config.options.num_cpus = qutip.settings.num_cpus; if config.options.num_cpus == 1:; # fallback on serial_map if num_cpu == 1, since there is no; # benefit of starting multiprocessing in this case; config.map_func = serial_map. # set initial value data; if options.tidy:; config.psi0 = psi0.tidyup(options.atol).full().ravel(); else:; config.psi0 = psi0.full().ravel(). config.psi0_dims = psi0.dims; config.psi0_shape = psi0.shape. # set options on ouput states; if config.options.steady_state_average:; config.options.average_states = True. # set general items; config.tlist = tlist; if isinstance(ntraj, (list, np.ndarray)):; config.ntraj = np.sort(ntraj)[-1]; else:; config.ntraj = ntraj. # set norm finding constants; config.norm_tol = options.norm_tol; config.norm_steps = options.norm_steps. # convert array based time-dependence to string format; H, c_ops, args = _td_wrap_array_str(H, c_ops, args, tlist). # SETUP ODE DATA IF NONE EXISTS OR NOT REUSING; # --------------------------------------------; if not options.rhs_reuse or not config.tdfunc:; # reset config collapse and time-dependence flags to default values; config.soft_reset(). # check for type of time-dependence (if any); time_type, h_stuff, c_stuff = _td_format_check(H, c_ops, 'mc'); c_terms = len(c_stuff[0]) + len(c_stuff[1]) + len(c_stuff[2]); # set time_type for use in multiprocessing; config.tflag = time_type. # check for collapse operators; if c_terms > 0:; config.cflag = 1; else:; config.cflag = 0. # Configure data; _mc_data_config(H, psi0, h_stuff, c_ops, c_stuff, args, e_ops,; options, config). # compile and load cython functions if nece",MatchSource.WIKI,docs/4.2/modules/qutip/mcsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html
https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:7855,Modifiability,config,config,7855,"tate must be a state vector.""). config.options = options. if progress_bar:; if progress_bar is True:; config.progress_bar = TextProgressBar(); else:; config.progress_bar = progress_bar; else:; config.progress_bar = BaseProgressBar(). # set num_cpus to the value given in qutip.settings if none in Options; if not config.options.num_cpus:; config.options.num_cpus = qutip.settings.num_cpus; if config.options.num_cpus == 1:; # fallback on serial_map if num_cpu == 1, since there is no; # benefit of starting multiprocessing in this case; config.map_func = serial_map. # set initial value data; if options.tidy:; config.psi0 = psi0.tidyup(options.atol).full().ravel(); else:; config.psi0 = psi0.full().ravel(). config.psi0_dims = psi0.dims; config.psi0_shape = psi0.shape. # set options on ouput states; if config.options.steady_state_average:; config.options.average_states = True. # set general items; config.tlist = tlist; if isinstance(ntraj, (list, np.ndarray)):; config.ntraj = np.sort(ntraj)[-1]; else:; config.ntraj = ntraj. # set norm finding constants; config.norm_tol = options.norm_tol; config.norm_steps = options.norm_steps. # convert array based time-dependence to string format; H, c_ops, args = _td_wrap_array_str(H, c_ops, args, tlist). # SETUP ODE DATA IF NONE EXISTS OR NOT REUSING; # --------------------------------------------; if not options.rhs_reuse or not config.tdfunc:; # reset config collapse and time-dependence flags to default values; config.soft_reset(). # check for type of time-dependence (if any); time_type, h_stuff, c_stuff = _td_format_check(H, c_ops, 'mc'); c_terms = len(c_stuff[0]) + len(c_stuff[1]) + len(c_stuff[2]); # set time_type for use in multiprocessing; config.tflag = time_type. # check for collapse operators; if c_terms > 0:; config.cflag = 1; else:; config.cflag = 0. # Configure data; _mc_data_config(H, psi0, h_stuff, c_ops, c_stuff, args, e_ops,; options, config). # compile and load cython functions if necessary; _mc_func_load(config). else:;",MatchSource.WIKI,docs/4.2/modules/qutip/mcsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html
https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:7907,Modifiability,config,config,7907,"options. if progress_bar:; if progress_bar is True:; config.progress_bar = TextProgressBar(); else:; config.progress_bar = progress_bar; else:; config.progress_bar = BaseProgressBar(). # set num_cpus to the value given in qutip.settings if none in Options; if not config.options.num_cpus:; config.options.num_cpus = qutip.settings.num_cpus; if config.options.num_cpus == 1:; # fallback on serial_map if num_cpu == 1, since there is no; # benefit of starting multiprocessing in this case; config.map_func = serial_map. # set initial value data; if options.tidy:; config.psi0 = psi0.tidyup(options.atol).full().ravel(); else:; config.psi0 = psi0.full().ravel(). config.psi0_dims = psi0.dims; config.psi0_shape = psi0.shape. # set options on ouput states; if config.options.steady_state_average:; config.options.average_states = True. # set general items; config.tlist = tlist; if isinstance(ntraj, (list, np.ndarray)):; config.ntraj = np.sort(ntraj)[-1]; else:; config.ntraj = ntraj. # set norm finding constants; config.norm_tol = options.norm_tol; config.norm_steps = options.norm_steps. # convert array based time-dependence to string format; H, c_ops, args = _td_wrap_array_str(H, c_ops, args, tlist). # SETUP ODE DATA IF NONE EXISTS OR NOT REUSING; # --------------------------------------------; if not options.rhs_reuse or not config.tdfunc:; # reset config collapse and time-dependence flags to default values; config.soft_reset(). # check for type of time-dependence (if any); time_type, h_stuff, c_stuff = _td_format_check(H, c_ops, 'mc'); c_terms = len(c_stuff[0]) + len(c_stuff[1]) + len(c_stuff[2]); # set time_type for use in multiprocessing; config.tflag = time_type. # check for collapse operators; if c_terms > 0:; config.cflag = 1; else:; config.cflag = 0. # Configure data; _mc_data_config(H, psi0, h_stuff, c_ops, c_stuff, args, e_ops,; options, config). # compile and load cython functions if necessary; _mc_func_load(config). else:; # setup args for new parameters when rhs_reuse=",MatchSource.WIKI,docs/4.2/modules/qutip/mcsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html
https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:7943,Modifiability,config,config,7943,"True:; config.progress_bar = TextProgressBar(); else:; config.progress_bar = progress_bar; else:; config.progress_bar = BaseProgressBar(). # set num_cpus to the value given in qutip.settings if none in Options; if not config.options.num_cpus:; config.options.num_cpus = qutip.settings.num_cpus; if config.options.num_cpus == 1:; # fallback on serial_map if num_cpu == 1, since there is no; # benefit of starting multiprocessing in this case; config.map_func = serial_map. # set initial value data; if options.tidy:; config.psi0 = psi0.tidyup(options.atol).full().ravel(); else:; config.psi0 = psi0.full().ravel(). config.psi0_dims = psi0.dims; config.psi0_shape = psi0.shape. # set options on ouput states; if config.options.steady_state_average:; config.options.average_states = True. # set general items; config.tlist = tlist; if isinstance(ntraj, (list, np.ndarray)):; config.ntraj = np.sort(ntraj)[-1]; else:; config.ntraj = ntraj. # set norm finding constants; config.norm_tol = options.norm_tol; config.norm_steps = options.norm_steps. # convert array based time-dependence to string format; H, c_ops, args = _td_wrap_array_str(H, c_ops, args, tlist). # SETUP ODE DATA IF NONE EXISTS OR NOT REUSING; # --------------------------------------------; if not options.rhs_reuse or not config.tdfunc:; # reset config collapse and time-dependence flags to default values; config.soft_reset(). # check for type of time-dependence (if any); time_type, h_stuff, c_stuff = _td_format_check(H, c_ops, 'mc'); c_terms = len(c_stuff[0]) + len(c_stuff[1]) + len(c_stuff[2]); # set time_type for use in multiprocessing; config.tflag = time_type. # check for collapse operators; if c_terms > 0:; config.cflag = 1; else:; config.cflag = 0. # Configure data; _mc_data_config(H, psi0, h_stuff, c_ops, c_stuff, args, e_ops,; options, config). # compile and load cython functions if necessary; _mc_func_load(config). else:; # setup args for new parameters when rhs_reuse=True and tdfunc is given; # string based; if co",MatchSource.WIKI,docs/4.2/modules/qutip/mcsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html
https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:8227,Modifiability,config,config,8227,"ngs.num_cpus; if config.options.num_cpus == 1:; # fallback on serial_map if num_cpu == 1, since there is no; # benefit of starting multiprocessing in this case; config.map_func = serial_map. # set initial value data; if options.tidy:; config.psi0 = psi0.tidyup(options.atol).full().ravel(); else:; config.psi0 = psi0.full().ravel(). config.psi0_dims = psi0.dims; config.psi0_shape = psi0.shape. # set options on ouput states; if config.options.steady_state_average:; config.options.average_states = True. # set general items; config.tlist = tlist; if isinstance(ntraj, (list, np.ndarray)):; config.ntraj = np.sort(ntraj)[-1]; else:; config.ntraj = ntraj. # set norm finding constants; config.norm_tol = options.norm_tol; config.norm_steps = options.norm_steps. # convert array based time-dependence to string format; H, c_ops, args = _td_wrap_array_str(H, c_ops, args, tlist). # SETUP ODE DATA IF NONE EXISTS OR NOT REUSING; # --------------------------------------------; if not options.rhs_reuse or not config.tdfunc:; # reset config collapse and time-dependence flags to default values; config.soft_reset(). # check for type of time-dependence (if any); time_type, h_stuff, c_stuff = _td_format_check(H, c_ops, 'mc'); c_terms = len(c_stuff[0]) + len(c_stuff[1]) + len(c_stuff[2]); # set time_type for use in multiprocessing; config.tflag = time_type. # check for collapse operators; if c_terms > 0:; config.cflag = 1; else:; config.cflag = 0. # Configure data; _mc_data_config(H, psi0, h_stuff, c_ops, c_stuff, args, e_ops,; options, config). # compile and load cython functions if necessary; _mc_func_load(config). else:; # setup args for new parameters when rhs_reuse=True and tdfunc is given; # string based; if config.tflag in [1, 10, 11]:; if any(args):; config.c_args = []; arg_items = list(args.items()); for k in range(len(arg_items)):; config.c_args.append(arg_items[k][1]); # function based; elif config.tflag in [2, 3, 20, 22]:; config.h_func_args = args. # load monte carlo class; mc =",MatchSource.WIKI,docs/4.2/modules/qutip/mcsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html
https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:8251,Modifiability,config,config,8251,"back on serial_map if num_cpu == 1, since there is no; # benefit of starting multiprocessing in this case; config.map_func = serial_map. # set initial value data; if options.tidy:; config.psi0 = psi0.tidyup(options.atol).full().ravel(); else:; config.psi0 = psi0.full().ravel(). config.psi0_dims = psi0.dims; config.psi0_shape = psi0.shape. # set options on ouput states; if config.options.steady_state_average:; config.options.average_states = True. # set general items; config.tlist = tlist; if isinstance(ntraj, (list, np.ndarray)):; config.ntraj = np.sort(ntraj)[-1]; else:; config.ntraj = ntraj. # set norm finding constants; config.norm_tol = options.norm_tol; config.norm_steps = options.norm_steps. # convert array based time-dependence to string format; H, c_ops, args = _td_wrap_array_str(H, c_ops, args, tlist). # SETUP ODE DATA IF NONE EXISTS OR NOT REUSING; # --------------------------------------------; if not options.rhs_reuse or not config.tdfunc:; # reset config collapse and time-dependence flags to default values; config.soft_reset(). # check for type of time-dependence (if any); time_type, h_stuff, c_stuff = _td_format_check(H, c_ops, 'mc'); c_terms = len(c_stuff[0]) + len(c_stuff[1]) + len(c_stuff[2]); # set time_type for use in multiprocessing; config.tflag = time_type. # check for collapse operators; if c_terms > 0:; config.cflag = 1; else:; config.cflag = 0. # Configure data; _mc_data_config(H, psi0, h_stuff, c_ops, c_stuff, args, e_ops,; options, config). # compile and load cython functions if necessary; _mc_func_load(config). else:; # setup args for new parameters when rhs_reuse=True and tdfunc is given; # string based; if config.tflag in [1, 10, 11]:; if any(args):; config.c_args = []; arg_items = list(args.items()); for k in range(len(arg_items)):; config.c_args.append(arg_items[k][1]); # function based; elif config.tflag in [2, 3, 20, 22]:; config.h_func_args = args. # load monte carlo class; mc = _MC(config). # Run the simulation; mc.run(). # Remove ",MatchSource.WIKI,docs/4.2/modules/qutip/mcsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html
https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:8312,Modifiability,config,config,8312,"back on serial_map if num_cpu == 1, since there is no; # benefit of starting multiprocessing in this case; config.map_func = serial_map. # set initial value data; if options.tidy:; config.psi0 = psi0.tidyup(options.atol).full().ravel(); else:; config.psi0 = psi0.full().ravel(). config.psi0_dims = psi0.dims; config.psi0_shape = psi0.shape. # set options on ouput states; if config.options.steady_state_average:; config.options.average_states = True. # set general items; config.tlist = tlist; if isinstance(ntraj, (list, np.ndarray)):; config.ntraj = np.sort(ntraj)[-1]; else:; config.ntraj = ntraj. # set norm finding constants; config.norm_tol = options.norm_tol; config.norm_steps = options.norm_steps. # convert array based time-dependence to string format; H, c_ops, args = _td_wrap_array_str(H, c_ops, args, tlist). # SETUP ODE DATA IF NONE EXISTS OR NOT REUSING; # --------------------------------------------; if not options.rhs_reuse or not config.tdfunc:; # reset config collapse and time-dependence flags to default values; config.soft_reset(). # check for type of time-dependence (if any); time_type, h_stuff, c_stuff = _td_format_check(H, c_ops, 'mc'); c_terms = len(c_stuff[0]) + len(c_stuff[1]) + len(c_stuff[2]); # set time_type for use in multiprocessing; config.tflag = time_type. # check for collapse operators; if c_terms > 0:; config.cflag = 1; else:; config.cflag = 0. # Configure data; _mc_data_config(H, psi0, h_stuff, c_ops, c_stuff, args, e_ops,; options, config). # compile and load cython functions if necessary; _mc_func_load(config). else:; # setup args for new parameters when rhs_reuse=True and tdfunc is given; # string based; if config.tflag in [1, 10, 11]:; if any(args):; config.c_args = []; arg_items = list(args.items()); for k in range(len(arg_items)):; config.c_args.append(arg_items[k][1]); # function based; elif config.tflag in [2, 3, 20, 22]:; config.h_func_args = args. # load monte carlo class; mc = _MC(config). # Run the simulation; mc.run(). # Remove ",MatchSource.WIKI,docs/4.2/modules/qutip/mcsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html
https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:8550,Modifiability,config,config,8550,"tions.tidy:; config.psi0 = psi0.tidyup(options.atol).full().ravel(); else:; config.psi0 = psi0.full().ravel(). config.psi0_dims = psi0.dims; config.psi0_shape = psi0.shape. # set options on ouput states; if config.options.steady_state_average:; config.options.average_states = True. # set general items; config.tlist = tlist; if isinstance(ntraj, (list, np.ndarray)):; config.ntraj = np.sort(ntraj)[-1]; else:; config.ntraj = ntraj. # set norm finding constants; config.norm_tol = options.norm_tol; config.norm_steps = options.norm_steps. # convert array based time-dependence to string format; H, c_ops, args = _td_wrap_array_str(H, c_ops, args, tlist). # SETUP ODE DATA IF NONE EXISTS OR NOT REUSING; # --------------------------------------------; if not options.rhs_reuse or not config.tdfunc:; # reset config collapse and time-dependence flags to default values; config.soft_reset(). # check for type of time-dependence (if any); time_type, h_stuff, c_stuff = _td_format_check(H, c_ops, 'mc'); c_terms = len(c_stuff[0]) + len(c_stuff[1]) + len(c_stuff[2]); # set time_type for use in multiprocessing; config.tflag = time_type. # check for collapse operators; if c_terms > 0:; config.cflag = 1; else:; config.cflag = 0. # Configure data; _mc_data_config(H, psi0, h_stuff, c_ops, c_stuff, args, e_ops,; options, config). # compile and load cython functions if necessary; _mc_func_load(config). else:; # setup args for new parameters when rhs_reuse=True and tdfunc is given; # string based; if config.tflag in [1, 10, 11]:; if any(args):; config.c_args = []; arg_items = list(args.items()); for k in range(len(arg_items)):; config.c_args.append(arg_items[k][1]); # function based; elif config.tflag in [2, 3, 20, 22]:; config.h_func_args = args. # load monte carlo class; mc = _MC(config). # Run the simulation; mc.run(). # Remove RHS cython file if necessary; if not options.rhs_reuse and config.tdname:; _cython_build_cleanup(config.tdname). # AFTER MCSOLVER IS DONE; # ----------------------. # S",MatchSource.WIKI,docs/4.2/modules/qutip/mcsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html
https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:8625,Modifiability,config,config,8625,"= psi0.shape. # set options on ouput states; if config.options.steady_state_average:; config.options.average_states = True. # set general items; config.tlist = tlist; if isinstance(ntraj, (list, np.ndarray)):; config.ntraj = np.sort(ntraj)[-1]; else:; config.ntraj = ntraj. # set norm finding constants; config.norm_tol = options.norm_tol; config.norm_steps = options.norm_steps. # convert array based time-dependence to string format; H, c_ops, args = _td_wrap_array_str(H, c_ops, args, tlist). # SETUP ODE DATA IF NONE EXISTS OR NOT REUSING; # --------------------------------------------; if not options.rhs_reuse or not config.tdfunc:; # reset config collapse and time-dependence flags to default values; config.soft_reset(). # check for type of time-dependence (if any); time_type, h_stuff, c_stuff = _td_format_check(H, c_ops, 'mc'); c_terms = len(c_stuff[0]) + len(c_stuff[1]) + len(c_stuff[2]); # set time_type for use in multiprocessing; config.tflag = time_type. # check for collapse operators; if c_terms > 0:; config.cflag = 1; else:; config.cflag = 0. # Configure data; _mc_data_config(H, psi0, h_stuff, c_ops, c_stuff, args, e_ops,; options, config). # compile and load cython functions if necessary; _mc_func_load(config). else:; # setup args for new parameters when rhs_reuse=True and tdfunc is given; # string based; if config.tflag in [1, 10, 11]:; if any(args):; config.c_args = []; arg_items = list(args.items()); for k in range(len(arg_items)):; config.c_args.append(arg_items[k][1]); # function based; elif config.tflag in [2, 3, 20, 22]:; config.h_func_args = args. # load monte carlo class; mc = _MC(config). # Run the simulation; mc.run(). # Remove RHS cython file if necessary; if not options.rhs_reuse and config.tdname:; _cython_build_cleanup(config.tdname). # AFTER MCSOLVER IS DONE; # ----------------------. # Store results in the Result object; output = Result(); output.solver = 'mcsolve'; output.seeds = config.options.seeds; # state vectors; if (mc.psi_out is not No",MatchSource.WIKI,docs/4.2/modules/qutip/mcsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html
https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:8650,Modifiability,config,config,8650,"es; if config.options.steady_state_average:; config.options.average_states = True. # set general items; config.tlist = tlist; if isinstance(ntraj, (list, np.ndarray)):; config.ntraj = np.sort(ntraj)[-1]; else:; config.ntraj = ntraj. # set norm finding constants; config.norm_tol = options.norm_tol; config.norm_steps = options.norm_steps. # convert array based time-dependence to string format; H, c_ops, args = _td_wrap_array_str(H, c_ops, args, tlist). # SETUP ODE DATA IF NONE EXISTS OR NOT REUSING; # --------------------------------------------; if not options.rhs_reuse or not config.tdfunc:; # reset config collapse and time-dependence flags to default values; config.soft_reset(). # check for type of time-dependence (if any); time_type, h_stuff, c_stuff = _td_format_check(H, c_ops, 'mc'); c_terms = len(c_stuff[0]) + len(c_stuff[1]) + len(c_stuff[2]); # set time_type for use in multiprocessing; config.tflag = time_type. # check for collapse operators; if c_terms > 0:; config.cflag = 1; else:; config.cflag = 0. # Configure data; _mc_data_config(H, psi0, h_stuff, c_ops, c_stuff, args, e_ops,; options, config). # compile and load cython functions if necessary; _mc_func_load(config). else:; # setup args for new parameters when rhs_reuse=True and tdfunc is given; # string based; if config.tflag in [1, 10, 11]:; if any(args):; config.c_args = []; arg_items = list(args.items()); for k in range(len(arg_items)):; config.c_args.append(arg_items[k][1]); # function based; elif config.tflag in [2, 3, 20, 22]:; config.h_func_args = args. # load monte carlo class; mc = _MC(config). # Run the simulation; mc.run(). # Remove RHS cython file if necessary; if not options.rhs_reuse and config.tdname:; _cython_build_cleanup(config.tdname). # AFTER MCSOLVER IS DONE; # ----------------------. # Store results in the Result object; output = Result(); output.solver = 'mcsolve'; output.seeds = config.options.seeds; # state vectors; if (mc.psi_out is not None and config.options.average_states; and",MatchSource.WIKI,docs/4.2/modules/qutip/mcsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html
https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:8759,Modifiability,config,config,8759,"s = True. # set general items; config.tlist = tlist; if isinstance(ntraj, (list, np.ndarray)):; config.ntraj = np.sort(ntraj)[-1]; else:; config.ntraj = ntraj. # set norm finding constants; config.norm_tol = options.norm_tol; config.norm_steps = options.norm_steps. # convert array based time-dependence to string format; H, c_ops, args = _td_wrap_array_str(H, c_ops, args, tlist). # SETUP ODE DATA IF NONE EXISTS OR NOT REUSING; # --------------------------------------------; if not options.rhs_reuse or not config.tdfunc:; # reset config collapse and time-dependence flags to default values; config.soft_reset(). # check for type of time-dependence (if any); time_type, h_stuff, c_stuff = _td_format_check(H, c_ops, 'mc'); c_terms = len(c_stuff[0]) + len(c_stuff[1]) + len(c_stuff[2]); # set time_type for use in multiprocessing; config.tflag = time_type. # check for collapse operators; if c_terms > 0:; config.cflag = 1; else:; config.cflag = 0. # Configure data; _mc_data_config(H, psi0, h_stuff, c_ops, c_stuff, args, e_ops,; options, config). # compile and load cython functions if necessary; _mc_func_load(config). else:; # setup args for new parameters when rhs_reuse=True and tdfunc is given; # string based; if config.tflag in [1, 10, 11]:; if any(args):; config.c_args = []; arg_items = list(args.items()); for k in range(len(arg_items)):; config.c_args.append(arg_items[k][1]); # function based; elif config.tflag in [2, 3, 20, 22]:; config.h_func_args = args. # load monte carlo class; mc = _MC(config). # Run the simulation; mc.run(). # Remove RHS cython file if necessary; if not options.rhs_reuse and config.tdname:; _cython_build_cleanup(config.tdname). # AFTER MCSOLVER IS DONE; # ----------------------. # Store results in the Result object; output = Result(); output.solver = 'mcsolve'; output.seeds = config.options.seeds; # state vectors; if (mc.psi_out is not None and config.options.average_states; and config.cflag and ntraj != 1):; output.states = parfor(_mc_dm_avg, mc.ps",MatchSource.WIKI,docs/4.2/modules/qutip/mcsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html
https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:8832,Modifiability,config,config,8832,"array)):; config.ntraj = np.sort(ntraj)[-1]; else:; config.ntraj = ntraj. # set norm finding constants; config.norm_tol = options.norm_tol; config.norm_steps = options.norm_steps. # convert array based time-dependence to string format; H, c_ops, args = _td_wrap_array_str(H, c_ops, args, tlist). # SETUP ODE DATA IF NONE EXISTS OR NOT REUSING; # --------------------------------------------; if not options.rhs_reuse or not config.tdfunc:; # reset config collapse and time-dependence flags to default values; config.soft_reset(). # check for type of time-dependence (if any); time_type, h_stuff, c_stuff = _td_format_check(H, c_ops, 'mc'); c_terms = len(c_stuff[0]) + len(c_stuff[1]) + len(c_stuff[2]); # set time_type for use in multiprocessing; config.tflag = time_type. # check for collapse operators; if c_terms > 0:; config.cflag = 1; else:; config.cflag = 0. # Configure data; _mc_data_config(H, psi0, h_stuff, c_ops, c_stuff, args, e_ops,; options, config). # compile and load cython functions if necessary; _mc_func_load(config). else:; # setup args for new parameters when rhs_reuse=True and tdfunc is given; # string based; if config.tflag in [1, 10, 11]:; if any(args):; config.c_args = []; arg_items = list(args.items()); for k in range(len(arg_items)):; config.c_args.append(arg_items[k][1]); # function based; elif config.tflag in [2, 3, 20, 22]:; config.h_func_args = args. # load monte carlo class; mc = _MC(config). # Run the simulation; mc.run(). # Remove RHS cython file if necessary; if not options.rhs_reuse and config.tdname:; _cython_build_cleanup(config.tdname). # AFTER MCSOLVER IS DONE; # ----------------------. # Store results in the Result object; output = Result(); output.solver = 'mcsolve'; output.seeds = config.options.seeds; # state vectors; if (mc.psi_out is not None and config.options.average_states; and config.cflag and ntraj != 1):; output.states = parfor(_mc_dm_avg, mc.psi_out.T); elif mc.psi_out is not None:; output.states = mc.psi_out. # expectation value",MatchSource.WIKI,docs/4.2/modules/qutip/mcsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html
https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:8940,Modifiability,config,config,8940,"ng constants; config.norm_tol = options.norm_tol; config.norm_steps = options.norm_steps. # convert array based time-dependence to string format; H, c_ops, args = _td_wrap_array_str(H, c_ops, args, tlist). # SETUP ODE DATA IF NONE EXISTS OR NOT REUSING; # --------------------------------------------; if not options.rhs_reuse or not config.tdfunc:; # reset config collapse and time-dependence flags to default values; config.soft_reset(). # check for type of time-dependence (if any); time_type, h_stuff, c_stuff = _td_format_check(H, c_ops, 'mc'); c_terms = len(c_stuff[0]) + len(c_stuff[1]) + len(c_stuff[2]); # set time_type for use in multiprocessing; config.tflag = time_type. # check for collapse operators; if c_terms > 0:; config.cflag = 1; else:; config.cflag = 0. # Configure data; _mc_data_config(H, psi0, h_stuff, c_ops, c_stuff, args, e_ops,; options, config). # compile and load cython functions if necessary; _mc_func_load(config). else:; # setup args for new parameters when rhs_reuse=True and tdfunc is given; # string based; if config.tflag in [1, 10, 11]:; if any(args):; config.c_args = []; arg_items = list(args.items()); for k in range(len(arg_items)):; config.c_args.append(arg_items[k][1]); # function based; elif config.tflag in [2, 3, 20, 22]:; config.h_func_args = args. # load monte carlo class; mc = _MC(config). # Run the simulation; mc.run(). # Remove RHS cython file if necessary; if not options.rhs_reuse and config.tdname:; _cython_build_cleanup(config.tdname). # AFTER MCSOLVER IS DONE; # ----------------------. # Store results in the Result object; output = Result(); output.solver = 'mcsolve'; output.seeds = config.options.seeds; # state vectors; if (mc.psi_out is not None and config.options.average_states; and config.cflag and ntraj != 1):; output.states = parfor(_mc_dm_avg, mc.psi_out.T); elif mc.psi_out is not None:; output.states = mc.psi_out. # expectation values; if (mc.expect_out is not None and config.cflag; and config.options.average_expect):; # ",MatchSource.WIKI,docs/4.2/modules/qutip/mcsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html
https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:8985,Modifiability,config,config,8985,"s.norm_steps. # convert array based time-dependence to string format; H, c_ops, args = _td_wrap_array_str(H, c_ops, args, tlist). # SETUP ODE DATA IF NONE EXISTS OR NOT REUSING; # --------------------------------------------; if not options.rhs_reuse or not config.tdfunc:; # reset config collapse and time-dependence flags to default values; config.soft_reset(). # check for type of time-dependence (if any); time_type, h_stuff, c_stuff = _td_format_check(H, c_ops, 'mc'); c_terms = len(c_stuff[0]) + len(c_stuff[1]) + len(c_stuff[2]); # set time_type for use in multiprocessing; config.tflag = time_type. # check for collapse operators; if c_terms > 0:; config.cflag = 1; else:; config.cflag = 0. # Configure data; _mc_data_config(H, psi0, h_stuff, c_ops, c_stuff, args, e_ops,; options, config). # compile and load cython functions if necessary; _mc_func_load(config). else:; # setup args for new parameters when rhs_reuse=True and tdfunc is given; # string based; if config.tflag in [1, 10, 11]:; if any(args):; config.c_args = []; arg_items = list(args.items()); for k in range(len(arg_items)):; config.c_args.append(arg_items[k][1]); # function based; elif config.tflag in [2, 3, 20, 22]:; config.h_func_args = args. # load monte carlo class; mc = _MC(config). # Run the simulation; mc.run(). # Remove RHS cython file if necessary; if not options.rhs_reuse and config.tdname:; _cython_build_cleanup(config.tdname). # AFTER MCSOLVER IS DONE; # ----------------------. # Store results in the Result object; output = Result(); output.solver = 'mcsolve'; output.seeds = config.options.seeds; # state vectors; if (mc.psi_out is not None and config.options.average_states; and config.cflag and ntraj != 1):; output.states = parfor(_mc_dm_avg, mc.psi_out.T); elif mc.psi_out is not None:; output.states = mc.psi_out. # expectation values; if (mc.expect_out is not None and config.cflag; and config.options.average_expect):; # averaging if multiple trajectories; if isinstance(ntraj, int):; output.expec",MatchSource.WIKI,docs/4.2/modules/qutip/mcsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html
https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:9070,Modifiability,config,config,9070,"s = _td_wrap_array_str(H, c_ops, args, tlist). # SETUP ODE DATA IF NONE EXISTS OR NOT REUSING; # --------------------------------------------; if not options.rhs_reuse or not config.tdfunc:; # reset config collapse and time-dependence flags to default values; config.soft_reset(). # check for type of time-dependence (if any); time_type, h_stuff, c_stuff = _td_format_check(H, c_ops, 'mc'); c_terms = len(c_stuff[0]) + len(c_stuff[1]) + len(c_stuff[2]); # set time_type for use in multiprocessing; config.tflag = time_type. # check for collapse operators; if c_terms > 0:; config.cflag = 1; else:; config.cflag = 0. # Configure data; _mc_data_config(H, psi0, h_stuff, c_ops, c_stuff, args, e_ops,; options, config). # compile and load cython functions if necessary; _mc_func_load(config). else:; # setup args for new parameters when rhs_reuse=True and tdfunc is given; # string based; if config.tflag in [1, 10, 11]:; if any(args):; config.c_args = []; arg_items = list(args.items()); for k in range(len(arg_items)):; config.c_args.append(arg_items[k][1]); # function based; elif config.tflag in [2, 3, 20, 22]:; config.h_func_args = args. # load monte carlo class; mc = _MC(config). # Run the simulation; mc.run(). # Remove RHS cython file if necessary; if not options.rhs_reuse and config.tdname:; _cython_build_cleanup(config.tdname). # AFTER MCSOLVER IS DONE; # ----------------------. # Store results in the Result object; output = Result(); output.solver = 'mcsolve'; output.seeds = config.options.seeds; # state vectors; if (mc.psi_out is not None and config.options.average_states; and config.cflag and ntraj != 1):; output.states = parfor(_mc_dm_avg, mc.psi_out.T); elif mc.psi_out is not None:; output.states = mc.psi_out. # expectation values; if (mc.expect_out is not None and config.cflag; and config.options.average_expect):; # averaging if multiple trajectories; if isinstance(ntraj, int):; output.expect = [np.mean(np.array([mc.expect_out[nt][op]; for nt in range(ntraj)],; dtype=obje",MatchSource.WIKI,docs/4.2/modules/qutip/mcsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html
https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:9132,Modifiability,config,config,9132,"DATA IF NONE EXISTS OR NOT REUSING; # --------------------------------------------; if not options.rhs_reuse or not config.tdfunc:; # reset config collapse and time-dependence flags to default values; config.soft_reset(). # check for type of time-dependence (if any); time_type, h_stuff, c_stuff = _td_format_check(H, c_ops, 'mc'); c_terms = len(c_stuff[0]) + len(c_stuff[1]) + len(c_stuff[2]); # set time_type for use in multiprocessing; config.tflag = time_type. # check for collapse operators; if c_terms > 0:; config.cflag = 1; else:; config.cflag = 0. # Configure data; _mc_data_config(H, psi0, h_stuff, c_ops, c_stuff, args, e_ops,; options, config). # compile and load cython functions if necessary; _mc_func_load(config). else:; # setup args for new parameters when rhs_reuse=True and tdfunc is given; # string based; if config.tflag in [1, 10, 11]:; if any(args):; config.c_args = []; arg_items = list(args.items()); for k in range(len(arg_items)):; config.c_args.append(arg_items[k][1]); # function based; elif config.tflag in [2, 3, 20, 22]:; config.h_func_args = args. # load monte carlo class; mc = _MC(config). # Run the simulation; mc.run(). # Remove RHS cython file if necessary; if not options.rhs_reuse and config.tdname:; _cython_build_cleanup(config.tdname). # AFTER MCSOLVER IS DONE; # ----------------------. # Store results in the Result object; output = Result(); output.solver = 'mcsolve'; output.seeds = config.options.seeds; # state vectors; if (mc.psi_out is not None and config.options.average_states; and config.cflag and ntraj != 1):; output.states = parfor(_mc_dm_avg, mc.psi_out.T); elif mc.psi_out is not None:; output.states = mc.psi_out. # expectation values; if (mc.expect_out is not None and config.cflag; and config.options.average_expect):; # averaging if multiple trajectories; if isinstance(ntraj, int):; output.expect = [np.mean(np.array([mc.expect_out[nt][op]; for nt in range(ntraj)],; dtype=object),; axis=0); for op in range(config.e_num)]; elif isinstan",MatchSource.WIKI,docs/4.2/modules/qutip/mcsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html
https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:9165,Modifiability,config,config,9165,"--------------------------------------; if not options.rhs_reuse or not config.tdfunc:; # reset config collapse and time-dependence flags to default values; config.soft_reset(). # check for type of time-dependence (if any); time_type, h_stuff, c_stuff = _td_format_check(H, c_ops, 'mc'); c_terms = len(c_stuff[0]) + len(c_stuff[1]) + len(c_stuff[2]); # set time_type for use in multiprocessing; config.tflag = time_type. # check for collapse operators; if c_terms > 0:; config.cflag = 1; else:; config.cflag = 0. # Configure data; _mc_data_config(H, psi0, h_stuff, c_ops, c_stuff, args, e_ops,; options, config). # compile and load cython functions if necessary; _mc_func_load(config). else:; # setup args for new parameters when rhs_reuse=True and tdfunc is given; # string based; if config.tflag in [1, 10, 11]:; if any(args):; config.c_args = []; arg_items = list(args.items()); for k in range(len(arg_items)):; config.c_args.append(arg_items[k][1]); # function based; elif config.tflag in [2, 3, 20, 22]:; config.h_func_args = args. # load monte carlo class; mc = _MC(config). # Run the simulation; mc.run(). # Remove RHS cython file if necessary; if not options.rhs_reuse and config.tdname:; _cython_build_cleanup(config.tdname). # AFTER MCSOLVER IS DONE; # ----------------------. # Store results in the Result object; output = Result(); output.solver = 'mcsolve'; output.seeds = config.options.seeds; # state vectors; if (mc.psi_out is not None and config.options.average_states; and config.cflag and ntraj != 1):; output.states = parfor(_mc_dm_avg, mc.psi_out.T); elif mc.psi_out is not None:; output.states = mc.psi_out. # expectation values; if (mc.expect_out is not None and config.cflag; and config.options.average_expect):; # averaging if multiple trajectories; if isinstance(ntraj, int):; output.expect = [np.mean(np.array([mc.expect_out[nt][op]; for nt in range(ntraj)],; dtype=object),; axis=0); for op in range(config.e_num)]; elif isinstance(ntraj, (list, np.ndarray)):; output.expec",MatchSource.WIKI,docs/4.2/modules/qutip/mcsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html
https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:9227,Modifiability,config,config,9227,"_reuse or not config.tdfunc:; # reset config collapse and time-dependence flags to default values; config.soft_reset(). # check for type of time-dependence (if any); time_type, h_stuff, c_stuff = _td_format_check(H, c_ops, 'mc'); c_terms = len(c_stuff[0]) + len(c_stuff[1]) + len(c_stuff[2]); # set time_type for use in multiprocessing; config.tflag = time_type. # check for collapse operators; if c_terms > 0:; config.cflag = 1; else:; config.cflag = 0. # Configure data; _mc_data_config(H, psi0, h_stuff, c_ops, c_stuff, args, e_ops,; options, config). # compile and load cython functions if necessary; _mc_func_load(config). else:; # setup args for new parameters when rhs_reuse=True and tdfunc is given; # string based; if config.tflag in [1, 10, 11]:; if any(args):; config.c_args = []; arg_items = list(args.items()); for k in range(len(arg_items)):; config.c_args.append(arg_items[k][1]); # function based; elif config.tflag in [2, 3, 20, 22]:; config.h_func_args = args. # load monte carlo class; mc = _MC(config). # Run the simulation; mc.run(). # Remove RHS cython file if necessary; if not options.rhs_reuse and config.tdname:; _cython_build_cleanup(config.tdname). # AFTER MCSOLVER IS DONE; # ----------------------. # Store results in the Result object; output = Result(); output.solver = 'mcsolve'; output.seeds = config.options.seeds; # state vectors; if (mc.psi_out is not None and config.options.average_states; and config.cflag and ntraj != 1):; output.states = parfor(_mc_dm_avg, mc.psi_out.T); elif mc.psi_out is not None:; output.states = mc.psi_out. # expectation values; if (mc.expect_out is not None and config.cflag; and config.options.average_expect):; # averaging if multiple trajectories; if isinstance(ntraj, int):; output.expect = [np.mean(np.array([mc.expect_out[nt][op]; for nt in range(ntraj)],; dtype=object),; axis=0); for op in range(config.e_num)]; elif isinstance(ntraj, (list, np.ndarray)):; output.expect = []; for num in ntraj:; expt_data = np.mean(mc.expect_",MatchSource.WIKI,docs/4.2/modules/qutip/mcsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html
https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:9336,Modifiability,config,config,9336," # check for type of time-dependence (if any); time_type, h_stuff, c_stuff = _td_format_check(H, c_ops, 'mc'); c_terms = len(c_stuff[0]) + len(c_stuff[1]) + len(c_stuff[2]); # set time_type for use in multiprocessing; config.tflag = time_type. # check for collapse operators; if c_terms > 0:; config.cflag = 1; else:; config.cflag = 0. # Configure data; _mc_data_config(H, psi0, h_stuff, c_ops, c_stuff, args, e_ops,; options, config). # compile and load cython functions if necessary; _mc_func_load(config). else:; # setup args for new parameters when rhs_reuse=True and tdfunc is given; # string based; if config.tflag in [1, 10, 11]:; if any(args):; config.c_args = []; arg_items = list(args.items()); for k in range(len(arg_items)):; config.c_args.append(arg_items[k][1]); # function based; elif config.tflag in [2, 3, 20, 22]:; config.h_func_args = args. # load monte carlo class; mc = _MC(config). # Run the simulation; mc.run(). # Remove RHS cython file if necessary; if not options.rhs_reuse and config.tdname:; _cython_build_cleanup(config.tdname). # AFTER MCSOLVER IS DONE; # ----------------------. # Store results in the Result object; output = Result(); output.solver = 'mcsolve'; output.seeds = config.options.seeds; # state vectors; if (mc.psi_out is not None and config.options.average_states; and config.cflag and ntraj != 1):; output.states = parfor(_mc_dm_avg, mc.psi_out.T); elif mc.psi_out is not None:; output.states = mc.psi_out. # expectation values; if (mc.expect_out is not None and config.cflag; and config.options.average_expect):; # averaging if multiple trajectories; if isinstance(ntraj, int):; output.expect = [np.mean(np.array([mc.expect_out[nt][op]; for nt in range(ntraj)],; dtype=object),; axis=0); for op in range(config.e_num)]; elif isinstance(ntraj, (list, np.ndarray)):; output.expect = []; for num in ntraj:; expt_data = np.mean(mc.expect_out[:num], axis=0); data_list = []; if any([not op.isherm for op in e_ops]):; for k in range(len(e_ops)):; if e_ops[k].i",MatchSource.WIKI,docs/4.2/modules/qutip/mcsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html
https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:9374,Modifiability,config,config,9374,"ndence (if any); time_type, h_stuff, c_stuff = _td_format_check(H, c_ops, 'mc'); c_terms = len(c_stuff[0]) + len(c_stuff[1]) + len(c_stuff[2]); # set time_type for use in multiprocessing; config.tflag = time_type. # check for collapse operators; if c_terms > 0:; config.cflag = 1; else:; config.cflag = 0. # Configure data; _mc_data_config(H, psi0, h_stuff, c_ops, c_stuff, args, e_ops,; options, config). # compile and load cython functions if necessary; _mc_func_load(config). else:; # setup args for new parameters when rhs_reuse=True and tdfunc is given; # string based; if config.tflag in [1, 10, 11]:; if any(args):; config.c_args = []; arg_items = list(args.items()); for k in range(len(arg_items)):; config.c_args.append(arg_items[k][1]); # function based; elif config.tflag in [2, 3, 20, 22]:; config.h_func_args = args. # load monte carlo class; mc = _MC(config). # Run the simulation; mc.run(). # Remove RHS cython file if necessary; if not options.rhs_reuse and config.tdname:; _cython_build_cleanup(config.tdname). # AFTER MCSOLVER IS DONE; # ----------------------. # Store results in the Result object; output = Result(); output.solver = 'mcsolve'; output.seeds = config.options.seeds; # state vectors; if (mc.psi_out is not None and config.options.average_states; and config.cflag and ntraj != 1):; output.states = parfor(_mc_dm_avg, mc.psi_out.T); elif mc.psi_out is not None:; output.states = mc.psi_out. # expectation values; if (mc.expect_out is not None and config.cflag; and config.options.average_expect):; # averaging if multiple trajectories; if isinstance(ntraj, int):; output.expect = [np.mean(np.array([mc.expect_out[nt][op]; for nt in range(ntraj)],; dtype=object),; axis=0); for op in range(config.e_num)]; elif isinstance(ntraj, (list, np.ndarray)):; output.expect = []; for num in ntraj:; expt_data = np.mean(mc.expect_out[:num], axis=0); data_list = []; if any([not op.isherm for op in e_ops]):; for k in range(len(e_ops)):; if e_ops[k].isherm:; data_list.append(np.r",MatchSource.WIKI,docs/4.2/modules/qutip/mcsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html
https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:9541,Modifiability,config,config,9541,"ocessing; config.tflag = time_type. # check for collapse operators; if c_terms > 0:; config.cflag = 1; else:; config.cflag = 0. # Configure data; _mc_data_config(H, psi0, h_stuff, c_ops, c_stuff, args, e_ops,; options, config). # compile and load cython functions if necessary; _mc_func_load(config). else:; # setup args for new parameters when rhs_reuse=True and tdfunc is given; # string based; if config.tflag in [1, 10, 11]:; if any(args):; config.c_args = []; arg_items = list(args.items()); for k in range(len(arg_items)):; config.c_args.append(arg_items[k][1]); # function based; elif config.tflag in [2, 3, 20, 22]:; config.h_func_args = args. # load monte carlo class; mc = _MC(config). # Run the simulation; mc.run(). # Remove RHS cython file if necessary; if not options.rhs_reuse and config.tdname:; _cython_build_cleanup(config.tdname). # AFTER MCSOLVER IS DONE; # ----------------------. # Store results in the Result object; output = Result(); output.solver = 'mcsolve'; output.seeds = config.options.seeds; # state vectors; if (mc.psi_out is not None and config.options.average_states; and config.cflag and ntraj != 1):; output.states = parfor(_mc_dm_avg, mc.psi_out.T); elif mc.psi_out is not None:; output.states = mc.psi_out. # expectation values; if (mc.expect_out is not None and config.cflag; and config.options.average_expect):; # averaging if multiple trajectories; if isinstance(ntraj, int):; output.expect = [np.mean(np.array([mc.expect_out[nt][op]; for nt in range(ntraj)],; dtype=object),; axis=0); for op in range(config.e_num)]; elif isinstance(ntraj, (list, np.ndarray)):; output.expect = []; for num in ntraj:; expt_data = np.mean(mc.expect_out[:num], axis=0); data_list = []; if any([not op.isherm for op in e_ops]):; for k in range(len(e_ops)):; if e_ops[k].isherm:; data_list.append(np.real(expt_data[k])); else:; data_list.append(expt_data[k]); else:; data_list = [data for data in expt_data]; output.expect.append(data_list); else:; # no averaging for single traje",MatchSource.WIKI,docs/4.2/modules/qutip/mcsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html
https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:9611,Modifiability,config,config,9611,"tors; if c_terms > 0:; config.cflag = 1; else:; config.cflag = 0. # Configure data; _mc_data_config(H, psi0, h_stuff, c_ops, c_stuff, args, e_ops,; options, config). # compile and load cython functions if necessary; _mc_func_load(config). else:; # setup args for new parameters when rhs_reuse=True and tdfunc is given; # string based; if config.tflag in [1, 10, 11]:; if any(args):; config.c_args = []; arg_items = list(args.items()); for k in range(len(arg_items)):; config.c_args.append(arg_items[k][1]); # function based; elif config.tflag in [2, 3, 20, 22]:; config.h_func_args = args. # load monte carlo class; mc = _MC(config). # Run the simulation; mc.run(). # Remove RHS cython file if necessary; if not options.rhs_reuse and config.tdname:; _cython_build_cleanup(config.tdname). # AFTER MCSOLVER IS DONE; # ----------------------. # Store results in the Result object; output = Result(); output.solver = 'mcsolve'; output.seeds = config.options.seeds; # state vectors; if (mc.psi_out is not None and config.options.average_states; and config.cflag and ntraj != 1):; output.states = parfor(_mc_dm_avg, mc.psi_out.T); elif mc.psi_out is not None:; output.states = mc.psi_out. # expectation values; if (mc.expect_out is not None and config.cflag; and config.options.average_expect):; # averaging if multiple trajectories; if isinstance(ntraj, int):; output.expect = [np.mean(np.array([mc.expect_out[nt][op]; for nt in range(ntraj)],; dtype=object),; axis=0); for op in range(config.e_num)]; elif isinstance(ntraj, (list, np.ndarray)):; output.expect = []; for num in ntraj:; expt_data = np.mean(mc.expect_out[:num], axis=0); data_list = []; if any([not op.isherm for op in e_ops]):; for k in range(len(e_ops)):; if e_ops[k].isherm:; data_list.append(np.real(expt_data[k])); else:; data_list.append(expt_data[k]); else:; data_list = [data for data in expt_data]; output.expect.append(data_list); else:; # no averaging for single trajectory or if average_expect flag; # (Options) is off; if mc.exp",MatchSource.WIKI,docs/4.2/modules/qutip/mcsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html
https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:9646,Modifiability,config,config,9646," 1; else:; config.cflag = 0. # Configure data; _mc_data_config(H, psi0, h_stuff, c_ops, c_stuff, args, e_ops,; options, config). # compile and load cython functions if necessary; _mc_func_load(config). else:; # setup args for new parameters when rhs_reuse=True and tdfunc is given; # string based; if config.tflag in [1, 10, 11]:; if any(args):; config.c_args = []; arg_items = list(args.items()); for k in range(len(arg_items)):; config.c_args.append(arg_items[k][1]); # function based; elif config.tflag in [2, 3, 20, 22]:; config.h_func_args = args. # load monte carlo class; mc = _MC(config). # Run the simulation; mc.run(). # Remove RHS cython file if necessary; if not options.rhs_reuse and config.tdname:; _cython_build_cleanup(config.tdname). # AFTER MCSOLVER IS DONE; # ----------------------. # Store results in the Result object; output = Result(); output.solver = 'mcsolve'; output.seeds = config.options.seeds; # state vectors; if (mc.psi_out is not None and config.options.average_states; and config.cflag and ntraj != 1):; output.states = parfor(_mc_dm_avg, mc.psi_out.T); elif mc.psi_out is not None:; output.states = mc.psi_out. # expectation values; if (mc.expect_out is not None and config.cflag; and config.options.average_expect):; # averaging if multiple trajectories; if isinstance(ntraj, int):; output.expect = [np.mean(np.array([mc.expect_out[nt][op]; for nt in range(ntraj)],; dtype=object),; axis=0); for op in range(config.e_num)]; elif isinstance(ntraj, (list, np.ndarray)):; output.expect = []; for num in ntraj:; expt_data = np.mean(mc.expect_out[:num], axis=0); data_list = []; if any([not op.isherm for op in e_ops]):; for k in range(len(e_ops)):; if e_ops[k].isherm:; data_list.append(np.real(expt_data[k])); else:; data_list.append(expt_data[k]); else:; data_list = [data for data in expt_data]; output.expect.append(data_list); else:; # no averaging for single trajectory or if average_expect flag; # (Options) is off; if mc.expect_out is not None:; output.expect =",MatchSource.WIKI,docs/4.2/modules/qutip/mcsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html
https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:9841,Modifiability,config,config,9841,"(config). else:; # setup args for new parameters when rhs_reuse=True and tdfunc is given; # string based; if config.tflag in [1, 10, 11]:; if any(args):; config.c_args = []; arg_items = list(args.items()); for k in range(len(arg_items)):; config.c_args.append(arg_items[k][1]); # function based; elif config.tflag in [2, 3, 20, 22]:; config.h_func_args = args. # load monte carlo class; mc = _MC(config). # Run the simulation; mc.run(). # Remove RHS cython file if necessary; if not options.rhs_reuse and config.tdname:; _cython_build_cleanup(config.tdname). # AFTER MCSOLVER IS DONE; # ----------------------. # Store results in the Result object; output = Result(); output.solver = 'mcsolve'; output.seeds = config.options.seeds; # state vectors; if (mc.psi_out is not None and config.options.average_states; and config.cflag and ntraj != 1):; output.states = parfor(_mc_dm_avg, mc.psi_out.T); elif mc.psi_out is not None:; output.states = mc.psi_out. # expectation values; if (mc.expect_out is not None and config.cflag; and config.options.average_expect):; # averaging if multiple trajectories; if isinstance(ntraj, int):; output.expect = [np.mean(np.array([mc.expect_out[nt][op]; for nt in range(ntraj)],; dtype=object),; axis=0); for op in range(config.e_num)]; elif isinstance(ntraj, (list, np.ndarray)):; output.expect = []; for num in ntraj:; expt_data = np.mean(mc.expect_out[:num], axis=0); data_list = []; if any([not op.isherm for op in e_ops]):; for k in range(len(e_ops)):; if e_ops[k].isherm:; data_list.append(np.real(expt_data[k])); else:; data_list.append(expt_data[k]); else:; data_list = [data for data in expt_data]; output.expect.append(data_list); else:; # no averaging for single trajectory or if average_expect flag; # (Options) is off; if mc.expect_out is not None:; output.expect = mc.expect_out. # simulation parameters; output.times = config.tlist; output.num_expect = config.e_num; output.num_collapse = config.c_num; output.ntraj = config.ntraj; output.col_times = mc.",MatchSource.WIKI,docs/4.2/modules/qutip/mcsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html
https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:9859,Modifiability,config,config,9859,"rgs for new parameters when rhs_reuse=True and tdfunc is given; # string based; if config.tflag in [1, 10, 11]:; if any(args):; config.c_args = []; arg_items = list(args.items()); for k in range(len(arg_items)):; config.c_args.append(arg_items[k][1]); # function based; elif config.tflag in [2, 3, 20, 22]:; config.h_func_args = args. # load monte carlo class; mc = _MC(config). # Run the simulation; mc.run(). # Remove RHS cython file if necessary; if not options.rhs_reuse and config.tdname:; _cython_build_cleanup(config.tdname). # AFTER MCSOLVER IS DONE; # ----------------------. # Store results in the Result object; output = Result(); output.solver = 'mcsolve'; output.seeds = config.options.seeds; # state vectors; if (mc.psi_out is not None and config.options.average_states; and config.cflag and ntraj != 1):; output.states = parfor(_mc_dm_avg, mc.psi_out.T); elif mc.psi_out is not None:; output.states = mc.psi_out. # expectation values; if (mc.expect_out is not None and config.cflag; and config.options.average_expect):; # averaging if multiple trajectories; if isinstance(ntraj, int):; output.expect = [np.mean(np.array([mc.expect_out[nt][op]; for nt in range(ntraj)],; dtype=object),; axis=0); for op in range(config.e_num)]; elif isinstance(ntraj, (list, np.ndarray)):; output.expect = []; for num in ntraj:; expt_data = np.mean(mc.expect_out[:num], axis=0); data_list = []; if any([not op.isherm for op in e_ops]):; for k in range(len(e_ops)):; if e_ops[k].isherm:; data_list.append(np.real(expt_data[k])); else:; data_list.append(expt_data[k]); else:; data_list = [data for data in expt_data]; output.expect.append(data_list); else:; # no averaging for single trajectory or if average_expect flag; # (Options) is off; if mc.expect_out is not None:; output.expect = mc.expect_out. # simulation parameters; output.times = config.tlist; output.num_expect = config.e_num; output.num_collapse = config.c_num; output.ntraj = config.ntraj; output.col_times = mc.collapse_times_out; output",MatchSource.WIKI,docs/4.2/modules/qutip/mcsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html
https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:10083,Modifiability,config,config,10083,"in range(len(arg_items)):; config.c_args.append(arg_items[k][1]); # function based; elif config.tflag in [2, 3, 20, 22]:; config.h_func_args = args. # load monte carlo class; mc = _MC(config). # Run the simulation; mc.run(). # Remove RHS cython file if necessary; if not options.rhs_reuse and config.tdname:; _cython_build_cleanup(config.tdname). # AFTER MCSOLVER IS DONE; # ----------------------. # Store results in the Result object; output = Result(); output.solver = 'mcsolve'; output.seeds = config.options.seeds; # state vectors; if (mc.psi_out is not None and config.options.average_states; and config.cflag and ntraj != 1):; output.states = parfor(_mc_dm_avg, mc.psi_out.T); elif mc.psi_out is not None:; output.states = mc.psi_out. # expectation values; if (mc.expect_out is not None and config.cflag; and config.options.average_expect):; # averaging if multiple trajectories; if isinstance(ntraj, int):; output.expect = [np.mean(np.array([mc.expect_out[nt][op]; for nt in range(ntraj)],; dtype=object),; axis=0); for op in range(config.e_num)]; elif isinstance(ntraj, (list, np.ndarray)):; output.expect = []; for num in ntraj:; expt_data = np.mean(mc.expect_out[:num], axis=0); data_list = []; if any([not op.isherm for op in e_ops]):; for k in range(len(e_ops)):; if e_ops[k].isherm:; data_list.append(np.real(expt_data[k])); else:; data_list.append(expt_data[k]); else:; data_list = [data for data in expt_data]; output.expect.append(data_list); else:; # no averaging for single trajectory or if average_expect flag; # (Options) is off; if mc.expect_out is not None:; output.expect = mc.expect_out. # simulation parameters; output.times = config.tlist; output.num_expect = config.e_num; output.num_collapse = config.c_num; output.ntraj = config.ntraj; output.col_times = mc.collapse_times_out; output.col_which = mc.which_op_out. if e_ops_dict:; output.expect = {e: output.expect[n]; for n, e in enumerate(e_ops_dict.keys())}. return output. # ------------------------------------------",MatchSource.WIKI,docs/4.2/modules/qutip/mcsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html
https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:10696,Modifiability,config,config,10696,"rfor(_mc_dm_avg, mc.psi_out.T); elif mc.psi_out is not None:; output.states = mc.psi_out. # expectation values; if (mc.expect_out is not None and config.cflag; and config.options.average_expect):; # averaging if multiple trajectories; if isinstance(ntraj, int):; output.expect = [np.mean(np.array([mc.expect_out[nt][op]; for nt in range(ntraj)],; dtype=object),; axis=0); for op in range(config.e_num)]; elif isinstance(ntraj, (list, np.ndarray)):; output.expect = []; for num in ntraj:; expt_data = np.mean(mc.expect_out[:num], axis=0); data_list = []; if any([not op.isherm for op in e_ops]):; for k in range(len(e_ops)):; if e_ops[k].isherm:; data_list.append(np.real(expt_data[k])); else:; data_list.append(expt_data[k]); else:; data_list = [data for data in expt_data]; output.expect.append(data_list); else:; # no averaging for single trajectory or if average_expect flag; # (Options) is off; if mc.expect_out is not None:; output.expect = mc.expect_out. # simulation parameters; output.times = config.tlist; output.num_expect = config.e_num; output.num_collapse = config.c_num; output.ntraj = config.ntraj; output.col_times = mc.collapse_times_out; output.col_which = mc.which_op_out. if e_ops_dict:; output.expect = {e: output.expect[n]; for n, e in enumerate(e_ops_dict.keys())}. return output. # -----------------------------------------------------------------------------; # MONTE CARLO CLASS; # -----------------------------------------------------------------------------; class _MC():; """"""; Private class for solving Monte Carlo evolution from mcsolve; """""". def __init__(self, config):. self.config = config; # set output variables, even if they are not used to simplify output; # code.; self.psi_out = None; self.expect_out = []; self.collapse_times_out = None; self.which_op_out = None. # FOR EVOLUTION WITH COLLAPSE OPERATORS; if config.c_num:; # preallocate ntraj arrays for state vectors, collapse times, and; # which operator; self.collapse_times_out = np.zeros(config.ntraj, dtyp",MatchSource.WIKI,docs/4.2/modules/qutip/mcsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html
https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:10730,Modifiability,config,config,10730,"elif mc.psi_out is not None:; output.states = mc.psi_out. # expectation values; if (mc.expect_out is not None and config.cflag; and config.options.average_expect):; # averaging if multiple trajectories; if isinstance(ntraj, int):; output.expect = [np.mean(np.array([mc.expect_out[nt][op]; for nt in range(ntraj)],; dtype=object),; axis=0); for op in range(config.e_num)]; elif isinstance(ntraj, (list, np.ndarray)):; output.expect = []; for num in ntraj:; expt_data = np.mean(mc.expect_out[:num], axis=0); data_list = []; if any([not op.isherm for op in e_ops]):; for k in range(len(e_ops)):; if e_ops[k].isherm:; data_list.append(np.real(expt_data[k])); else:; data_list.append(expt_data[k]); else:; data_list = [data for data in expt_data]; output.expect.append(data_list); else:; # no averaging for single trajectory or if average_expect flag; # (Options) is off; if mc.expect_out is not None:; output.expect = mc.expect_out. # simulation parameters; output.times = config.tlist; output.num_expect = config.e_num; output.num_collapse = config.c_num; output.ntraj = config.ntraj; output.col_times = mc.collapse_times_out; output.col_which = mc.which_op_out. if e_ops_dict:; output.expect = {e: output.expect[n]; for n, e in enumerate(e_ops_dict.keys())}. return output. # -----------------------------------------------------------------------------; # MONTE CARLO CLASS; # -----------------------------------------------------------------------------; class _MC():; """"""; Private class for solving Monte Carlo evolution from mcsolve; """""". def __init__(self, config):. self.config = config; # set output variables, even if they are not used to simplify output; # code.; self.psi_out = None; self.expect_out = []; self.collapse_times_out = None; self.which_op_out = None. # FOR EVOLUTION WITH COLLAPSE OPERATORS; if config.c_num:; # preallocate ntraj arrays for state vectors, collapse times, and; # which operator; self.collapse_times_out = np.zeros(config.ntraj, dtype=np.ndarray); self.which_op_ou",MatchSource.WIKI,docs/4.2/modules/qutip/mcsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html
https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:10766,Modifiability,config,config,10766,"t.states = mc.psi_out. # expectation values; if (mc.expect_out is not None and config.cflag; and config.options.average_expect):; # averaging if multiple trajectories; if isinstance(ntraj, int):; output.expect = [np.mean(np.array([mc.expect_out[nt][op]; for nt in range(ntraj)],; dtype=object),; axis=0); for op in range(config.e_num)]; elif isinstance(ntraj, (list, np.ndarray)):; output.expect = []; for num in ntraj:; expt_data = np.mean(mc.expect_out[:num], axis=0); data_list = []; if any([not op.isherm for op in e_ops]):; for k in range(len(e_ops)):; if e_ops[k].isherm:; data_list.append(np.real(expt_data[k])); else:; data_list.append(expt_data[k]); else:; data_list = [data for data in expt_data]; output.expect.append(data_list); else:; # no averaging for single trajectory or if average_expect flag; # (Options) is off; if mc.expect_out is not None:; output.expect = mc.expect_out. # simulation parameters; output.times = config.tlist; output.num_expect = config.e_num; output.num_collapse = config.c_num; output.ntraj = config.ntraj; output.col_times = mc.collapse_times_out; output.col_which = mc.which_op_out. if e_ops_dict:; output.expect = {e: output.expect[n]; for n, e in enumerate(e_ops_dict.keys())}. return output. # -----------------------------------------------------------------------------; # MONTE CARLO CLASS; # -----------------------------------------------------------------------------; class _MC():; """"""; Private class for solving Monte Carlo evolution from mcsolve; """""". def __init__(self, config):. self.config = config; # set output variables, even if they are not used to simplify output; # code.; self.psi_out = None; self.expect_out = []; self.collapse_times_out = None; self.which_op_out = None. # FOR EVOLUTION WITH COLLAPSE OPERATORS; if config.c_num:; # preallocate ntraj arrays for state vectors, collapse times, and; # which operator; self.collapse_times_out = np.zeros(config.ntraj, dtype=np.ndarray); self.which_op_out = np.zeros(config.ntraj, dtype=np",MatchSource.WIKI,docs/4.2/modules/qutip/mcsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html
https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:10795,Modifiability,config,config,10795,"tion values; if (mc.expect_out is not None and config.cflag; and config.options.average_expect):; # averaging if multiple trajectories; if isinstance(ntraj, int):; output.expect = [np.mean(np.array([mc.expect_out[nt][op]; for nt in range(ntraj)],; dtype=object),; axis=0); for op in range(config.e_num)]; elif isinstance(ntraj, (list, np.ndarray)):; output.expect = []; for num in ntraj:; expt_data = np.mean(mc.expect_out[:num], axis=0); data_list = []; if any([not op.isherm for op in e_ops]):; for k in range(len(e_ops)):; if e_ops[k].isherm:; data_list.append(np.real(expt_data[k])); else:; data_list.append(expt_data[k]); else:; data_list = [data for data in expt_data]; output.expect.append(data_list); else:; # no averaging for single trajectory or if average_expect flag; # (Options) is off; if mc.expect_out is not None:; output.expect = mc.expect_out. # simulation parameters; output.times = config.tlist; output.num_expect = config.e_num; output.num_collapse = config.c_num; output.ntraj = config.ntraj; output.col_times = mc.collapse_times_out; output.col_which = mc.which_op_out. if e_ops_dict:; output.expect = {e: output.expect[n]; for n, e in enumerate(e_ops_dict.keys())}. return output. # -----------------------------------------------------------------------------; # MONTE CARLO CLASS; # -----------------------------------------------------------------------------; class _MC():; """"""; Private class for solving Monte Carlo evolution from mcsolve; """""". def __init__(self, config):. self.config = config; # set output variables, even if they are not used to simplify output; # code.; self.psi_out = None; self.expect_out = []; self.collapse_times_out = None; self.which_op_out = None. # FOR EVOLUTION WITH COLLAPSE OPERATORS; if config.c_num:; # preallocate ntraj arrays for state vectors, collapse times, and; # which operator; self.collapse_times_out = np.zeros(config.ntraj, dtype=np.ndarray); self.which_op_out = np.zeros(config.ntraj, dtype=np.ndarray); if config.e_num == 0 o",MatchSource.WIKI,docs/4.2/modules/qutip/mcsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html
https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:11287,Modifiability,config,config,11287,"e_ops]):; for k in range(len(e_ops)):; if e_ops[k].isherm:; data_list.append(np.real(expt_data[k])); else:; data_list.append(expt_data[k]); else:; data_list = [data for data in expt_data]; output.expect.append(data_list); else:; # no averaging for single trajectory or if average_expect flag; # (Options) is off; if mc.expect_out is not None:; output.expect = mc.expect_out. # simulation parameters; output.times = config.tlist; output.num_expect = config.e_num; output.num_collapse = config.c_num; output.ntraj = config.ntraj; output.col_times = mc.collapse_times_out; output.col_which = mc.which_op_out. if e_ops_dict:; output.expect = {e: output.expect[n]; for n, e in enumerate(e_ops_dict.keys())}. return output. # -----------------------------------------------------------------------------; # MONTE CARLO CLASS; # -----------------------------------------------------------------------------; class _MC():; """"""; Private class for solving Monte Carlo evolution from mcsolve; """""". def __init__(self, config):. self.config = config; # set output variables, even if they are not used to simplify output; # code.; self.psi_out = None; self.expect_out = []; self.collapse_times_out = None; self.which_op_out = None. # FOR EVOLUTION WITH COLLAPSE OPERATORS; if config.c_num:; # preallocate ntraj arrays for state vectors, collapse times, and; # which operator; self.collapse_times_out = np.zeros(config.ntraj, dtype=np.ndarray); self.which_op_out = np.zeros(config.ntraj, dtype=np.ndarray); if config.e_num == 0 or config.options.store_states:; self.psi_out = [None] * config.ntraj; if config.e_num > 0:; self.expect_out = [None] * config.ntraj. # setup seeds array; if self.config.options.seeds is None:; self.config.options.seeds = \; randint(1, 100000000.0 + 1, size=config.ntraj); else:; # if ntraj was reduced but reusing seeds; seed_length = len(config.options.seeds); if seed_length > config.ntraj:; self.config.options.seeds = \; config.options.seeds[0:config.ntraj]; # if ntraj was increased",MatchSource.WIKI,docs/4.2/modules/qutip/mcsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html
https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:11302,Modifiability,config,config,11302,"t.append(np.real(expt_data[k])); else:; data_list.append(expt_data[k]); else:; data_list = [data for data in expt_data]; output.expect.append(data_list); else:; # no averaging for single trajectory or if average_expect flag; # (Options) is off; if mc.expect_out is not None:; output.expect = mc.expect_out. # simulation parameters; output.times = config.tlist; output.num_expect = config.e_num; output.num_collapse = config.c_num; output.ntraj = config.ntraj; output.col_times = mc.collapse_times_out; output.col_which = mc.which_op_out. if e_ops_dict:; output.expect = {e: output.expect[n]; for n, e in enumerate(e_ops_dict.keys())}. return output. # -----------------------------------------------------------------------------; # MONTE CARLO CLASS; # -----------------------------------------------------------------------------; class _MC():; """"""; Private class for solving Monte Carlo evolution from mcsolve; """""". def __init__(self, config):. self.config = config; # set output variables, even if they are not used to simplify output; # code.; self.psi_out = None; self.expect_out = []; self.collapse_times_out = None; self.which_op_out = None. # FOR EVOLUTION WITH COLLAPSE OPERATORS; if config.c_num:; # preallocate ntraj arrays for state vectors, collapse times, and; # which operator; self.collapse_times_out = np.zeros(config.ntraj, dtype=np.ndarray); self.which_op_out = np.zeros(config.ntraj, dtype=np.ndarray); if config.e_num == 0 or config.options.store_states:; self.psi_out = [None] * config.ntraj; if config.e_num > 0:; self.expect_out = [None] * config.ntraj. # setup seeds array; if self.config.options.seeds is None:; self.config.options.seeds = \; randint(1, 100000000.0 + 1, size=config.ntraj); else:; # if ntraj was reduced but reusing seeds; seed_length = len(config.options.seeds); if seed_length > config.ntraj:; self.config.options.seeds = \; config.options.seeds[0:config.ntraj]; # if ntraj was increased but reusing seeds; elif seed_length < config.ntraj:; newseeds = ra",MatchSource.WIKI,docs/4.2/modules/qutip/mcsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html
https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:11311,Modifiability,config,config,11311,"t.append(np.real(expt_data[k])); else:; data_list.append(expt_data[k]); else:; data_list = [data for data in expt_data]; output.expect.append(data_list); else:; # no averaging for single trajectory or if average_expect flag; # (Options) is off; if mc.expect_out is not None:; output.expect = mc.expect_out. # simulation parameters; output.times = config.tlist; output.num_expect = config.e_num; output.num_collapse = config.c_num; output.ntraj = config.ntraj; output.col_times = mc.collapse_times_out; output.col_which = mc.which_op_out. if e_ops_dict:; output.expect = {e: output.expect[n]; for n, e in enumerate(e_ops_dict.keys())}. return output. # -----------------------------------------------------------------------------; # MONTE CARLO CLASS; # -----------------------------------------------------------------------------; class _MC():; """"""; Private class for solving Monte Carlo evolution from mcsolve; """""". def __init__(self, config):. self.config = config; # set output variables, even if they are not used to simplify output; # code.; self.psi_out = None; self.expect_out = []; self.collapse_times_out = None; self.which_op_out = None. # FOR EVOLUTION WITH COLLAPSE OPERATORS; if config.c_num:; # preallocate ntraj arrays for state vectors, collapse times, and; # which operator; self.collapse_times_out = np.zeros(config.ntraj, dtype=np.ndarray); self.which_op_out = np.zeros(config.ntraj, dtype=np.ndarray); if config.e_num == 0 or config.options.store_states:; self.psi_out = [None] * config.ntraj; if config.e_num > 0:; self.expect_out = [None] * config.ntraj. # setup seeds array; if self.config.options.seeds is None:; self.config.options.seeds = \; randint(1, 100000000.0 + 1, size=config.ntraj); else:; # if ntraj was reduced but reusing seeds; seed_length = len(config.options.seeds); if seed_length > config.ntraj:; self.config.options.seeds = \; config.options.seeds[0:config.ntraj]; # if ntraj was increased but reusing seeds; elif seed_length < config.ntraj:; newseeds = ra",MatchSource.WIKI,docs/4.2/modules/qutip/mcsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html
https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:11332,Modifiability,variab,variables,11332,"t.append(np.real(expt_data[k])); else:; data_list.append(expt_data[k]); else:; data_list = [data for data in expt_data]; output.expect.append(data_list); else:; # no averaging for single trajectory or if average_expect flag; # (Options) is off; if mc.expect_out is not None:; output.expect = mc.expect_out. # simulation parameters; output.times = config.tlist; output.num_expect = config.e_num; output.num_collapse = config.c_num; output.ntraj = config.ntraj; output.col_times = mc.collapse_times_out; output.col_which = mc.which_op_out. if e_ops_dict:; output.expect = {e: output.expect[n]; for n, e in enumerate(e_ops_dict.keys())}. return output. # -----------------------------------------------------------------------------; # MONTE CARLO CLASS; # -----------------------------------------------------------------------------; class _MC():; """"""; Private class for solving Monte Carlo evolution from mcsolve; """""". def __init__(self, config):. self.config = config; # set output variables, even if they are not used to simplify output; # code.; self.psi_out = None; self.expect_out = []; self.collapse_times_out = None; self.which_op_out = None. # FOR EVOLUTION WITH COLLAPSE OPERATORS; if config.c_num:; # preallocate ntraj arrays for state vectors, collapse times, and; # which operator; self.collapse_times_out = np.zeros(config.ntraj, dtype=np.ndarray); self.which_op_out = np.zeros(config.ntraj, dtype=np.ndarray); if config.e_num == 0 or config.options.store_states:; self.psi_out = [None] * config.ntraj; if config.e_num > 0:; self.expect_out = [None] * config.ntraj. # setup seeds array; if self.config.options.seeds is None:; self.config.options.seeds = \; randint(1, 100000000.0 + 1, size=config.ntraj); else:; # if ntraj was reduced but reusing seeds; seed_length = len(config.options.seeds); if seed_length > config.ntraj:; self.config.options.seeds = \; config.options.seeds[0:config.ntraj]; # if ntraj was increased but reusing seeds; elif seed_length < config.ntraj:; newseeds = ra",MatchSource.WIKI,docs/4.2/modules/qutip/mcsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html
https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:11543,Modifiability,config,config,11543," for single trajectory or if average_expect flag; # (Options) is off; if mc.expect_out is not None:; output.expect = mc.expect_out. # simulation parameters; output.times = config.tlist; output.num_expect = config.e_num; output.num_collapse = config.c_num; output.ntraj = config.ntraj; output.col_times = mc.collapse_times_out; output.col_which = mc.which_op_out. if e_ops_dict:; output.expect = {e: output.expect[n]; for n, e in enumerate(e_ops_dict.keys())}. return output. # -----------------------------------------------------------------------------; # MONTE CARLO CLASS; # -----------------------------------------------------------------------------; class _MC():; """"""; Private class for solving Monte Carlo evolution from mcsolve; """""". def __init__(self, config):. self.config = config; # set output variables, even if they are not used to simplify output; # code.; self.psi_out = None; self.expect_out = []; self.collapse_times_out = None; self.which_op_out = None. # FOR EVOLUTION WITH COLLAPSE OPERATORS; if config.c_num:; # preallocate ntraj arrays for state vectors, collapse times, and; # which operator; self.collapse_times_out = np.zeros(config.ntraj, dtype=np.ndarray); self.which_op_out = np.zeros(config.ntraj, dtype=np.ndarray); if config.e_num == 0 or config.options.store_states:; self.psi_out = [None] * config.ntraj; if config.e_num > 0:; self.expect_out = [None] * config.ntraj. # setup seeds array; if self.config.options.seeds is None:; self.config.options.seeds = \; randint(1, 100000000.0 + 1, size=config.ntraj); else:; # if ntraj was reduced but reusing seeds; seed_length = len(config.options.seeds); if seed_length > config.ntraj:; self.config.options.seeds = \; config.options.seeds[0:config.ntraj]; # if ntraj was increased but reusing seeds; elif seed_length < config.ntraj:; newseeds = randint(1, 100000000.0 + 1, ; size=(config.ntraj - seed_length)); self.config.options.seeds = np.hstack(; (config.options.seeds, newseeds)). def run(self):. if debug:; print(ins",MatchSource.WIKI,docs/4.2/modules/qutip/mcsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html
https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:11678,Modifiability,config,config,11678,"s; output.times = config.tlist; output.num_expect = config.e_num; output.num_collapse = config.c_num; output.ntraj = config.ntraj; output.col_times = mc.collapse_times_out; output.col_which = mc.which_op_out. if e_ops_dict:; output.expect = {e: output.expect[n]; for n, e in enumerate(e_ops_dict.keys())}. return output. # -----------------------------------------------------------------------------; # MONTE CARLO CLASS; # -----------------------------------------------------------------------------; class _MC():; """"""; Private class for solving Monte Carlo evolution from mcsolve; """""". def __init__(self, config):. self.config = config; # set output variables, even if they are not used to simplify output; # code.; self.psi_out = None; self.expect_out = []; self.collapse_times_out = None; self.which_op_out = None. # FOR EVOLUTION WITH COLLAPSE OPERATORS; if config.c_num:; # preallocate ntraj arrays for state vectors, collapse times, and; # which operator; self.collapse_times_out = np.zeros(config.ntraj, dtype=np.ndarray); self.which_op_out = np.zeros(config.ntraj, dtype=np.ndarray); if config.e_num == 0 or config.options.store_states:; self.psi_out = [None] * config.ntraj; if config.e_num > 0:; self.expect_out = [None] * config.ntraj. # setup seeds array; if self.config.options.seeds is None:; self.config.options.seeds = \; randint(1, 100000000.0 + 1, size=config.ntraj); else:; # if ntraj was reduced but reusing seeds; seed_length = len(config.options.seeds); if seed_length > config.ntraj:; self.config.options.seeds = \; config.options.seeds[0:config.ntraj]; # if ntraj was increased but reusing seeds; elif seed_length < config.ntraj:; newseeds = randint(1, 100000000.0 + 1, ; size=(config.ntraj - seed_length)); self.config.options.seeds = np.hstack(; (config.options.seeds, newseeds)). def run(self):. if debug:; print(inspect.stack()[0][3]). if self.config.c_num == 0:; self.config.ntraj = 1; if self.config.e_num == 0 or self.config.options.store_states:; self.expect_out, se",MatchSource.WIKI,docs/4.2/modules/qutip/mcsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html
https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:11740,Modifiability,config,config,11740,"um; output.num_collapse = config.c_num; output.ntraj = config.ntraj; output.col_times = mc.collapse_times_out; output.col_which = mc.which_op_out. if e_ops_dict:; output.expect = {e: output.expect[n]; for n, e in enumerate(e_ops_dict.keys())}. return output. # -----------------------------------------------------------------------------; # MONTE CARLO CLASS; # -----------------------------------------------------------------------------; class _MC():; """"""; Private class for solving Monte Carlo evolution from mcsolve; """""". def __init__(self, config):. self.config = config; # set output variables, even if they are not used to simplify output; # code.; self.psi_out = None; self.expect_out = []; self.collapse_times_out = None; self.which_op_out = None. # FOR EVOLUTION WITH COLLAPSE OPERATORS; if config.c_num:; # preallocate ntraj arrays for state vectors, collapse times, and; # which operator; self.collapse_times_out = np.zeros(config.ntraj, dtype=np.ndarray); self.which_op_out = np.zeros(config.ntraj, dtype=np.ndarray); if config.e_num == 0 or config.options.store_states:; self.psi_out = [None] * config.ntraj; if config.e_num > 0:; self.expect_out = [None] * config.ntraj. # setup seeds array; if self.config.options.seeds is None:; self.config.options.seeds = \; randint(1, 100000000.0 + 1, size=config.ntraj); else:; # if ntraj was reduced but reusing seeds; seed_length = len(config.options.seeds); if seed_length > config.ntraj:; self.config.options.seeds = \; config.options.seeds[0:config.ntraj]; # if ntraj was increased but reusing seeds; elif seed_length < config.ntraj:; newseeds = randint(1, 100000000.0 + 1, ; size=(config.ntraj - seed_length)); self.config.options.seeds = np.hstack(; (config.options.seeds, newseeds)). def run(self):. if debug:; print(inspect.stack()[0][3]). if self.config.c_num == 0:; self.config.ntraj = 1; if self.config.e_num == 0 or self.config.options.store_states:; self.expect_out, self.psi_out = \; _evolve_no_collapse_psi_out(self.config); else",MatchSource.WIKI,docs/4.2/modules/qutip/mcsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html
https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:11776,Modifiability,config,config,11776,"c_num; output.ntraj = config.ntraj; output.col_times = mc.collapse_times_out; output.col_which = mc.which_op_out. if e_ops_dict:; output.expect = {e: output.expect[n]; for n, e in enumerate(e_ops_dict.keys())}. return output. # -----------------------------------------------------------------------------; # MONTE CARLO CLASS; # -----------------------------------------------------------------------------; class _MC():; """"""; Private class for solving Monte Carlo evolution from mcsolve; """""". def __init__(self, config):. self.config = config; # set output variables, even if they are not used to simplify output; # code.; self.psi_out = None; self.expect_out = []; self.collapse_times_out = None; self.which_op_out = None. # FOR EVOLUTION WITH COLLAPSE OPERATORS; if config.c_num:; # preallocate ntraj arrays for state vectors, collapse times, and; # which operator; self.collapse_times_out = np.zeros(config.ntraj, dtype=np.ndarray); self.which_op_out = np.zeros(config.ntraj, dtype=np.ndarray); if config.e_num == 0 or config.options.store_states:; self.psi_out = [None] * config.ntraj; if config.e_num > 0:; self.expect_out = [None] * config.ntraj. # setup seeds array; if self.config.options.seeds is None:; self.config.options.seeds = \; randint(1, 100000000.0 + 1, size=config.ntraj); else:; # if ntraj was reduced but reusing seeds; seed_length = len(config.options.seeds); if seed_length > config.ntraj:; self.config.options.seeds = \; config.options.seeds[0:config.ntraj]; # if ntraj was increased but reusing seeds; elif seed_length < config.ntraj:; newseeds = randint(1, 100000000.0 + 1, ; size=(config.ntraj - seed_length)); self.config.options.seeds = np.hstack(; (config.options.seeds, newseeds)). def run(self):. if debug:; print(inspect.stack()[0][3]). if self.config.c_num == 0:; self.config.ntraj = 1; if self.config.e_num == 0 or self.config.options.store_states:; self.expect_out, self.psi_out = \; _evolve_no_collapse_psi_out(self.config); else:; self.expect_out = _evolve_no_",MatchSource.WIKI,docs/4.2/modules/qutip/mcsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html
https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:11797,Modifiability,config,config,11797,"= config.ntraj; output.col_times = mc.collapse_times_out; output.col_which = mc.which_op_out. if e_ops_dict:; output.expect = {e: output.expect[n]; for n, e in enumerate(e_ops_dict.keys())}. return output. # -----------------------------------------------------------------------------; # MONTE CARLO CLASS; # -----------------------------------------------------------------------------; class _MC():; """"""; Private class for solving Monte Carlo evolution from mcsolve; """""". def __init__(self, config):. self.config = config; # set output variables, even if they are not used to simplify output; # code.; self.psi_out = None; self.expect_out = []; self.collapse_times_out = None; self.which_op_out = None. # FOR EVOLUTION WITH COLLAPSE OPERATORS; if config.c_num:; # preallocate ntraj arrays for state vectors, collapse times, and; # which operator; self.collapse_times_out = np.zeros(config.ntraj, dtype=np.ndarray); self.which_op_out = np.zeros(config.ntraj, dtype=np.ndarray); if config.e_num == 0 or config.options.store_states:; self.psi_out = [None] * config.ntraj; if config.e_num > 0:; self.expect_out = [None] * config.ntraj. # setup seeds array; if self.config.options.seeds is None:; self.config.options.seeds = \; randint(1, 100000000.0 + 1, size=config.ntraj); else:; # if ntraj was reduced but reusing seeds; seed_length = len(config.options.seeds); if seed_length > config.ntraj:; self.config.options.seeds = \; config.options.seeds[0:config.ntraj]; # if ntraj was increased but reusing seeds; elif seed_length < config.ntraj:; newseeds = randint(1, 100000000.0 + 1, ; size=(config.ntraj - seed_length)); self.config.options.seeds = np.hstack(; (config.options.seeds, newseeds)). def run(self):. if debug:; print(inspect.stack()[0][3]). if self.config.c_num == 0:; self.config.ntraj = 1; if self.config.e_num == 0 or self.config.options.store_states:; self.expect_out, self.psi_out = \; _evolve_no_collapse_psi_out(self.config); else:; self.expect_out = _evolve_no_collapse_expect_out(s",MatchSource.WIKI,docs/4.2/modules/qutip/mcsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html
https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:11851,Modifiability,config,config,11851,"_out; output.col_which = mc.which_op_out. if e_ops_dict:; output.expect = {e: output.expect[n]; for n, e in enumerate(e_ops_dict.keys())}. return output. # -----------------------------------------------------------------------------; # MONTE CARLO CLASS; # -----------------------------------------------------------------------------; class _MC():; """"""; Private class for solving Monte Carlo evolution from mcsolve; """""". def __init__(self, config):. self.config = config; # set output variables, even if they are not used to simplify output; # code.; self.psi_out = None; self.expect_out = []; self.collapse_times_out = None; self.which_op_out = None. # FOR EVOLUTION WITH COLLAPSE OPERATORS; if config.c_num:; # preallocate ntraj arrays for state vectors, collapse times, and; # which operator; self.collapse_times_out = np.zeros(config.ntraj, dtype=np.ndarray); self.which_op_out = np.zeros(config.ntraj, dtype=np.ndarray); if config.e_num == 0 or config.options.store_states:; self.psi_out = [None] * config.ntraj; if config.e_num > 0:; self.expect_out = [None] * config.ntraj. # setup seeds array; if self.config.options.seeds is None:; self.config.options.seeds = \; randint(1, 100000000.0 + 1, size=config.ntraj); else:; # if ntraj was reduced but reusing seeds; seed_length = len(config.options.seeds); if seed_length > config.ntraj:; self.config.options.seeds = \; config.options.seeds[0:config.ntraj]; # if ntraj was increased but reusing seeds; elif seed_length < config.ntraj:; newseeds = randint(1, 100000000.0 + 1, ; size=(config.ntraj - seed_length)); self.config.options.seeds = np.hstack(; (config.options.seeds, newseeds)). def run(self):. if debug:; print(inspect.stack()[0][3]). if self.config.c_num == 0:; self.config.ntraj = 1; if self.config.e_num == 0 or self.config.options.store_states:; self.expect_out, self.psi_out = \; _evolve_no_collapse_psi_out(self.config); else:; self.expect_out = _evolve_no_collapse_expect_out(self.config). else:; # set arguments for input to mo",MatchSource.WIKI,docs/4.2/modules/qutip/mcsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html
https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:11868,Modifiability,config,config,11868,"h = mc.which_op_out. if e_ops_dict:; output.expect = {e: output.expect[n]; for n, e in enumerate(e_ops_dict.keys())}. return output. # -----------------------------------------------------------------------------; # MONTE CARLO CLASS; # -----------------------------------------------------------------------------; class _MC():; """"""; Private class for solving Monte Carlo evolution from mcsolve; """""". def __init__(self, config):. self.config = config; # set output variables, even if they are not used to simplify output; # code.; self.psi_out = None; self.expect_out = []; self.collapse_times_out = None; self.which_op_out = None. # FOR EVOLUTION WITH COLLAPSE OPERATORS; if config.c_num:; # preallocate ntraj arrays for state vectors, collapse times, and; # which operator; self.collapse_times_out = np.zeros(config.ntraj, dtype=np.ndarray); self.which_op_out = np.zeros(config.ntraj, dtype=np.ndarray); if config.e_num == 0 or config.options.store_states:; self.psi_out = [None] * config.ntraj; if config.e_num > 0:; self.expect_out = [None] * config.ntraj. # setup seeds array; if self.config.options.seeds is None:; self.config.options.seeds = \; randint(1, 100000000.0 + 1, size=config.ntraj); else:; # if ntraj was reduced but reusing seeds; seed_length = len(config.options.seeds); if seed_length > config.ntraj:; self.config.options.seeds = \; config.options.seeds[0:config.ntraj]; # if ntraj was increased but reusing seeds; elif seed_length < config.ntraj:; newseeds = randint(1, 100000000.0 + 1, ; size=(config.ntraj - seed_length)); self.config.options.seeds = np.hstack(; (config.options.seeds, newseeds)). def run(self):. if debug:; print(inspect.stack()[0][3]). if self.config.c_num == 0:; self.config.ntraj = 1; if self.config.e_num == 0 or self.config.options.store_states:; self.expect_out, self.psi_out = \; _evolve_no_collapse_psi_out(self.config); else:; self.expect_out = _evolve_no_collapse_expect_out(self.config). else:; # set arguments for input to monte carlo; map_kwargs ",MatchSource.WIKI,docs/4.2/modules/qutip/mcsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html
https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:11914,Modifiability,config,config,11914,"put.expect = {e: output.expect[n]; for n, e in enumerate(e_ops_dict.keys())}. return output. # -----------------------------------------------------------------------------; # MONTE CARLO CLASS; # -----------------------------------------------------------------------------; class _MC():; """"""; Private class for solving Monte Carlo evolution from mcsolve; """""". def __init__(self, config):. self.config = config; # set output variables, even if they are not used to simplify output; # code.; self.psi_out = None; self.expect_out = []; self.collapse_times_out = None; self.which_op_out = None. # FOR EVOLUTION WITH COLLAPSE OPERATORS; if config.c_num:; # preallocate ntraj arrays for state vectors, collapse times, and; # which operator; self.collapse_times_out = np.zeros(config.ntraj, dtype=np.ndarray); self.which_op_out = np.zeros(config.ntraj, dtype=np.ndarray); if config.e_num == 0 or config.options.store_states:; self.psi_out = [None] * config.ntraj; if config.e_num > 0:; self.expect_out = [None] * config.ntraj. # setup seeds array; if self.config.options.seeds is None:; self.config.options.seeds = \; randint(1, 100000000.0 + 1, size=config.ntraj); else:; # if ntraj was reduced but reusing seeds; seed_length = len(config.options.seeds); if seed_length > config.ntraj:; self.config.options.seeds = \; config.options.seeds[0:config.ntraj]; # if ntraj was increased but reusing seeds; elif seed_length < config.ntraj:; newseeds = randint(1, 100000000.0 + 1, ; size=(config.ntraj - seed_length)); self.config.options.seeds = np.hstack(; (config.options.seeds, newseeds)). def run(self):. if debug:; print(inspect.stack()[0][3]). if self.config.c_num == 0:; self.config.ntraj = 1; if self.config.e_num == 0 or self.config.options.store_states:; self.expect_out, self.psi_out = \; _evolve_no_collapse_psi_out(self.config); else:; self.expect_out = _evolve_no_collapse_expect_out(self.config). else:; # set arguments for input to monte carlo; map_kwargs = {'progress_bar': self.config.progress_",MatchSource.WIKI,docs/4.2/modules/qutip/mcsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html
https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:11957,Modifiability,config,config,11957,"te(e_ops_dict.keys())}. return output. # -----------------------------------------------------------------------------; # MONTE CARLO CLASS; # -----------------------------------------------------------------------------; class _MC():; """"""; Private class for solving Monte Carlo evolution from mcsolve; """""". def __init__(self, config):. self.config = config; # set output variables, even if they are not used to simplify output; # code.; self.psi_out = None; self.expect_out = []; self.collapse_times_out = None; self.which_op_out = None. # FOR EVOLUTION WITH COLLAPSE OPERATORS; if config.c_num:; # preallocate ntraj arrays for state vectors, collapse times, and; # which operator; self.collapse_times_out = np.zeros(config.ntraj, dtype=np.ndarray); self.which_op_out = np.zeros(config.ntraj, dtype=np.ndarray); if config.e_num == 0 or config.options.store_states:; self.psi_out = [None] * config.ntraj; if config.e_num > 0:; self.expect_out = [None] * config.ntraj. # setup seeds array; if self.config.options.seeds is None:; self.config.options.seeds = \; randint(1, 100000000.0 + 1, size=config.ntraj); else:; # if ntraj was reduced but reusing seeds; seed_length = len(config.options.seeds); if seed_length > config.ntraj:; self.config.options.seeds = \; config.options.seeds[0:config.ntraj]; # if ntraj was increased but reusing seeds; elif seed_length < config.ntraj:; newseeds = randint(1, 100000000.0 + 1, ; size=(config.ntraj - seed_length)); self.config.options.seeds = np.hstack(; (config.options.seeds, newseeds)). def run(self):. if debug:; print(inspect.stack()[0][3]). if self.config.c_num == 0:; self.config.ntraj = 1; if self.config.e_num == 0 or self.config.options.store_states:; self.expect_out, self.psi_out = \; _evolve_no_collapse_psi_out(self.config); else:; self.expect_out = _evolve_no_collapse_expect_out(self.config). else:; # set arguments for input to monte carlo; map_kwargs = {'progress_bar': self.config.progress_bar,; 'num_cpus': self.config.options.num_cpus}; map_k",MatchSource.WIKI,docs/4.2/modules/qutip/mcsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html
https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:11993,Modifiability,config,config,11993,"t. # -----------------------------------------------------------------------------; # MONTE CARLO CLASS; # -----------------------------------------------------------------------------; class _MC():; """"""; Private class for solving Monte Carlo evolution from mcsolve; """""". def __init__(self, config):. self.config = config; # set output variables, even if they are not used to simplify output; # code.; self.psi_out = None; self.expect_out = []; self.collapse_times_out = None; self.which_op_out = None. # FOR EVOLUTION WITH COLLAPSE OPERATORS; if config.c_num:; # preallocate ntraj arrays for state vectors, collapse times, and; # which operator; self.collapse_times_out = np.zeros(config.ntraj, dtype=np.ndarray); self.which_op_out = np.zeros(config.ntraj, dtype=np.ndarray); if config.e_num == 0 or config.options.store_states:; self.psi_out = [None] * config.ntraj; if config.e_num > 0:; self.expect_out = [None] * config.ntraj. # setup seeds array; if self.config.options.seeds is None:; self.config.options.seeds = \; randint(1, 100000000.0 + 1, size=config.ntraj); else:; # if ntraj was reduced but reusing seeds; seed_length = len(config.options.seeds); if seed_length > config.ntraj:; self.config.options.seeds = \; config.options.seeds[0:config.ntraj]; # if ntraj was increased but reusing seeds; elif seed_length < config.ntraj:; newseeds = randint(1, 100000000.0 + 1, ; size=(config.ntraj - seed_length)); self.config.options.seeds = np.hstack(; (config.options.seeds, newseeds)). def run(self):. if debug:; print(inspect.stack()[0][3]). if self.config.c_num == 0:; self.config.ntraj = 1; if self.config.e_num == 0 or self.config.options.store_states:; self.expect_out, self.psi_out = \; _evolve_no_collapse_psi_out(self.config); else:; self.expect_out = _evolve_no_collapse_expect_out(self.config). else:; # set arguments for input to monte carlo; map_kwargs = {'progress_bar': self.config.progress_bar,; 'num_cpus': self.config.options.num_cpus}; map_kwargs.update(self.config.map_kwargs)",MatchSource.WIKI,docs/4.2/modules/qutip/mcsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html
https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:12052,Modifiability,config,config,12052,"-----------------------------; # MONTE CARLO CLASS; # -----------------------------------------------------------------------------; class _MC():; """"""; Private class for solving Monte Carlo evolution from mcsolve; """""". def __init__(self, config):. self.config = config; # set output variables, even if they are not used to simplify output; # code.; self.psi_out = None; self.expect_out = []; self.collapse_times_out = None; self.which_op_out = None. # FOR EVOLUTION WITH COLLAPSE OPERATORS; if config.c_num:; # preallocate ntraj arrays for state vectors, collapse times, and; # which operator; self.collapse_times_out = np.zeros(config.ntraj, dtype=np.ndarray); self.which_op_out = np.zeros(config.ntraj, dtype=np.ndarray); if config.e_num == 0 or config.options.store_states:; self.psi_out = [None] * config.ntraj; if config.e_num > 0:; self.expect_out = [None] * config.ntraj. # setup seeds array; if self.config.options.seeds is None:; self.config.options.seeds = \; randint(1, 100000000.0 + 1, size=config.ntraj); else:; # if ntraj was reduced but reusing seeds; seed_length = len(config.options.seeds); if seed_length > config.ntraj:; self.config.options.seeds = \; config.options.seeds[0:config.ntraj]; # if ntraj was increased but reusing seeds; elif seed_length < config.ntraj:; newseeds = randint(1, 100000000.0 + 1, ; size=(config.ntraj - seed_length)); self.config.options.seeds = np.hstack(; (config.options.seeds, newseeds)). def run(self):. if debug:; print(inspect.stack()[0][3]). if self.config.c_num == 0:; self.config.ntraj = 1; if self.config.e_num == 0 or self.config.options.store_states:; self.expect_out, self.psi_out = \; _evolve_no_collapse_psi_out(self.config); else:; self.expect_out = _evolve_no_collapse_expect_out(self.config). else:; # set arguments for input to monte carlo; map_kwargs = {'progress_bar': self.config.progress_bar,; 'num_cpus': self.config.options.num_cpus}; map_kwargs.update(self.config.map_kwargs). task_args = (self.config, self.config.options,; sel",MatchSource.WIKI,docs/4.2/modules/qutip/mcsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html
https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:12134,Modifiability,config,config,12134," # -----------------------------------------------------------------------------; class _MC():; """"""; Private class for solving Monte Carlo evolution from mcsolve; """""". def __init__(self, config):. self.config = config; # set output variables, even if they are not used to simplify output; # code.; self.psi_out = None; self.expect_out = []; self.collapse_times_out = None; self.which_op_out = None. # FOR EVOLUTION WITH COLLAPSE OPERATORS; if config.c_num:; # preallocate ntraj arrays for state vectors, collapse times, and; # which operator; self.collapse_times_out = np.zeros(config.ntraj, dtype=np.ndarray); self.which_op_out = np.zeros(config.ntraj, dtype=np.ndarray); if config.e_num == 0 or config.options.store_states:; self.psi_out = [None] * config.ntraj; if config.e_num > 0:; self.expect_out = [None] * config.ntraj. # setup seeds array; if self.config.options.seeds is None:; self.config.options.seeds = \; randint(1, 100000000.0 + 1, size=config.ntraj); else:; # if ntraj was reduced but reusing seeds; seed_length = len(config.options.seeds); if seed_length > config.ntraj:; self.config.options.seeds = \; config.options.seeds[0:config.ntraj]; # if ntraj was increased but reusing seeds; elif seed_length < config.ntraj:; newseeds = randint(1, 100000000.0 + 1, ; size=(config.ntraj - seed_length)); self.config.options.seeds = np.hstack(; (config.options.seeds, newseeds)). def run(self):. if debug:; print(inspect.stack()[0][3]). if self.config.c_num == 0:; self.config.ntraj = 1; if self.config.e_num == 0 or self.config.options.store_states:; self.expect_out, self.psi_out = \; _evolve_no_collapse_psi_out(self.config); else:; self.expect_out = _evolve_no_collapse_expect_out(self.config). else:; # set arguments for input to monte carlo; map_kwargs = {'progress_bar': self.config.progress_bar,; 'num_cpus': self.config.options.num_cpus}; map_kwargs.update(self.config.map_kwargs). task_args = (self.config, self.config.options,; self.config.options.seeds); task_kwargs = {}. results",MatchSource.WIKI,docs/4.2/modules/qutip/mcsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html
https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:12174,Modifiability,config,config,12174,"---------------; class _MC():; """"""; Private class for solving Monte Carlo evolution from mcsolve; """""". def __init__(self, config):. self.config = config; # set output variables, even if they are not used to simplify output; # code.; self.psi_out = None; self.expect_out = []; self.collapse_times_out = None; self.which_op_out = None. # FOR EVOLUTION WITH COLLAPSE OPERATORS; if config.c_num:; # preallocate ntraj arrays for state vectors, collapse times, and; # which operator; self.collapse_times_out = np.zeros(config.ntraj, dtype=np.ndarray); self.which_op_out = np.zeros(config.ntraj, dtype=np.ndarray); if config.e_num == 0 or config.options.store_states:; self.psi_out = [None] * config.ntraj; if config.e_num > 0:; self.expect_out = [None] * config.ntraj. # setup seeds array; if self.config.options.seeds is None:; self.config.options.seeds = \; randint(1, 100000000.0 + 1, size=config.ntraj); else:; # if ntraj was reduced but reusing seeds; seed_length = len(config.options.seeds); if seed_length > config.ntraj:; self.config.options.seeds = \; config.options.seeds[0:config.ntraj]; # if ntraj was increased but reusing seeds; elif seed_length < config.ntraj:; newseeds = randint(1, 100000000.0 + 1, ; size=(config.ntraj - seed_length)); self.config.options.seeds = np.hstack(; (config.options.seeds, newseeds)). def run(self):. if debug:; print(inspect.stack()[0][3]). if self.config.c_num == 0:; self.config.ntraj = 1; if self.config.e_num == 0 or self.config.options.store_states:; self.expect_out, self.psi_out = \; _evolve_no_collapse_psi_out(self.config); else:; self.expect_out = _evolve_no_collapse_expect_out(self.config). else:; # set arguments for input to monte carlo; map_kwargs = {'progress_bar': self.config.progress_bar,; 'num_cpus': self.config.options.num_cpus}; map_kwargs.update(self.config.map_kwargs). task_args = (self.config, self.config.options,; self.config.options.seeds); task_kwargs = {}. results = config.map_func(_mc_alg_evolve,; list(range(config.ntraj)),; t",MatchSource.WIKI,docs/4.2/modules/qutip/mcsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html
https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:12194,Modifiability,config,config,12194,"""""; Private class for solving Monte Carlo evolution from mcsolve; """""". def __init__(self, config):. self.config = config; # set output variables, even if they are not used to simplify output; # code.; self.psi_out = None; self.expect_out = []; self.collapse_times_out = None; self.which_op_out = None. # FOR EVOLUTION WITH COLLAPSE OPERATORS; if config.c_num:; # preallocate ntraj arrays for state vectors, collapse times, and; # which operator; self.collapse_times_out = np.zeros(config.ntraj, dtype=np.ndarray); self.which_op_out = np.zeros(config.ntraj, dtype=np.ndarray); if config.e_num == 0 or config.options.store_states:; self.psi_out = [None] * config.ntraj; if config.e_num > 0:; self.expect_out = [None] * config.ntraj. # setup seeds array; if self.config.options.seeds is None:; self.config.options.seeds = \; randint(1, 100000000.0 + 1, size=config.ntraj); else:; # if ntraj was reduced but reusing seeds; seed_length = len(config.options.seeds); if seed_length > config.ntraj:; self.config.options.seeds = \; config.options.seeds[0:config.ntraj]; # if ntraj was increased but reusing seeds; elif seed_length < config.ntraj:; newseeds = randint(1, 100000000.0 + 1, ; size=(config.ntraj - seed_length)); self.config.options.seeds = np.hstack(; (config.options.seeds, newseeds)). def run(self):. if debug:; print(inspect.stack()[0][3]). if self.config.c_num == 0:; self.config.ntraj = 1; if self.config.e_num == 0 or self.config.options.store_states:; self.expect_out, self.psi_out = \; _evolve_no_collapse_psi_out(self.config); else:; self.expect_out = _evolve_no_collapse_expect_out(self.config). else:; # set arguments for input to monte carlo; map_kwargs = {'progress_bar': self.config.progress_bar,; 'num_cpus': self.config.options.num_cpus}; map_kwargs.update(self.config.map_kwargs). task_args = (self.config, self.config.options,; self.config.options.seeds); task_kwargs = {}. results = config.map_func(_mc_alg_evolve,; list(range(config.ntraj)),; task_args, task_kwargs,; **map_kwa",MatchSource.WIKI,docs/4.2/modules/qutip/mcsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html
https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:12220,Modifiability,config,config,12220," solving Monte Carlo evolution from mcsolve; """""". def __init__(self, config):. self.config = config; # set output variables, even if they are not used to simplify output; # code.; self.psi_out = None; self.expect_out = []; self.collapse_times_out = None; self.which_op_out = None. # FOR EVOLUTION WITH COLLAPSE OPERATORS; if config.c_num:; # preallocate ntraj arrays for state vectors, collapse times, and; # which operator; self.collapse_times_out = np.zeros(config.ntraj, dtype=np.ndarray); self.which_op_out = np.zeros(config.ntraj, dtype=np.ndarray); if config.e_num == 0 or config.options.store_states:; self.psi_out = [None] * config.ntraj; if config.e_num > 0:; self.expect_out = [None] * config.ntraj. # setup seeds array; if self.config.options.seeds is None:; self.config.options.seeds = \; randint(1, 100000000.0 + 1, size=config.ntraj); else:; # if ntraj was reduced but reusing seeds; seed_length = len(config.options.seeds); if seed_length > config.ntraj:; self.config.options.seeds = \; config.options.seeds[0:config.ntraj]; # if ntraj was increased but reusing seeds; elif seed_length < config.ntraj:; newseeds = randint(1, 100000000.0 + 1, ; size=(config.ntraj - seed_length)); self.config.options.seeds = np.hstack(; (config.options.seeds, newseeds)). def run(self):. if debug:; print(inspect.stack()[0][3]). if self.config.c_num == 0:; self.config.ntraj = 1; if self.config.e_num == 0 or self.config.options.store_states:; self.expect_out, self.psi_out = \; _evolve_no_collapse_psi_out(self.config); else:; self.expect_out = _evolve_no_collapse_expect_out(self.config). else:; # set arguments for input to monte carlo; map_kwargs = {'progress_bar': self.config.progress_bar,; 'num_cpus': self.config.options.num_cpus}; map_kwargs.update(self.config.map_kwargs). task_args = (self.config, self.config.options,; self.config.options.seeds); task_kwargs = {}. results = config.map_func(_mc_alg_evolve,; list(range(config.ntraj)),; task_args, task_kwargs,; **map_kwargs). for n, result ",MatchSource.WIKI,docs/4.2/modules/qutip/mcsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html
https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:12243,Modifiability,config,config,12243,"lution from mcsolve; """""". def __init__(self, config):. self.config = config; # set output variables, even if they are not used to simplify output; # code.; self.psi_out = None; self.expect_out = []; self.collapse_times_out = None; self.which_op_out = None. # FOR EVOLUTION WITH COLLAPSE OPERATORS; if config.c_num:; # preallocate ntraj arrays for state vectors, collapse times, and; # which operator; self.collapse_times_out = np.zeros(config.ntraj, dtype=np.ndarray); self.which_op_out = np.zeros(config.ntraj, dtype=np.ndarray); if config.e_num == 0 or config.options.store_states:; self.psi_out = [None] * config.ntraj; if config.e_num > 0:; self.expect_out = [None] * config.ntraj. # setup seeds array; if self.config.options.seeds is None:; self.config.options.seeds = \; randint(1, 100000000.0 + 1, size=config.ntraj); else:; # if ntraj was reduced but reusing seeds; seed_length = len(config.options.seeds); if seed_length > config.ntraj:; self.config.options.seeds = \; config.options.seeds[0:config.ntraj]; # if ntraj was increased but reusing seeds; elif seed_length < config.ntraj:; newseeds = randint(1, 100000000.0 + 1, ; size=(config.ntraj - seed_length)); self.config.options.seeds = np.hstack(; (config.options.seeds, newseeds)). def run(self):. if debug:; print(inspect.stack()[0][3]). if self.config.c_num == 0:; self.config.ntraj = 1; if self.config.e_num == 0 or self.config.options.store_states:; self.expect_out, self.psi_out = \; _evolve_no_collapse_psi_out(self.config); else:; self.expect_out = _evolve_no_collapse_expect_out(self.config). else:; # set arguments for input to monte carlo; map_kwargs = {'progress_bar': self.config.progress_bar,; 'num_cpus': self.config.options.num_cpus}; map_kwargs.update(self.config.map_kwargs). task_args = (self.config, self.config.options,; self.config.options.seeds); task_kwargs = {}. results = config.map_func(_mc_alg_evolve,; list(range(config.ntraj)),; task_args, task_kwargs,; **map_kwargs). for n, result in enumerate(results):; s",MatchSource.WIKI,docs/4.2/modules/qutip/mcsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html
https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:12321,Modifiability,config,config,12321,"nfig):. self.config = config; # set output variables, even if they are not used to simplify output; # code.; self.psi_out = None; self.expect_out = []; self.collapse_times_out = None; self.which_op_out = None. # FOR EVOLUTION WITH COLLAPSE OPERATORS; if config.c_num:; # preallocate ntraj arrays for state vectors, collapse times, and; # which operator; self.collapse_times_out = np.zeros(config.ntraj, dtype=np.ndarray); self.which_op_out = np.zeros(config.ntraj, dtype=np.ndarray); if config.e_num == 0 or config.options.store_states:; self.psi_out = [None] * config.ntraj; if config.e_num > 0:; self.expect_out = [None] * config.ntraj. # setup seeds array; if self.config.options.seeds is None:; self.config.options.seeds = \; randint(1, 100000000.0 + 1, size=config.ntraj); else:; # if ntraj was reduced but reusing seeds; seed_length = len(config.options.seeds); if seed_length > config.ntraj:; self.config.options.seeds = \; config.options.seeds[0:config.ntraj]; # if ntraj was increased but reusing seeds; elif seed_length < config.ntraj:; newseeds = randint(1, 100000000.0 + 1, ; size=(config.ntraj - seed_length)); self.config.options.seeds = np.hstack(; (config.options.seeds, newseeds)). def run(self):. if debug:; print(inspect.stack()[0][3]). if self.config.c_num == 0:; self.config.ntraj = 1; if self.config.e_num == 0 or self.config.options.store_states:; self.expect_out, self.psi_out = \; _evolve_no_collapse_psi_out(self.config); else:; self.expect_out = _evolve_no_collapse_expect_out(self.config). else:; # set arguments for input to monte carlo; map_kwargs = {'progress_bar': self.config.progress_bar,; 'num_cpus': self.config.options.num_cpus}; map_kwargs.update(self.config.map_kwargs). task_args = (self.config, self.config.options,; self.config.options.seeds); task_kwargs = {}. results = config.map_func(_mc_alg_evolve,; list(range(config.ntraj)),; task_args, task_kwargs,; **map_kwargs). for n, result in enumerate(results):; state_out, expect_out, collapse_times, which_op",MatchSource.WIKI,docs/4.2/modules/qutip/mcsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html
https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:12383,Modifiability,config,config,12383,"y output; # code.; self.psi_out = None; self.expect_out = []; self.collapse_times_out = None; self.which_op_out = None. # FOR EVOLUTION WITH COLLAPSE OPERATORS; if config.c_num:; # preallocate ntraj arrays for state vectors, collapse times, and; # which operator; self.collapse_times_out = np.zeros(config.ntraj, dtype=np.ndarray); self.which_op_out = np.zeros(config.ntraj, dtype=np.ndarray); if config.e_num == 0 or config.options.store_states:; self.psi_out = [None] * config.ntraj; if config.e_num > 0:; self.expect_out = [None] * config.ntraj. # setup seeds array; if self.config.options.seeds is None:; self.config.options.seeds = \; randint(1, 100000000.0 + 1, size=config.ntraj); else:; # if ntraj was reduced but reusing seeds; seed_length = len(config.options.seeds); if seed_length > config.ntraj:; self.config.options.seeds = \; config.options.seeds[0:config.ntraj]; # if ntraj was increased but reusing seeds; elif seed_length < config.ntraj:; newseeds = randint(1, 100000000.0 + 1, ; size=(config.ntraj - seed_length)); self.config.options.seeds = np.hstack(; (config.options.seeds, newseeds)). def run(self):. if debug:; print(inspect.stack()[0][3]). if self.config.c_num == 0:; self.config.ntraj = 1; if self.config.e_num == 0 or self.config.options.store_states:; self.expect_out, self.psi_out = \; _evolve_no_collapse_psi_out(self.config); else:; self.expect_out = _evolve_no_collapse_expect_out(self.config). else:; # set arguments for input to monte carlo; map_kwargs = {'progress_bar': self.config.progress_bar,; 'num_cpus': self.config.options.num_cpus}; map_kwargs.update(self.config.map_kwargs). task_args = (self.config, self.config.options,; self.config.options.seeds); task_kwargs = {}. results = config.map_func(_mc_alg_evolve,; list(range(config.ntraj)),; task_args, task_kwargs,; **map_kwargs). for n, result in enumerate(results):; state_out, expect_out, collapse_times, which_oper = result. if self.config.e_num == 0 or self.config.options.store_states:; self.psi_out[",MatchSource.WIKI,docs/4.2/modules/qutip/mcsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html
https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:12418,Modifiability,config,config,12418,"lf.expect_out = []; self.collapse_times_out = None; self.which_op_out = None. # FOR EVOLUTION WITH COLLAPSE OPERATORS; if config.c_num:; # preallocate ntraj arrays for state vectors, collapse times, and; # which operator; self.collapse_times_out = np.zeros(config.ntraj, dtype=np.ndarray); self.which_op_out = np.zeros(config.ntraj, dtype=np.ndarray); if config.e_num == 0 or config.options.store_states:; self.psi_out = [None] * config.ntraj; if config.e_num > 0:; self.expect_out = [None] * config.ntraj. # setup seeds array; if self.config.options.seeds is None:; self.config.options.seeds = \; randint(1, 100000000.0 + 1, size=config.ntraj); else:; # if ntraj was reduced but reusing seeds; seed_length = len(config.options.seeds); if seed_length > config.ntraj:; self.config.options.seeds = \; config.options.seeds[0:config.ntraj]; # if ntraj was increased but reusing seeds; elif seed_length < config.ntraj:; newseeds = randint(1, 100000000.0 + 1, ; size=(config.ntraj - seed_length)); self.config.options.seeds = np.hstack(; (config.options.seeds, newseeds)). def run(self):. if debug:; print(inspect.stack()[0][3]). if self.config.c_num == 0:; self.config.ntraj = 1; if self.config.e_num == 0 or self.config.options.store_states:; self.expect_out, self.psi_out = \; _evolve_no_collapse_psi_out(self.config); else:; self.expect_out = _evolve_no_collapse_expect_out(self.config). else:; # set arguments for input to monte carlo; map_kwargs = {'progress_bar': self.config.progress_bar,; 'num_cpus': self.config.options.num_cpus}; map_kwargs.update(self.config.map_kwargs). task_args = (self.config, self.config.options,; self.config.options.seeds); task_kwargs = {}. results = config.map_func(_mc_alg_evolve,; list(range(config.ntraj)),; task_args, task_kwargs,; **map_kwargs). for n, result in enumerate(results):; state_out, expect_out, collapse_times, which_oper = result. if self.config.e_num == 0 or self.config.options.store_states:; self.psi_out[n] = state_out. if self.config.e_num > 0:; ",MatchSource.WIKI,docs/4.2/modules/qutip/mcsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html
https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:12454,Modifiability,config,config,12454,"se_times_out = None; self.which_op_out = None. # FOR EVOLUTION WITH COLLAPSE OPERATORS; if config.c_num:; # preallocate ntraj arrays for state vectors, collapse times, and; # which operator; self.collapse_times_out = np.zeros(config.ntraj, dtype=np.ndarray); self.which_op_out = np.zeros(config.ntraj, dtype=np.ndarray); if config.e_num == 0 or config.options.store_states:; self.psi_out = [None] * config.ntraj; if config.e_num > 0:; self.expect_out = [None] * config.ntraj. # setup seeds array; if self.config.options.seeds is None:; self.config.options.seeds = \; randint(1, 100000000.0 + 1, size=config.ntraj); else:; # if ntraj was reduced but reusing seeds; seed_length = len(config.options.seeds); if seed_length > config.ntraj:; self.config.options.seeds = \; config.options.seeds[0:config.ntraj]; # if ntraj was increased but reusing seeds; elif seed_length < config.ntraj:; newseeds = randint(1, 100000000.0 + 1, ; size=(config.ntraj - seed_length)); self.config.options.seeds = np.hstack(; (config.options.seeds, newseeds)). def run(self):. if debug:; print(inspect.stack()[0][3]). if self.config.c_num == 0:; self.config.ntraj = 1; if self.config.e_num == 0 or self.config.options.store_states:; self.expect_out, self.psi_out = \; _evolve_no_collapse_psi_out(self.config); else:; self.expect_out = _evolve_no_collapse_expect_out(self.config). else:; # set arguments for input to monte carlo; map_kwargs = {'progress_bar': self.config.progress_bar,; 'num_cpus': self.config.options.num_cpus}; map_kwargs.update(self.config.map_kwargs). task_args = (self.config, self.config.options,; self.config.options.seeds); task_kwargs = {}. results = config.map_func(_mc_alg_evolve,; list(range(config.ntraj)),; task_args, task_kwargs,; **map_kwargs). for n, result in enumerate(results):; state_out, expect_out, collapse_times, which_oper = result. if self.config.e_num == 0 or self.config.options.store_states:; self.psi_out[n] = state_out. if self.config.e_num > 0:; self.expect_out[n] = expect_out",MatchSource.WIKI,docs/4.2/modules/qutip/mcsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html
https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:12553,Modifiability,config,config,12553,"; # preallocate ntraj arrays for state vectors, collapse times, and; # which operator; self.collapse_times_out = np.zeros(config.ntraj, dtype=np.ndarray); self.which_op_out = np.zeros(config.ntraj, dtype=np.ndarray); if config.e_num == 0 or config.options.store_states:; self.psi_out = [None] * config.ntraj; if config.e_num > 0:; self.expect_out = [None] * config.ntraj. # setup seeds array; if self.config.options.seeds is None:; self.config.options.seeds = \; randint(1, 100000000.0 + 1, size=config.ntraj); else:; # if ntraj was reduced but reusing seeds; seed_length = len(config.options.seeds); if seed_length > config.ntraj:; self.config.options.seeds = \; config.options.seeds[0:config.ntraj]; # if ntraj was increased but reusing seeds; elif seed_length < config.ntraj:; newseeds = randint(1, 100000000.0 + 1, ; size=(config.ntraj - seed_length)); self.config.options.seeds = np.hstack(; (config.options.seeds, newseeds)). def run(self):. if debug:; print(inspect.stack()[0][3]). if self.config.c_num == 0:; self.config.ntraj = 1; if self.config.e_num == 0 or self.config.options.store_states:; self.expect_out, self.psi_out = \; _evolve_no_collapse_psi_out(self.config); else:; self.expect_out = _evolve_no_collapse_expect_out(self.config). else:; # set arguments for input to monte carlo; map_kwargs = {'progress_bar': self.config.progress_bar,; 'num_cpus': self.config.options.num_cpus}; map_kwargs.update(self.config.map_kwargs). task_args = (self.config, self.config.options,; self.config.options.seeds); task_kwargs = {}. results = config.map_func(_mc_alg_evolve,; list(range(config.ntraj)),; task_args, task_kwargs,; **map_kwargs). for n, result in enumerate(results):; state_out, expect_out, collapse_times, which_oper = result. if self.config.e_num == 0 or self.config.options.store_states:; self.psi_out[n] = state_out. if self.config.e_num > 0:; self.expect_out[n] = expect_out. self.collapse_times_out[n] = collapse_times; self.which_op_out[n] = which_oper. self.psi_out = np.asar",MatchSource.WIKI,docs/4.2/modules/qutip/mcsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html
https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:12578,Modifiability,config,config,12578,"ays for state vectors, collapse times, and; # which operator; self.collapse_times_out = np.zeros(config.ntraj, dtype=np.ndarray); self.which_op_out = np.zeros(config.ntraj, dtype=np.ndarray); if config.e_num == 0 or config.options.store_states:; self.psi_out = [None] * config.ntraj; if config.e_num > 0:; self.expect_out = [None] * config.ntraj. # setup seeds array; if self.config.options.seeds is None:; self.config.options.seeds = \; randint(1, 100000000.0 + 1, size=config.ntraj); else:; # if ntraj was reduced but reusing seeds; seed_length = len(config.options.seeds); if seed_length > config.ntraj:; self.config.options.seeds = \; config.options.seeds[0:config.ntraj]; # if ntraj was increased but reusing seeds; elif seed_length < config.ntraj:; newseeds = randint(1, 100000000.0 + 1, ; size=(config.ntraj - seed_length)); self.config.options.seeds = np.hstack(; (config.options.seeds, newseeds)). def run(self):. if debug:; print(inspect.stack()[0][3]). if self.config.c_num == 0:; self.config.ntraj = 1; if self.config.e_num == 0 or self.config.options.store_states:; self.expect_out, self.psi_out = \; _evolve_no_collapse_psi_out(self.config); else:; self.expect_out = _evolve_no_collapse_expect_out(self.config). else:; # set arguments for input to monte carlo; map_kwargs = {'progress_bar': self.config.progress_bar,; 'num_cpus': self.config.options.num_cpus}; map_kwargs.update(self.config.map_kwargs). task_args = (self.config, self.config.options,; self.config.options.seeds); task_kwargs = {}. results = config.map_func(_mc_alg_evolve,; list(range(config.ntraj)),; task_args, task_kwargs,; **map_kwargs). for n, result in enumerate(results):; state_out, expect_out, collapse_times, which_oper = result. if self.config.e_num == 0 or self.config.options.store_states:; self.psi_out[n] = state_out. if self.config.e_num > 0:; self.expect_out[n] = expect_out. self.collapse_times_out[n] = collapse_times; self.which_op_out[n] = which_oper. self.psi_out = np.asarray(self.psi_out, dtype=o",MatchSource.WIKI,docs/4.2/modules/qutip/mcsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html
https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:12604,Modifiability,config,config,12604,"lapse times, and; # which operator; self.collapse_times_out = np.zeros(config.ntraj, dtype=np.ndarray); self.which_op_out = np.zeros(config.ntraj, dtype=np.ndarray); if config.e_num == 0 or config.options.store_states:; self.psi_out = [None] * config.ntraj; if config.e_num > 0:; self.expect_out = [None] * config.ntraj. # setup seeds array; if self.config.options.seeds is None:; self.config.options.seeds = \; randint(1, 100000000.0 + 1, size=config.ntraj); else:; # if ntraj was reduced but reusing seeds; seed_length = len(config.options.seeds); if seed_length > config.ntraj:; self.config.options.seeds = \; config.options.seeds[0:config.ntraj]; # if ntraj was increased but reusing seeds; elif seed_length < config.ntraj:; newseeds = randint(1, 100000000.0 + 1, ; size=(config.ntraj - seed_length)); self.config.options.seeds = np.hstack(; (config.options.seeds, newseeds)). def run(self):. if debug:; print(inspect.stack()[0][3]). if self.config.c_num == 0:; self.config.ntraj = 1; if self.config.e_num == 0 or self.config.options.store_states:; self.expect_out, self.psi_out = \; _evolve_no_collapse_psi_out(self.config); else:; self.expect_out = _evolve_no_collapse_expect_out(self.config). else:; # set arguments for input to monte carlo; map_kwargs = {'progress_bar': self.config.progress_bar,; 'num_cpus': self.config.options.num_cpus}; map_kwargs.update(self.config.map_kwargs). task_args = (self.config, self.config.options,; self.config.options.seeds); task_kwargs = {}. results = config.map_func(_mc_alg_evolve,; list(range(config.ntraj)),; task_args, task_kwargs,; **map_kwargs). for n, result in enumerate(results):; state_out, expect_out, collapse_times, which_oper = result. if self.config.e_num == 0 or self.config.options.store_states:; self.psi_out[n] = state_out. if self.config.e_num > 0:; self.expect_out[n] = expect_out. self.collapse_times_out[n] = collapse_times; self.which_op_out[n] = which_oper. self.psi_out = np.asarray(self.psi_out, dtype=object). # ----------------",MatchSource.WIKI,docs/4.2/modules/qutip/mcsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html
https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:12630,Modifiability,config,config,12630,"operator; self.collapse_times_out = np.zeros(config.ntraj, dtype=np.ndarray); self.which_op_out = np.zeros(config.ntraj, dtype=np.ndarray); if config.e_num == 0 or config.options.store_states:; self.psi_out = [None] * config.ntraj; if config.e_num > 0:; self.expect_out = [None] * config.ntraj. # setup seeds array; if self.config.options.seeds is None:; self.config.options.seeds = \; randint(1, 100000000.0 + 1, size=config.ntraj); else:; # if ntraj was reduced but reusing seeds; seed_length = len(config.options.seeds); if seed_length > config.ntraj:; self.config.options.seeds = \; config.options.seeds[0:config.ntraj]; # if ntraj was increased but reusing seeds; elif seed_length < config.ntraj:; newseeds = randint(1, 100000000.0 + 1, ; size=(config.ntraj - seed_length)); self.config.options.seeds = np.hstack(; (config.options.seeds, newseeds)). def run(self):. if debug:; print(inspect.stack()[0][3]). if self.config.c_num == 0:; self.config.ntraj = 1; if self.config.e_num == 0 or self.config.options.store_states:; self.expect_out, self.psi_out = \; _evolve_no_collapse_psi_out(self.config); else:; self.expect_out = _evolve_no_collapse_expect_out(self.config). else:; # set arguments for input to monte carlo; map_kwargs = {'progress_bar': self.config.progress_bar,; 'num_cpus': self.config.options.num_cpus}; map_kwargs.update(self.config.map_kwargs). task_args = (self.config, self.config.options,; self.config.options.seeds); task_kwargs = {}. results = config.map_func(_mc_alg_evolve,; list(range(config.ntraj)),; task_args, task_kwargs,; **map_kwargs). for n, result in enumerate(results):; state_out, expect_out, collapse_times, which_oper = result. if self.config.e_num == 0 or self.config.options.store_states:; self.psi_out[n] = state_out. if self.config.e_num > 0:; self.expect_out[n] = expect_out. self.collapse_times_out[n] = collapse_times; self.which_op_out[n] = which_oper. self.psi_out = np.asarray(self.psi_out, dtype=object). # ------------------------------------------",MatchSource.WIKI,docs/4.2/modules/qutip/mcsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html
https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:12728,Modifiability,config,config,12728,"s(config.ntraj, dtype=np.ndarray); if config.e_num == 0 or config.options.store_states:; self.psi_out = [None] * config.ntraj; if config.e_num > 0:; self.expect_out = [None] * config.ntraj. # setup seeds array; if self.config.options.seeds is None:; self.config.options.seeds = \; randint(1, 100000000.0 + 1, size=config.ntraj); else:; # if ntraj was reduced but reusing seeds; seed_length = len(config.options.seeds); if seed_length > config.ntraj:; self.config.options.seeds = \; config.options.seeds[0:config.ntraj]; # if ntraj was increased but reusing seeds; elif seed_length < config.ntraj:; newseeds = randint(1, 100000000.0 + 1, ; size=(config.ntraj - seed_length)); self.config.options.seeds = np.hstack(; (config.options.seeds, newseeds)). def run(self):. if debug:; print(inspect.stack()[0][3]). if self.config.c_num == 0:; self.config.ntraj = 1; if self.config.e_num == 0 or self.config.options.store_states:; self.expect_out, self.psi_out = \; _evolve_no_collapse_psi_out(self.config); else:; self.expect_out = _evolve_no_collapse_expect_out(self.config). else:; # set arguments for input to monte carlo; map_kwargs = {'progress_bar': self.config.progress_bar,; 'num_cpus': self.config.options.num_cpus}; map_kwargs.update(self.config.map_kwargs). task_args = (self.config, self.config.options,; self.config.options.seeds); task_kwargs = {}. results = config.map_func(_mc_alg_evolve,; list(range(config.ntraj)),; task_args, task_kwargs,; **map_kwargs). for n, result in enumerate(results):; state_out, expect_out, collapse_times, which_oper = result. if self.config.e_num == 0 or self.config.options.store_states:; self.psi_out[n] = state_out. if self.config.e_num > 0:; self.expect_out[n] = expect_out. self.collapse_times_out[n] = collapse_times; self.which_op_out[n] = which_oper. self.psi_out = np.asarray(self.psi_out, dtype=object). # -----------------------------------------------------------------------------; # CODES FOR PYTHON FUNCTION BASED TIME-DEPENDENT RHS; # ------------",MatchSource.WIKI,docs/4.2/modules/qutip/mcsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html
https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:12798,Modifiability,config,config,12798,"g.options.store_states:; self.psi_out = [None] * config.ntraj; if config.e_num > 0:; self.expect_out = [None] * config.ntraj. # setup seeds array; if self.config.options.seeds is None:; self.config.options.seeds = \; randint(1, 100000000.0 + 1, size=config.ntraj); else:; # if ntraj was reduced but reusing seeds; seed_length = len(config.options.seeds); if seed_length > config.ntraj:; self.config.options.seeds = \; config.options.seeds[0:config.ntraj]; # if ntraj was increased but reusing seeds; elif seed_length < config.ntraj:; newseeds = randint(1, 100000000.0 + 1, ; size=(config.ntraj - seed_length)); self.config.options.seeds = np.hstack(; (config.options.seeds, newseeds)). def run(self):. if debug:; print(inspect.stack()[0][3]). if self.config.c_num == 0:; self.config.ntraj = 1; if self.config.e_num == 0 or self.config.options.store_states:; self.expect_out, self.psi_out = \; _evolve_no_collapse_psi_out(self.config); else:; self.expect_out = _evolve_no_collapse_expect_out(self.config). else:; # set arguments for input to monte carlo; map_kwargs = {'progress_bar': self.config.progress_bar,; 'num_cpus': self.config.options.num_cpus}; map_kwargs.update(self.config.map_kwargs). task_args = (self.config, self.config.options,; self.config.options.seeds); task_kwargs = {}. results = config.map_func(_mc_alg_evolve,; list(range(config.ntraj)),; task_args, task_kwargs,; **map_kwargs). for n, result in enumerate(results):; state_out, expect_out, collapse_times, which_oper = result. if self.config.e_num == 0 or self.config.options.store_states:; self.psi_out[n] = state_out. if self.config.e_num > 0:; self.expect_out[n] = expect_out. self.collapse_times_out[n] = collapse_times; self.which_op_out[n] = which_oper. self.psi_out = np.asarray(self.psi_out, dtype=object). # -----------------------------------------------------------------------------; # CODES FOR PYTHON FUNCTION BASED TIME-DEPENDENT RHS; # ---------------------------------------------------------------------------",MatchSource.WIKI,docs/4.2/modules/qutip/mcsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html
https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:12891,Modifiability,config,config,12891,"pect_out = [None] * config.ntraj. # setup seeds array; if self.config.options.seeds is None:; self.config.options.seeds = \; randint(1, 100000000.0 + 1, size=config.ntraj); else:; # if ntraj was reduced but reusing seeds; seed_length = len(config.options.seeds); if seed_length > config.ntraj:; self.config.options.seeds = \; config.options.seeds[0:config.ntraj]; # if ntraj was increased but reusing seeds; elif seed_length < config.ntraj:; newseeds = randint(1, 100000000.0 + 1, ; size=(config.ntraj - seed_length)); self.config.options.seeds = np.hstack(; (config.options.seeds, newseeds)). def run(self):. if debug:; print(inspect.stack()[0][3]). if self.config.c_num == 0:; self.config.ntraj = 1; if self.config.e_num == 0 or self.config.options.store_states:; self.expect_out, self.psi_out = \; _evolve_no_collapse_psi_out(self.config); else:; self.expect_out = _evolve_no_collapse_expect_out(self.config). else:; # set arguments for input to monte carlo; map_kwargs = {'progress_bar': self.config.progress_bar,; 'num_cpus': self.config.options.num_cpus}; map_kwargs.update(self.config.map_kwargs). task_args = (self.config, self.config.options,; self.config.options.seeds); task_kwargs = {}. results = config.map_func(_mc_alg_evolve,; list(range(config.ntraj)),; task_args, task_kwargs,; **map_kwargs). for n, result in enumerate(results):; state_out, expect_out, collapse_times, which_oper = result. if self.config.e_num == 0 or self.config.options.store_states:; self.psi_out[n] = state_out. if self.config.e_num > 0:; self.expect_out[n] = expect_out. self.collapse_times_out[n] = collapse_times; self.which_op_out[n] = which_oper. self.psi_out = np.asarray(self.psi_out, dtype=object). # -----------------------------------------------------------------------------; # CODES FOR PYTHON FUNCTION BASED TIME-DEPENDENT RHS; # -----------------------------------------------------------------------------. # RHS of ODE for time-dependent systems with no collapse operators; def _tdRHS(t, psi, co",MatchSource.WIKI,docs/4.2/modules/qutip/mcsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html
https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:12930,Modifiability,config,config,12930,"up seeds array; if self.config.options.seeds is None:; self.config.options.seeds = \; randint(1, 100000000.0 + 1, size=config.ntraj); else:; # if ntraj was reduced but reusing seeds; seed_length = len(config.options.seeds); if seed_length > config.ntraj:; self.config.options.seeds = \; config.options.seeds[0:config.ntraj]; # if ntraj was increased but reusing seeds; elif seed_length < config.ntraj:; newseeds = randint(1, 100000000.0 + 1, ; size=(config.ntraj - seed_length)); self.config.options.seeds = np.hstack(; (config.options.seeds, newseeds)). def run(self):. if debug:; print(inspect.stack()[0][3]). if self.config.c_num == 0:; self.config.ntraj = 1; if self.config.e_num == 0 or self.config.options.store_states:; self.expect_out, self.psi_out = \; _evolve_no_collapse_psi_out(self.config); else:; self.expect_out = _evolve_no_collapse_expect_out(self.config). else:; # set arguments for input to monte carlo; map_kwargs = {'progress_bar': self.config.progress_bar,; 'num_cpus': self.config.options.num_cpus}; map_kwargs.update(self.config.map_kwargs). task_args = (self.config, self.config.options,; self.config.options.seeds); task_kwargs = {}. results = config.map_func(_mc_alg_evolve,; list(range(config.ntraj)),; task_args, task_kwargs,; **map_kwargs). for n, result in enumerate(results):; state_out, expect_out, collapse_times, which_oper = result. if self.config.e_num == 0 or self.config.options.store_states:; self.psi_out[n] = state_out. if self.config.e_num > 0:; self.expect_out[n] = expect_out. self.collapse_times_out[n] = collapse_times; self.which_op_out[n] = which_oper. self.psi_out = np.asarray(self.psi_out, dtype=object). # -----------------------------------------------------------------------------; # CODES FOR PYTHON FUNCTION BASED TIME-DEPENDENT RHS; # -----------------------------------------------------------------------------. # RHS of ODE for time-dependent systems with no collapse operators; def _tdRHS(t, psi, config):; h_data = config.h_func(t, confi",MatchSource.WIKI,docs/4.2/modules/qutip/mcsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html
https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:12979,Modifiability,config,config,12979,"one:; self.config.options.seeds = \; randint(1, 100000000.0 + 1, size=config.ntraj); else:; # if ntraj was reduced but reusing seeds; seed_length = len(config.options.seeds); if seed_length > config.ntraj:; self.config.options.seeds = \; config.options.seeds[0:config.ntraj]; # if ntraj was increased but reusing seeds; elif seed_length < config.ntraj:; newseeds = randint(1, 100000000.0 + 1, ; size=(config.ntraj - seed_length)); self.config.options.seeds = np.hstack(; (config.options.seeds, newseeds)). def run(self):. if debug:; print(inspect.stack()[0][3]). if self.config.c_num == 0:; self.config.ntraj = 1; if self.config.e_num == 0 or self.config.options.store_states:; self.expect_out, self.psi_out = \; _evolve_no_collapse_psi_out(self.config); else:; self.expect_out = _evolve_no_collapse_expect_out(self.config). else:; # set arguments for input to monte carlo; map_kwargs = {'progress_bar': self.config.progress_bar,; 'num_cpus': self.config.options.num_cpus}; map_kwargs.update(self.config.map_kwargs). task_args = (self.config, self.config.options,; self.config.options.seeds); task_kwargs = {}. results = config.map_func(_mc_alg_evolve,; list(range(config.ntraj)),; task_args, task_kwargs,; **map_kwargs). for n, result in enumerate(results):; state_out, expect_out, collapse_times, which_oper = result. if self.config.e_num == 0 or self.config.options.store_states:; self.psi_out[n] = state_out. if self.config.e_num > 0:; self.expect_out[n] = expect_out. self.collapse_times_out[n] = collapse_times; self.which_op_out[n] = which_oper. self.psi_out = np.asarray(self.psi_out, dtype=object). # -----------------------------------------------------------------------------; # CODES FOR PYTHON FUNCTION BASED TIME-DEPENDENT RHS; # -----------------------------------------------------------------------------. # RHS of ODE for time-dependent systems with no collapse operators; def _tdRHS(t, psi, config):; h_data = config.h_func(t, config.h_func_args).data; return spmv(h_data, psi). # ",MatchSource.WIKI,docs/4.2/modules/qutip/mcsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html
https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:13017,Modifiability,config,config,13017,"int(1, 100000000.0 + 1, size=config.ntraj); else:; # if ntraj was reduced but reusing seeds; seed_length = len(config.options.seeds); if seed_length > config.ntraj:; self.config.options.seeds = \; config.options.seeds[0:config.ntraj]; # if ntraj was increased but reusing seeds; elif seed_length < config.ntraj:; newseeds = randint(1, 100000000.0 + 1, ; size=(config.ntraj - seed_length)); self.config.options.seeds = np.hstack(; (config.options.seeds, newseeds)). def run(self):. if debug:; print(inspect.stack()[0][3]). if self.config.c_num == 0:; self.config.ntraj = 1; if self.config.e_num == 0 or self.config.options.store_states:; self.expect_out, self.psi_out = \; _evolve_no_collapse_psi_out(self.config); else:; self.expect_out = _evolve_no_collapse_expect_out(self.config). else:; # set arguments for input to monte carlo; map_kwargs = {'progress_bar': self.config.progress_bar,; 'num_cpus': self.config.options.num_cpus}; map_kwargs.update(self.config.map_kwargs). task_args = (self.config, self.config.options,; self.config.options.seeds); task_kwargs = {}. results = config.map_func(_mc_alg_evolve,; list(range(config.ntraj)),; task_args, task_kwargs,; **map_kwargs). for n, result in enumerate(results):; state_out, expect_out, collapse_times, which_oper = result. if self.config.e_num == 0 or self.config.options.store_states:; self.psi_out[n] = state_out. if self.config.e_num > 0:; self.expect_out[n] = expect_out. self.collapse_times_out[n] = collapse_times; self.which_op_out[n] = which_oper. self.psi_out = np.asarray(self.psi_out, dtype=object). # -----------------------------------------------------------------------------; # CODES FOR PYTHON FUNCTION BASED TIME-DEPENDENT RHS; # -----------------------------------------------------------------------------. # RHS of ODE for time-dependent systems with no collapse operators; def _tdRHS(t, psi, config):; h_data = config.h_func(t, config.h_func_args).data; return spmv(h_data, psi). # RHS of ODE for constant Hamiltonian and a",MatchSource.WIKI,docs/4.2/modules/qutip/mcsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html
https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:13030,Modifiability,config,config,13030,"000000.0 + 1, size=config.ntraj); else:; # if ntraj was reduced but reusing seeds; seed_length = len(config.options.seeds); if seed_length > config.ntraj:; self.config.options.seeds = \; config.options.seeds[0:config.ntraj]; # if ntraj was increased but reusing seeds; elif seed_length < config.ntraj:; newseeds = randint(1, 100000000.0 + 1, ; size=(config.ntraj - seed_length)); self.config.options.seeds = np.hstack(; (config.options.seeds, newseeds)). def run(self):. if debug:; print(inspect.stack()[0][3]). if self.config.c_num == 0:; self.config.ntraj = 1; if self.config.e_num == 0 or self.config.options.store_states:; self.expect_out, self.psi_out = \; _evolve_no_collapse_psi_out(self.config); else:; self.expect_out = _evolve_no_collapse_expect_out(self.config). else:; # set arguments for input to monte carlo; map_kwargs = {'progress_bar': self.config.progress_bar,; 'num_cpus': self.config.options.num_cpus}; map_kwargs.update(self.config.map_kwargs). task_args = (self.config, self.config.options,; self.config.options.seeds); task_kwargs = {}. results = config.map_func(_mc_alg_evolve,; list(range(config.ntraj)),; task_args, task_kwargs,; **map_kwargs). for n, result in enumerate(results):; state_out, expect_out, collapse_times, which_oper = result. if self.config.e_num == 0 or self.config.options.store_states:; self.psi_out[n] = state_out. if self.config.e_num > 0:; self.expect_out[n] = expect_out. self.collapse_times_out[n] = collapse_times; self.which_op_out[n] = which_oper. self.psi_out = np.asarray(self.psi_out, dtype=object). # -----------------------------------------------------------------------------; # CODES FOR PYTHON FUNCTION BASED TIME-DEPENDENT RHS; # -----------------------------------------------------------------------------. # RHS of ODE for time-dependent systems with no collapse operators; def _tdRHS(t, psi, config):; h_data = config.h_func(t, config.h_func_args).data; return spmv(h_data, psi). # RHS of ODE for constant Hamiltonian and at least on",MatchSource.WIKI,docs/4.2/modules/qutip/mcsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html
https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:13052,Modifiability,config,config,13052,"fig.ntraj); else:; # if ntraj was reduced but reusing seeds; seed_length = len(config.options.seeds); if seed_length > config.ntraj:; self.config.options.seeds = \; config.options.seeds[0:config.ntraj]; # if ntraj was increased but reusing seeds; elif seed_length < config.ntraj:; newseeds = randint(1, 100000000.0 + 1, ; size=(config.ntraj - seed_length)); self.config.options.seeds = np.hstack(; (config.options.seeds, newseeds)). def run(self):. if debug:; print(inspect.stack()[0][3]). if self.config.c_num == 0:; self.config.ntraj = 1; if self.config.e_num == 0 or self.config.options.store_states:; self.expect_out, self.psi_out = \; _evolve_no_collapse_psi_out(self.config); else:; self.expect_out = _evolve_no_collapse_expect_out(self.config). else:; # set arguments for input to monte carlo; map_kwargs = {'progress_bar': self.config.progress_bar,; 'num_cpus': self.config.options.num_cpus}; map_kwargs.update(self.config.map_kwargs). task_args = (self.config, self.config.options,; self.config.options.seeds); task_kwargs = {}. results = config.map_func(_mc_alg_evolve,; list(range(config.ntraj)),; task_args, task_kwargs,; **map_kwargs). for n, result in enumerate(results):; state_out, expect_out, collapse_times, which_oper = result. if self.config.e_num == 0 or self.config.options.store_states:; self.psi_out[n] = state_out. if self.config.e_num > 0:; self.expect_out[n] = expect_out. self.collapse_times_out[n] = collapse_times; self.which_op_out[n] = which_oper. self.psi_out = np.asarray(self.psi_out, dtype=object). # -----------------------------------------------------------------------------; # CODES FOR PYTHON FUNCTION BASED TIME-DEPENDENT RHS; # -----------------------------------------------------------------------------. # RHS of ODE for time-dependent systems with no collapse operators; def _tdRHS(t, psi, config):; h_data = config.h_func(t, config.h_func_args).data; return spmv(h_data, psi). # RHS of ODE for constant Hamiltonian and at least one function based; # co",MatchSource.WIKI,docs/4.2/modules/qutip/mcsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html
https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:13103,Modifiability,config,config,13103,"reusing seeds; seed_length = len(config.options.seeds); if seed_length > config.ntraj:; self.config.options.seeds = \; config.options.seeds[0:config.ntraj]; # if ntraj was increased but reusing seeds; elif seed_length < config.ntraj:; newseeds = randint(1, 100000000.0 + 1, ; size=(config.ntraj - seed_length)); self.config.options.seeds = np.hstack(; (config.options.seeds, newseeds)). def run(self):. if debug:; print(inspect.stack()[0][3]). if self.config.c_num == 0:; self.config.ntraj = 1; if self.config.e_num == 0 or self.config.options.store_states:; self.expect_out, self.psi_out = \; _evolve_no_collapse_psi_out(self.config); else:; self.expect_out = _evolve_no_collapse_expect_out(self.config). else:; # set arguments for input to monte carlo; map_kwargs = {'progress_bar': self.config.progress_bar,; 'num_cpus': self.config.options.num_cpus}; map_kwargs.update(self.config.map_kwargs). task_args = (self.config, self.config.options,; self.config.options.seeds); task_kwargs = {}. results = config.map_func(_mc_alg_evolve,; list(range(config.ntraj)),; task_args, task_kwargs,; **map_kwargs). for n, result in enumerate(results):; state_out, expect_out, collapse_times, which_oper = result. if self.config.e_num == 0 or self.config.options.store_states:; self.psi_out[n] = state_out. if self.config.e_num > 0:; self.expect_out[n] = expect_out. self.collapse_times_out[n] = collapse_times; self.which_op_out[n] = which_oper. self.psi_out = np.asarray(self.psi_out, dtype=object). # -----------------------------------------------------------------------------; # CODES FOR PYTHON FUNCTION BASED TIME-DEPENDENT RHS; # -----------------------------------------------------------------------------. # RHS of ODE for time-dependent systems with no collapse operators; def _tdRHS(t, psi, config):; h_data = config.h_func(t, config.h_func_args).data; return spmv(h_data, psi). # RHS of ODE for constant Hamiltonian and at least one function based; # collapse operator; def _cRHStd(t, psi, config):",MatchSource.WIKI,docs/4.2/modules/qutip/mcsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html
https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:13147,Modifiability,config,config,13147,"n(config.options.seeds); if seed_length > config.ntraj:; self.config.options.seeds = \; config.options.seeds[0:config.ntraj]; # if ntraj was increased but reusing seeds; elif seed_length < config.ntraj:; newseeds = randint(1, 100000000.0 + 1, ; size=(config.ntraj - seed_length)); self.config.options.seeds = np.hstack(; (config.options.seeds, newseeds)). def run(self):. if debug:; print(inspect.stack()[0][3]). if self.config.c_num == 0:; self.config.ntraj = 1; if self.config.e_num == 0 or self.config.options.store_states:; self.expect_out, self.psi_out = \; _evolve_no_collapse_psi_out(self.config); else:; self.expect_out = _evolve_no_collapse_expect_out(self.config). else:; # set arguments for input to monte carlo; map_kwargs = {'progress_bar': self.config.progress_bar,; 'num_cpus': self.config.options.num_cpus}; map_kwargs.update(self.config.map_kwargs). task_args = (self.config, self.config.options,; self.config.options.seeds); task_kwargs = {}. results = config.map_func(_mc_alg_evolve,; list(range(config.ntraj)),; task_args, task_kwargs,; **map_kwargs). for n, result in enumerate(results):; state_out, expect_out, collapse_times, which_oper = result. if self.config.e_num == 0 or self.config.options.store_states:; self.psi_out[n] = state_out. if self.config.e_num > 0:; self.expect_out[n] = expect_out. self.collapse_times_out[n] = collapse_times; self.which_op_out[n] = which_oper. self.psi_out = np.asarray(self.psi_out, dtype=object). # -----------------------------------------------------------------------------; # CODES FOR PYTHON FUNCTION BASED TIME-DEPENDENT RHS; # -----------------------------------------------------------------------------. # RHS of ODE for time-dependent systems with no collapse operators; def _tdRHS(t, psi, config):; h_data = config.h_func(t, config.h_func_args).data; return spmv(h_data, psi). # RHS of ODE for constant Hamiltonian and at least one function based; # collapse operator; def _cRHStd(t, psi, config):; sys = cy_ode_rhs(t, psi, conf",MatchSource.WIKI,docs/4.2/modules/qutip/mcsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html
https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:13310,Modifiability,config,config,13310,"ength < config.ntraj:; newseeds = randint(1, 100000000.0 + 1, ; size=(config.ntraj - seed_length)); self.config.options.seeds = np.hstack(; (config.options.seeds, newseeds)). def run(self):. if debug:; print(inspect.stack()[0][3]). if self.config.c_num == 0:; self.config.ntraj = 1; if self.config.e_num == 0 or self.config.options.store_states:; self.expect_out, self.psi_out = \; _evolve_no_collapse_psi_out(self.config); else:; self.expect_out = _evolve_no_collapse_expect_out(self.config). else:; # set arguments for input to monte carlo; map_kwargs = {'progress_bar': self.config.progress_bar,; 'num_cpus': self.config.options.num_cpus}; map_kwargs.update(self.config.map_kwargs). task_args = (self.config, self.config.options,; self.config.options.seeds); task_kwargs = {}. results = config.map_func(_mc_alg_evolve,; list(range(config.ntraj)),; task_args, task_kwargs,; **map_kwargs). for n, result in enumerate(results):; state_out, expect_out, collapse_times, which_oper = result. if self.config.e_num == 0 or self.config.options.store_states:; self.psi_out[n] = state_out. if self.config.e_num > 0:; self.expect_out[n] = expect_out. self.collapse_times_out[n] = collapse_times; self.which_op_out[n] = which_oper. self.psi_out = np.asarray(self.psi_out, dtype=object). # -----------------------------------------------------------------------------; # CODES FOR PYTHON FUNCTION BASED TIME-DEPENDENT RHS; # -----------------------------------------------------------------------------. # RHS of ODE for time-dependent systems with no collapse operators; def _tdRHS(t, psi, config):; h_data = config.h_func(t, config.h_func_args).data; return spmv(h_data, psi). # RHS of ODE for constant Hamiltonian and at least one function based; # collapse operator; def _cRHStd(t, psi, config):; sys = cy_ode_rhs(t, psi, config.h_data,; config.h_ind, config.h_ptr); col = np.array([np.abs(config.c_funcs[j](t, config.c_func_args)) ** 2 *; spmv_csr(config.n_ops_data[j],; config.n_ops_ind[j],; config.n_ops_p",MatchSource.WIKI,docs/4.2/modules/qutip/mcsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html
https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:13336,Modifiability,config,config,13336,"seeds = randint(1, 100000000.0 + 1, ; size=(config.ntraj - seed_length)); self.config.options.seeds = np.hstack(; (config.options.seeds, newseeds)). def run(self):. if debug:; print(inspect.stack()[0][3]). if self.config.c_num == 0:; self.config.ntraj = 1; if self.config.e_num == 0 or self.config.options.store_states:; self.expect_out, self.psi_out = \; _evolve_no_collapse_psi_out(self.config); else:; self.expect_out = _evolve_no_collapse_expect_out(self.config). else:; # set arguments for input to monte carlo; map_kwargs = {'progress_bar': self.config.progress_bar,; 'num_cpus': self.config.options.num_cpus}; map_kwargs.update(self.config.map_kwargs). task_args = (self.config, self.config.options,; self.config.options.seeds); task_kwargs = {}. results = config.map_func(_mc_alg_evolve,; list(range(config.ntraj)),; task_args, task_kwargs,; **map_kwargs). for n, result in enumerate(results):; state_out, expect_out, collapse_times, which_oper = result. if self.config.e_num == 0 or self.config.options.store_states:; self.psi_out[n] = state_out. if self.config.e_num > 0:; self.expect_out[n] = expect_out. self.collapse_times_out[n] = collapse_times; self.which_op_out[n] = which_oper. self.psi_out = np.asarray(self.psi_out, dtype=object). # -----------------------------------------------------------------------------; # CODES FOR PYTHON FUNCTION BASED TIME-DEPENDENT RHS; # -----------------------------------------------------------------------------. # RHS of ODE for time-dependent systems with no collapse operators; def _tdRHS(t, psi, config):; h_data = config.h_func(t, config.h_func_args).data; return spmv(h_data, psi). # RHS of ODE for constant Hamiltonian and at least one function based; # collapse operator; def _cRHStd(t, psi, config):; sys = cy_ode_rhs(t, psi, config.h_data,; config.h_ind, config.h_ptr); col = np.array([np.abs(config.c_funcs[j](t, config.c_func_args)) ** 2 *; spmv_csr(config.n_ops_data[j],; config.n_ops_ind[j],; config.n_ops_ptr[j], psi); for j in conf",MatchSource.WIKI,docs/4.2/modules/qutip/mcsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html
https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:13403,Modifiability,config,config,13403,"gth)); self.config.options.seeds = np.hstack(; (config.options.seeds, newseeds)). def run(self):. if debug:; print(inspect.stack()[0][3]). if self.config.c_num == 0:; self.config.ntraj = 1; if self.config.e_num == 0 or self.config.options.store_states:; self.expect_out, self.psi_out = \; _evolve_no_collapse_psi_out(self.config); else:; self.expect_out = _evolve_no_collapse_expect_out(self.config). else:; # set arguments for input to monte carlo; map_kwargs = {'progress_bar': self.config.progress_bar,; 'num_cpus': self.config.options.num_cpus}; map_kwargs.update(self.config.map_kwargs). task_args = (self.config, self.config.options,; self.config.options.seeds); task_kwargs = {}. results = config.map_func(_mc_alg_evolve,; list(range(config.ntraj)),; task_args, task_kwargs,; **map_kwargs). for n, result in enumerate(results):; state_out, expect_out, collapse_times, which_oper = result. if self.config.e_num == 0 or self.config.options.store_states:; self.psi_out[n] = state_out. if self.config.e_num > 0:; self.expect_out[n] = expect_out. self.collapse_times_out[n] = collapse_times; self.which_op_out[n] = which_oper. self.psi_out = np.asarray(self.psi_out, dtype=object). # -----------------------------------------------------------------------------; # CODES FOR PYTHON FUNCTION BASED TIME-DEPENDENT RHS; # -----------------------------------------------------------------------------. # RHS of ODE for time-dependent systems with no collapse operators; def _tdRHS(t, psi, config):; h_data = config.h_func(t, config.h_func_args).data; return spmv(h_data, psi). # RHS of ODE for constant Hamiltonian and at least one function based; # collapse operator; def _cRHStd(t, psi, config):; sys = cy_ode_rhs(t, psi, config.h_data,; config.h_ind, config.h_ptr); col = np.array([np.abs(config.c_funcs[j](t, config.c_func_args)) ** 2 *; spmv_csr(config.n_ops_data[j],; config.n_ops_ind[j],; config.n_ops_ptr[j], psi); for j in config.c_td_inds]); return sys - 0.5 * np.sum(col, 0). # RHS of ODE for",MatchSource.WIKI,docs/4.2/modules/qutip/mcsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html
https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:13893,Modifiability,config,config,13893,"args = {'progress_bar': self.config.progress_bar,; 'num_cpus': self.config.options.num_cpus}; map_kwargs.update(self.config.map_kwargs). task_args = (self.config, self.config.options,; self.config.options.seeds); task_kwargs = {}. results = config.map_func(_mc_alg_evolve,; list(range(config.ntraj)),; task_args, task_kwargs,; **map_kwargs). for n, result in enumerate(results):; state_out, expect_out, collapse_times, which_oper = result. if self.config.e_num == 0 or self.config.options.store_states:; self.psi_out[n] = state_out. if self.config.e_num > 0:; self.expect_out[n] = expect_out. self.collapse_times_out[n] = collapse_times; self.which_op_out[n] = which_oper. self.psi_out = np.asarray(self.psi_out, dtype=object). # -----------------------------------------------------------------------------; # CODES FOR PYTHON FUNCTION BASED TIME-DEPENDENT RHS; # -----------------------------------------------------------------------------. # RHS of ODE for time-dependent systems with no collapse operators; def _tdRHS(t, psi, config):; h_data = config.h_func(t, config.h_func_args).data; return spmv(h_data, psi). # RHS of ODE for constant Hamiltonian and at least one function based; # collapse operator; def _cRHStd(t, psi, config):; sys = cy_ode_rhs(t, psi, config.h_data,; config.h_ind, config.h_ptr); col = np.array([np.abs(config.c_funcs[j](t, config.c_func_args)) ** 2 *; spmv_csr(config.n_ops_data[j],; config.n_ops_ind[j],; config.n_ops_ptr[j], psi); for j in config.c_td_inds]); return sys - 0.5 * np.sum(col, 0). # RHS of ODE for list-function based Hamiltonian; def _tdRHStd(t, psi, config):; const_term = spmv_csr(config.h_data,; config.h_ind,; config.h_ptr, psi); h_func_term = np.array([config.h_funcs[j](t, config.h_func_args) *; spmv_csr(config.h_td_data[j],; config.h_td_ind[j],; config.h_td_ptr[j], psi); for j in config.h_td_inds]); col_func_terms = np.array([np.abs(; config.c_funcs[j](t, config.c_func_args)) ** 2 *; spmv_csr(config.n_ops_data[j],; config.n_ops_ind[j],; co",MatchSource.WIKI,docs/4.2/modules/qutip/mcsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html
https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:13912,Modifiability,config,config,13912,"args = {'progress_bar': self.config.progress_bar,; 'num_cpus': self.config.options.num_cpus}; map_kwargs.update(self.config.map_kwargs). task_args = (self.config, self.config.options,; self.config.options.seeds); task_kwargs = {}. results = config.map_func(_mc_alg_evolve,; list(range(config.ntraj)),; task_args, task_kwargs,; **map_kwargs). for n, result in enumerate(results):; state_out, expect_out, collapse_times, which_oper = result. if self.config.e_num == 0 or self.config.options.store_states:; self.psi_out[n] = state_out. if self.config.e_num > 0:; self.expect_out[n] = expect_out. self.collapse_times_out[n] = collapse_times; self.which_op_out[n] = which_oper. self.psi_out = np.asarray(self.psi_out, dtype=object). # -----------------------------------------------------------------------------; # CODES FOR PYTHON FUNCTION BASED TIME-DEPENDENT RHS; # -----------------------------------------------------------------------------. # RHS of ODE for time-dependent systems with no collapse operators; def _tdRHS(t, psi, config):; h_data = config.h_func(t, config.h_func_args).data; return spmv(h_data, psi). # RHS of ODE for constant Hamiltonian and at least one function based; # collapse operator; def _cRHStd(t, psi, config):; sys = cy_ode_rhs(t, psi, config.h_data,; config.h_ind, config.h_ptr); col = np.array([np.abs(config.c_funcs[j](t, config.c_func_args)) ** 2 *; spmv_csr(config.n_ops_data[j],; config.n_ops_ind[j],; config.n_ops_ptr[j], psi); for j in config.c_td_inds]); return sys - 0.5 * np.sum(col, 0). # RHS of ODE for list-function based Hamiltonian; def _tdRHStd(t, psi, config):; const_term = spmv_csr(config.h_data,; config.h_ind,; config.h_ptr, psi); h_func_term = np.array([config.h_funcs[j](t, config.h_func_args) *; spmv_csr(config.h_td_data[j],; config.h_td_ind[j],; config.h_td_ptr[j], psi); for j in config.h_td_inds]); col_func_terms = np.array([np.abs(; config.c_funcs[j](t, config.c_func_args)) ** 2 *; spmv_csr(config.n_ops_data[j],; config.n_ops_ind[j],; co",MatchSource.WIKI,docs/4.2/modules/qutip/mcsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html
https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:13929,Modifiability,config,config,13929,"lf.config.options.num_cpus}; map_kwargs.update(self.config.map_kwargs). task_args = (self.config, self.config.options,; self.config.options.seeds); task_kwargs = {}. results = config.map_func(_mc_alg_evolve,; list(range(config.ntraj)),; task_args, task_kwargs,; **map_kwargs). for n, result in enumerate(results):; state_out, expect_out, collapse_times, which_oper = result. if self.config.e_num == 0 or self.config.options.store_states:; self.psi_out[n] = state_out. if self.config.e_num > 0:; self.expect_out[n] = expect_out. self.collapse_times_out[n] = collapse_times; self.which_op_out[n] = which_oper. self.psi_out = np.asarray(self.psi_out, dtype=object). # -----------------------------------------------------------------------------; # CODES FOR PYTHON FUNCTION BASED TIME-DEPENDENT RHS; # -----------------------------------------------------------------------------. # RHS of ODE for time-dependent systems with no collapse operators; def _tdRHS(t, psi, config):; h_data = config.h_func(t, config.h_func_args).data; return spmv(h_data, psi). # RHS of ODE for constant Hamiltonian and at least one function based; # collapse operator; def _cRHStd(t, psi, config):; sys = cy_ode_rhs(t, psi, config.h_data,; config.h_ind, config.h_ptr); col = np.array([np.abs(config.c_funcs[j](t, config.c_func_args)) ** 2 *; spmv_csr(config.n_ops_data[j],; config.n_ops_ind[j],; config.n_ops_ptr[j], psi); for j in config.c_td_inds]); return sys - 0.5 * np.sum(col, 0). # RHS of ODE for list-function based Hamiltonian; def _tdRHStd(t, psi, config):; const_term = spmv_csr(config.h_data,; config.h_ind,; config.h_ptr, psi); h_func_term = np.array([config.h_funcs[j](t, config.h_func_args) *; spmv_csr(config.h_td_data[j],; config.h_td_ind[j],; config.h_td_ptr[j], psi); for j in config.h_td_inds]); col_func_terms = np.array([np.abs(; config.c_funcs[j](t, config.c_func_args)) ** 2 *; spmv_csr(config.n_ops_data[j],; config.n_ops_ind[j],; config.n_ops_ptr[j],; psi); for j in config.c_td_inds]); return (con",MatchSource.WIKI,docs/4.2/modules/qutip/mcsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html
https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:14093,Modifiability,config,config,14093,"g.options.seeds); task_kwargs = {}. results = config.map_func(_mc_alg_evolve,; list(range(config.ntraj)),; task_args, task_kwargs,; **map_kwargs). for n, result in enumerate(results):; state_out, expect_out, collapse_times, which_oper = result. if self.config.e_num == 0 or self.config.options.store_states:; self.psi_out[n] = state_out. if self.config.e_num > 0:; self.expect_out[n] = expect_out. self.collapse_times_out[n] = collapse_times; self.which_op_out[n] = which_oper. self.psi_out = np.asarray(self.psi_out, dtype=object). # -----------------------------------------------------------------------------; # CODES FOR PYTHON FUNCTION BASED TIME-DEPENDENT RHS; # -----------------------------------------------------------------------------. # RHS of ODE for time-dependent systems with no collapse operators; def _tdRHS(t, psi, config):; h_data = config.h_func(t, config.h_func_args).data; return spmv(h_data, psi). # RHS of ODE for constant Hamiltonian and at least one function based; # collapse operator; def _cRHStd(t, psi, config):; sys = cy_ode_rhs(t, psi, config.h_data,; config.h_ind, config.h_ptr); col = np.array([np.abs(config.c_funcs[j](t, config.c_func_args)) ** 2 *; spmv_csr(config.n_ops_data[j],; config.n_ops_ind[j],; config.n_ops_ptr[j], psi); for j in config.c_td_inds]); return sys - 0.5 * np.sum(col, 0). # RHS of ODE for list-function based Hamiltonian; def _tdRHStd(t, psi, config):; const_term = spmv_csr(config.h_data,; config.h_ind,; config.h_ptr, psi); h_func_term = np.array([config.h_funcs[j](t, config.h_func_args) *; spmv_csr(config.h_td_data[j],; config.h_td_ind[j],; config.h_td_ptr[j], psi); for j in config.h_td_inds]); col_func_terms = np.array([np.abs(; config.c_funcs[j](t, config.c_func_args)) ** 2 *; spmv_csr(config.n_ops_data[j],; config.n_ops_ind[j],; config.n_ops_ptr[j],; psi); for j in config.c_td_inds]); return (const_term + np.sum(h_func_term, 0); - 0.5 * np.sum(col_func_terms, 0)). def _tdRHStd_with_state(t, psi, config):. const_term = spmv_",MatchSource.WIKI,docs/4.2/modules/qutip/mcsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html
https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:14128,Modifiability,config,config,14128,"g.options.seeds); task_kwargs = {}. results = config.map_func(_mc_alg_evolve,; list(range(config.ntraj)),; task_args, task_kwargs,; **map_kwargs). for n, result in enumerate(results):; state_out, expect_out, collapse_times, which_oper = result. if self.config.e_num == 0 or self.config.options.store_states:; self.psi_out[n] = state_out. if self.config.e_num > 0:; self.expect_out[n] = expect_out. self.collapse_times_out[n] = collapse_times; self.which_op_out[n] = which_oper. self.psi_out = np.asarray(self.psi_out, dtype=object). # -----------------------------------------------------------------------------; # CODES FOR PYTHON FUNCTION BASED TIME-DEPENDENT RHS; # -----------------------------------------------------------------------------. # RHS of ODE for time-dependent systems with no collapse operators; def _tdRHS(t, psi, config):; h_data = config.h_func(t, config.h_func_args).data; return spmv(h_data, psi). # RHS of ODE for constant Hamiltonian and at least one function based; # collapse operator; def _cRHStd(t, psi, config):; sys = cy_ode_rhs(t, psi, config.h_data,; config.h_ind, config.h_ptr); col = np.array([np.abs(config.c_funcs[j](t, config.c_func_args)) ** 2 *; spmv_csr(config.n_ops_data[j],; config.n_ops_ind[j],; config.n_ops_ptr[j], psi); for j in config.c_td_inds]); return sys - 0.5 * np.sum(col, 0). # RHS of ODE for list-function based Hamiltonian; def _tdRHStd(t, psi, config):; const_term = spmv_csr(config.h_data,; config.h_ind,; config.h_ptr, psi); h_func_term = np.array([config.h_funcs[j](t, config.h_func_args) *; spmv_csr(config.h_td_data[j],; config.h_td_ind[j],; config.h_td_ptr[j], psi); for j in config.h_td_inds]); col_func_terms = np.array([np.abs(; config.c_funcs[j](t, config.c_func_args)) ** 2 *; spmv_csr(config.n_ops_data[j],; config.n_ops_ind[j],; config.n_ops_ptr[j],; psi); for j in config.c_td_inds]); return (const_term + np.sum(h_func_term, 0); - 0.5 * np.sum(col_func_terms, 0)). def _tdRHStd_with_state(t, psi, config):. const_term = spmv_",MatchSource.WIKI,docs/4.2/modules/qutip/mcsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html
https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:14144,Modifiability,config,config,14144,"nge(config.ntraj)),; task_args, task_kwargs,; **map_kwargs). for n, result in enumerate(results):; state_out, expect_out, collapse_times, which_oper = result. if self.config.e_num == 0 or self.config.options.store_states:; self.psi_out[n] = state_out. if self.config.e_num > 0:; self.expect_out[n] = expect_out. self.collapse_times_out[n] = collapse_times; self.which_op_out[n] = which_oper. self.psi_out = np.asarray(self.psi_out, dtype=object). # -----------------------------------------------------------------------------; # CODES FOR PYTHON FUNCTION BASED TIME-DEPENDENT RHS; # -----------------------------------------------------------------------------. # RHS of ODE for time-dependent systems with no collapse operators; def _tdRHS(t, psi, config):; h_data = config.h_func(t, config.h_func_args).data; return spmv(h_data, psi). # RHS of ODE for constant Hamiltonian and at least one function based; # collapse operator; def _cRHStd(t, psi, config):; sys = cy_ode_rhs(t, psi, config.h_data,; config.h_ind, config.h_ptr); col = np.array([np.abs(config.c_funcs[j](t, config.c_func_args)) ** 2 *; spmv_csr(config.n_ops_data[j],; config.n_ops_ind[j],; config.n_ops_ptr[j], psi); for j in config.c_td_inds]); return sys - 0.5 * np.sum(col, 0). # RHS of ODE for list-function based Hamiltonian; def _tdRHStd(t, psi, config):; const_term = spmv_csr(config.h_data,; config.h_ind,; config.h_ptr, psi); h_func_term = np.array([config.h_funcs[j](t, config.h_func_args) *; spmv_csr(config.h_td_data[j],; config.h_td_ind[j],; config.h_td_ptr[j], psi); for j in config.h_td_inds]); col_func_terms = np.array([np.abs(; config.c_funcs[j](t, config.c_func_args)) ** 2 *; spmv_csr(config.n_ops_data[j],; config.n_ops_ind[j],; config.n_ops_ptr[j],; psi); for j in config.c_td_inds]); return (const_term + np.sum(h_func_term, 0); - 0.5 * np.sum(col_func_terms, 0)). def _tdRHStd_with_state(t, psi, config):. const_term = spmv_csr(config.h_data,; config.h_ind,; config.h_ptr, psi). h_func_term = np.array([; conf",MatchSource.WIKI,docs/4.2/modules/qutip/mcsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html
https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:14158,Modifiability,config,config,14158,"j)),; task_args, task_kwargs,; **map_kwargs). for n, result in enumerate(results):; state_out, expect_out, collapse_times, which_oper = result. if self.config.e_num == 0 or self.config.options.store_states:; self.psi_out[n] = state_out. if self.config.e_num > 0:; self.expect_out[n] = expect_out. self.collapse_times_out[n] = collapse_times; self.which_op_out[n] = which_oper. self.psi_out = np.asarray(self.psi_out, dtype=object). # -----------------------------------------------------------------------------; # CODES FOR PYTHON FUNCTION BASED TIME-DEPENDENT RHS; # -----------------------------------------------------------------------------. # RHS of ODE for time-dependent systems with no collapse operators; def _tdRHS(t, psi, config):; h_data = config.h_func(t, config.h_func_args).data; return spmv(h_data, psi). # RHS of ODE for constant Hamiltonian and at least one function based; # collapse operator; def _cRHStd(t, psi, config):; sys = cy_ode_rhs(t, psi, config.h_data,; config.h_ind, config.h_ptr); col = np.array([np.abs(config.c_funcs[j](t, config.c_func_args)) ** 2 *; spmv_csr(config.n_ops_data[j],; config.n_ops_ind[j],; config.n_ops_ptr[j], psi); for j in config.c_td_inds]); return sys - 0.5 * np.sum(col, 0). # RHS of ODE for list-function based Hamiltonian; def _tdRHStd(t, psi, config):; const_term = spmv_csr(config.h_data,; config.h_ind,; config.h_ptr, psi); h_func_term = np.array([config.h_funcs[j](t, config.h_func_args) *; spmv_csr(config.h_td_data[j],; config.h_td_ind[j],; config.h_td_ptr[j], psi); for j in config.h_td_inds]); col_func_terms = np.array([np.abs(; config.c_funcs[j](t, config.c_func_args)) ** 2 *; spmv_csr(config.n_ops_data[j],; config.n_ops_ind[j],; config.n_ops_ptr[j],; psi); for j in config.c_td_inds]); return (const_term + np.sum(h_func_term, 0); - 0.5 * np.sum(col_func_terms, 0)). def _tdRHStd_with_state(t, psi, config):. const_term = spmv_csr(config.h_data,; config.h_ind,; config.h_ptr, psi). h_func_term = np.array([; config.h_funcs[j](t",MatchSource.WIKI,docs/4.2/modules/qutip/mcsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html
https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:14196,Modifiability,config,config,14196,"args). for n, result in enumerate(results):; state_out, expect_out, collapse_times, which_oper = result. if self.config.e_num == 0 or self.config.options.store_states:; self.psi_out[n] = state_out. if self.config.e_num > 0:; self.expect_out[n] = expect_out. self.collapse_times_out[n] = collapse_times; self.which_op_out[n] = which_oper. self.psi_out = np.asarray(self.psi_out, dtype=object). # -----------------------------------------------------------------------------; # CODES FOR PYTHON FUNCTION BASED TIME-DEPENDENT RHS; # -----------------------------------------------------------------------------. # RHS of ODE for time-dependent systems with no collapse operators; def _tdRHS(t, psi, config):; h_data = config.h_func(t, config.h_func_args).data; return spmv(h_data, psi). # RHS of ODE for constant Hamiltonian and at least one function based; # collapse operator; def _cRHStd(t, psi, config):; sys = cy_ode_rhs(t, psi, config.h_data,; config.h_ind, config.h_ptr); col = np.array([np.abs(config.c_funcs[j](t, config.c_func_args)) ** 2 *; spmv_csr(config.n_ops_data[j],; config.n_ops_ind[j],; config.n_ops_ptr[j], psi); for j in config.c_td_inds]); return sys - 0.5 * np.sum(col, 0). # RHS of ODE for list-function based Hamiltonian; def _tdRHStd(t, psi, config):; const_term = spmv_csr(config.h_data,; config.h_ind,; config.h_ptr, psi); h_func_term = np.array([config.h_funcs[j](t, config.h_func_args) *; spmv_csr(config.h_td_data[j],; config.h_td_ind[j],; config.h_td_ptr[j], psi); for j in config.h_td_inds]); col_func_terms = np.array([np.abs(; config.c_funcs[j](t, config.c_func_args)) ** 2 *; spmv_csr(config.n_ops_data[j],; config.n_ops_ind[j],; config.n_ops_ptr[j],; psi); for j in config.c_td_inds]); return (const_term + np.sum(h_func_term, 0); - 0.5 * np.sum(col_func_terms, 0)). def _tdRHStd_with_state(t, psi, config):. const_term = spmv_csr(config.h_data,; config.h_ind,; config.h_ptr, psi). h_func_term = np.array([; config.h_funcs[j](t, psi, config.h_func_args) *; spmv_csr(c",MatchSource.WIKI,docs/4.2/modules/qutip/mcsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html
https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:14217,Modifiability,config,config,14217,"sult in enumerate(results):; state_out, expect_out, collapse_times, which_oper = result. if self.config.e_num == 0 or self.config.options.store_states:; self.psi_out[n] = state_out. if self.config.e_num > 0:; self.expect_out[n] = expect_out. self.collapse_times_out[n] = collapse_times; self.which_op_out[n] = which_oper. self.psi_out = np.asarray(self.psi_out, dtype=object). # -----------------------------------------------------------------------------; # CODES FOR PYTHON FUNCTION BASED TIME-DEPENDENT RHS; # -----------------------------------------------------------------------------. # RHS of ODE for time-dependent systems with no collapse operators; def _tdRHS(t, psi, config):; h_data = config.h_func(t, config.h_func_args).data; return spmv(h_data, psi). # RHS of ODE for constant Hamiltonian and at least one function based; # collapse operator; def _cRHStd(t, psi, config):; sys = cy_ode_rhs(t, psi, config.h_data,; config.h_ind, config.h_ptr); col = np.array([np.abs(config.c_funcs[j](t, config.c_func_args)) ** 2 *; spmv_csr(config.n_ops_data[j],; config.n_ops_ind[j],; config.n_ops_ptr[j], psi); for j in config.c_td_inds]); return sys - 0.5 * np.sum(col, 0). # RHS of ODE for list-function based Hamiltonian; def _tdRHStd(t, psi, config):; const_term = spmv_csr(config.h_data,; config.h_ind,; config.h_ptr, psi); h_func_term = np.array([config.h_funcs[j](t, config.h_func_args) *; spmv_csr(config.h_td_data[j],; config.h_td_ind[j],; config.h_td_ptr[j], psi); for j in config.h_td_inds]); col_func_terms = np.array([np.abs(; config.c_funcs[j](t, config.c_func_args)) ** 2 *; spmv_csr(config.n_ops_data[j],; config.n_ops_ind[j],; config.n_ops_ptr[j],; psi); for j in config.c_td_inds]); return (const_term + np.sum(h_func_term, 0); - 0.5 * np.sum(col_func_terms, 0)). def _tdRHStd_with_state(t, psi, config):. const_term = spmv_csr(config.h_data,; config.h_ind,; config.h_ptr, psi). h_func_term = np.array([; config.h_funcs[j](t, psi, config.h_func_args) *; spmv_csr(config.h_td_data[",MatchSource.WIKI,docs/4.2/modules/qutip/mcsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html
https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:14255,Modifiability,config,config,14255,"tate_out, expect_out, collapse_times, which_oper = result. if self.config.e_num == 0 or self.config.options.store_states:; self.psi_out[n] = state_out. if self.config.e_num > 0:; self.expect_out[n] = expect_out. self.collapse_times_out[n] = collapse_times; self.which_op_out[n] = which_oper. self.psi_out = np.asarray(self.psi_out, dtype=object). # -----------------------------------------------------------------------------; # CODES FOR PYTHON FUNCTION BASED TIME-DEPENDENT RHS; # -----------------------------------------------------------------------------. # RHS of ODE for time-dependent systems with no collapse operators; def _tdRHS(t, psi, config):; h_data = config.h_func(t, config.h_func_args).data; return spmv(h_data, psi). # RHS of ODE for constant Hamiltonian and at least one function based; # collapse operator; def _cRHStd(t, psi, config):; sys = cy_ode_rhs(t, psi, config.h_data,; config.h_ind, config.h_ptr); col = np.array([np.abs(config.c_funcs[j](t, config.c_func_args)) ** 2 *; spmv_csr(config.n_ops_data[j],; config.n_ops_ind[j],; config.n_ops_ptr[j], psi); for j in config.c_td_inds]); return sys - 0.5 * np.sum(col, 0). # RHS of ODE for list-function based Hamiltonian; def _tdRHStd(t, psi, config):; const_term = spmv_csr(config.h_data,; config.h_ind,; config.h_ptr, psi); h_func_term = np.array([config.h_funcs[j](t, config.h_func_args) *; spmv_csr(config.h_td_data[j],; config.h_td_ind[j],; config.h_td_ptr[j], psi); for j in config.h_td_inds]); col_func_terms = np.array([np.abs(; config.c_funcs[j](t, config.c_func_args)) ** 2 *; spmv_csr(config.n_ops_data[j],; config.n_ops_ind[j],; config.n_ops_ptr[j],; psi); for j in config.c_td_inds]); return (const_term + np.sum(h_func_term, 0); - 0.5 * np.sum(col_func_terms, 0)). def _tdRHStd_with_state(t, psi, config):. const_term = spmv_csr(config.h_data,; config.h_ind,; config.h_ptr, psi). h_func_term = np.array([; config.h_funcs[j](t, psi, config.h_func_args) *; spmv_csr(config.h_td_data[j],; config.h_td_ind[j],; con",MatchSource.WIKI,docs/4.2/modules/qutip/mcsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html
https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:14278,Modifiability,config,config,14278,"_times, which_oper = result. if self.config.e_num == 0 or self.config.options.store_states:; self.psi_out[n] = state_out. if self.config.e_num > 0:; self.expect_out[n] = expect_out. self.collapse_times_out[n] = collapse_times; self.which_op_out[n] = which_oper. self.psi_out = np.asarray(self.psi_out, dtype=object). # -----------------------------------------------------------------------------; # CODES FOR PYTHON FUNCTION BASED TIME-DEPENDENT RHS; # -----------------------------------------------------------------------------. # RHS of ODE for time-dependent systems with no collapse operators; def _tdRHS(t, psi, config):; h_data = config.h_func(t, config.h_func_args).data; return spmv(h_data, psi). # RHS of ODE for constant Hamiltonian and at least one function based; # collapse operator; def _cRHStd(t, psi, config):; sys = cy_ode_rhs(t, psi, config.h_data,; config.h_ind, config.h_ptr); col = np.array([np.abs(config.c_funcs[j](t, config.c_func_args)) ** 2 *; spmv_csr(config.n_ops_data[j],; config.n_ops_ind[j],; config.n_ops_ptr[j], psi); for j in config.c_td_inds]); return sys - 0.5 * np.sum(col, 0). # RHS of ODE for list-function based Hamiltonian; def _tdRHStd(t, psi, config):; const_term = spmv_csr(config.h_data,; config.h_ind,; config.h_ptr, psi); h_func_term = np.array([config.h_funcs[j](t, config.h_func_args) *; spmv_csr(config.h_td_data[j],; config.h_td_ind[j],; config.h_td_ptr[j], psi); for j in config.h_td_inds]); col_func_terms = np.array([np.abs(; config.c_funcs[j](t, config.c_func_args)) ** 2 *; spmv_csr(config.n_ops_data[j],; config.n_ops_ind[j],; config.n_ops_ptr[j],; psi); for j in config.c_td_inds]); return (const_term + np.sum(h_func_term, 0); - 0.5 * np.sum(col_func_terms, 0)). def _tdRHStd_with_state(t, psi, config):. const_term = spmv_csr(config.h_data,; config.h_ind,; config.h_ptr, psi). h_func_term = np.array([; config.h_funcs[j](t, psi, config.h_func_args) *; spmv_csr(config.h_td_data[j],; config.h_td_ind[j],; config.h_td_ptr[j], psi); for j in",MatchSource.WIKI,docs/4.2/modules/qutip/mcsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html
https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:14300,Modifiability,config,config,14300,"sult. if self.config.e_num == 0 or self.config.options.store_states:; self.psi_out[n] = state_out. if self.config.e_num > 0:; self.expect_out[n] = expect_out. self.collapse_times_out[n] = collapse_times; self.which_op_out[n] = which_oper. self.psi_out = np.asarray(self.psi_out, dtype=object). # -----------------------------------------------------------------------------; # CODES FOR PYTHON FUNCTION BASED TIME-DEPENDENT RHS; # -----------------------------------------------------------------------------. # RHS of ODE for time-dependent systems with no collapse operators; def _tdRHS(t, psi, config):; h_data = config.h_func(t, config.h_func_args).data; return spmv(h_data, psi). # RHS of ODE for constant Hamiltonian and at least one function based; # collapse operator; def _cRHStd(t, psi, config):; sys = cy_ode_rhs(t, psi, config.h_data,; config.h_ind, config.h_ptr); col = np.array([np.abs(config.c_funcs[j](t, config.c_func_args)) ** 2 *; spmv_csr(config.n_ops_data[j],; config.n_ops_ind[j],; config.n_ops_ptr[j], psi); for j in config.c_td_inds]); return sys - 0.5 * np.sum(col, 0). # RHS of ODE for list-function based Hamiltonian; def _tdRHStd(t, psi, config):; const_term = spmv_csr(config.h_data,; config.h_ind,; config.h_ptr, psi); h_func_term = np.array([config.h_funcs[j](t, config.h_func_args) *; spmv_csr(config.h_td_data[j],; config.h_td_ind[j],; config.h_td_ptr[j], psi); for j in config.h_td_inds]); col_func_terms = np.array([np.abs(; config.c_funcs[j](t, config.c_func_args)) ** 2 *; spmv_csr(config.n_ops_data[j],; config.n_ops_ind[j],; config.n_ops_ptr[j],; psi); for j in config.c_td_inds]); return (const_term + np.sum(h_func_term, 0); - 0.5 * np.sum(col_func_terms, 0)). def _tdRHStd_with_state(t, psi, config):. const_term = spmv_csr(config.h_data,; config.h_ind,; config.h_ptr, psi). h_func_term = np.array([; config.h_funcs[j](t, psi, config.h_func_args) *; spmv_csr(config.h_td_data[j],; config.h_td_ind[j],; config.h_td_ptr[j], psi); for j in config.h_td_inds]). c",MatchSource.WIKI,docs/4.2/modules/qutip/mcsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html
https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:14336,Modifiability,config,config,14336," 0 or self.config.options.store_states:; self.psi_out[n] = state_out. if self.config.e_num > 0:; self.expect_out[n] = expect_out. self.collapse_times_out[n] = collapse_times; self.which_op_out[n] = which_oper. self.psi_out = np.asarray(self.psi_out, dtype=object). # -----------------------------------------------------------------------------; # CODES FOR PYTHON FUNCTION BASED TIME-DEPENDENT RHS; # -----------------------------------------------------------------------------. # RHS of ODE for time-dependent systems with no collapse operators; def _tdRHS(t, psi, config):; h_data = config.h_func(t, config.h_func_args).data; return spmv(h_data, psi). # RHS of ODE for constant Hamiltonian and at least one function based; # collapse operator; def _cRHStd(t, psi, config):; sys = cy_ode_rhs(t, psi, config.h_data,; config.h_ind, config.h_ptr); col = np.array([np.abs(config.c_funcs[j](t, config.c_func_args)) ** 2 *; spmv_csr(config.n_ops_data[j],; config.n_ops_ind[j],; config.n_ops_ptr[j], psi); for j in config.c_td_inds]); return sys - 0.5 * np.sum(col, 0). # RHS of ODE for list-function based Hamiltonian; def _tdRHStd(t, psi, config):; const_term = spmv_csr(config.h_data,; config.h_ind,; config.h_ptr, psi); h_func_term = np.array([config.h_funcs[j](t, config.h_func_args) *; spmv_csr(config.h_td_data[j],; config.h_td_ind[j],; config.h_td_ptr[j], psi); for j in config.h_td_inds]); col_func_terms = np.array([np.abs(; config.c_funcs[j](t, config.c_func_args)) ** 2 *; spmv_csr(config.n_ops_data[j],; config.n_ops_ind[j],; config.n_ops_ptr[j],; psi); for j in config.c_td_inds]); return (const_term + np.sum(h_func_term, 0); - 0.5 * np.sum(col_func_terms, 0)). def _tdRHStd_with_state(t, psi, config):. const_term = spmv_csr(config.h_data,; config.h_ind,; config.h_ptr, psi). h_func_term = np.array([; config.h_funcs[j](t, psi, config.h_func_args) *; spmv_csr(config.h_td_data[j],; config.h_td_ind[j],; config.h_td_ptr[j], psi); for j in config.h_td_inds]). col_func_terms = np.array([; n",MatchSource.WIKI,docs/4.2/modules/qutip/mcsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html
https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:14462,Modifiability,config,config,14462,"pect_out. self.collapse_times_out[n] = collapse_times; self.which_op_out[n] = which_oper. self.psi_out = np.asarray(self.psi_out, dtype=object). # -----------------------------------------------------------------------------; # CODES FOR PYTHON FUNCTION BASED TIME-DEPENDENT RHS; # -----------------------------------------------------------------------------. # RHS of ODE for time-dependent systems with no collapse operators; def _tdRHS(t, psi, config):; h_data = config.h_func(t, config.h_func_args).data; return spmv(h_data, psi). # RHS of ODE for constant Hamiltonian and at least one function based; # collapse operator; def _cRHStd(t, psi, config):; sys = cy_ode_rhs(t, psi, config.h_data,; config.h_ind, config.h_ptr); col = np.array([np.abs(config.c_funcs[j](t, config.c_func_args)) ** 2 *; spmv_csr(config.n_ops_data[j],; config.n_ops_ind[j],; config.n_ops_ptr[j], psi); for j in config.c_td_inds]); return sys - 0.5 * np.sum(col, 0). # RHS of ODE for list-function based Hamiltonian; def _tdRHStd(t, psi, config):; const_term = spmv_csr(config.h_data,; config.h_ind,; config.h_ptr, psi); h_func_term = np.array([config.h_funcs[j](t, config.h_func_args) *; spmv_csr(config.h_td_data[j],; config.h_td_ind[j],; config.h_td_ptr[j], psi); for j in config.h_td_inds]); col_func_terms = np.array([np.abs(; config.c_funcs[j](t, config.c_func_args)) ** 2 *; spmv_csr(config.n_ops_data[j],; config.n_ops_ind[j],; config.n_ops_ptr[j],; psi); for j in config.c_td_inds]); return (const_term + np.sum(h_func_term, 0); - 0.5 * np.sum(col_func_terms, 0)). def _tdRHStd_with_state(t, psi, config):. const_term = spmv_csr(config.h_data,; config.h_ind,; config.h_ptr, psi). h_func_term = np.array([; config.h_funcs[j](t, psi, config.h_func_args) *; spmv_csr(config.h_td_data[j],; config.h_td_ind[j],; config.h_td_ptr[j], psi); for j in config.h_td_inds]). col_func_terms = np.array([; np.abs(config.c_funcs[j](t, config.c_func_args)) ** 2 *; spmv_csr(config.n_ops_data[j],; config.n_ops_ind[j],; config.n_op",MatchSource.WIKI,docs/4.2/modules/qutip/mcsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html
https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:14494,Modifiability,config,config,14494,"pect_out. self.collapse_times_out[n] = collapse_times; self.which_op_out[n] = which_oper. self.psi_out = np.asarray(self.psi_out, dtype=object). # -----------------------------------------------------------------------------; # CODES FOR PYTHON FUNCTION BASED TIME-DEPENDENT RHS; # -----------------------------------------------------------------------------. # RHS of ODE for time-dependent systems with no collapse operators; def _tdRHS(t, psi, config):; h_data = config.h_func(t, config.h_func_args).data; return spmv(h_data, psi). # RHS of ODE for constant Hamiltonian and at least one function based; # collapse operator; def _cRHStd(t, psi, config):; sys = cy_ode_rhs(t, psi, config.h_data,; config.h_ind, config.h_ptr); col = np.array([np.abs(config.c_funcs[j](t, config.c_func_args)) ** 2 *; spmv_csr(config.n_ops_data[j],; config.n_ops_ind[j],; config.n_ops_ptr[j], psi); for j in config.c_td_inds]); return sys - 0.5 * np.sum(col, 0). # RHS of ODE for list-function based Hamiltonian; def _tdRHStd(t, psi, config):; const_term = spmv_csr(config.h_data,; config.h_ind,; config.h_ptr, psi); h_func_term = np.array([config.h_funcs[j](t, config.h_func_args) *; spmv_csr(config.h_td_data[j],; config.h_td_ind[j],; config.h_td_ptr[j], psi); for j in config.h_td_inds]); col_func_terms = np.array([np.abs(; config.c_funcs[j](t, config.c_func_args)) ** 2 *; spmv_csr(config.n_ops_data[j],; config.n_ops_ind[j],; config.n_ops_ptr[j],; psi); for j in config.c_td_inds]); return (const_term + np.sum(h_func_term, 0); - 0.5 * np.sum(col_func_terms, 0)). def _tdRHStd_with_state(t, psi, config):. const_term = spmv_csr(config.h_data,; config.h_ind,; config.h_ptr, psi). h_func_term = np.array([; config.h_funcs[j](t, psi, config.h_func_args) *; spmv_csr(config.h_td_data[j],; config.h_td_ind[j],; config.h_td_ptr[j], psi); for j in config.h_td_inds]). col_func_terms = np.array([; np.abs(config.c_funcs[j](t, config.c_func_args)) ** 2 *; spmv_csr(config.n_ops_data[j],; config.n_ops_ind[j],; config.n_op",MatchSource.WIKI,docs/4.2/modules/qutip/mcsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html
https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:14510,Modifiability,config,config,14510,"h_op_out[n] = which_oper. self.psi_out = np.asarray(self.psi_out, dtype=object). # -----------------------------------------------------------------------------; # CODES FOR PYTHON FUNCTION BASED TIME-DEPENDENT RHS; # -----------------------------------------------------------------------------. # RHS of ODE for time-dependent systems with no collapse operators; def _tdRHS(t, psi, config):; h_data = config.h_func(t, config.h_func_args).data; return spmv(h_data, psi). # RHS of ODE for constant Hamiltonian and at least one function based; # collapse operator; def _cRHStd(t, psi, config):; sys = cy_ode_rhs(t, psi, config.h_data,; config.h_ind, config.h_ptr); col = np.array([np.abs(config.c_funcs[j](t, config.c_func_args)) ** 2 *; spmv_csr(config.n_ops_data[j],; config.n_ops_ind[j],; config.n_ops_ptr[j], psi); for j in config.c_td_inds]); return sys - 0.5 * np.sum(col, 0). # RHS of ODE for list-function based Hamiltonian; def _tdRHStd(t, psi, config):; const_term = spmv_csr(config.h_data,; config.h_ind,; config.h_ptr, psi); h_func_term = np.array([config.h_funcs[j](t, config.h_func_args) *; spmv_csr(config.h_td_data[j],; config.h_td_ind[j],; config.h_td_ptr[j], psi); for j in config.h_td_inds]); col_func_terms = np.array([np.abs(; config.c_funcs[j](t, config.c_func_args)) ** 2 *; spmv_csr(config.n_ops_data[j],; config.n_ops_ind[j],; config.n_ops_ptr[j],; psi); for j in config.c_td_inds]); return (const_term + np.sum(h_func_term, 0); - 0.5 * np.sum(col_func_terms, 0)). def _tdRHStd_with_state(t, psi, config):. const_term = spmv_csr(config.h_data,; config.h_ind,; config.h_ptr, psi). h_func_term = np.array([; config.h_funcs[j](t, psi, config.h_func_args) *; spmv_csr(config.h_td_data[j],; config.h_td_ind[j],; config.h_td_ptr[j], psi); for j in config.h_td_inds]). col_func_terms = np.array([; np.abs(config.c_funcs[j](t, config.c_func_args)) ** 2 *; spmv_csr(config.n_ops_data[j],; config.n_ops_ind[j],; config.n_ops_ptr[j], psi); for j in config.c_td_inds]). return (const_term",MatchSource.WIKI,docs/4.2/modules/qutip/mcsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html
https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:14525,Modifiability,config,config,14525,"hich_oper. self.psi_out = np.asarray(self.psi_out, dtype=object). # -----------------------------------------------------------------------------; # CODES FOR PYTHON FUNCTION BASED TIME-DEPENDENT RHS; # -----------------------------------------------------------------------------. # RHS of ODE for time-dependent systems with no collapse operators; def _tdRHS(t, psi, config):; h_data = config.h_func(t, config.h_func_args).data; return spmv(h_data, psi). # RHS of ODE for constant Hamiltonian and at least one function based; # collapse operator; def _cRHStd(t, psi, config):; sys = cy_ode_rhs(t, psi, config.h_data,; config.h_ind, config.h_ptr); col = np.array([np.abs(config.c_funcs[j](t, config.c_func_args)) ** 2 *; spmv_csr(config.n_ops_data[j],; config.n_ops_ind[j],; config.n_ops_ptr[j], psi); for j in config.c_td_inds]); return sys - 0.5 * np.sum(col, 0). # RHS of ODE for list-function based Hamiltonian; def _tdRHStd(t, psi, config):; const_term = spmv_csr(config.h_data,; config.h_ind,; config.h_ptr, psi); h_func_term = np.array([config.h_funcs[j](t, config.h_func_args) *; spmv_csr(config.h_td_data[j],; config.h_td_ind[j],; config.h_td_ptr[j], psi); for j in config.h_td_inds]); col_func_terms = np.array([np.abs(; config.c_funcs[j](t, config.c_func_args)) ** 2 *; spmv_csr(config.n_ops_data[j],; config.n_ops_ind[j],; config.n_ops_ptr[j],; psi); for j in config.c_td_inds]); return (const_term + np.sum(h_func_term, 0); - 0.5 * np.sum(col_func_terms, 0)). def _tdRHStd_with_state(t, psi, config):. const_term = spmv_csr(config.h_data,; config.h_ind,; config.h_ptr, psi). h_func_term = np.array([; config.h_funcs[j](t, psi, config.h_func_args) *; spmv_csr(config.h_td_data[j],; config.h_td_ind[j],; config.h_td_ptr[j], psi); for j in config.h_td_inds]). col_func_terms = np.array([; np.abs(config.c_funcs[j](t, config.c_func_args)) ** 2 *; spmv_csr(config.n_ops_data[j],; config.n_ops_ind[j],; config.n_ops_ptr[j], psi); for j in config.c_td_inds]). return (const_term + np.sum(h_func",MatchSource.WIKI,docs/4.2/modules/qutip/mcsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html
https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:14569,Modifiability,config,config,14569,"_out, dtype=object). # -----------------------------------------------------------------------------; # CODES FOR PYTHON FUNCTION BASED TIME-DEPENDENT RHS; # -----------------------------------------------------------------------------. # RHS of ODE for time-dependent systems with no collapse operators; def _tdRHS(t, psi, config):; h_data = config.h_func(t, config.h_func_args).data; return spmv(h_data, psi). # RHS of ODE for constant Hamiltonian and at least one function based; # collapse operator; def _cRHStd(t, psi, config):; sys = cy_ode_rhs(t, psi, config.h_data,; config.h_ind, config.h_ptr); col = np.array([np.abs(config.c_funcs[j](t, config.c_func_args)) ** 2 *; spmv_csr(config.n_ops_data[j],; config.n_ops_ind[j],; config.n_ops_ptr[j], psi); for j in config.c_td_inds]); return sys - 0.5 * np.sum(col, 0). # RHS of ODE for list-function based Hamiltonian; def _tdRHStd(t, psi, config):; const_term = spmv_csr(config.h_data,; config.h_ind,; config.h_ptr, psi); h_func_term = np.array([config.h_funcs[j](t, config.h_func_args) *; spmv_csr(config.h_td_data[j],; config.h_td_ind[j],; config.h_td_ptr[j], psi); for j in config.h_td_inds]); col_func_terms = np.array([np.abs(; config.c_funcs[j](t, config.c_func_args)) ** 2 *; spmv_csr(config.n_ops_data[j],; config.n_ops_ind[j],; config.n_ops_ptr[j],; psi); for j in config.c_td_inds]); return (const_term + np.sum(h_func_term, 0); - 0.5 * np.sum(col_func_terms, 0)). def _tdRHStd_with_state(t, psi, config):. const_term = spmv_csr(config.h_data,; config.h_ind,; config.h_ptr, psi). h_func_term = np.array([; config.h_funcs[j](t, psi, config.h_func_args) *; spmv_csr(config.h_td_data[j],; config.h_td_ind[j],; config.h_td_ptr[j], psi); for j in config.h_td_inds]). col_func_terms = np.array([; np.abs(config.c_funcs[j](t, config.c_func_args)) ** 2 *; spmv_csr(config.n_ops_data[j],; config.n_ops_ind[j],; config.n_ops_ptr[j], psi); for j in config.c_td_inds]). return (const_term + np.sum(h_func_term, 0); - 0.5 * np.sum(col_func_terms, 0)",MatchSource.WIKI,docs/4.2/modules/qutip/mcsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html
https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:14590,Modifiability,config,config,14590,"t). # -----------------------------------------------------------------------------; # CODES FOR PYTHON FUNCTION BASED TIME-DEPENDENT RHS; # -----------------------------------------------------------------------------. # RHS of ODE for time-dependent systems with no collapse operators; def _tdRHS(t, psi, config):; h_data = config.h_func(t, config.h_func_args).data; return spmv(h_data, psi). # RHS of ODE for constant Hamiltonian and at least one function based; # collapse operator; def _cRHStd(t, psi, config):; sys = cy_ode_rhs(t, psi, config.h_data,; config.h_ind, config.h_ptr); col = np.array([np.abs(config.c_funcs[j](t, config.c_func_args)) ** 2 *; spmv_csr(config.n_ops_data[j],; config.n_ops_ind[j],; config.n_ops_ptr[j], psi); for j in config.c_td_inds]); return sys - 0.5 * np.sum(col, 0). # RHS of ODE for list-function based Hamiltonian; def _tdRHStd(t, psi, config):; const_term = spmv_csr(config.h_data,; config.h_ind,; config.h_ptr, psi); h_func_term = np.array([config.h_funcs[j](t, config.h_func_args) *; spmv_csr(config.h_td_data[j],; config.h_td_ind[j],; config.h_td_ptr[j], psi); for j in config.h_td_inds]); col_func_terms = np.array([np.abs(; config.c_funcs[j](t, config.c_func_args)) ** 2 *; spmv_csr(config.n_ops_data[j],; config.n_ops_ind[j],; config.n_ops_ptr[j],; psi); for j in config.c_td_inds]); return (const_term + np.sum(h_func_term, 0); - 0.5 * np.sum(col_func_terms, 0)). def _tdRHStd_with_state(t, psi, config):. const_term = spmv_csr(config.h_data,; config.h_ind,; config.h_ptr, psi). h_func_term = np.array([; config.h_funcs[j](t, psi, config.h_func_args) *; spmv_csr(config.h_td_data[j],; config.h_td_ind[j],; config.h_td_ptr[j], psi); for j in config.h_td_inds]). col_func_terms = np.array([; np.abs(config.c_funcs[j](t, config.c_func_args)) ** 2 *; spmv_csr(config.n_ops_data[j],; config.n_ops_ind[j],; config.n_ops_ptr[j], psi); for j in config.c_td_inds]). return (const_term + np.sum(h_func_term, 0); - 0.5 * np.sum(col_func_terms, 0)). # RHS of ODE fo",MatchSource.WIKI,docs/4.2/modules/qutip/mcsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html
https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:14622,Modifiability,config,config,14622,"--------------------------------------------------------; # CODES FOR PYTHON FUNCTION BASED TIME-DEPENDENT RHS; # -----------------------------------------------------------------------------. # RHS of ODE for time-dependent systems with no collapse operators; def _tdRHS(t, psi, config):; h_data = config.h_func(t, config.h_func_args).data; return spmv(h_data, psi). # RHS of ODE for constant Hamiltonian and at least one function based; # collapse operator; def _cRHStd(t, psi, config):; sys = cy_ode_rhs(t, psi, config.h_data,; config.h_ind, config.h_ptr); col = np.array([np.abs(config.c_funcs[j](t, config.c_func_args)) ** 2 *; spmv_csr(config.n_ops_data[j],; config.n_ops_ind[j],; config.n_ops_ptr[j], psi); for j in config.c_td_inds]); return sys - 0.5 * np.sum(col, 0). # RHS of ODE for list-function based Hamiltonian; def _tdRHStd(t, psi, config):; const_term = spmv_csr(config.h_data,; config.h_ind,; config.h_ptr, psi); h_func_term = np.array([config.h_funcs[j](t, config.h_func_args) *; spmv_csr(config.h_td_data[j],; config.h_td_ind[j],; config.h_td_ptr[j], psi); for j in config.h_td_inds]); col_func_terms = np.array([np.abs(; config.c_funcs[j](t, config.c_func_args)) ** 2 *; spmv_csr(config.n_ops_data[j],; config.n_ops_ind[j],; config.n_ops_ptr[j],; psi); for j in config.c_td_inds]); return (const_term + np.sum(h_func_term, 0); - 0.5 * np.sum(col_func_terms, 0)). def _tdRHStd_with_state(t, psi, config):. const_term = spmv_csr(config.h_data,; config.h_ind,; config.h_ptr, psi). h_func_term = np.array([; config.h_funcs[j](t, psi, config.h_func_args) *; spmv_csr(config.h_td_data[j],; config.h_td_ind[j],; config.h_td_ptr[j], psi); for j in config.h_td_inds]). col_func_terms = np.array([; np.abs(config.c_funcs[j](t, config.c_func_args)) ** 2 *; spmv_csr(config.n_ops_data[j],; config.n_ops_ind[j],; config.n_ops_ptr[j], psi); for j in config.c_td_inds]). return (const_term + np.sum(h_func_term, 0); - 0.5 * np.sum(col_func_terms, 0)). # RHS of ODE for python function Hamilton",MatchSource.WIKI,docs/4.2/modules/qutip/mcsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html
https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:14644,Modifiability,config,config,14644,"-----------------------------; # CODES FOR PYTHON FUNCTION BASED TIME-DEPENDENT RHS; # -----------------------------------------------------------------------------. # RHS of ODE for time-dependent systems with no collapse operators; def _tdRHS(t, psi, config):; h_data = config.h_func(t, config.h_func_args).data; return spmv(h_data, psi). # RHS of ODE for constant Hamiltonian and at least one function based; # collapse operator; def _cRHStd(t, psi, config):; sys = cy_ode_rhs(t, psi, config.h_data,; config.h_ind, config.h_ptr); col = np.array([np.abs(config.c_funcs[j](t, config.c_func_args)) ** 2 *; spmv_csr(config.n_ops_data[j],; config.n_ops_ind[j],; config.n_ops_ptr[j], psi); for j in config.c_td_inds]); return sys - 0.5 * np.sum(col, 0). # RHS of ODE for list-function based Hamiltonian; def _tdRHStd(t, psi, config):; const_term = spmv_csr(config.h_data,; config.h_ind,; config.h_ptr, psi); h_func_term = np.array([config.h_funcs[j](t, config.h_func_args) *; spmv_csr(config.h_td_data[j],; config.h_td_ind[j],; config.h_td_ptr[j], psi); for j in config.h_td_inds]); col_func_terms = np.array([np.abs(; config.c_funcs[j](t, config.c_func_args)) ** 2 *; spmv_csr(config.n_ops_data[j],; config.n_ops_ind[j],; config.n_ops_ptr[j],; psi); for j in config.c_td_inds]); return (const_term + np.sum(h_func_term, 0); - 0.5 * np.sum(col_func_terms, 0)). def _tdRHStd_with_state(t, psi, config):. const_term = spmv_csr(config.h_data,; config.h_ind,; config.h_ptr, psi). h_func_term = np.array([; config.h_funcs[j](t, psi, config.h_func_args) *; spmv_csr(config.h_td_data[j],; config.h_td_ind[j],; config.h_td_ptr[j], psi); for j in config.h_td_inds]). col_func_terms = np.array([; np.abs(config.c_funcs[j](t, config.c_func_args)) ** 2 *; spmv_csr(config.n_ops_data[j],; config.n_ops_ind[j],; config.n_ops_ptr[j], psi); for j in config.c_td_inds]). return (const_term + np.sum(h_func_term, 0); - 0.5 * np.sum(col_func_terms, 0)). # RHS of ODE for python function Hamiltonian; def _pyRHSc(t, psi, co",MatchSource.WIKI,docs/4.2/modules/qutip/mcsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html
https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:14665,Modifiability,config,config,14665,"--------; # CODES FOR PYTHON FUNCTION BASED TIME-DEPENDENT RHS; # -----------------------------------------------------------------------------. # RHS of ODE for time-dependent systems with no collapse operators; def _tdRHS(t, psi, config):; h_data = config.h_func(t, config.h_func_args).data; return spmv(h_data, psi). # RHS of ODE for constant Hamiltonian and at least one function based; # collapse operator; def _cRHStd(t, psi, config):; sys = cy_ode_rhs(t, psi, config.h_data,; config.h_ind, config.h_ptr); col = np.array([np.abs(config.c_funcs[j](t, config.c_func_args)) ** 2 *; spmv_csr(config.n_ops_data[j],; config.n_ops_ind[j],; config.n_ops_ptr[j], psi); for j in config.c_td_inds]); return sys - 0.5 * np.sum(col, 0). # RHS of ODE for list-function based Hamiltonian; def _tdRHStd(t, psi, config):; const_term = spmv_csr(config.h_data,; config.h_ind,; config.h_ptr, psi); h_func_term = np.array([config.h_funcs[j](t, config.h_func_args) *; spmv_csr(config.h_td_data[j],; config.h_td_ind[j],; config.h_td_ptr[j], psi); for j in config.h_td_inds]); col_func_terms = np.array([np.abs(; config.c_funcs[j](t, config.c_func_args)) ** 2 *; spmv_csr(config.n_ops_data[j],; config.n_ops_ind[j],; config.n_ops_ptr[j],; psi); for j in config.c_td_inds]); return (const_term + np.sum(h_func_term, 0); - 0.5 * np.sum(col_func_terms, 0)). def _tdRHStd_with_state(t, psi, config):. const_term = spmv_csr(config.h_data,; config.h_ind,; config.h_ptr, psi). h_func_term = np.array([; config.h_funcs[j](t, psi, config.h_func_args) *; spmv_csr(config.h_td_data[j],; config.h_td_ind[j],; config.h_td_ptr[j], psi); for j in config.h_td_inds]). col_func_terms = np.array([; np.abs(config.c_funcs[j](t, config.c_func_args)) ** 2 *; spmv_csr(config.n_ops_data[j],; config.n_ops_ind[j],; config.n_ops_ptr[j], psi); for j in config.c_td_inds]). return (const_term + np.sum(h_func_term, 0); - 0.5 * np.sum(col_func_terms, 0)). # RHS of ODE for python function Hamiltonian; def _pyRHSc(t, psi, config):; h_func_data = ",MatchSource.WIKI,docs/4.2/modules/qutip/mcsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html
https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:14700,Modifiability,config,config,14700," FUNCTION BASED TIME-DEPENDENT RHS; # -----------------------------------------------------------------------------. # RHS of ODE for time-dependent systems with no collapse operators; def _tdRHS(t, psi, config):; h_data = config.h_func(t, config.h_func_args).data; return spmv(h_data, psi). # RHS of ODE for constant Hamiltonian and at least one function based; # collapse operator; def _cRHStd(t, psi, config):; sys = cy_ode_rhs(t, psi, config.h_data,; config.h_ind, config.h_ptr); col = np.array([np.abs(config.c_funcs[j](t, config.c_func_args)) ** 2 *; spmv_csr(config.n_ops_data[j],; config.n_ops_ind[j],; config.n_ops_ptr[j], psi); for j in config.c_td_inds]); return sys - 0.5 * np.sum(col, 0). # RHS of ODE for list-function based Hamiltonian; def _tdRHStd(t, psi, config):; const_term = spmv_csr(config.h_data,; config.h_ind,; config.h_ptr, psi); h_func_term = np.array([config.h_funcs[j](t, config.h_func_args) *; spmv_csr(config.h_td_data[j],; config.h_td_ind[j],; config.h_td_ptr[j], psi); for j in config.h_td_inds]); col_func_terms = np.array([np.abs(; config.c_funcs[j](t, config.c_func_args)) ** 2 *; spmv_csr(config.n_ops_data[j],; config.n_ops_ind[j],; config.n_ops_ptr[j],; psi); for j in config.c_td_inds]); return (const_term + np.sum(h_func_term, 0); - 0.5 * np.sum(col_func_terms, 0)). def _tdRHStd_with_state(t, psi, config):. const_term = spmv_csr(config.h_data,; config.h_ind,; config.h_ptr, psi). h_func_term = np.array([; config.h_funcs[j](t, psi, config.h_func_args) *; spmv_csr(config.h_td_data[j],; config.h_td_ind[j],; config.h_td_ptr[j], psi); for j in config.h_td_inds]). col_func_terms = np.array([; np.abs(config.c_funcs[j](t, config.c_func_args)) ** 2 *; spmv_csr(config.n_ops_data[j],; config.n_ops_ind[j],; config.n_ops_ptr[j], psi); for j in config.c_td_inds]). return (const_term + np.sum(h_func_term, 0); - 0.5 * np.sum(col_func_terms, 0)). # RHS of ODE for python function Hamiltonian; def _pyRHSc(t, psi, config):; h_func_data = - 1.0j * config.h_funcs(t, c",MatchSource.WIKI,docs/4.2/modules/qutip/mcsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html
https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:14756,Modifiability,config,config,14756,"------------------------------------------------. # RHS of ODE for time-dependent systems with no collapse operators; def _tdRHS(t, psi, config):; h_data = config.h_func(t, config.h_func_args).data; return spmv(h_data, psi). # RHS of ODE for constant Hamiltonian and at least one function based; # collapse operator; def _cRHStd(t, psi, config):; sys = cy_ode_rhs(t, psi, config.h_data,; config.h_ind, config.h_ptr); col = np.array([np.abs(config.c_funcs[j](t, config.c_func_args)) ** 2 *; spmv_csr(config.n_ops_data[j],; config.n_ops_ind[j],; config.n_ops_ptr[j], psi); for j in config.c_td_inds]); return sys - 0.5 * np.sum(col, 0). # RHS of ODE for list-function based Hamiltonian; def _tdRHStd(t, psi, config):; const_term = spmv_csr(config.h_data,; config.h_ind,; config.h_ptr, psi); h_func_term = np.array([config.h_funcs[j](t, config.h_func_args) *; spmv_csr(config.h_td_data[j],; config.h_td_ind[j],; config.h_td_ptr[j], psi); for j in config.h_td_inds]); col_func_terms = np.array([np.abs(; config.c_funcs[j](t, config.c_func_args)) ** 2 *; spmv_csr(config.n_ops_data[j],; config.n_ops_ind[j],; config.n_ops_ptr[j],; psi); for j in config.c_td_inds]); return (const_term + np.sum(h_func_term, 0); - 0.5 * np.sum(col_func_terms, 0)). def _tdRHStd_with_state(t, psi, config):. const_term = spmv_csr(config.h_data,; config.h_ind,; config.h_ptr, psi). h_func_term = np.array([; config.h_funcs[j](t, psi, config.h_func_args) *; spmv_csr(config.h_td_data[j],; config.h_td_ind[j],; config.h_td_ptr[j], psi); for j in config.h_td_inds]). col_func_terms = np.array([; np.abs(config.c_funcs[j](t, config.c_func_args)) ** 2 *; spmv_csr(config.n_ops_data[j],; config.n_ops_ind[j],; config.n_ops_ptr[j], psi); for j in config.c_td_inds]). return (const_term + np.sum(h_func_term, 0); - 0.5 * np.sum(col_func_terms, 0)). # RHS of ODE for python function Hamiltonian; def _pyRHSc(t, psi, config):; h_func_data = - 1.0j * config.h_funcs(t, config.h_func_args); h_func_term = spmv(h_func_data, psi); const_col",MatchSource.WIKI,docs/4.2/modules/qutip/mcsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html
https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:14777,Modifiability,config,config,14777,"-------------------------------. # RHS of ODE for time-dependent systems with no collapse operators; def _tdRHS(t, psi, config):; h_data = config.h_func(t, config.h_func_args).data; return spmv(h_data, psi). # RHS of ODE for constant Hamiltonian and at least one function based; # collapse operator; def _cRHStd(t, psi, config):; sys = cy_ode_rhs(t, psi, config.h_data,; config.h_ind, config.h_ptr); col = np.array([np.abs(config.c_funcs[j](t, config.c_func_args)) ** 2 *; spmv_csr(config.n_ops_data[j],; config.n_ops_ind[j],; config.n_ops_ptr[j], psi); for j in config.c_td_inds]); return sys - 0.5 * np.sum(col, 0). # RHS of ODE for list-function based Hamiltonian; def _tdRHStd(t, psi, config):; const_term = spmv_csr(config.h_data,; config.h_ind,; config.h_ptr, psi); h_func_term = np.array([config.h_funcs[j](t, config.h_func_args) *; spmv_csr(config.h_td_data[j],; config.h_td_ind[j],; config.h_td_ptr[j], psi); for j in config.h_td_inds]); col_func_terms = np.array([np.abs(; config.c_funcs[j](t, config.c_func_args)) ** 2 *; spmv_csr(config.n_ops_data[j],; config.n_ops_ind[j],; config.n_ops_ptr[j],; psi); for j in config.c_td_inds]); return (const_term + np.sum(h_func_term, 0); - 0.5 * np.sum(col_func_terms, 0)). def _tdRHStd_with_state(t, psi, config):. const_term = spmv_csr(config.h_data,; config.h_ind,; config.h_ptr, psi). h_func_term = np.array([; config.h_funcs[j](t, psi, config.h_func_args) *; spmv_csr(config.h_td_data[j],; config.h_td_ind[j],; config.h_td_ptr[j], psi); for j in config.h_td_inds]). col_func_terms = np.array([; np.abs(config.c_funcs[j](t, config.c_func_args)) ** 2 *; spmv_csr(config.n_ops_data[j],; config.n_ops_ind[j],; config.n_ops_ptr[j], psi); for j in config.c_td_inds]). return (const_term + np.sum(h_func_term, 0); - 0.5 * np.sum(col_func_terms, 0)). # RHS of ODE for python function Hamiltonian; def _pyRHSc(t, psi, config):; h_func_data = - 1.0j * config.h_funcs(t, config.h_func_args); h_func_term = spmv(h_func_data, psi); const_col_term = 0; if len",MatchSource.WIKI,docs/4.2/modules/qutip/mcsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html
https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:14815,Modifiability,config,config,14815,"-. # RHS of ODE for time-dependent systems with no collapse operators; def _tdRHS(t, psi, config):; h_data = config.h_func(t, config.h_func_args).data; return spmv(h_data, psi). # RHS of ODE for constant Hamiltonian and at least one function based; # collapse operator; def _cRHStd(t, psi, config):; sys = cy_ode_rhs(t, psi, config.h_data,; config.h_ind, config.h_ptr); col = np.array([np.abs(config.c_funcs[j](t, config.c_func_args)) ** 2 *; spmv_csr(config.n_ops_data[j],; config.n_ops_ind[j],; config.n_ops_ptr[j], psi); for j in config.c_td_inds]); return sys - 0.5 * np.sum(col, 0). # RHS of ODE for list-function based Hamiltonian; def _tdRHStd(t, psi, config):; const_term = spmv_csr(config.h_data,; config.h_ind,; config.h_ptr, psi); h_func_term = np.array([config.h_funcs[j](t, config.h_func_args) *; spmv_csr(config.h_td_data[j],; config.h_td_ind[j],; config.h_td_ptr[j], psi); for j in config.h_td_inds]); col_func_terms = np.array([np.abs(; config.c_funcs[j](t, config.c_func_args)) ** 2 *; spmv_csr(config.n_ops_data[j],; config.n_ops_ind[j],; config.n_ops_ptr[j],; psi); for j in config.c_td_inds]); return (const_term + np.sum(h_func_term, 0); - 0.5 * np.sum(col_func_terms, 0)). def _tdRHStd_with_state(t, psi, config):. const_term = spmv_csr(config.h_data,; config.h_ind,; config.h_ptr, psi). h_func_term = np.array([; config.h_funcs[j](t, psi, config.h_func_args) *; spmv_csr(config.h_td_data[j],; config.h_td_ind[j],; config.h_td_ptr[j], psi); for j in config.h_td_inds]). col_func_terms = np.array([; np.abs(config.c_funcs[j](t, config.c_func_args)) ** 2 *; spmv_csr(config.n_ops_data[j],; config.n_ops_ind[j],; config.n_ops_ptr[j], psi); for j in config.c_td_inds]). return (const_term + np.sum(h_func_term, 0); - 0.5 * np.sum(col_func_terms, 0)). # RHS of ODE for python function Hamiltonian; def _pyRHSc(t, psi, config):; h_func_data = - 1.0j * config.h_funcs(t, config.h_func_args); h_func_term = spmv(h_func_data, psi); const_col_term = 0; if len(config.c_const_inds) > 0:; c",MatchSource.WIKI,docs/4.2/modules/qutip/mcsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html
https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:14838,Modifiability,config,config,14838,"dent systems with no collapse operators; def _tdRHS(t, psi, config):; h_data = config.h_func(t, config.h_func_args).data; return spmv(h_data, psi). # RHS of ODE for constant Hamiltonian and at least one function based; # collapse operator; def _cRHStd(t, psi, config):; sys = cy_ode_rhs(t, psi, config.h_data,; config.h_ind, config.h_ptr); col = np.array([np.abs(config.c_funcs[j](t, config.c_func_args)) ** 2 *; spmv_csr(config.n_ops_data[j],; config.n_ops_ind[j],; config.n_ops_ptr[j], psi); for j in config.c_td_inds]); return sys - 0.5 * np.sum(col, 0). # RHS of ODE for list-function based Hamiltonian; def _tdRHStd(t, psi, config):; const_term = spmv_csr(config.h_data,; config.h_ind,; config.h_ptr, psi); h_func_term = np.array([config.h_funcs[j](t, config.h_func_args) *; spmv_csr(config.h_td_data[j],; config.h_td_ind[j],; config.h_td_ptr[j], psi); for j in config.h_td_inds]); col_func_terms = np.array([np.abs(; config.c_funcs[j](t, config.c_func_args)) ** 2 *; spmv_csr(config.n_ops_data[j],; config.n_ops_ind[j],; config.n_ops_ptr[j],; psi); for j in config.c_td_inds]); return (const_term + np.sum(h_func_term, 0); - 0.5 * np.sum(col_func_terms, 0)). def _tdRHStd_with_state(t, psi, config):. const_term = spmv_csr(config.h_data,; config.h_ind,; config.h_ptr, psi). h_func_term = np.array([; config.h_funcs[j](t, psi, config.h_func_args) *; spmv_csr(config.h_td_data[j],; config.h_td_ind[j],; config.h_td_ptr[j], psi); for j in config.h_td_inds]). col_func_terms = np.array([; np.abs(config.c_funcs[j](t, config.c_func_args)) ** 2 *; spmv_csr(config.n_ops_data[j],; config.n_ops_ind[j],; config.n_ops_ptr[j], psi); for j in config.c_td_inds]). return (const_term + np.sum(h_func_term, 0); - 0.5 * np.sum(col_func_terms, 0)). # RHS of ODE for python function Hamiltonian; def _pyRHSc(t, psi, config):; h_func_data = - 1.0j * config.h_funcs(t, config.h_func_args); h_func_term = spmv(h_func_data, psi); const_col_term = 0; if len(config.c_const_inds) > 0:; const_col_term = spmv_csr(config",MatchSource.WIKI,docs/4.2/modules/qutip/mcsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html
https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:14860,Modifiability,config,config,14860,"llapse operators; def _tdRHS(t, psi, config):; h_data = config.h_func(t, config.h_func_args).data; return spmv(h_data, psi). # RHS of ODE for constant Hamiltonian and at least one function based; # collapse operator; def _cRHStd(t, psi, config):; sys = cy_ode_rhs(t, psi, config.h_data,; config.h_ind, config.h_ptr); col = np.array([np.abs(config.c_funcs[j](t, config.c_func_args)) ** 2 *; spmv_csr(config.n_ops_data[j],; config.n_ops_ind[j],; config.n_ops_ptr[j], psi); for j in config.c_td_inds]); return sys - 0.5 * np.sum(col, 0). # RHS of ODE for list-function based Hamiltonian; def _tdRHStd(t, psi, config):; const_term = spmv_csr(config.h_data,; config.h_ind,; config.h_ptr, psi); h_func_term = np.array([config.h_funcs[j](t, config.h_func_args) *; spmv_csr(config.h_td_data[j],; config.h_td_ind[j],; config.h_td_ptr[j], psi); for j in config.h_td_inds]); col_func_terms = np.array([np.abs(; config.c_funcs[j](t, config.c_func_args)) ** 2 *; spmv_csr(config.n_ops_data[j],; config.n_ops_ind[j],; config.n_ops_ptr[j],; psi); for j in config.c_td_inds]); return (const_term + np.sum(h_func_term, 0); - 0.5 * np.sum(col_func_terms, 0)). def _tdRHStd_with_state(t, psi, config):. const_term = spmv_csr(config.h_data,; config.h_ind,; config.h_ptr, psi). h_func_term = np.array([; config.h_funcs[j](t, psi, config.h_func_args) *; spmv_csr(config.h_td_data[j],; config.h_td_ind[j],; config.h_td_ptr[j], psi); for j in config.h_td_inds]). col_func_terms = np.array([; np.abs(config.c_funcs[j](t, config.c_func_args)) ** 2 *; spmv_csr(config.n_ops_data[j],; config.n_ops_ind[j],; config.n_ops_ptr[j], psi); for j in config.c_td_inds]). return (const_term + np.sum(h_func_term, 0); - 0.5 * np.sum(col_func_terms, 0)). # RHS of ODE for python function Hamiltonian; def _pyRHSc(t, psi, config):; h_func_data = - 1.0j * config.h_funcs(t, config.h_func_args); h_func_term = spmv(h_func_data, psi); const_col_term = 0; if len(config.c_const_inds) > 0:; const_col_term = spmv_csr(config.h_data, config.h_ind,",MatchSource.WIKI,docs/4.2/modules/qutip/mcsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html
https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:14897,Modifiability,config,config,14897,"t, psi, config):; h_data = config.h_func(t, config.h_func_args).data; return spmv(h_data, psi). # RHS of ODE for constant Hamiltonian and at least one function based; # collapse operator; def _cRHStd(t, psi, config):; sys = cy_ode_rhs(t, psi, config.h_data,; config.h_ind, config.h_ptr); col = np.array([np.abs(config.c_funcs[j](t, config.c_func_args)) ** 2 *; spmv_csr(config.n_ops_data[j],; config.n_ops_ind[j],; config.n_ops_ptr[j], psi); for j in config.c_td_inds]); return sys - 0.5 * np.sum(col, 0). # RHS of ODE for list-function based Hamiltonian; def _tdRHStd(t, psi, config):; const_term = spmv_csr(config.h_data,; config.h_ind,; config.h_ptr, psi); h_func_term = np.array([config.h_funcs[j](t, config.h_func_args) *; spmv_csr(config.h_td_data[j],; config.h_td_ind[j],; config.h_td_ptr[j], psi); for j in config.h_td_inds]); col_func_terms = np.array([np.abs(; config.c_funcs[j](t, config.c_func_args)) ** 2 *; spmv_csr(config.n_ops_data[j],; config.n_ops_ind[j],; config.n_ops_ptr[j],; psi); for j in config.c_td_inds]); return (const_term + np.sum(h_func_term, 0); - 0.5 * np.sum(col_func_terms, 0)). def _tdRHStd_with_state(t, psi, config):. const_term = spmv_csr(config.h_data,; config.h_ind,; config.h_ptr, psi). h_func_term = np.array([; config.h_funcs[j](t, psi, config.h_func_args) *; spmv_csr(config.h_td_data[j],; config.h_td_ind[j],; config.h_td_ptr[j], psi); for j in config.h_td_inds]). col_func_terms = np.array([; np.abs(config.c_funcs[j](t, config.c_func_args)) ** 2 *; spmv_csr(config.n_ops_data[j],; config.n_ops_ind[j],; config.n_ops_ptr[j], psi); for j in config.c_td_inds]). return (const_term + np.sum(h_func_term, 0); - 0.5 * np.sum(col_func_terms, 0)). # RHS of ODE for python function Hamiltonian; def _pyRHSc(t, psi, config):; h_func_data = - 1.0j * config.h_funcs(t, config.h_func_args); h_func_term = spmv(h_func_data, psi); const_col_term = 0; if len(config.c_const_inds) > 0:; const_col_term = spmv_csr(config.h_data, config.h_ind,; config.h_ptr, psi). return h",MatchSource.WIKI,docs/4.2/modules/qutip/mcsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html
https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:15030,Modifiability,config,config,15030," and at least one function based; # collapse operator; def _cRHStd(t, psi, config):; sys = cy_ode_rhs(t, psi, config.h_data,; config.h_ind, config.h_ptr); col = np.array([np.abs(config.c_funcs[j](t, config.c_func_args)) ** 2 *; spmv_csr(config.n_ops_data[j],; config.n_ops_ind[j],; config.n_ops_ptr[j], psi); for j in config.c_td_inds]); return sys - 0.5 * np.sum(col, 0). # RHS of ODE for list-function based Hamiltonian; def _tdRHStd(t, psi, config):; const_term = spmv_csr(config.h_data,; config.h_ind,; config.h_ptr, psi); h_func_term = np.array([config.h_funcs[j](t, config.h_func_args) *; spmv_csr(config.h_td_data[j],; config.h_td_ind[j],; config.h_td_ptr[j], psi); for j in config.h_td_inds]); col_func_terms = np.array([np.abs(; config.c_funcs[j](t, config.c_func_args)) ** 2 *; spmv_csr(config.n_ops_data[j],; config.n_ops_ind[j],; config.n_ops_ptr[j],; psi); for j in config.c_td_inds]); return (const_term + np.sum(h_func_term, 0); - 0.5 * np.sum(col_func_terms, 0)). def _tdRHStd_with_state(t, psi, config):. const_term = spmv_csr(config.h_data,; config.h_ind,; config.h_ptr, psi). h_func_term = np.array([; config.h_funcs[j](t, psi, config.h_func_args) *; spmv_csr(config.h_td_data[j],; config.h_td_ind[j],; config.h_td_ptr[j], psi); for j in config.h_td_inds]). col_func_terms = np.array([; np.abs(config.c_funcs[j](t, config.c_func_args)) ** 2 *; spmv_csr(config.n_ops_data[j],; config.n_ops_ind[j],; config.n_ops_ptr[j], psi); for j in config.c_td_inds]). return (const_term + np.sum(h_func_term, 0); - 0.5 * np.sum(col_func_terms, 0)). # RHS of ODE for python function Hamiltonian; def _pyRHSc(t, psi, config):; h_func_data = - 1.0j * config.h_funcs(t, config.h_func_args); h_func_term = spmv(h_func_data, psi); const_col_term = 0; if len(config.c_const_inds) > 0:; const_col_term = spmv_csr(config.h_data, config.h_ind,; config.h_ptr, psi). return h_func_term + const_col_term. def _pyRHSc_with_state(t, psi, config):; h_func_data = - 1.0j * config.h_funcs(t, psi, config.h_func_ar",MatchSource.WIKI,docs/4.2/modules/qutip/mcsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html
https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:15062,Modifiability,config,config,15062,"collapse operator; def _cRHStd(t, psi, config):; sys = cy_ode_rhs(t, psi, config.h_data,; config.h_ind, config.h_ptr); col = np.array([np.abs(config.c_funcs[j](t, config.c_func_args)) ** 2 *; spmv_csr(config.n_ops_data[j],; config.n_ops_ind[j],; config.n_ops_ptr[j], psi); for j in config.c_td_inds]); return sys - 0.5 * np.sum(col, 0). # RHS of ODE for list-function based Hamiltonian; def _tdRHStd(t, psi, config):; const_term = spmv_csr(config.h_data,; config.h_ind,; config.h_ptr, psi); h_func_term = np.array([config.h_funcs[j](t, config.h_func_args) *; spmv_csr(config.h_td_data[j],; config.h_td_ind[j],; config.h_td_ptr[j], psi); for j in config.h_td_inds]); col_func_terms = np.array([np.abs(; config.c_funcs[j](t, config.c_func_args)) ** 2 *; spmv_csr(config.n_ops_data[j],; config.n_ops_ind[j],; config.n_ops_ptr[j],; psi); for j in config.c_td_inds]); return (const_term + np.sum(h_func_term, 0); - 0.5 * np.sum(col_func_terms, 0)). def _tdRHStd_with_state(t, psi, config):. const_term = spmv_csr(config.h_data,; config.h_ind,; config.h_ptr, psi). h_func_term = np.array([; config.h_funcs[j](t, psi, config.h_func_args) *; spmv_csr(config.h_td_data[j],; config.h_td_ind[j],; config.h_td_ptr[j], psi); for j in config.h_td_inds]). col_func_terms = np.array([; np.abs(config.c_funcs[j](t, config.c_func_args)) ** 2 *; spmv_csr(config.n_ops_data[j],; config.n_ops_ind[j],; config.n_ops_ptr[j], psi); for j in config.c_td_inds]). return (const_term + np.sum(h_func_term, 0); - 0.5 * np.sum(col_func_terms, 0)). # RHS of ODE for python function Hamiltonian; def _pyRHSc(t, psi, config):; h_func_data = - 1.0j * config.h_funcs(t, config.h_func_args); h_func_term = spmv(h_func_data, psi); const_col_term = 0; if len(config.c_const_inds) > 0:; const_col_term = spmv_csr(config.h_data, config.h_ind,; config.h_ptr, psi). return h_func_term + const_col_term. def _pyRHSc_with_state(t, psi, config):; h_func_data = - 1.0j * config.h_funcs(t, psi, config.h_func_args); h_func_term = spmv(h_func_data,",MatchSource.WIKI,docs/4.2/modules/qutip/mcsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html
https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:15078,Modifiability,config,config,15078,"_cRHStd(t, psi, config):; sys = cy_ode_rhs(t, psi, config.h_data,; config.h_ind, config.h_ptr); col = np.array([np.abs(config.c_funcs[j](t, config.c_func_args)) ** 2 *; spmv_csr(config.n_ops_data[j],; config.n_ops_ind[j],; config.n_ops_ptr[j], psi); for j in config.c_td_inds]); return sys - 0.5 * np.sum(col, 0). # RHS of ODE for list-function based Hamiltonian; def _tdRHStd(t, psi, config):; const_term = spmv_csr(config.h_data,; config.h_ind,; config.h_ptr, psi); h_func_term = np.array([config.h_funcs[j](t, config.h_func_args) *; spmv_csr(config.h_td_data[j],; config.h_td_ind[j],; config.h_td_ptr[j], psi); for j in config.h_td_inds]); col_func_terms = np.array([np.abs(; config.c_funcs[j](t, config.c_func_args)) ** 2 *; spmv_csr(config.n_ops_data[j],; config.n_ops_ind[j],; config.n_ops_ptr[j],; psi); for j in config.c_td_inds]); return (const_term + np.sum(h_func_term, 0); - 0.5 * np.sum(col_func_terms, 0)). def _tdRHStd_with_state(t, psi, config):. const_term = spmv_csr(config.h_data,; config.h_ind,; config.h_ptr, psi). h_func_term = np.array([; config.h_funcs[j](t, psi, config.h_func_args) *; spmv_csr(config.h_td_data[j],; config.h_td_ind[j],; config.h_td_ptr[j], psi); for j in config.h_td_inds]). col_func_terms = np.array([; np.abs(config.c_funcs[j](t, config.c_func_args)) ** 2 *; spmv_csr(config.n_ops_data[j],; config.n_ops_ind[j],; config.n_ops_ptr[j], psi); for j in config.c_td_inds]). return (const_term + np.sum(h_func_term, 0); - 0.5 * np.sum(col_func_terms, 0)). # RHS of ODE for python function Hamiltonian; def _pyRHSc(t, psi, config):; h_func_data = - 1.0j * config.h_funcs(t, config.h_func_args); h_func_term = spmv(h_func_data, psi); const_col_term = 0; if len(config.c_const_inds) > 0:; const_col_term = spmv_csr(config.h_data, config.h_ind,; config.h_ptr, psi). return h_func_term + const_col_term. def _pyRHSc_with_state(t, psi, config):; h_func_data = - 1.0j * config.h_funcs(t, psi, config.h_func_args); h_func_term = spmv(h_func_data, psi); const_col_term =",MatchSource.WIKI,docs/4.2/modules/qutip/mcsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html
https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:15093,Modifiability,config,config,15093," config):; sys = cy_ode_rhs(t, psi, config.h_data,; config.h_ind, config.h_ptr); col = np.array([np.abs(config.c_funcs[j](t, config.c_func_args)) ** 2 *; spmv_csr(config.n_ops_data[j],; config.n_ops_ind[j],; config.n_ops_ptr[j], psi); for j in config.c_td_inds]); return sys - 0.5 * np.sum(col, 0). # RHS of ODE for list-function based Hamiltonian; def _tdRHStd(t, psi, config):; const_term = spmv_csr(config.h_data,; config.h_ind,; config.h_ptr, psi); h_func_term = np.array([config.h_funcs[j](t, config.h_func_args) *; spmv_csr(config.h_td_data[j],; config.h_td_ind[j],; config.h_td_ptr[j], psi); for j in config.h_td_inds]); col_func_terms = np.array([np.abs(; config.c_funcs[j](t, config.c_func_args)) ** 2 *; spmv_csr(config.n_ops_data[j],; config.n_ops_ind[j],; config.n_ops_ptr[j],; psi); for j in config.c_td_inds]); return (const_term + np.sum(h_func_term, 0); - 0.5 * np.sum(col_func_terms, 0)). def _tdRHStd_with_state(t, psi, config):. const_term = spmv_csr(config.h_data,; config.h_ind,; config.h_ptr, psi). h_func_term = np.array([; config.h_funcs[j](t, psi, config.h_func_args) *; spmv_csr(config.h_td_data[j],; config.h_td_ind[j],; config.h_td_ptr[j], psi); for j in config.h_td_inds]). col_func_terms = np.array([; np.abs(config.c_funcs[j](t, config.c_func_args)) ** 2 *; spmv_csr(config.n_ops_data[j],; config.n_ops_ind[j],; config.n_ops_ptr[j], psi); for j in config.c_td_inds]). return (const_term + np.sum(h_func_term, 0); - 0.5 * np.sum(col_func_terms, 0)). # RHS of ODE for python function Hamiltonian; def _pyRHSc(t, psi, config):; h_func_data = - 1.0j * config.h_funcs(t, config.h_func_args); h_func_term = spmv(h_func_data, psi); const_col_term = 0; if len(config.c_const_inds) > 0:; const_col_term = spmv_csr(config.h_data, config.h_ind,; config.h_ptr, psi). return h_func_term + const_col_term. def _pyRHSc_with_state(t, psi, config):; h_func_data = - 1.0j * config.h_funcs(t, psi, config.h_func_args); h_func_term = spmv(h_func_data, psi); const_col_term = 0; if len(confi",MatchSource.WIKI,docs/4.2/modules/qutip/mcsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html
https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:15139,Modifiability,config,config,15139,"ata,; config.h_ind, config.h_ptr); col = np.array([np.abs(config.c_funcs[j](t, config.c_func_args)) ** 2 *; spmv_csr(config.n_ops_data[j],; config.n_ops_ind[j],; config.n_ops_ptr[j], psi); for j in config.c_td_inds]); return sys - 0.5 * np.sum(col, 0). # RHS of ODE for list-function based Hamiltonian; def _tdRHStd(t, psi, config):; const_term = spmv_csr(config.h_data,; config.h_ind,; config.h_ptr, psi); h_func_term = np.array([config.h_funcs[j](t, config.h_func_args) *; spmv_csr(config.h_td_data[j],; config.h_td_ind[j],; config.h_td_ptr[j], psi); for j in config.h_td_inds]); col_func_terms = np.array([np.abs(; config.c_funcs[j](t, config.c_func_args)) ** 2 *; spmv_csr(config.n_ops_data[j],; config.n_ops_ind[j],; config.n_ops_ptr[j],; psi); for j in config.c_td_inds]); return (const_term + np.sum(h_func_term, 0); - 0.5 * np.sum(col_func_terms, 0)). def _tdRHStd_with_state(t, psi, config):. const_term = spmv_csr(config.h_data,; config.h_ind,; config.h_ptr, psi). h_func_term = np.array([; config.h_funcs[j](t, psi, config.h_func_args) *; spmv_csr(config.h_td_data[j],; config.h_td_ind[j],; config.h_td_ptr[j], psi); for j in config.h_td_inds]). col_func_terms = np.array([; np.abs(config.c_funcs[j](t, config.c_func_args)) ** 2 *; spmv_csr(config.n_ops_data[j],; config.n_ops_ind[j],; config.n_ops_ptr[j], psi); for j in config.c_td_inds]). return (const_term + np.sum(h_func_term, 0); - 0.5 * np.sum(col_func_terms, 0)). # RHS of ODE for python function Hamiltonian; def _pyRHSc(t, psi, config):; h_func_data = - 1.0j * config.h_funcs(t, config.h_func_args); h_func_term = spmv(h_func_data, psi); const_col_term = 0; if len(config.c_const_inds) > 0:; const_col_term = spmv_csr(config.h_data, config.h_ind,; config.h_ptr, psi). return h_func_term + const_col_term. def _pyRHSc_with_state(t, psi, config):; h_func_data = - 1.0j * config.h_funcs(t, psi, config.h_func_args); h_func_term = spmv(h_func_data, psi); const_col_term = 0; if len(config.c_const_inds) > 0:; const_col_term = spmv_c",MatchSource.WIKI,docs/4.2/modules/qutip/mcsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html
https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:15165,Modifiability,config,config,15165,"onfig.h_ptr); col = np.array([np.abs(config.c_funcs[j](t, config.c_func_args)) ** 2 *; spmv_csr(config.n_ops_data[j],; config.n_ops_ind[j],; config.n_ops_ptr[j], psi); for j in config.c_td_inds]); return sys - 0.5 * np.sum(col, 0). # RHS of ODE for list-function based Hamiltonian; def _tdRHStd(t, psi, config):; const_term = spmv_csr(config.h_data,; config.h_ind,; config.h_ptr, psi); h_func_term = np.array([config.h_funcs[j](t, config.h_func_args) *; spmv_csr(config.h_td_data[j],; config.h_td_ind[j],; config.h_td_ptr[j], psi); for j in config.h_td_inds]); col_func_terms = np.array([np.abs(; config.c_funcs[j](t, config.c_func_args)) ** 2 *; spmv_csr(config.n_ops_data[j],; config.n_ops_ind[j],; config.n_ops_ptr[j],; psi); for j in config.c_td_inds]); return (const_term + np.sum(h_func_term, 0); - 0.5 * np.sum(col_func_terms, 0)). def _tdRHStd_with_state(t, psi, config):. const_term = spmv_csr(config.h_data,; config.h_ind,; config.h_ptr, psi). h_func_term = np.array([; config.h_funcs[j](t, psi, config.h_func_args) *; spmv_csr(config.h_td_data[j],; config.h_td_ind[j],; config.h_td_ptr[j], psi); for j in config.h_td_inds]). col_func_terms = np.array([; np.abs(config.c_funcs[j](t, config.c_func_args)) ** 2 *; spmv_csr(config.n_ops_data[j],; config.n_ops_ind[j],; config.n_ops_ptr[j], psi); for j in config.c_td_inds]). return (const_term + np.sum(h_func_term, 0); - 0.5 * np.sum(col_func_terms, 0)). # RHS of ODE for python function Hamiltonian; def _pyRHSc(t, psi, config):; h_func_data = - 1.0j * config.h_funcs(t, config.h_func_args); h_func_term = spmv(h_func_data, psi); const_col_term = 0; if len(config.c_const_inds) > 0:; const_col_term = spmv_csr(config.h_data, config.h_ind,; config.h_ptr, psi). return h_func_term + const_col_term. def _pyRHSc_with_state(t, psi, config):; h_func_data = - 1.0j * config.h_funcs(t, psi, config.h_func_args); h_func_term = spmv(h_func_data, psi); const_col_term = 0; if len(config.c_const_inds) > 0:; const_col_term = spmv_csr(config.h_data, con",MatchSource.WIKI,docs/4.2/modules/qutip/mcsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html
https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:15197,Modifiability,config,config,15197,"[np.abs(config.c_funcs[j](t, config.c_func_args)) ** 2 *; spmv_csr(config.n_ops_data[j],; config.n_ops_ind[j],; config.n_ops_ptr[j], psi); for j in config.c_td_inds]); return sys - 0.5 * np.sum(col, 0). # RHS of ODE for list-function based Hamiltonian; def _tdRHStd(t, psi, config):; const_term = spmv_csr(config.h_data,; config.h_ind,; config.h_ptr, psi); h_func_term = np.array([config.h_funcs[j](t, config.h_func_args) *; spmv_csr(config.h_td_data[j],; config.h_td_ind[j],; config.h_td_ptr[j], psi); for j in config.h_td_inds]); col_func_terms = np.array([np.abs(; config.c_funcs[j](t, config.c_func_args)) ** 2 *; spmv_csr(config.n_ops_data[j],; config.n_ops_ind[j],; config.n_ops_ptr[j],; psi); for j in config.c_td_inds]); return (const_term + np.sum(h_func_term, 0); - 0.5 * np.sum(col_func_terms, 0)). def _tdRHStd_with_state(t, psi, config):. const_term = spmv_csr(config.h_data,; config.h_ind,; config.h_ptr, psi). h_func_term = np.array([; config.h_funcs[j](t, psi, config.h_func_args) *; spmv_csr(config.h_td_data[j],; config.h_td_ind[j],; config.h_td_ptr[j], psi); for j in config.h_td_inds]). col_func_terms = np.array([; np.abs(config.c_funcs[j](t, config.c_func_args)) ** 2 *; spmv_csr(config.n_ops_data[j],; config.n_ops_ind[j],; config.n_ops_ptr[j], psi); for j in config.c_td_inds]). return (const_term + np.sum(h_func_term, 0); - 0.5 * np.sum(col_func_terms, 0)). # RHS of ODE for python function Hamiltonian; def _pyRHSc(t, psi, config):; h_func_data = - 1.0j * config.h_funcs(t, config.h_func_args); h_func_term = spmv(h_func_data, psi); const_col_term = 0; if len(config.c_const_inds) > 0:; const_col_term = spmv_csr(config.h_data, config.h_ind,; config.h_ptr, psi). return h_func_term + const_col_term. def _pyRHSc_with_state(t, psi, config):; h_func_data = - 1.0j * config.h_funcs(t, psi, config.h_func_args); h_func_term = spmv(h_func_data, psi); const_col_term = 0; if len(config.c_const_inds) > 0:; const_col_term = spmv_csr(config.h_data, config.h_ind,; config.h_ptr, psi",MatchSource.WIKI,docs/4.2/modules/qutip/mcsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html
https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:15219,Modifiability,config,config,15219,", config.c_func_args)) ** 2 *; spmv_csr(config.n_ops_data[j],; config.n_ops_ind[j],; config.n_ops_ptr[j], psi); for j in config.c_td_inds]); return sys - 0.5 * np.sum(col, 0). # RHS of ODE for list-function based Hamiltonian; def _tdRHStd(t, psi, config):; const_term = spmv_csr(config.h_data,; config.h_ind,; config.h_ptr, psi); h_func_term = np.array([config.h_funcs[j](t, config.h_func_args) *; spmv_csr(config.h_td_data[j],; config.h_td_ind[j],; config.h_td_ptr[j], psi); for j in config.h_td_inds]); col_func_terms = np.array([np.abs(; config.c_funcs[j](t, config.c_func_args)) ** 2 *; spmv_csr(config.n_ops_data[j],; config.n_ops_ind[j],; config.n_ops_ptr[j],; psi); for j in config.c_td_inds]); return (const_term + np.sum(h_func_term, 0); - 0.5 * np.sum(col_func_terms, 0)). def _tdRHStd_with_state(t, psi, config):. const_term = spmv_csr(config.h_data,; config.h_ind,; config.h_ptr, psi). h_func_term = np.array([; config.h_funcs[j](t, psi, config.h_func_args) *; spmv_csr(config.h_td_data[j],; config.h_td_ind[j],; config.h_td_ptr[j], psi); for j in config.h_td_inds]). col_func_terms = np.array([; np.abs(config.c_funcs[j](t, config.c_func_args)) ** 2 *; spmv_csr(config.n_ops_data[j],; config.n_ops_ind[j],; config.n_ops_ptr[j], psi); for j in config.c_td_inds]). return (const_term + np.sum(h_func_term, 0); - 0.5 * np.sum(col_func_terms, 0)). # RHS of ODE for python function Hamiltonian; def _pyRHSc(t, psi, config):; h_func_data = - 1.0j * config.h_funcs(t, config.h_func_args); h_func_term = spmv(h_func_data, psi); const_col_term = 0; if len(config.c_const_inds) > 0:; const_col_term = spmv_csr(config.h_data, config.h_ind,; config.h_ptr, psi). return h_func_term + const_col_term. def _pyRHSc_with_state(t, psi, config):; h_func_data = - 1.0j * config.h_funcs(t, psi, config.h_func_args); h_func_term = spmv(h_func_data, psi); const_col_term = 0; if len(config.c_const_inds) > 0:; const_col_term = spmv_csr(config.h_data, config.h_ind,; config.h_ptr, psi). return h_func_term + con",MatchSource.WIKI,docs/4.2/modules/qutip/mcsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html
https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:15240,Modifiability,config,config,15240,") ** 2 *; spmv_csr(config.n_ops_data[j],; config.n_ops_ind[j],; config.n_ops_ptr[j], psi); for j in config.c_td_inds]); return sys - 0.5 * np.sum(col, 0). # RHS of ODE for list-function based Hamiltonian; def _tdRHStd(t, psi, config):; const_term = spmv_csr(config.h_data,; config.h_ind,; config.h_ptr, psi); h_func_term = np.array([config.h_funcs[j](t, config.h_func_args) *; spmv_csr(config.h_td_data[j],; config.h_td_ind[j],; config.h_td_ptr[j], psi); for j in config.h_td_inds]); col_func_terms = np.array([np.abs(; config.c_funcs[j](t, config.c_func_args)) ** 2 *; spmv_csr(config.n_ops_data[j],; config.n_ops_ind[j],; config.n_ops_ptr[j],; psi); for j in config.c_td_inds]); return (const_term + np.sum(h_func_term, 0); - 0.5 * np.sum(col_func_terms, 0)). def _tdRHStd_with_state(t, psi, config):. const_term = spmv_csr(config.h_data,; config.h_ind,; config.h_ptr, psi). h_func_term = np.array([; config.h_funcs[j](t, psi, config.h_func_args) *; spmv_csr(config.h_td_data[j],; config.h_td_ind[j],; config.h_td_ptr[j], psi); for j in config.h_td_inds]). col_func_terms = np.array([; np.abs(config.c_funcs[j](t, config.c_func_args)) ** 2 *; spmv_csr(config.n_ops_data[j],; config.n_ops_ind[j],; config.n_ops_ptr[j], psi); for j in config.c_td_inds]). return (const_term + np.sum(h_func_term, 0); - 0.5 * np.sum(col_func_terms, 0)). # RHS of ODE for python function Hamiltonian; def _pyRHSc(t, psi, config):; h_func_data = - 1.0j * config.h_funcs(t, config.h_func_args); h_func_term = spmv(h_func_data, psi); const_col_term = 0; if len(config.c_const_inds) > 0:; const_col_term = spmv_csr(config.h_data, config.h_ind,; config.h_ptr, psi). return h_func_term + const_col_term. def _pyRHSc_with_state(t, psi, config):; h_func_data = - 1.0j * config.h_funcs(t, psi, config.h_func_args); h_func_term = spmv(h_func_data, psi); const_col_term = 0; if len(config.c_const_inds) > 0:; const_col_term = spmv_csr(config.h_data, config.h_ind,; config.h_ptr, psi). return h_func_term + const_col_term. # -------",MatchSource.WIKI,docs/4.2/modules/qutip/mcsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html
https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:15275,Modifiability,config,config,15275,"ops_data[j],; config.n_ops_ind[j],; config.n_ops_ptr[j], psi); for j in config.c_td_inds]); return sys - 0.5 * np.sum(col, 0). # RHS of ODE for list-function based Hamiltonian; def _tdRHStd(t, psi, config):; const_term = spmv_csr(config.h_data,; config.h_ind,; config.h_ptr, psi); h_func_term = np.array([config.h_funcs[j](t, config.h_func_args) *; spmv_csr(config.h_td_data[j],; config.h_td_ind[j],; config.h_td_ptr[j], psi); for j in config.h_td_inds]); col_func_terms = np.array([np.abs(; config.c_funcs[j](t, config.c_func_args)) ** 2 *; spmv_csr(config.n_ops_data[j],; config.n_ops_ind[j],; config.n_ops_ptr[j],; psi); for j in config.c_td_inds]); return (const_term + np.sum(h_func_term, 0); - 0.5 * np.sum(col_func_terms, 0)). def _tdRHStd_with_state(t, psi, config):. const_term = spmv_csr(config.h_data,; config.h_ind,; config.h_ptr, psi). h_func_term = np.array([; config.h_funcs[j](t, psi, config.h_func_args) *; spmv_csr(config.h_td_data[j],; config.h_td_ind[j],; config.h_td_ptr[j], psi); for j in config.h_td_inds]). col_func_terms = np.array([; np.abs(config.c_funcs[j](t, config.c_func_args)) ** 2 *; spmv_csr(config.n_ops_data[j],; config.n_ops_ind[j],; config.n_ops_ptr[j], psi); for j in config.c_td_inds]). return (const_term + np.sum(h_func_term, 0); - 0.5 * np.sum(col_func_terms, 0)). # RHS of ODE for python function Hamiltonian; def _pyRHSc(t, psi, config):; h_func_data = - 1.0j * config.h_funcs(t, config.h_func_args); h_func_term = spmv(h_func_data, psi); const_col_term = 0; if len(config.c_const_inds) > 0:; const_col_term = spmv_csr(config.h_data, config.h_ind,; config.h_ptr, psi). return h_func_term + const_col_term. def _pyRHSc_with_state(t, psi, config):; h_func_data = - 1.0j * config.h_funcs(t, psi, config.h_func_args); h_func_term = spmv(h_func_data, psi); const_col_term = 0; if len(config.c_const_inds) > 0:; const_col_term = spmv_csr(config.h_data, config.h_ind,; config.h_ptr, psi). return h_func_term + const_col_term. # -----------------------------------",MatchSource.WIKI,docs/4.2/modules/qutip/mcsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html
https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:15331,Modifiability,config,config,15331," in config.c_td_inds]); return sys - 0.5 * np.sum(col, 0). # RHS of ODE for list-function based Hamiltonian; def _tdRHStd(t, psi, config):; const_term = spmv_csr(config.h_data,; config.h_ind,; config.h_ptr, psi); h_func_term = np.array([config.h_funcs[j](t, config.h_func_args) *; spmv_csr(config.h_td_data[j],; config.h_td_ind[j],; config.h_td_ptr[j], psi); for j in config.h_td_inds]); col_func_terms = np.array([np.abs(; config.c_funcs[j](t, config.c_func_args)) ** 2 *; spmv_csr(config.n_ops_data[j],; config.n_ops_ind[j],; config.n_ops_ptr[j],; psi); for j in config.c_td_inds]); return (const_term + np.sum(h_func_term, 0); - 0.5 * np.sum(col_func_terms, 0)). def _tdRHStd_with_state(t, psi, config):. const_term = spmv_csr(config.h_data,; config.h_ind,; config.h_ptr, psi). h_func_term = np.array([; config.h_funcs[j](t, psi, config.h_func_args) *; spmv_csr(config.h_td_data[j],; config.h_td_ind[j],; config.h_td_ptr[j], psi); for j in config.h_td_inds]). col_func_terms = np.array([; np.abs(config.c_funcs[j](t, config.c_func_args)) ** 2 *; spmv_csr(config.n_ops_data[j],; config.n_ops_ind[j],; config.n_ops_ptr[j], psi); for j in config.c_td_inds]). return (const_term + np.sum(h_func_term, 0); - 0.5 * np.sum(col_func_terms, 0)). # RHS of ODE for python function Hamiltonian; def _pyRHSc(t, psi, config):; h_func_data = - 1.0j * config.h_funcs(t, config.h_func_args); h_func_term = spmv(h_func_data, psi); const_col_term = 0; if len(config.c_const_inds) > 0:; const_col_term = spmv_csr(config.h_data, config.h_ind,; config.h_ptr, psi). return h_func_term + const_col_term. def _pyRHSc_with_state(t, psi, config):; h_func_data = - 1.0j * config.h_funcs(t, psi, config.h_func_args); h_func_term = spmv(h_func_data, psi); const_col_term = 0; if len(config.c_const_inds) > 0:; const_col_term = spmv_csr(config.h_data, config.h_ind,; config.h_ptr, psi). return h_func_term + const_col_term. # -----------------------------------------------------------------------------; # evolution solver: retu",MatchSource.WIKI,docs/4.2/modules/qutip/mcsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html
https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:15352,Modifiability,config,config,15352,"inds]); return sys - 0.5 * np.sum(col, 0). # RHS of ODE for list-function based Hamiltonian; def _tdRHStd(t, psi, config):; const_term = spmv_csr(config.h_data,; config.h_ind,; config.h_ptr, psi); h_func_term = np.array([config.h_funcs[j](t, config.h_func_args) *; spmv_csr(config.h_td_data[j],; config.h_td_ind[j],; config.h_td_ptr[j], psi); for j in config.h_td_inds]); col_func_terms = np.array([np.abs(; config.c_funcs[j](t, config.c_func_args)) ** 2 *; spmv_csr(config.n_ops_data[j],; config.n_ops_ind[j],; config.n_ops_ptr[j],; psi); for j in config.c_td_inds]); return (const_term + np.sum(h_func_term, 0); - 0.5 * np.sum(col_func_terms, 0)). def _tdRHStd_with_state(t, psi, config):. const_term = spmv_csr(config.h_data,; config.h_ind,; config.h_ptr, psi). h_func_term = np.array([; config.h_funcs[j](t, psi, config.h_func_args) *; spmv_csr(config.h_td_data[j],; config.h_td_ind[j],; config.h_td_ptr[j], psi); for j in config.h_td_inds]). col_func_terms = np.array([; np.abs(config.c_funcs[j](t, config.c_func_args)) ** 2 *; spmv_csr(config.n_ops_data[j],; config.n_ops_ind[j],; config.n_ops_ptr[j], psi); for j in config.c_td_inds]). return (const_term + np.sum(h_func_term, 0); - 0.5 * np.sum(col_func_terms, 0)). # RHS of ODE for python function Hamiltonian; def _pyRHSc(t, psi, config):; h_func_data = - 1.0j * config.h_funcs(t, config.h_func_args); h_func_term = spmv(h_func_data, psi); const_col_term = 0; if len(config.c_const_inds) > 0:; const_col_term = spmv_csr(config.h_data, config.h_ind,; config.h_ptr, psi). return h_func_term + const_col_term. def _pyRHSc_with_state(t, psi, config):; h_func_data = - 1.0j * config.h_funcs(t, psi, config.h_func_args); h_func_term = spmv(h_func_data, psi); const_col_term = 0; if len(config.c_const_inds) > 0:; const_col_term = spmv_csr(config.h_data, config.h_ind,; config.h_ptr, psi). return h_func_term + const_col_term. # -----------------------------------------------------------------------------; # evolution solver: return psi at reques",MatchSource.WIKI,docs/4.2/modules/qutip/mcsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html
https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:15390,Modifiability,config,config,15390,"sum(col, 0). # RHS of ODE for list-function based Hamiltonian; def _tdRHStd(t, psi, config):; const_term = spmv_csr(config.h_data,; config.h_ind,; config.h_ptr, psi); h_func_term = np.array([config.h_funcs[j](t, config.h_func_args) *; spmv_csr(config.h_td_data[j],; config.h_td_ind[j],; config.h_td_ptr[j], psi); for j in config.h_td_inds]); col_func_terms = np.array([np.abs(; config.c_funcs[j](t, config.c_func_args)) ** 2 *; spmv_csr(config.n_ops_data[j],; config.n_ops_ind[j],; config.n_ops_ptr[j],; psi); for j in config.c_td_inds]); return (const_term + np.sum(h_func_term, 0); - 0.5 * np.sum(col_func_terms, 0)). def _tdRHStd_with_state(t, psi, config):. const_term = spmv_csr(config.h_data,; config.h_ind,; config.h_ptr, psi). h_func_term = np.array([; config.h_funcs[j](t, psi, config.h_func_args) *; spmv_csr(config.h_td_data[j],; config.h_td_ind[j],; config.h_td_ptr[j], psi); for j in config.h_td_inds]). col_func_terms = np.array([; np.abs(config.c_funcs[j](t, config.c_func_args)) ** 2 *; spmv_csr(config.n_ops_data[j],; config.n_ops_ind[j],; config.n_ops_ptr[j], psi); for j in config.c_td_inds]). return (const_term + np.sum(h_func_term, 0); - 0.5 * np.sum(col_func_terms, 0)). # RHS of ODE for python function Hamiltonian; def _pyRHSc(t, psi, config):; h_func_data = - 1.0j * config.h_funcs(t, config.h_func_args); h_func_term = spmv(h_func_data, psi); const_col_term = 0; if len(config.c_const_inds) > 0:; const_col_term = spmv_csr(config.h_data, config.h_ind,; config.h_ptr, psi). return h_func_term + const_col_term. def _pyRHSc_with_state(t, psi, config):; h_func_data = - 1.0j * config.h_funcs(t, psi, config.h_func_args); h_func_term = spmv(h_func_data, psi); const_col_term = 0; if len(config.c_const_inds) > 0:; const_col_term = spmv_csr(config.h_data, config.h_ind,; config.h_ptr, psi). return h_func_term + const_col_term. # -----------------------------------------------------------------------------; # evolution solver: return psi at requested times for no collapse ope",MatchSource.WIKI,docs/4.2/modules/qutip/mcsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html
https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:15413,Modifiability,config,config,15413,"list-function based Hamiltonian; def _tdRHStd(t, psi, config):; const_term = spmv_csr(config.h_data,; config.h_ind,; config.h_ptr, psi); h_func_term = np.array([config.h_funcs[j](t, config.h_func_args) *; spmv_csr(config.h_td_data[j],; config.h_td_ind[j],; config.h_td_ptr[j], psi); for j in config.h_td_inds]); col_func_terms = np.array([np.abs(; config.c_funcs[j](t, config.c_func_args)) ** 2 *; spmv_csr(config.n_ops_data[j],; config.n_ops_ind[j],; config.n_ops_ptr[j],; psi); for j in config.c_td_inds]); return (const_term + np.sum(h_func_term, 0); - 0.5 * np.sum(col_func_terms, 0)). def _tdRHStd_with_state(t, psi, config):. const_term = spmv_csr(config.h_data,; config.h_ind,; config.h_ptr, psi). h_func_term = np.array([; config.h_funcs[j](t, psi, config.h_func_args) *; spmv_csr(config.h_td_data[j],; config.h_td_ind[j],; config.h_td_ptr[j], psi); for j in config.h_td_inds]). col_func_terms = np.array([; np.abs(config.c_funcs[j](t, config.c_func_args)) ** 2 *; spmv_csr(config.n_ops_data[j],; config.n_ops_ind[j],; config.n_ops_ptr[j], psi); for j in config.c_td_inds]). return (const_term + np.sum(h_func_term, 0); - 0.5 * np.sum(col_func_terms, 0)). # RHS of ODE for python function Hamiltonian; def _pyRHSc(t, psi, config):; h_func_data = - 1.0j * config.h_funcs(t, config.h_func_args); h_func_term = spmv(h_func_data, psi); const_col_term = 0; if len(config.c_const_inds) > 0:; const_col_term = spmv_csr(config.h_data, config.h_ind,; config.h_ptr, psi). return h_func_term + const_col_term. def _pyRHSc_with_state(t, psi, config):; h_func_data = - 1.0j * config.h_funcs(t, psi, config.h_func_args); h_func_term = spmv(h_func_data, psi); const_col_term = 0; if len(config.c_const_inds) > 0:; const_col_term = spmv_csr(config.h_data, config.h_ind,; config.h_ptr, psi). return h_func_term + const_col_term. # -----------------------------------------------------------------------------; # evolution solver: return psi at requested times for no collapse operators; # ---------------------",MatchSource.WIKI,docs/4.2/modules/qutip/mcsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html
https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:15435,Modifiability,config,config,15435,"iltonian; def _tdRHStd(t, psi, config):; const_term = spmv_csr(config.h_data,; config.h_ind,; config.h_ptr, psi); h_func_term = np.array([config.h_funcs[j](t, config.h_func_args) *; spmv_csr(config.h_td_data[j],; config.h_td_ind[j],; config.h_td_ptr[j], psi); for j in config.h_td_inds]); col_func_terms = np.array([np.abs(; config.c_funcs[j](t, config.c_func_args)) ** 2 *; spmv_csr(config.n_ops_data[j],; config.n_ops_ind[j],; config.n_ops_ptr[j],; psi); for j in config.c_td_inds]); return (const_term + np.sum(h_func_term, 0); - 0.5 * np.sum(col_func_terms, 0)). def _tdRHStd_with_state(t, psi, config):. const_term = spmv_csr(config.h_data,; config.h_ind,; config.h_ptr, psi). h_func_term = np.array([; config.h_funcs[j](t, psi, config.h_func_args) *; spmv_csr(config.h_td_data[j],; config.h_td_ind[j],; config.h_td_ptr[j], psi); for j in config.h_td_inds]). col_func_terms = np.array([; np.abs(config.c_funcs[j](t, config.c_func_args)) ** 2 *; spmv_csr(config.n_ops_data[j],; config.n_ops_ind[j],; config.n_ops_ptr[j], psi); for j in config.c_td_inds]). return (const_term + np.sum(h_func_term, 0); - 0.5 * np.sum(col_func_terms, 0)). # RHS of ODE for python function Hamiltonian; def _pyRHSc(t, psi, config):; h_func_data = - 1.0j * config.h_funcs(t, config.h_func_args); h_func_term = spmv(h_func_data, psi); const_col_term = 0; if len(config.c_const_inds) > 0:; const_col_term = spmv_csr(config.h_data, config.h_ind,; config.h_ptr, psi). return h_func_term + const_col_term. def _pyRHSc_with_state(t, psi, config):; h_func_data = - 1.0j * config.h_funcs(t, psi, config.h_func_args); h_func_term = spmv(h_func_data, psi); const_col_term = 0; if len(config.c_const_inds) > 0:; const_col_term = spmv_csr(config.h_data, config.h_ind,; config.h_ptr, psi). return h_func_term + const_col_term. # -----------------------------------------------------------------------------; # evolution solver: return psi at requested times for no collapse operators; # -------------------------------------------",MatchSource.WIKI,docs/4.2/modules/qutip/mcsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html
https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:15471,Modifiability,config,config,15471,", config):; const_term = spmv_csr(config.h_data,; config.h_ind,; config.h_ptr, psi); h_func_term = np.array([config.h_funcs[j](t, config.h_func_args) *; spmv_csr(config.h_td_data[j],; config.h_td_ind[j],; config.h_td_ptr[j], psi); for j in config.h_td_inds]); col_func_terms = np.array([np.abs(; config.c_funcs[j](t, config.c_func_args)) ** 2 *; spmv_csr(config.n_ops_data[j],; config.n_ops_ind[j],; config.n_ops_ptr[j],; psi); for j in config.c_td_inds]); return (const_term + np.sum(h_func_term, 0); - 0.5 * np.sum(col_func_terms, 0)). def _tdRHStd_with_state(t, psi, config):. const_term = spmv_csr(config.h_data,; config.h_ind,; config.h_ptr, psi). h_func_term = np.array([; config.h_funcs[j](t, psi, config.h_func_args) *; spmv_csr(config.h_td_data[j],; config.h_td_ind[j],; config.h_td_ptr[j], psi); for j in config.h_td_inds]). col_func_terms = np.array([; np.abs(config.c_funcs[j](t, config.c_func_args)) ** 2 *; spmv_csr(config.n_ops_data[j],; config.n_ops_ind[j],; config.n_ops_ptr[j], psi); for j in config.c_td_inds]). return (const_term + np.sum(h_func_term, 0); - 0.5 * np.sum(col_func_terms, 0)). # RHS of ODE for python function Hamiltonian; def _pyRHSc(t, psi, config):; h_func_data = - 1.0j * config.h_funcs(t, config.h_func_args); h_func_term = spmv(h_func_data, psi); const_col_term = 0; if len(config.c_const_inds) > 0:; const_col_term = spmv_csr(config.h_data, config.h_ind,; config.h_ptr, psi). return h_func_term + const_col_term. def _pyRHSc_with_state(t, psi, config):; h_func_data = - 1.0j * config.h_funcs(t, psi, config.h_func_args); h_func_term = spmv(h_func_data, psi); const_col_term = 0; if len(config.c_const_inds) > 0:; const_col_term = spmv_csr(config.h_data, config.h_ind,; config.h_ptr, psi). return h_func_term + const_col_term. # -----------------------------------------------------------------------------; # evolution solver: return psi at requested times for no collapse operators; # ------------------------------------------------------------------------",MatchSource.WIKI,docs/4.2/modules/qutip/mcsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html
https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:15638,Modifiability,config,config,15638,"csr(config.h_td_data[j],; config.h_td_ind[j],; config.h_td_ptr[j], psi); for j in config.h_td_inds]); col_func_terms = np.array([np.abs(; config.c_funcs[j](t, config.c_func_args)) ** 2 *; spmv_csr(config.n_ops_data[j],; config.n_ops_ind[j],; config.n_ops_ptr[j],; psi); for j in config.c_td_inds]); return (const_term + np.sum(h_func_term, 0); - 0.5 * np.sum(col_func_terms, 0)). def _tdRHStd_with_state(t, psi, config):. const_term = spmv_csr(config.h_data,; config.h_ind,; config.h_ptr, psi). h_func_term = np.array([; config.h_funcs[j](t, psi, config.h_func_args) *; spmv_csr(config.h_td_data[j],; config.h_td_ind[j],; config.h_td_ptr[j], psi); for j in config.h_td_inds]). col_func_terms = np.array([; np.abs(config.c_funcs[j](t, config.c_func_args)) ** 2 *; spmv_csr(config.n_ops_data[j],; config.n_ops_ind[j],; config.n_ops_ptr[j], psi); for j in config.c_td_inds]). return (const_term + np.sum(h_func_term, 0); - 0.5 * np.sum(col_func_terms, 0)). # RHS of ODE for python function Hamiltonian; def _pyRHSc(t, psi, config):; h_func_data = - 1.0j * config.h_funcs(t, config.h_func_args); h_func_term = spmv(h_func_data, psi); const_col_term = 0; if len(config.c_const_inds) > 0:; const_col_term = spmv_csr(config.h_data, config.h_ind,; config.h_ptr, psi). return h_func_term + const_col_term. def _pyRHSc_with_state(t, psi, config):; h_func_data = - 1.0j * config.h_funcs(t, psi, config.h_func_args); h_func_term = spmv(h_func_data, psi); const_col_term = 0; if len(config.c_const_inds) > 0:; const_col_term = spmv_csr(config.h_data, config.h_ind,; config.h_ptr, psi). return h_func_term + const_col_term. # -----------------------------------------------------------------------------; # evolution solver: return psi at requested times for no collapse operators; # -----------------------------------------------------------------------------; def _evolve_no_collapse_psi_out(config):; """"""; Calculates state vectors at times tlist if no collapse AND no; expectation values are given.; """""". global",MatchSource.WIKI,docs/4.2/modules/qutip/mcsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html
https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:15671,Modifiability,config,config,15671,"h_td_ptr[j], psi); for j in config.h_td_inds]); col_func_terms = np.array([np.abs(; config.c_funcs[j](t, config.c_func_args)) ** 2 *; spmv_csr(config.n_ops_data[j],; config.n_ops_ind[j],; config.n_ops_ptr[j],; psi); for j in config.c_td_inds]); return (const_term + np.sum(h_func_term, 0); - 0.5 * np.sum(col_func_terms, 0)). def _tdRHStd_with_state(t, psi, config):. const_term = spmv_csr(config.h_data,; config.h_ind,; config.h_ptr, psi). h_func_term = np.array([; config.h_funcs[j](t, psi, config.h_func_args) *; spmv_csr(config.h_td_data[j],; config.h_td_ind[j],; config.h_td_ptr[j], psi); for j in config.h_td_inds]). col_func_terms = np.array([; np.abs(config.c_funcs[j](t, config.c_func_args)) ** 2 *; spmv_csr(config.n_ops_data[j],; config.n_ops_ind[j],; config.n_ops_ptr[j], psi); for j in config.c_td_inds]). return (const_term + np.sum(h_func_term, 0); - 0.5 * np.sum(col_func_terms, 0)). # RHS of ODE for python function Hamiltonian; def _pyRHSc(t, psi, config):; h_func_data = - 1.0j * config.h_funcs(t, config.h_func_args); h_func_term = spmv(h_func_data, psi); const_col_term = 0; if len(config.c_const_inds) > 0:; const_col_term = spmv_csr(config.h_data, config.h_ind,; config.h_ptr, psi). return h_func_term + const_col_term. def _pyRHSc_with_state(t, psi, config):; h_func_data = - 1.0j * config.h_funcs(t, psi, config.h_func_args); h_func_term = spmv(h_func_data, psi); const_col_term = 0; if len(config.c_const_inds) > 0:; const_col_term = spmv_csr(config.h_data, config.h_ind,; config.h_ptr, psi). return h_func_term + const_col_term. # -----------------------------------------------------------------------------; # evolution solver: return psi at requested times for no collapse operators; # -----------------------------------------------------------------------------; def _evolve_no_collapse_psi_out(config):; """"""; Calculates state vectors at times tlist if no collapse AND no; expectation values are given.; """""". global _cy_rhs_func; global _cy_col_spmv_func, _cy_col_expe",MatchSource.WIKI,docs/4.2/modules/qutip/mcsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html
https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:15689,Modifiability,config,config,15689,"i); for j in config.h_td_inds]); col_func_terms = np.array([np.abs(; config.c_funcs[j](t, config.c_func_args)) ** 2 *; spmv_csr(config.n_ops_data[j],; config.n_ops_ind[j],; config.n_ops_ptr[j],; psi); for j in config.c_td_inds]); return (const_term + np.sum(h_func_term, 0); - 0.5 * np.sum(col_func_terms, 0)). def _tdRHStd_with_state(t, psi, config):. const_term = spmv_csr(config.h_data,; config.h_ind,; config.h_ptr, psi). h_func_term = np.array([; config.h_funcs[j](t, psi, config.h_func_args) *; spmv_csr(config.h_td_data[j],; config.h_td_ind[j],; config.h_td_ptr[j], psi); for j in config.h_td_inds]). col_func_terms = np.array([; np.abs(config.c_funcs[j](t, config.c_func_args)) ** 2 *; spmv_csr(config.n_ops_data[j],; config.n_ops_ind[j],; config.n_ops_ptr[j], psi); for j in config.c_td_inds]). return (const_term + np.sum(h_func_term, 0); - 0.5 * np.sum(col_func_terms, 0)). # RHS of ODE for python function Hamiltonian; def _pyRHSc(t, psi, config):; h_func_data = - 1.0j * config.h_funcs(t, config.h_func_args); h_func_term = spmv(h_func_data, psi); const_col_term = 0; if len(config.c_const_inds) > 0:; const_col_term = spmv_csr(config.h_data, config.h_ind,; config.h_ptr, psi). return h_func_term + const_col_term. def _pyRHSc_with_state(t, psi, config):; h_func_data = - 1.0j * config.h_funcs(t, psi, config.h_func_args); h_func_term = spmv(h_func_data, psi); const_col_term = 0; if len(config.c_const_inds) > 0:; const_col_term = spmv_csr(config.h_data, config.h_ind,; config.h_ptr, psi). return h_func_term + const_col_term. # -----------------------------------------------------------------------------; # evolution solver: return psi at requested times for no collapse operators; # -----------------------------------------------------------------------------; def _evolve_no_collapse_psi_out(config):; """"""; Calculates state vectors at times tlist if no collapse AND no; expectation values are given.; """""". global _cy_rhs_func; global _cy_col_spmv_func, _cy_col_expect_func; global",MatchSource.WIKI,docs/4.2/modules/qutip/mcsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html
https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:15775,Modifiability,config,config,15775,".array([np.abs(; config.c_funcs[j](t, config.c_func_args)) ** 2 *; spmv_csr(config.n_ops_data[j],; config.n_ops_ind[j],; config.n_ops_ptr[j],; psi); for j in config.c_td_inds]); return (const_term + np.sum(h_func_term, 0); - 0.5 * np.sum(col_func_terms, 0)). def _tdRHStd_with_state(t, psi, config):. const_term = spmv_csr(config.h_data,; config.h_ind,; config.h_ptr, psi). h_func_term = np.array([; config.h_funcs[j](t, psi, config.h_func_args) *; spmv_csr(config.h_td_data[j],; config.h_td_ind[j],; config.h_td_ptr[j], psi); for j in config.h_td_inds]). col_func_terms = np.array([; np.abs(config.c_funcs[j](t, config.c_func_args)) ** 2 *; spmv_csr(config.n_ops_data[j],; config.n_ops_ind[j],; config.n_ops_ptr[j], psi); for j in config.c_td_inds]). return (const_term + np.sum(h_func_term, 0); - 0.5 * np.sum(col_func_terms, 0)). # RHS of ODE for python function Hamiltonian; def _pyRHSc(t, psi, config):; h_func_data = - 1.0j * config.h_funcs(t, config.h_func_args); h_func_term = spmv(h_func_data, psi); const_col_term = 0; if len(config.c_const_inds) > 0:; const_col_term = spmv_csr(config.h_data, config.h_ind,; config.h_ptr, psi). return h_func_term + const_col_term. def _pyRHSc_with_state(t, psi, config):; h_func_data = - 1.0j * config.h_funcs(t, psi, config.h_func_args); h_func_term = spmv(h_func_data, psi); const_col_term = 0; if len(config.c_const_inds) > 0:; const_col_term = spmv_csr(config.h_data, config.h_ind,; config.h_ptr, psi). return h_func_term + const_col_term. # -----------------------------------------------------------------------------; # evolution solver: return psi at requested times for no collapse operators; # -----------------------------------------------------------------------------; def _evolve_no_collapse_psi_out(config):; """"""; Calculates state vectors at times tlist if no collapse AND no; expectation values are given.; """""". global _cy_rhs_func; global _cy_col_spmv_func, _cy_col_expect_func; global _cy_col_spmv_call_func, _cy_col_expect_call_func. n",MatchSource.WIKI,docs/4.2/modules/qutip/mcsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html
https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:15828,Modifiability,config,config,15828,"mv_csr(config.n_ops_data[j],; config.n_ops_ind[j],; config.n_ops_ptr[j],; psi); for j in config.c_td_inds]); return (const_term + np.sum(h_func_term, 0); - 0.5 * np.sum(col_func_terms, 0)). def _tdRHStd_with_state(t, psi, config):. const_term = spmv_csr(config.h_data,; config.h_ind,; config.h_ptr, psi). h_func_term = np.array([; config.h_funcs[j](t, psi, config.h_func_args) *; spmv_csr(config.h_td_data[j],; config.h_td_ind[j],; config.h_td_ptr[j], psi); for j in config.h_td_inds]). col_func_terms = np.array([; np.abs(config.c_funcs[j](t, config.c_func_args)) ** 2 *; spmv_csr(config.n_ops_data[j],; config.n_ops_ind[j],; config.n_ops_ptr[j], psi); for j in config.c_td_inds]). return (const_term + np.sum(h_func_term, 0); - 0.5 * np.sum(col_func_terms, 0)). # RHS of ODE for python function Hamiltonian; def _pyRHSc(t, psi, config):; h_func_data = - 1.0j * config.h_funcs(t, config.h_func_args); h_func_term = spmv(h_func_data, psi); const_col_term = 0; if len(config.c_const_inds) > 0:; const_col_term = spmv_csr(config.h_data, config.h_ind,; config.h_ptr, psi). return h_func_term + const_col_term. def _pyRHSc_with_state(t, psi, config):; h_func_data = - 1.0j * config.h_funcs(t, psi, config.h_func_args); h_func_term = spmv(h_func_data, psi); const_col_term = 0; if len(config.c_const_inds) > 0:; const_col_term = spmv_csr(config.h_data, config.h_ind,; config.h_ptr, psi). return h_func_term + const_col_term. # -----------------------------------------------------------------------------; # evolution solver: return psi at requested times for no collapse operators; # -----------------------------------------------------------------------------; def _evolve_no_collapse_psi_out(config):; """"""; Calculates state vectors at times tlist if no collapse AND no; expectation values are given.; """""". global _cy_rhs_func; global _cy_col_spmv_func, _cy_col_expect_func; global _cy_col_spmv_call_func, _cy_col_expect_call_func. num_times = len(config.tlist); psi_out = np.array([None] * num_times). ",MatchSource.WIKI,docs/4.2/modules/qutip/mcsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html
https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:15843,Modifiability,config,config,15843,"ig.n_ops_ind[j],; config.n_ops_ptr[j],; psi); for j in config.c_td_inds]); return (const_term + np.sum(h_func_term, 0); - 0.5 * np.sum(col_func_terms, 0)). def _tdRHStd_with_state(t, psi, config):. const_term = spmv_csr(config.h_data,; config.h_ind,; config.h_ptr, psi). h_func_term = np.array([; config.h_funcs[j](t, psi, config.h_func_args) *; spmv_csr(config.h_td_data[j],; config.h_td_ind[j],; config.h_td_ptr[j], psi); for j in config.h_td_inds]). col_func_terms = np.array([; np.abs(config.c_funcs[j](t, config.c_func_args)) ** 2 *; spmv_csr(config.n_ops_data[j],; config.n_ops_ind[j],; config.n_ops_ptr[j], psi); for j in config.c_td_inds]). return (const_term + np.sum(h_func_term, 0); - 0.5 * np.sum(col_func_terms, 0)). # RHS of ODE for python function Hamiltonian; def _pyRHSc(t, psi, config):; h_func_data = - 1.0j * config.h_funcs(t, config.h_func_args); h_func_term = spmv(h_func_data, psi); const_col_term = 0; if len(config.c_const_inds) > 0:; const_col_term = spmv_csr(config.h_data, config.h_ind,; config.h_ptr, psi). return h_func_term + const_col_term. def _pyRHSc_with_state(t, psi, config):; h_func_data = - 1.0j * config.h_funcs(t, psi, config.h_func_args); h_func_term = spmv(h_func_data, psi); const_col_term = 0; if len(config.c_const_inds) > 0:; const_col_term = spmv_csr(config.h_data, config.h_ind,; config.h_ptr, psi). return h_func_term + const_col_term. # -----------------------------------------------------------------------------; # evolution solver: return psi at requested times for no collapse operators; # -----------------------------------------------------------------------------; def _evolve_no_collapse_psi_out(config):; """"""; Calculates state vectors at times tlist if no collapse AND no; expectation values are given.; """""". global _cy_rhs_func; global _cy_col_spmv_func, _cy_col_expect_func; global _cy_col_spmv_call_func, _cy_col_expect_call_func. num_times = len(config.tlist); psi_out = np.array([None] * num_times). expect_out = []; for i in range(co",MatchSource.WIKI,docs/4.2/modules/qutip/mcsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html
https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:15858,Modifiability,config,config,15858,",; config.n_ops_ptr[j],; psi); for j in config.c_td_inds]); return (const_term + np.sum(h_func_term, 0); - 0.5 * np.sum(col_func_terms, 0)). def _tdRHStd_with_state(t, psi, config):. const_term = spmv_csr(config.h_data,; config.h_ind,; config.h_ptr, psi). h_func_term = np.array([; config.h_funcs[j](t, psi, config.h_func_args) *; spmv_csr(config.h_td_data[j],; config.h_td_ind[j],; config.h_td_ptr[j], psi); for j in config.h_td_inds]). col_func_terms = np.array([; np.abs(config.c_funcs[j](t, config.c_func_args)) ** 2 *; spmv_csr(config.n_ops_data[j],; config.n_ops_ind[j],; config.n_ops_ptr[j], psi); for j in config.c_td_inds]). return (const_term + np.sum(h_func_term, 0); - 0.5 * np.sum(col_func_terms, 0)). # RHS of ODE for python function Hamiltonian; def _pyRHSc(t, psi, config):; h_func_data = - 1.0j * config.h_funcs(t, config.h_func_args); h_func_term = spmv(h_func_data, psi); const_col_term = 0; if len(config.c_const_inds) > 0:; const_col_term = spmv_csr(config.h_data, config.h_ind,; config.h_ptr, psi). return h_func_term + const_col_term. def _pyRHSc_with_state(t, psi, config):; h_func_data = - 1.0j * config.h_funcs(t, psi, config.h_func_args); h_func_term = spmv(h_func_data, psi); const_col_term = 0; if len(config.c_const_inds) > 0:; const_col_term = spmv_csr(config.h_data, config.h_ind,; config.h_ptr, psi). return h_func_term + const_col_term. # -----------------------------------------------------------------------------; # evolution solver: return psi at requested times for no collapse operators; # -----------------------------------------------------------------------------; def _evolve_no_collapse_psi_out(config):; """"""; Calculates state vectors at times tlist if no collapse AND no; expectation values are given.; """""". global _cy_rhs_func; global _cy_col_spmv_func, _cy_col_expect_func; global _cy_col_spmv_call_func, _cy_col_expect_call_func. num_times = len(config.tlist); psi_out = np.array([None] * num_times). expect_out = []; for i in range(config.e_num):; i",MatchSource.WIKI,docs/4.2/modules/qutip/mcsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html
https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:15946,Modifiability,config,config,15946,"(h_func_term, 0); - 0.5 * np.sum(col_func_terms, 0)). def _tdRHStd_with_state(t, psi, config):. const_term = spmv_csr(config.h_data,; config.h_ind,; config.h_ptr, psi). h_func_term = np.array([; config.h_funcs[j](t, psi, config.h_func_args) *; spmv_csr(config.h_td_data[j],; config.h_td_ind[j],; config.h_td_ptr[j], psi); for j in config.h_td_inds]). col_func_terms = np.array([; np.abs(config.c_funcs[j](t, config.c_func_args)) ** 2 *; spmv_csr(config.n_ops_data[j],; config.n_ops_ind[j],; config.n_ops_ptr[j], psi); for j in config.c_td_inds]). return (const_term + np.sum(h_func_term, 0); - 0.5 * np.sum(col_func_terms, 0)). # RHS of ODE for python function Hamiltonian; def _pyRHSc(t, psi, config):; h_func_data = - 1.0j * config.h_funcs(t, config.h_func_args); h_func_term = spmv(h_func_data, psi); const_col_term = 0; if len(config.c_const_inds) > 0:; const_col_term = spmv_csr(config.h_data, config.h_ind,; config.h_ptr, psi). return h_func_term + const_col_term. def _pyRHSc_with_state(t, psi, config):; h_func_data = - 1.0j * config.h_funcs(t, psi, config.h_func_args); h_func_term = spmv(h_func_data, psi); const_col_term = 0; if len(config.c_const_inds) > 0:; const_col_term = spmv_csr(config.h_data, config.h_ind,; config.h_ptr, psi). return h_func_term + const_col_term. # -----------------------------------------------------------------------------; # evolution solver: return psi at requested times for no collapse operators; # -----------------------------------------------------------------------------; def _evolve_no_collapse_psi_out(config):; """"""; Calculates state vectors at times tlist if no collapse AND no; expectation values are given.; """""". global _cy_rhs_func; global _cy_col_spmv_func, _cy_col_expect_func; global _cy_col_spmv_call_func, _cy_col_expect_call_func. num_times = len(config.tlist); psi_out = np.array([None] * num_times). expect_out = []; for i in range(config.e_num):; if config.e_ops_isherm[i]:; # preallocate real array of zeros; expect_out.append(np.zer",MatchSource.WIKI,docs/4.2/modules/qutip/mcsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html
https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:15979,Modifiability,config,config,15979,"_func_terms, 0)). def _tdRHStd_with_state(t, psi, config):. const_term = spmv_csr(config.h_data,; config.h_ind,; config.h_ptr, psi). h_func_term = np.array([; config.h_funcs[j](t, psi, config.h_func_args) *; spmv_csr(config.h_td_data[j],; config.h_td_ind[j],; config.h_td_ptr[j], psi); for j in config.h_td_inds]). col_func_terms = np.array([; np.abs(config.c_funcs[j](t, config.c_func_args)) ** 2 *; spmv_csr(config.n_ops_data[j],; config.n_ops_ind[j],; config.n_ops_ptr[j], psi); for j in config.c_td_inds]). return (const_term + np.sum(h_func_term, 0); - 0.5 * np.sum(col_func_terms, 0)). # RHS of ODE for python function Hamiltonian; def _pyRHSc(t, psi, config):; h_func_data = - 1.0j * config.h_funcs(t, config.h_func_args); h_func_term = spmv(h_func_data, psi); const_col_term = 0; if len(config.c_const_inds) > 0:; const_col_term = spmv_csr(config.h_data, config.h_ind,; config.h_ptr, psi). return h_func_term + const_col_term. def _pyRHSc_with_state(t, psi, config):; h_func_data = - 1.0j * config.h_funcs(t, psi, config.h_func_args); h_func_term = spmv(h_func_data, psi); const_col_term = 0; if len(config.c_const_inds) > 0:; const_col_term = spmv_csr(config.h_data, config.h_ind,; config.h_ptr, psi). return h_func_term + const_col_term. # -----------------------------------------------------------------------------; # evolution solver: return psi at requested times for no collapse operators; # -----------------------------------------------------------------------------; def _evolve_no_collapse_psi_out(config):; """"""; Calculates state vectors at times tlist if no collapse AND no; expectation values are given.; """""". global _cy_rhs_func; global _cy_col_spmv_func, _cy_col_expect_func; global _cy_col_spmv_call_func, _cy_col_expect_call_func. num_times = len(config.tlist); psi_out = np.array([None] * num_times). expect_out = []; for i in range(config.e_num):; if config.e_ops_isherm[i]:; # preallocate real array of zeros; expect_out.append(np.zeros(num_times, dtype=float)); else:; ",MatchSource.WIKI,docs/4.2/modules/qutip/mcsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html
https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:16002,Modifiability,config,config,16002," def _tdRHStd_with_state(t, psi, config):. const_term = spmv_csr(config.h_data,; config.h_ind,; config.h_ptr, psi). h_func_term = np.array([; config.h_funcs[j](t, psi, config.h_func_args) *; spmv_csr(config.h_td_data[j],; config.h_td_ind[j],; config.h_td_ptr[j], psi); for j in config.h_td_inds]). col_func_terms = np.array([; np.abs(config.c_funcs[j](t, config.c_func_args)) ** 2 *; spmv_csr(config.n_ops_data[j],; config.n_ops_ind[j],; config.n_ops_ptr[j], psi); for j in config.c_td_inds]). return (const_term + np.sum(h_func_term, 0); - 0.5 * np.sum(col_func_terms, 0)). # RHS of ODE for python function Hamiltonian; def _pyRHSc(t, psi, config):; h_func_data = - 1.0j * config.h_funcs(t, config.h_func_args); h_func_term = spmv(h_func_data, psi); const_col_term = 0; if len(config.c_const_inds) > 0:; const_col_term = spmv_csr(config.h_data, config.h_ind,; config.h_ptr, psi). return h_func_term + const_col_term. def _pyRHSc_with_state(t, psi, config):; h_func_data = - 1.0j * config.h_funcs(t, psi, config.h_func_args); h_func_term = spmv(h_func_data, psi); const_col_term = 0; if len(config.c_const_inds) > 0:; const_col_term = spmv_csr(config.h_data, config.h_ind,; config.h_ptr, psi). return h_func_term + const_col_term. # -----------------------------------------------------------------------------; # evolution solver: return psi at requested times for no collapse operators; # -----------------------------------------------------------------------------; def _evolve_no_collapse_psi_out(config):; """"""; Calculates state vectors at times tlist if no collapse AND no; expectation values are given.; """""". global _cy_rhs_func; global _cy_col_spmv_func, _cy_col_expect_func; global _cy_col_spmv_call_func, _cy_col_expect_call_func. num_times = len(config.tlist); psi_out = np.array([None] * num_times). expect_out = []; for i in range(config.e_num):; if config.e_ops_isherm[i]:; # preallocate real array of zeros; expect_out.append(np.zeros(num_times, dtype=float)); else:; # preallocate comp",MatchSource.WIKI,docs/4.2/modules/qutip/mcsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html
https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:16088,Modifiability,config,config,16088," spmv_csr(config.h_data,; config.h_ind,; config.h_ptr, psi). h_func_term = np.array([; config.h_funcs[j](t, psi, config.h_func_args) *; spmv_csr(config.h_td_data[j],; config.h_td_ind[j],; config.h_td_ptr[j], psi); for j in config.h_td_inds]). col_func_terms = np.array([; np.abs(config.c_funcs[j](t, config.c_func_args)) ** 2 *; spmv_csr(config.n_ops_data[j],; config.n_ops_ind[j],; config.n_ops_ptr[j], psi); for j in config.c_td_inds]). return (const_term + np.sum(h_func_term, 0); - 0.5 * np.sum(col_func_terms, 0)). # RHS of ODE for python function Hamiltonian; def _pyRHSc(t, psi, config):; h_func_data = - 1.0j * config.h_funcs(t, config.h_func_args); h_func_term = spmv(h_func_data, psi); const_col_term = 0; if len(config.c_const_inds) > 0:; const_col_term = spmv_csr(config.h_data, config.h_ind,; config.h_ptr, psi). return h_func_term + const_col_term. def _pyRHSc_with_state(t, psi, config):; h_func_data = - 1.0j * config.h_funcs(t, psi, config.h_func_args); h_func_term = spmv(h_func_data, psi); const_col_term = 0; if len(config.c_const_inds) > 0:; const_col_term = spmv_csr(config.h_data, config.h_ind,; config.h_ptr, psi). return h_func_term + const_col_term. # -----------------------------------------------------------------------------; # evolution solver: return psi at requested times for no collapse operators; # -----------------------------------------------------------------------------; def _evolve_no_collapse_psi_out(config):; """"""; Calculates state vectors at times tlist if no collapse AND no; expectation values are given.; """""". global _cy_rhs_func; global _cy_col_spmv_func, _cy_col_expect_func; global _cy_col_spmv_call_func, _cy_col_expect_call_func. num_times = len(config.tlist); psi_out = np.array([None] * num_times). expect_out = []; for i in range(config.e_num):; if config.e_ops_isherm[i]:; # preallocate real array of zeros; expect_out.append(np.zeros(num_times, dtype=float)); else:; # preallocate complex array of zeros; expect_out.append(np.zeros(num_tim",MatchSource.WIKI,docs/4.2/modules/qutip/mcsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html
https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:16141,Modifiability,config,config,16141,"erm = np.array([; config.h_funcs[j](t, psi, config.h_func_args) *; spmv_csr(config.h_td_data[j],; config.h_td_ind[j],; config.h_td_ptr[j], psi); for j in config.h_td_inds]). col_func_terms = np.array([; np.abs(config.c_funcs[j](t, config.c_func_args)) ** 2 *; spmv_csr(config.n_ops_data[j],; config.n_ops_ind[j],; config.n_ops_ptr[j], psi); for j in config.c_td_inds]). return (const_term + np.sum(h_func_term, 0); - 0.5 * np.sum(col_func_terms, 0)). # RHS of ODE for python function Hamiltonian; def _pyRHSc(t, psi, config):; h_func_data = - 1.0j * config.h_funcs(t, config.h_func_args); h_func_term = spmv(h_func_data, psi); const_col_term = 0; if len(config.c_const_inds) > 0:; const_col_term = spmv_csr(config.h_data, config.h_ind,; config.h_ptr, psi). return h_func_term + const_col_term. def _pyRHSc_with_state(t, psi, config):; h_func_data = - 1.0j * config.h_funcs(t, psi, config.h_func_args); h_func_term = spmv(h_func_data, psi); const_col_term = 0; if len(config.c_const_inds) > 0:; const_col_term = spmv_csr(config.h_data, config.h_ind,; config.h_ptr, psi). return h_func_term + const_col_term. # -----------------------------------------------------------------------------; # evolution solver: return psi at requested times for no collapse operators; # -----------------------------------------------------------------------------; def _evolve_no_collapse_psi_out(config):; """"""; Calculates state vectors at times tlist if no collapse AND no; expectation values are given.; """""". global _cy_rhs_func; global _cy_col_spmv_func, _cy_col_expect_func; global _cy_col_spmv_call_func, _cy_col_expect_call_func. num_times = len(config.tlist); psi_out = np.array([None] * num_times). expect_out = []; for i in range(config.e_num):; if config.e_ops_isherm[i]:; # preallocate real array of zeros; expect_out.append(np.zeros(num_times, dtype=float)); else:; # preallocate complex array of zeros; expect_out.append(np.zeros(num_times, dtype=complex)). expect_out[i][0] = \; cy_expect_psi_csr(config.e_",MatchSource.WIKI,docs/4.2/modules/qutip/mcsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html
https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:16156,Modifiability,config,config,16156,"](t, psi, config.h_func_args) *; spmv_csr(config.h_td_data[j],; config.h_td_ind[j],; config.h_td_ptr[j], psi); for j in config.h_td_inds]). col_func_terms = np.array([; np.abs(config.c_funcs[j](t, config.c_func_args)) ** 2 *; spmv_csr(config.n_ops_data[j],; config.n_ops_ind[j],; config.n_ops_ptr[j], psi); for j in config.c_td_inds]). return (const_term + np.sum(h_func_term, 0); - 0.5 * np.sum(col_func_terms, 0)). # RHS of ODE for python function Hamiltonian; def _pyRHSc(t, psi, config):; h_func_data = - 1.0j * config.h_funcs(t, config.h_func_args); h_func_term = spmv(h_func_data, psi); const_col_term = 0; if len(config.c_const_inds) > 0:; const_col_term = spmv_csr(config.h_data, config.h_ind,; config.h_ptr, psi). return h_func_term + const_col_term. def _pyRHSc_with_state(t, psi, config):; h_func_data = - 1.0j * config.h_funcs(t, psi, config.h_func_args); h_func_term = spmv(h_func_data, psi); const_col_term = 0; if len(config.c_const_inds) > 0:; const_col_term = spmv_csr(config.h_data, config.h_ind,; config.h_ptr, psi). return h_func_term + const_col_term. # -----------------------------------------------------------------------------; # evolution solver: return psi at requested times for no collapse operators; # -----------------------------------------------------------------------------; def _evolve_no_collapse_psi_out(config):; """"""; Calculates state vectors at times tlist if no collapse AND no; expectation values are given.; """""". global _cy_rhs_func; global _cy_col_spmv_func, _cy_col_expect_func; global _cy_col_spmv_call_func, _cy_col_expect_call_func. num_times = len(config.tlist); psi_out = np.array([None] * num_times). expect_out = []; for i in range(config.e_num):; if config.e_ops_isherm[i]:; # preallocate real array of zeros; expect_out.append(np.zeros(num_times, dtype=float)); else:; # preallocate complex array of zeros; expect_out.append(np.zeros(num_times, dtype=complex)). expect_out[i][0] = \; cy_expect_psi_csr(config.e_ops_data[i],; config.e_ops_ind[i],",MatchSource.WIKI,docs/4.2/modules/qutip/mcsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html
https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:16171,Modifiability,config,config,16171,"g.h_func_args) *; spmv_csr(config.h_td_data[j],; config.h_td_ind[j],; config.h_td_ptr[j], psi); for j in config.h_td_inds]). col_func_terms = np.array([; np.abs(config.c_funcs[j](t, config.c_func_args)) ** 2 *; spmv_csr(config.n_ops_data[j],; config.n_ops_ind[j],; config.n_ops_ptr[j], psi); for j in config.c_td_inds]). return (const_term + np.sum(h_func_term, 0); - 0.5 * np.sum(col_func_terms, 0)). # RHS of ODE for python function Hamiltonian; def _pyRHSc(t, psi, config):; h_func_data = - 1.0j * config.h_funcs(t, config.h_func_args); h_func_term = spmv(h_func_data, psi); const_col_term = 0; if len(config.c_const_inds) > 0:; const_col_term = spmv_csr(config.h_data, config.h_ind,; config.h_ptr, psi). return h_func_term + const_col_term. def _pyRHSc_with_state(t, psi, config):; h_func_data = - 1.0j * config.h_funcs(t, psi, config.h_func_args); h_func_term = spmv(h_func_data, psi); const_col_term = 0; if len(config.c_const_inds) > 0:; const_col_term = spmv_csr(config.h_data, config.h_ind,; config.h_ptr, psi). return h_func_term + const_col_term. # -----------------------------------------------------------------------------; # evolution solver: return psi at requested times for no collapse operators; # -----------------------------------------------------------------------------; def _evolve_no_collapse_psi_out(config):; """"""; Calculates state vectors at times tlist if no collapse AND no; expectation values are given.; """""". global _cy_rhs_func; global _cy_col_spmv_func, _cy_col_expect_func; global _cy_col_spmv_call_func, _cy_col_expect_call_func. num_times = len(config.tlist); psi_out = np.array([None] * num_times). expect_out = []; for i in range(config.e_num):; if config.e_ops_isherm[i]:; # preallocate real array of zeros; expect_out.append(np.zeros(num_times, dtype=float)); else:; # preallocate complex array of zeros; expect_out.append(np.zeros(num_times, dtype=complex)). expect_out[i][0] = \; cy_expect_psi_csr(config.e_ops_data[i],; config.e_ops_ind[i],; config.e_ops_",MatchSource.WIKI,docs/4.2/modules/qutip/mcsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html
https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:16499,Modifiability,config,config,16499,"fig.n_ops_ind[j],; config.n_ops_ptr[j], psi); for j in config.c_td_inds]). return (const_term + np.sum(h_func_term, 0); - 0.5 * np.sum(col_func_terms, 0)). # RHS of ODE for python function Hamiltonian; def _pyRHSc(t, psi, config):; h_func_data = - 1.0j * config.h_funcs(t, config.h_func_args); h_func_term = spmv(h_func_data, psi); const_col_term = 0; if len(config.c_const_inds) > 0:; const_col_term = spmv_csr(config.h_data, config.h_ind,; config.h_ptr, psi). return h_func_term + const_col_term. def _pyRHSc_with_state(t, psi, config):; h_func_data = - 1.0j * config.h_funcs(t, psi, config.h_func_args); h_func_term = spmv(h_func_data, psi); const_col_term = 0; if len(config.c_const_inds) > 0:; const_col_term = spmv_csr(config.h_data, config.h_ind,; config.h_ptr, psi). return h_func_term + const_col_term. # -----------------------------------------------------------------------------; # evolution solver: return psi at requested times for no collapse operators; # -----------------------------------------------------------------------------; def _evolve_no_collapse_psi_out(config):; """"""; Calculates state vectors at times tlist if no collapse AND no; expectation values are given.; """""". global _cy_rhs_func; global _cy_col_spmv_func, _cy_col_expect_func; global _cy_col_spmv_call_func, _cy_col_expect_call_func. num_times = len(config.tlist); psi_out = np.array([None] * num_times). expect_out = []; for i in range(config.e_num):; if config.e_ops_isherm[i]:; # preallocate real array of zeros; expect_out.append(np.zeros(num_times, dtype=float)); else:; # preallocate complex array of zeros; expect_out.append(np.zeros(num_times, dtype=complex)). expect_out[i][0] = \; cy_expect_psi_csr(config.e_ops_data[i],; config.e_ops_ind[i],; config.e_ops_ptr[i],; config.psi0,; config.e_ops_isherm[i]). if debug:; print(inspect.stack()[0][3]). if not _cy_rhs_func:; _mc_func_load(config). opt = config.options; if config.tflag in [1, 10, 11]:; ODE = ode(_cy_rhs_func); code = compile('ODE.set_f_params",MatchSource.WIKI,docs/4.2/modules/qutip/mcsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html
https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:16754,Modifiability,config,config,16754,"onst_col_term = 0; if len(config.c_const_inds) > 0:; const_col_term = spmv_csr(config.h_data, config.h_ind,; config.h_ptr, psi). return h_func_term + const_col_term. def _pyRHSc_with_state(t, psi, config):; h_func_data = - 1.0j * config.h_funcs(t, psi, config.h_func_args); h_func_term = spmv(h_func_data, psi); const_col_term = 0; if len(config.c_const_inds) > 0:; const_col_term = spmv_csr(config.h_data, config.h_ind,; config.h_ptr, psi). return h_func_term + const_col_term. # -----------------------------------------------------------------------------; # evolution solver: return psi at requested times for no collapse operators; # -----------------------------------------------------------------------------; def _evolve_no_collapse_psi_out(config):; """"""; Calculates state vectors at times tlist if no collapse AND no; expectation values are given.; """""". global _cy_rhs_func; global _cy_col_spmv_func, _cy_col_expect_func; global _cy_col_spmv_call_func, _cy_col_expect_call_func. num_times = len(config.tlist); psi_out = np.array([None] * num_times). expect_out = []; for i in range(config.e_num):; if config.e_ops_isherm[i]:; # preallocate real array of zeros; expect_out.append(np.zeros(num_times, dtype=float)); else:; # preallocate complex array of zeros; expect_out.append(np.zeros(num_times, dtype=complex)). expect_out[i][0] = \; cy_expect_psi_csr(config.e_ops_data[i],; config.e_ops_ind[i],; config.e_ops_ptr[i],; config.psi0,; config.e_ops_isherm[i]). if debug:; print(inspect.stack()[0][3]). if not _cy_rhs_func:; _mc_func_load(config). opt = config.options; if config.tflag in [1, 10, 11]:; ODE = ode(_cy_rhs_func); code = compile('ODE.set_f_params(' + config.string + ')',; '<string>', 'exec'); exec(code); elif config.tflag == 2:; ODE = ode(_cRHStd); ODE.set_f_params(config); elif config.tflag in [20, 22]:; if config.options.rhs_with_state:; ODE = ode(_tdRHStd_with_state); else:; ODE = ode(_tdRHStd); ODE.set_f_params(config); elif config.tflag == 3:; if config.options.rhs_w",MatchSource.WIKI,docs/4.2/modules/qutip/mcsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html
https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:16841,Modifiability,config,config,16841,"config.h_data, config.h_ind,; config.h_ptr, psi). return h_func_term + const_col_term. def _pyRHSc_with_state(t, psi, config):; h_func_data = - 1.0j * config.h_funcs(t, psi, config.h_func_args); h_func_term = spmv(h_func_data, psi); const_col_term = 0; if len(config.c_const_inds) > 0:; const_col_term = spmv_csr(config.h_data, config.h_ind,; config.h_ptr, psi). return h_func_term + const_col_term. # -----------------------------------------------------------------------------; # evolution solver: return psi at requested times for no collapse operators; # -----------------------------------------------------------------------------; def _evolve_no_collapse_psi_out(config):; """"""; Calculates state vectors at times tlist if no collapse AND no; expectation values are given.; """""". global _cy_rhs_func; global _cy_col_spmv_func, _cy_col_expect_func; global _cy_col_spmv_call_func, _cy_col_expect_call_func. num_times = len(config.tlist); psi_out = np.array([None] * num_times). expect_out = []; for i in range(config.e_num):; if config.e_ops_isherm[i]:; # preallocate real array of zeros; expect_out.append(np.zeros(num_times, dtype=float)); else:; # preallocate complex array of zeros; expect_out.append(np.zeros(num_times, dtype=complex)). expect_out[i][0] = \; cy_expect_psi_csr(config.e_ops_data[i],; config.e_ops_ind[i],; config.e_ops_ptr[i],; config.psi0,; config.e_ops_isherm[i]). if debug:; print(inspect.stack()[0][3]). if not _cy_rhs_func:; _mc_func_load(config). opt = config.options; if config.tflag in [1, 10, 11]:; ODE = ode(_cy_rhs_func); code = compile('ODE.set_f_params(' + config.string + ')',; '<string>', 'exec'); exec(code); elif config.tflag == 2:; ODE = ode(_cRHStd); ODE.set_f_params(config); elif config.tflag in [20, 22]:; if config.options.rhs_with_state:; ODE = ode(_tdRHStd_with_state); else:; ODE = ode(_tdRHStd); ODE.set_f_params(config); elif config.tflag == 3:; if config.options.rhs_with_state:; ODE = ode(_pyRHSc_with_state); else:; ODE = ode(_pyRHSc); ODE.set_f",MatchSource.WIKI,docs/4.2/modules/qutip/mcsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html
https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:16860,Modifiability,config,config,16860," config.h_ptr, psi). return h_func_term + const_col_term. def _pyRHSc_with_state(t, psi, config):; h_func_data = - 1.0j * config.h_funcs(t, psi, config.h_func_args); h_func_term = spmv(h_func_data, psi); const_col_term = 0; if len(config.c_const_inds) > 0:; const_col_term = spmv_csr(config.h_data, config.h_ind,; config.h_ptr, psi). return h_func_term + const_col_term. # -----------------------------------------------------------------------------; # evolution solver: return psi at requested times for no collapse operators; # -----------------------------------------------------------------------------; def _evolve_no_collapse_psi_out(config):; """"""; Calculates state vectors at times tlist if no collapse AND no; expectation values are given.; """""". global _cy_rhs_func; global _cy_col_spmv_func, _cy_col_expect_func; global _cy_col_spmv_call_func, _cy_col_expect_call_func. num_times = len(config.tlist); psi_out = np.array([None] * num_times). expect_out = []; for i in range(config.e_num):; if config.e_ops_isherm[i]:; # preallocate real array of zeros; expect_out.append(np.zeros(num_times, dtype=float)); else:; # preallocate complex array of zeros; expect_out.append(np.zeros(num_times, dtype=complex)). expect_out[i][0] = \; cy_expect_psi_csr(config.e_ops_data[i],; config.e_ops_ind[i],; config.e_ops_ptr[i],; config.psi0,; config.e_ops_isherm[i]). if debug:; print(inspect.stack()[0][3]). if not _cy_rhs_func:; _mc_func_load(config). opt = config.options; if config.tflag in [1, 10, 11]:; ODE = ode(_cy_rhs_func); code = compile('ODE.set_f_params(' + config.string + ')',; '<string>', 'exec'); exec(code); elif config.tflag == 2:; ODE = ode(_cRHStd); ODE.set_f_params(config); elif config.tflag in [20, 22]:; if config.options.rhs_with_state:; ODE = ode(_tdRHStd_with_state); else:; ODE = ode(_tdRHStd); ODE.set_f_params(config); elif config.tflag == 3:; if config.options.rhs_with_state:; ODE = ode(_pyRHSc_with_state); else:; ODE = ode(_pyRHSc); ODE.set_f_params(config); else:; ODE = ",MatchSource.WIKI,docs/4.2/modules/qutip/mcsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html
https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:17113,Modifiability,config,config,17113,"_const_inds) > 0:; const_col_term = spmv_csr(config.h_data, config.h_ind,; config.h_ptr, psi). return h_func_term + const_col_term. # -----------------------------------------------------------------------------; # evolution solver: return psi at requested times for no collapse operators; # -----------------------------------------------------------------------------; def _evolve_no_collapse_psi_out(config):; """"""; Calculates state vectors at times tlist if no collapse AND no; expectation values are given.; """""". global _cy_rhs_func; global _cy_col_spmv_func, _cy_col_expect_func; global _cy_col_spmv_call_func, _cy_col_expect_call_func. num_times = len(config.tlist); psi_out = np.array([None] * num_times). expect_out = []; for i in range(config.e_num):; if config.e_ops_isherm[i]:; # preallocate real array of zeros; expect_out.append(np.zeros(num_times, dtype=float)); else:; # preallocate complex array of zeros; expect_out.append(np.zeros(num_times, dtype=complex)). expect_out[i][0] = \; cy_expect_psi_csr(config.e_ops_data[i],; config.e_ops_ind[i],; config.e_ops_ptr[i],; config.psi0,; config.e_ops_isherm[i]). if debug:; print(inspect.stack()[0][3]). if not _cy_rhs_func:; _mc_func_load(config). opt = config.options; if config.tflag in [1, 10, 11]:; ODE = ode(_cy_rhs_func); code = compile('ODE.set_f_params(' + config.string + ')',; '<string>', 'exec'); exec(code); elif config.tflag == 2:; ODE = ode(_cRHStd); ODE.set_f_params(config); elif config.tflag in [20, 22]:; if config.options.rhs_with_state:; ODE = ode(_tdRHStd_with_state); else:; ODE = ode(_tdRHStd); ODE.set_f_params(config); elif config.tflag == 3:; if config.options.rhs_with_state:; ODE = ode(_pyRHSc_with_state); else:; ODE = ode(_pyRHSc); ODE.set_f_params(config); else:; ODE = ode(cy_ode_rhs); ODE.set_f_params(config.h_data, config.h_ind, config.h_ptr). # initialize ODE solver for RHS; ODE.set_integrator('zvode', method=opt.method, order=opt.order,; atol=opt.atol, rtol=opt.rtol, nsteps=opt.nsteps,; first_step=o",MatchSource.WIKI,docs/4.2/modules/qutip/mcsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html
https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:17136,Modifiability,config,config,17136," spmv_csr(config.h_data, config.h_ind,; config.h_ptr, psi). return h_func_term + const_col_term. # -----------------------------------------------------------------------------; # evolution solver: return psi at requested times for no collapse operators; # -----------------------------------------------------------------------------; def _evolve_no_collapse_psi_out(config):; """"""; Calculates state vectors at times tlist if no collapse AND no; expectation values are given.; """""". global _cy_rhs_func; global _cy_col_spmv_func, _cy_col_expect_func; global _cy_col_spmv_call_func, _cy_col_expect_call_func. num_times = len(config.tlist); psi_out = np.array([None] * num_times). expect_out = []; for i in range(config.e_num):; if config.e_ops_isherm[i]:; # preallocate real array of zeros; expect_out.append(np.zeros(num_times, dtype=float)); else:; # preallocate complex array of zeros; expect_out.append(np.zeros(num_times, dtype=complex)). expect_out[i][0] = \; cy_expect_psi_csr(config.e_ops_data[i],; config.e_ops_ind[i],; config.e_ops_ptr[i],; config.psi0,; config.e_ops_isherm[i]). if debug:; print(inspect.stack()[0][3]). if not _cy_rhs_func:; _mc_func_load(config). opt = config.options; if config.tflag in [1, 10, 11]:; ODE = ode(_cy_rhs_func); code = compile('ODE.set_f_params(' + config.string + ')',; '<string>', 'exec'); exec(code); elif config.tflag == 2:; ODE = ode(_cRHStd); ODE.set_f_params(config); elif config.tflag in [20, 22]:; if config.options.rhs_with_state:; ODE = ode(_tdRHStd_with_state); else:; ODE = ode(_tdRHStd); ODE.set_f_params(config); elif config.tflag == 3:; if config.options.rhs_with_state:; ODE = ode(_pyRHSc_with_state); else:; ODE = ode(_pyRHSc); ODE.set_f_params(config); else:; ODE = ode(cy_ode_rhs); ODE.set_f_params(config.h_data, config.h_ind, config.h_ptr). # initialize ODE solver for RHS; ODE.set_integrator('zvode', method=opt.method, order=opt.order,; atol=opt.atol, rtol=opt.rtol, nsteps=opt.nsteps,; first_step=opt.first_step, min_step=opt.min_step",MatchSource.WIKI,docs/4.2/modules/qutip/mcsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html
https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:17158,Modifiability,config,config,17158,", config.h_ind,; config.h_ptr, psi). return h_func_term + const_col_term. # -----------------------------------------------------------------------------; # evolution solver: return psi at requested times for no collapse operators; # -----------------------------------------------------------------------------; def _evolve_no_collapse_psi_out(config):; """"""; Calculates state vectors at times tlist if no collapse AND no; expectation values are given.; """""". global _cy_rhs_func; global _cy_col_spmv_func, _cy_col_expect_func; global _cy_col_spmv_call_func, _cy_col_expect_call_func. num_times = len(config.tlist); psi_out = np.array([None] * num_times). expect_out = []; for i in range(config.e_num):; if config.e_ops_isherm[i]:; # preallocate real array of zeros; expect_out.append(np.zeros(num_times, dtype=float)); else:; # preallocate complex array of zeros; expect_out.append(np.zeros(num_times, dtype=complex)). expect_out[i][0] = \; cy_expect_psi_csr(config.e_ops_data[i],; config.e_ops_ind[i],; config.e_ops_ptr[i],; config.psi0,; config.e_ops_isherm[i]). if debug:; print(inspect.stack()[0][3]). if not _cy_rhs_func:; _mc_func_load(config). opt = config.options; if config.tflag in [1, 10, 11]:; ODE = ode(_cy_rhs_func); code = compile('ODE.set_f_params(' + config.string + ')',; '<string>', 'exec'); exec(code); elif config.tflag == 2:; ODE = ode(_cRHStd); ODE.set_f_params(config); elif config.tflag in [20, 22]:; if config.options.rhs_with_state:; ODE = ode(_tdRHStd_with_state); else:; ODE = ode(_tdRHStd); ODE.set_f_params(config); elif config.tflag == 3:; if config.options.rhs_with_state:; ODE = ode(_pyRHSc_with_state); else:; ODE = ode(_pyRHSc); ODE.set_f_params(config); else:; ODE = ode(cy_ode_rhs); ODE.set_f_params(config.h_data, config.h_ind, config.h_ptr). # initialize ODE solver for RHS; ODE.set_integrator('zvode', method=opt.method, order=opt.order,; atol=opt.atol, rtol=opt.rtol, nsteps=opt.nsteps,; first_step=opt.first_step, min_step=opt.min_step,; max_step=opt.max_st",MatchSource.WIKI,docs/4.2/modules/qutip/mcsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html
https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:17180,Modifiability,config,config,17180,"g.h_ptr, psi). return h_func_term + const_col_term. # -----------------------------------------------------------------------------; # evolution solver: return psi at requested times for no collapse operators; # -----------------------------------------------------------------------------; def _evolve_no_collapse_psi_out(config):; """"""; Calculates state vectors at times tlist if no collapse AND no; expectation values are given.; """""". global _cy_rhs_func; global _cy_col_spmv_func, _cy_col_expect_func; global _cy_col_spmv_call_func, _cy_col_expect_call_func. num_times = len(config.tlist); psi_out = np.array([None] * num_times). expect_out = []; for i in range(config.e_num):; if config.e_ops_isherm[i]:; # preallocate real array of zeros; expect_out.append(np.zeros(num_times, dtype=float)); else:; # preallocate complex array of zeros; expect_out.append(np.zeros(num_times, dtype=complex)). expect_out[i][0] = \; cy_expect_psi_csr(config.e_ops_data[i],; config.e_ops_ind[i],; config.e_ops_ptr[i],; config.psi0,; config.e_ops_isherm[i]). if debug:; print(inspect.stack()[0][3]). if not _cy_rhs_func:; _mc_func_load(config). opt = config.options; if config.tflag in [1, 10, 11]:; ODE = ode(_cy_rhs_func); code = compile('ODE.set_f_params(' + config.string + ')',; '<string>', 'exec'); exec(code); elif config.tflag == 2:; ODE = ode(_cRHStd); ODE.set_f_params(config); elif config.tflag in [20, 22]:; if config.options.rhs_with_state:; ODE = ode(_tdRHStd_with_state); else:; ODE = ode(_tdRHStd); ODE.set_f_params(config); elif config.tflag == 3:; if config.options.rhs_with_state:; ODE = ode(_pyRHSc_with_state); else:; ODE = ode(_pyRHSc); ODE.set_f_params(config); else:; ODE = ode(cy_ode_rhs); ODE.set_f_params(config.h_data, config.h_ind, config.h_ptr). # initialize ODE solver for RHS; ODE.set_integrator('zvode', method=opt.method, order=opt.order,; atol=opt.atol, rtol=opt.rtol, nsteps=opt.nsteps,; first_step=opt.first_step, min_step=opt.min_step,; max_step=opt.max_step); # set initial con",MatchSource.WIKI,docs/4.2/modules/qutip/mcsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html
https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:17194,Modifiability,config,config,17194,"urn h_func_term + const_col_term. # -----------------------------------------------------------------------------; # evolution solver: return psi at requested times for no collapse operators; # -----------------------------------------------------------------------------; def _evolve_no_collapse_psi_out(config):; """"""; Calculates state vectors at times tlist if no collapse AND no; expectation values are given.; """""". global _cy_rhs_func; global _cy_col_spmv_func, _cy_col_expect_func; global _cy_col_spmv_call_func, _cy_col_expect_call_func. num_times = len(config.tlist); psi_out = np.array([None] * num_times). expect_out = []; for i in range(config.e_num):; if config.e_ops_isherm[i]:; # preallocate real array of zeros; expect_out.append(np.zeros(num_times, dtype=float)); else:; # preallocate complex array of zeros; expect_out.append(np.zeros(num_times, dtype=complex)). expect_out[i][0] = \; cy_expect_psi_csr(config.e_ops_data[i],; config.e_ops_ind[i],; config.e_ops_ptr[i],; config.psi0,; config.e_ops_isherm[i]). if debug:; print(inspect.stack()[0][3]). if not _cy_rhs_func:; _mc_func_load(config). opt = config.options; if config.tflag in [1, 10, 11]:; ODE = ode(_cy_rhs_func); code = compile('ODE.set_f_params(' + config.string + ')',; '<string>', 'exec'); exec(code); elif config.tflag == 2:; ODE = ode(_cRHStd); ODE.set_f_params(config); elif config.tflag in [20, 22]:; if config.options.rhs_with_state:; ODE = ode(_tdRHStd_with_state); else:; ODE = ode(_tdRHStd); ODE.set_f_params(config); elif config.tflag == 3:; if config.options.rhs_with_state:; ODE = ode(_pyRHSc_with_state); else:; ODE = ode(_pyRHSc); ODE.set_f_params(config); else:; ODE = ode(cy_ode_rhs); ODE.set_f_params(config.h_data, config.h_ind, config.h_ptr). # initialize ODE solver for RHS; ODE.set_integrator('zvode', method=opt.method, order=opt.order,; atol=opt.atol, rtol=opt.rtol, nsteps=opt.nsteps,; first_step=opt.first_step, min_step=opt.min_step,; max_step=opt.max_step); # set initial conditions; ODE.set_i",MatchSource.WIKI,docs/4.2/modules/qutip/mcsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html
https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:17296,Modifiability,config,config,17296,"--------------------------; # evolution solver: return psi at requested times for no collapse operators; # -----------------------------------------------------------------------------; def _evolve_no_collapse_psi_out(config):; """"""; Calculates state vectors at times tlist if no collapse AND no; expectation values are given.; """""". global _cy_rhs_func; global _cy_col_spmv_func, _cy_col_expect_func; global _cy_col_spmv_call_func, _cy_col_expect_call_func. num_times = len(config.tlist); psi_out = np.array([None] * num_times). expect_out = []; for i in range(config.e_num):; if config.e_ops_isherm[i]:; # preallocate real array of zeros; expect_out.append(np.zeros(num_times, dtype=float)); else:; # preallocate complex array of zeros; expect_out.append(np.zeros(num_times, dtype=complex)). expect_out[i][0] = \; cy_expect_psi_csr(config.e_ops_data[i],; config.e_ops_ind[i],; config.e_ops_ptr[i],; config.psi0,; config.e_ops_isherm[i]). if debug:; print(inspect.stack()[0][3]). if not _cy_rhs_func:; _mc_func_load(config). opt = config.options; if config.tflag in [1, 10, 11]:; ODE = ode(_cy_rhs_func); code = compile('ODE.set_f_params(' + config.string + ')',; '<string>', 'exec'); exec(code); elif config.tflag == 2:; ODE = ode(_cRHStd); ODE.set_f_params(config); elif config.tflag in [20, 22]:; if config.options.rhs_with_state:; ODE = ode(_tdRHStd_with_state); else:; ODE = ode(_tdRHStd); ODE.set_f_params(config); elif config.tflag == 3:; if config.options.rhs_with_state:; ODE = ode(_pyRHSc_with_state); else:; ODE = ode(_pyRHSc); ODE.set_f_params(config); else:; ODE = ode(cy_ode_rhs); ODE.set_f_params(config.h_data, config.h_ind, config.h_ptr). # initialize ODE solver for RHS; ODE.set_integrator('zvode', method=opt.method, order=opt.order,; atol=opt.atol, rtol=opt.rtol, nsteps=opt.nsteps,; first_step=opt.first_step, min_step=opt.min_step,; max_step=opt.max_step); # set initial conditions; ODE.set_initial_value(config.psi0, config.tlist[0]); psi_out[0] = Qobj(config.psi0, config.psi0_d",MatchSource.WIKI,docs/4.2/modules/qutip/mcsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html
https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:17311,Modifiability,config,config,17311,"evolution solver: return psi at requested times for no collapse operators; # -----------------------------------------------------------------------------; def _evolve_no_collapse_psi_out(config):; """"""; Calculates state vectors at times tlist if no collapse AND no; expectation values are given.; """""". global _cy_rhs_func; global _cy_col_spmv_func, _cy_col_expect_func; global _cy_col_spmv_call_func, _cy_col_expect_call_func. num_times = len(config.tlist); psi_out = np.array([None] * num_times). expect_out = []; for i in range(config.e_num):; if config.e_ops_isherm[i]:; # preallocate real array of zeros; expect_out.append(np.zeros(num_times, dtype=float)); else:; # preallocate complex array of zeros; expect_out.append(np.zeros(num_times, dtype=complex)). expect_out[i][0] = \; cy_expect_psi_csr(config.e_ops_data[i],; config.e_ops_ind[i],; config.e_ops_ptr[i],; config.psi0,; config.e_ops_isherm[i]). if debug:; print(inspect.stack()[0][3]). if not _cy_rhs_func:; _mc_func_load(config). opt = config.options; if config.tflag in [1, 10, 11]:; ODE = ode(_cy_rhs_func); code = compile('ODE.set_f_params(' + config.string + ')',; '<string>', 'exec'); exec(code); elif config.tflag == 2:; ODE = ode(_cRHStd); ODE.set_f_params(config); elif config.tflag in [20, 22]:; if config.options.rhs_with_state:; ODE = ode(_tdRHStd_with_state); else:; ODE = ode(_tdRHStd); ODE.set_f_params(config); elif config.tflag == 3:; if config.options.rhs_with_state:; ODE = ode(_pyRHSc_with_state); else:; ODE = ode(_pyRHSc); ODE.set_f_params(config); else:; ODE = ode(cy_ode_rhs); ODE.set_f_params(config.h_data, config.h_ind, config.h_ptr). # initialize ODE solver for RHS; ODE.set_integrator('zvode', method=opt.method, order=opt.order,; atol=opt.atol, rtol=opt.rtol, nsteps=opt.nsteps,; first_step=opt.first_step, min_step=opt.min_step,; max_step=opt.max_step); # set initial conditions; ODE.set_initial_value(config.psi0, config.tlist[0]); psi_out[0] = Qobj(config.psi0, config.psi0_dims,; config.psi0_shape); for",MatchSource.WIKI,docs/4.2/modules/qutip/mcsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html
https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:17330,Modifiability,config,config,17330,": return psi at requested times for no collapse operators; # -----------------------------------------------------------------------------; def _evolve_no_collapse_psi_out(config):; """"""; Calculates state vectors at times tlist if no collapse AND no; expectation values are given.; """""". global _cy_rhs_func; global _cy_col_spmv_func, _cy_col_expect_func; global _cy_col_spmv_call_func, _cy_col_expect_call_func. num_times = len(config.tlist); psi_out = np.array([None] * num_times). expect_out = []; for i in range(config.e_num):; if config.e_ops_isherm[i]:; # preallocate real array of zeros; expect_out.append(np.zeros(num_times, dtype=float)); else:; # preallocate complex array of zeros; expect_out.append(np.zeros(num_times, dtype=complex)). expect_out[i][0] = \; cy_expect_psi_csr(config.e_ops_data[i],; config.e_ops_ind[i],; config.e_ops_ptr[i],; config.psi0,; config.e_ops_isherm[i]). if debug:; print(inspect.stack()[0][3]). if not _cy_rhs_func:; _mc_func_load(config). opt = config.options; if config.tflag in [1, 10, 11]:; ODE = ode(_cy_rhs_func); code = compile('ODE.set_f_params(' + config.string + ')',; '<string>', 'exec'); exec(code); elif config.tflag == 2:; ODE = ode(_cRHStd); ODE.set_f_params(config); elif config.tflag in [20, 22]:; if config.options.rhs_with_state:; ODE = ode(_tdRHStd_with_state); else:; ODE = ode(_tdRHStd); ODE.set_f_params(config); elif config.tflag == 3:; if config.options.rhs_with_state:; ODE = ode(_pyRHSc_with_state); else:; ODE = ode(_pyRHSc); ODE.set_f_params(config); else:; ODE = ode(cy_ode_rhs); ODE.set_f_params(config.h_data, config.h_ind, config.h_ptr). # initialize ODE solver for RHS; ODE.set_integrator('zvode', method=opt.method, order=opt.order,; atol=opt.atol, rtol=opt.rtol, nsteps=opt.nsteps,; first_step=opt.first_step, min_step=opt.min_step,; max_step=opt.max_step); # set initial conditions; ODE.set_initial_value(config.psi0, config.tlist[0]); psi_out[0] = Qobj(config.psi0, config.psi0_dims,; config.psi0_shape); for k in range(1, nu",MatchSource.WIKI,docs/4.2/modules/qutip/mcsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html
https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:17422,Modifiability,config,config,17422,"------------------------------------------------; def _evolve_no_collapse_psi_out(config):; """"""; Calculates state vectors at times tlist if no collapse AND no; expectation values are given.; """""". global _cy_rhs_func; global _cy_col_spmv_func, _cy_col_expect_func; global _cy_col_spmv_call_func, _cy_col_expect_call_func. num_times = len(config.tlist); psi_out = np.array([None] * num_times). expect_out = []; for i in range(config.e_num):; if config.e_ops_isherm[i]:; # preallocate real array of zeros; expect_out.append(np.zeros(num_times, dtype=float)); else:; # preallocate complex array of zeros; expect_out.append(np.zeros(num_times, dtype=complex)). expect_out[i][0] = \; cy_expect_psi_csr(config.e_ops_data[i],; config.e_ops_ind[i],; config.e_ops_ptr[i],; config.psi0,; config.e_ops_isherm[i]). if debug:; print(inspect.stack()[0][3]). if not _cy_rhs_func:; _mc_func_load(config). opt = config.options; if config.tflag in [1, 10, 11]:; ODE = ode(_cy_rhs_func); code = compile('ODE.set_f_params(' + config.string + ')',; '<string>', 'exec'); exec(code); elif config.tflag == 2:; ODE = ode(_cRHStd); ODE.set_f_params(config); elif config.tflag in [20, 22]:; if config.options.rhs_with_state:; ODE = ode(_tdRHStd_with_state); else:; ODE = ode(_tdRHStd); ODE.set_f_params(config); elif config.tflag == 3:; if config.options.rhs_with_state:; ODE = ode(_pyRHSc_with_state); else:; ODE = ode(_pyRHSc); ODE.set_f_params(config); else:; ODE = ode(cy_ode_rhs); ODE.set_f_params(config.h_data, config.h_ind, config.h_ptr). # initialize ODE solver for RHS; ODE.set_integrator('zvode', method=opt.method, order=opt.order,; atol=opt.atol, rtol=opt.rtol, nsteps=opt.nsteps,; first_step=opt.first_step, min_step=opt.min_step,; max_step=opt.max_step); # set initial conditions; ODE.set_initial_value(config.psi0, config.tlist[0]); psi_out[0] = Qobj(config.psi0, config.psi0_dims,; config.psi0_shape); for k in range(1, num_times):; ODE.integrate(config.tlist[k], step=0) # integrate up to tlist[k]; if ODE.succ",MatchSource.WIKI,docs/4.2/modules/qutip/mcsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html
https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:17482,Modifiability,config,config,17482,"------; def _evolve_no_collapse_psi_out(config):; """"""; Calculates state vectors at times tlist if no collapse AND no; expectation values are given.; """""". global _cy_rhs_func; global _cy_col_spmv_func, _cy_col_expect_func; global _cy_col_spmv_call_func, _cy_col_expect_call_func. num_times = len(config.tlist); psi_out = np.array([None] * num_times). expect_out = []; for i in range(config.e_num):; if config.e_ops_isherm[i]:; # preallocate real array of zeros; expect_out.append(np.zeros(num_times, dtype=float)); else:; # preallocate complex array of zeros; expect_out.append(np.zeros(num_times, dtype=complex)). expect_out[i][0] = \; cy_expect_psi_csr(config.e_ops_data[i],; config.e_ops_ind[i],; config.e_ops_ptr[i],; config.psi0,; config.e_ops_isherm[i]). if debug:; print(inspect.stack()[0][3]). if not _cy_rhs_func:; _mc_func_load(config). opt = config.options; if config.tflag in [1, 10, 11]:; ODE = ode(_cy_rhs_func); code = compile('ODE.set_f_params(' + config.string + ')',; '<string>', 'exec'); exec(code); elif config.tflag == 2:; ODE = ode(_cRHStd); ODE.set_f_params(config); elif config.tflag in [20, 22]:; if config.options.rhs_with_state:; ODE = ode(_tdRHStd_with_state); else:; ODE = ode(_tdRHStd); ODE.set_f_params(config); elif config.tflag == 3:; if config.options.rhs_with_state:; ODE = ode(_pyRHSc_with_state); else:; ODE = ode(_pyRHSc); ODE.set_f_params(config); else:; ODE = ode(cy_ode_rhs); ODE.set_f_params(config.h_data, config.h_ind, config.h_ptr). # initialize ODE solver for RHS; ODE.set_integrator('zvode', method=opt.method, order=opt.order,; atol=opt.atol, rtol=opt.rtol, nsteps=opt.nsteps,; first_step=opt.first_step, min_step=opt.min_step,; max_step=opt.max_step); # set initial conditions; ODE.set_initial_value(config.psi0, config.tlist[0]); psi_out[0] = Qobj(config.psi0, config.psi0_dims,; config.psi0_shape); for k in range(1, num_times):; ODE.integrate(config.tlist[k], step=0) # integrate up to tlist[k]; if ODE.successful():; state = ODE.y / dznrm2(ODE.y); ",MatchSource.WIKI,docs/4.2/modules/qutip/mcsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html
https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:17539,Modifiability,config,config,17539,"imes tlist if no collapse AND no; expectation values are given.; """""". global _cy_rhs_func; global _cy_col_spmv_func, _cy_col_expect_func; global _cy_col_spmv_call_func, _cy_col_expect_call_func. num_times = len(config.tlist); psi_out = np.array([None] * num_times). expect_out = []; for i in range(config.e_num):; if config.e_ops_isherm[i]:; # preallocate real array of zeros; expect_out.append(np.zeros(num_times, dtype=float)); else:; # preallocate complex array of zeros; expect_out.append(np.zeros(num_times, dtype=complex)). expect_out[i][0] = \; cy_expect_psi_csr(config.e_ops_data[i],; config.e_ops_ind[i],; config.e_ops_ptr[i],; config.psi0,; config.e_ops_isherm[i]). if debug:; print(inspect.stack()[0][3]). if not _cy_rhs_func:; _mc_func_load(config). opt = config.options; if config.tflag in [1, 10, 11]:; ODE = ode(_cy_rhs_func); code = compile('ODE.set_f_params(' + config.string + ')',; '<string>', 'exec'); exec(code); elif config.tflag == 2:; ODE = ode(_cRHStd); ODE.set_f_params(config); elif config.tflag in [20, 22]:; if config.options.rhs_with_state:; ODE = ode(_tdRHStd_with_state); else:; ODE = ode(_tdRHStd); ODE.set_f_params(config); elif config.tflag == 3:; if config.options.rhs_with_state:; ODE = ode(_pyRHSc_with_state); else:; ODE = ode(_pyRHSc); ODE.set_f_params(config); else:; ODE = ode(cy_ode_rhs); ODE.set_f_params(config.h_data, config.h_ind, config.h_ptr). # initialize ODE solver for RHS; ODE.set_integrator('zvode', method=opt.method, order=opt.order,; atol=opt.atol, rtol=opt.rtol, nsteps=opt.nsteps,; first_step=opt.first_step, min_step=opt.min_step,; max_step=opt.max_step); # set initial conditions; ODE.set_initial_value(config.psi0, config.tlist[0]); psi_out[0] = Qobj(config.psi0, config.psi0_dims,; config.psi0_shape); for k in range(1, num_times):; ODE.integrate(config.tlist[k], step=0) # integrate up to tlist[k]; if ODE.successful():; state = ODE.y / dznrm2(ODE.y); psi_out[k] = Qobj(state, config.psi0_dims, config.psi0_shape); for jj in range(confi",MatchSource.WIKI,docs/4.2/modules/qutip/mcsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html
https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:17553,Modifiability,config,config,17553,"imes tlist if no collapse AND no; expectation values are given.; """""". global _cy_rhs_func; global _cy_col_spmv_func, _cy_col_expect_func; global _cy_col_spmv_call_func, _cy_col_expect_call_func. num_times = len(config.tlist); psi_out = np.array([None] * num_times). expect_out = []; for i in range(config.e_num):; if config.e_ops_isherm[i]:; # preallocate real array of zeros; expect_out.append(np.zeros(num_times, dtype=float)); else:; # preallocate complex array of zeros; expect_out.append(np.zeros(num_times, dtype=complex)). expect_out[i][0] = \; cy_expect_psi_csr(config.e_ops_data[i],; config.e_ops_ind[i],; config.e_ops_ptr[i],; config.psi0,; config.e_ops_isherm[i]). if debug:; print(inspect.stack()[0][3]). if not _cy_rhs_func:; _mc_func_load(config). opt = config.options; if config.tflag in [1, 10, 11]:; ODE = ode(_cy_rhs_func); code = compile('ODE.set_f_params(' + config.string + ')',; '<string>', 'exec'); exec(code); elif config.tflag == 2:; ODE = ode(_cRHStd); ODE.set_f_params(config); elif config.tflag in [20, 22]:; if config.options.rhs_with_state:; ODE = ode(_tdRHStd_with_state); else:; ODE = ode(_tdRHStd); ODE.set_f_params(config); elif config.tflag == 3:; if config.options.rhs_with_state:; ODE = ode(_pyRHSc_with_state); else:; ODE = ode(_pyRHSc); ODE.set_f_params(config); else:; ODE = ode(cy_ode_rhs); ODE.set_f_params(config.h_data, config.h_ind, config.h_ptr). # initialize ODE solver for RHS; ODE.set_integrator('zvode', method=opt.method, order=opt.order,; atol=opt.atol, rtol=opt.rtol, nsteps=opt.nsteps,; first_step=opt.first_step, min_step=opt.min_step,; max_step=opt.max_step); # set initial conditions; ODE.set_initial_value(config.psi0, config.tlist[0]); psi_out[0] = Qobj(config.psi0, config.psi0_dims,; config.psi0_shape); for k in range(1, num_times):; ODE.integrate(config.tlist[k], step=0) # integrate up to tlist[k]; if ODE.successful():; state = ODE.y / dznrm2(ODE.y); psi_out[k] = Qobj(state, config.psi0_dims, config.psi0_shape); for jj in range(confi",MatchSource.WIKI,docs/4.2/modules/qutip/mcsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html
https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:17583,Modifiability,config,config,17583,"; expectation values are given.; """""". global _cy_rhs_func; global _cy_col_spmv_func, _cy_col_expect_func; global _cy_col_spmv_call_func, _cy_col_expect_call_func. num_times = len(config.tlist); psi_out = np.array([None] * num_times). expect_out = []; for i in range(config.e_num):; if config.e_ops_isherm[i]:; # preallocate real array of zeros; expect_out.append(np.zeros(num_times, dtype=float)); else:; # preallocate complex array of zeros; expect_out.append(np.zeros(num_times, dtype=complex)). expect_out[i][0] = \; cy_expect_psi_csr(config.e_ops_data[i],; config.e_ops_ind[i],; config.e_ops_ptr[i],; config.psi0,; config.e_ops_isherm[i]). if debug:; print(inspect.stack()[0][3]). if not _cy_rhs_func:; _mc_func_load(config). opt = config.options; if config.tflag in [1, 10, 11]:; ODE = ode(_cy_rhs_func); code = compile('ODE.set_f_params(' + config.string + ')',; '<string>', 'exec'); exec(code); elif config.tflag == 2:; ODE = ode(_cRHStd); ODE.set_f_params(config); elif config.tflag in [20, 22]:; if config.options.rhs_with_state:; ODE = ode(_tdRHStd_with_state); else:; ODE = ode(_tdRHStd); ODE.set_f_params(config); elif config.tflag == 3:; if config.options.rhs_with_state:; ODE = ode(_pyRHSc_with_state); else:; ODE = ode(_pyRHSc); ODE.set_f_params(config); else:; ODE = ode(cy_ode_rhs); ODE.set_f_params(config.h_data, config.h_ind, config.h_ptr). # initialize ODE solver for RHS; ODE.set_integrator('zvode', method=opt.method, order=opt.order,; atol=opt.atol, rtol=opt.rtol, nsteps=opt.nsteps,; first_step=opt.first_step, min_step=opt.min_step,; max_step=opt.max_step); # set initial conditions; ODE.set_initial_value(config.psi0, config.tlist[0]); psi_out[0] = Qobj(config.psi0, config.psi0_dims,; config.psi0_shape); for k in range(1, num_times):; ODE.integrate(config.tlist[k], step=0) # integrate up to tlist[k]; if ODE.successful():; state = ODE.y / dznrm2(ODE.y); psi_out[k] = Qobj(state, config.psi0_dims, config.psi0_shape); for jj in range(config.e_num):; expect_out[jj][k] = c",MatchSource.WIKI,docs/4.2/modules/qutip/mcsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html
https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:17692,Modifiability,config,config,17692,"spmv_call_func, _cy_col_expect_call_func. num_times = len(config.tlist); psi_out = np.array([None] * num_times). expect_out = []; for i in range(config.e_num):; if config.e_ops_isherm[i]:; # preallocate real array of zeros; expect_out.append(np.zeros(num_times, dtype=float)); else:; # preallocate complex array of zeros; expect_out.append(np.zeros(num_times, dtype=complex)). expect_out[i][0] = \; cy_expect_psi_csr(config.e_ops_data[i],; config.e_ops_ind[i],; config.e_ops_ptr[i],; config.psi0,; config.e_ops_isherm[i]). if debug:; print(inspect.stack()[0][3]). if not _cy_rhs_func:; _mc_func_load(config). opt = config.options; if config.tflag in [1, 10, 11]:; ODE = ode(_cy_rhs_func); code = compile('ODE.set_f_params(' + config.string + ')',; '<string>', 'exec'); exec(code); elif config.tflag == 2:; ODE = ode(_cRHStd); ODE.set_f_params(config); elif config.tflag in [20, 22]:; if config.options.rhs_with_state:; ODE = ode(_tdRHStd_with_state); else:; ODE = ode(_tdRHStd); ODE.set_f_params(config); elif config.tflag == 3:; if config.options.rhs_with_state:; ODE = ode(_pyRHSc_with_state); else:; ODE = ode(_pyRHSc); ODE.set_f_params(config); else:; ODE = ode(cy_ode_rhs); ODE.set_f_params(config.h_data, config.h_ind, config.h_ptr). # initialize ODE solver for RHS; ODE.set_integrator('zvode', method=opt.method, order=opt.order,; atol=opt.atol, rtol=opt.rtol, nsteps=opt.nsteps,; first_step=opt.first_step, min_step=opt.min_step,; max_step=opt.max_step); # set initial conditions; ODE.set_initial_value(config.psi0, config.tlist[0]); psi_out[0] = Qobj(config.psi0, config.psi0_dims,; config.psi0_shape); for k in range(1, num_times):; ODE.integrate(config.tlist[k], step=0) # integrate up to tlist[k]; if ODE.successful():; state = ODE.y / dznrm2(ODE.y); psi_out[k] = Qobj(state, config.psi0_dims, config.psi0_shape); for jj in range(config.e_num):; expect_out[jj][k] = cy_expect_psi_csr(; config.e_ops_data[jj], config.e_ops_ind[jj],; config.e_ops_ptr[jj], state,; config.e_ops_isherm[jj]); ",MatchSource.WIKI,docs/4.2/modules/qutip/mcsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html
https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:17706,Modifiability,config,config,17706,"spmv_call_func, _cy_col_expect_call_func. num_times = len(config.tlist); psi_out = np.array([None] * num_times). expect_out = []; for i in range(config.e_num):; if config.e_ops_isherm[i]:; # preallocate real array of zeros; expect_out.append(np.zeros(num_times, dtype=float)); else:; # preallocate complex array of zeros; expect_out.append(np.zeros(num_times, dtype=complex)). expect_out[i][0] = \; cy_expect_psi_csr(config.e_ops_data[i],; config.e_ops_ind[i],; config.e_ops_ptr[i],; config.psi0,; config.e_ops_isherm[i]). if debug:; print(inspect.stack()[0][3]). if not _cy_rhs_func:; _mc_func_load(config). opt = config.options; if config.tflag in [1, 10, 11]:; ODE = ode(_cy_rhs_func); code = compile('ODE.set_f_params(' + config.string + ')',; '<string>', 'exec'); exec(code); elif config.tflag == 2:; ODE = ode(_cRHStd); ODE.set_f_params(config); elif config.tflag in [20, 22]:; if config.options.rhs_with_state:; ODE = ode(_tdRHStd_with_state); else:; ODE = ode(_tdRHStd); ODE.set_f_params(config); elif config.tflag == 3:; if config.options.rhs_with_state:; ODE = ode(_pyRHSc_with_state); else:; ODE = ode(_pyRHSc); ODE.set_f_params(config); else:; ODE = ode(cy_ode_rhs); ODE.set_f_params(config.h_data, config.h_ind, config.h_ptr). # initialize ODE solver for RHS; ODE.set_integrator('zvode', method=opt.method, order=opt.order,; atol=opt.atol, rtol=opt.rtol, nsteps=opt.nsteps,; first_step=opt.first_step, min_step=opt.min_step,; max_step=opt.max_step); # set initial conditions; ODE.set_initial_value(config.psi0, config.tlist[0]); psi_out[0] = Qobj(config.psi0, config.psi0_dims,; config.psi0_shape); for k in range(1, num_times):; ODE.integrate(config.tlist[k], step=0) # integrate up to tlist[k]; if ODE.successful():; state = ODE.y / dznrm2(ODE.y); psi_out[k] = Qobj(state, config.psi0_dims, config.psi0_shape); for jj in range(config.e_num):; expect_out[jj][k] = cy_expect_psi_csr(; config.e_ops_data[jj], config.e_ops_ind[jj],; config.e_ops_ptr[jj], state,; config.e_ops_isherm[jj]); ",MatchSource.WIKI,docs/4.2/modules/qutip/mcsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html
https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:17729,Modifiability,config,config,17729,"ct_call_func. num_times = len(config.tlist); psi_out = np.array([None] * num_times). expect_out = []; for i in range(config.e_num):; if config.e_ops_isherm[i]:; # preallocate real array of zeros; expect_out.append(np.zeros(num_times, dtype=float)); else:; # preallocate complex array of zeros; expect_out.append(np.zeros(num_times, dtype=complex)). expect_out[i][0] = \; cy_expect_psi_csr(config.e_ops_data[i],; config.e_ops_ind[i],; config.e_ops_ptr[i],; config.psi0,; config.e_ops_isherm[i]). if debug:; print(inspect.stack()[0][3]). if not _cy_rhs_func:; _mc_func_load(config). opt = config.options; if config.tflag in [1, 10, 11]:; ODE = ode(_cy_rhs_func); code = compile('ODE.set_f_params(' + config.string + ')',; '<string>', 'exec'); exec(code); elif config.tflag == 2:; ODE = ode(_cRHStd); ODE.set_f_params(config); elif config.tflag in [20, 22]:; if config.options.rhs_with_state:; ODE = ode(_tdRHStd_with_state); else:; ODE = ode(_tdRHStd); ODE.set_f_params(config); elif config.tflag == 3:; if config.options.rhs_with_state:; ODE = ode(_pyRHSc_with_state); else:; ODE = ode(_pyRHSc); ODE.set_f_params(config); else:; ODE = ode(cy_ode_rhs); ODE.set_f_params(config.h_data, config.h_ind, config.h_ptr). # initialize ODE solver for RHS; ODE.set_integrator('zvode', method=opt.method, order=opt.order,; atol=opt.atol, rtol=opt.rtol, nsteps=opt.nsteps,; first_step=opt.first_step, min_step=opt.min_step,; max_step=opt.max_step); # set initial conditions; ODE.set_initial_value(config.psi0, config.tlist[0]); psi_out[0] = Qobj(config.psi0, config.psi0_dims,; config.psi0_shape); for k in range(1, num_times):; ODE.integrate(config.tlist[k], step=0) # integrate up to tlist[k]; if ODE.successful():; state = ODE.y / dznrm2(ODE.y); psi_out[k] = Qobj(state, config.psi0_dims, config.psi0_shape); for jj in range(config.e_num):; expect_out[jj][k] = cy_expect_psi_csr(; config.e_ops_data[jj], config.e_ops_ind[jj],; config.e_ops_ptr[jj], state,; config.e_ops_isherm[jj]); else:; raise ValueError('Erro",MatchSource.WIKI,docs/4.2/modules/qutip/mcsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html
https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:17836,Modifiability,config,config,17836,"um):; if config.e_ops_isherm[i]:; # preallocate real array of zeros; expect_out.append(np.zeros(num_times, dtype=float)); else:; # preallocate complex array of zeros; expect_out.append(np.zeros(num_times, dtype=complex)). expect_out[i][0] = \; cy_expect_psi_csr(config.e_ops_data[i],; config.e_ops_ind[i],; config.e_ops_ptr[i],; config.psi0,; config.e_ops_isherm[i]). if debug:; print(inspect.stack()[0][3]). if not _cy_rhs_func:; _mc_func_load(config). opt = config.options; if config.tflag in [1, 10, 11]:; ODE = ode(_cy_rhs_func); code = compile('ODE.set_f_params(' + config.string + ')',; '<string>', 'exec'); exec(code); elif config.tflag == 2:; ODE = ode(_cRHStd); ODE.set_f_params(config); elif config.tflag in [20, 22]:; if config.options.rhs_with_state:; ODE = ode(_tdRHStd_with_state); else:; ODE = ode(_tdRHStd); ODE.set_f_params(config); elif config.tflag == 3:; if config.options.rhs_with_state:; ODE = ode(_pyRHSc_with_state); else:; ODE = ode(_pyRHSc); ODE.set_f_params(config); else:; ODE = ode(cy_ode_rhs); ODE.set_f_params(config.h_data, config.h_ind, config.h_ptr). # initialize ODE solver for RHS; ODE.set_integrator('zvode', method=opt.method, order=opt.order,; atol=opt.atol, rtol=opt.rtol, nsteps=opt.nsteps,; first_step=opt.first_step, min_step=opt.min_step,; max_step=opt.max_step); # set initial conditions; ODE.set_initial_value(config.psi0, config.tlist[0]); psi_out[0] = Qobj(config.psi0, config.psi0_dims,; config.psi0_shape); for k in range(1, num_times):; ODE.integrate(config.tlist[k], step=0) # integrate up to tlist[k]; if ODE.successful():; state = ODE.y / dznrm2(ODE.y); psi_out[k] = Qobj(state, config.psi0_dims, config.psi0_shape); for jj in range(config.e_num):; expect_out[jj][k] = cy_expect_psi_csr(; config.e_ops_data[jj], config.e_ops_ind[jj],; config.e_ops_ptr[jj], state,; config.e_ops_isherm[jj]); else:; raise ValueError('Error in ODE solver'). return expect_out, psi_out. # -----------------------------------------------------------------------------",MatchSource.WIKI,docs/4.2/modules/qutip/mcsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html
https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:17892,Modifiability,config,config,17892,"eallocate real array of zeros; expect_out.append(np.zeros(num_times, dtype=float)); else:; # preallocate complex array of zeros; expect_out.append(np.zeros(num_times, dtype=complex)). expect_out[i][0] = \; cy_expect_psi_csr(config.e_ops_data[i],; config.e_ops_ind[i],; config.e_ops_ptr[i],; config.psi0,; config.e_ops_isherm[i]). if debug:; print(inspect.stack()[0][3]). if not _cy_rhs_func:; _mc_func_load(config). opt = config.options; if config.tflag in [1, 10, 11]:; ODE = ode(_cy_rhs_func); code = compile('ODE.set_f_params(' + config.string + ')',; '<string>', 'exec'); exec(code); elif config.tflag == 2:; ODE = ode(_cRHStd); ODE.set_f_params(config); elif config.tflag in [20, 22]:; if config.options.rhs_with_state:; ODE = ode(_tdRHStd_with_state); else:; ODE = ode(_tdRHStd); ODE.set_f_params(config); elif config.tflag == 3:; if config.options.rhs_with_state:; ODE = ode(_pyRHSc_with_state); else:; ODE = ode(_pyRHSc); ODE.set_f_params(config); else:; ODE = ode(cy_ode_rhs); ODE.set_f_params(config.h_data, config.h_ind, config.h_ptr). # initialize ODE solver for RHS; ODE.set_integrator('zvode', method=opt.method, order=opt.order,; atol=opt.atol, rtol=opt.rtol, nsteps=opt.nsteps,; first_step=opt.first_step, min_step=opt.min_step,; max_step=opt.max_step); # set initial conditions; ODE.set_initial_value(config.psi0, config.tlist[0]); psi_out[0] = Qobj(config.psi0, config.psi0_dims,; config.psi0_shape); for k in range(1, num_times):; ODE.integrate(config.tlist[k], step=0) # integrate up to tlist[k]; if ODE.successful():; state = ODE.y / dznrm2(ODE.y); psi_out[k] = Qobj(state, config.psi0_dims, config.psi0_shape); for jj in range(config.e_num):; expect_out[jj][k] = cy_expect_psi_csr(; config.e_ops_data[jj], config.e_ops_ind[jj],; config.e_ops_ptr[jj], state,; config.e_ops_isherm[jj]); else:; raise ValueError('Error in ODE solver'). return expect_out, psi_out. # -----------------------------------------------------------------------------; # evolution solver: return expectati",MatchSource.WIKI,docs/4.2/modules/qutip/mcsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html
https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:17907,Modifiability,config,config,17907,"ray of zeros; expect_out.append(np.zeros(num_times, dtype=float)); else:; # preallocate complex array of zeros; expect_out.append(np.zeros(num_times, dtype=complex)). expect_out[i][0] = \; cy_expect_psi_csr(config.e_ops_data[i],; config.e_ops_ind[i],; config.e_ops_ptr[i],; config.psi0,; config.e_ops_isherm[i]). if debug:; print(inspect.stack()[0][3]). if not _cy_rhs_func:; _mc_func_load(config). opt = config.options; if config.tflag in [1, 10, 11]:; ODE = ode(_cy_rhs_func); code = compile('ODE.set_f_params(' + config.string + ')',; '<string>', 'exec'); exec(code); elif config.tflag == 2:; ODE = ode(_cRHStd); ODE.set_f_params(config); elif config.tflag in [20, 22]:; if config.options.rhs_with_state:; ODE = ode(_tdRHStd_with_state); else:; ODE = ode(_tdRHStd); ODE.set_f_params(config); elif config.tflag == 3:; if config.options.rhs_with_state:; ODE = ode(_pyRHSc_with_state); else:; ODE = ode(_pyRHSc); ODE.set_f_params(config); else:; ODE = ode(cy_ode_rhs); ODE.set_f_params(config.h_data, config.h_ind, config.h_ptr). # initialize ODE solver for RHS; ODE.set_integrator('zvode', method=opt.method, order=opt.order,; atol=opt.atol, rtol=opt.rtol, nsteps=opt.nsteps,; first_step=opt.first_step, min_step=opt.min_step,; max_step=opt.max_step); # set initial conditions; ODE.set_initial_value(config.psi0, config.tlist[0]); psi_out[0] = Qobj(config.psi0, config.psi0_dims,; config.psi0_shape); for k in range(1, num_times):; ODE.integrate(config.tlist[k], step=0) # integrate up to tlist[k]; if ODE.successful():; state = ODE.y / dznrm2(ODE.y); psi_out[k] = Qobj(state, config.psi0_dims, config.psi0_shape); for jj in range(config.e_num):; expect_out[jj][k] = cy_expect_psi_csr(; config.e_ops_data[jj], config.e_ops_ind[jj],; config.e_ops_ptr[jj], state,; config.e_ops_isherm[jj]); else:; raise ValueError('Error in ODE solver'). return expect_out, psi_out. # -----------------------------------------------------------------------------; # evolution solver: return expectation values at reque",MatchSource.WIKI,docs/4.2/modules/qutip/mcsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html
https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:17921,Modifiability,config,config,17921,"xpect_out.append(np.zeros(num_times, dtype=float)); else:; # preallocate complex array of zeros; expect_out.append(np.zeros(num_times, dtype=complex)). expect_out[i][0] = \; cy_expect_psi_csr(config.e_ops_data[i],; config.e_ops_ind[i],; config.e_ops_ptr[i],; config.psi0,; config.e_ops_isherm[i]). if debug:; print(inspect.stack()[0][3]). if not _cy_rhs_func:; _mc_func_load(config). opt = config.options; if config.tflag in [1, 10, 11]:; ODE = ode(_cy_rhs_func); code = compile('ODE.set_f_params(' + config.string + ')',; '<string>', 'exec'); exec(code); elif config.tflag == 2:; ODE = ode(_cRHStd); ODE.set_f_params(config); elif config.tflag in [20, 22]:; if config.options.rhs_with_state:; ODE = ode(_tdRHStd_with_state); else:; ODE = ode(_tdRHStd); ODE.set_f_params(config); elif config.tflag == 3:; if config.options.rhs_with_state:; ODE = ode(_pyRHSc_with_state); else:; ODE = ode(_pyRHSc); ODE.set_f_params(config); else:; ODE = ode(cy_ode_rhs); ODE.set_f_params(config.h_data, config.h_ind, config.h_ptr). # initialize ODE solver for RHS; ODE.set_integrator('zvode', method=opt.method, order=opt.order,; atol=opt.atol, rtol=opt.rtol, nsteps=opt.nsteps,; first_step=opt.first_step, min_step=opt.min_step,; max_step=opt.max_step); # set initial conditions; ODE.set_initial_value(config.psi0, config.tlist[0]); psi_out[0] = Qobj(config.psi0, config.psi0_dims,; config.psi0_shape); for k in range(1, num_times):; ODE.integrate(config.tlist[k], step=0) # integrate up to tlist[k]; if ODE.successful():; state = ODE.y / dznrm2(ODE.y); psi_out[k] = Qobj(state, config.psi0_dims, config.psi0_shape); for jj in range(config.e_num):; expect_out[jj][k] = cy_expect_psi_csr(; config.e_ops_data[jj], config.e_ops_ind[jj],; config.e_ops_ptr[jj], state,; config.e_ops_isherm[jj]); else:; raise ValueError('Error in ODE solver'). return expect_out, psi_out. # -----------------------------------------------------------------------------; # evolution solver: return expectation values at requested times for",MatchSource.WIKI,docs/4.2/modules/qutip/mcsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html
https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:18207,Modifiability,config,config,18207,"e_ops_isherm[i]). if debug:; print(inspect.stack()[0][3]). if not _cy_rhs_func:; _mc_func_load(config). opt = config.options; if config.tflag in [1, 10, 11]:; ODE = ode(_cy_rhs_func); code = compile('ODE.set_f_params(' + config.string + ')',; '<string>', 'exec'); exec(code); elif config.tflag == 2:; ODE = ode(_cRHStd); ODE.set_f_params(config); elif config.tflag in [20, 22]:; if config.options.rhs_with_state:; ODE = ode(_tdRHStd_with_state); else:; ODE = ode(_tdRHStd); ODE.set_f_params(config); elif config.tflag == 3:; if config.options.rhs_with_state:; ODE = ode(_pyRHSc_with_state); else:; ODE = ode(_pyRHSc); ODE.set_f_params(config); else:; ODE = ode(cy_ode_rhs); ODE.set_f_params(config.h_data, config.h_ind, config.h_ptr). # initialize ODE solver for RHS; ODE.set_integrator('zvode', method=opt.method, order=opt.order,; atol=opt.atol, rtol=opt.rtol, nsteps=opt.nsteps,; first_step=opt.first_step, min_step=opt.min_step,; max_step=opt.max_step); # set initial conditions; ODE.set_initial_value(config.psi0, config.tlist[0]); psi_out[0] = Qobj(config.psi0, config.psi0_dims,; config.psi0_shape); for k in range(1, num_times):; ODE.integrate(config.tlist[k], step=0) # integrate up to tlist[k]; if ODE.successful():; state = ODE.y / dznrm2(ODE.y); psi_out[k] = Qobj(state, config.psi0_dims, config.psi0_shape); for jj in range(config.e_num):; expect_out[jj][k] = cy_expect_psi_csr(; config.e_ops_data[jj], config.e_ops_ind[jj],; config.e_ops_ptr[jj], state,; config.e_ops_isherm[jj]); else:; raise ValueError('Error in ODE solver'). return expect_out, psi_out. # -----------------------------------------------------------------------------; # evolution solver: return expectation values at requested times for no; # collapse oper; # -----------------------------------------------------------------------------; def _evolve_no_collapse_expect_out(config):; """"""; Calculates expect.values at times tlist if no collapse ops. given; """""". global _cy_rhs_func; global _cy_col_spmv_func, _cy_col_e",MatchSource.WIKI,docs/4.2/modules/qutip/mcsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html
https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:18220,Modifiability,config,config,18220,"f debug:; print(inspect.stack()[0][3]). if not _cy_rhs_func:; _mc_func_load(config). opt = config.options; if config.tflag in [1, 10, 11]:; ODE = ode(_cy_rhs_func); code = compile('ODE.set_f_params(' + config.string + ')',; '<string>', 'exec'); exec(code); elif config.tflag == 2:; ODE = ode(_cRHStd); ODE.set_f_params(config); elif config.tflag in [20, 22]:; if config.options.rhs_with_state:; ODE = ode(_tdRHStd_with_state); else:; ODE = ode(_tdRHStd); ODE.set_f_params(config); elif config.tflag == 3:; if config.options.rhs_with_state:; ODE = ode(_pyRHSc_with_state); else:; ODE = ode(_pyRHSc); ODE.set_f_params(config); else:; ODE = ode(cy_ode_rhs); ODE.set_f_params(config.h_data, config.h_ind, config.h_ptr). # initialize ODE solver for RHS; ODE.set_integrator('zvode', method=opt.method, order=opt.order,; atol=opt.atol, rtol=opt.rtol, nsteps=opt.nsteps,; first_step=opt.first_step, min_step=opt.min_step,; max_step=opt.max_step); # set initial conditions; ODE.set_initial_value(config.psi0, config.tlist[0]); psi_out[0] = Qobj(config.psi0, config.psi0_dims,; config.psi0_shape); for k in range(1, num_times):; ODE.integrate(config.tlist[k], step=0) # integrate up to tlist[k]; if ODE.successful():; state = ODE.y / dznrm2(ODE.y); psi_out[k] = Qobj(state, config.psi0_dims, config.psi0_shape); for jj in range(config.e_num):; expect_out[jj][k] = cy_expect_psi_csr(; config.e_ops_data[jj], config.e_ops_ind[jj],; config.e_ops_ptr[jj], state,; config.e_ops_isherm[jj]); else:; raise ValueError('Error in ODE solver'). return expect_out, psi_out. # -----------------------------------------------------------------------------; # evolution solver: return expectation values at requested times for no; # collapse oper; # -----------------------------------------------------------------------------; def _evolve_no_collapse_expect_out(config):; """"""; Calculates expect.values at times tlist if no collapse ops. given; """""". global _cy_rhs_func; global _cy_col_spmv_func, _cy_col_expect_func; global ",MatchSource.WIKI,docs/4.2/modules/qutip/mcsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html
https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:18256,Modifiability,config,config,18256,"tack()[0][3]). if not _cy_rhs_func:; _mc_func_load(config). opt = config.options; if config.tflag in [1, 10, 11]:; ODE = ode(_cy_rhs_func); code = compile('ODE.set_f_params(' + config.string + ')',; '<string>', 'exec'); exec(code); elif config.tflag == 2:; ODE = ode(_cRHStd); ODE.set_f_params(config); elif config.tflag in [20, 22]:; if config.options.rhs_with_state:; ODE = ode(_tdRHStd_with_state); else:; ODE = ode(_tdRHStd); ODE.set_f_params(config); elif config.tflag == 3:; if config.options.rhs_with_state:; ODE = ode(_pyRHSc_with_state); else:; ODE = ode(_pyRHSc); ODE.set_f_params(config); else:; ODE = ode(cy_ode_rhs); ODE.set_f_params(config.h_data, config.h_ind, config.h_ptr). # initialize ODE solver for RHS; ODE.set_integrator('zvode', method=opt.method, order=opt.order,; atol=opt.atol, rtol=opt.rtol, nsteps=opt.nsteps,; first_step=opt.first_step, min_step=opt.min_step,; max_step=opt.max_step); # set initial conditions; ODE.set_initial_value(config.psi0, config.tlist[0]); psi_out[0] = Qobj(config.psi0, config.psi0_dims,; config.psi0_shape); for k in range(1, num_times):; ODE.integrate(config.tlist[k], step=0) # integrate up to tlist[k]; if ODE.successful():; state = ODE.y / dznrm2(ODE.y); psi_out[k] = Qobj(state, config.psi0_dims, config.psi0_shape); for jj in range(config.e_num):; expect_out[jj][k] = cy_expect_psi_csr(; config.e_ops_data[jj], config.e_ops_ind[jj],; config.e_ops_ptr[jj], state,; config.e_ops_isherm[jj]); else:; raise ValueError('Error in ODE solver'). return expect_out, psi_out. # -----------------------------------------------------------------------------; # evolution solver: return expectation values at requested times for no; # collapse oper; # -----------------------------------------------------------------------------; def _evolve_no_collapse_expect_out(config):; """"""; Calculates expect.values at times tlist if no collapse ops. given; """""". global _cy_rhs_func; global _cy_col_spmv_func, _cy_col_expect_func; global _cy_col_spmv_call_func, ",MatchSource.WIKI,docs/4.2/modules/qutip/mcsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html
https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:18269,Modifiability,config,config,18269,"y_rhs_func:; _mc_func_load(config). opt = config.options; if config.tflag in [1, 10, 11]:; ODE = ode(_cy_rhs_func); code = compile('ODE.set_f_params(' + config.string + ')',; '<string>', 'exec'); exec(code); elif config.tflag == 2:; ODE = ode(_cRHStd); ODE.set_f_params(config); elif config.tflag in [20, 22]:; if config.options.rhs_with_state:; ODE = ode(_tdRHStd_with_state); else:; ODE = ode(_tdRHStd); ODE.set_f_params(config); elif config.tflag == 3:; if config.options.rhs_with_state:; ODE = ode(_pyRHSc_with_state); else:; ODE = ode(_pyRHSc); ODE.set_f_params(config); else:; ODE = ode(cy_ode_rhs); ODE.set_f_params(config.h_data, config.h_ind, config.h_ptr). # initialize ODE solver for RHS; ODE.set_integrator('zvode', method=opt.method, order=opt.order,; atol=opt.atol, rtol=opt.rtol, nsteps=opt.nsteps,; first_step=opt.first_step, min_step=opt.min_step,; max_step=opt.max_step); # set initial conditions; ODE.set_initial_value(config.psi0, config.tlist[0]); psi_out[0] = Qobj(config.psi0, config.psi0_dims,; config.psi0_shape); for k in range(1, num_times):; ODE.integrate(config.tlist[k], step=0) # integrate up to tlist[k]; if ODE.successful():; state = ODE.y / dznrm2(ODE.y); psi_out[k] = Qobj(state, config.psi0_dims, config.psi0_shape); for jj in range(config.e_num):; expect_out[jj][k] = cy_expect_psi_csr(; config.e_ops_data[jj], config.e_ops_ind[jj],; config.e_ops_ptr[jj], state,; config.e_ops_isherm[jj]); else:; raise ValueError('Error in ODE solver'). return expect_out, psi_out. # -----------------------------------------------------------------------------; # evolution solver: return expectation values at requested times for no; # collapse oper; # -----------------------------------------------------------------------------; def _evolve_no_collapse_expect_out(config):; """"""; Calculates expect.values at times tlist if no collapse ops. given; """""". global _cy_rhs_func; global _cy_col_spmv_func, _cy_col_expect_func; global _cy_col_spmv_call_func, _cy_col_expect_call_func.",MatchSource.WIKI,docs/4.2/modules/qutip/mcsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html
https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:18288,Modifiability,config,config,18288,"_func_load(config). opt = config.options; if config.tflag in [1, 10, 11]:; ODE = ode(_cy_rhs_func); code = compile('ODE.set_f_params(' + config.string + ')',; '<string>', 'exec'); exec(code); elif config.tflag == 2:; ODE = ode(_cRHStd); ODE.set_f_params(config); elif config.tflag in [20, 22]:; if config.options.rhs_with_state:; ODE = ode(_tdRHStd_with_state); else:; ODE = ode(_tdRHStd); ODE.set_f_params(config); elif config.tflag == 3:; if config.options.rhs_with_state:; ODE = ode(_pyRHSc_with_state); else:; ODE = ode(_pyRHSc); ODE.set_f_params(config); else:; ODE = ode(cy_ode_rhs); ODE.set_f_params(config.h_data, config.h_ind, config.h_ptr). # initialize ODE solver for RHS; ODE.set_integrator('zvode', method=opt.method, order=opt.order,; atol=opt.atol, rtol=opt.rtol, nsteps=opt.nsteps,; first_step=opt.first_step, min_step=opt.min_step,; max_step=opt.max_step); # set initial conditions; ODE.set_initial_value(config.psi0, config.tlist[0]); psi_out[0] = Qobj(config.psi0, config.psi0_dims,; config.psi0_shape); for k in range(1, num_times):; ODE.integrate(config.tlist[k], step=0) # integrate up to tlist[k]; if ODE.successful():; state = ODE.y / dznrm2(ODE.y); psi_out[k] = Qobj(state, config.psi0_dims, config.psi0_shape); for jj in range(config.e_num):; expect_out[jj][k] = cy_expect_psi_csr(; config.e_ops_data[jj], config.e_ops_ind[jj],; config.e_ops_ptr[jj], state,; config.e_ops_isherm[jj]); else:; raise ValueError('Error in ODE solver'). return expect_out, psi_out. # -----------------------------------------------------------------------------; # evolution solver: return expectation values at requested times for no; # collapse oper; # -----------------------------------------------------------------------------; def _evolve_no_collapse_expect_out(config):; """"""; Calculates expect.values at times tlist if no collapse ops. given; """""". global _cy_rhs_func; global _cy_col_spmv_func, _cy_col_expect_func; global _cy_col_spmv_call_func, _cy_col_expect_call_func. if debug:; prin",MatchSource.WIKI,docs/4.2/modules/qutip/mcsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html
https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:18353,Modifiability,config,config,18353,"0, 11]:; ODE = ode(_cy_rhs_func); code = compile('ODE.set_f_params(' + config.string + ')',; '<string>', 'exec'); exec(code); elif config.tflag == 2:; ODE = ode(_cRHStd); ODE.set_f_params(config); elif config.tflag in [20, 22]:; if config.options.rhs_with_state:; ODE = ode(_tdRHStd_with_state); else:; ODE = ode(_tdRHStd); ODE.set_f_params(config); elif config.tflag == 3:; if config.options.rhs_with_state:; ODE = ode(_pyRHSc_with_state); else:; ODE = ode(_pyRHSc); ODE.set_f_params(config); else:; ODE = ode(cy_ode_rhs); ODE.set_f_params(config.h_data, config.h_ind, config.h_ptr). # initialize ODE solver for RHS; ODE.set_integrator('zvode', method=opt.method, order=opt.order,; atol=opt.atol, rtol=opt.rtol, nsteps=opt.nsteps,; first_step=opt.first_step, min_step=opt.min_step,; max_step=opt.max_step); # set initial conditions; ODE.set_initial_value(config.psi0, config.tlist[0]); psi_out[0] = Qobj(config.psi0, config.psi0_dims,; config.psi0_shape); for k in range(1, num_times):; ODE.integrate(config.tlist[k], step=0) # integrate up to tlist[k]; if ODE.successful():; state = ODE.y / dznrm2(ODE.y); psi_out[k] = Qobj(state, config.psi0_dims, config.psi0_shape); for jj in range(config.e_num):; expect_out[jj][k] = cy_expect_psi_csr(; config.e_ops_data[jj], config.e_ops_ind[jj],; config.e_ops_ptr[jj], state,; config.e_ops_isherm[jj]); else:; raise ValueError('Error in ODE solver'). return expect_out, psi_out. # -----------------------------------------------------------------------------; # evolution solver: return expectation values at requested times for no; # collapse oper; # -----------------------------------------------------------------------------; def _evolve_no_collapse_expect_out(config):; """"""; Calculates expect.values at times tlist if no collapse ops. given; """""". global _cy_rhs_func; global _cy_col_spmv_func, _cy_col_expect_func; global _cy_col_spmv_call_func, _cy_col_expect_call_func. if debug:; print(inspect.stack()[0][3]). num_times = len(config.tlist); expect_ou",MatchSource.WIKI,docs/4.2/modules/qutip/mcsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html
https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:18484,Modifiability,config,config,18484,"e); elif config.tflag == 2:; ODE = ode(_cRHStd); ODE.set_f_params(config); elif config.tflag in [20, 22]:; if config.options.rhs_with_state:; ODE = ode(_tdRHStd_with_state); else:; ODE = ode(_tdRHStd); ODE.set_f_params(config); elif config.tflag == 3:; if config.options.rhs_with_state:; ODE = ode(_pyRHSc_with_state); else:; ODE = ode(_pyRHSc); ODE.set_f_params(config); else:; ODE = ode(cy_ode_rhs); ODE.set_f_params(config.h_data, config.h_ind, config.h_ptr). # initialize ODE solver for RHS; ODE.set_integrator('zvode', method=opt.method, order=opt.order,; atol=opt.atol, rtol=opt.rtol, nsteps=opt.nsteps,; first_step=opt.first_step, min_step=opt.min_step,; max_step=opt.max_step); # set initial conditions; ODE.set_initial_value(config.psi0, config.tlist[0]); psi_out[0] = Qobj(config.psi0, config.psi0_dims,; config.psi0_shape); for k in range(1, num_times):; ODE.integrate(config.tlist[k], step=0) # integrate up to tlist[k]; if ODE.successful():; state = ODE.y / dznrm2(ODE.y); psi_out[k] = Qobj(state, config.psi0_dims, config.psi0_shape); for jj in range(config.e_num):; expect_out[jj][k] = cy_expect_psi_csr(; config.e_ops_data[jj], config.e_ops_ind[jj],; config.e_ops_ptr[jj], state,; config.e_ops_isherm[jj]); else:; raise ValueError('Error in ODE solver'). return expect_out, psi_out. # -----------------------------------------------------------------------------; # evolution solver: return expectation values at requested times for no; # collapse oper; # -----------------------------------------------------------------------------; def _evolve_no_collapse_expect_out(config):; """"""; Calculates expect.values at times tlist if no collapse ops. given; """""". global _cy_rhs_func; global _cy_col_spmv_func, _cy_col_expect_func; global _cy_col_spmv_call_func, _cy_col_expect_call_func. if debug:; print(inspect.stack()[0][3]). num_times = len(config.tlist); expect_out = []; for i in range(config.e_num):; if config.e_ops_isherm[i]:; # preallocate real array of zeros; expect_out.append(n",MatchSource.WIKI,docs/4.2/modules/qutip/mcsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html
https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:18502,Modifiability,config,config,18502,"; ODE = ode(_cRHStd); ODE.set_f_params(config); elif config.tflag in [20, 22]:; if config.options.rhs_with_state:; ODE = ode(_tdRHStd_with_state); else:; ODE = ode(_tdRHStd); ODE.set_f_params(config); elif config.tflag == 3:; if config.options.rhs_with_state:; ODE = ode(_pyRHSc_with_state); else:; ODE = ode(_pyRHSc); ODE.set_f_params(config); else:; ODE = ode(cy_ode_rhs); ODE.set_f_params(config.h_data, config.h_ind, config.h_ptr). # initialize ODE solver for RHS; ODE.set_integrator('zvode', method=opt.method, order=opt.order,; atol=opt.atol, rtol=opt.rtol, nsteps=opt.nsteps,; first_step=opt.first_step, min_step=opt.min_step,; max_step=opt.max_step); # set initial conditions; ODE.set_initial_value(config.psi0, config.tlist[0]); psi_out[0] = Qobj(config.psi0, config.psi0_dims,; config.psi0_shape); for k in range(1, num_times):; ODE.integrate(config.tlist[k], step=0) # integrate up to tlist[k]; if ODE.successful():; state = ODE.y / dznrm2(ODE.y); psi_out[k] = Qobj(state, config.psi0_dims, config.psi0_shape); for jj in range(config.e_num):; expect_out[jj][k] = cy_expect_psi_csr(; config.e_ops_data[jj], config.e_ops_ind[jj],; config.e_ops_ptr[jj], state,; config.e_ops_isherm[jj]); else:; raise ValueError('Error in ODE solver'). return expect_out, psi_out. # -----------------------------------------------------------------------------; # evolution solver: return expectation values at requested times for no; # collapse oper; # -----------------------------------------------------------------------------; def _evolve_no_collapse_expect_out(config):; """"""; Calculates expect.values at times tlist if no collapse ops. given; """""". global _cy_rhs_func; global _cy_col_spmv_func, _cy_col_expect_func; global _cy_col_spmv_call_func, _cy_col_expect_call_func. if debug:; print(inspect.stack()[0][3]). num_times = len(config.tlist); expect_out = []; for i in range(config.e_num):; if config.e_ops_isherm[i]:; # preallocate real array of zeros; expect_out.append(np.zeros(num_times, dtype=fl",MatchSource.WIKI,docs/4.2/modules/qutip/mcsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html
https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:18538,Modifiability,config,config,18538,"et_f_params(config); elif config.tflag in [20, 22]:; if config.options.rhs_with_state:; ODE = ode(_tdRHStd_with_state); else:; ODE = ode(_tdRHStd); ODE.set_f_params(config); elif config.tflag == 3:; if config.options.rhs_with_state:; ODE = ode(_pyRHSc_with_state); else:; ODE = ode(_pyRHSc); ODE.set_f_params(config); else:; ODE = ode(cy_ode_rhs); ODE.set_f_params(config.h_data, config.h_ind, config.h_ptr). # initialize ODE solver for RHS; ODE.set_integrator('zvode', method=opt.method, order=opt.order,; atol=opt.atol, rtol=opt.rtol, nsteps=opt.nsteps,; first_step=opt.first_step, min_step=opt.min_step,; max_step=opt.max_step); # set initial conditions; ODE.set_initial_value(config.psi0, config.tlist[0]); psi_out[0] = Qobj(config.psi0, config.psi0_dims,; config.psi0_shape); for k in range(1, num_times):; ODE.integrate(config.tlist[k], step=0) # integrate up to tlist[k]; if ODE.successful():; state = ODE.y / dznrm2(ODE.y); psi_out[k] = Qobj(state, config.psi0_dims, config.psi0_shape); for jj in range(config.e_num):; expect_out[jj][k] = cy_expect_psi_csr(; config.e_ops_data[jj], config.e_ops_ind[jj],; config.e_ops_ptr[jj], state,; config.e_ops_isherm[jj]); else:; raise ValueError('Error in ODE solver'). return expect_out, psi_out. # -----------------------------------------------------------------------------; # evolution solver: return expectation values at requested times for no; # collapse oper; # -----------------------------------------------------------------------------; def _evolve_no_collapse_expect_out(config):; """"""; Calculates expect.values at times tlist if no collapse ops. given; """""". global _cy_rhs_func; global _cy_col_spmv_func, _cy_col_expect_func; global _cy_col_spmv_call_func, _cy_col_expect_call_func. if debug:; print(inspect.stack()[0][3]). num_times = len(config.tlist); expect_out = []; for i in range(config.e_num):; if config.e_ops_isherm[i]:; # preallocate real array of zeros; expect_out.append(np.zeros(num_times, dtype=float)); else:; # preallocate",MatchSource.WIKI,docs/4.2/modules/qutip/mcsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html
https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:18594,Modifiability,config,config,18594," 22]:; if config.options.rhs_with_state:; ODE = ode(_tdRHStd_with_state); else:; ODE = ode(_tdRHStd); ODE.set_f_params(config); elif config.tflag == 3:; if config.options.rhs_with_state:; ODE = ode(_pyRHSc_with_state); else:; ODE = ode(_pyRHSc); ODE.set_f_params(config); else:; ODE = ode(cy_ode_rhs); ODE.set_f_params(config.h_data, config.h_ind, config.h_ptr). # initialize ODE solver for RHS; ODE.set_integrator('zvode', method=opt.method, order=opt.order,; atol=opt.atol, rtol=opt.rtol, nsteps=opt.nsteps,; first_step=opt.first_step, min_step=opt.min_step,; max_step=opt.max_step); # set initial conditions; ODE.set_initial_value(config.psi0, config.tlist[0]); psi_out[0] = Qobj(config.psi0, config.psi0_dims,; config.psi0_shape); for k in range(1, num_times):; ODE.integrate(config.tlist[k], step=0) # integrate up to tlist[k]; if ODE.successful():; state = ODE.y / dznrm2(ODE.y); psi_out[k] = Qobj(state, config.psi0_dims, config.psi0_shape); for jj in range(config.e_num):; expect_out[jj][k] = cy_expect_psi_csr(; config.e_ops_data[jj], config.e_ops_ind[jj],; config.e_ops_ptr[jj], state,; config.e_ops_isherm[jj]); else:; raise ValueError('Error in ODE solver'). return expect_out, psi_out. # -----------------------------------------------------------------------------; # evolution solver: return expectation values at requested times for no; # collapse oper; # -----------------------------------------------------------------------------; def _evolve_no_collapse_expect_out(config):; """"""; Calculates expect.values at times tlist if no collapse ops. given; """""". global _cy_rhs_func; global _cy_col_spmv_func, _cy_col_expect_func; global _cy_col_spmv_call_func, _cy_col_expect_call_func. if debug:; print(inspect.stack()[0][3]). num_times = len(config.tlist); expect_out = []; for i in range(config.e_num):; if config.e_ops_isherm[i]:; # preallocate real array of zeros; expect_out.append(np.zeros(num_times, dtype=float)); else:; # preallocate complex array of zeros; expect_out.append(np.",MatchSource.WIKI,docs/4.2/modules/qutip/mcsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html
https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:18617,Modifiability,config,config,18617,":; ODE = ode(_tdRHStd_with_state); else:; ODE = ode(_tdRHStd); ODE.set_f_params(config); elif config.tflag == 3:; if config.options.rhs_with_state:; ODE = ode(_pyRHSc_with_state); else:; ODE = ode(_pyRHSc); ODE.set_f_params(config); else:; ODE = ode(cy_ode_rhs); ODE.set_f_params(config.h_data, config.h_ind, config.h_ptr). # initialize ODE solver for RHS; ODE.set_integrator('zvode', method=opt.method, order=opt.order,; atol=opt.atol, rtol=opt.rtol, nsteps=opt.nsteps,; first_step=opt.first_step, min_step=opt.min_step,; max_step=opt.max_step); # set initial conditions; ODE.set_initial_value(config.psi0, config.tlist[0]); psi_out[0] = Qobj(config.psi0, config.psi0_dims,; config.psi0_shape); for k in range(1, num_times):; ODE.integrate(config.tlist[k], step=0) # integrate up to tlist[k]; if ODE.successful():; state = ODE.y / dznrm2(ODE.y); psi_out[k] = Qobj(state, config.psi0_dims, config.psi0_shape); for jj in range(config.e_num):; expect_out[jj][k] = cy_expect_psi_csr(; config.e_ops_data[jj], config.e_ops_ind[jj],; config.e_ops_ptr[jj], state,; config.e_ops_isherm[jj]); else:; raise ValueError('Error in ODE solver'). return expect_out, psi_out. # -----------------------------------------------------------------------------; # evolution solver: return expectation values at requested times for no; # collapse oper; # -----------------------------------------------------------------------------; def _evolve_no_collapse_expect_out(config):; """"""; Calculates expect.values at times tlist if no collapse ops. given; """""". global _cy_rhs_func; global _cy_col_spmv_func, _cy_col_expect_func; global _cy_col_spmv_call_func, _cy_col_expect_call_func. if debug:; print(inspect.stack()[0][3]). num_times = len(config.tlist); expect_out = []; for i in range(config.e_num):; if config.e_ops_isherm[i]:; # preallocate real array of zeros; expect_out.append(np.zeros(num_times, dtype=float)); else:; # preallocate complex array of zeros; expect_out.append(np.zeros(num_times, dtype=complex)). expect",MatchSource.WIKI,docs/4.2/modules/qutip/mcsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html
https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:18640,Modifiability,config,config,18640,"ith_state); else:; ODE = ode(_tdRHStd); ODE.set_f_params(config); elif config.tflag == 3:; if config.options.rhs_with_state:; ODE = ode(_pyRHSc_with_state); else:; ODE = ode(_pyRHSc); ODE.set_f_params(config); else:; ODE = ode(cy_ode_rhs); ODE.set_f_params(config.h_data, config.h_ind, config.h_ptr). # initialize ODE solver for RHS; ODE.set_integrator('zvode', method=opt.method, order=opt.order,; atol=opt.atol, rtol=opt.rtol, nsteps=opt.nsteps,; first_step=opt.first_step, min_step=opt.min_step,; max_step=opt.max_step); # set initial conditions; ODE.set_initial_value(config.psi0, config.tlist[0]); psi_out[0] = Qobj(config.psi0, config.psi0_dims,; config.psi0_shape); for k in range(1, num_times):; ODE.integrate(config.tlist[k], step=0) # integrate up to tlist[k]; if ODE.successful():; state = ODE.y / dznrm2(ODE.y); psi_out[k] = Qobj(state, config.psi0_dims, config.psi0_shape); for jj in range(config.e_num):; expect_out[jj][k] = cy_expect_psi_csr(; config.e_ops_data[jj], config.e_ops_ind[jj],; config.e_ops_ptr[jj], state,; config.e_ops_isherm[jj]); else:; raise ValueError('Error in ODE solver'). return expect_out, psi_out. # -----------------------------------------------------------------------------; # evolution solver: return expectation values at requested times for no; # collapse oper; # -----------------------------------------------------------------------------; def _evolve_no_collapse_expect_out(config):; """"""; Calculates expect.values at times tlist if no collapse ops. given; """""". global _cy_rhs_func; global _cy_col_spmv_func, _cy_col_expect_func; global _cy_col_spmv_call_func, _cy_col_expect_call_func. if debug:; print(inspect.stack()[0][3]). num_times = len(config.tlist); expect_out = []; for i in range(config.e_num):; if config.e_ops_isherm[i]:; # preallocate real array of zeros; expect_out.append(np.zeros(num_times, dtype=float)); else:; # preallocate complex array of zeros; expect_out.append(np.zeros(num_times, dtype=complex)). expect_out[i][0] = \; cy_expe",MatchSource.WIKI,docs/4.2/modules/qutip/mcsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html
https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:18670,Modifiability,config,config,18670,"e(_tdRHStd); ODE.set_f_params(config); elif config.tflag == 3:; if config.options.rhs_with_state:; ODE = ode(_pyRHSc_with_state); else:; ODE = ode(_pyRHSc); ODE.set_f_params(config); else:; ODE = ode(cy_ode_rhs); ODE.set_f_params(config.h_data, config.h_ind, config.h_ptr). # initialize ODE solver for RHS; ODE.set_integrator('zvode', method=opt.method, order=opt.order,; atol=opt.atol, rtol=opt.rtol, nsteps=opt.nsteps,; first_step=opt.first_step, min_step=opt.min_step,; max_step=opt.max_step); # set initial conditions; ODE.set_initial_value(config.psi0, config.tlist[0]); psi_out[0] = Qobj(config.psi0, config.psi0_dims,; config.psi0_shape); for k in range(1, num_times):; ODE.integrate(config.tlist[k], step=0) # integrate up to tlist[k]; if ODE.successful():; state = ODE.y / dznrm2(ODE.y); psi_out[k] = Qobj(state, config.psi0_dims, config.psi0_shape); for jj in range(config.e_num):; expect_out[jj][k] = cy_expect_psi_csr(; config.e_ops_data[jj], config.e_ops_ind[jj],; config.e_ops_ptr[jj], state,; config.e_ops_isherm[jj]); else:; raise ValueError('Error in ODE solver'). return expect_out, psi_out. # -----------------------------------------------------------------------------; # evolution solver: return expectation values at requested times for no; # collapse oper; # -----------------------------------------------------------------------------; def _evolve_no_collapse_expect_out(config):; """"""; Calculates expect.values at times tlist if no collapse ops. given; """""". global _cy_rhs_func; global _cy_col_spmv_func, _cy_col_expect_func; global _cy_col_spmv_call_func, _cy_col_expect_call_func. if debug:; print(inspect.stack()[0][3]). num_times = len(config.tlist); expect_out = []; for i in range(config.e_num):; if config.e_ops_isherm[i]:; # preallocate real array of zeros; expect_out.append(np.zeros(num_times, dtype=float)); else:; # preallocate complex array of zeros; expect_out.append(np.zeros(num_times, dtype=complex)). expect_out[i][0] = \; cy_expect_psi_csr(config.e_ops_da",MatchSource.WIKI,docs/4.2/modules/qutip/mcsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html
https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:19059,Modifiability,config,config,19059,"tr). # initialize ODE solver for RHS; ODE.set_integrator('zvode', method=opt.method, order=opt.order,; atol=opt.atol, rtol=opt.rtol, nsteps=opt.nsteps,; first_step=opt.first_step, min_step=opt.min_step,; max_step=opt.max_step); # set initial conditions; ODE.set_initial_value(config.psi0, config.tlist[0]); psi_out[0] = Qobj(config.psi0, config.psi0_dims,; config.psi0_shape); for k in range(1, num_times):; ODE.integrate(config.tlist[k], step=0) # integrate up to tlist[k]; if ODE.successful():; state = ODE.y / dznrm2(ODE.y); psi_out[k] = Qobj(state, config.psi0_dims, config.psi0_shape); for jj in range(config.e_num):; expect_out[jj][k] = cy_expect_psi_csr(; config.e_ops_data[jj], config.e_ops_ind[jj],; config.e_ops_ptr[jj], state,; config.e_ops_isherm[jj]); else:; raise ValueError('Error in ODE solver'). return expect_out, psi_out. # -----------------------------------------------------------------------------; # evolution solver: return expectation values at requested times for no; # collapse oper; # -----------------------------------------------------------------------------; def _evolve_no_collapse_expect_out(config):; """"""; Calculates expect.values at times tlist if no collapse ops. given; """""". global _cy_rhs_func; global _cy_col_spmv_func, _cy_col_expect_func; global _cy_col_spmv_call_func, _cy_col_expect_call_func. if debug:; print(inspect.stack()[0][3]). num_times = len(config.tlist); expect_out = []; for i in range(config.e_num):; if config.e_ops_isherm[i]:; # preallocate real array of zeros; expect_out.append(np.zeros(num_times, dtype=float)); else:; # preallocate complex array of zeros; expect_out.append(np.zeros(num_times, dtype=complex)). expect_out[i][0] = \; cy_expect_psi_csr(config.e_ops_data[i],; config.e_ops_ind[i],; config.e_ops_ptr[i],; config.psi0,; config.e_ops_isherm[i]). if not _cy_rhs_func:; _mc_func_load(config). opt = config.options; if config.tflag in [1, 10, 11]:; ODE = ode(_cy_rhs_func); code = compile('ODE.set_f_params(' + config.string + '",MatchSource.WIKI,docs/4.2/modules/qutip/mcsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html
https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:19328,Modifiability,config,config,19328,"1, num_times):; ODE.integrate(config.tlist[k], step=0) # integrate up to tlist[k]; if ODE.successful():; state = ODE.y / dznrm2(ODE.y); psi_out[k] = Qobj(state, config.psi0_dims, config.psi0_shape); for jj in range(config.e_num):; expect_out[jj][k] = cy_expect_psi_csr(; config.e_ops_data[jj], config.e_ops_ind[jj],; config.e_ops_ptr[jj], state,; config.e_ops_isherm[jj]); else:; raise ValueError('Error in ODE solver'). return expect_out, psi_out. # -----------------------------------------------------------------------------; # evolution solver: return expectation values at requested times for no; # collapse oper; # -----------------------------------------------------------------------------; def _evolve_no_collapse_expect_out(config):; """"""; Calculates expect.values at times tlist if no collapse ops. given; """""". global _cy_rhs_func; global _cy_col_spmv_func, _cy_col_expect_func; global _cy_col_spmv_call_func, _cy_col_expect_call_func. if debug:; print(inspect.stack()[0][3]). num_times = len(config.tlist); expect_out = []; for i in range(config.e_num):; if config.e_ops_isherm[i]:; # preallocate real array of zeros; expect_out.append(np.zeros(num_times, dtype=float)); else:; # preallocate complex array of zeros; expect_out.append(np.zeros(num_times, dtype=complex)). expect_out[i][0] = \; cy_expect_psi_csr(config.e_ops_data[i],; config.e_ops_ind[i],; config.e_ops_ptr[i],; config.psi0,; config.e_ops_isherm[i]). if not _cy_rhs_func:; _mc_func_load(config). opt = config.options; if config.tflag in [1, 10, 11]:; ODE = ode(_cy_rhs_func); code = compile('ODE.set_f_params(' + config.string + ')',; '<string>', 'exec'); exec(code); elif config.tflag == 2:; ODE = ode(_cRHStd); ODE.set_f_params(config); elif config.tflag in [20, 22]:; if config.options.rhs_with_state:; ODE = ode(_tdRHStd_with_state); else:; ODE = ode(_tdRHStd); ODE.set_f_params(config); elif config.tflag == 3:; if config.options.rhs_with_state:; ODE = ode(_pyRHSc_with_state); else:; ODE = ode(_pyRHSc); ODE.set_f_p",MatchSource.WIKI,docs/4.2/modules/qutip/mcsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html
https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:19375,Modifiability,config,config,19375,"g.tlist[k], step=0) # integrate up to tlist[k]; if ODE.successful():; state = ODE.y / dznrm2(ODE.y); psi_out[k] = Qobj(state, config.psi0_dims, config.psi0_shape); for jj in range(config.e_num):; expect_out[jj][k] = cy_expect_psi_csr(; config.e_ops_data[jj], config.e_ops_ind[jj],; config.e_ops_ptr[jj], state,; config.e_ops_isherm[jj]); else:; raise ValueError('Error in ODE solver'). return expect_out, psi_out. # -----------------------------------------------------------------------------; # evolution solver: return expectation values at requested times for no; # collapse oper; # -----------------------------------------------------------------------------; def _evolve_no_collapse_expect_out(config):; """"""; Calculates expect.values at times tlist if no collapse ops. given; """""". global _cy_rhs_func; global _cy_col_spmv_func, _cy_col_expect_func; global _cy_col_spmv_call_func, _cy_col_expect_call_func. if debug:; print(inspect.stack()[0][3]). num_times = len(config.tlist); expect_out = []; for i in range(config.e_num):; if config.e_ops_isherm[i]:; # preallocate real array of zeros; expect_out.append(np.zeros(num_times, dtype=float)); else:; # preallocate complex array of zeros; expect_out.append(np.zeros(num_times, dtype=complex)). expect_out[i][0] = \; cy_expect_psi_csr(config.e_ops_data[i],; config.e_ops_ind[i],; config.e_ops_ptr[i],; config.psi0,; config.e_ops_isherm[i]). if not _cy_rhs_func:; _mc_func_load(config). opt = config.options; if config.tflag in [1, 10, 11]:; ODE = ode(_cy_rhs_func); code = compile('ODE.set_f_params(' + config.string + ')',; '<string>', 'exec'); exec(code); elif config.tflag == 2:; ODE = ode(_cRHStd); ODE.set_f_params(config); elif config.tflag in [20, 22]:; if config.options.rhs_with_state:; ODE = ode(_tdRHStd_with_state); else:; ODE = ode(_tdRHStd); ODE.set_f_params(config); elif config.tflag == 3:; if config.options.rhs_with_state:; ODE = ode(_pyRHSc_with_state); else:; ODE = ode(_pyRHSc); ODE.set_f_params(config); else:; ODE = ode(cy_o",MatchSource.WIKI,docs/4.2/modules/qutip/mcsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html
https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:19394,Modifiability,config,config,19394,"p to tlist[k]; if ODE.successful():; state = ODE.y / dznrm2(ODE.y); psi_out[k] = Qobj(state, config.psi0_dims, config.psi0_shape); for jj in range(config.e_num):; expect_out[jj][k] = cy_expect_psi_csr(; config.e_ops_data[jj], config.e_ops_ind[jj],; config.e_ops_ptr[jj], state,; config.e_ops_isherm[jj]); else:; raise ValueError('Error in ODE solver'). return expect_out, psi_out. # -----------------------------------------------------------------------------; # evolution solver: return expectation values at requested times for no; # collapse oper; # -----------------------------------------------------------------------------; def _evolve_no_collapse_expect_out(config):; """"""; Calculates expect.values at times tlist if no collapse ops. given; """""". global _cy_rhs_func; global _cy_col_spmv_func, _cy_col_expect_func; global _cy_col_spmv_call_func, _cy_col_expect_call_func. if debug:; print(inspect.stack()[0][3]). num_times = len(config.tlist); expect_out = []; for i in range(config.e_num):; if config.e_ops_isherm[i]:; # preallocate real array of zeros; expect_out.append(np.zeros(num_times, dtype=float)); else:; # preallocate complex array of zeros; expect_out.append(np.zeros(num_times, dtype=complex)). expect_out[i][0] = \; cy_expect_psi_csr(config.e_ops_data[i],; config.e_ops_ind[i],; config.e_ops_ptr[i],; config.psi0,; config.e_ops_isherm[i]). if not _cy_rhs_func:; _mc_func_load(config). opt = config.options; if config.tflag in [1, 10, 11]:; ODE = ode(_cy_rhs_func); code = compile('ODE.set_f_params(' + config.string + ')',; '<string>', 'exec'); exec(code); elif config.tflag == 2:; ODE = ode(_cRHStd); ODE.set_f_params(config); elif config.tflag in [20, 22]:; if config.options.rhs_with_state:; ODE = ode(_tdRHStd_with_state); else:; ODE = ode(_tdRHStd); ODE.set_f_params(config); elif config.tflag == 3:; if config.options.rhs_with_state:; ODE = ode(_pyRHSc_with_state); else:; ODE = ode(_pyRHSc); ODE.set_f_params(config); else:; ODE = ode(cy_ode_rhs); ODE.set_f_params(config.",MatchSource.WIKI,docs/4.2/modules/qutip/mcsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html
https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:19647,Modifiability,config,config,19647,"ind[jj],; config.e_ops_ptr[jj], state,; config.e_ops_isherm[jj]); else:; raise ValueError('Error in ODE solver'). return expect_out, psi_out. # -----------------------------------------------------------------------------; # evolution solver: return expectation values at requested times for no; # collapse oper; # -----------------------------------------------------------------------------; def _evolve_no_collapse_expect_out(config):; """"""; Calculates expect.values at times tlist if no collapse ops. given; """""". global _cy_rhs_func; global _cy_col_spmv_func, _cy_col_expect_func; global _cy_col_spmv_call_func, _cy_col_expect_call_func. if debug:; print(inspect.stack()[0][3]). num_times = len(config.tlist); expect_out = []; for i in range(config.e_num):; if config.e_ops_isherm[i]:; # preallocate real array of zeros; expect_out.append(np.zeros(num_times, dtype=float)); else:; # preallocate complex array of zeros; expect_out.append(np.zeros(num_times, dtype=complex)). expect_out[i][0] = \; cy_expect_psi_csr(config.e_ops_data[i],; config.e_ops_ind[i],; config.e_ops_ptr[i],; config.psi0,; config.e_ops_isherm[i]). if not _cy_rhs_func:; _mc_func_load(config). opt = config.options; if config.tflag in [1, 10, 11]:; ODE = ode(_cy_rhs_func); code = compile('ODE.set_f_params(' + config.string + ')',; '<string>', 'exec'); exec(code); elif config.tflag == 2:; ODE = ode(_cRHStd); ODE.set_f_params(config); elif config.tflag in [20, 22]:; if config.options.rhs_with_state:; ODE = ode(_tdRHStd_with_state); else:; ODE = ode(_tdRHStd); ODE.set_f_params(config); elif config.tflag == 3:; if config.options.rhs_with_state:; ODE = ode(_pyRHSc_with_state); else:; ODE = ode(_pyRHSc); ODE.set_f_params(config); else:; ODE = ode(cy_ode_rhs); ODE.set_f_params(config.h_data, config.h_ind, config.h_ptr). ODE.set_integrator('zvode', method=opt.method, order=opt.order,; atol=opt.atol, rtol=opt.rtol, nsteps=opt.nsteps,; first_step=opt.first_step, min_step=opt.min_step,; max_step=opt.max_step); ODE.set_ini",MatchSource.WIKI,docs/4.2/modules/qutip/mcsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html
https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:19670,Modifiability,config,config,19670,"te,; config.e_ops_isherm[jj]); else:; raise ValueError('Error in ODE solver'). return expect_out, psi_out. # -----------------------------------------------------------------------------; # evolution solver: return expectation values at requested times for no; # collapse oper; # -----------------------------------------------------------------------------; def _evolve_no_collapse_expect_out(config):; """"""; Calculates expect.values at times tlist if no collapse ops. given; """""". global _cy_rhs_func; global _cy_col_spmv_func, _cy_col_expect_func; global _cy_col_spmv_call_func, _cy_col_expect_call_func. if debug:; print(inspect.stack()[0][3]). num_times = len(config.tlist); expect_out = []; for i in range(config.e_num):; if config.e_ops_isherm[i]:; # preallocate real array of zeros; expect_out.append(np.zeros(num_times, dtype=float)); else:; # preallocate complex array of zeros; expect_out.append(np.zeros(num_times, dtype=complex)). expect_out[i][0] = \; cy_expect_psi_csr(config.e_ops_data[i],; config.e_ops_ind[i],; config.e_ops_ptr[i],; config.psi0,; config.e_ops_isherm[i]). if not _cy_rhs_func:; _mc_func_load(config). opt = config.options; if config.tflag in [1, 10, 11]:; ODE = ode(_cy_rhs_func); code = compile('ODE.set_f_params(' + config.string + ')',; '<string>', 'exec'); exec(code); elif config.tflag == 2:; ODE = ode(_cRHStd); ODE.set_f_params(config); elif config.tflag in [20, 22]:; if config.options.rhs_with_state:; ODE = ode(_tdRHStd_with_state); else:; ODE = ode(_tdRHStd); ODE.set_f_params(config); elif config.tflag == 3:; if config.options.rhs_with_state:; ODE = ode(_pyRHSc_with_state); else:; ODE = ode(_pyRHSc); ODE.set_f_params(config); else:; ODE = ode(cy_ode_rhs); ODE.set_f_params(config.h_data, config.h_ind, config.h_ptr). ODE.set_integrator('zvode', method=opt.method, order=opt.order,; atol=opt.atol, rtol=opt.rtol, nsteps=opt.nsteps,; first_step=opt.first_step, min_step=opt.min_step,; max_step=opt.max_step); ODE.set_initial_value(config.psi0, config.tlist",MatchSource.WIKI,docs/4.2/modules/qutip/mcsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html
https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:19692,Modifiability,config,config,19692,"m[jj]); else:; raise ValueError('Error in ODE solver'). return expect_out, psi_out. # -----------------------------------------------------------------------------; # evolution solver: return expectation values at requested times for no; # collapse oper; # -----------------------------------------------------------------------------; def _evolve_no_collapse_expect_out(config):; """"""; Calculates expect.values at times tlist if no collapse ops. given; """""". global _cy_rhs_func; global _cy_col_spmv_func, _cy_col_expect_func; global _cy_col_spmv_call_func, _cy_col_expect_call_func. if debug:; print(inspect.stack()[0][3]). num_times = len(config.tlist); expect_out = []; for i in range(config.e_num):; if config.e_ops_isherm[i]:; # preallocate real array of zeros; expect_out.append(np.zeros(num_times, dtype=float)); else:; # preallocate complex array of zeros; expect_out.append(np.zeros(num_times, dtype=complex)). expect_out[i][0] = \; cy_expect_psi_csr(config.e_ops_data[i],; config.e_ops_ind[i],; config.e_ops_ptr[i],; config.psi0,; config.e_ops_isherm[i]). if not _cy_rhs_func:; _mc_func_load(config). opt = config.options; if config.tflag in [1, 10, 11]:; ODE = ode(_cy_rhs_func); code = compile('ODE.set_f_params(' + config.string + ')',; '<string>', 'exec'); exec(code); elif config.tflag == 2:; ODE = ode(_cRHStd); ODE.set_f_params(config); elif config.tflag in [20, 22]:; if config.options.rhs_with_state:; ODE = ode(_tdRHStd_with_state); else:; ODE = ode(_tdRHStd); ODE.set_f_params(config); elif config.tflag == 3:; if config.options.rhs_with_state:; ODE = ode(_pyRHSc_with_state); else:; ODE = ode(_pyRHSc); ODE.set_f_params(config); else:; ODE = ode(cy_ode_rhs); ODE.set_f_params(config.h_data, config.h_ind, config.h_ptr). ODE.set_integrator('zvode', method=opt.method, order=opt.order,; atol=opt.atol, rtol=opt.rtol, nsteps=opt.nsteps,; first_step=opt.first_step, min_step=opt.min_step,; max_step=opt.max_step); ODE.set_initial_value(config.psi0, config.tlist[0]); for jj in range(",MatchSource.WIKI,docs/4.2/modules/qutip/mcsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html
https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:19714,Modifiability,config,config,19714,"alueError('Error in ODE solver'). return expect_out, psi_out. # -----------------------------------------------------------------------------; # evolution solver: return expectation values at requested times for no; # collapse oper; # -----------------------------------------------------------------------------; def _evolve_no_collapse_expect_out(config):; """"""; Calculates expect.values at times tlist if no collapse ops. given; """""". global _cy_rhs_func; global _cy_col_spmv_func, _cy_col_expect_func; global _cy_col_spmv_call_func, _cy_col_expect_call_func. if debug:; print(inspect.stack()[0][3]). num_times = len(config.tlist); expect_out = []; for i in range(config.e_num):; if config.e_ops_isherm[i]:; # preallocate real array of zeros; expect_out.append(np.zeros(num_times, dtype=float)); else:; # preallocate complex array of zeros; expect_out.append(np.zeros(num_times, dtype=complex)). expect_out[i][0] = \; cy_expect_psi_csr(config.e_ops_data[i],; config.e_ops_ind[i],; config.e_ops_ptr[i],; config.psi0,; config.e_ops_isherm[i]). if not _cy_rhs_func:; _mc_func_load(config). opt = config.options; if config.tflag in [1, 10, 11]:; ODE = ode(_cy_rhs_func); code = compile('ODE.set_f_params(' + config.string + ')',; '<string>', 'exec'); exec(code); elif config.tflag == 2:; ODE = ode(_cRHStd); ODE.set_f_params(config); elif config.tflag in [20, 22]:; if config.options.rhs_with_state:; ODE = ode(_tdRHStd_with_state); else:; ODE = ode(_tdRHStd); ODE.set_f_params(config); elif config.tflag == 3:; if config.options.rhs_with_state:; ODE = ode(_pyRHSc_with_state); else:; ODE = ode(_pyRHSc); ODE.set_f_params(config); else:; ODE = ode(cy_ode_rhs); ODE.set_f_params(config.h_data, config.h_ind, config.h_ptr). ODE.set_integrator('zvode', method=opt.method, order=opt.order,; atol=opt.atol, rtol=opt.rtol, nsteps=opt.nsteps,; first_step=opt.first_step, min_step=opt.min_step,; max_step=opt.max_step); ODE.set_initial_value(config.psi0, config.tlist[0]); for jj in range(config.e_num):; expect",MatchSource.WIKI,docs/4.2/modules/qutip/mcsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html
https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:19728,Modifiability,config,config,19728,"n ODE solver'). return expect_out, psi_out. # -----------------------------------------------------------------------------; # evolution solver: return expectation values at requested times for no; # collapse oper; # -----------------------------------------------------------------------------; def _evolve_no_collapse_expect_out(config):; """"""; Calculates expect.values at times tlist if no collapse ops. given; """""". global _cy_rhs_func; global _cy_col_spmv_func, _cy_col_expect_func; global _cy_col_spmv_call_func, _cy_col_expect_call_func. if debug:; print(inspect.stack()[0][3]). num_times = len(config.tlist); expect_out = []; for i in range(config.e_num):; if config.e_ops_isherm[i]:; # preallocate real array of zeros; expect_out.append(np.zeros(num_times, dtype=float)); else:; # preallocate complex array of zeros; expect_out.append(np.zeros(num_times, dtype=complex)). expect_out[i][0] = \; cy_expect_psi_csr(config.e_ops_data[i],; config.e_ops_ind[i],; config.e_ops_ptr[i],; config.psi0,; config.e_ops_isherm[i]). if not _cy_rhs_func:; _mc_func_load(config). opt = config.options; if config.tflag in [1, 10, 11]:; ODE = ode(_cy_rhs_func); code = compile('ODE.set_f_params(' + config.string + ')',; '<string>', 'exec'); exec(code); elif config.tflag == 2:; ODE = ode(_cRHStd); ODE.set_f_params(config); elif config.tflag in [20, 22]:; if config.options.rhs_with_state:; ODE = ode(_tdRHStd_with_state); else:; ODE = ode(_tdRHStd); ODE.set_f_params(config); elif config.tflag == 3:; if config.options.rhs_with_state:; ODE = ode(_pyRHSc_with_state); else:; ODE = ode(_pyRHSc); ODE.set_f_params(config); else:; ODE = ode(cy_ode_rhs); ODE.set_f_params(config.h_data, config.h_ind, config.h_ptr). ODE.set_integrator('zvode', method=opt.method, order=opt.order,; atol=opt.atol, rtol=opt.rtol, nsteps=opt.nsteps,; first_step=opt.first_step, min_step=opt.min_step,; max_step=opt.max_step); ODE.set_initial_value(config.psi0, config.tlist[0]); for jj in range(config.e_num):; expect_out[jj][0] = cy_e",MatchSource.WIKI,docs/4.2/modules/qutip/mcsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html
https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:19789,Modifiability,config,config,19789,"-----------------------------------------------------------------------------; # evolution solver: return expectation values at requested times for no; # collapse oper; # -----------------------------------------------------------------------------; def _evolve_no_collapse_expect_out(config):; """"""; Calculates expect.values at times tlist if no collapse ops. given; """""". global _cy_rhs_func; global _cy_col_spmv_func, _cy_col_expect_func; global _cy_col_spmv_call_func, _cy_col_expect_call_func. if debug:; print(inspect.stack()[0][3]). num_times = len(config.tlist); expect_out = []; for i in range(config.e_num):; if config.e_ops_isherm[i]:; # preallocate real array of zeros; expect_out.append(np.zeros(num_times, dtype=float)); else:; # preallocate complex array of zeros; expect_out.append(np.zeros(num_times, dtype=complex)). expect_out[i][0] = \; cy_expect_psi_csr(config.e_ops_data[i],; config.e_ops_ind[i],; config.e_ops_ptr[i],; config.psi0,; config.e_ops_isherm[i]). if not _cy_rhs_func:; _mc_func_load(config). opt = config.options; if config.tflag in [1, 10, 11]:; ODE = ode(_cy_rhs_func); code = compile('ODE.set_f_params(' + config.string + ')',; '<string>', 'exec'); exec(code); elif config.tflag == 2:; ODE = ode(_cRHStd); ODE.set_f_params(config); elif config.tflag in [20, 22]:; if config.options.rhs_with_state:; ODE = ode(_tdRHStd_with_state); else:; ODE = ode(_tdRHStd); ODE.set_f_params(config); elif config.tflag == 3:; if config.options.rhs_with_state:; ODE = ode(_pyRHSc_with_state); else:; ODE = ode(_pyRHSc); ODE.set_f_params(config); else:; ODE = ode(cy_ode_rhs); ODE.set_f_params(config.h_data, config.h_ind, config.h_ptr). ODE.set_integrator('zvode', method=opt.method, order=opt.order,; atol=opt.atol, rtol=opt.rtol, nsteps=opt.nsteps,; first_step=opt.first_step, min_step=opt.min_step,; max_step=opt.max_step); ODE.set_initial_value(config.psi0, config.tlist[0]); for jj in range(config.e_num):; expect_out[jj][0] = cy_expect_psi_csr(; config.e_ops_data[jj], config.e",MatchSource.WIKI,docs/4.2/modules/qutip/mcsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html
https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:19804,Modifiability,config,config,19804,"-----------------------------------------------; # evolution solver: return expectation values at requested times for no; # collapse oper; # -----------------------------------------------------------------------------; def _evolve_no_collapse_expect_out(config):; """"""; Calculates expect.values at times tlist if no collapse ops. given; """""". global _cy_rhs_func; global _cy_col_spmv_func, _cy_col_expect_func; global _cy_col_spmv_call_func, _cy_col_expect_call_func. if debug:; print(inspect.stack()[0][3]). num_times = len(config.tlist); expect_out = []; for i in range(config.e_num):; if config.e_ops_isherm[i]:; # preallocate real array of zeros; expect_out.append(np.zeros(num_times, dtype=float)); else:; # preallocate complex array of zeros; expect_out.append(np.zeros(num_times, dtype=complex)). expect_out[i][0] = \; cy_expect_psi_csr(config.e_ops_data[i],; config.e_ops_ind[i],; config.e_ops_ptr[i],; config.psi0,; config.e_ops_isherm[i]). if not _cy_rhs_func:; _mc_func_load(config). opt = config.options; if config.tflag in [1, 10, 11]:; ODE = ode(_cy_rhs_func); code = compile('ODE.set_f_params(' + config.string + ')',; '<string>', 'exec'); exec(code); elif config.tflag == 2:; ODE = ode(_cRHStd); ODE.set_f_params(config); elif config.tflag in [20, 22]:; if config.options.rhs_with_state:; ODE = ode(_tdRHStd_with_state); else:; ODE = ode(_tdRHStd); ODE.set_f_params(config); elif config.tflag == 3:; if config.options.rhs_with_state:; ODE = ode(_pyRHSc_with_state); else:; ODE = ode(_pyRHSc); ODE.set_f_params(config); else:; ODE = ode(cy_ode_rhs); ODE.set_f_params(config.h_data, config.h_ind, config.h_ptr). ODE.set_integrator('zvode', method=opt.method, order=opt.order,; atol=opt.atol, rtol=opt.rtol, nsteps=opt.nsteps,; first_step=opt.first_step, min_step=opt.min_step,; max_step=opt.max_step); ODE.set_initial_value(config.psi0, config.tlist[0]); for jj in range(config.e_num):; expect_out[jj][0] = cy_expect_psi_csr(; config.e_ops_data[jj], config.e_ops_ind[jj],; config.e_ops_p",MatchSource.WIKI,docs/4.2/modules/qutip/mcsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html
https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:19823,Modifiability,config,config,19823,"-------------------------------; # evolution solver: return expectation values at requested times for no; # collapse oper; # -----------------------------------------------------------------------------; def _evolve_no_collapse_expect_out(config):; """"""; Calculates expect.values at times tlist if no collapse ops. given; """""". global _cy_rhs_func; global _cy_col_spmv_func, _cy_col_expect_func; global _cy_col_spmv_call_func, _cy_col_expect_call_func. if debug:; print(inspect.stack()[0][3]). num_times = len(config.tlist); expect_out = []; for i in range(config.e_num):; if config.e_ops_isherm[i]:; # preallocate real array of zeros; expect_out.append(np.zeros(num_times, dtype=float)); else:; # preallocate complex array of zeros; expect_out.append(np.zeros(num_times, dtype=complex)). expect_out[i][0] = \; cy_expect_psi_csr(config.e_ops_data[i],; config.e_ops_ind[i],; config.e_ops_ptr[i],; config.psi0,; config.e_ops_isherm[i]). if not _cy_rhs_func:; _mc_func_load(config). opt = config.options; if config.tflag in [1, 10, 11]:; ODE = ode(_cy_rhs_func); code = compile('ODE.set_f_params(' + config.string + ')',; '<string>', 'exec'); exec(code); elif config.tflag == 2:; ODE = ode(_cRHStd); ODE.set_f_params(config); elif config.tflag in [20, 22]:; if config.options.rhs_with_state:; ODE = ode(_tdRHStd_with_state); else:; ODE = ode(_tdRHStd); ODE.set_f_params(config); elif config.tflag == 3:; if config.options.rhs_with_state:; ODE = ode(_pyRHSc_with_state); else:; ODE = ode(_pyRHSc); ODE.set_f_params(config); else:; ODE = ode(cy_ode_rhs); ODE.set_f_params(config.h_data, config.h_ind, config.h_ptr). ODE.set_integrator('zvode', method=opt.method, order=opt.order,; atol=opt.atol, rtol=opt.rtol, nsteps=opt.nsteps,; first_step=opt.first_step, min_step=opt.min_step,; max_step=opt.max_step); ODE.set_initial_value(config.psi0, config.tlist[0]); for jj in range(config.e_num):; expect_out[jj][0] = cy_expect_psi_csr(; config.e_ops_data[jj], config.e_ops_ind[jj],; config.e_ops_ptr[jj], config.ps",MatchSource.WIKI,docs/4.2/modules/qutip/mcsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html
https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:19915,Modifiability,config,config,19915,"d times for no; # collapse oper; # -----------------------------------------------------------------------------; def _evolve_no_collapse_expect_out(config):; """"""; Calculates expect.values at times tlist if no collapse ops. given; """""". global _cy_rhs_func; global _cy_col_spmv_func, _cy_col_expect_func; global _cy_col_spmv_call_func, _cy_col_expect_call_func. if debug:; print(inspect.stack()[0][3]). num_times = len(config.tlist); expect_out = []; for i in range(config.e_num):; if config.e_ops_isherm[i]:; # preallocate real array of zeros; expect_out.append(np.zeros(num_times, dtype=float)); else:; # preallocate complex array of zeros; expect_out.append(np.zeros(num_times, dtype=complex)). expect_out[i][0] = \; cy_expect_psi_csr(config.e_ops_data[i],; config.e_ops_ind[i],; config.e_ops_ptr[i],; config.psi0,; config.e_ops_isherm[i]). if not _cy_rhs_func:; _mc_func_load(config). opt = config.options; if config.tflag in [1, 10, 11]:; ODE = ode(_cy_rhs_func); code = compile('ODE.set_f_params(' + config.string + ')',; '<string>', 'exec'); exec(code); elif config.tflag == 2:; ODE = ode(_cRHStd); ODE.set_f_params(config); elif config.tflag in [20, 22]:; if config.options.rhs_with_state:; ODE = ode(_tdRHStd_with_state); else:; ODE = ode(_tdRHStd); ODE.set_f_params(config); elif config.tflag == 3:; if config.options.rhs_with_state:; ODE = ode(_pyRHSc_with_state); else:; ODE = ode(_pyRHSc); ODE.set_f_params(config); else:; ODE = ode(cy_ode_rhs); ODE.set_f_params(config.h_data, config.h_ind, config.h_ptr). ODE.set_integrator('zvode', method=opt.method, order=opt.order,; atol=opt.atol, rtol=opt.rtol, nsteps=opt.nsteps,; first_step=opt.first_step, min_step=opt.min_step,; max_step=opt.max_step); ODE.set_initial_value(config.psi0, config.tlist[0]); for jj in range(config.e_num):; expect_out[jj][0] = cy_expect_psi_csr(; config.e_ops_data[jj], config.e_ops_ind[jj],; config.e_ops_ptr[jj], config.psi0,; config.e_ops_isherm[jj]). for k in range(1, num_times):; ODE.integrate(config.tlist[",MatchSource.WIKI,docs/4.2/modules/qutip/mcsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html
https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:19975,Modifiability,config,config,19975,"----------------------------------------------------------------------; def _evolve_no_collapse_expect_out(config):; """"""; Calculates expect.values at times tlist if no collapse ops. given; """""". global _cy_rhs_func; global _cy_col_spmv_func, _cy_col_expect_func; global _cy_col_spmv_call_func, _cy_col_expect_call_func. if debug:; print(inspect.stack()[0][3]). num_times = len(config.tlist); expect_out = []; for i in range(config.e_num):; if config.e_ops_isherm[i]:; # preallocate real array of zeros; expect_out.append(np.zeros(num_times, dtype=float)); else:; # preallocate complex array of zeros; expect_out.append(np.zeros(num_times, dtype=complex)). expect_out[i][0] = \; cy_expect_psi_csr(config.e_ops_data[i],; config.e_ops_ind[i],; config.e_ops_ptr[i],; config.psi0,; config.e_ops_isherm[i]). if not _cy_rhs_func:; _mc_func_load(config). opt = config.options; if config.tflag in [1, 10, 11]:; ODE = ode(_cy_rhs_func); code = compile('ODE.set_f_params(' + config.string + ')',; '<string>', 'exec'); exec(code); elif config.tflag == 2:; ODE = ode(_cRHStd); ODE.set_f_params(config); elif config.tflag in [20, 22]:; if config.options.rhs_with_state:; ODE = ode(_tdRHStd_with_state); else:; ODE = ode(_tdRHStd); ODE.set_f_params(config); elif config.tflag == 3:; if config.options.rhs_with_state:; ODE = ode(_pyRHSc_with_state); else:; ODE = ode(_pyRHSc); ODE.set_f_params(config); else:; ODE = ode(cy_ode_rhs); ODE.set_f_params(config.h_data, config.h_ind, config.h_ptr). ODE.set_integrator('zvode', method=opt.method, order=opt.order,; atol=opt.atol, rtol=opt.rtol, nsteps=opt.nsteps,; first_step=opt.first_step, min_step=opt.min_step,; max_step=opt.max_step); ODE.set_initial_value(config.psi0, config.tlist[0]); for jj in range(config.e_num):; expect_out[jj][0] = cy_expect_psi_csr(; config.e_ops_data[jj], config.e_ops_ind[jj],; config.e_ops_ptr[jj], config.psi0,; config.e_ops_isherm[jj]). for k in range(1, num_times):; ODE.integrate(config.tlist[k], step=0) # integrate up to tlist[k]; if",MatchSource.WIKI,docs/4.2/modules/qutip/mcsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html
https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:20032,Modifiability,config,config,20032,"no_collapse_expect_out(config):; """"""; Calculates expect.values at times tlist if no collapse ops. given; """""". global _cy_rhs_func; global _cy_col_spmv_func, _cy_col_expect_func; global _cy_col_spmv_call_func, _cy_col_expect_call_func. if debug:; print(inspect.stack()[0][3]). num_times = len(config.tlist); expect_out = []; for i in range(config.e_num):; if config.e_ops_isherm[i]:; # preallocate real array of zeros; expect_out.append(np.zeros(num_times, dtype=float)); else:; # preallocate complex array of zeros; expect_out.append(np.zeros(num_times, dtype=complex)). expect_out[i][0] = \; cy_expect_psi_csr(config.e_ops_data[i],; config.e_ops_ind[i],; config.e_ops_ptr[i],; config.psi0,; config.e_ops_isherm[i]). if not _cy_rhs_func:; _mc_func_load(config). opt = config.options; if config.tflag in [1, 10, 11]:; ODE = ode(_cy_rhs_func); code = compile('ODE.set_f_params(' + config.string + ')',; '<string>', 'exec'); exec(code); elif config.tflag == 2:; ODE = ode(_cRHStd); ODE.set_f_params(config); elif config.tflag in [20, 22]:; if config.options.rhs_with_state:; ODE = ode(_tdRHStd_with_state); else:; ODE = ode(_tdRHStd); ODE.set_f_params(config); elif config.tflag == 3:; if config.options.rhs_with_state:; ODE = ode(_pyRHSc_with_state); else:; ODE = ode(_pyRHSc); ODE.set_f_params(config); else:; ODE = ode(cy_ode_rhs); ODE.set_f_params(config.h_data, config.h_ind, config.h_ptr). ODE.set_integrator('zvode', method=opt.method, order=opt.order,; atol=opt.atol, rtol=opt.rtol, nsteps=opt.nsteps,; first_step=opt.first_step, min_step=opt.min_step,; max_step=opt.max_step); ODE.set_initial_value(config.psi0, config.tlist[0]); for jj in range(config.e_num):; expect_out[jj][0] = cy_expect_psi_csr(; config.e_ops_data[jj], config.e_ops_ind[jj],; config.e_ops_ptr[jj], config.psi0,; config.e_ops_isherm[jj]). for k in range(1, num_times):; ODE.integrate(config.tlist[k], step=0) # integrate up to tlist[k]; if ODE.successful():; state = ODE.y / dznrm2(ODE.y); for jj in range(config.e_num):; e",MatchSource.WIKI,docs/4.2/modules/qutip/mcsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html
https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:20046,Modifiability,config,config,20046,"no_collapse_expect_out(config):; """"""; Calculates expect.values at times tlist if no collapse ops. given; """""". global _cy_rhs_func; global _cy_col_spmv_func, _cy_col_expect_func; global _cy_col_spmv_call_func, _cy_col_expect_call_func. if debug:; print(inspect.stack()[0][3]). num_times = len(config.tlist); expect_out = []; for i in range(config.e_num):; if config.e_ops_isherm[i]:; # preallocate real array of zeros; expect_out.append(np.zeros(num_times, dtype=float)); else:; # preallocate complex array of zeros; expect_out.append(np.zeros(num_times, dtype=complex)). expect_out[i][0] = \; cy_expect_psi_csr(config.e_ops_data[i],; config.e_ops_ind[i],; config.e_ops_ptr[i],; config.psi0,; config.e_ops_isherm[i]). if not _cy_rhs_func:; _mc_func_load(config). opt = config.options; if config.tflag in [1, 10, 11]:; ODE = ode(_cy_rhs_func); code = compile('ODE.set_f_params(' + config.string + ')',; '<string>', 'exec'); exec(code); elif config.tflag == 2:; ODE = ode(_cRHStd); ODE.set_f_params(config); elif config.tflag in [20, 22]:; if config.options.rhs_with_state:; ODE = ode(_tdRHStd_with_state); else:; ODE = ode(_tdRHStd); ODE.set_f_params(config); elif config.tflag == 3:; if config.options.rhs_with_state:; ODE = ode(_pyRHSc_with_state); else:; ODE = ode(_pyRHSc); ODE.set_f_params(config); else:; ODE = ode(cy_ode_rhs); ODE.set_f_params(config.h_data, config.h_ind, config.h_ptr). ODE.set_integrator('zvode', method=opt.method, order=opt.order,; atol=opt.atol, rtol=opt.rtol, nsteps=opt.nsteps,; first_step=opt.first_step, min_step=opt.min_step,; max_step=opt.max_step); ODE.set_initial_value(config.psi0, config.tlist[0]); for jj in range(config.e_num):; expect_out[jj][0] = cy_expect_psi_csr(; config.e_ops_data[jj], config.e_ops_ind[jj],; config.e_ops_ptr[jj], config.psi0,; config.e_ops_isherm[jj]). for k in range(1, num_times):; ODE.integrate(config.tlist[k], step=0) # integrate up to tlist[k]; if ODE.successful():; state = ODE.y / dznrm2(ODE.y); for jj in range(config.e_num):; e",MatchSource.WIKI,docs/4.2/modules/qutip/mcsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html
https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:20076,Modifiability,config,config,20076," """"""; Calculates expect.values at times tlist if no collapse ops. given; """""". global _cy_rhs_func; global _cy_col_spmv_func, _cy_col_expect_func; global _cy_col_spmv_call_func, _cy_col_expect_call_func. if debug:; print(inspect.stack()[0][3]). num_times = len(config.tlist); expect_out = []; for i in range(config.e_num):; if config.e_ops_isherm[i]:; # preallocate real array of zeros; expect_out.append(np.zeros(num_times, dtype=float)); else:; # preallocate complex array of zeros; expect_out.append(np.zeros(num_times, dtype=complex)). expect_out[i][0] = \; cy_expect_psi_csr(config.e_ops_data[i],; config.e_ops_ind[i],; config.e_ops_ptr[i],; config.psi0,; config.e_ops_isherm[i]). if not _cy_rhs_func:; _mc_func_load(config). opt = config.options; if config.tflag in [1, 10, 11]:; ODE = ode(_cy_rhs_func); code = compile('ODE.set_f_params(' + config.string + ')',; '<string>', 'exec'); exec(code); elif config.tflag == 2:; ODE = ode(_cRHStd); ODE.set_f_params(config); elif config.tflag in [20, 22]:; if config.options.rhs_with_state:; ODE = ode(_tdRHStd_with_state); else:; ODE = ode(_tdRHStd); ODE.set_f_params(config); elif config.tflag == 3:; if config.options.rhs_with_state:; ODE = ode(_pyRHSc_with_state); else:; ODE = ode(_pyRHSc); ODE.set_f_params(config); else:; ODE = ode(cy_ode_rhs); ODE.set_f_params(config.h_data, config.h_ind, config.h_ptr). ODE.set_integrator('zvode', method=opt.method, order=opt.order,; atol=opt.atol, rtol=opt.rtol, nsteps=opt.nsteps,; first_step=opt.first_step, min_step=opt.min_step,; max_step=opt.max_step); ODE.set_initial_value(config.psi0, config.tlist[0]); for jj in range(config.e_num):; expect_out[jj][0] = cy_expect_psi_csr(; config.e_ops_data[jj], config.e_ops_ind[jj],; config.e_ops_ptr[jj], config.psi0,; config.e_ops_isherm[jj]). for k in range(1, num_times):; ODE.integrate(config.tlist[k], step=0) # integrate up to tlist[k]; if ODE.successful():; state = ODE.y / dznrm2(ODE.y); for jj in range(config.e_num):; expect_out[jj][k] = cy_expect_psi",MatchSource.WIKI,docs/4.2/modules/qutip/mcsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html
https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:20185,Modifiability,config,config,20185,"nc, _cy_col_expect_func; global _cy_col_spmv_call_func, _cy_col_expect_call_func. if debug:; print(inspect.stack()[0][3]). num_times = len(config.tlist); expect_out = []; for i in range(config.e_num):; if config.e_ops_isherm[i]:; # preallocate real array of zeros; expect_out.append(np.zeros(num_times, dtype=float)); else:; # preallocate complex array of zeros; expect_out.append(np.zeros(num_times, dtype=complex)). expect_out[i][0] = \; cy_expect_psi_csr(config.e_ops_data[i],; config.e_ops_ind[i],; config.e_ops_ptr[i],; config.psi0,; config.e_ops_isherm[i]). if not _cy_rhs_func:; _mc_func_load(config). opt = config.options; if config.tflag in [1, 10, 11]:; ODE = ode(_cy_rhs_func); code = compile('ODE.set_f_params(' + config.string + ')',; '<string>', 'exec'); exec(code); elif config.tflag == 2:; ODE = ode(_cRHStd); ODE.set_f_params(config); elif config.tflag in [20, 22]:; if config.options.rhs_with_state:; ODE = ode(_tdRHStd_with_state); else:; ODE = ode(_tdRHStd); ODE.set_f_params(config); elif config.tflag == 3:; if config.options.rhs_with_state:; ODE = ode(_pyRHSc_with_state); else:; ODE = ode(_pyRHSc); ODE.set_f_params(config); else:; ODE = ode(cy_ode_rhs); ODE.set_f_params(config.h_data, config.h_ind, config.h_ptr). ODE.set_integrator('zvode', method=opt.method, order=opt.order,; atol=opt.atol, rtol=opt.rtol, nsteps=opt.nsteps,; first_step=opt.first_step, min_step=opt.min_step,; max_step=opt.max_step); ODE.set_initial_value(config.psi0, config.tlist[0]); for jj in range(config.e_num):; expect_out[jj][0] = cy_expect_psi_csr(; config.e_ops_data[jj], config.e_ops_ind[jj],; config.e_ops_ptr[jj], config.psi0,; config.e_ops_isherm[jj]). for k in range(1, num_times):; ODE.integrate(config.tlist[k], step=0) # integrate up to tlist[k]; if ODE.successful():; state = ODE.y / dznrm2(ODE.y); for jj in range(config.e_num):; expect_out[jj][k] = cy_expect_psi_csr(; config.e_ops_data[jj], config.e_ops_ind[jj],; config.e_ops_ptr[jj], state,; config.e_ops_isherm[jj]); else:; raise",MatchSource.WIKI,docs/4.2/modules/qutip/mcsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html
https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:20199,Modifiability,config,config,20199,"nc, _cy_col_expect_func; global _cy_col_spmv_call_func, _cy_col_expect_call_func. if debug:; print(inspect.stack()[0][3]). num_times = len(config.tlist); expect_out = []; for i in range(config.e_num):; if config.e_ops_isherm[i]:; # preallocate real array of zeros; expect_out.append(np.zeros(num_times, dtype=float)); else:; # preallocate complex array of zeros; expect_out.append(np.zeros(num_times, dtype=complex)). expect_out[i][0] = \; cy_expect_psi_csr(config.e_ops_data[i],; config.e_ops_ind[i],; config.e_ops_ptr[i],; config.psi0,; config.e_ops_isherm[i]). if not _cy_rhs_func:; _mc_func_load(config). opt = config.options; if config.tflag in [1, 10, 11]:; ODE = ode(_cy_rhs_func); code = compile('ODE.set_f_params(' + config.string + ')',; '<string>', 'exec'); exec(code); elif config.tflag == 2:; ODE = ode(_cRHStd); ODE.set_f_params(config); elif config.tflag in [20, 22]:; if config.options.rhs_with_state:; ODE = ode(_tdRHStd_with_state); else:; ODE = ode(_tdRHStd); ODE.set_f_params(config); elif config.tflag == 3:; if config.options.rhs_with_state:; ODE = ode(_pyRHSc_with_state); else:; ODE = ode(_pyRHSc); ODE.set_f_params(config); else:; ODE = ode(cy_ode_rhs); ODE.set_f_params(config.h_data, config.h_ind, config.h_ptr). ODE.set_integrator('zvode', method=opt.method, order=opt.order,; atol=opt.atol, rtol=opt.rtol, nsteps=opt.nsteps,; first_step=opt.first_step, min_step=opt.min_step,; max_step=opt.max_step); ODE.set_initial_value(config.psi0, config.tlist[0]); for jj in range(config.e_num):; expect_out[jj][0] = cy_expect_psi_csr(; config.e_ops_data[jj], config.e_ops_ind[jj],; config.e_ops_ptr[jj], config.psi0,; config.e_ops_isherm[jj]). for k in range(1, num_times):; ODE.integrate(config.tlist[k], step=0) # integrate up to tlist[k]; if ODE.successful():; state = ODE.y / dznrm2(ODE.y); for jj in range(config.e_num):; expect_out[jj][k] = cy_expect_psi_csr(; config.e_ops_data[jj], config.e_ops_ind[jj],; config.e_ops_ptr[jj], state,; config.e_ops_isherm[jj]); else:; raise",MatchSource.WIKI,docs/4.2/modules/qutip/mcsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html
https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:20222,Modifiability,config,config,20222,"bal _cy_col_spmv_call_func, _cy_col_expect_call_func. if debug:; print(inspect.stack()[0][3]). num_times = len(config.tlist); expect_out = []; for i in range(config.e_num):; if config.e_ops_isherm[i]:; # preallocate real array of zeros; expect_out.append(np.zeros(num_times, dtype=float)); else:; # preallocate complex array of zeros; expect_out.append(np.zeros(num_times, dtype=complex)). expect_out[i][0] = \; cy_expect_psi_csr(config.e_ops_data[i],; config.e_ops_ind[i],; config.e_ops_ptr[i],; config.psi0,; config.e_ops_isherm[i]). if not _cy_rhs_func:; _mc_func_load(config). opt = config.options; if config.tflag in [1, 10, 11]:; ODE = ode(_cy_rhs_func); code = compile('ODE.set_f_params(' + config.string + ')',; '<string>', 'exec'); exec(code); elif config.tflag == 2:; ODE = ode(_cRHStd); ODE.set_f_params(config); elif config.tflag in [20, 22]:; if config.options.rhs_with_state:; ODE = ode(_tdRHStd_with_state); else:; ODE = ode(_tdRHStd); ODE.set_f_params(config); elif config.tflag == 3:; if config.options.rhs_with_state:; ODE = ode(_pyRHSc_with_state); else:; ODE = ode(_pyRHSc); ODE.set_f_params(config); else:; ODE = ode(cy_ode_rhs); ODE.set_f_params(config.h_data, config.h_ind, config.h_ptr). ODE.set_integrator('zvode', method=opt.method, order=opt.order,; atol=opt.atol, rtol=opt.rtol, nsteps=opt.nsteps,; first_step=opt.first_step, min_step=opt.min_step,; max_step=opt.max_step); ODE.set_initial_value(config.psi0, config.tlist[0]); for jj in range(config.e_num):; expect_out[jj][0] = cy_expect_psi_csr(; config.e_ops_data[jj], config.e_ops_ind[jj],; config.e_ops_ptr[jj], config.psi0,; config.e_ops_isherm[jj]). for k in range(1, num_times):; ODE.integrate(config.tlist[k], step=0) # integrate up to tlist[k]; if ODE.successful():; state = ODE.y / dznrm2(ODE.y); for jj in range(config.e_num):; expect_out[jj][k] = cy_expect_psi_csr(; config.e_ops_data[jj], config.e_ops_ind[jj],; config.e_ops_ptr[jj], state,; config.e_ops_isherm[jj]); else:; raise ValueError('Error in ODE sol",MatchSource.WIKI,docs/4.2/modules/qutip/mcsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html
https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:20329,Modifiability,config,config,20329,"xpect_out = []; for i in range(config.e_num):; if config.e_ops_isherm[i]:; # preallocate real array of zeros; expect_out.append(np.zeros(num_times, dtype=float)); else:; # preallocate complex array of zeros; expect_out.append(np.zeros(num_times, dtype=complex)). expect_out[i][0] = \; cy_expect_psi_csr(config.e_ops_data[i],; config.e_ops_ind[i],; config.e_ops_ptr[i],; config.psi0,; config.e_ops_isherm[i]). if not _cy_rhs_func:; _mc_func_load(config). opt = config.options; if config.tflag in [1, 10, 11]:; ODE = ode(_cy_rhs_func); code = compile('ODE.set_f_params(' + config.string + ')',; '<string>', 'exec'); exec(code); elif config.tflag == 2:; ODE = ode(_cRHStd); ODE.set_f_params(config); elif config.tflag in [20, 22]:; if config.options.rhs_with_state:; ODE = ode(_tdRHStd_with_state); else:; ODE = ode(_tdRHStd); ODE.set_f_params(config); elif config.tflag == 3:; if config.options.rhs_with_state:; ODE = ode(_pyRHSc_with_state); else:; ODE = ode(_pyRHSc); ODE.set_f_params(config); else:; ODE = ode(cy_ode_rhs); ODE.set_f_params(config.h_data, config.h_ind, config.h_ptr). ODE.set_integrator('zvode', method=opt.method, order=opt.order,; atol=opt.atol, rtol=opt.rtol, nsteps=opt.nsteps,; first_step=opt.first_step, min_step=opt.min_step,; max_step=opt.max_step); ODE.set_initial_value(config.psi0, config.tlist[0]); for jj in range(config.e_num):; expect_out[jj][0] = cy_expect_psi_csr(; config.e_ops_data[jj], config.e_ops_ind[jj],; config.e_ops_ptr[jj], config.psi0,; config.e_ops_isherm[jj]). for k in range(1, num_times):; ODE.integrate(config.tlist[k], step=0) # integrate up to tlist[k]; if ODE.successful():; state = ODE.y / dznrm2(ODE.y); for jj in range(config.e_num):; expect_out[jj][k] = cy_expect_psi_csr(; config.e_ops_data[jj], config.e_ops_ind[jj],; config.e_ops_ptr[jj], state,; config.e_ops_isherm[jj]); else:; raise ValueError('Error in ODE solver'). return expect_out. # -----------------------------------------------------------------------------; # single-trajectory",MatchSource.WIKI,docs/4.2/modules/qutip/mcsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html
https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:20385,Modifiability,config,config,20385,"e_num):; if config.e_ops_isherm[i]:; # preallocate real array of zeros; expect_out.append(np.zeros(num_times, dtype=float)); else:; # preallocate complex array of zeros; expect_out.append(np.zeros(num_times, dtype=complex)). expect_out[i][0] = \; cy_expect_psi_csr(config.e_ops_data[i],; config.e_ops_ind[i],; config.e_ops_ptr[i],; config.psi0,; config.e_ops_isherm[i]). if not _cy_rhs_func:; _mc_func_load(config). opt = config.options; if config.tflag in [1, 10, 11]:; ODE = ode(_cy_rhs_func); code = compile('ODE.set_f_params(' + config.string + ')',; '<string>', 'exec'); exec(code); elif config.tflag == 2:; ODE = ode(_cRHStd); ODE.set_f_params(config); elif config.tflag in [20, 22]:; if config.options.rhs_with_state:; ODE = ode(_tdRHStd_with_state); else:; ODE = ode(_tdRHStd); ODE.set_f_params(config); elif config.tflag == 3:; if config.options.rhs_with_state:; ODE = ode(_pyRHSc_with_state); else:; ODE = ode(_pyRHSc); ODE.set_f_params(config); else:; ODE = ode(cy_ode_rhs); ODE.set_f_params(config.h_data, config.h_ind, config.h_ptr). ODE.set_integrator('zvode', method=opt.method, order=opt.order,; atol=opt.atol, rtol=opt.rtol, nsteps=opt.nsteps,; first_step=opt.first_step, min_step=opt.min_step,; max_step=opt.max_step); ODE.set_initial_value(config.psi0, config.tlist[0]); for jj in range(config.e_num):; expect_out[jj][0] = cy_expect_psi_csr(; config.e_ops_data[jj], config.e_ops_ind[jj],; config.e_ops_ptr[jj], config.psi0,; config.e_ops_isherm[jj]). for k in range(1, num_times):; ODE.integrate(config.tlist[k], step=0) # integrate up to tlist[k]; if ODE.successful():; state = ODE.y / dznrm2(ODE.y); for jj in range(config.e_num):; expect_out[jj][k] = cy_expect_psi_csr(; config.e_ops_data[jj], config.e_ops_ind[jj],; config.e_ops_ptr[jj], state,; config.e_ops_isherm[jj]); else:; raise ValueError('Error in ODE solver'). return expect_out. # -----------------------------------------------------------------------------; # single-trajectory for monte carlo; # ------------------",MatchSource.WIKI,docs/4.2/modules/qutip/mcsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html
https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:20400,Modifiability,config,config,20400,"g.e_ops_isherm[i]:; # preallocate real array of zeros; expect_out.append(np.zeros(num_times, dtype=float)); else:; # preallocate complex array of zeros; expect_out.append(np.zeros(num_times, dtype=complex)). expect_out[i][0] = \; cy_expect_psi_csr(config.e_ops_data[i],; config.e_ops_ind[i],; config.e_ops_ptr[i],; config.psi0,; config.e_ops_isherm[i]). if not _cy_rhs_func:; _mc_func_load(config). opt = config.options; if config.tflag in [1, 10, 11]:; ODE = ode(_cy_rhs_func); code = compile('ODE.set_f_params(' + config.string + ')',; '<string>', 'exec'); exec(code); elif config.tflag == 2:; ODE = ode(_cRHStd); ODE.set_f_params(config); elif config.tflag in [20, 22]:; if config.options.rhs_with_state:; ODE = ode(_tdRHStd_with_state); else:; ODE = ode(_tdRHStd); ODE.set_f_params(config); elif config.tflag == 3:; if config.options.rhs_with_state:; ODE = ode(_pyRHSc_with_state); else:; ODE = ode(_pyRHSc); ODE.set_f_params(config); else:; ODE = ode(cy_ode_rhs); ODE.set_f_params(config.h_data, config.h_ind, config.h_ptr). ODE.set_integrator('zvode', method=opt.method, order=opt.order,; atol=opt.atol, rtol=opt.rtol, nsteps=opt.nsteps,; first_step=opt.first_step, min_step=opt.min_step,; max_step=opt.max_step); ODE.set_initial_value(config.psi0, config.tlist[0]); for jj in range(config.e_num):; expect_out[jj][0] = cy_expect_psi_csr(; config.e_ops_data[jj], config.e_ops_ind[jj],; config.e_ops_ptr[jj], config.psi0,; config.e_ops_isherm[jj]). for k in range(1, num_times):; ODE.integrate(config.tlist[k], step=0) # integrate up to tlist[k]; if ODE.successful():; state = ODE.y / dznrm2(ODE.y); for jj in range(config.e_num):; expect_out[jj][k] = cy_expect_psi_csr(; config.e_ops_data[jj], config.e_ops_ind[jj],; config.e_ops_ptr[jj], state,; config.e_ops_isherm[jj]); else:; raise ValueError('Error in ODE solver'). return expect_out. # -----------------------------------------------------------------------------; # single-trajectory for monte carlo; # ------------------------------------",MatchSource.WIKI,docs/4.2/modules/qutip/mcsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html
https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:20414,Modifiability,config,config,20414,"i]:; # preallocate real array of zeros; expect_out.append(np.zeros(num_times, dtype=float)); else:; # preallocate complex array of zeros; expect_out.append(np.zeros(num_times, dtype=complex)). expect_out[i][0] = \; cy_expect_psi_csr(config.e_ops_data[i],; config.e_ops_ind[i],; config.e_ops_ptr[i],; config.psi0,; config.e_ops_isherm[i]). if not _cy_rhs_func:; _mc_func_load(config). opt = config.options; if config.tflag in [1, 10, 11]:; ODE = ode(_cy_rhs_func); code = compile('ODE.set_f_params(' + config.string + ')',; '<string>', 'exec'); exec(code); elif config.tflag == 2:; ODE = ode(_cRHStd); ODE.set_f_params(config); elif config.tflag in [20, 22]:; if config.options.rhs_with_state:; ODE = ode(_tdRHStd_with_state); else:; ODE = ode(_tdRHStd); ODE.set_f_params(config); elif config.tflag == 3:; if config.options.rhs_with_state:; ODE = ode(_pyRHSc_with_state); else:; ODE = ode(_pyRHSc); ODE.set_f_params(config); else:; ODE = ode(cy_ode_rhs); ODE.set_f_params(config.h_data, config.h_ind, config.h_ptr). ODE.set_integrator('zvode', method=opt.method, order=opt.order,; atol=opt.atol, rtol=opt.rtol, nsteps=opt.nsteps,; first_step=opt.first_step, min_step=opt.min_step,; max_step=opt.max_step); ODE.set_initial_value(config.psi0, config.tlist[0]); for jj in range(config.e_num):; expect_out[jj][0] = cy_expect_psi_csr(; config.e_ops_data[jj], config.e_ops_ind[jj],; config.e_ops_ptr[jj], config.psi0,; config.e_ops_isherm[jj]). for k in range(1, num_times):; ODE.integrate(config.tlist[k], step=0) # integrate up to tlist[k]; if ODE.successful():; state = ODE.y / dznrm2(ODE.y); for jj in range(config.e_num):; expect_out[jj][k] = cy_expect_psi_csr(; config.e_ops_data[jj], config.e_ops_ind[jj],; config.e_ops_ptr[jj], state,; config.e_ops_isherm[jj]); else:; raise ValueError('Error in ODE solver'). return expect_out. # -----------------------------------------------------------------------------; # single-trajectory for monte carlo; # --------------------------------------------------",MatchSource.WIKI,docs/4.2/modules/qutip/mcsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html
https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:20641,Modifiability,config,config,20641,"ect_psi_csr(config.e_ops_data[i],; config.e_ops_ind[i],; config.e_ops_ptr[i],; config.psi0,; config.e_ops_isherm[i]). if not _cy_rhs_func:; _mc_func_load(config). opt = config.options; if config.tflag in [1, 10, 11]:; ODE = ode(_cy_rhs_func); code = compile('ODE.set_f_params(' + config.string + ')',; '<string>', 'exec'); exec(code); elif config.tflag == 2:; ODE = ode(_cRHStd); ODE.set_f_params(config); elif config.tflag in [20, 22]:; if config.options.rhs_with_state:; ODE = ode(_tdRHStd_with_state); else:; ODE = ode(_tdRHStd); ODE.set_f_params(config); elif config.tflag == 3:; if config.options.rhs_with_state:; ODE = ode(_pyRHSc_with_state); else:; ODE = ode(_pyRHSc); ODE.set_f_params(config); else:; ODE = ode(cy_ode_rhs); ODE.set_f_params(config.h_data, config.h_ind, config.h_ptr). ODE.set_integrator('zvode', method=opt.method, order=opt.order,; atol=opt.atol, rtol=opt.rtol, nsteps=opt.nsteps,; first_step=opt.first_step, min_step=opt.min_step,; max_step=opt.max_step); ODE.set_initial_value(config.psi0, config.tlist[0]); for jj in range(config.e_num):; expect_out[jj][0] = cy_expect_psi_csr(; config.e_ops_data[jj], config.e_ops_ind[jj],; config.e_ops_ptr[jj], config.psi0,; config.e_ops_isherm[jj]). for k in range(1, num_times):; ODE.integrate(config.tlist[k], step=0) # integrate up to tlist[k]; if ODE.successful():; state = ODE.y / dznrm2(ODE.y); for jj in range(config.e_num):; expect_out[jj][k] = cy_expect_psi_csr(; config.e_ops_data[jj], config.e_ops_ind[jj],; config.e_ops_ptr[jj], state,; config.e_ops_isherm[jj]); else:; raise ValueError('Error in ODE solver'). return expect_out. # -----------------------------------------------------------------------------; # single-trajectory for monte carlo; # -----------------------------------------------------------------------------; def _mc_alg_evolve(nt, config, opt, seeds):; """"""; Monte Carlo algorithm returning state-vector or expectation values; at times tlist for a single trajectory.; """""". global _cy_rhs_func; global _",MatchSource.WIKI,docs/4.2/modules/qutip/mcsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html
https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:20654,Modifiability,config,config,20654,"e_ops_data[i],; config.e_ops_ind[i],; config.e_ops_ptr[i],; config.psi0,; config.e_ops_isherm[i]). if not _cy_rhs_func:; _mc_func_load(config). opt = config.options; if config.tflag in [1, 10, 11]:; ODE = ode(_cy_rhs_func); code = compile('ODE.set_f_params(' + config.string + ')',; '<string>', 'exec'); exec(code); elif config.tflag == 2:; ODE = ode(_cRHStd); ODE.set_f_params(config); elif config.tflag in [20, 22]:; if config.options.rhs_with_state:; ODE = ode(_tdRHStd_with_state); else:; ODE = ode(_tdRHStd); ODE.set_f_params(config); elif config.tflag == 3:; if config.options.rhs_with_state:; ODE = ode(_pyRHSc_with_state); else:; ODE = ode(_pyRHSc); ODE.set_f_params(config); else:; ODE = ode(cy_ode_rhs); ODE.set_f_params(config.h_data, config.h_ind, config.h_ptr). ODE.set_integrator('zvode', method=opt.method, order=opt.order,; atol=opt.atol, rtol=opt.rtol, nsteps=opt.nsteps,; first_step=opt.first_step, min_step=opt.min_step,; max_step=opt.max_step); ODE.set_initial_value(config.psi0, config.tlist[0]); for jj in range(config.e_num):; expect_out[jj][0] = cy_expect_psi_csr(; config.e_ops_data[jj], config.e_ops_ind[jj],; config.e_ops_ptr[jj], config.psi0,; config.e_ops_isherm[jj]). for k in range(1, num_times):; ODE.integrate(config.tlist[k], step=0) # integrate up to tlist[k]; if ODE.successful():; state = ODE.y / dznrm2(ODE.y); for jj in range(config.e_num):; expect_out[jj][k] = cy_expect_psi_csr(; config.e_ops_data[jj], config.e_ops_ind[jj],; config.e_ops_ptr[jj], state,; config.e_ops_isherm[jj]); else:; raise ValueError('Error in ODE solver'). return expect_out. # -----------------------------------------------------------------------------; # single-trajectory for monte carlo; # -----------------------------------------------------------------------------; def _mc_alg_evolve(nt, config, opt, seeds):; """"""; Monte Carlo algorithm returning state-vector or expectation values; at times tlist for a single trajectory.; """""". global _cy_rhs_func; global _cy_col_spmv_func, _",MatchSource.WIKI,docs/4.2/modules/qutip/mcsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html
https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:20688,Modifiability,config,config,20688,"_ops_ind[i],; config.e_ops_ptr[i],; config.psi0,; config.e_ops_isherm[i]). if not _cy_rhs_func:; _mc_func_load(config). opt = config.options; if config.tflag in [1, 10, 11]:; ODE = ode(_cy_rhs_func); code = compile('ODE.set_f_params(' + config.string + ')',; '<string>', 'exec'); exec(code); elif config.tflag == 2:; ODE = ode(_cRHStd); ODE.set_f_params(config); elif config.tflag in [20, 22]:; if config.options.rhs_with_state:; ODE = ode(_tdRHStd_with_state); else:; ODE = ode(_tdRHStd); ODE.set_f_params(config); elif config.tflag == 3:; if config.options.rhs_with_state:; ODE = ode(_pyRHSc_with_state); else:; ODE = ode(_pyRHSc); ODE.set_f_params(config); else:; ODE = ode(cy_ode_rhs); ODE.set_f_params(config.h_data, config.h_ind, config.h_ptr). ODE.set_integrator('zvode', method=opt.method, order=opt.order,; atol=opt.atol, rtol=opt.rtol, nsteps=opt.nsteps,; first_step=opt.first_step, min_step=opt.min_step,; max_step=opt.max_step); ODE.set_initial_value(config.psi0, config.tlist[0]); for jj in range(config.e_num):; expect_out[jj][0] = cy_expect_psi_csr(; config.e_ops_data[jj], config.e_ops_ind[jj],; config.e_ops_ptr[jj], config.psi0,; config.e_ops_isherm[jj]). for k in range(1, num_times):; ODE.integrate(config.tlist[k], step=0) # integrate up to tlist[k]; if ODE.successful():; state = ODE.y / dznrm2(ODE.y); for jj in range(config.e_num):; expect_out[jj][k] = cy_expect_psi_csr(; config.e_ops_data[jj], config.e_ops_ind[jj],; config.e_ops_ptr[jj], state,; config.e_ops_isherm[jj]); else:; raise ValueError('Error in ODE solver'). return expect_out. # -----------------------------------------------------------------------------; # single-trajectory for monte carlo; # -----------------------------------------------------------------------------; def _mc_alg_evolve(nt, config, opt, seeds):; """"""; Monte Carlo algorithm returning state-vector or expectation values; at times tlist for a single trajectory.; """""". global _cy_rhs_func; global _cy_col_spmv_func, _cy_col_expect_func; glo",MatchSource.WIKI,docs/4.2/modules/qutip/mcsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html
https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:20744,Modifiability,config,config,20744,"i0,; config.e_ops_isherm[i]). if not _cy_rhs_func:; _mc_func_load(config). opt = config.options; if config.tflag in [1, 10, 11]:; ODE = ode(_cy_rhs_func); code = compile('ODE.set_f_params(' + config.string + ')',; '<string>', 'exec'); exec(code); elif config.tflag == 2:; ODE = ode(_cRHStd); ODE.set_f_params(config); elif config.tflag in [20, 22]:; if config.options.rhs_with_state:; ODE = ode(_tdRHStd_with_state); else:; ODE = ode(_tdRHStd); ODE.set_f_params(config); elif config.tflag == 3:; if config.options.rhs_with_state:; ODE = ode(_pyRHSc_with_state); else:; ODE = ode(_pyRHSc); ODE.set_f_params(config); else:; ODE = ode(cy_ode_rhs); ODE.set_f_params(config.h_data, config.h_ind, config.h_ptr). ODE.set_integrator('zvode', method=opt.method, order=opt.order,; atol=opt.atol, rtol=opt.rtol, nsteps=opt.nsteps,; first_step=opt.first_step, min_step=opt.min_step,; max_step=opt.max_step); ODE.set_initial_value(config.psi0, config.tlist[0]); for jj in range(config.e_num):; expect_out[jj][0] = cy_expect_psi_csr(; config.e_ops_data[jj], config.e_ops_ind[jj],; config.e_ops_ptr[jj], config.psi0,; config.e_ops_isherm[jj]). for k in range(1, num_times):; ODE.integrate(config.tlist[k], step=0) # integrate up to tlist[k]; if ODE.successful():; state = ODE.y / dznrm2(ODE.y); for jj in range(config.e_num):; expect_out[jj][k] = cy_expect_psi_csr(; config.e_ops_data[jj], config.e_ops_ind[jj],; config.e_ops_ptr[jj], state,; config.e_ops_isherm[jj]); else:; raise ValueError('Error in ODE solver'). return expect_out. # -----------------------------------------------------------------------------; # single-trajectory for monte carlo; # -----------------------------------------------------------------------------; def _mc_alg_evolve(nt, config, opt, seeds):; """"""; Monte Carlo algorithm returning state-vector or expectation values; at times tlist for a single trajectory.; """""". global _cy_rhs_func; global _cy_col_spmv_func, _cy_col_expect_func; global _cy_col_spmv_call_func, _cy_col_expect_ca",MatchSource.WIKI,docs/4.2/modules/qutip/mcsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html
https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:20767,Modifiability,config,config,20767,"y_rhs_func:; _mc_func_load(config). opt = config.options; if config.tflag in [1, 10, 11]:; ODE = ode(_cy_rhs_func); code = compile('ODE.set_f_params(' + config.string + ')',; '<string>', 'exec'); exec(code); elif config.tflag == 2:; ODE = ode(_cRHStd); ODE.set_f_params(config); elif config.tflag in [20, 22]:; if config.options.rhs_with_state:; ODE = ode(_tdRHStd_with_state); else:; ODE = ode(_tdRHStd); ODE.set_f_params(config); elif config.tflag == 3:; if config.options.rhs_with_state:; ODE = ode(_pyRHSc_with_state); else:; ODE = ode(_pyRHSc); ODE.set_f_params(config); else:; ODE = ode(cy_ode_rhs); ODE.set_f_params(config.h_data, config.h_ind, config.h_ptr). ODE.set_integrator('zvode', method=opt.method, order=opt.order,; atol=opt.atol, rtol=opt.rtol, nsteps=opt.nsteps,; first_step=opt.first_step, min_step=opt.min_step,; max_step=opt.max_step); ODE.set_initial_value(config.psi0, config.tlist[0]); for jj in range(config.e_num):; expect_out[jj][0] = cy_expect_psi_csr(; config.e_ops_data[jj], config.e_ops_ind[jj],; config.e_ops_ptr[jj], config.psi0,; config.e_ops_isherm[jj]). for k in range(1, num_times):; ODE.integrate(config.tlist[k], step=0) # integrate up to tlist[k]; if ODE.successful():; state = ODE.y / dznrm2(ODE.y); for jj in range(config.e_num):; expect_out[jj][k] = cy_expect_psi_csr(; config.e_ops_data[jj], config.e_ops_ind[jj],; config.e_ops_ptr[jj], state,; config.e_ops_isherm[jj]); else:; raise ValueError('Error in ODE solver'). return expect_out. # -----------------------------------------------------------------------------; # single-trajectory for monte carlo; # -----------------------------------------------------------------------------; def _mc_alg_evolve(nt, config, opt, seeds):; """"""; Monte Carlo algorithm returning state-vector or expectation values; at times tlist for a single trajectory.; """""". global _cy_rhs_func; global _cy_col_spmv_func, _cy_col_expect_func; global _cy_col_spmv_call_func, _cy_col_expect_call_func. tlist = config.tlist; num_times",MatchSource.WIKI,docs/4.2/modules/qutip/mcsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html
https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:20790,Modifiability,config,config,20790,"oad(config). opt = config.options; if config.tflag in [1, 10, 11]:; ODE = ode(_cy_rhs_func); code = compile('ODE.set_f_params(' + config.string + ')',; '<string>', 'exec'); exec(code); elif config.tflag == 2:; ODE = ode(_cRHStd); ODE.set_f_params(config); elif config.tflag in [20, 22]:; if config.options.rhs_with_state:; ODE = ode(_tdRHStd_with_state); else:; ODE = ode(_tdRHStd); ODE.set_f_params(config); elif config.tflag == 3:; if config.options.rhs_with_state:; ODE = ode(_pyRHSc_with_state); else:; ODE = ode(_pyRHSc); ODE.set_f_params(config); else:; ODE = ode(cy_ode_rhs); ODE.set_f_params(config.h_data, config.h_ind, config.h_ptr). ODE.set_integrator('zvode', method=opt.method, order=opt.order,; atol=opt.atol, rtol=opt.rtol, nsteps=opt.nsteps,; first_step=opt.first_step, min_step=opt.min_step,; max_step=opt.max_step); ODE.set_initial_value(config.psi0, config.tlist[0]); for jj in range(config.e_num):; expect_out[jj][0] = cy_expect_psi_csr(; config.e_ops_data[jj], config.e_ops_ind[jj],; config.e_ops_ptr[jj], config.psi0,; config.e_ops_isherm[jj]). for k in range(1, num_times):; ODE.integrate(config.tlist[k], step=0) # integrate up to tlist[k]; if ODE.successful():; state = ODE.y / dznrm2(ODE.y); for jj in range(config.e_num):; expect_out[jj][k] = cy_expect_psi_csr(; config.e_ops_data[jj], config.e_ops_ind[jj],; config.e_ops_ptr[jj], state,; config.e_ops_isherm[jj]); else:; raise ValueError('Error in ODE solver'). return expect_out. # -----------------------------------------------------------------------------; # single-trajectory for monte carlo; # -----------------------------------------------------------------------------; def _mc_alg_evolve(nt, config, opt, seeds):; """"""; Monte Carlo algorithm returning state-vector or expectation values; at times tlist for a single trajectory.; """""". global _cy_rhs_func; global _cy_col_spmv_func, _cy_col_expect_func; global _cy_col_spmv_call_func, _cy_col_expect_call_func. tlist = config.tlist; num_times = len(tlist). if not _",MatchSource.WIKI,docs/4.2/modules/qutip/mcsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html
https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:20812,Modifiability,config,config,20812,"ig.options; if config.tflag in [1, 10, 11]:; ODE = ode(_cy_rhs_func); code = compile('ODE.set_f_params(' + config.string + ')',; '<string>', 'exec'); exec(code); elif config.tflag == 2:; ODE = ode(_cRHStd); ODE.set_f_params(config); elif config.tflag in [20, 22]:; if config.options.rhs_with_state:; ODE = ode(_tdRHStd_with_state); else:; ODE = ode(_tdRHStd); ODE.set_f_params(config); elif config.tflag == 3:; if config.options.rhs_with_state:; ODE = ode(_pyRHSc_with_state); else:; ODE = ode(_pyRHSc); ODE.set_f_params(config); else:; ODE = ode(cy_ode_rhs); ODE.set_f_params(config.h_data, config.h_ind, config.h_ptr). ODE.set_integrator('zvode', method=opt.method, order=opt.order,; atol=opt.atol, rtol=opt.rtol, nsteps=opt.nsteps,; first_step=opt.first_step, min_step=opt.min_step,; max_step=opt.max_step); ODE.set_initial_value(config.psi0, config.tlist[0]); for jj in range(config.e_num):; expect_out[jj][0] = cy_expect_psi_csr(; config.e_ops_data[jj], config.e_ops_ind[jj],; config.e_ops_ptr[jj], config.psi0,; config.e_ops_isherm[jj]). for k in range(1, num_times):; ODE.integrate(config.tlist[k], step=0) # integrate up to tlist[k]; if ODE.successful():; state = ODE.y / dznrm2(ODE.y); for jj in range(config.e_num):; expect_out[jj][k] = cy_expect_psi_csr(; config.e_ops_data[jj], config.e_ops_ind[jj],; config.e_ops_ptr[jj], state,; config.e_ops_isherm[jj]); else:; raise ValueError('Error in ODE solver'). return expect_out. # -----------------------------------------------------------------------------; # single-trajectory for monte carlo; # -----------------------------------------------------------------------------; def _mc_alg_evolve(nt, config, opt, seeds):; """"""; Monte Carlo algorithm returning state-vector or expectation values; at times tlist for a single trajectory.; """""". global _cy_rhs_func; global _cy_col_spmv_func, _cy_col_expect_func; global _cy_col_spmv_call_func, _cy_col_expect_call_func. tlist = config.tlist; num_times = len(tlist). if not _cy_rhs_func:; _mc_func",MatchSource.WIKI,docs/4.2/modules/qutip/mcsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html
https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:20826,Modifiability,config,config,20826,"fig.tflag in [1, 10, 11]:; ODE = ode(_cy_rhs_func); code = compile('ODE.set_f_params(' + config.string + ')',; '<string>', 'exec'); exec(code); elif config.tflag == 2:; ODE = ode(_cRHStd); ODE.set_f_params(config); elif config.tflag in [20, 22]:; if config.options.rhs_with_state:; ODE = ode(_tdRHStd_with_state); else:; ODE = ode(_tdRHStd); ODE.set_f_params(config); elif config.tflag == 3:; if config.options.rhs_with_state:; ODE = ode(_pyRHSc_with_state); else:; ODE = ode(_pyRHSc); ODE.set_f_params(config); else:; ODE = ode(cy_ode_rhs); ODE.set_f_params(config.h_data, config.h_ind, config.h_ptr). ODE.set_integrator('zvode', method=opt.method, order=opt.order,; atol=opt.atol, rtol=opt.rtol, nsteps=opt.nsteps,; first_step=opt.first_step, min_step=opt.min_step,; max_step=opt.max_step); ODE.set_initial_value(config.psi0, config.tlist[0]); for jj in range(config.e_num):; expect_out[jj][0] = cy_expect_psi_csr(; config.e_ops_data[jj], config.e_ops_ind[jj],; config.e_ops_ptr[jj], config.psi0,; config.e_ops_isherm[jj]). for k in range(1, num_times):; ODE.integrate(config.tlist[k], step=0) # integrate up to tlist[k]; if ODE.successful():; state = ODE.y / dznrm2(ODE.y); for jj in range(config.e_num):; expect_out[jj][k] = cy_expect_psi_csr(; config.e_ops_data[jj], config.e_ops_ind[jj],; config.e_ops_ptr[jj], state,; config.e_ops_isherm[jj]); else:; raise ValueError('Error in ODE solver'). return expect_out. # -----------------------------------------------------------------------------; # single-trajectory for monte carlo; # -----------------------------------------------------------------------------; def _mc_alg_evolve(nt, config, opt, seeds):; """"""; Monte Carlo algorithm returning state-vector or expectation values; at times tlist for a single trajectory.; """""". global _cy_rhs_func; global _cy_col_spmv_func, _cy_col_expect_func; global _cy_col_spmv_call_func, _cy_col_expect_call_func. tlist = config.tlist; num_times = len(tlist). if not _cy_rhs_func:; _mc_func_load(config). if ",MatchSource.WIKI,docs/4.2/modules/qutip/mcsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html
https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:20897,Modifiability,config,config,20897,"DE.set_f_params(' + config.string + ')',; '<string>', 'exec'); exec(code); elif config.tflag == 2:; ODE = ode(_cRHStd); ODE.set_f_params(config); elif config.tflag in [20, 22]:; if config.options.rhs_with_state:; ODE = ode(_tdRHStd_with_state); else:; ODE = ode(_tdRHStd); ODE.set_f_params(config); elif config.tflag == 3:; if config.options.rhs_with_state:; ODE = ode(_pyRHSc_with_state); else:; ODE = ode(_pyRHSc); ODE.set_f_params(config); else:; ODE = ode(cy_ode_rhs); ODE.set_f_params(config.h_data, config.h_ind, config.h_ptr). ODE.set_integrator('zvode', method=opt.method, order=opt.order,; atol=opt.atol, rtol=opt.rtol, nsteps=opt.nsteps,; first_step=opt.first_step, min_step=opt.min_step,; max_step=opt.max_step); ODE.set_initial_value(config.psi0, config.tlist[0]); for jj in range(config.e_num):; expect_out[jj][0] = cy_expect_psi_csr(; config.e_ops_data[jj], config.e_ops_ind[jj],; config.e_ops_ptr[jj], config.psi0,; config.e_ops_isherm[jj]). for k in range(1, num_times):; ODE.integrate(config.tlist[k], step=0) # integrate up to tlist[k]; if ODE.successful():; state = ODE.y / dznrm2(ODE.y); for jj in range(config.e_num):; expect_out[jj][k] = cy_expect_psi_csr(; config.e_ops_data[jj], config.e_ops_ind[jj],; config.e_ops_ptr[jj], state,; config.e_ops_isherm[jj]); else:; raise ValueError('Error in ODE solver'). return expect_out. # -----------------------------------------------------------------------------; # single-trajectory for monte carlo; # -----------------------------------------------------------------------------; def _mc_alg_evolve(nt, config, opt, seeds):; """"""; Monte Carlo algorithm returning state-vector or expectation values; at times tlist for a single trajectory.; """""". global _cy_rhs_func; global _cy_col_spmv_func, _cy_col_expect_func; global _cy_col_spmv_call_func, _cy_col_expect_call_func. tlist = config.tlist; num_times = len(tlist). if not _cy_rhs_func:; _mc_func_load(config). if config.options.steady_state_average:; states_out = np.zeros((1), dtype",MatchSource.WIKI,docs/4.2/modules/qutip/mcsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html
https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:21019,Modifiability,config,config,21019,"); ODE.set_f_params(config); elif config.tflag in [20, 22]:; if config.options.rhs_with_state:; ODE = ode(_tdRHStd_with_state); else:; ODE = ode(_tdRHStd); ODE.set_f_params(config); elif config.tflag == 3:; if config.options.rhs_with_state:; ODE = ode(_pyRHSc_with_state); else:; ODE = ode(_pyRHSc); ODE.set_f_params(config); else:; ODE = ode(cy_ode_rhs); ODE.set_f_params(config.h_data, config.h_ind, config.h_ptr). ODE.set_integrator('zvode', method=opt.method, order=opt.order,; atol=opt.atol, rtol=opt.rtol, nsteps=opt.nsteps,; first_step=opt.first_step, min_step=opt.min_step,; max_step=opt.max_step); ODE.set_initial_value(config.psi0, config.tlist[0]); for jj in range(config.e_num):; expect_out[jj][0] = cy_expect_psi_csr(; config.e_ops_data[jj], config.e_ops_ind[jj],; config.e_ops_ptr[jj], config.psi0,; config.e_ops_isherm[jj]). for k in range(1, num_times):; ODE.integrate(config.tlist[k], step=0) # integrate up to tlist[k]; if ODE.successful():; state = ODE.y / dznrm2(ODE.y); for jj in range(config.e_num):; expect_out[jj][k] = cy_expect_psi_csr(; config.e_ops_data[jj], config.e_ops_ind[jj],; config.e_ops_ptr[jj], state,; config.e_ops_isherm[jj]); else:; raise ValueError('Error in ODE solver'). return expect_out. # -----------------------------------------------------------------------------; # single-trajectory for monte carlo; # -----------------------------------------------------------------------------; def _mc_alg_evolve(nt, config, opt, seeds):; """"""; Monte Carlo algorithm returning state-vector or expectation values; at times tlist for a single trajectory.; """""". global _cy_rhs_func; global _cy_col_spmv_func, _cy_col_expect_func; global _cy_col_spmv_call_func, _cy_col_expect_call_func. tlist = config.tlist; num_times = len(tlist). if not _cy_rhs_func:; _mc_func_load(config). if config.options.steady_state_average:; states_out = np.zeros((1), dtype=object); else:; states_out = np.zeros((num_times), dtype=object). temp = sp.csr_matrix(; np.reshape(config.psi0, (co",MatchSource.WIKI,docs/4.2/modules/qutip/mcsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html
https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:21075,Modifiability,config,config,21075,"flag in [20, 22]:; if config.options.rhs_with_state:; ODE = ode(_tdRHStd_with_state); else:; ODE = ode(_tdRHStd); ODE.set_f_params(config); elif config.tflag == 3:; if config.options.rhs_with_state:; ODE = ode(_pyRHSc_with_state); else:; ODE = ode(_pyRHSc); ODE.set_f_params(config); else:; ODE = ode(cy_ode_rhs); ODE.set_f_params(config.h_data, config.h_ind, config.h_ptr). ODE.set_integrator('zvode', method=opt.method, order=opt.order,; atol=opt.atol, rtol=opt.rtol, nsteps=opt.nsteps,; first_step=opt.first_step, min_step=opt.min_step,; max_step=opt.max_step); ODE.set_initial_value(config.psi0, config.tlist[0]); for jj in range(config.e_num):; expect_out[jj][0] = cy_expect_psi_csr(; config.e_ops_data[jj], config.e_ops_ind[jj],; config.e_ops_ptr[jj], config.psi0,; config.e_ops_isherm[jj]). for k in range(1, num_times):; ODE.integrate(config.tlist[k], step=0) # integrate up to tlist[k]; if ODE.successful():; state = ODE.y / dznrm2(ODE.y); for jj in range(config.e_num):; expect_out[jj][k] = cy_expect_psi_csr(; config.e_ops_data[jj], config.e_ops_ind[jj],; config.e_ops_ptr[jj], state,; config.e_ops_isherm[jj]); else:; raise ValueError('Error in ODE solver'). return expect_out. # -----------------------------------------------------------------------------; # single-trajectory for monte carlo; # -----------------------------------------------------------------------------; def _mc_alg_evolve(nt, config, opt, seeds):; """"""; Monte Carlo algorithm returning state-vector or expectation values; at times tlist for a single trajectory.; """""". global _cy_rhs_func; global _cy_col_spmv_func, _cy_col_expect_func; global _cy_col_spmv_call_func, _cy_col_expect_call_func. tlist = config.tlist; num_times = len(tlist). if not _cy_rhs_func:; _mc_func_load(config). if config.options.steady_state_average:; states_out = np.zeros((1), dtype=object); else:; states_out = np.zeros((num_times), dtype=object). temp = sp.csr_matrix(; np.reshape(config.psi0, (config.psi0.shape[0], 1)),; dtype=complex);",MatchSource.WIKI,docs/4.2/modules/qutip/mcsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html
https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:21098,Modifiability,config,config,21098,"s_with_state:; ODE = ode(_tdRHStd_with_state); else:; ODE = ode(_tdRHStd); ODE.set_f_params(config); elif config.tflag == 3:; if config.options.rhs_with_state:; ODE = ode(_pyRHSc_with_state); else:; ODE = ode(_pyRHSc); ODE.set_f_params(config); else:; ODE = ode(cy_ode_rhs); ODE.set_f_params(config.h_data, config.h_ind, config.h_ptr). ODE.set_integrator('zvode', method=opt.method, order=opt.order,; atol=opt.atol, rtol=opt.rtol, nsteps=opt.nsteps,; first_step=opt.first_step, min_step=opt.min_step,; max_step=opt.max_step); ODE.set_initial_value(config.psi0, config.tlist[0]); for jj in range(config.e_num):; expect_out[jj][0] = cy_expect_psi_csr(; config.e_ops_data[jj], config.e_ops_ind[jj],; config.e_ops_ptr[jj], config.psi0,; config.e_ops_isherm[jj]). for k in range(1, num_times):; ODE.integrate(config.tlist[k], step=0) # integrate up to tlist[k]; if ODE.successful():; state = ODE.y / dznrm2(ODE.y); for jj in range(config.e_num):; expect_out[jj][k] = cy_expect_psi_csr(; config.e_ops_data[jj], config.e_ops_ind[jj],; config.e_ops_ptr[jj], state,; config.e_ops_isherm[jj]); else:; raise ValueError('Error in ODE solver'). return expect_out. # -----------------------------------------------------------------------------; # single-trajectory for monte carlo; # -----------------------------------------------------------------------------; def _mc_alg_evolve(nt, config, opt, seeds):; """"""; Monte Carlo algorithm returning state-vector or expectation values; at times tlist for a single trajectory.; """""". global _cy_rhs_func; global _cy_col_spmv_func, _cy_col_expect_func; global _cy_col_spmv_call_func, _cy_col_expect_call_func. tlist = config.tlist; num_times = len(tlist). if not _cy_rhs_func:; _mc_func_load(config). if config.options.steady_state_average:; states_out = np.zeros((1), dtype=object); else:; states_out = np.zeros((num_times), dtype=object). temp = sp.csr_matrix(; np.reshape(config.psi0, (config.psi0.shape[0], 1)),; dtype=complex); temp = csr2fast(temp); if (config.optio",MatchSource.WIKI,docs/4.2/modules/qutip/mcsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html
https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:21121,Modifiability,config,config,21121,"e(_tdRHStd_with_state); else:; ODE = ode(_tdRHStd); ODE.set_f_params(config); elif config.tflag == 3:; if config.options.rhs_with_state:; ODE = ode(_pyRHSc_with_state); else:; ODE = ode(_pyRHSc); ODE.set_f_params(config); else:; ODE = ode(cy_ode_rhs); ODE.set_f_params(config.h_data, config.h_ind, config.h_ptr). ODE.set_integrator('zvode', method=opt.method, order=opt.order,; atol=opt.atol, rtol=opt.rtol, nsteps=opt.nsteps,; first_step=opt.first_step, min_step=opt.min_step,; max_step=opt.max_step); ODE.set_initial_value(config.psi0, config.tlist[0]); for jj in range(config.e_num):; expect_out[jj][0] = cy_expect_psi_csr(; config.e_ops_data[jj], config.e_ops_ind[jj],; config.e_ops_ptr[jj], config.psi0,; config.e_ops_isherm[jj]). for k in range(1, num_times):; ODE.integrate(config.tlist[k], step=0) # integrate up to tlist[k]; if ODE.successful():; state = ODE.y / dznrm2(ODE.y); for jj in range(config.e_num):; expect_out[jj][k] = cy_expect_psi_csr(; config.e_ops_data[jj], config.e_ops_ind[jj],; config.e_ops_ptr[jj], state,; config.e_ops_isherm[jj]); else:; raise ValueError('Error in ODE solver'). return expect_out. # -----------------------------------------------------------------------------; # single-trajectory for monte carlo; # -----------------------------------------------------------------------------; def _mc_alg_evolve(nt, config, opt, seeds):; """"""; Monte Carlo algorithm returning state-vector or expectation values; at times tlist for a single trajectory.; """""". global _cy_rhs_func; global _cy_col_spmv_func, _cy_col_expect_func; global _cy_col_spmv_call_func, _cy_col_expect_call_func. tlist = config.tlist; num_times = len(tlist). if not _cy_rhs_func:; _mc_func_load(config). if config.options.steady_state_average:; states_out = np.zeros((1), dtype=object); else:; states_out = np.zeros((num_times), dtype=object). temp = sp.csr_matrix(; np.reshape(config.psi0, (config.psi0.shape[0], 1)),; dtype=complex); temp = csr2fast(temp); if (config.options.average_states and; ",MatchSource.WIKI,docs/4.2/modules/qutip/mcsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html
https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:21151,Modifiability,config,config,21151,"e:; ODE = ode(_tdRHStd); ODE.set_f_params(config); elif config.tflag == 3:; if config.options.rhs_with_state:; ODE = ode(_pyRHSc_with_state); else:; ODE = ode(_pyRHSc); ODE.set_f_params(config); else:; ODE = ode(cy_ode_rhs); ODE.set_f_params(config.h_data, config.h_ind, config.h_ptr). ODE.set_integrator('zvode', method=opt.method, order=opt.order,; atol=opt.atol, rtol=opt.rtol, nsteps=opt.nsteps,; first_step=opt.first_step, min_step=opt.min_step,; max_step=opt.max_step); ODE.set_initial_value(config.psi0, config.tlist[0]); for jj in range(config.e_num):; expect_out[jj][0] = cy_expect_psi_csr(; config.e_ops_data[jj], config.e_ops_ind[jj],; config.e_ops_ptr[jj], config.psi0,; config.e_ops_isherm[jj]). for k in range(1, num_times):; ODE.integrate(config.tlist[k], step=0) # integrate up to tlist[k]; if ODE.successful():; state = ODE.y / dznrm2(ODE.y); for jj in range(config.e_num):; expect_out[jj][k] = cy_expect_psi_csr(; config.e_ops_data[jj], config.e_ops_ind[jj],; config.e_ops_ptr[jj], state,; config.e_ops_isherm[jj]); else:; raise ValueError('Error in ODE solver'). return expect_out. # -----------------------------------------------------------------------------; # single-trajectory for monte carlo; # -----------------------------------------------------------------------------; def _mc_alg_evolve(nt, config, opt, seeds):; """"""; Monte Carlo algorithm returning state-vector or expectation values; at times tlist for a single trajectory.; """""". global _cy_rhs_func; global _cy_col_spmv_func, _cy_col_expect_func; global _cy_col_spmv_call_func, _cy_col_expect_call_func. tlist = config.tlist; num_times = len(tlist). if not _cy_rhs_func:; _mc_func_load(config). if config.options.steady_state_average:; states_out = np.zeros((1), dtype=object); else:; states_out = np.zeros((num_times), dtype=object). temp = sp.csr_matrix(; np.reshape(config.psi0, (config.psi0.shape[0], 1)),; dtype=complex); temp = csr2fast(temp); if (config.options.average_states and; not config.options.steady_",MatchSource.WIKI,docs/4.2/modules/qutip/mcsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html
https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:21466,Modifiability,config,config,21466,"h_ptr). ODE.set_integrator('zvode', method=opt.method, order=opt.order,; atol=opt.atol, rtol=opt.rtol, nsteps=opt.nsteps,; first_step=opt.first_step, min_step=opt.min_step,; max_step=opt.max_step); ODE.set_initial_value(config.psi0, config.tlist[0]); for jj in range(config.e_num):; expect_out[jj][0] = cy_expect_psi_csr(; config.e_ops_data[jj], config.e_ops_ind[jj],; config.e_ops_ptr[jj], config.psi0,; config.e_ops_isherm[jj]). for k in range(1, num_times):; ODE.integrate(config.tlist[k], step=0) # integrate up to tlist[k]; if ODE.successful():; state = ODE.y / dznrm2(ODE.y); for jj in range(config.e_num):; expect_out[jj][k] = cy_expect_psi_csr(; config.e_ops_data[jj], config.e_ops_ind[jj],; config.e_ops_ptr[jj], state,; config.e_ops_isherm[jj]); else:; raise ValueError('Error in ODE solver'). return expect_out. # -----------------------------------------------------------------------------; # single-trajectory for monte carlo; # -----------------------------------------------------------------------------; def _mc_alg_evolve(nt, config, opt, seeds):; """"""; Monte Carlo algorithm returning state-vector or expectation values; at times tlist for a single trajectory.; """""". global _cy_rhs_func; global _cy_col_spmv_func, _cy_col_expect_func; global _cy_col_spmv_call_func, _cy_col_expect_call_func. tlist = config.tlist; num_times = len(tlist). if not _cy_rhs_func:; _mc_func_load(config). if config.options.steady_state_average:; states_out = np.zeros((1), dtype=object); else:; states_out = np.zeros((num_times), dtype=object). temp = sp.csr_matrix(; np.reshape(config.psi0, (config.psi0.shape[0], 1)),; dtype=complex); temp = csr2fast(temp); if (config.options.average_states and; not config.options.steady_state_average):; # output is averaged states, so use dm; states_out[0] = Qobj(temp*temp.H,; [config.psi0_dims[0],; config.psi0_dims[0]],; [config.psi0_shape[0],; config.psi0_shape[0]],; fast='mc-dm'); elif (not config.options.average_states and; not config.options.steady_state_a",MatchSource.WIKI,docs/4.2/modules/qutip/mcsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html
https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:21740,Modifiability,config,config,21740,"sr(; config.e_ops_data[jj], config.e_ops_ind[jj],; config.e_ops_ptr[jj], config.psi0,; config.e_ops_isherm[jj]). for k in range(1, num_times):; ODE.integrate(config.tlist[k], step=0) # integrate up to tlist[k]; if ODE.successful():; state = ODE.y / dznrm2(ODE.y); for jj in range(config.e_num):; expect_out[jj][k] = cy_expect_psi_csr(; config.e_ops_data[jj], config.e_ops_ind[jj],; config.e_ops_ptr[jj], state,; config.e_ops_isherm[jj]); else:; raise ValueError('Error in ODE solver'). return expect_out. # -----------------------------------------------------------------------------; # single-trajectory for monte carlo; # -----------------------------------------------------------------------------; def _mc_alg_evolve(nt, config, opt, seeds):; """"""; Monte Carlo algorithm returning state-vector or expectation values; at times tlist for a single trajectory.; """""". global _cy_rhs_func; global _cy_col_spmv_func, _cy_col_expect_func; global _cy_col_spmv_call_func, _cy_col_expect_call_func. tlist = config.tlist; num_times = len(tlist). if not _cy_rhs_func:; _mc_func_load(config). if config.options.steady_state_average:; states_out = np.zeros((1), dtype=object); else:; states_out = np.zeros((num_times), dtype=object). temp = sp.csr_matrix(; np.reshape(config.psi0, (config.psi0.shape[0], 1)),; dtype=complex); temp = csr2fast(temp); if (config.options.average_states and; not config.options.steady_state_average):; # output is averaged states, so use dm; states_out[0] = Qobj(temp*temp.H,; [config.psi0_dims[0],; config.psi0_dims[0]],; [config.psi0_shape[0],; config.psi0_shape[0]],; fast='mc-dm'); elif (not config.options.average_states and; not config.options.steady_state_average):; # output is not averaged, so write state vectors; states_out[0] = Qobj(temp, config.psi0_dims,; config.psi0_shape, fast='mc'); elif config.options.steady_state_average:; states_out[0] = temp * temp.H. # PRE-GENERATE LIST FOR EXPECTATION VALUES; expect_out = []; for i in range(config.e_num):; if config.e_op",MatchSource.WIKI,docs/4.2/modules/qutip/mcsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html
https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:21814,Modifiability,config,config,21814,"ops_ptr[jj], config.psi0,; config.e_ops_isherm[jj]). for k in range(1, num_times):; ODE.integrate(config.tlist[k], step=0) # integrate up to tlist[k]; if ODE.successful():; state = ODE.y / dznrm2(ODE.y); for jj in range(config.e_num):; expect_out[jj][k] = cy_expect_psi_csr(; config.e_ops_data[jj], config.e_ops_ind[jj],; config.e_ops_ptr[jj], state,; config.e_ops_isherm[jj]); else:; raise ValueError('Error in ODE solver'). return expect_out. # -----------------------------------------------------------------------------; # single-trajectory for monte carlo; # -----------------------------------------------------------------------------; def _mc_alg_evolve(nt, config, opt, seeds):; """"""; Monte Carlo algorithm returning state-vector or expectation values; at times tlist for a single trajectory.; """""". global _cy_rhs_func; global _cy_col_spmv_func, _cy_col_expect_func; global _cy_col_spmv_call_func, _cy_col_expect_call_func. tlist = config.tlist; num_times = len(tlist). if not _cy_rhs_func:; _mc_func_load(config). if config.options.steady_state_average:; states_out = np.zeros((1), dtype=object); else:; states_out = np.zeros((num_times), dtype=object). temp = sp.csr_matrix(; np.reshape(config.psi0, (config.psi0.shape[0], 1)),; dtype=complex); temp = csr2fast(temp); if (config.options.average_states and; not config.options.steady_state_average):; # output is averaged states, so use dm; states_out[0] = Qobj(temp*temp.H,; [config.psi0_dims[0],; config.psi0_dims[0]],; [config.psi0_shape[0],; config.psi0_shape[0]],; fast='mc-dm'); elif (not config.options.average_states and; not config.options.steady_state_average):; # output is not averaged, so write state vectors; states_out[0] = Qobj(temp, config.psi0_dims,; config.psi0_shape, fast='mc'); elif config.options.steady_state_average:; states_out[0] = temp * temp.H. # PRE-GENERATE LIST FOR EXPECTATION VALUES; expect_out = []; for i in range(config.e_num):; if config.e_ops_isherm[i]:; # preallocate real array of zeros; expect_out.a",MatchSource.WIKI,docs/4.2/modules/qutip/mcsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html
https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:21826,Modifiability,config,config,21826,"onfig.e_ops_isherm[jj]). for k in range(1, num_times):; ODE.integrate(config.tlist[k], step=0) # integrate up to tlist[k]; if ODE.successful():; state = ODE.y / dznrm2(ODE.y); for jj in range(config.e_num):; expect_out[jj][k] = cy_expect_psi_csr(; config.e_ops_data[jj], config.e_ops_ind[jj],; config.e_ops_ptr[jj], state,; config.e_ops_isherm[jj]); else:; raise ValueError('Error in ODE solver'). return expect_out. # -----------------------------------------------------------------------------; # single-trajectory for monte carlo; # -----------------------------------------------------------------------------; def _mc_alg_evolve(nt, config, opt, seeds):; """"""; Monte Carlo algorithm returning state-vector or expectation values; at times tlist for a single trajectory.; """""". global _cy_rhs_func; global _cy_col_spmv_func, _cy_col_expect_func; global _cy_col_spmv_call_func, _cy_col_expect_call_func. tlist = config.tlist; num_times = len(tlist). if not _cy_rhs_func:; _mc_func_load(config). if config.options.steady_state_average:; states_out = np.zeros((1), dtype=object); else:; states_out = np.zeros((num_times), dtype=object). temp = sp.csr_matrix(; np.reshape(config.psi0, (config.psi0.shape[0], 1)),; dtype=complex); temp = csr2fast(temp); if (config.options.average_states and; not config.options.steady_state_average):; # output is averaged states, so use dm; states_out[0] = Qobj(temp*temp.H,; [config.psi0_dims[0],; config.psi0_dims[0]],; [config.psi0_shape[0],; config.psi0_shape[0]],; fast='mc-dm'); elif (not config.options.average_states and; not config.options.steady_state_average):; # output is not averaged, so write state vectors; states_out[0] = Qobj(temp, config.psi0_dims,; config.psi0_shape, fast='mc'); elif config.options.steady_state_average:; states_out[0] = temp * temp.H. # PRE-GENERATE LIST FOR EXPECTATION VALUES; expect_out = []; for i in range(config.e_num):; if config.e_ops_isherm[i]:; # preallocate real array of zeros; expect_out.append(np.zeros(num_times, dt",MatchSource.WIKI,docs/4.2/modules/qutip/mcsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html
https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:21997,Modifiability,config,config,21997,"DE.y); for jj in range(config.e_num):; expect_out[jj][k] = cy_expect_psi_csr(; config.e_ops_data[jj], config.e_ops_ind[jj],; config.e_ops_ptr[jj], state,; config.e_ops_isherm[jj]); else:; raise ValueError('Error in ODE solver'). return expect_out. # -----------------------------------------------------------------------------; # single-trajectory for monte carlo; # -----------------------------------------------------------------------------; def _mc_alg_evolve(nt, config, opt, seeds):; """"""; Monte Carlo algorithm returning state-vector or expectation values; at times tlist for a single trajectory.; """""". global _cy_rhs_func; global _cy_col_spmv_func, _cy_col_expect_func; global _cy_col_spmv_call_func, _cy_col_expect_call_func. tlist = config.tlist; num_times = len(tlist). if not _cy_rhs_func:; _mc_func_load(config). if config.options.steady_state_average:; states_out = np.zeros((1), dtype=object); else:; states_out = np.zeros((num_times), dtype=object). temp = sp.csr_matrix(; np.reshape(config.psi0, (config.psi0.shape[0], 1)),; dtype=complex); temp = csr2fast(temp); if (config.options.average_states and; not config.options.steady_state_average):; # output is averaged states, so use dm; states_out[0] = Qobj(temp*temp.H,; [config.psi0_dims[0],; config.psi0_dims[0]],; [config.psi0_shape[0],; config.psi0_shape[0]],; fast='mc-dm'); elif (not config.options.average_states and; not config.options.steady_state_average):; # output is not averaged, so write state vectors; states_out[0] = Qobj(temp, config.psi0_dims,; config.psi0_shape, fast='mc'); elif config.options.steady_state_average:; states_out[0] = temp * temp.H. # PRE-GENERATE LIST FOR EXPECTATION VALUES; expect_out = []; for i in range(config.e_num):; if config.e_ops_isherm[i]:; # preallocate real array of zeros; expect_out.append(np.zeros(num_times, dtype=float)); else:; # preallocate complex array of zeros; expect_out.append(np.zeros(num_times, dtype=complex)). expect_out[i][0] = \; cy_expect_psi_csr(config.e_ops_dat",MatchSource.WIKI,docs/4.2/modules/qutip/mcsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html
https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:22011,Modifiability,config,config,22011,"n range(config.e_num):; expect_out[jj][k] = cy_expect_psi_csr(; config.e_ops_data[jj], config.e_ops_ind[jj],; config.e_ops_ptr[jj], state,; config.e_ops_isherm[jj]); else:; raise ValueError('Error in ODE solver'). return expect_out. # -----------------------------------------------------------------------------; # single-trajectory for monte carlo; # -----------------------------------------------------------------------------; def _mc_alg_evolve(nt, config, opt, seeds):; """"""; Monte Carlo algorithm returning state-vector or expectation values; at times tlist for a single trajectory.; """""". global _cy_rhs_func; global _cy_col_spmv_func, _cy_col_expect_func; global _cy_col_spmv_call_func, _cy_col_expect_call_func. tlist = config.tlist; num_times = len(tlist). if not _cy_rhs_func:; _mc_func_load(config). if config.options.steady_state_average:; states_out = np.zeros((1), dtype=object); else:; states_out = np.zeros((num_times), dtype=object). temp = sp.csr_matrix(; np.reshape(config.psi0, (config.psi0.shape[0], 1)),; dtype=complex); temp = csr2fast(temp); if (config.options.average_states and; not config.options.steady_state_average):; # output is averaged states, so use dm; states_out[0] = Qobj(temp*temp.H,; [config.psi0_dims[0],; config.psi0_dims[0]],; [config.psi0_shape[0],; config.psi0_shape[0]],; fast='mc-dm'); elif (not config.options.average_states and; not config.options.steady_state_average):; # output is not averaged, so write state vectors; states_out[0] = Qobj(temp, config.psi0_dims,; config.psi0_shape, fast='mc'); elif config.options.steady_state_average:; states_out[0] = temp * temp.H. # PRE-GENERATE LIST FOR EXPECTATION VALUES; expect_out = []; for i in range(config.e_num):; if config.e_ops_isherm[i]:; # preallocate real array of zeros; expect_out.append(np.zeros(num_times, dtype=float)); else:; # preallocate complex array of zeros; expect_out.append(np.zeros(num_times, dtype=complex)). expect_out[i][0] = \; cy_expect_psi_csr(config.e_ops_data[i],; config.",MatchSource.WIKI,docs/4.2/modules/qutip/mcsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html
https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:22082,Modifiability,config,config,22082,"y_expect_psi_csr(; config.e_ops_data[jj], config.e_ops_ind[jj],; config.e_ops_ptr[jj], state,; config.e_ops_isherm[jj]); else:; raise ValueError('Error in ODE solver'). return expect_out. # -----------------------------------------------------------------------------; # single-trajectory for monte carlo; # -----------------------------------------------------------------------------; def _mc_alg_evolve(nt, config, opt, seeds):; """"""; Monte Carlo algorithm returning state-vector or expectation values; at times tlist for a single trajectory.; """""". global _cy_rhs_func; global _cy_col_spmv_func, _cy_col_expect_func; global _cy_col_spmv_call_func, _cy_col_expect_call_func. tlist = config.tlist; num_times = len(tlist). if not _cy_rhs_func:; _mc_func_load(config). if config.options.steady_state_average:; states_out = np.zeros((1), dtype=object); else:; states_out = np.zeros((num_times), dtype=object). temp = sp.csr_matrix(; np.reshape(config.psi0, (config.psi0.shape[0], 1)),; dtype=complex); temp = csr2fast(temp); if (config.options.average_states and; not config.options.steady_state_average):; # output is averaged states, so use dm; states_out[0] = Qobj(temp*temp.H,; [config.psi0_dims[0],; config.psi0_dims[0]],; [config.psi0_shape[0],; config.psi0_shape[0]],; fast='mc-dm'); elif (not config.options.average_states and; not config.options.steady_state_average):; # output is not averaged, so write state vectors; states_out[0] = Qobj(temp, config.psi0_dims,; config.psi0_shape, fast='mc'); elif config.options.steady_state_average:; states_out[0] = temp * temp.H. # PRE-GENERATE LIST FOR EXPECTATION VALUES; expect_out = []; for i in range(config.e_num):; if config.e_ops_isherm[i]:; # preallocate real array of zeros; expect_out.append(np.zeros(num_times, dtype=float)); else:; # preallocate complex array of zeros; expect_out.append(np.zeros(num_times, dtype=complex)). expect_out[i][0] = \; cy_expect_psi_csr(config.e_ops_data[i],; config.e_ops_ind[i],; config.e_ops_ptr[i],; config.p",MatchSource.WIKI,docs/4.2/modules/qutip/mcsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html
https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:22121,Modifiability,config,config,22121,"nd[jj],; config.e_ops_ptr[jj], state,; config.e_ops_isherm[jj]); else:; raise ValueError('Error in ODE solver'). return expect_out. # -----------------------------------------------------------------------------; # single-trajectory for monte carlo; # -----------------------------------------------------------------------------; def _mc_alg_evolve(nt, config, opt, seeds):; """"""; Monte Carlo algorithm returning state-vector or expectation values; at times tlist for a single trajectory.; """""". global _cy_rhs_func; global _cy_col_spmv_func, _cy_col_expect_func; global _cy_col_spmv_call_func, _cy_col_expect_call_func. tlist = config.tlist; num_times = len(tlist). if not _cy_rhs_func:; _mc_func_load(config). if config.options.steady_state_average:; states_out = np.zeros((1), dtype=object); else:; states_out = np.zeros((num_times), dtype=object). temp = sp.csr_matrix(; np.reshape(config.psi0, (config.psi0.shape[0], 1)),; dtype=complex); temp = csr2fast(temp); if (config.options.average_states and; not config.options.steady_state_average):; # output is averaged states, so use dm; states_out[0] = Qobj(temp*temp.H,; [config.psi0_dims[0],; config.psi0_dims[0]],; [config.psi0_shape[0],; config.psi0_shape[0]],; fast='mc-dm'); elif (not config.options.average_states and; not config.options.steady_state_average):; # output is not averaged, so write state vectors; states_out[0] = Qobj(temp, config.psi0_dims,; config.psi0_shape, fast='mc'); elif config.options.steady_state_average:; states_out[0] = temp * temp.H. # PRE-GENERATE LIST FOR EXPECTATION VALUES; expect_out = []; for i in range(config.e_num):; if config.e_ops_isherm[i]:; # preallocate real array of zeros; expect_out.append(np.zeros(num_times, dtype=float)); else:; # preallocate complex array of zeros; expect_out.append(np.zeros(num_times, dtype=complex)). expect_out[i][0] = \; cy_expect_psi_csr(config.e_ops_data[i],; config.e_ops_ind[i],; config.e_ops_ptr[i],; config.psi0,; config.e_ops_isherm[i]). collapse_times = []; which",MatchSource.WIKI,docs/4.2/modules/qutip/mcsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html
https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:22236,Modifiability,config,config,22236,"t_out. # -----------------------------------------------------------------------------; # single-trajectory for monte carlo; # -----------------------------------------------------------------------------; def _mc_alg_evolve(nt, config, opt, seeds):; """"""; Monte Carlo algorithm returning state-vector or expectation values; at times tlist for a single trajectory.; """""". global _cy_rhs_func; global _cy_col_spmv_func, _cy_col_expect_func; global _cy_col_spmv_call_func, _cy_col_expect_call_func. tlist = config.tlist; num_times = len(tlist). if not _cy_rhs_func:; _mc_func_load(config). if config.options.steady_state_average:; states_out = np.zeros((1), dtype=object); else:; states_out = np.zeros((num_times), dtype=object). temp = sp.csr_matrix(; np.reshape(config.psi0, (config.psi0.shape[0], 1)),; dtype=complex); temp = csr2fast(temp); if (config.options.average_states and; not config.options.steady_state_average):; # output is averaged states, so use dm; states_out[0] = Qobj(temp*temp.H,; [config.psi0_dims[0],; config.psi0_dims[0]],; [config.psi0_shape[0],; config.psi0_shape[0]],; fast='mc-dm'); elif (not config.options.average_states and; not config.options.steady_state_average):; # output is not averaged, so write state vectors; states_out[0] = Qobj(temp, config.psi0_dims,; config.psi0_shape, fast='mc'); elif config.options.steady_state_average:; states_out[0] = temp * temp.H. # PRE-GENERATE LIST FOR EXPECTATION VALUES; expect_out = []; for i in range(config.e_num):; if config.e_ops_isherm[i]:; # preallocate real array of zeros; expect_out.append(np.zeros(num_times, dtype=float)); else:; # preallocate complex array of zeros; expect_out.append(np.zeros(num_times, dtype=complex)). expect_out[i][0] = \; cy_expect_psi_csr(config.e_ops_data[i],; config.e_ops_ind[i],; config.e_ops_ptr[i],; config.psi0,; config.e_ops_isherm[i]). collapse_times = []; which_oper = []. # SEED AND RNG AND GENERATE; prng = RandomState(seeds[nt]); # first rand is collapse norm, second is which opera",MatchSource.WIKI,docs/4.2/modules/qutip/mcsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html
https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:22258,Modifiability,config,config,22258,"---------------------------------------------------------------------; # single-trajectory for monte carlo; # -----------------------------------------------------------------------------; def _mc_alg_evolve(nt, config, opt, seeds):; """"""; Monte Carlo algorithm returning state-vector or expectation values; at times tlist for a single trajectory.; """""". global _cy_rhs_func; global _cy_col_spmv_func, _cy_col_expect_func; global _cy_col_spmv_call_func, _cy_col_expect_call_func. tlist = config.tlist; num_times = len(tlist). if not _cy_rhs_func:; _mc_func_load(config). if config.options.steady_state_average:; states_out = np.zeros((1), dtype=object); else:; states_out = np.zeros((num_times), dtype=object). temp = sp.csr_matrix(; np.reshape(config.psi0, (config.psi0.shape[0], 1)),; dtype=complex); temp = csr2fast(temp); if (config.options.average_states and; not config.options.steady_state_average):; # output is averaged states, so use dm; states_out[0] = Qobj(temp*temp.H,; [config.psi0_dims[0],; config.psi0_dims[0]],; [config.psi0_shape[0],; config.psi0_shape[0]],; fast='mc-dm'); elif (not config.options.average_states and; not config.options.steady_state_average):; # output is not averaged, so write state vectors; states_out[0] = Qobj(temp, config.psi0_dims,; config.psi0_shape, fast='mc'); elif config.options.steady_state_average:; states_out[0] = temp * temp.H. # PRE-GENERATE LIST FOR EXPECTATION VALUES; expect_out = []; for i in range(config.e_num):; if config.e_ops_isherm[i]:; # preallocate real array of zeros; expect_out.append(np.zeros(num_times, dtype=float)); else:; # preallocate complex array of zeros; expect_out.append(np.zeros(num_times, dtype=complex)). expect_out[i][0] = \; cy_expect_psi_csr(config.e_ops_data[i],; config.e_ops_ind[i],; config.e_ops_ptr[i],; config.psi0,; config.e_ops_isherm[i]). collapse_times = []; which_oper = []. # SEED AND RNG AND GENERATE; prng = RandomState(seeds[nt]); # first rand is collapse norm, second is which operator; rand_vals = ",MatchSource.WIKI,docs/4.2/modules/qutip/mcsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html
https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:22282,Modifiability,config,config,22282,"----------------------------------------------; # single-trajectory for monte carlo; # -----------------------------------------------------------------------------; def _mc_alg_evolve(nt, config, opt, seeds):; """"""; Monte Carlo algorithm returning state-vector or expectation values; at times tlist for a single trajectory.; """""". global _cy_rhs_func; global _cy_col_spmv_func, _cy_col_expect_func; global _cy_col_spmv_call_func, _cy_col_expect_call_func. tlist = config.tlist; num_times = len(tlist). if not _cy_rhs_func:; _mc_func_load(config). if config.options.steady_state_average:; states_out = np.zeros((1), dtype=object); else:; states_out = np.zeros((num_times), dtype=object). temp = sp.csr_matrix(; np.reshape(config.psi0, (config.psi0.shape[0], 1)),; dtype=complex); temp = csr2fast(temp); if (config.options.average_states and; not config.options.steady_state_average):; # output is averaged states, so use dm; states_out[0] = Qobj(temp*temp.H,; [config.psi0_dims[0],; config.psi0_dims[0]],; [config.psi0_shape[0],; config.psi0_shape[0]],; fast='mc-dm'); elif (not config.options.average_states and; not config.options.steady_state_average):; # output is not averaged, so write state vectors; states_out[0] = Qobj(temp, config.psi0_dims,; config.psi0_shape, fast='mc'); elif config.options.steady_state_average:; states_out[0] = temp * temp.H. # PRE-GENERATE LIST FOR EXPECTATION VALUES; expect_out = []; for i in range(config.e_num):; if config.e_ops_isherm[i]:; # preallocate real array of zeros; expect_out.append(np.zeros(num_times, dtype=float)); else:; # preallocate complex array of zeros; expect_out.append(np.zeros(num_times, dtype=complex)). expect_out[i][0] = \; cy_expect_psi_csr(config.e_ops_data[i],; config.e_ops_ind[i],; config.e_ops_ptr[i],; config.psi0,; config.e_ops_isherm[i]). collapse_times = []; which_oper = []. # SEED AND RNG AND GENERATE; prng = RandomState(seeds[nt]); # first rand is collapse norm, second is which operator; rand_vals = prng.rand(2). # CREATE ",MatchSource.WIKI,docs/4.2/modules/qutip/mcsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html
https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:22305,Modifiability,config,config,22305,"-----------------------; # single-trajectory for monte carlo; # -----------------------------------------------------------------------------; def _mc_alg_evolve(nt, config, opt, seeds):; """"""; Monte Carlo algorithm returning state-vector or expectation values; at times tlist for a single trajectory.; """""". global _cy_rhs_func; global _cy_col_spmv_func, _cy_col_expect_func; global _cy_col_spmv_call_func, _cy_col_expect_call_func. tlist = config.tlist; num_times = len(tlist). if not _cy_rhs_func:; _mc_func_load(config). if config.options.steady_state_average:; states_out = np.zeros((1), dtype=object); else:; states_out = np.zeros((num_times), dtype=object). temp = sp.csr_matrix(; np.reshape(config.psi0, (config.psi0.shape[0], 1)),; dtype=complex); temp = csr2fast(temp); if (config.options.average_states and; not config.options.steady_state_average):; # output is averaged states, so use dm; states_out[0] = Qobj(temp*temp.H,; [config.psi0_dims[0],; config.psi0_dims[0]],; [config.psi0_shape[0],; config.psi0_shape[0]],; fast='mc-dm'); elif (not config.options.average_states and; not config.options.steady_state_average):; # output is not averaged, so write state vectors; states_out[0] = Qobj(temp, config.psi0_dims,; config.psi0_shape, fast='mc'); elif config.options.steady_state_average:; states_out[0] = temp * temp.H. # PRE-GENERATE LIST FOR EXPECTATION VALUES; expect_out = []; for i in range(config.e_num):; if config.e_ops_isherm[i]:; # preallocate real array of zeros; expect_out.append(np.zeros(num_times, dtype=float)); else:; # preallocate complex array of zeros; expect_out.append(np.zeros(num_times, dtype=complex)). expect_out[i][0] = \; cy_expect_psi_csr(config.e_ops_data[i],; config.e_ops_ind[i],; config.e_ops_ptr[i],; config.psi0,; config.e_ops_isherm[i]). collapse_times = []; which_oper = []. # SEED AND RNG AND GENERATE; prng = RandomState(seeds[nt]); # first rand is collapse norm, second is which operator; rand_vals = prng.rand(2). # CREATE ODE OBJECT CORRESPONDING",MatchSource.WIKI,docs/4.2/modules/qutip/mcsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html
https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:22354,Modifiability,config,config,22354,"ajectory for monte carlo; # -----------------------------------------------------------------------------; def _mc_alg_evolve(nt, config, opt, seeds):; """"""; Monte Carlo algorithm returning state-vector or expectation values; at times tlist for a single trajectory.; """""". global _cy_rhs_func; global _cy_col_spmv_func, _cy_col_expect_func; global _cy_col_spmv_call_func, _cy_col_expect_call_func. tlist = config.tlist; num_times = len(tlist). if not _cy_rhs_func:; _mc_func_load(config). if config.options.steady_state_average:; states_out = np.zeros((1), dtype=object); else:; states_out = np.zeros((num_times), dtype=object). temp = sp.csr_matrix(; np.reshape(config.psi0, (config.psi0.shape[0], 1)),; dtype=complex); temp = csr2fast(temp); if (config.options.average_states and; not config.options.steady_state_average):; # output is averaged states, so use dm; states_out[0] = Qobj(temp*temp.H,; [config.psi0_dims[0],; config.psi0_dims[0]],; [config.psi0_shape[0],; config.psi0_shape[0]],; fast='mc-dm'); elif (not config.options.average_states and; not config.options.steady_state_average):; # output is not averaged, so write state vectors; states_out[0] = Qobj(temp, config.psi0_dims,; config.psi0_shape, fast='mc'); elif config.options.steady_state_average:; states_out[0] = temp * temp.H. # PRE-GENERATE LIST FOR EXPECTATION VALUES; expect_out = []; for i in range(config.e_num):; if config.e_ops_isherm[i]:; # preallocate real array of zeros; expect_out.append(np.zeros(num_times, dtype=float)); else:; # preallocate complex array of zeros; expect_out.append(np.zeros(num_times, dtype=complex)). expect_out[i][0] = \; cy_expect_psi_csr(config.e_ops_data[i],; config.e_ops_ind[i],; config.e_ops_ptr[i],; config.psi0,; config.e_ops_isherm[i]). collapse_times = []; which_oper = []. # SEED AND RNG AND GENERATE; prng = RandomState(seeds[nt]); # first rand is collapse norm, second is which operator; rand_vals = prng.rand(2). # CREATE ODE OBJECT CORRESPONDING TO DESIRED TIME-DEPENDENCE; if conf",MatchSource.WIKI,docs/4.2/modules/qutip/mcsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html
https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:22393,Modifiability,config,config,22393,"---------------------------------------------------------; def _mc_alg_evolve(nt, config, opt, seeds):; """"""; Monte Carlo algorithm returning state-vector or expectation values; at times tlist for a single trajectory.; """""". global _cy_rhs_func; global _cy_col_spmv_func, _cy_col_expect_func; global _cy_col_spmv_call_func, _cy_col_expect_call_func. tlist = config.tlist; num_times = len(tlist). if not _cy_rhs_func:; _mc_func_load(config). if config.options.steady_state_average:; states_out = np.zeros((1), dtype=object); else:; states_out = np.zeros((num_times), dtype=object). temp = sp.csr_matrix(; np.reshape(config.psi0, (config.psi0.shape[0], 1)),; dtype=complex); temp = csr2fast(temp); if (config.options.average_states and; not config.options.steady_state_average):; # output is averaged states, so use dm; states_out[0] = Qobj(temp*temp.H,; [config.psi0_dims[0],; config.psi0_dims[0]],; [config.psi0_shape[0],; config.psi0_shape[0]],; fast='mc-dm'); elif (not config.options.average_states and; not config.options.steady_state_average):; # output is not averaged, so write state vectors; states_out[0] = Qobj(temp, config.psi0_dims,; config.psi0_shape, fast='mc'); elif config.options.steady_state_average:; states_out[0] = temp * temp.H. # PRE-GENERATE LIST FOR EXPECTATION VALUES; expect_out = []; for i in range(config.e_num):; if config.e_ops_isherm[i]:; # preallocate real array of zeros; expect_out.append(np.zeros(num_times, dtype=float)); else:; # preallocate complex array of zeros; expect_out.append(np.zeros(num_times, dtype=complex)). expect_out[i][0] = \; cy_expect_psi_csr(config.e_ops_data[i],; config.e_ops_ind[i],; config.e_ops_ptr[i],; config.psi0,; config.e_ops_isherm[i]). collapse_times = []; which_oper = []. # SEED AND RNG AND GENERATE; prng = RandomState(seeds[nt]); # first rand is collapse norm, second is which operator; rand_vals = prng.rand(2). # CREATE ODE OBJECT CORRESPONDING TO DESIRED TIME-DEPENDENCE; if config.tflag in [1, 10, 11]:; ODE = ode(_cy_rhs_func",MatchSource.WIKI,docs/4.2/modules/qutip/mcsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html
https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:22509,Modifiability,config,config,22509,"nt, config, opt, seeds):; """"""; Monte Carlo algorithm returning state-vector or expectation values; at times tlist for a single trajectory.; """""". global _cy_rhs_func; global _cy_col_spmv_func, _cy_col_expect_func; global _cy_col_spmv_call_func, _cy_col_expect_call_func. tlist = config.tlist; num_times = len(tlist). if not _cy_rhs_func:; _mc_func_load(config). if config.options.steady_state_average:; states_out = np.zeros((1), dtype=object); else:; states_out = np.zeros((num_times), dtype=object). temp = sp.csr_matrix(; np.reshape(config.psi0, (config.psi0.shape[0], 1)),; dtype=complex); temp = csr2fast(temp); if (config.options.average_states and; not config.options.steady_state_average):; # output is averaged states, so use dm; states_out[0] = Qobj(temp*temp.H,; [config.psi0_dims[0],; config.psi0_dims[0]],; [config.psi0_shape[0],; config.psi0_shape[0]],; fast='mc-dm'); elif (not config.options.average_states and; not config.options.steady_state_average):; # output is not averaged, so write state vectors; states_out[0] = Qobj(temp, config.psi0_dims,; config.psi0_shape, fast='mc'); elif config.options.steady_state_average:; states_out[0] = temp * temp.H. # PRE-GENERATE LIST FOR EXPECTATION VALUES; expect_out = []; for i in range(config.e_num):; if config.e_ops_isherm[i]:; # preallocate real array of zeros; expect_out.append(np.zeros(num_times, dtype=float)); else:; # preallocate complex array of zeros; expect_out.append(np.zeros(num_times, dtype=complex)). expect_out[i][0] = \; cy_expect_psi_csr(config.e_ops_data[i],; config.e_ops_ind[i],; config.e_ops_ptr[i],; config.psi0,; config.e_ops_isherm[i]). collapse_times = []; which_oper = []. # SEED AND RNG AND GENERATE; prng = RandomState(seeds[nt]); # first rand is collapse norm, second is which operator; rand_vals = prng.rand(2). # CREATE ODE OBJECT CORRESPONDING TO DESIRED TIME-DEPENDENCE; if config.tflag in [1, 10, 11]:; ODE = ode(_cy_rhs_func); code = compile('ODE.set_f_params(' + config.string + ')',; '<string>', 'ex",MatchSource.WIKI,docs/4.2/modules/qutip/mcsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html
https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:22528,Modifiability,config,config,22528,"state-vector or expectation values; at times tlist for a single trajectory.; """""". global _cy_rhs_func; global _cy_col_spmv_func, _cy_col_expect_func; global _cy_col_spmv_call_func, _cy_col_expect_call_func. tlist = config.tlist; num_times = len(tlist). if not _cy_rhs_func:; _mc_func_load(config). if config.options.steady_state_average:; states_out = np.zeros((1), dtype=object); else:; states_out = np.zeros((num_times), dtype=object). temp = sp.csr_matrix(; np.reshape(config.psi0, (config.psi0.shape[0], 1)),; dtype=complex); temp = csr2fast(temp); if (config.options.average_states and; not config.options.steady_state_average):; # output is averaged states, so use dm; states_out[0] = Qobj(temp*temp.H,; [config.psi0_dims[0],; config.psi0_dims[0]],; [config.psi0_shape[0],; config.psi0_shape[0]],; fast='mc-dm'); elif (not config.options.average_states and; not config.options.steady_state_average):; # output is not averaged, so write state vectors; states_out[0] = Qobj(temp, config.psi0_dims,; config.psi0_shape, fast='mc'); elif config.options.steady_state_average:; states_out[0] = temp * temp.H. # PRE-GENERATE LIST FOR EXPECTATION VALUES; expect_out = []; for i in range(config.e_num):; if config.e_ops_isherm[i]:; # preallocate real array of zeros; expect_out.append(np.zeros(num_times, dtype=float)); else:; # preallocate complex array of zeros; expect_out.append(np.zeros(num_times, dtype=complex)). expect_out[i][0] = \; cy_expect_psi_csr(config.e_ops_data[i],; config.e_ops_ind[i],; config.e_ops_ptr[i],; config.psi0,; config.e_ops_isherm[i]). collapse_times = []; which_oper = []. # SEED AND RNG AND GENERATE; prng = RandomState(seeds[nt]); # first rand is collapse norm, second is which operator; rand_vals = prng.rand(2). # CREATE ODE OBJECT CORRESPONDING TO DESIRED TIME-DEPENDENCE; if config.tflag in [1, 10, 11]:; ODE = ode(_cy_rhs_func); code = compile('ODE.set_f_params(' + config.string + ')',; '<string>', 'exec'); exec(code); elif config.tflag == 2:; ODE = ode(_cRHStd); O",MatchSource.WIKI,docs/4.2/modules/qutip/mcsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html
https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:22564,Modifiability,config,config,22564,"values; at times tlist for a single trajectory.; """""". global _cy_rhs_func; global _cy_col_spmv_func, _cy_col_expect_func; global _cy_col_spmv_call_func, _cy_col_expect_call_func. tlist = config.tlist; num_times = len(tlist). if not _cy_rhs_func:; _mc_func_load(config). if config.options.steady_state_average:; states_out = np.zeros((1), dtype=object); else:; states_out = np.zeros((num_times), dtype=object). temp = sp.csr_matrix(; np.reshape(config.psi0, (config.psi0.shape[0], 1)),; dtype=complex); temp = csr2fast(temp); if (config.options.average_states and; not config.options.steady_state_average):; # output is averaged states, so use dm; states_out[0] = Qobj(temp*temp.H,; [config.psi0_dims[0],; config.psi0_dims[0]],; [config.psi0_shape[0],; config.psi0_shape[0]],; fast='mc-dm'); elif (not config.options.average_states and; not config.options.steady_state_average):; # output is not averaged, so write state vectors; states_out[0] = Qobj(temp, config.psi0_dims,; config.psi0_shape, fast='mc'); elif config.options.steady_state_average:; states_out[0] = temp * temp.H. # PRE-GENERATE LIST FOR EXPECTATION VALUES; expect_out = []; for i in range(config.e_num):; if config.e_ops_isherm[i]:; # preallocate real array of zeros; expect_out.append(np.zeros(num_times, dtype=float)); else:; # preallocate complex array of zeros; expect_out.append(np.zeros(num_times, dtype=complex)). expect_out[i][0] = \; cy_expect_psi_csr(config.e_ops_data[i],; config.e_ops_ind[i],; config.e_ops_ptr[i],; config.psi0,; config.e_ops_isherm[i]). collapse_times = []; which_oper = []. # SEED AND RNG AND GENERATE; prng = RandomState(seeds[nt]); # first rand is collapse norm, second is which operator; rand_vals = prng.rand(2). # CREATE ODE OBJECT CORRESPONDING TO DESIRED TIME-DEPENDENCE; if config.tflag in [1, 10, 11]:; ODE = ode(_cy_rhs_func); code = compile('ODE.set_f_params(' + config.string + ')',; '<string>', 'exec'); exec(code); elif config.tflag == 2:; ODE = ode(_cRHStd); ODE.set_f_params(config); el",MatchSource.WIKI,docs/4.2/modules/qutip/mcsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html
https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:22709,Modifiability,config,config,22709," global _cy_col_spmv_call_func, _cy_col_expect_call_func. tlist = config.tlist; num_times = len(tlist). if not _cy_rhs_func:; _mc_func_load(config). if config.options.steady_state_average:; states_out = np.zeros((1), dtype=object); else:; states_out = np.zeros((num_times), dtype=object). temp = sp.csr_matrix(; np.reshape(config.psi0, (config.psi0.shape[0], 1)),; dtype=complex); temp = csr2fast(temp); if (config.options.average_states and; not config.options.steady_state_average):; # output is averaged states, so use dm; states_out[0] = Qobj(temp*temp.H,; [config.psi0_dims[0],; config.psi0_dims[0]],; [config.psi0_shape[0],; config.psi0_shape[0]],; fast='mc-dm'); elif (not config.options.average_states and; not config.options.steady_state_average):; # output is not averaged, so write state vectors; states_out[0] = Qobj(temp, config.psi0_dims,; config.psi0_shape, fast='mc'); elif config.options.steady_state_average:; states_out[0] = temp * temp.H. # PRE-GENERATE LIST FOR EXPECTATION VALUES; expect_out = []; for i in range(config.e_num):; if config.e_ops_isherm[i]:; # preallocate real array of zeros; expect_out.append(np.zeros(num_times, dtype=float)); else:; # preallocate complex array of zeros; expect_out.append(np.zeros(num_times, dtype=complex)). expect_out[i][0] = \; cy_expect_psi_csr(config.e_ops_data[i],; config.e_ops_ind[i],; config.e_ops_ptr[i],; config.psi0,; config.e_ops_isherm[i]). collapse_times = []; which_oper = []. # SEED AND RNG AND GENERATE; prng = RandomState(seeds[nt]); # first rand is collapse norm, second is which operator; rand_vals = prng.rand(2). # CREATE ODE OBJECT CORRESPONDING TO DESIRED TIME-DEPENDENCE; if config.tflag in [1, 10, 11]:; ODE = ode(_cy_rhs_func); code = compile('ODE.set_f_params(' + config.string + ')',; '<string>', 'exec'); exec(code); elif config.tflag == 2:; ODE = ode(_cRHStd); ODE.set_f_params(config); elif config.tflag in [20, 22]:; if config.options.rhs_with_state:; ODE = ode(_tdRHStd_with_state); else:; ODE = ode(_tdRHSt",MatchSource.WIKI,docs/4.2/modules/qutip/mcsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html
https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:22728,Modifiability,config,config,22728,"_func. tlist = config.tlist; num_times = len(tlist). if not _cy_rhs_func:; _mc_func_load(config). if config.options.steady_state_average:; states_out = np.zeros((1), dtype=object); else:; states_out = np.zeros((num_times), dtype=object). temp = sp.csr_matrix(; np.reshape(config.psi0, (config.psi0.shape[0], 1)),; dtype=complex); temp = csr2fast(temp); if (config.options.average_states and; not config.options.steady_state_average):; # output is averaged states, so use dm; states_out[0] = Qobj(temp*temp.H,; [config.psi0_dims[0],; config.psi0_dims[0]],; [config.psi0_shape[0],; config.psi0_shape[0]],; fast='mc-dm'); elif (not config.options.average_states and; not config.options.steady_state_average):; # output is not averaged, so write state vectors; states_out[0] = Qobj(temp, config.psi0_dims,; config.psi0_shape, fast='mc'); elif config.options.steady_state_average:; states_out[0] = temp * temp.H. # PRE-GENERATE LIST FOR EXPECTATION VALUES; expect_out = []; for i in range(config.e_num):; if config.e_ops_isherm[i]:; # preallocate real array of zeros; expect_out.append(np.zeros(num_times, dtype=float)); else:; # preallocate complex array of zeros; expect_out.append(np.zeros(num_times, dtype=complex)). expect_out[i][0] = \; cy_expect_psi_csr(config.e_ops_data[i],; config.e_ops_ind[i],; config.e_ops_ptr[i],; config.psi0,; config.e_ops_isherm[i]). collapse_times = []; which_oper = []. # SEED AND RNG AND GENERATE; prng = RandomState(seeds[nt]); # first rand is collapse norm, second is which operator; rand_vals = prng.rand(2). # CREATE ODE OBJECT CORRESPONDING TO DESIRED TIME-DEPENDENCE; if config.tflag in [1, 10, 11]:; ODE = ode(_cy_rhs_func); code = compile('ODE.set_f_params(' + config.string + ')',; '<string>', 'exec'); exec(code); elif config.tflag == 2:; ODE = ode(_cRHStd); ODE.set_f_params(config); elif config.tflag in [20, 22]:; if config.options.rhs_with_state:; ODE = ode(_tdRHStd_with_state); else:; ODE = ode(_tdRHStd); ODE.set_f_params(config); elif config.tflag == 3",MatchSource.WIKI,docs/4.2/modules/qutip/mcsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html
https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:22981,Modifiability,config,config,22981,"emp = sp.csr_matrix(; np.reshape(config.psi0, (config.psi0.shape[0], 1)),; dtype=complex); temp = csr2fast(temp); if (config.options.average_states and; not config.options.steady_state_average):; # output is averaged states, so use dm; states_out[0] = Qobj(temp*temp.H,; [config.psi0_dims[0],; config.psi0_dims[0]],; [config.psi0_shape[0],; config.psi0_shape[0]],; fast='mc-dm'); elif (not config.options.average_states and; not config.options.steady_state_average):; # output is not averaged, so write state vectors; states_out[0] = Qobj(temp, config.psi0_dims,; config.psi0_shape, fast='mc'); elif config.options.steady_state_average:; states_out[0] = temp * temp.H. # PRE-GENERATE LIST FOR EXPECTATION VALUES; expect_out = []; for i in range(config.e_num):; if config.e_ops_isherm[i]:; # preallocate real array of zeros; expect_out.append(np.zeros(num_times, dtype=float)); else:; # preallocate complex array of zeros; expect_out.append(np.zeros(num_times, dtype=complex)). expect_out[i][0] = \; cy_expect_psi_csr(config.e_ops_data[i],; config.e_ops_ind[i],; config.e_ops_ptr[i],; config.psi0,; config.e_ops_isherm[i]). collapse_times = []; which_oper = []. # SEED AND RNG AND GENERATE; prng = RandomState(seeds[nt]); # first rand is collapse norm, second is which operator; rand_vals = prng.rand(2). # CREATE ODE OBJECT CORRESPONDING TO DESIRED TIME-DEPENDENCE; if config.tflag in [1, 10, 11]:; ODE = ode(_cy_rhs_func); code = compile('ODE.set_f_params(' + config.string + ')',; '<string>', 'exec'); exec(code); elif config.tflag == 2:; ODE = ode(_cRHStd); ODE.set_f_params(config); elif config.tflag in [20, 22]:; if config.options.rhs_with_state:; ODE = ode(_tdRHStd_with_state); else:; ODE = ode(_tdRHStd); ODE.set_f_params(config); elif config.tflag == 3:; if config.options.rhs_with_state:; ODE = ode(_pyRHSc_with_state); else:; ODE = ode(_pyRHSc); ODE.set_f_params(config); else:; ODE = ode(_cy_rhs_func); ODE.set_f_params(config.h_data, config.h_ind,; config.h_ptr). # initialize ODE solve",MatchSource.WIKI,docs/4.2/modules/qutip/mcsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html
https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:23004,Modifiability,config,config,23004,"nfig.psi0, (config.psi0.shape[0], 1)),; dtype=complex); temp = csr2fast(temp); if (config.options.average_states and; not config.options.steady_state_average):; # output is averaged states, so use dm; states_out[0] = Qobj(temp*temp.H,; [config.psi0_dims[0],; config.psi0_dims[0]],; [config.psi0_shape[0],; config.psi0_shape[0]],; fast='mc-dm'); elif (not config.options.average_states and; not config.options.steady_state_average):; # output is not averaged, so write state vectors; states_out[0] = Qobj(temp, config.psi0_dims,; config.psi0_shape, fast='mc'); elif config.options.steady_state_average:; states_out[0] = temp * temp.H. # PRE-GENERATE LIST FOR EXPECTATION VALUES; expect_out = []; for i in range(config.e_num):; if config.e_ops_isherm[i]:; # preallocate real array of zeros; expect_out.append(np.zeros(num_times, dtype=float)); else:; # preallocate complex array of zeros; expect_out.append(np.zeros(num_times, dtype=complex)). expect_out[i][0] = \; cy_expect_psi_csr(config.e_ops_data[i],; config.e_ops_ind[i],; config.e_ops_ptr[i],; config.psi0,; config.e_ops_isherm[i]). collapse_times = []; which_oper = []. # SEED AND RNG AND GENERATE; prng = RandomState(seeds[nt]); # first rand is collapse norm, second is which operator; rand_vals = prng.rand(2). # CREATE ODE OBJECT CORRESPONDING TO DESIRED TIME-DEPENDENCE; if config.tflag in [1, 10, 11]:; ODE = ode(_cy_rhs_func); code = compile('ODE.set_f_params(' + config.string + ')',; '<string>', 'exec'); exec(code); elif config.tflag == 2:; ODE = ode(_cRHStd); ODE.set_f_params(config); elif config.tflag in [20, 22]:; if config.options.rhs_with_state:; ODE = ode(_tdRHStd_with_state); else:; ODE = ode(_tdRHStd); ODE.set_f_params(config); elif config.tflag == 3:; if config.options.rhs_with_state:; ODE = ode(_pyRHSc_with_state); else:; ODE = ode(_pyRHSc); ODE.set_f_params(config); else:; ODE = ode(_cy_rhs_func); ODE.set_f_params(config.h_data, config.h_ind,; config.h_ptr). # initialize ODE solver for RHS; ODE._integrator = qutip_z",MatchSource.WIKI,docs/4.2/modules/qutip/mcsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html
https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:23026,Modifiability,config,config,23026,".shape[0], 1)),; dtype=complex); temp = csr2fast(temp); if (config.options.average_states and; not config.options.steady_state_average):; # output is averaged states, so use dm; states_out[0] = Qobj(temp*temp.H,; [config.psi0_dims[0],; config.psi0_dims[0]],; [config.psi0_shape[0],; config.psi0_shape[0]],; fast='mc-dm'); elif (not config.options.average_states and; not config.options.steady_state_average):; # output is not averaged, so write state vectors; states_out[0] = Qobj(temp, config.psi0_dims,; config.psi0_shape, fast='mc'); elif config.options.steady_state_average:; states_out[0] = temp * temp.H. # PRE-GENERATE LIST FOR EXPECTATION VALUES; expect_out = []; for i in range(config.e_num):; if config.e_ops_isherm[i]:; # preallocate real array of zeros; expect_out.append(np.zeros(num_times, dtype=float)); else:; # preallocate complex array of zeros; expect_out.append(np.zeros(num_times, dtype=complex)). expect_out[i][0] = \; cy_expect_psi_csr(config.e_ops_data[i],; config.e_ops_ind[i],; config.e_ops_ptr[i],; config.psi0,; config.e_ops_isherm[i]). collapse_times = []; which_oper = []. # SEED AND RNG AND GENERATE; prng = RandomState(seeds[nt]); # first rand is collapse norm, second is which operator; rand_vals = prng.rand(2). # CREATE ODE OBJECT CORRESPONDING TO DESIRED TIME-DEPENDENCE; if config.tflag in [1, 10, 11]:; ODE = ode(_cy_rhs_func); code = compile('ODE.set_f_params(' + config.string + ')',; '<string>', 'exec'); exec(code); elif config.tflag == 2:; ODE = ode(_cRHStd); ODE.set_f_params(config); elif config.tflag in [20, 22]:; if config.options.rhs_with_state:; ODE = ode(_tdRHStd_with_state); else:; ODE = ode(_tdRHStd); ODE.set_f_params(config); elif config.tflag == 3:; if config.options.rhs_with_state:; ODE = ode(_pyRHSc_with_state); else:; ODE = ode(_pyRHSc); ODE.set_f_params(config); else:; ODE = ode(_cy_rhs_func); ODE.set_f_params(config.h_data, config.h_ind,; config.h_ptr). # initialize ODE solver for RHS; ODE._integrator = qutip_zvode(; method=opt.meth",MatchSource.WIKI,docs/4.2/modules/qutip/mcsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html
https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:23048,Modifiability,config,config,23048,"=complex); temp = csr2fast(temp); if (config.options.average_states and; not config.options.steady_state_average):; # output is averaged states, so use dm; states_out[0] = Qobj(temp*temp.H,; [config.psi0_dims[0],; config.psi0_dims[0]],; [config.psi0_shape[0],; config.psi0_shape[0]],; fast='mc-dm'); elif (not config.options.average_states and; not config.options.steady_state_average):; # output is not averaged, so write state vectors; states_out[0] = Qobj(temp, config.psi0_dims,; config.psi0_shape, fast='mc'); elif config.options.steady_state_average:; states_out[0] = temp * temp.H. # PRE-GENERATE LIST FOR EXPECTATION VALUES; expect_out = []; for i in range(config.e_num):; if config.e_ops_isherm[i]:; # preallocate real array of zeros; expect_out.append(np.zeros(num_times, dtype=float)); else:; # preallocate complex array of zeros; expect_out.append(np.zeros(num_times, dtype=complex)). expect_out[i][0] = \; cy_expect_psi_csr(config.e_ops_data[i],; config.e_ops_ind[i],; config.e_ops_ptr[i],; config.psi0,; config.e_ops_isherm[i]). collapse_times = []; which_oper = []. # SEED AND RNG AND GENERATE; prng = RandomState(seeds[nt]); # first rand is collapse norm, second is which operator; rand_vals = prng.rand(2). # CREATE ODE OBJECT CORRESPONDING TO DESIRED TIME-DEPENDENCE; if config.tflag in [1, 10, 11]:; ODE = ode(_cy_rhs_func); code = compile('ODE.set_f_params(' + config.string + ')',; '<string>', 'exec'); exec(code); elif config.tflag == 2:; ODE = ode(_cRHStd); ODE.set_f_params(config); elif config.tflag in [20, 22]:; if config.options.rhs_with_state:; ODE = ode(_tdRHStd_with_state); else:; ODE = ode(_tdRHStd); ODE.set_f_params(config); elif config.tflag == 3:; if config.options.rhs_with_state:; ODE = ode(_pyRHSc_with_state); else:; ODE = ode(_pyRHSc); ODE.set_f_params(config); else:; ODE = ode(_cy_rhs_func); ODE.set_f_params(config.h_data, config.h_ind,; config.h_ptr). # initialize ODE solver for RHS; ODE._integrator = qutip_zvode(; method=opt.method, order=opt.order, a",MatchSource.WIKI,docs/4.2/modules/qutip/mcsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html
https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:23062,Modifiability,config,config,23062,"csr2fast(temp); if (config.options.average_states and; not config.options.steady_state_average):; # output is averaged states, so use dm; states_out[0] = Qobj(temp*temp.H,; [config.psi0_dims[0],; config.psi0_dims[0]],; [config.psi0_shape[0],; config.psi0_shape[0]],; fast='mc-dm'); elif (not config.options.average_states and; not config.options.steady_state_average):; # output is not averaged, so write state vectors; states_out[0] = Qobj(temp, config.psi0_dims,; config.psi0_shape, fast='mc'); elif config.options.steady_state_average:; states_out[0] = temp * temp.H. # PRE-GENERATE LIST FOR EXPECTATION VALUES; expect_out = []; for i in range(config.e_num):; if config.e_ops_isherm[i]:; # preallocate real array of zeros; expect_out.append(np.zeros(num_times, dtype=float)); else:; # preallocate complex array of zeros; expect_out.append(np.zeros(num_times, dtype=complex)). expect_out[i][0] = \; cy_expect_psi_csr(config.e_ops_data[i],; config.e_ops_ind[i],; config.e_ops_ptr[i],; config.psi0,; config.e_ops_isherm[i]). collapse_times = []; which_oper = []. # SEED AND RNG AND GENERATE; prng = RandomState(seeds[nt]); # first rand is collapse norm, second is which operator; rand_vals = prng.rand(2). # CREATE ODE OBJECT CORRESPONDING TO DESIRED TIME-DEPENDENCE; if config.tflag in [1, 10, 11]:; ODE = ode(_cy_rhs_func); code = compile('ODE.set_f_params(' + config.string + ')',; '<string>', 'exec'); exec(code); elif config.tflag == 2:; ODE = ode(_cRHStd); ODE.set_f_params(config); elif config.tflag in [20, 22]:; if config.options.rhs_with_state:; ODE = ode(_tdRHStd_with_state); else:; ODE = ode(_tdRHStd); ODE.set_f_params(config); elif config.tflag == 3:; if config.options.rhs_with_state:; ODE = ode(_pyRHSc_with_state); else:; ODE = ode(_pyRHSc); ODE.set_f_params(config); else:; ODE = ode(_cy_rhs_func); ODE.set_f_params(config.h_data, config.h_ind,; config.h_ptr). # initialize ODE solver for RHS; ODE._integrator = qutip_zvode(; method=opt.method, order=opt.order, atol=opt.atol,; rto",MatchSource.WIKI,docs/4.2/modules/qutip/mcsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html
https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:23333,Modifiability,config,config,23333,"; config.psi0_shape[0]],; fast='mc-dm'); elif (not config.options.average_states and; not config.options.steady_state_average):; # output is not averaged, so write state vectors; states_out[0] = Qobj(temp, config.psi0_dims,; config.psi0_shape, fast='mc'); elif config.options.steady_state_average:; states_out[0] = temp * temp.H. # PRE-GENERATE LIST FOR EXPECTATION VALUES; expect_out = []; for i in range(config.e_num):; if config.e_ops_isherm[i]:; # preallocate real array of zeros; expect_out.append(np.zeros(num_times, dtype=float)); else:; # preallocate complex array of zeros; expect_out.append(np.zeros(num_times, dtype=complex)). expect_out[i][0] = \; cy_expect_psi_csr(config.e_ops_data[i],; config.e_ops_ind[i],; config.e_ops_ptr[i],; config.psi0,; config.e_ops_isherm[i]). collapse_times = []; which_oper = []. # SEED AND RNG AND GENERATE; prng = RandomState(seeds[nt]); # first rand is collapse norm, second is which operator; rand_vals = prng.rand(2). # CREATE ODE OBJECT CORRESPONDING TO DESIRED TIME-DEPENDENCE; if config.tflag in [1, 10, 11]:; ODE = ode(_cy_rhs_func); code = compile('ODE.set_f_params(' + config.string + ')',; '<string>', 'exec'); exec(code); elif config.tflag == 2:; ODE = ode(_cRHStd); ODE.set_f_params(config); elif config.tflag in [20, 22]:; if config.options.rhs_with_state:; ODE = ode(_tdRHStd_with_state); else:; ODE = ode(_tdRHStd); ODE.set_f_params(config); elif config.tflag == 3:; if config.options.rhs_with_state:; ODE = ode(_pyRHSc_with_state); else:; ODE = ode(_pyRHSc); ODE.set_f_params(config); else:; ODE = ode(_cy_rhs_func); ODE.set_f_params(config.h_data, config.h_ind,; config.h_ptr). # initialize ODE solver for RHS; ODE._integrator = qutip_zvode(; method=opt.method, order=opt.order, atol=opt.atol,; rtol=opt.rtol, nsteps=opt.nsteps, first_step=opt.first_step,; min_step=opt.min_step, max_step=opt.max_step). if not len(ODE._y):; ODE.t = 0.0; ODE._y = np.array([0.0], complex); ODE._integrator.reset(len(ODE._y), ODE.jac is not None). # set init",MatchSource.WIKI,docs/4.2/modules/qutip/mcsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html
https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:23425,Modifiability,config,config,23425,"_average):; # output is not averaged, so write state vectors; states_out[0] = Qobj(temp, config.psi0_dims,; config.psi0_shape, fast='mc'); elif config.options.steady_state_average:; states_out[0] = temp * temp.H. # PRE-GENERATE LIST FOR EXPECTATION VALUES; expect_out = []; for i in range(config.e_num):; if config.e_ops_isherm[i]:; # preallocate real array of zeros; expect_out.append(np.zeros(num_times, dtype=float)); else:; # preallocate complex array of zeros; expect_out.append(np.zeros(num_times, dtype=complex)). expect_out[i][0] = \; cy_expect_psi_csr(config.e_ops_data[i],; config.e_ops_ind[i],; config.e_ops_ptr[i],; config.psi0,; config.e_ops_isherm[i]). collapse_times = []; which_oper = []. # SEED AND RNG AND GENERATE; prng = RandomState(seeds[nt]); # first rand is collapse norm, second is which operator; rand_vals = prng.rand(2). # CREATE ODE OBJECT CORRESPONDING TO DESIRED TIME-DEPENDENCE; if config.tflag in [1, 10, 11]:; ODE = ode(_cy_rhs_func); code = compile('ODE.set_f_params(' + config.string + ')',; '<string>', 'exec'); exec(code); elif config.tflag == 2:; ODE = ode(_cRHStd); ODE.set_f_params(config); elif config.tflag in [20, 22]:; if config.options.rhs_with_state:; ODE = ode(_tdRHStd_with_state); else:; ODE = ode(_tdRHStd); ODE.set_f_params(config); elif config.tflag == 3:; if config.options.rhs_with_state:; ODE = ode(_pyRHSc_with_state); else:; ODE = ode(_pyRHSc); ODE.set_f_params(config); else:; ODE = ode(_cy_rhs_func); ODE.set_f_params(config.h_data, config.h_ind,; config.h_ptr). # initialize ODE solver for RHS; ODE._integrator = qutip_zvode(; method=opt.method, order=opt.order, atol=opt.atol,; rtol=opt.rtol, nsteps=opt.nsteps, first_step=opt.first_step,; min_step=opt.min_step, max_step=opt.max_step). if not len(ODE._y):; ODE.t = 0.0; ODE._y = np.array([0.0], complex); ODE._integrator.reset(len(ODE._y), ODE.jac is not None). # set initial conditions; ODE.set_initial_value(config.psi0, tlist[0]). # make array for collapse operator inds; cinds = np.ar",MatchSource.WIKI,docs/4.2/modules/qutip/mcsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html
https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:23485,Modifiability,config,config,23485,"rite state vectors; states_out[0] = Qobj(temp, config.psi0_dims,; config.psi0_shape, fast='mc'); elif config.options.steady_state_average:; states_out[0] = temp * temp.H. # PRE-GENERATE LIST FOR EXPECTATION VALUES; expect_out = []; for i in range(config.e_num):; if config.e_ops_isherm[i]:; # preallocate real array of zeros; expect_out.append(np.zeros(num_times, dtype=float)); else:; # preallocate complex array of zeros; expect_out.append(np.zeros(num_times, dtype=complex)). expect_out[i][0] = \; cy_expect_psi_csr(config.e_ops_data[i],; config.e_ops_ind[i],; config.e_ops_ptr[i],; config.psi0,; config.e_ops_isherm[i]). collapse_times = []; which_oper = []. # SEED AND RNG AND GENERATE; prng = RandomState(seeds[nt]); # first rand is collapse norm, second is which operator; rand_vals = prng.rand(2). # CREATE ODE OBJECT CORRESPONDING TO DESIRED TIME-DEPENDENCE; if config.tflag in [1, 10, 11]:; ODE = ode(_cy_rhs_func); code = compile('ODE.set_f_params(' + config.string + ')',; '<string>', 'exec'); exec(code); elif config.tflag == 2:; ODE = ode(_cRHStd); ODE.set_f_params(config); elif config.tflag in [20, 22]:; if config.options.rhs_with_state:; ODE = ode(_tdRHStd_with_state); else:; ODE = ode(_tdRHStd); ODE.set_f_params(config); elif config.tflag == 3:; if config.options.rhs_with_state:; ODE = ode(_pyRHSc_with_state); else:; ODE = ode(_pyRHSc); ODE.set_f_params(config); else:; ODE = ode(_cy_rhs_func); ODE.set_f_params(config.h_data, config.h_ind,; config.h_ptr). # initialize ODE solver for RHS; ODE._integrator = qutip_zvode(; method=opt.method, order=opt.order, atol=opt.atol,; rtol=opt.rtol, nsteps=opt.nsteps, first_step=opt.first_step,; min_step=opt.min_step, max_step=opt.max_step). if not len(ODE._y):; ODE.t = 0.0; ODE._y = np.array([0.0], complex); ODE._integrator.reset(len(ODE._y), ODE.jac is not None). # set initial conditions; ODE.set_initial_value(config.psi0, tlist[0]). # make array for collapse operator inds; cinds = np.arange(config.c_num). # RUN ODE UNTIL EACH T",MatchSource.WIKI,docs/4.2/modules/qutip/mcsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html
https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:23542,Modifiability,config,config,23542," fast='mc'); elif config.options.steady_state_average:; states_out[0] = temp * temp.H. # PRE-GENERATE LIST FOR EXPECTATION VALUES; expect_out = []; for i in range(config.e_num):; if config.e_ops_isherm[i]:; # preallocate real array of zeros; expect_out.append(np.zeros(num_times, dtype=float)); else:; # preallocate complex array of zeros; expect_out.append(np.zeros(num_times, dtype=complex)). expect_out[i][0] = \; cy_expect_psi_csr(config.e_ops_data[i],; config.e_ops_ind[i],; config.e_ops_ptr[i],; config.psi0,; config.e_ops_isherm[i]). collapse_times = []; which_oper = []. # SEED AND RNG AND GENERATE; prng = RandomState(seeds[nt]); # first rand is collapse norm, second is which operator; rand_vals = prng.rand(2). # CREATE ODE OBJECT CORRESPONDING TO DESIRED TIME-DEPENDENCE; if config.tflag in [1, 10, 11]:; ODE = ode(_cy_rhs_func); code = compile('ODE.set_f_params(' + config.string + ')',; '<string>', 'exec'); exec(code); elif config.tflag == 2:; ODE = ode(_cRHStd); ODE.set_f_params(config); elif config.tflag in [20, 22]:; if config.options.rhs_with_state:; ODE = ode(_tdRHStd_with_state); else:; ODE = ode(_tdRHStd); ODE.set_f_params(config); elif config.tflag == 3:; if config.options.rhs_with_state:; ODE = ode(_pyRHSc_with_state); else:; ODE = ode(_pyRHSc); ODE.set_f_params(config); else:; ODE = ode(_cy_rhs_func); ODE.set_f_params(config.h_data, config.h_ind,; config.h_ptr). # initialize ODE solver for RHS; ODE._integrator = qutip_zvode(; method=opt.method, order=opt.order, atol=opt.atol,; rtol=opt.rtol, nsteps=opt.nsteps, first_step=opt.first_step,; min_step=opt.min_step, max_step=opt.max_step). if not len(ODE._y):; ODE.t = 0.0; ODE._y = np.array([0.0], complex); ODE._integrator.reset(len(ODE._y), ODE.jac is not None). # set initial conditions; ODE.set_initial_value(config.psi0, tlist[0]). # make array for collapse operator inds; cinds = np.arange(config.c_num). # RUN ODE UNTIL EACH TIME IN TLIST; for k in range(1, num_times):; # ODE WHILE LOOP FOR INTEGRATE UP TO TI",MatchSource.WIKI,docs/4.2/modules/qutip/mcsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html
https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:23556,Modifiability,config,config,23556," fast='mc'); elif config.options.steady_state_average:; states_out[0] = temp * temp.H. # PRE-GENERATE LIST FOR EXPECTATION VALUES; expect_out = []; for i in range(config.e_num):; if config.e_ops_isherm[i]:; # preallocate real array of zeros; expect_out.append(np.zeros(num_times, dtype=float)); else:; # preallocate complex array of zeros; expect_out.append(np.zeros(num_times, dtype=complex)). expect_out[i][0] = \; cy_expect_psi_csr(config.e_ops_data[i],; config.e_ops_ind[i],; config.e_ops_ptr[i],; config.psi0,; config.e_ops_isherm[i]). collapse_times = []; which_oper = []. # SEED AND RNG AND GENERATE; prng = RandomState(seeds[nt]); # first rand is collapse norm, second is which operator; rand_vals = prng.rand(2). # CREATE ODE OBJECT CORRESPONDING TO DESIRED TIME-DEPENDENCE; if config.tflag in [1, 10, 11]:; ODE = ode(_cy_rhs_func); code = compile('ODE.set_f_params(' + config.string + ')',; '<string>', 'exec'); exec(code); elif config.tflag == 2:; ODE = ode(_cRHStd); ODE.set_f_params(config); elif config.tflag in [20, 22]:; if config.options.rhs_with_state:; ODE = ode(_tdRHStd_with_state); else:; ODE = ode(_tdRHStd); ODE.set_f_params(config); elif config.tflag == 3:; if config.options.rhs_with_state:; ODE = ode(_pyRHSc_with_state); else:; ODE = ode(_pyRHSc); ODE.set_f_params(config); else:; ODE = ode(_cy_rhs_func); ODE.set_f_params(config.h_data, config.h_ind,; config.h_ptr). # initialize ODE solver for RHS; ODE._integrator = qutip_zvode(; method=opt.method, order=opt.order, atol=opt.atol,; rtol=opt.rtol, nsteps=opt.nsteps, first_step=opt.first_step,; min_step=opt.min_step, max_step=opt.max_step). if not len(ODE._y):; ODE.t = 0.0; ODE._y = np.array([0.0], complex); ODE._integrator.reset(len(ODE._y), ODE.jac is not None). # set initial conditions; ODE.set_initial_value(config.psi0, tlist[0]). # make array for collapse operator inds; cinds = np.arange(config.c_num). # RUN ODE UNTIL EACH TIME IN TLIST; for k in range(1, num_times):; # ODE WHILE LOOP FOR INTEGRATE UP TO TI",MatchSource.WIKI,docs/4.2/modules/qutip/mcsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html
https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:23586,Modifiability,config,config,23586,".steady_state_average:; states_out[0] = temp * temp.H. # PRE-GENERATE LIST FOR EXPECTATION VALUES; expect_out = []; for i in range(config.e_num):; if config.e_ops_isherm[i]:; # preallocate real array of zeros; expect_out.append(np.zeros(num_times, dtype=float)); else:; # preallocate complex array of zeros; expect_out.append(np.zeros(num_times, dtype=complex)). expect_out[i][0] = \; cy_expect_psi_csr(config.e_ops_data[i],; config.e_ops_ind[i],; config.e_ops_ptr[i],; config.psi0,; config.e_ops_isherm[i]). collapse_times = []; which_oper = []. # SEED AND RNG AND GENERATE; prng = RandomState(seeds[nt]); # first rand is collapse norm, second is which operator; rand_vals = prng.rand(2). # CREATE ODE OBJECT CORRESPONDING TO DESIRED TIME-DEPENDENCE; if config.tflag in [1, 10, 11]:; ODE = ode(_cy_rhs_func); code = compile('ODE.set_f_params(' + config.string + ')',; '<string>', 'exec'); exec(code); elif config.tflag == 2:; ODE = ode(_cRHStd); ODE.set_f_params(config); elif config.tflag in [20, 22]:; if config.options.rhs_with_state:; ODE = ode(_tdRHStd_with_state); else:; ODE = ode(_tdRHStd); ODE.set_f_params(config); elif config.tflag == 3:; if config.options.rhs_with_state:; ODE = ode(_pyRHSc_with_state); else:; ODE = ode(_pyRHSc); ODE.set_f_params(config); else:; ODE = ode(_cy_rhs_func); ODE.set_f_params(config.h_data, config.h_ind,; config.h_ptr). # initialize ODE solver for RHS; ODE._integrator = qutip_zvode(; method=opt.method, order=opt.order, atol=opt.atol,; rtol=opt.rtol, nsteps=opt.nsteps, first_step=opt.first_step,; min_step=opt.min_step, max_step=opt.max_step). if not len(ODE._y):; ODE.t = 0.0; ODE._y = np.array([0.0], complex); ODE._integrator.reset(len(ODE._y), ODE.jac is not None). # set initial conditions; ODE.set_initial_value(config.psi0, tlist[0]). # make array for collapse operator inds; cinds = np.arange(config.c_num). # RUN ODE UNTIL EACH TIME IN TLIST; for k in range(1, num_times):; # ODE WHILE LOOP FOR INTEGRATE UP TO TIME TLIST[k]; while ODE.t < tlist",MatchSource.WIKI,docs/4.2/modules/qutip/mcsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html
https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:23695,Modifiability,config,config,23695," in range(config.e_num):; if config.e_ops_isherm[i]:; # preallocate real array of zeros; expect_out.append(np.zeros(num_times, dtype=float)); else:; # preallocate complex array of zeros; expect_out.append(np.zeros(num_times, dtype=complex)). expect_out[i][0] = \; cy_expect_psi_csr(config.e_ops_data[i],; config.e_ops_ind[i],; config.e_ops_ptr[i],; config.psi0,; config.e_ops_isherm[i]). collapse_times = []; which_oper = []. # SEED AND RNG AND GENERATE; prng = RandomState(seeds[nt]); # first rand is collapse norm, second is which operator; rand_vals = prng.rand(2). # CREATE ODE OBJECT CORRESPONDING TO DESIRED TIME-DEPENDENCE; if config.tflag in [1, 10, 11]:; ODE = ode(_cy_rhs_func); code = compile('ODE.set_f_params(' + config.string + ')',; '<string>', 'exec'); exec(code); elif config.tflag == 2:; ODE = ode(_cRHStd); ODE.set_f_params(config); elif config.tflag in [20, 22]:; if config.options.rhs_with_state:; ODE = ode(_tdRHStd_with_state); else:; ODE = ode(_tdRHStd); ODE.set_f_params(config); elif config.tflag == 3:; if config.options.rhs_with_state:; ODE = ode(_pyRHSc_with_state); else:; ODE = ode(_pyRHSc); ODE.set_f_params(config); else:; ODE = ode(_cy_rhs_func); ODE.set_f_params(config.h_data, config.h_ind,; config.h_ptr). # initialize ODE solver for RHS; ODE._integrator = qutip_zvode(; method=opt.method, order=opt.order, atol=opt.atol,; rtol=opt.rtol, nsteps=opt.nsteps, first_step=opt.first_step,; min_step=opt.min_step, max_step=opt.max_step). if not len(ODE._y):; ODE.t = 0.0; ODE._y = np.array([0.0], complex); ODE._integrator.reset(len(ODE._y), ODE.jac is not None). # set initial conditions; ODE.set_initial_value(config.psi0, tlist[0]). # make array for collapse operator inds; cinds = np.arange(config.c_num). # RUN ODE UNTIL EACH TIME IN TLIST; for k in range(1, num_times):; # ODE WHILE LOOP FOR INTEGRATE UP TO TIME TLIST[k]; while ODE.t < tlist[k]:; t_prev = ODE.t; y_prev = ODE.y; norm2_prev = dznrm2(ODE._y) ** 2; # integrate up to tlist[k], one step at a time.; ",MatchSource.WIKI,docs/4.2/modules/qutip/mcsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html
https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:23709,Modifiability,config,config,23709," in range(config.e_num):; if config.e_ops_isherm[i]:; # preallocate real array of zeros; expect_out.append(np.zeros(num_times, dtype=float)); else:; # preallocate complex array of zeros; expect_out.append(np.zeros(num_times, dtype=complex)). expect_out[i][0] = \; cy_expect_psi_csr(config.e_ops_data[i],; config.e_ops_ind[i],; config.e_ops_ptr[i],; config.psi0,; config.e_ops_isherm[i]). collapse_times = []; which_oper = []. # SEED AND RNG AND GENERATE; prng = RandomState(seeds[nt]); # first rand is collapse norm, second is which operator; rand_vals = prng.rand(2). # CREATE ODE OBJECT CORRESPONDING TO DESIRED TIME-DEPENDENCE; if config.tflag in [1, 10, 11]:; ODE = ode(_cy_rhs_func); code = compile('ODE.set_f_params(' + config.string + ')',; '<string>', 'exec'); exec(code); elif config.tflag == 2:; ODE = ode(_cRHStd); ODE.set_f_params(config); elif config.tflag in [20, 22]:; if config.options.rhs_with_state:; ODE = ode(_tdRHStd_with_state); else:; ODE = ode(_tdRHStd); ODE.set_f_params(config); elif config.tflag == 3:; if config.options.rhs_with_state:; ODE = ode(_pyRHSc_with_state); else:; ODE = ode(_pyRHSc); ODE.set_f_params(config); else:; ODE = ode(_cy_rhs_func); ODE.set_f_params(config.h_data, config.h_ind,; config.h_ptr). # initialize ODE solver for RHS; ODE._integrator = qutip_zvode(; method=opt.method, order=opt.order, atol=opt.atol,; rtol=opt.rtol, nsteps=opt.nsteps, first_step=opt.first_step,; min_step=opt.min_step, max_step=opt.max_step). if not len(ODE._y):; ODE.t = 0.0; ODE._y = np.array([0.0], complex); ODE._integrator.reset(len(ODE._y), ODE.jac is not None). # set initial conditions; ODE.set_initial_value(config.psi0, tlist[0]). # make array for collapse operator inds; cinds = np.arange(config.c_num). # RUN ODE UNTIL EACH TIME IN TLIST; for k in range(1, num_times):; # ODE WHILE LOOP FOR INTEGRATE UP TO TIME TLIST[k]; while ODE.t < tlist[k]:; t_prev = ODE.t; y_prev = ODE.y; norm2_prev = dznrm2(ODE._y) ** 2; # integrate up to tlist[k], one step at a time.; ",MatchSource.WIKI,docs/4.2/modules/qutip/mcsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html
https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:23732,Modifiability,config,config,23732," config.e_ops_isherm[i]:; # preallocate real array of zeros; expect_out.append(np.zeros(num_times, dtype=float)); else:; # preallocate complex array of zeros; expect_out.append(np.zeros(num_times, dtype=complex)). expect_out[i][0] = \; cy_expect_psi_csr(config.e_ops_data[i],; config.e_ops_ind[i],; config.e_ops_ptr[i],; config.psi0,; config.e_ops_isherm[i]). collapse_times = []; which_oper = []. # SEED AND RNG AND GENERATE; prng = RandomState(seeds[nt]); # first rand is collapse norm, second is which operator; rand_vals = prng.rand(2). # CREATE ODE OBJECT CORRESPONDING TO DESIRED TIME-DEPENDENCE; if config.tflag in [1, 10, 11]:; ODE = ode(_cy_rhs_func); code = compile('ODE.set_f_params(' + config.string + ')',; '<string>', 'exec'); exec(code); elif config.tflag == 2:; ODE = ode(_cRHStd); ODE.set_f_params(config); elif config.tflag in [20, 22]:; if config.options.rhs_with_state:; ODE = ode(_tdRHStd_with_state); else:; ODE = ode(_tdRHStd); ODE.set_f_params(config); elif config.tflag == 3:; if config.options.rhs_with_state:; ODE = ode(_pyRHSc_with_state); else:; ODE = ode(_pyRHSc); ODE.set_f_params(config); else:; ODE = ode(_cy_rhs_func); ODE.set_f_params(config.h_data, config.h_ind,; config.h_ptr). # initialize ODE solver for RHS; ODE._integrator = qutip_zvode(; method=opt.method, order=opt.order, atol=opt.atol,; rtol=opt.rtol, nsteps=opt.nsteps, first_step=opt.first_step,; min_step=opt.min_step, max_step=opt.max_step). if not len(ODE._y):; ODE.t = 0.0; ODE._y = np.array([0.0], complex); ODE._integrator.reset(len(ODE._y), ODE.jac is not None). # set initial conditions; ODE.set_initial_value(config.psi0, tlist[0]). # make array for collapse operator inds; cinds = np.arange(config.c_num). # RUN ODE UNTIL EACH TIME IN TLIST; for k in range(1, num_times):; # ODE WHILE LOOP FOR INTEGRATE UP TO TIME TLIST[k]; while ODE.t < tlist[k]:; t_prev = ODE.t; y_prev = ODE.y; norm2_prev = dznrm2(ODE._y) ** 2; # integrate up to tlist[k], one step at a time.; ODE.integrate(tlist[k], step=",MatchSource.WIKI,docs/4.2/modules/qutip/mcsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html
https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:23839,Modifiability,config,config,23839,"locate complex array of zeros; expect_out.append(np.zeros(num_times, dtype=complex)). expect_out[i][0] = \; cy_expect_psi_csr(config.e_ops_data[i],; config.e_ops_ind[i],; config.e_ops_ptr[i],; config.psi0,; config.e_ops_isherm[i]). collapse_times = []; which_oper = []. # SEED AND RNG AND GENERATE; prng = RandomState(seeds[nt]); # first rand is collapse norm, second is which operator; rand_vals = prng.rand(2). # CREATE ODE OBJECT CORRESPONDING TO DESIRED TIME-DEPENDENCE; if config.tflag in [1, 10, 11]:; ODE = ode(_cy_rhs_func); code = compile('ODE.set_f_params(' + config.string + ')',; '<string>', 'exec'); exec(code); elif config.tflag == 2:; ODE = ode(_cRHStd); ODE.set_f_params(config); elif config.tflag in [20, 22]:; if config.options.rhs_with_state:; ODE = ode(_tdRHStd_with_state); else:; ODE = ode(_tdRHStd); ODE.set_f_params(config); elif config.tflag == 3:; if config.options.rhs_with_state:; ODE = ode(_pyRHSc_with_state); else:; ODE = ode(_pyRHSc); ODE.set_f_params(config); else:; ODE = ode(_cy_rhs_func); ODE.set_f_params(config.h_data, config.h_ind,; config.h_ptr). # initialize ODE solver for RHS; ODE._integrator = qutip_zvode(; method=opt.method, order=opt.order, atol=opt.atol,; rtol=opt.rtol, nsteps=opt.nsteps, first_step=opt.first_step,; min_step=opt.min_step, max_step=opt.max_step). if not len(ODE._y):; ODE.t = 0.0; ODE._y = np.array([0.0], complex); ODE._integrator.reset(len(ODE._y), ODE.jac is not None). # set initial conditions; ODE.set_initial_value(config.psi0, tlist[0]). # make array for collapse operator inds; cinds = np.arange(config.c_num). # RUN ODE UNTIL EACH TIME IN TLIST; for k in range(1, num_times):; # ODE WHILE LOOP FOR INTEGRATE UP TO TIME TLIST[k]; while ODE.t < tlist[k]:; t_prev = ODE.t; y_prev = ODE.y; norm2_prev = dznrm2(ODE._y) ** 2; # integrate up to tlist[k], one step at a time.; ODE.integrate(tlist[k], step=1); if not ODE.successful():; raise Exception(""ZVODE failed!""); norm2_psi = dznrm2(ODE._y) ** 2; if norm2_psi <= rand_vals[0]:;",MatchSource.WIKI,docs/4.2/modules/qutip/mcsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html
https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:23897,Modifiability,config,config,23897,"ut.append(np.zeros(num_times, dtype=complex)). expect_out[i][0] = \; cy_expect_psi_csr(config.e_ops_data[i],; config.e_ops_ind[i],; config.e_ops_ptr[i],; config.psi0,; config.e_ops_isherm[i]). collapse_times = []; which_oper = []. # SEED AND RNG AND GENERATE; prng = RandomState(seeds[nt]); # first rand is collapse norm, second is which operator; rand_vals = prng.rand(2). # CREATE ODE OBJECT CORRESPONDING TO DESIRED TIME-DEPENDENCE; if config.tflag in [1, 10, 11]:; ODE = ode(_cy_rhs_func); code = compile('ODE.set_f_params(' + config.string + ')',; '<string>', 'exec'); exec(code); elif config.tflag == 2:; ODE = ode(_cRHStd); ODE.set_f_params(config); elif config.tflag in [20, 22]:; if config.options.rhs_with_state:; ODE = ode(_tdRHStd_with_state); else:; ODE = ode(_tdRHStd); ODE.set_f_params(config); elif config.tflag == 3:; if config.options.rhs_with_state:; ODE = ode(_pyRHSc_with_state); else:; ODE = ode(_pyRHSc); ODE.set_f_params(config); else:; ODE = ode(_cy_rhs_func); ODE.set_f_params(config.h_data, config.h_ind,; config.h_ptr). # initialize ODE solver for RHS; ODE._integrator = qutip_zvode(; method=opt.method, order=opt.order, atol=opt.atol,; rtol=opt.rtol, nsteps=opt.nsteps, first_step=opt.first_step,; min_step=opt.min_step, max_step=opt.max_step). if not len(ODE._y):; ODE.t = 0.0; ODE._y = np.array([0.0], complex); ODE._integrator.reset(len(ODE._y), ODE.jac is not None). # set initial conditions; ODE.set_initial_value(config.psi0, tlist[0]). # make array for collapse operator inds; cinds = np.arange(config.c_num). # RUN ODE UNTIL EACH TIME IN TLIST; for k in range(1, num_times):; # ODE WHILE LOOP FOR INTEGRATE UP TO TIME TLIST[k]; while ODE.t < tlist[k]:; t_prev = ODE.t; y_prev = ODE.y; norm2_prev = dznrm2(ODE._y) ** 2; # integrate up to tlist[k], one step at a time.; ODE.integrate(tlist[k], step=1); if not ODE.successful():; raise Exception(""ZVODE failed!""); norm2_psi = dznrm2(ODE._y) ** 2; if norm2_psi <= rand_vals[0]:; # collapse has occured:; # find collap",MatchSource.WIKI,docs/4.2/modules/qutip/mcsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html
https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:23912,Modifiability,config,config,23912,"s(num_times, dtype=complex)). expect_out[i][0] = \; cy_expect_psi_csr(config.e_ops_data[i],; config.e_ops_ind[i],; config.e_ops_ptr[i],; config.psi0,; config.e_ops_isherm[i]). collapse_times = []; which_oper = []. # SEED AND RNG AND GENERATE; prng = RandomState(seeds[nt]); # first rand is collapse norm, second is which operator; rand_vals = prng.rand(2). # CREATE ODE OBJECT CORRESPONDING TO DESIRED TIME-DEPENDENCE; if config.tflag in [1, 10, 11]:; ODE = ode(_cy_rhs_func); code = compile('ODE.set_f_params(' + config.string + ')',; '<string>', 'exec'); exec(code); elif config.tflag == 2:; ODE = ode(_cRHStd); ODE.set_f_params(config); elif config.tflag in [20, 22]:; if config.options.rhs_with_state:; ODE = ode(_tdRHStd_with_state); else:; ODE = ode(_tdRHStd); ODE.set_f_params(config); elif config.tflag == 3:; if config.options.rhs_with_state:; ODE = ode(_pyRHSc_with_state); else:; ODE = ode(_pyRHSc); ODE.set_f_params(config); else:; ODE = ode(_cy_rhs_func); ODE.set_f_params(config.h_data, config.h_ind,; config.h_ptr). # initialize ODE solver for RHS; ODE._integrator = qutip_zvode(; method=opt.method, order=opt.order, atol=opt.atol,; rtol=opt.rtol, nsteps=opt.nsteps, first_step=opt.first_step,; min_step=opt.min_step, max_step=opt.max_step). if not len(ODE._y):; ODE.t = 0.0; ODE._y = np.array([0.0], complex); ODE._integrator.reset(len(ODE._y), ODE.jac is not None). # set initial conditions; ODE.set_initial_value(config.psi0, tlist[0]). # make array for collapse operator inds; cinds = np.arange(config.c_num). # RUN ODE UNTIL EACH TIME IN TLIST; for k in range(1, num_times):; # ODE WHILE LOOP FOR INTEGRATE UP TO TIME TLIST[k]; while ODE.t < tlist[k]:; t_prev = ODE.t; y_prev = ODE.y; norm2_prev = dznrm2(ODE._y) ** 2; # integrate up to tlist[k], one step at a time.; ODE.integrate(tlist[k], step=1); if not ODE.successful():; raise Exception(""ZVODE failed!""); norm2_psi = dznrm2(ODE._y) ** 2; if norm2_psi <= rand_vals[0]:; # collapse has occured:; # find collapse time to within ",MatchSource.WIKI,docs/4.2/modules/qutip/mcsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html
https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:23927,Modifiability,config,config,23927,"ype=complex)). expect_out[i][0] = \; cy_expect_psi_csr(config.e_ops_data[i],; config.e_ops_ind[i],; config.e_ops_ptr[i],; config.psi0,; config.e_ops_isherm[i]). collapse_times = []; which_oper = []. # SEED AND RNG AND GENERATE; prng = RandomState(seeds[nt]); # first rand is collapse norm, second is which operator; rand_vals = prng.rand(2). # CREATE ODE OBJECT CORRESPONDING TO DESIRED TIME-DEPENDENCE; if config.tflag in [1, 10, 11]:; ODE = ode(_cy_rhs_func); code = compile('ODE.set_f_params(' + config.string + ')',; '<string>', 'exec'); exec(code); elif config.tflag == 2:; ODE = ode(_cRHStd); ODE.set_f_params(config); elif config.tflag in [20, 22]:; if config.options.rhs_with_state:; ODE = ode(_tdRHStd_with_state); else:; ODE = ode(_tdRHStd); ODE.set_f_params(config); elif config.tflag == 3:; if config.options.rhs_with_state:; ODE = ode(_pyRHSc_with_state); else:; ODE = ode(_pyRHSc); ODE.set_f_params(config); else:; ODE = ode(_cy_rhs_func); ODE.set_f_params(config.h_data, config.h_ind,; config.h_ptr). # initialize ODE solver for RHS; ODE._integrator = qutip_zvode(; method=opt.method, order=opt.order, atol=opt.atol,; rtol=opt.rtol, nsteps=opt.nsteps, first_step=opt.first_step,; min_step=opt.min_step, max_step=opt.max_step). if not len(ODE._y):; ODE.t = 0.0; ODE._y = np.array([0.0], complex); ODE._integrator.reset(len(ODE._y), ODE.jac is not None). # set initial conditions; ODE.set_initial_value(config.psi0, tlist[0]). # make array for collapse operator inds; cinds = np.arange(config.c_num). # RUN ODE UNTIL EACH TIME IN TLIST; for k in range(1, num_times):; # ODE WHILE LOOP FOR INTEGRATE UP TO TIME TLIST[k]; while ODE.t < tlist[k]:; t_prev = ODE.t; y_prev = ODE.y; norm2_prev = dznrm2(ODE._y) ** 2; # integrate up to tlist[k], one step at a time.; ODE.integrate(tlist[k], step=1); if not ODE.successful():; raise Exception(""ZVODE failed!""); norm2_psi = dznrm2(ODE._y) ** 2; if norm2_psi <= rand_vals[0]:; # collapse has occured:; # find collapse time to within specified toler",MatchSource.WIKI,docs/4.2/modules/qutip/mcsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html
https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:24342,Modifiability,config,config,24342,"fig.tflag in [1, 10, 11]:; ODE = ode(_cy_rhs_func); code = compile('ODE.set_f_params(' + config.string + ')',; '<string>', 'exec'); exec(code); elif config.tflag == 2:; ODE = ode(_cRHStd); ODE.set_f_params(config); elif config.tflag in [20, 22]:; if config.options.rhs_with_state:; ODE = ode(_tdRHStd_with_state); else:; ODE = ode(_tdRHStd); ODE.set_f_params(config); elif config.tflag == 3:; if config.options.rhs_with_state:; ODE = ode(_pyRHSc_with_state); else:; ODE = ode(_pyRHSc); ODE.set_f_params(config); else:; ODE = ode(_cy_rhs_func); ODE.set_f_params(config.h_data, config.h_ind,; config.h_ptr). # initialize ODE solver for RHS; ODE._integrator = qutip_zvode(; method=opt.method, order=opt.order, atol=opt.atol,; rtol=opt.rtol, nsteps=opt.nsteps, first_step=opt.first_step,; min_step=opt.min_step, max_step=opt.max_step). if not len(ODE._y):; ODE.t = 0.0; ODE._y = np.array([0.0], complex); ODE._integrator.reset(len(ODE._y), ODE.jac is not None). # set initial conditions; ODE.set_initial_value(config.psi0, tlist[0]). # make array for collapse operator inds; cinds = np.arange(config.c_num). # RUN ODE UNTIL EACH TIME IN TLIST; for k in range(1, num_times):; # ODE WHILE LOOP FOR INTEGRATE UP TO TIME TLIST[k]; while ODE.t < tlist[k]:; t_prev = ODE.t; y_prev = ODE.y; norm2_prev = dznrm2(ODE._y) ** 2; # integrate up to tlist[k], one step at a time.; ODE.integrate(tlist[k], step=1); if not ODE.successful():; raise Exception(""ZVODE failed!""); norm2_psi = dznrm2(ODE._y) ** 2; if norm2_psi <= rand_vals[0]:; # collapse has occured:; # find collapse time to within specified tolerance; # ------------------------------------------------; ii = 0; t_final = ODE.t; while ii < config.norm_steps:; ii += 1; t_guess = t_prev + \; np.log(norm2_prev / rand_vals[0]) / \; np.log(norm2_prev / norm2_psi) * (t_final - t_prev); ODE._y = y_prev; ODE.t = t_prev; ODE._integrator.call_args[3] = 1; ODE.integrate(t_guess, step=0); if not ODE.successful():; raise Exception(; ""ZVODE failed after adjusting ",MatchSource.WIKI,docs/4.2/modules/qutip/mcsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html
https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:24425,Modifiability,config,config,24425,"config.string + ')',; '<string>', 'exec'); exec(code); elif config.tflag == 2:; ODE = ode(_cRHStd); ODE.set_f_params(config); elif config.tflag in [20, 22]:; if config.options.rhs_with_state:; ODE = ode(_tdRHStd_with_state); else:; ODE = ode(_tdRHStd); ODE.set_f_params(config); elif config.tflag == 3:; if config.options.rhs_with_state:; ODE = ode(_pyRHSc_with_state); else:; ODE = ode(_pyRHSc); ODE.set_f_params(config); else:; ODE = ode(_cy_rhs_func); ODE.set_f_params(config.h_data, config.h_ind,; config.h_ptr). # initialize ODE solver for RHS; ODE._integrator = qutip_zvode(; method=opt.method, order=opt.order, atol=opt.atol,; rtol=opt.rtol, nsteps=opt.nsteps, first_step=opt.first_step,; min_step=opt.min_step, max_step=opt.max_step). if not len(ODE._y):; ODE.t = 0.0; ODE._y = np.array([0.0], complex); ODE._integrator.reset(len(ODE._y), ODE.jac is not None). # set initial conditions; ODE.set_initial_value(config.psi0, tlist[0]). # make array for collapse operator inds; cinds = np.arange(config.c_num). # RUN ODE UNTIL EACH TIME IN TLIST; for k in range(1, num_times):; # ODE WHILE LOOP FOR INTEGRATE UP TO TIME TLIST[k]; while ODE.t < tlist[k]:; t_prev = ODE.t; y_prev = ODE.y; norm2_prev = dznrm2(ODE._y) ** 2; # integrate up to tlist[k], one step at a time.; ODE.integrate(tlist[k], step=1); if not ODE.successful():; raise Exception(""ZVODE failed!""); norm2_psi = dznrm2(ODE._y) ** 2; if norm2_psi <= rand_vals[0]:; # collapse has occured:; # find collapse time to within specified tolerance; # ------------------------------------------------; ii = 0; t_final = ODE.t; while ii < config.norm_steps:; ii += 1; t_guess = t_prev + \; np.log(norm2_prev / rand_vals[0]) / \; np.log(norm2_prev / norm2_psi) * (t_final - t_prev); ODE._y = y_prev; ODE.t = t_prev; ODE._integrator.call_args[3] = 1; ODE.integrate(t_guess, step=0); if not ODE.successful():; raise Exception(; ""ZVODE failed after adjusting step size!""); norm2_guess = dznrm2(ODE._y)**2; if (np.abs(rand_vals[0] - norm2_guess) <;",MatchSource.WIKI,docs/4.2/modules/qutip/mcsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html
https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:25021,Modifiability,config,config,25021,".method, order=opt.order, atol=opt.atol,; rtol=opt.rtol, nsteps=opt.nsteps, first_step=opt.first_step,; min_step=opt.min_step, max_step=opt.max_step). if not len(ODE._y):; ODE.t = 0.0; ODE._y = np.array([0.0], complex); ODE._integrator.reset(len(ODE._y), ODE.jac is not None). # set initial conditions; ODE.set_initial_value(config.psi0, tlist[0]). # make array for collapse operator inds; cinds = np.arange(config.c_num). # RUN ODE UNTIL EACH TIME IN TLIST; for k in range(1, num_times):; # ODE WHILE LOOP FOR INTEGRATE UP TO TIME TLIST[k]; while ODE.t < tlist[k]:; t_prev = ODE.t; y_prev = ODE.y; norm2_prev = dznrm2(ODE._y) ** 2; # integrate up to tlist[k], one step at a time.; ODE.integrate(tlist[k], step=1); if not ODE.successful():; raise Exception(""ZVODE failed!""); norm2_psi = dznrm2(ODE._y) ** 2; if norm2_psi <= rand_vals[0]:; # collapse has occured:; # find collapse time to within specified tolerance; # ------------------------------------------------; ii = 0; t_final = ODE.t; while ii < config.norm_steps:; ii += 1; t_guess = t_prev + \; np.log(norm2_prev / rand_vals[0]) / \; np.log(norm2_prev / norm2_psi) * (t_final - t_prev); ODE._y = y_prev; ODE.t = t_prev; ODE._integrator.call_args[3] = 1; ODE.integrate(t_guess, step=0); if not ODE.successful():; raise Exception(; ""ZVODE failed after adjusting step size!""); norm2_guess = dznrm2(ODE._y)**2; if (np.abs(rand_vals[0] - norm2_guess) <; config.norm_tol * rand_vals[0]):; break; elif (norm2_guess < rand_vals[0]):; # t_guess is still > t_jump; t_final = t_guess; norm2_psi = norm2_guess; else:; # t_guess < t_jump; t_prev = t_guess; y_prev = ODE.y; norm2_prev = norm2_guess; if ii > config.norm_steps:; raise Exception(""Norm tolerance not reached. "" +; ""Increase accuracy of ODE solver or "" +; ""Options.norm_steps.""). collapse_times.append(ODE.t). # some string based collapse operators; if config.tflag in [1, 11]:; n_dp = [cy_expect_psi_csr(config.n_ops_data[i],; config.n_ops_ind[i],; config.n_ops_ptr[i],; ODE._y, 1); for i in",MatchSource.WIKI,docs/4.2/modules/qutip/mcsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html
https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:25426,Modifiability,config,config,25426," = np.arange(config.c_num). # RUN ODE UNTIL EACH TIME IN TLIST; for k in range(1, num_times):; # ODE WHILE LOOP FOR INTEGRATE UP TO TIME TLIST[k]; while ODE.t < tlist[k]:; t_prev = ODE.t; y_prev = ODE.y; norm2_prev = dznrm2(ODE._y) ** 2; # integrate up to tlist[k], one step at a time.; ODE.integrate(tlist[k], step=1); if not ODE.successful():; raise Exception(""ZVODE failed!""); norm2_psi = dznrm2(ODE._y) ** 2; if norm2_psi <= rand_vals[0]:; # collapse has occured:; # find collapse time to within specified tolerance; # ------------------------------------------------; ii = 0; t_final = ODE.t; while ii < config.norm_steps:; ii += 1; t_guess = t_prev + \; np.log(norm2_prev / rand_vals[0]) / \; np.log(norm2_prev / norm2_psi) * (t_final - t_prev); ODE._y = y_prev; ODE.t = t_prev; ODE._integrator.call_args[3] = 1; ODE.integrate(t_guess, step=0); if not ODE.successful():; raise Exception(; ""ZVODE failed after adjusting step size!""); norm2_guess = dznrm2(ODE._y)**2; if (np.abs(rand_vals[0] - norm2_guess) <; config.norm_tol * rand_vals[0]):; break; elif (norm2_guess < rand_vals[0]):; # t_guess is still > t_jump; t_final = t_guess; norm2_psi = norm2_guess; else:; # t_guess < t_jump; t_prev = t_guess; y_prev = ODE.y; norm2_prev = norm2_guess; if ii > config.norm_steps:; raise Exception(""Norm tolerance not reached. "" +; ""Increase accuracy of ODE solver or "" +; ""Options.norm_steps.""). collapse_times.append(ODE.t). # some string based collapse operators; if config.tflag in [1, 11]:; n_dp = [cy_expect_psi_csr(config.n_ops_data[i],; config.n_ops_ind[i],; config.n_ops_ptr[i],; ODE._y, 1); for i in config.c_const_inds]. _locals = locals(); # calculates the expectation values for time-dependent; # norm collapse operators; exec(_cy_col_expect_call_func, globals(), _locals); n_dp = np.array(_locals['n_dp']). elif config.tflag in [2, 20, 22]:; # some Python function based collapse operators; n_dp = [cy_expect_psi_csr(config.n_ops_data[i],; config.n_ops_ind[i],; config.n_ops_ptr[i],; ODE._",MatchSource.WIKI,docs/4.2/modules/qutip/mcsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html
https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:25671,Modifiability,config,config,25671,"grate up to tlist[k], one step at a time.; ODE.integrate(tlist[k], step=1); if not ODE.successful():; raise Exception(""ZVODE failed!""); norm2_psi = dznrm2(ODE._y) ** 2; if norm2_psi <= rand_vals[0]:; # collapse has occured:; # find collapse time to within specified tolerance; # ------------------------------------------------; ii = 0; t_final = ODE.t; while ii < config.norm_steps:; ii += 1; t_guess = t_prev + \; np.log(norm2_prev / rand_vals[0]) / \; np.log(norm2_prev / norm2_psi) * (t_final - t_prev); ODE._y = y_prev; ODE.t = t_prev; ODE._integrator.call_args[3] = 1; ODE.integrate(t_guess, step=0); if not ODE.successful():; raise Exception(; ""ZVODE failed after adjusting step size!""); norm2_guess = dznrm2(ODE._y)**2; if (np.abs(rand_vals[0] - norm2_guess) <; config.norm_tol * rand_vals[0]):; break; elif (norm2_guess < rand_vals[0]):; # t_guess is still > t_jump; t_final = t_guess; norm2_psi = norm2_guess; else:; # t_guess < t_jump; t_prev = t_guess; y_prev = ODE.y; norm2_prev = norm2_guess; if ii > config.norm_steps:; raise Exception(""Norm tolerance not reached. "" +; ""Increase accuracy of ODE solver or "" +; ""Options.norm_steps.""). collapse_times.append(ODE.t). # some string based collapse operators; if config.tflag in [1, 11]:; n_dp = [cy_expect_psi_csr(config.n_ops_data[i],; config.n_ops_ind[i],; config.n_ops_ptr[i],; ODE._y, 1); for i in config.c_const_inds]. _locals = locals(); # calculates the expectation values for time-dependent; # norm collapse operators; exec(_cy_col_expect_call_func, globals(), _locals); n_dp = np.array(_locals['n_dp']). elif config.tflag in [2, 20, 22]:; # some Python function based collapse operators; n_dp = [cy_expect_psi_csr(config.n_ops_data[i],; config.n_ops_ind[i],; config.n_ops_ptr[i],; ODE._y, 1); for i in config.c_const_inds]; n_dp += [abs(config.c_funcs[i](; ODE.t, config.c_func_args)) ** 2 *; cy_expect_psi_csr(config.n_ops_data[i],; config.n_ops_ind[i],; config.n_ops_ptr[i],; ODE._y, 1); for i in config.c_td_inds]; n_dp = np.ar",MatchSource.WIKI,docs/4.2/modules/qutip/mcsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html
https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:25879,Modifiability,config,config,25879,"llapse has occured:; # find collapse time to within specified tolerance; # ------------------------------------------------; ii = 0; t_final = ODE.t; while ii < config.norm_steps:; ii += 1; t_guess = t_prev + \; np.log(norm2_prev / rand_vals[0]) / \; np.log(norm2_prev / norm2_psi) * (t_final - t_prev); ODE._y = y_prev; ODE.t = t_prev; ODE._integrator.call_args[3] = 1; ODE.integrate(t_guess, step=0); if not ODE.successful():; raise Exception(; ""ZVODE failed after adjusting step size!""); norm2_guess = dznrm2(ODE._y)**2; if (np.abs(rand_vals[0] - norm2_guess) <; config.norm_tol * rand_vals[0]):; break; elif (norm2_guess < rand_vals[0]):; # t_guess is still > t_jump; t_final = t_guess; norm2_psi = norm2_guess; else:; # t_guess < t_jump; t_prev = t_guess; y_prev = ODE.y; norm2_prev = norm2_guess; if ii > config.norm_steps:; raise Exception(""Norm tolerance not reached. "" +; ""Increase accuracy of ODE solver or "" +; ""Options.norm_steps.""). collapse_times.append(ODE.t). # some string based collapse operators; if config.tflag in [1, 11]:; n_dp = [cy_expect_psi_csr(config.n_ops_data[i],; config.n_ops_ind[i],; config.n_ops_ptr[i],; ODE._y, 1); for i in config.c_const_inds]. _locals = locals(); # calculates the expectation values for time-dependent; # norm collapse operators; exec(_cy_col_expect_call_func, globals(), _locals); n_dp = np.array(_locals['n_dp']). elif config.tflag in [2, 20, 22]:; # some Python function based collapse operators; n_dp = [cy_expect_psi_csr(config.n_ops_data[i],; config.n_ops_ind[i],; config.n_ops_ptr[i],; ODE._y, 1); for i in config.c_const_inds]; n_dp += [abs(config.c_funcs[i](; ODE.t, config.c_func_args)) ** 2 *; cy_expect_psi_csr(config.n_ops_data[i],; config.n_ops_ind[i],; config.n_ops_ptr[i],; ODE._y, 1); for i in config.c_td_inds]; n_dp = np.array(n_dp); else:; # all constant collapse operators.; n_dp = np.array(; [cy_expect_psi_csr(config.n_ops_data[i],; config.n_ops_ind[i],; config.n_ops_ptr[i],; ODE._y, 1); for i in range(config.c_num)]). # d",MatchSource.WIKI,docs/4.2/modules/qutip/mcsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html
https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:25931,Modifiability,config,config,25931,"specified tolerance; # ------------------------------------------------; ii = 0; t_final = ODE.t; while ii < config.norm_steps:; ii += 1; t_guess = t_prev + \; np.log(norm2_prev / rand_vals[0]) / \; np.log(norm2_prev / norm2_psi) * (t_final - t_prev); ODE._y = y_prev; ODE.t = t_prev; ODE._integrator.call_args[3] = 1; ODE.integrate(t_guess, step=0); if not ODE.successful():; raise Exception(; ""ZVODE failed after adjusting step size!""); norm2_guess = dznrm2(ODE._y)**2; if (np.abs(rand_vals[0] - norm2_guess) <; config.norm_tol * rand_vals[0]):; break; elif (norm2_guess < rand_vals[0]):; # t_guess is still > t_jump; t_final = t_guess; norm2_psi = norm2_guess; else:; # t_guess < t_jump; t_prev = t_guess; y_prev = ODE.y; norm2_prev = norm2_guess; if ii > config.norm_steps:; raise Exception(""Norm tolerance not reached. "" +; ""Increase accuracy of ODE solver or "" +; ""Options.norm_steps.""). collapse_times.append(ODE.t). # some string based collapse operators; if config.tflag in [1, 11]:; n_dp = [cy_expect_psi_csr(config.n_ops_data[i],; config.n_ops_ind[i],; config.n_ops_ptr[i],; ODE._y, 1); for i in config.c_const_inds]. _locals = locals(); # calculates the expectation values for time-dependent; # norm collapse operators; exec(_cy_col_expect_call_func, globals(), _locals); n_dp = np.array(_locals['n_dp']). elif config.tflag in [2, 20, 22]:; # some Python function based collapse operators; n_dp = [cy_expect_psi_csr(config.n_ops_data[i],; config.n_ops_ind[i],; config.n_ops_ptr[i],; ODE._y, 1); for i in config.c_const_inds]; n_dp += [abs(config.c_funcs[i](; ODE.t, config.c_func_args)) ** 2 *; cy_expect_psi_csr(config.n_ops_data[i],; config.n_ops_ind[i],; config.n_ops_ptr[i],; ODE._y, 1); for i in config.c_td_inds]; n_dp = np.array(n_dp); else:; # all constant collapse operators.; n_dp = np.array(; [cy_expect_psi_csr(config.n_ops_data[i],; config.n_ops_ind[i],; config.n_ops_ptr[i],; ODE._y, 1); for i in range(config.c_num)]). # determine which operator does collapse and store it;",MatchSource.WIKI,docs/4.2/modules/qutip/mcsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html
https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:25954,Modifiability,config,config,25954,"----------------------------------; ii = 0; t_final = ODE.t; while ii < config.norm_steps:; ii += 1; t_guess = t_prev + \; np.log(norm2_prev / rand_vals[0]) / \; np.log(norm2_prev / norm2_psi) * (t_final - t_prev); ODE._y = y_prev; ODE.t = t_prev; ODE._integrator.call_args[3] = 1; ODE.integrate(t_guess, step=0); if not ODE.successful():; raise Exception(; ""ZVODE failed after adjusting step size!""); norm2_guess = dznrm2(ODE._y)**2; if (np.abs(rand_vals[0] - norm2_guess) <; config.norm_tol * rand_vals[0]):; break; elif (norm2_guess < rand_vals[0]):; # t_guess is still > t_jump; t_final = t_guess; norm2_psi = norm2_guess; else:; # t_guess < t_jump; t_prev = t_guess; y_prev = ODE.y; norm2_prev = norm2_guess; if ii > config.norm_steps:; raise Exception(""Norm tolerance not reached. "" +; ""Increase accuracy of ODE solver or "" +; ""Options.norm_steps.""). collapse_times.append(ODE.t). # some string based collapse operators; if config.tflag in [1, 11]:; n_dp = [cy_expect_psi_csr(config.n_ops_data[i],; config.n_ops_ind[i],; config.n_ops_ptr[i],; ODE._y, 1); for i in config.c_const_inds]. _locals = locals(); # calculates the expectation values for time-dependent; # norm collapse operators; exec(_cy_col_expect_call_func, globals(), _locals); n_dp = np.array(_locals['n_dp']). elif config.tflag in [2, 20, 22]:; # some Python function based collapse operators; n_dp = [cy_expect_psi_csr(config.n_ops_data[i],; config.n_ops_ind[i],; config.n_ops_ptr[i],; ODE._y, 1); for i in config.c_const_inds]; n_dp += [abs(config.c_funcs[i](; ODE.t, config.c_func_args)) ** 2 *; cy_expect_psi_csr(config.n_ops_data[i],; config.n_ops_ind[i],; config.n_ops_ptr[i],; ODE._y, 1); for i in config.c_td_inds]; n_dp = np.array(n_dp); else:; # all constant collapse operators.; n_dp = np.array(; [cy_expect_psi_csr(config.n_ops_data[i],; config.n_ops_ind[i],; config.n_ops_ptr[i],; ODE._y, 1); for i in range(config.c_num)]). # determine which operator does collapse and store it; kk = np.cumsum(n_dp / np.sum(n_dp)); ",MatchSource.WIKI,docs/4.2/modules/qutip/mcsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html
https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:25976,Modifiability,config,config,25976,"-----------; ii = 0; t_final = ODE.t; while ii < config.norm_steps:; ii += 1; t_guess = t_prev + \; np.log(norm2_prev / rand_vals[0]) / \; np.log(norm2_prev / norm2_psi) * (t_final - t_prev); ODE._y = y_prev; ODE.t = t_prev; ODE._integrator.call_args[3] = 1; ODE.integrate(t_guess, step=0); if not ODE.successful():; raise Exception(; ""ZVODE failed after adjusting step size!""); norm2_guess = dznrm2(ODE._y)**2; if (np.abs(rand_vals[0] - norm2_guess) <; config.norm_tol * rand_vals[0]):; break; elif (norm2_guess < rand_vals[0]):; # t_guess is still > t_jump; t_final = t_guess; norm2_psi = norm2_guess; else:; # t_guess < t_jump; t_prev = t_guess; y_prev = ODE.y; norm2_prev = norm2_guess; if ii > config.norm_steps:; raise Exception(""Norm tolerance not reached. "" +; ""Increase accuracy of ODE solver or "" +; ""Options.norm_steps.""). collapse_times.append(ODE.t). # some string based collapse operators; if config.tflag in [1, 11]:; n_dp = [cy_expect_psi_csr(config.n_ops_data[i],; config.n_ops_ind[i],; config.n_ops_ptr[i],; ODE._y, 1); for i in config.c_const_inds]. _locals = locals(); # calculates the expectation values for time-dependent; # norm collapse operators; exec(_cy_col_expect_call_func, globals(), _locals); n_dp = np.array(_locals['n_dp']). elif config.tflag in [2, 20, 22]:; # some Python function based collapse operators; n_dp = [cy_expect_psi_csr(config.n_ops_data[i],; config.n_ops_ind[i],; config.n_ops_ptr[i],; ODE._y, 1); for i in config.c_const_inds]; n_dp += [abs(config.c_funcs[i](; ODE.t, config.c_func_args)) ** 2 *; cy_expect_psi_csr(config.n_ops_data[i],; config.n_ops_ind[i],; config.n_ops_ptr[i],; ODE._y, 1); for i in config.c_td_inds]; n_dp = np.array(n_dp); else:; # all constant collapse operators.; n_dp = np.array(; [cy_expect_psi_csr(config.n_ops_data[i],; config.n_ops_ind[i],; config.n_ops_ptr[i],; ODE._y, 1); for i in range(config.c_num)]). # determine which operator does collapse and store it; kk = np.cumsum(n_dp / np.sum(n_dp)); j = cinds[kk >= rand_v",MatchSource.WIKI,docs/4.2/modules/qutip/mcsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html
https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:26019,Modifiability,config,config,26019,"e ii < config.norm_steps:; ii += 1; t_guess = t_prev + \; np.log(norm2_prev / rand_vals[0]) / \; np.log(norm2_prev / norm2_psi) * (t_final - t_prev); ODE._y = y_prev; ODE.t = t_prev; ODE._integrator.call_args[3] = 1; ODE.integrate(t_guess, step=0); if not ODE.successful():; raise Exception(; ""ZVODE failed after adjusting step size!""); norm2_guess = dznrm2(ODE._y)**2; if (np.abs(rand_vals[0] - norm2_guess) <; config.norm_tol * rand_vals[0]):; break; elif (norm2_guess < rand_vals[0]):; # t_guess is still > t_jump; t_final = t_guess; norm2_psi = norm2_guess; else:; # t_guess < t_jump; t_prev = t_guess; y_prev = ODE.y; norm2_prev = norm2_guess; if ii > config.norm_steps:; raise Exception(""Norm tolerance not reached. "" +; ""Increase accuracy of ODE solver or "" +; ""Options.norm_steps.""). collapse_times.append(ODE.t). # some string based collapse operators; if config.tflag in [1, 11]:; n_dp = [cy_expect_psi_csr(config.n_ops_data[i],; config.n_ops_ind[i],; config.n_ops_ptr[i],; ODE._y, 1); for i in config.c_const_inds]. _locals = locals(); # calculates the expectation values for time-dependent; # norm collapse operators; exec(_cy_col_expect_call_func, globals(), _locals); n_dp = np.array(_locals['n_dp']). elif config.tflag in [2, 20, 22]:; # some Python function based collapse operators; n_dp = [cy_expect_psi_csr(config.n_ops_data[i],; config.n_ops_ind[i],; config.n_ops_ptr[i],; ODE._y, 1); for i in config.c_const_inds]; n_dp += [abs(config.c_funcs[i](; ODE.t, config.c_func_args)) ** 2 *; cy_expect_psi_csr(config.n_ops_data[i],; config.n_ops_ind[i],; config.n_ops_ptr[i],; ODE._y, 1); for i in config.c_td_inds]; n_dp = np.array(n_dp); else:; # all constant collapse operators.; n_dp = np.array(; [cy_expect_psi_csr(config.n_ops_data[i],; config.n_ops_ind[i],; config.n_ops_ptr[i],; ODE._y, 1); for i in range(config.c_num)]). # determine which operator does collapse and store it; kk = np.cumsum(n_dp / np.sum(n_dp)); j = cinds[kk >= rand_vals[1]][0]; which_oper.append(j); if j in ",MatchSource.WIKI,docs/4.2/modules/qutip/mcsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html
https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:26235,Modifiability,config,config,26235,"integrate(t_guess, step=0); if not ODE.successful():; raise Exception(; ""ZVODE failed after adjusting step size!""); norm2_guess = dznrm2(ODE._y)**2; if (np.abs(rand_vals[0] - norm2_guess) <; config.norm_tol * rand_vals[0]):; break; elif (norm2_guess < rand_vals[0]):; # t_guess is still > t_jump; t_final = t_guess; norm2_psi = norm2_guess; else:; # t_guess < t_jump; t_prev = t_guess; y_prev = ODE.y; norm2_prev = norm2_guess; if ii > config.norm_steps:; raise Exception(""Norm tolerance not reached. "" +; ""Increase accuracy of ODE solver or "" +; ""Options.norm_steps.""). collapse_times.append(ODE.t). # some string based collapse operators; if config.tflag in [1, 11]:; n_dp = [cy_expect_psi_csr(config.n_ops_data[i],; config.n_ops_ind[i],; config.n_ops_ptr[i],; ODE._y, 1); for i in config.c_const_inds]. _locals = locals(); # calculates the expectation values for time-dependent; # norm collapse operators; exec(_cy_col_expect_call_func, globals(), _locals); n_dp = np.array(_locals['n_dp']). elif config.tflag in [2, 20, 22]:; # some Python function based collapse operators; n_dp = [cy_expect_psi_csr(config.n_ops_data[i],; config.n_ops_ind[i],; config.n_ops_ptr[i],; ODE._y, 1); for i in config.c_const_inds]; n_dp += [abs(config.c_funcs[i](; ODE.t, config.c_func_args)) ** 2 *; cy_expect_psi_csr(config.n_ops_data[i],; config.n_ops_ind[i],; config.n_ops_ptr[i],; ODE._y, 1); for i in config.c_td_inds]; n_dp = np.array(n_dp); else:; # all constant collapse operators.; n_dp = np.array(; [cy_expect_psi_csr(config.n_ops_data[i],; config.n_ops_ind[i],; config.n_ops_ptr[i],; ODE._y, 1); for i in range(config.c_num)]). # determine which operator does collapse and store it; kk = np.cumsum(n_dp / np.sum(n_dp)); j = cinds[kk >= rand_vals[1]][0]; which_oper.append(j); if j in config.c_const_inds:; state = spmv_csr(config.c_ops_data[j],; config.c_ops_ind[j],; config.c_ops_ptr[j], ODE._y); else:; if config.tflag in [1, 11]:; _locals = locals(); # calculates the state vector for collapse by a; # t",MatchSource.WIKI,docs/4.2/modules/qutip/mcsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html
https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:26340,Modifiability,config,config,26340," Exception(; ""ZVODE failed after adjusting step size!""); norm2_guess = dznrm2(ODE._y)**2; if (np.abs(rand_vals[0] - norm2_guess) <; config.norm_tol * rand_vals[0]):; break; elif (norm2_guess < rand_vals[0]):; # t_guess is still > t_jump; t_final = t_guess; norm2_psi = norm2_guess; else:; # t_guess < t_jump; t_prev = t_guess; y_prev = ODE.y; norm2_prev = norm2_guess; if ii > config.norm_steps:; raise Exception(""Norm tolerance not reached. "" +; ""Increase accuracy of ODE solver or "" +; ""Options.norm_steps.""). collapse_times.append(ODE.t). # some string based collapse operators; if config.tflag in [1, 11]:; n_dp = [cy_expect_psi_csr(config.n_ops_data[i],; config.n_ops_ind[i],; config.n_ops_ptr[i],; ODE._y, 1); for i in config.c_const_inds]. _locals = locals(); # calculates the expectation values for time-dependent; # norm collapse operators; exec(_cy_col_expect_call_func, globals(), _locals); n_dp = np.array(_locals['n_dp']). elif config.tflag in [2, 20, 22]:; # some Python function based collapse operators; n_dp = [cy_expect_psi_csr(config.n_ops_data[i],; config.n_ops_ind[i],; config.n_ops_ptr[i],; ODE._y, 1); for i in config.c_const_inds]; n_dp += [abs(config.c_funcs[i](; ODE.t, config.c_func_args)) ** 2 *; cy_expect_psi_csr(config.n_ops_data[i],; config.n_ops_ind[i],; config.n_ops_ptr[i],; ODE._y, 1); for i in config.c_td_inds]; n_dp = np.array(n_dp); else:; # all constant collapse operators.; n_dp = np.array(; [cy_expect_psi_csr(config.n_ops_data[i],; config.n_ops_ind[i],; config.n_ops_ptr[i],; ODE._y, 1); for i in range(config.c_num)]). # determine which operator does collapse and store it; kk = np.cumsum(n_dp / np.sum(n_dp)); j = cinds[kk >= rand_vals[1]][0]; which_oper.append(j); if j in config.c_const_inds:; state = spmv_csr(config.c_ops_data[j],; config.c_ops_ind[j],; config.c_ops_ptr[j], ODE._y); else:; if config.tflag in [1, 11]:; _locals = locals(); # calculates the state vector for collapse by a; # time-dependent collapse operator; exec(_cy_col_spmv_call_fun",MatchSource.WIKI,docs/4.2/modules/qutip/mcsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html
https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:26363,Modifiability,config,config,26363,"uess = dznrm2(ODE._y)**2; if (np.abs(rand_vals[0] - norm2_guess) <; config.norm_tol * rand_vals[0]):; break; elif (norm2_guess < rand_vals[0]):; # t_guess is still > t_jump; t_final = t_guess; norm2_psi = norm2_guess; else:; # t_guess < t_jump; t_prev = t_guess; y_prev = ODE.y; norm2_prev = norm2_guess; if ii > config.norm_steps:; raise Exception(""Norm tolerance not reached. "" +; ""Increase accuracy of ODE solver or "" +; ""Options.norm_steps.""). collapse_times.append(ODE.t). # some string based collapse operators; if config.tflag in [1, 11]:; n_dp = [cy_expect_psi_csr(config.n_ops_data[i],; config.n_ops_ind[i],; config.n_ops_ptr[i],; ODE._y, 1); for i in config.c_const_inds]. _locals = locals(); # calculates the expectation values for time-dependent; # norm collapse operators; exec(_cy_col_expect_call_func, globals(), _locals); n_dp = np.array(_locals['n_dp']). elif config.tflag in [2, 20, 22]:; # some Python function based collapse operators; n_dp = [cy_expect_psi_csr(config.n_ops_data[i],; config.n_ops_ind[i],; config.n_ops_ptr[i],; ODE._y, 1); for i in config.c_const_inds]; n_dp += [abs(config.c_funcs[i](; ODE.t, config.c_func_args)) ** 2 *; cy_expect_psi_csr(config.n_ops_data[i],; config.n_ops_ind[i],; config.n_ops_ptr[i],; ODE._y, 1); for i in config.c_td_inds]; n_dp = np.array(n_dp); else:; # all constant collapse operators.; n_dp = np.array(; [cy_expect_psi_csr(config.n_ops_data[i],; config.n_ops_ind[i],; config.n_ops_ptr[i],; ODE._y, 1); for i in range(config.c_num)]). # determine which operator does collapse and store it; kk = np.cumsum(n_dp / np.sum(n_dp)); j = cinds[kk >= rand_vals[1]][0]; which_oper.append(j); if j in config.c_const_inds:; state = spmv_csr(config.c_ops_data[j],; config.c_ops_ind[j],; config.c_ops_ptr[j], ODE._y); else:; if config.tflag in [1, 11]:; _locals = locals(); # calculates the state vector for collapse by a; # time-dependent collapse operator; exec(_cy_col_spmv_call_func, globals(), _locals); state = _locals['state']; else:; state =",MatchSource.WIKI,docs/4.2/modules/qutip/mcsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html
https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:26385,Modifiability,config,config,26385,"2; if (np.abs(rand_vals[0] - norm2_guess) <; config.norm_tol * rand_vals[0]):; break; elif (norm2_guess < rand_vals[0]):; # t_guess is still > t_jump; t_final = t_guess; norm2_psi = norm2_guess; else:; # t_guess < t_jump; t_prev = t_guess; y_prev = ODE.y; norm2_prev = norm2_guess; if ii > config.norm_steps:; raise Exception(""Norm tolerance not reached. "" +; ""Increase accuracy of ODE solver or "" +; ""Options.norm_steps.""). collapse_times.append(ODE.t). # some string based collapse operators; if config.tflag in [1, 11]:; n_dp = [cy_expect_psi_csr(config.n_ops_data[i],; config.n_ops_ind[i],; config.n_ops_ptr[i],; ODE._y, 1); for i in config.c_const_inds]. _locals = locals(); # calculates the expectation values for time-dependent; # norm collapse operators; exec(_cy_col_expect_call_func, globals(), _locals); n_dp = np.array(_locals['n_dp']). elif config.tflag in [2, 20, 22]:; # some Python function based collapse operators; n_dp = [cy_expect_psi_csr(config.n_ops_data[i],; config.n_ops_ind[i],; config.n_ops_ptr[i],; ODE._y, 1); for i in config.c_const_inds]; n_dp += [abs(config.c_funcs[i](; ODE.t, config.c_func_args)) ** 2 *; cy_expect_psi_csr(config.n_ops_data[i],; config.n_ops_ind[i],; config.n_ops_ptr[i],; ODE._y, 1); for i in config.c_td_inds]; n_dp = np.array(n_dp); else:; # all constant collapse operators.; n_dp = np.array(; [cy_expect_psi_csr(config.n_ops_data[i],; config.n_ops_ind[i],; config.n_ops_ptr[i],; ODE._y, 1); for i in range(config.c_num)]). # determine which operator does collapse and store it; kk = np.cumsum(n_dp / np.sum(n_dp)); j = cinds[kk >= rand_vals[1]][0]; which_oper.append(j); if j in config.c_const_inds:; state = spmv_csr(config.c_ops_data[j],; config.c_ops_ind[j],; config.c_ops_ptr[j], ODE._y); else:; if config.tflag in [1, 11]:; _locals = locals(); # calculates the state vector for collapse by a; # time-dependent collapse operator; exec(_cy_col_spmv_call_func, globals(), _locals); state = _locals['state']; else:; state = \; config.c_funcs[j](",MatchSource.WIKI,docs/4.2/modules/qutip/mcsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html
https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:26428,Modifiability,config,config,26428,"<; config.norm_tol * rand_vals[0]):; break; elif (norm2_guess < rand_vals[0]):; # t_guess is still > t_jump; t_final = t_guess; norm2_psi = norm2_guess; else:; # t_guess < t_jump; t_prev = t_guess; y_prev = ODE.y; norm2_prev = norm2_guess; if ii > config.norm_steps:; raise Exception(""Norm tolerance not reached. "" +; ""Increase accuracy of ODE solver or "" +; ""Options.norm_steps.""). collapse_times.append(ODE.t). # some string based collapse operators; if config.tflag in [1, 11]:; n_dp = [cy_expect_psi_csr(config.n_ops_data[i],; config.n_ops_ind[i],; config.n_ops_ptr[i],; ODE._y, 1); for i in config.c_const_inds]. _locals = locals(); # calculates the expectation values for time-dependent; # norm collapse operators; exec(_cy_col_expect_call_func, globals(), _locals); n_dp = np.array(_locals['n_dp']). elif config.tflag in [2, 20, 22]:; # some Python function based collapse operators; n_dp = [cy_expect_psi_csr(config.n_ops_data[i],; config.n_ops_ind[i],; config.n_ops_ptr[i],; ODE._y, 1); for i in config.c_const_inds]; n_dp += [abs(config.c_funcs[i](; ODE.t, config.c_func_args)) ** 2 *; cy_expect_psi_csr(config.n_ops_data[i],; config.n_ops_ind[i],; config.n_ops_ptr[i],; ODE._y, 1); for i in config.c_td_inds]; n_dp = np.array(n_dp); else:; # all constant collapse operators.; n_dp = np.array(; [cy_expect_psi_csr(config.n_ops_data[i],; config.n_ops_ind[i],; config.n_ops_ptr[i],; ODE._y, 1); for i in range(config.c_num)]). # determine which operator does collapse and store it; kk = np.cumsum(n_dp / np.sum(n_dp)); j = cinds[kk >= rand_vals[1]][0]; which_oper.append(j); if j in config.c_const_inds:; state = spmv_csr(config.c_ops_data[j],; config.c_ops_ind[j],; config.c_ops_ptr[j], ODE._y); else:; if config.tflag in [1, 11]:; _locals = locals(); # calculates the state vector for collapse by a; # time-dependent collapse operator; exec(_cy_col_spmv_call_func, globals(), _locals); state = _locals['state']; else:; state = \; config.c_funcs[j](ODE.t,; config.c_func_args) * \; spmv_csr(",MatchSource.WIKI,docs/4.2/modules/qutip/mcsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html
https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:26463,Modifiability,config,config,26463,"s[0]):; break; elif (norm2_guess < rand_vals[0]):; # t_guess is still > t_jump; t_final = t_guess; norm2_psi = norm2_guess; else:; # t_guess < t_jump; t_prev = t_guess; y_prev = ODE.y; norm2_prev = norm2_guess; if ii > config.norm_steps:; raise Exception(""Norm tolerance not reached. "" +; ""Increase accuracy of ODE solver or "" +; ""Options.norm_steps.""). collapse_times.append(ODE.t). # some string based collapse operators; if config.tflag in [1, 11]:; n_dp = [cy_expect_psi_csr(config.n_ops_data[i],; config.n_ops_ind[i],; config.n_ops_ptr[i],; ODE._y, 1); for i in config.c_const_inds]. _locals = locals(); # calculates the expectation values for time-dependent; # norm collapse operators; exec(_cy_col_expect_call_func, globals(), _locals); n_dp = np.array(_locals['n_dp']). elif config.tflag in [2, 20, 22]:; # some Python function based collapse operators; n_dp = [cy_expect_psi_csr(config.n_ops_data[i],; config.n_ops_ind[i],; config.n_ops_ptr[i],; ODE._y, 1); for i in config.c_const_inds]; n_dp += [abs(config.c_funcs[i](; ODE.t, config.c_func_args)) ** 2 *; cy_expect_psi_csr(config.n_ops_data[i],; config.n_ops_ind[i],; config.n_ops_ptr[i],; ODE._y, 1); for i in config.c_td_inds]; n_dp = np.array(n_dp); else:; # all constant collapse operators.; n_dp = np.array(; [cy_expect_psi_csr(config.n_ops_data[i],; config.n_ops_ind[i],; config.n_ops_ptr[i],; ODE._y, 1); for i in range(config.c_num)]). # determine which operator does collapse and store it; kk = np.cumsum(n_dp / np.sum(n_dp)); j = cinds[kk >= rand_vals[1]][0]; which_oper.append(j); if j in config.c_const_inds:; state = spmv_csr(config.c_ops_data[j],; config.c_ops_ind[j],; config.c_ops_ptr[j], ODE._y); else:; if config.tflag in [1, 11]:; _locals = locals(); # calculates the state vector for collapse by a; # time-dependent collapse operator; exec(_cy_col_spmv_call_func, globals(), _locals); state = _locals['state']; else:; state = \; config.c_funcs[j](ODE.t,; config.c_func_args) * \; spmv_csr(config.c_ops_data[j],; config.",MatchSource.WIKI,docs/4.2/modules/qutip/mcsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html
https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:26490,Modifiability,config,config,26490,"vals[0]):; # t_guess is still > t_jump; t_final = t_guess; norm2_psi = norm2_guess; else:; # t_guess < t_jump; t_prev = t_guess; y_prev = ODE.y; norm2_prev = norm2_guess; if ii > config.norm_steps:; raise Exception(""Norm tolerance not reached. "" +; ""Increase accuracy of ODE solver or "" +; ""Options.norm_steps.""). collapse_times.append(ODE.t). # some string based collapse operators; if config.tflag in [1, 11]:; n_dp = [cy_expect_psi_csr(config.n_ops_data[i],; config.n_ops_ind[i],; config.n_ops_ptr[i],; ODE._y, 1); for i in config.c_const_inds]. _locals = locals(); # calculates the expectation values for time-dependent; # norm collapse operators; exec(_cy_col_expect_call_func, globals(), _locals); n_dp = np.array(_locals['n_dp']). elif config.tflag in [2, 20, 22]:; # some Python function based collapse operators; n_dp = [cy_expect_psi_csr(config.n_ops_data[i],; config.n_ops_ind[i],; config.n_ops_ptr[i],; ODE._y, 1); for i in config.c_const_inds]; n_dp += [abs(config.c_funcs[i](; ODE.t, config.c_func_args)) ** 2 *; cy_expect_psi_csr(config.n_ops_data[i],; config.n_ops_ind[i],; config.n_ops_ptr[i],; ODE._y, 1); for i in config.c_td_inds]; n_dp = np.array(n_dp); else:; # all constant collapse operators.; n_dp = np.array(; [cy_expect_psi_csr(config.n_ops_data[i],; config.n_ops_ind[i],; config.n_ops_ptr[i],; ODE._y, 1); for i in range(config.c_num)]). # determine which operator does collapse and store it; kk = np.cumsum(n_dp / np.sum(n_dp)); j = cinds[kk >= rand_vals[1]][0]; which_oper.append(j); if j in config.c_const_inds:; state = spmv_csr(config.c_ops_data[j],; config.c_ops_ind[j],; config.c_ops_ptr[j], ODE._y); else:; if config.tflag in [1, 11]:; _locals = locals(); # calculates the state vector for collapse by a; # time-dependent collapse operator; exec(_cy_col_spmv_call_func, globals(), _locals); state = _locals['state']; else:; state = \; config.c_funcs[j](ODE.t,; config.c_func_args) * \; spmv_csr(config.c_ops_data[j],; config.c_ops_ind[j],; config.c_ops_ptr[j], ODE",MatchSource.WIKI,docs/4.2/modules/qutip/mcsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html
https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:26537,Modifiability,config,config,26537,"l > t_jump; t_final = t_guess; norm2_psi = norm2_guess; else:; # t_guess < t_jump; t_prev = t_guess; y_prev = ODE.y; norm2_prev = norm2_guess; if ii > config.norm_steps:; raise Exception(""Norm tolerance not reached. "" +; ""Increase accuracy of ODE solver or "" +; ""Options.norm_steps.""). collapse_times.append(ODE.t). # some string based collapse operators; if config.tflag in [1, 11]:; n_dp = [cy_expect_psi_csr(config.n_ops_data[i],; config.n_ops_ind[i],; config.n_ops_ptr[i],; ODE._y, 1); for i in config.c_const_inds]. _locals = locals(); # calculates the expectation values for time-dependent; # norm collapse operators; exec(_cy_col_expect_call_func, globals(), _locals); n_dp = np.array(_locals['n_dp']). elif config.tflag in [2, 20, 22]:; # some Python function based collapse operators; n_dp = [cy_expect_psi_csr(config.n_ops_data[i],; config.n_ops_ind[i],; config.n_ops_ptr[i],; ODE._y, 1); for i in config.c_const_inds]; n_dp += [abs(config.c_funcs[i](; ODE.t, config.c_func_args)) ** 2 *; cy_expect_psi_csr(config.n_ops_data[i],; config.n_ops_ind[i],; config.n_ops_ptr[i],; ODE._y, 1); for i in config.c_td_inds]; n_dp = np.array(n_dp); else:; # all constant collapse operators.; n_dp = np.array(; [cy_expect_psi_csr(config.n_ops_data[i],; config.n_ops_ind[i],; config.n_ops_ptr[i],; ODE._y, 1); for i in range(config.c_num)]). # determine which operator does collapse and store it; kk = np.cumsum(n_dp / np.sum(n_dp)); j = cinds[kk >= rand_vals[1]][0]; which_oper.append(j); if j in config.c_const_inds:; state = spmv_csr(config.c_ops_data[j],; config.c_ops_ind[j],; config.c_ops_ptr[j], ODE._y); else:; if config.tflag in [1, 11]:; _locals = locals(); # calculates the state vector for collapse by a; # time-dependent collapse operator; exec(_cy_col_spmv_call_func, globals(), _locals); state = _locals['state']; else:; state = \; config.c_funcs[j](ODE.t,; config.c_func_args) * \; spmv_csr(config.c_ops_data[j],; config.c_ops_ind[j],; config.c_ops_ptr[j], ODE._y); state = state / dznrm2(",MatchSource.WIKI,docs/4.2/modules/qutip/mcsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html
https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:26560,Modifiability,config,config,26560,"2_psi = norm2_guess; else:; # t_guess < t_jump; t_prev = t_guess; y_prev = ODE.y; norm2_prev = norm2_guess; if ii > config.norm_steps:; raise Exception(""Norm tolerance not reached. "" +; ""Increase accuracy of ODE solver or "" +; ""Options.norm_steps.""). collapse_times.append(ODE.t). # some string based collapse operators; if config.tflag in [1, 11]:; n_dp = [cy_expect_psi_csr(config.n_ops_data[i],; config.n_ops_ind[i],; config.n_ops_ptr[i],; ODE._y, 1); for i in config.c_const_inds]. _locals = locals(); # calculates the expectation values for time-dependent; # norm collapse operators; exec(_cy_col_expect_call_func, globals(), _locals); n_dp = np.array(_locals['n_dp']). elif config.tflag in [2, 20, 22]:; # some Python function based collapse operators; n_dp = [cy_expect_psi_csr(config.n_ops_data[i],; config.n_ops_ind[i],; config.n_ops_ptr[i],; ODE._y, 1); for i in config.c_const_inds]; n_dp += [abs(config.c_funcs[i](; ODE.t, config.c_func_args)) ** 2 *; cy_expect_psi_csr(config.n_ops_data[i],; config.n_ops_ind[i],; config.n_ops_ptr[i],; ODE._y, 1); for i in config.c_td_inds]; n_dp = np.array(n_dp); else:; # all constant collapse operators.; n_dp = np.array(; [cy_expect_psi_csr(config.n_ops_data[i],; config.n_ops_ind[i],; config.n_ops_ptr[i],; ODE._y, 1); for i in range(config.c_num)]). # determine which operator does collapse and store it; kk = np.cumsum(n_dp / np.sum(n_dp)); j = cinds[kk >= rand_vals[1]][0]; which_oper.append(j); if j in config.c_const_inds:; state = spmv_csr(config.c_ops_data[j],; config.c_ops_ind[j],; config.c_ops_ptr[j], ODE._y); else:; if config.tflag in [1, 11]:; _locals = locals(); # calculates the state vector for collapse by a; # time-dependent collapse operator; exec(_cy_col_spmv_call_func, globals(), _locals); state = _locals['state']; else:; state = \; config.c_funcs[j](ODE.t,; config.c_func_args) * \; spmv_csr(config.c_ops_data[j],; config.c_ops_ind[j],; config.c_ops_ptr[j], ODE._y); state = state / dznrm2(state); ODE._y = state; ODE._integr",MatchSource.WIKI,docs/4.2/modules/qutip/mcsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html
https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:26582,Modifiability,config,config,26582,"se:; # t_guess < t_jump; t_prev = t_guess; y_prev = ODE.y; norm2_prev = norm2_guess; if ii > config.norm_steps:; raise Exception(""Norm tolerance not reached. "" +; ""Increase accuracy of ODE solver or "" +; ""Options.norm_steps.""). collapse_times.append(ODE.t). # some string based collapse operators; if config.tflag in [1, 11]:; n_dp = [cy_expect_psi_csr(config.n_ops_data[i],; config.n_ops_ind[i],; config.n_ops_ptr[i],; ODE._y, 1); for i in config.c_const_inds]. _locals = locals(); # calculates the expectation values for time-dependent; # norm collapse operators; exec(_cy_col_expect_call_func, globals(), _locals); n_dp = np.array(_locals['n_dp']). elif config.tflag in [2, 20, 22]:; # some Python function based collapse operators; n_dp = [cy_expect_psi_csr(config.n_ops_data[i],; config.n_ops_ind[i],; config.n_ops_ptr[i],; ODE._y, 1); for i in config.c_const_inds]; n_dp += [abs(config.c_funcs[i](; ODE.t, config.c_func_args)) ** 2 *; cy_expect_psi_csr(config.n_ops_data[i],; config.n_ops_ind[i],; config.n_ops_ptr[i],; ODE._y, 1); for i in config.c_td_inds]; n_dp = np.array(n_dp); else:; # all constant collapse operators.; n_dp = np.array(; [cy_expect_psi_csr(config.n_ops_data[i],; config.n_ops_ind[i],; config.n_ops_ptr[i],; ODE._y, 1); for i in range(config.c_num)]). # determine which operator does collapse and store it; kk = np.cumsum(n_dp / np.sum(n_dp)); j = cinds[kk >= rand_vals[1]][0]; which_oper.append(j); if j in config.c_const_inds:; state = spmv_csr(config.c_ops_data[j],; config.c_ops_ind[j],; config.c_ops_ptr[j], ODE._y); else:; if config.tflag in [1, 11]:; _locals = locals(); # calculates the state vector for collapse by a; # time-dependent collapse operator; exec(_cy_col_spmv_call_func, globals(), _locals); state = _locals['state']; else:; state = \; config.c_funcs[j](ODE.t,; config.c_func_args) * \; spmv_csr(config.c_ops_data[j],; config.c_ops_ind[j],; config.c_ops_ptr[j], ODE._y); state = state / dznrm2(state); ODE._y = state; ODE._integrator.call_args[3] = 1;",MatchSource.WIKI,docs/4.2/modules/qutip/mcsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html
https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:26625,Modifiability,config,config,26625," y_prev = ODE.y; norm2_prev = norm2_guess; if ii > config.norm_steps:; raise Exception(""Norm tolerance not reached. "" +; ""Increase accuracy of ODE solver or "" +; ""Options.norm_steps.""). collapse_times.append(ODE.t). # some string based collapse operators; if config.tflag in [1, 11]:; n_dp = [cy_expect_psi_csr(config.n_ops_data[i],; config.n_ops_ind[i],; config.n_ops_ptr[i],; ODE._y, 1); for i in config.c_const_inds]. _locals = locals(); # calculates the expectation values for time-dependent; # norm collapse operators; exec(_cy_col_expect_call_func, globals(), _locals); n_dp = np.array(_locals['n_dp']). elif config.tflag in [2, 20, 22]:; # some Python function based collapse operators; n_dp = [cy_expect_psi_csr(config.n_ops_data[i],; config.n_ops_ind[i],; config.n_ops_ptr[i],; ODE._y, 1); for i in config.c_const_inds]; n_dp += [abs(config.c_funcs[i](; ODE.t, config.c_func_args)) ** 2 *; cy_expect_psi_csr(config.n_ops_data[i],; config.n_ops_ind[i],; config.n_ops_ptr[i],; ODE._y, 1); for i in config.c_td_inds]; n_dp = np.array(n_dp); else:; # all constant collapse operators.; n_dp = np.array(; [cy_expect_psi_csr(config.n_ops_data[i],; config.n_ops_ind[i],; config.n_ops_ptr[i],; ODE._y, 1); for i in range(config.c_num)]). # determine which operator does collapse and store it; kk = np.cumsum(n_dp / np.sum(n_dp)); j = cinds[kk >= rand_vals[1]][0]; which_oper.append(j); if j in config.c_const_inds:; state = spmv_csr(config.c_ops_data[j],; config.c_ops_ind[j],; config.c_ops_ptr[j], ODE._y); else:; if config.tflag in [1, 11]:; _locals = locals(); # calculates the state vector for collapse by a; # time-dependent collapse operator; exec(_cy_col_spmv_call_func, globals(), _locals); state = _locals['state']; else:; state = \; config.c_funcs[j](ODE.t,; config.c_func_args) * \; spmv_csr(config.c_ops_data[j],; config.c_ops_ind[j],; config.c_ops_ptr[j], ODE._y); state = state / dznrm2(state); ODE._y = state; ODE._integrator.call_args[3] = 1; rand_vals = prng.rand(2). # after while l",MatchSource.WIKI,docs/4.2/modules/qutip/mcsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html
https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:26747,Modifiability,config,config,26747," +; ""Increase accuracy of ODE solver or "" +; ""Options.norm_steps.""). collapse_times.append(ODE.t). # some string based collapse operators; if config.tflag in [1, 11]:; n_dp = [cy_expect_psi_csr(config.n_ops_data[i],; config.n_ops_ind[i],; config.n_ops_ptr[i],; ODE._y, 1); for i in config.c_const_inds]. _locals = locals(); # calculates the expectation values for time-dependent; # norm collapse operators; exec(_cy_col_expect_call_func, globals(), _locals); n_dp = np.array(_locals['n_dp']). elif config.tflag in [2, 20, 22]:; # some Python function based collapse operators; n_dp = [cy_expect_psi_csr(config.n_ops_data[i],; config.n_ops_ind[i],; config.n_ops_ptr[i],; ODE._y, 1); for i in config.c_const_inds]; n_dp += [abs(config.c_funcs[i](; ODE.t, config.c_func_args)) ** 2 *; cy_expect_psi_csr(config.n_ops_data[i],; config.n_ops_ind[i],; config.n_ops_ptr[i],; ODE._y, 1); for i in config.c_td_inds]; n_dp = np.array(n_dp); else:; # all constant collapse operators.; n_dp = np.array(; [cy_expect_psi_csr(config.n_ops_data[i],; config.n_ops_ind[i],; config.n_ops_ptr[i],; ODE._y, 1); for i in range(config.c_num)]). # determine which operator does collapse and store it; kk = np.cumsum(n_dp / np.sum(n_dp)); j = cinds[kk >= rand_vals[1]][0]; which_oper.append(j); if j in config.c_const_inds:; state = spmv_csr(config.c_ops_data[j],; config.c_ops_ind[j],; config.c_ops_ptr[j], ODE._y); else:; if config.tflag in [1, 11]:; _locals = locals(); # calculates the state vector for collapse by a; # time-dependent collapse operator; exec(_cy_col_spmv_call_func, globals(), _locals); state = _locals['state']; else:; state = \; config.c_funcs[j](ODE.t,; config.c_func_args) * \; spmv_csr(config.c_ops_data[j],; config.c_ops_ind[j],; config.c_ops_ptr[j], ODE._y); state = state / dznrm2(state); ODE._y = state; ODE._integrator.call_args[3] = 1; rand_vals = prng.rand(2). # after while loop; # ----------------; out_psi = ODE._y / dznrm2(ODE._y); if config.e_num == 0 or config.options.store_states:; out",MatchSource.WIKI,docs/4.2/modules/qutip/mcsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html
https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:26770,Modifiability,config,config,26770,"E solver or "" +; ""Options.norm_steps.""). collapse_times.append(ODE.t). # some string based collapse operators; if config.tflag in [1, 11]:; n_dp = [cy_expect_psi_csr(config.n_ops_data[i],; config.n_ops_ind[i],; config.n_ops_ptr[i],; ODE._y, 1); for i in config.c_const_inds]. _locals = locals(); # calculates the expectation values for time-dependent; # norm collapse operators; exec(_cy_col_expect_call_func, globals(), _locals); n_dp = np.array(_locals['n_dp']). elif config.tflag in [2, 20, 22]:; # some Python function based collapse operators; n_dp = [cy_expect_psi_csr(config.n_ops_data[i],; config.n_ops_ind[i],; config.n_ops_ptr[i],; ODE._y, 1); for i in config.c_const_inds]; n_dp += [abs(config.c_funcs[i](; ODE.t, config.c_func_args)) ** 2 *; cy_expect_psi_csr(config.n_ops_data[i],; config.n_ops_ind[i],; config.n_ops_ptr[i],; ODE._y, 1); for i in config.c_td_inds]; n_dp = np.array(n_dp); else:; # all constant collapse operators.; n_dp = np.array(; [cy_expect_psi_csr(config.n_ops_data[i],; config.n_ops_ind[i],; config.n_ops_ptr[i],; ODE._y, 1); for i in range(config.c_num)]). # determine which operator does collapse and store it; kk = np.cumsum(n_dp / np.sum(n_dp)); j = cinds[kk >= rand_vals[1]][0]; which_oper.append(j); if j in config.c_const_inds:; state = spmv_csr(config.c_ops_data[j],; config.c_ops_ind[j],; config.c_ops_ptr[j], ODE._y); else:; if config.tflag in [1, 11]:; _locals = locals(); # calculates the state vector for collapse by a; # time-dependent collapse operator; exec(_cy_col_spmv_call_func, globals(), _locals); state = _locals['state']; else:; state = \; config.c_funcs[j](ODE.t,; config.c_func_args) * \; spmv_csr(config.c_ops_data[j],; config.c_ops_ind[j],; config.c_ops_ptr[j], ODE._y); state = state / dznrm2(state); ODE._y = state; ODE._integrator.call_args[3] = 1; rand_vals = prng.rand(2). # after while loop; # ----------------; out_psi = ODE._y / dznrm2(ODE._y); if config.e_num == 0 or config.options.store_states:; out_psi_csr = dense2D_to_fastcsr",MatchSource.WIKI,docs/4.2/modules/qutip/mcsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html
https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:26792,Modifiability,config,config,26792,"ns.norm_steps.""). collapse_times.append(ODE.t). # some string based collapse operators; if config.tflag in [1, 11]:; n_dp = [cy_expect_psi_csr(config.n_ops_data[i],; config.n_ops_ind[i],; config.n_ops_ptr[i],; ODE._y, 1); for i in config.c_const_inds]. _locals = locals(); # calculates the expectation values for time-dependent; # norm collapse operators; exec(_cy_col_expect_call_func, globals(), _locals); n_dp = np.array(_locals['n_dp']). elif config.tflag in [2, 20, 22]:; # some Python function based collapse operators; n_dp = [cy_expect_psi_csr(config.n_ops_data[i],; config.n_ops_ind[i],; config.n_ops_ptr[i],; ODE._y, 1); for i in config.c_const_inds]; n_dp += [abs(config.c_funcs[i](; ODE.t, config.c_func_args)) ** 2 *; cy_expect_psi_csr(config.n_ops_data[i],; config.n_ops_ind[i],; config.n_ops_ptr[i],; ODE._y, 1); for i in config.c_td_inds]; n_dp = np.array(n_dp); else:; # all constant collapse operators.; n_dp = np.array(; [cy_expect_psi_csr(config.n_ops_data[i],; config.n_ops_ind[i],; config.n_ops_ptr[i],; ODE._y, 1); for i in range(config.c_num)]). # determine which operator does collapse and store it; kk = np.cumsum(n_dp / np.sum(n_dp)); j = cinds[kk >= rand_vals[1]][0]; which_oper.append(j); if j in config.c_const_inds:; state = spmv_csr(config.c_ops_data[j],; config.c_ops_ind[j],; config.c_ops_ptr[j], ODE._y); else:; if config.tflag in [1, 11]:; _locals = locals(); # calculates the state vector for collapse by a; # time-dependent collapse operator; exec(_cy_col_spmv_call_func, globals(), _locals); state = _locals['state']; else:; state = \; config.c_funcs[j](ODE.t,; config.c_func_args) * \; spmv_csr(config.c_ops_data[j],; config.c_ops_ind[j],; config.c_ops_ptr[j], ODE._y); state = state / dznrm2(state); ODE._y = state; ODE._integrator.call_args[3] = 1; rand_vals = prng.rand(2). # after while loop; # ----------------; out_psi = ODE._y / dznrm2(ODE._y); if config.e_num == 0 or config.options.store_states:; out_psi_csr = dense2D_to_fastcsr_cmode(np.reshape(out_",MatchSource.WIKI,docs/4.2/modules/qutip/mcsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html
https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:26841,Modifiability,config,config,26841,"). # some string based collapse operators; if config.tflag in [1, 11]:; n_dp = [cy_expect_psi_csr(config.n_ops_data[i],; config.n_ops_ind[i],; config.n_ops_ptr[i],; ODE._y, 1); for i in config.c_const_inds]. _locals = locals(); # calculates the expectation values for time-dependent; # norm collapse operators; exec(_cy_col_expect_call_func, globals(), _locals); n_dp = np.array(_locals['n_dp']). elif config.tflag in [2, 20, 22]:; # some Python function based collapse operators; n_dp = [cy_expect_psi_csr(config.n_ops_data[i],; config.n_ops_ind[i],; config.n_ops_ptr[i],; ODE._y, 1); for i in config.c_const_inds]; n_dp += [abs(config.c_funcs[i](; ODE.t, config.c_func_args)) ** 2 *; cy_expect_psi_csr(config.n_ops_data[i],; config.n_ops_ind[i],; config.n_ops_ptr[i],; ODE._y, 1); for i in config.c_td_inds]; n_dp = np.array(n_dp); else:; # all constant collapse operators.; n_dp = np.array(; [cy_expect_psi_csr(config.n_ops_data[i],; config.n_ops_ind[i],; config.n_ops_ptr[i],; ODE._y, 1); for i in range(config.c_num)]). # determine which operator does collapse and store it; kk = np.cumsum(n_dp / np.sum(n_dp)); j = cinds[kk >= rand_vals[1]][0]; which_oper.append(j); if j in config.c_const_inds:; state = spmv_csr(config.c_ops_data[j],; config.c_ops_ind[j],; config.c_ops_ptr[j], ODE._y); else:; if config.tflag in [1, 11]:; _locals = locals(); # calculates the state vector for collapse by a; # time-dependent collapse operator; exec(_cy_col_spmv_call_func, globals(), _locals); state = _locals['state']; else:; state = \; config.c_funcs[j](ODE.t,; config.c_func_args) * \; spmv_csr(config.c_ops_data[j],; config.c_ops_ind[j],; config.c_ops_ptr[j], ODE._y); state = state / dznrm2(state); ODE._y = state; ODE._integrator.call_args[3] = 1; rand_vals = prng.rand(2). # after while loop; # ----------------; out_psi = ODE._y / dznrm2(ODE._y); if config.e_num == 0 or config.options.store_states:; out_psi_csr = dense2D_to_fastcsr_cmode(np.reshape(out_psi,; (out_psi.shape[0], 1)),; out_psi.shape[",MatchSource.WIKI,docs/4.2/modules/qutip/mcsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html
https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:27014,Modifiability,config,config,27014,"; for i in config.c_const_inds]. _locals = locals(); # calculates the expectation values for time-dependent; # norm collapse operators; exec(_cy_col_expect_call_func, globals(), _locals); n_dp = np.array(_locals['n_dp']). elif config.tflag in [2, 20, 22]:; # some Python function based collapse operators; n_dp = [cy_expect_psi_csr(config.n_ops_data[i],; config.n_ops_ind[i],; config.n_ops_ptr[i],; ODE._y, 1); for i in config.c_const_inds]; n_dp += [abs(config.c_funcs[i](; ODE.t, config.c_func_args)) ** 2 *; cy_expect_psi_csr(config.n_ops_data[i],; config.n_ops_ind[i],; config.n_ops_ptr[i],; ODE._y, 1); for i in config.c_td_inds]; n_dp = np.array(n_dp); else:; # all constant collapse operators.; n_dp = np.array(; [cy_expect_psi_csr(config.n_ops_data[i],; config.n_ops_ind[i],; config.n_ops_ptr[i],; ODE._y, 1); for i in range(config.c_num)]). # determine which operator does collapse and store it; kk = np.cumsum(n_dp / np.sum(n_dp)); j = cinds[kk >= rand_vals[1]][0]; which_oper.append(j); if j in config.c_const_inds:; state = spmv_csr(config.c_ops_data[j],; config.c_ops_ind[j],; config.c_ops_ptr[j], ODE._y); else:; if config.tflag in [1, 11]:; _locals = locals(); # calculates the state vector for collapse by a; # time-dependent collapse operator; exec(_cy_col_spmv_call_func, globals(), _locals); state = _locals['state']; else:; state = \; config.c_funcs[j](ODE.t,; config.c_func_args) * \; spmv_csr(config.c_ops_data[j],; config.c_ops_ind[j],; config.c_ops_ptr[j], ODE._y); state = state / dznrm2(state); ODE._y = state; ODE._integrator.call_args[3] = 1; rand_vals = prng.rand(2). # after while loop; # ----------------; out_psi = ODE._y / dznrm2(ODE._y); if config.e_num == 0 or config.options.store_states:; out_psi_csr = dense2D_to_fastcsr_cmode(np.reshape(out_psi,; (out_psi.shape[0], 1)),; out_psi.shape[0], 1); if (config.options.average_states and; not config.options.steady_state_average):; states_out[k] = Qobj(; out_psi_csr * out_psi_csr.H,; [config.psi0_dims[0], config.psi",MatchSource.WIKI,docs/4.2/modules/qutip/mcsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html
https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:27053,Modifiability,config,config,27053," _locals = locals(); # calculates the expectation values for time-dependent; # norm collapse operators; exec(_cy_col_expect_call_func, globals(), _locals); n_dp = np.array(_locals['n_dp']). elif config.tflag in [2, 20, 22]:; # some Python function based collapse operators; n_dp = [cy_expect_psi_csr(config.n_ops_data[i],; config.n_ops_ind[i],; config.n_ops_ptr[i],; ODE._y, 1); for i in config.c_const_inds]; n_dp += [abs(config.c_funcs[i](; ODE.t, config.c_func_args)) ** 2 *; cy_expect_psi_csr(config.n_ops_data[i],; config.n_ops_ind[i],; config.n_ops_ptr[i],; ODE._y, 1); for i in config.c_td_inds]; n_dp = np.array(n_dp); else:; # all constant collapse operators.; n_dp = np.array(; [cy_expect_psi_csr(config.n_ops_data[i],; config.n_ops_ind[i],; config.n_ops_ptr[i],; ODE._y, 1); for i in range(config.c_num)]). # determine which operator does collapse and store it; kk = np.cumsum(n_dp / np.sum(n_dp)); j = cinds[kk >= rand_vals[1]][0]; which_oper.append(j); if j in config.c_const_inds:; state = spmv_csr(config.c_ops_data[j],; config.c_ops_ind[j],; config.c_ops_ptr[j], ODE._y); else:; if config.tflag in [1, 11]:; _locals = locals(); # calculates the state vector for collapse by a; # time-dependent collapse operator; exec(_cy_col_spmv_call_func, globals(), _locals); state = _locals['state']; else:; state = \; config.c_funcs[j](ODE.t,; config.c_func_args) * \; spmv_csr(config.c_ops_data[j],; config.c_ops_ind[j],; config.c_ops_ptr[j], ODE._y); state = state / dznrm2(state); ODE._y = state; ODE._integrator.call_args[3] = 1; rand_vals = prng.rand(2). # after while loop; # ----------------; out_psi = ODE._y / dznrm2(ODE._y); if config.e_num == 0 or config.options.store_states:; out_psi_csr = dense2D_to_fastcsr_cmode(np.reshape(out_psi,; (out_psi.shape[0], 1)),; out_psi.shape[0], 1); if (config.options.average_states and; not config.options.steady_state_average):; states_out[k] = Qobj(; out_psi_csr * out_psi_csr.H,; [config.psi0_dims[0], config.psi0_dims[0]],; [config.psi0_shape[0",MatchSource.WIKI,docs/4.2/modules/qutip/mcsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html
https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:27076,Modifiability,config,config,27076,"es the expectation values for time-dependent; # norm collapse operators; exec(_cy_col_expect_call_func, globals(), _locals); n_dp = np.array(_locals['n_dp']). elif config.tflag in [2, 20, 22]:; # some Python function based collapse operators; n_dp = [cy_expect_psi_csr(config.n_ops_data[i],; config.n_ops_ind[i],; config.n_ops_ptr[i],; ODE._y, 1); for i in config.c_const_inds]; n_dp += [abs(config.c_funcs[i](; ODE.t, config.c_func_args)) ** 2 *; cy_expect_psi_csr(config.n_ops_data[i],; config.n_ops_ind[i],; config.n_ops_ptr[i],; ODE._y, 1); for i in config.c_td_inds]; n_dp = np.array(n_dp); else:; # all constant collapse operators.; n_dp = np.array(; [cy_expect_psi_csr(config.n_ops_data[i],; config.n_ops_ind[i],; config.n_ops_ptr[i],; ODE._y, 1); for i in range(config.c_num)]). # determine which operator does collapse and store it; kk = np.cumsum(n_dp / np.sum(n_dp)); j = cinds[kk >= rand_vals[1]][0]; which_oper.append(j); if j in config.c_const_inds:; state = spmv_csr(config.c_ops_data[j],; config.c_ops_ind[j],; config.c_ops_ptr[j], ODE._y); else:; if config.tflag in [1, 11]:; _locals = locals(); # calculates the state vector for collapse by a; # time-dependent collapse operator; exec(_cy_col_spmv_call_func, globals(), _locals); state = _locals['state']; else:; state = \; config.c_funcs[j](ODE.t,; config.c_func_args) * \; spmv_csr(config.c_ops_data[j],; config.c_ops_ind[j],; config.c_ops_ptr[j], ODE._y); state = state / dznrm2(state); ODE._y = state; ODE._integrator.call_args[3] = 1; rand_vals = prng.rand(2). # after while loop; # ----------------; out_psi = ODE._y / dznrm2(ODE._y); if config.e_num == 0 or config.options.store_states:; out_psi_csr = dense2D_to_fastcsr_cmode(np.reshape(out_psi,; (out_psi.shape[0], 1)),; out_psi.shape[0], 1); if (config.options.average_states and; not config.options.steady_state_average):; states_out[k] = Qobj(; out_psi_csr * out_psi_csr.H,; [config.psi0_dims[0], config.psi0_dims[0]],; [config.psi0_shape[0], config.psi0_shape[0]],; fast",MatchSource.WIKI,docs/4.2/modules/qutip/mcsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html
https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:27098,Modifiability,config,config,27098,"es for time-dependent; # norm collapse operators; exec(_cy_col_expect_call_func, globals(), _locals); n_dp = np.array(_locals['n_dp']). elif config.tflag in [2, 20, 22]:; # some Python function based collapse operators; n_dp = [cy_expect_psi_csr(config.n_ops_data[i],; config.n_ops_ind[i],; config.n_ops_ptr[i],; ODE._y, 1); for i in config.c_const_inds]; n_dp += [abs(config.c_funcs[i](; ODE.t, config.c_func_args)) ** 2 *; cy_expect_psi_csr(config.n_ops_data[i],; config.n_ops_ind[i],; config.n_ops_ptr[i],; ODE._y, 1); for i in config.c_td_inds]; n_dp = np.array(n_dp); else:; # all constant collapse operators.; n_dp = np.array(; [cy_expect_psi_csr(config.n_ops_data[i],; config.n_ops_ind[i],; config.n_ops_ptr[i],; ODE._y, 1); for i in range(config.c_num)]). # determine which operator does collapse and store it; kk = np.cumsum(n_dp / np.sum(n_dp)); j = cinds[kk >= rand_vals[1]][0]; which_oper.append(j); if j in config.c_const_inds:; state = spmv_csr(config.c_ops_data[j],; config.c_ops_ind[j],; config.c_ops_ptr[j], ODE._y); else:; if config.tflag in [1, 11]:; _locals = locals(); # calculates the state vector for collapse by a; # time-dependent collapse operator; exec(_cy_col_spmv_call_func, globals(), _locals); state = _locals['state']; else:; state = \; config.c_funcs[j](ODE.t,; config.c_func_args) * \; spmv_csr(config.c_ops_data[j],; config.c_ops_ind[j],; config.c_ops_ptr[j], ODE._y); state = state / dznrm2(state); ODE._y = state; ODE._integrator.call_args[3] = 1; rand_vals = prng.rand(2). # after while loop; # ----------------; out_psi = ODE._y / dznrm2(ODE._y); if config.e_num == 0 or config.options.store_states:; out_psi_csr = dense2D_to_fastcsr_cmode(np.reshape(out_psi,; (out_psi.shape[0], 1)),; out_psi.shape[0], 1); if (config.options.average_states and; not config.options.steady_state_average):; states_out[k] = Qobj(; out_psi_csr * out_psi_csr.H,; [config.psi0_dims[0], config.psi0_dims[0]],; [config.psi0_shape[0], config.psi0_shape[0]],; fast='mc-dm'). elif config",MatchSource.WIKI,docs/4.2/modules/qutip/mcsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html
https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:27138,Modifiability,config,config,27138,"perators; exec(_cy_col_expect_call_func, globals(), _locals); n_dp = np.array(_locals['n_dp']). elif config.tflag in [2, 20, 22]:; # some Python function based collapse operators; n_dp = [cy_expect_psi_csr(config.n_ops_data[i],; config.n_ops_ind[i],; config.n_ops_ptr[i],; ODE._y, 1); for i in config.c_const_inds]; n_dp += [abs(config.c_funcs[i](; ODE.t, config.c_func_args)) ** 2 *; cy_expect_psi_csr(config.n_ops_data[i],; config.n_ops_ind[i],; config.n_ops_ptr[i],; ODE._y, 1); for i in config.c_td_inds]; n_dp = np.array(n_dp); else:; # all constant collapse operators.; n_dp = np.array(; [cy_expect_psi_csr(config.n_ops_data[i],; config.n_ops_ind[i],; config.n_ops_ptr[i],; ODE._y, 1); for i in range(config.c_num)]). # determine which operator does collapse and store it; kk = np.cumsum(n_dp / np.sum(n_dp)); j = cinds[kk >= rand_vals[1]][0]; which_oper.append(j); if j in config.c_const_inds:; state = spmv_csr(config.c_ops_data[j],; config.c_ops_ind[j],; config.c_ops_ptr[j], ODE._y); else:; if config.tflag in [1, 11]:; _locals = locals(); # calculates the state vector for collapse by a; # time-dependent collapse operator; exec(_cy_col_spmv_call_func, globals(), _locals); state = _locals['state']; else:; state = \; config.c_funcs[j](ODE.t,; config.c_func_args) * \; spmv_csr(config.c_ops_data[j],; config.c_ops_ind[j],; config.c_ops_ptr[j], ODE._y); state = state / dznrm2(state); ODE._y = state; ODE._integrator.call_args[3] = 1; rand_vals = prng.rand(2). # after while loop; # ----------------; out_psi = ODE._y / dznrm2(ODE._y); if config.e_num == 0 or config.options.store_states:; out_psi_csr = dense2D_to_fastcsr_cmode(np.reshape(out_psi,; (out_psi.shape[0], 1)),; out_psi.shape[0], 1); if (config.options.average_states and; not config.options.steady_state_average):; states_out[k] = Qobj(; out_psi_csr * out_psi_csr.H,; [config.psi0_dims[0], config.psi0_dims[0]],; [config.psi0_shape[0], config.psi0_shape[0]],; fast='mc-dm'). elif config.options.steady_state_average:; states_o",MatchSource.WIKI,docs/4.2/modules/qutip/mcsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html
https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:27363,Modifiability,config,config,27363,", 22]:; # some Python function based collapse operators; n_dp = [cy_expect_psi_csr(config.n_ops_data[i],; config.n_ops_ind[i],; config.n_ops_ptr[i],; ODE._y, 1); for i in config.c_const_inds]; n_dp += [abs(config.c_funcs[i](; ODE.t, config.c_func_args)) ** 2 *; cy_expect_psi_csr(config.n_ops_data[i],; config.n_ops_ind[i],; config.n_ops_ptr[i],; ODE._y, 1); for i in config.c_td_inds]; n_dp = np.array(n_dp); else:; # all constant collapse operators.; n_dp = np.array(; [cy_expect_psi_csr(config.n_ops_data[i],; config.n_ops_ind[i],; config.n_ops_ptr[i],; ODE._y, 1); for i in range(config.c_num)]). # determine which operator does collapse and store it; kk = np.cumsum(n_dp / np.sum(n_dp)); j = cinds[kk >= rand_vals[1]][0]; which_oper.append(j); if j in config.c_const_inds:; state = spmv_csr(config.c_ops_data[j],; config.c_ops_ind[j],; config.c_ops_ptr[j], ODE._y); else:; if config.tflag in [1, 11]:; _locals = locals(); # calculates the state vector for collapse by a; # time-dependent collapse operator; exec(_cy_col_spmv_call_func, globals(), _locals); state = _locals['state']; else:; state = \; config.c_funcs[j](ODE.t,; config.c_func_args) * \; spmv_csr(config.c_ops_data[j],; config.c_ops_ind[j],; config.c_ops_ptr[j], ODE._y); state = state / dznrm2(state); ODE._y = state; ODE._integrator.call_args[3] = 1; rand_vals = prng.rand(2). # after while loop; # ----------------; out_psi = ODE._y / dznrm2(ODE._y); if config.e_num == 0 or config.options.store_states:; out_psi_csr = dense2D_to_fastcsr_cmode(np.reshape(out_psi,; (out_psi.shape[0], 1)),; out_psi.shape[0], 1); if (config.options.average_states and; not config.options.steady_state_average):; states_out[k] = Qobj(; out_psi_csr * out_psi_csr.H,; [config.psi0_dims[0], config.psi0_dims[0]],; [config.psi0_shape[0], config.psi0_shape[0]],; fast='mc-dm'). elif config.options.steady_state_average:; states_out[0] = (; states_out[0] +; (out_psi_csr * out_psi_csr.H)). else:; states_out[k] = Qobj(out_psi_csr, config.psi0_dims,; conf",MatchSource.WIKI,docs/4.2/modules/qutip/mcsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html
https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:27389,Modifiability,config,config,27389,"g.n_ops_ptr[i],; ODE._y, 1); for i in config.c_const_inds]; n_dp += [abs(config.c_funcs[i](; ODE.t, config.c_func_args)) ** 2 *; cy_expect_psi_csr(config.n_ops_data[i],; config.n_ops_ind[i],; config.n_ops_ptr[i],; ODE._y, 1); for i in config.c_td_inds]; n_dp = np.array(n_dp); else:; # all constant collapse operators.; n_dp = np.array(; [cy_expect_psi_csr(config.n_ops_data[i],; config.n_ops_ind[i],; config.n_ops_ptr[i],; ODE._y, 1); for i in range(config.c_num)]). # determine which operator does collapse and store it; kk = np.cumsum(n_dp / np.sum(n_dp)); j = cinds[kk >= rand_vals[1]][0]; which_oper.append(j); if j in config.c_const_inds:; state = spmv_csr(config.c_ops_data[j],; config.c_ops_ind[j],; config.c_ops_ptr[j], ODE._y); else:; if config.tflag in [1, 11]:; _locals = locals(); # calculates the state vector for collapse by a; # time-dependent collapse operator; exec(_cy_col_spmv_call_func, globals(), _locals); state = _locals['state']; else:; state = \; config.c_funcs[j](ODE.t,; config.c_func_args) * \; spmv_csr(config.c_ops_data[j],; config.c_ops_ind[j],; config.c_ops_ptr[j], ODE._y); state = state / dznrm2(state); ODE._y = state; ODE._integrator.call_args[3] = 1; rand_vals = prng.rand(2). # after while loop; # ----------------; out_psi = ODE._y / dznrm2(ODE._y); if config.e_num == 0 or config.options.store_states:; out_psi_csr = dense2D_to_fastcsr_cmode(np.reshape(out_psi,; (out_psi.shape[0], 1)),; out_psi.shape[0], 1); if (config.options.average_states and; not config.options.steady_state_average):; states_out[k] = Qobj(; out_psi_csr * out_psi_csr.H,; [config.psi0_dims[0], config.psi0_dims[0]],; [config.psi0_shape[0], config.psi0_shape[0]],; fast='mc-dm'). elif config.options.steady_state_average:; states_out[0] = (; states_out[0] +; (out_psi_csr * out_psi_csr.H)). else:; states_out[k] = Qobj(out_psi_csr, config.psi0_dims,; config.psi0_shape, fast='mc'). for jj in range(config.e_num):; expect_out[jj][k] = cy_expect_psi_csr(; config.e_ops_data[jj], config.e_op",MatchSource.WIKI,docs/4.2/modules/qutip/mcsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html
https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:27423,Modifiability,config,config,27423,", 1); for i in config.c_const_inds]; n_dp += [abs(config.c_funcs[i](; ODE.t, config.c_func_args)) ** 2 *; cy_expect_psi_csr(config.n_ops_data[i],; config.n_ops_ind[i],; config.n_ops_ptr[i],; ODE._y, 1); for i in config.c_td_inds]; n_dp = np.array(n_dp); else:; # all constant collapse operators.; n_dp = np.array(; [cy_expect_psi_csr(config.n_ops_data[i],; config.n_ops_ind[i],; config.n_ops_ptr[i],; ODE._y, 1); for i in range(config.c_num)]). # determine which operator does collapse and store it; kk = np.cumsum(n_dp / np.sum(n_dp)); j = cinds[kk >= rand_vals[1]][0]; which_oper.append(j); if j in config.c_const_inds:; state = spmv_csr(config.c_ops_data[j],; config.c_ops_ind[j],; config.c_ops_ptr[j], ODE._y); else:; if config.tflag in [1, 11]:; _locals = locals(); # calculates the state vector for collapse by a; # time-dependent collapse operator; exec(_cy_col_spmv_call_func, globals(), _locals); state = _locals['state']; else:; state = \; config.c_funcs[j](ODE.t,; config.c_func_args) * \; spmv_csr(config.c_ops_data[j],; config.c_ops_ind[j],; config.c_ops_ptr[j], ODE._y); state = state / dznrm2(state); ODE._y = state; ODE._integrator.call_args[3] = 1; rand_vals = prng.rand(2). # after while loop; # ----------------; out_psi = ODE._y / dznrm2(ODE._y); if config.e_num == 0 or config.options.store_states:; out_psi_csr = dense2D_to_fastcsr_cmode(np.reshape(out_psi,; (out_psi.shape[0], 1)),; out_psi.shape[0], 1); if (config.options.average_states and; not config.options.steady_state_average):; states_out[k] = Qobj(; out_psi_csr * out_psi_csr.H,; [config.psi0_dims[0], config.psi0_dims[0]],; [config.psi0_shape[0], config.psi0_shape[0]],; fast='mc-dm'). elif config.options.steady_state_average:; states_out[0] = (; states_out[0] +; (out_psi_csr * out_psi_csr.H)). else:; states_out[k] = Qobj(out_psi_csr, config.psi0_dims,; config.psi0_shape, fast='mc'). for jj in range(config.e_num):; expect_out[jj][k] = cy_expect_psi_csr(; config.e_ops_data[jj], config.e_ops_ind[jj],; config.e_o",MatchSource.WIKI,docs/4.2/modules/qutip/mcsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html
https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:27446,Modifiability,config,config,27446,"t_inds]; n_dp += [abs(config.c_funcs[i](; ODE.t, config.c_func_args)) ** 2 *; cy_expect_psi_csr(config.n_ops_data[i],; config.n_ops_ind[i],; config.n_ops_ptr[i],; ODE._y, 1); for i in config.c_td_inds]; n_dp = np.array(n_dp); else:; # all constant collapse operators.; n_dp = np.array(; [cy_expect_psi_csr(config.n_ops_data[i],; config.n_ops_ind[i],; config.n_ops_ptr[i],; ODE._y, 1); for i in range(config.c_num)]). # determine which operator does collapse and store it; kk = np.cumsum(n_dp / np.sum(n_dp)); j = cinds[kk >= rand_vals[1]][0]; which_oper.append(j); if j in config.c_const_inds:; state = spmv_csr(config.c_ops_data[j],; config.c_ops_ind[j],; config.c_ops_ptr[j], ODE._y); else:; if config.tflag in [1, 11]:; _locals = locals(); # calculates the state vector for collapse by a; # time-dependent collapse operator; exec(_cy_col_spmv_call_func, globals(), _locals); state = _locals['state']; else:; state = \; config.c_funcs[j](ODE.t,; config.c_func_args) * \; spmv_csr(config.c_ops_data[j],; config.c_ops_ind[j],; config.c_ops_ptr[j], ODE._y); state = state / dznrm2(state); ODE._y = state; ODE._integrator.call_args[3] = 1; rand_vals = prng.rand(2). # after while loop; # ----------------; out_psi = ODE._y / dznrm2(ODE._y); if config.e_num == 0 or config.options.store_states:; out_psi_csr = dense2D_to_fastcsr_cmode(np.reshape(out_psi,; (out_psi.shape[0], 1)),; out_psi.shape[0], 1); if (config.options.average_states and; not config.options.steady_state_average):; states_out[k] = Qobj(; out_psi_csr * out_psi_csr.H,; [config.psi0_dims[0], config.psi0_dims[0]],; [config.psi0_shape[0], config.psi0_shape[0]],; fast='mc-dm'). elif config.options.steady_state_average:; states_out[0] = (; states_out[0] +; (out_psi_csr * out_psi_csr.H)). else:; states_out[k] = Qobj(out_psi_csr, config.psi0_dims,; config.psi0_shape, fast='mc'). for jj in range(config.e_num):; expect_out[jj][k] = cy_expect_psi_csr(; config.e_ops_data[jj], config.e_ops_ind[jj],; config.e_ops_ptr[jj], out_psi,; config.",MatchSource.WIKI,docs/4.2/modules/qutip/mcsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html
https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:27468,Modifiability,config,config,27468,"onfig.c_funcs[i](; ODE.t, config.c_func_args)) ** 2 *; cy_expect_psi_csr(config.n_ops_data[i],; config.n_ops_ind[i],; config.n_ops_ptr[i],; ODE._y, 1); for i in config.c_td_inds]; n_dp = np.array(n_dp); else:; # all constant collapse operators.; n_dp = np.array(; [cy_expect_psi_csr(config.n_ops_data[i],; config.n_ops_ind[i],; config.n_ops_ptr[i],; ODE._y, 1); for i in range(config.c_num)]). # determine which operator does collapse and store it; kk = np.cumsum(n_dp / np.sum(n_dp)); j = cinds[kk >= rand_vals[1]][0]; which_oper.append(j); if j in config.c_const_inds:; state = spmv_csr(config.c_ops_data[j],; config.c_ops_ind[j],; config.c_ops_ptr[j], ODE._y); else:; if config.tflag in [1, 11]:; _locals = locals(); # calculates the state vector for collapse by a; # time-dependent collapse operator; exec(_cy_col_spmv_call_func, globals(), _locals); state = _locals['state']; else:; state = \; config.c_funcs[j](ODE.t,; config.c_func_args) * \; spmv_csr(config.c_ops_data[j],; config.c_ops_ind[j],; config.c_ops_ptr[j], ODE._y); state = state / dznrm2(state); ODE._y = state; ODE._integrator.call_args[3] = 1; rand_vals = prng.rand(2). # after while loop; # ----------------; out_psi = ODE._y / dznrm2(ODE._y); if config.e_num == 0 or config.options.store_states:; out_psi_csr = dense2D_to_fastcsr_cmode(np.reshape(out_psi,; (out_psi.shape[0], 1)),; out_psi.shape[0], 1); if (config.options.average_states and; not config.options.steady_state_average):; states_out[k] = Qobj(; out_psi_csr * out_psi_csr.H,; [config.psi0_dims[0], config.psi0_dims[0]],; [config.psi0_shape[0], config.psi0_shape[0]],; fast='mc-dm'). elif config.options.steady_state_average:; states_out[0] = (; states_out[0] +; (out_psi_csr * out_psi_csr.H)). else:; states_out[k] = Qobj(out_psi_csr, config.psi0_dims,; config.psi0_shape, fast='mc'). for jj in range(config.e_num):; expect_out[jj][k] = cy_expect_psi_csr(; config.e_ops_data[jj], config.e_ops_ind[jj],; config.e_ops_ptr[jj], out_psi,; config.e_ops_isherm[jj]). # R",MatchSource.WIKI,docs/4.2/modules/qutip/mcsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html
https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:27683,Modifiability,config,config,27683,"nstant collapse operators.; n_dp = np.array(; [cy_expect_psi_csr(config.n_ops_data[i],; config.n_ops_ind[i],; config.n_ops_ptr[i],; ODE._y, 1); for i in range(config.c_num)]). # determine which operator does collapse and store it; kk = np.cumsum(n_dp / np.sum(n_dp)); j = cinds[kk >= rand_vals[1]][0]; which_oper.append(j); if j in config.c_const_inds:; state = spmv_csr(config.c_ops_data[j],; config.c_ops_ind[j],; config.c_ops_ptr[j], ODE._y); else:; if config.tflag in [1, 11]:; _locals = locals(); # calculates the state vector for collapse by a; # time-dependent collapse operator; exec(_cy_col_spmv_call_func, globals(), _locals); state = _locals['state']; else:; state = \; config.c_funcs[j](ODE.t,; config.c_func_args) * \; spmv_csr(config.c_ops_data[j],; config.c_ops_ind[j],; config.c_ops_ptr[j], ODE._y); state = state / dznrm2(state); ODE._y = state; ODE._integrator.call_args[3] = 1; rand_vals = prng.rand(2). # after while loop; # ----------------; out_psi = ODE._y / dznrm2(ODE._y); if config.e_num == 0 or config.options.store_states:; out_psi_csr = dense2D_to_fastcsr_cmode(np.reshape(out_psi,; (out_psi.shape[0], 1)),; out_psi.shape[0], 1); if (config.options.average_states and; not config.options.steady_state_average):; states_out[k] = Qobj(; out_psi_csr * out_psi_csr.H,; [config.psi0_dims[0], config.psi0_dims[0]],; [config.psi0_shape[0], config.psi0_shape[0]],; fast='mc-dm'). elif config.options.steady_state_average:; states_out[0] = (; states_out[0] +; (out_psi_csr * out_psi_csr.H)). else:; states_out[k] = Qobj(out_psi_csr, config.psi0_dims,; config.psi0_shape, fast='mc'). for jj in range(config.e_num):; expect_out[jj][k] = cy_expect_psi_csr(; config.e_ops_data[jj], config.e_ops_ind[jj],; config.e_ops_ptr[jj], out_psi,; config.e_ops_isherm[jj]). # Run at end of mc_alg function; # -----------------------------; if config.options.steady_state_average:; states_out = np.array([Qobj(states_out[0] / float(len(tlist)),; [config.psi0_dims[0],; config.psi0_dims[0]],; [conf",MatchSource.WIKI,docs/4.2/modules/qutip/mcsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html
https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:27704,Modifiability,config,config,27704,"erators.; n_dp = np.array(; [cy_expect_psi_csr(config.n_ops_data[i],; config.n_ops_ind[i],; config.n_ops_ptr[i],; ODE._y, 1); for i in range(config.c_num)]). # determine which operator does collapse and store it; kk = np.cumsum(n_dp / np.sum(n_dp)); j = cinds[kk >= rand_vals[1]][0]; which_oper.append(j); if j in config.c_const_inds:; state = spmv_csr(config.c_ops_data[j],; config.c_ops_ind[j],; config.c_ops_ptr[j], ODE._y); else:; if config.tflag in [1, 11]:; _locals = locals(); # calculates the state vector for collapse by a; # time-dependent collapse operator; exec(_cy_col_spmv_call_func, globals(), _locals); state = _locals['state']; else:; state = \; config.c_funcs[j](ODE.t,; config.c_func_args) * \; spmv_csr(config.c_ops_data[j],; config.c_ops_ind[j],; config.c_ops_ptr[j], ODE._y); state = state / dznrm2(state); ODE._y = state; ODE._integrator.call_args[3] = 1; rand_vals = prng.rand(2). # after while loop; # ----------------; out_psi = ODE._y / dznrm2(ODE._y); if config.e_num == 0 or config.options.store_states:; out_psi_csr = dense2D_to_fastcsr_cmode(np.reshape(out_psi,; (out_psi.shape[0], 1)),; out_psi.shape[0], 1); if (config.options.average_states and; not config.options.steady_state_average):; states_out[k] = Qobj(; out_psi_csr * out_psi_csr.H,; [config.psi0_dims[0], config.psi0_dims[0]],; [config.psi0_shape[0], config.psi0_shape[0]],; fast='mc-dm'). elif config.options.steady_state_average:; states_out[0] = (; states_out[0] +; (out_psi_csr * out_psi_csr.H)). else:; states_out[k] = Qobj(out_psi_csr, config.psi0_dims,; config.psi0_shape, fast='mc'). for jj in range(config.e_num):; expect_out[jj][k] = cy_expect_psi_csr(; config.e_ops_data[jj], config.e_ops_ind[jj],; config.e_ops_ptr[jj], out_psi,; config.e_ops_isherm[jj]). # Run at end of mc_alg function; # -----------------------------; if config.options.steady_state_average:; states_out = np.array([Qobj(states_out[0] / float(len(tlist)),; [config.psi0_dims[0],; config.psi0_dims[0]],; [config.psi0_shape[0],;",MatchSource.WIKI,docs/4.2/modules/qutip/mcsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html
https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:27845,Modifiability,config,config,27845,"e(config.c_num)]). # determine which operator does collapse and store it; kk = np.cumsum(n_dp / np.sum(n_dp)); j = cinds[kk >= rand_vals[1]][0]; which_oper.append(j); if j in config.c_const_inds:; state = spmv_csr(config.c_ops_data[j],; config.c_ops_ind[j],; config.c_ops_ptr[j], ODE._y); else:; if config.tflag in [1, 11]:; _locals = locals(); # calculates the state vector for collapse by a; # time-dependent collapse operator; exec(_cy_col_spmv_call_func, globals(), _locals); state = _locals['state']; else:; state = \; config.c_funcs[j](ODE.t,; config.c_func_args) * \; spmv_csr(config.c_ops_data[j],; config.c_ops_ind[j],; config.c_ops_ptr[j], ODE._y); state = state / dznrm2(state); ODE._y = state; ODE._integrator.call_args[3] = 1; rand_vals = prng.rand(2). # after while loop; # ----------------; out_psi = ODE._y / dznrm2(ODE._y); if config.e_num == 0 or config.options.store_states:; out_psi_csr = dense2D_to_fastcsr_cmode(np.reshape(out_psi,; (out_psi.shape[0], 1)),; out_psi.shape[0], 1); if (config.options.average_states and; not config.options.steady_state_average):; states_out[k] = Qobj(; out_psi_csr * out_psi_csr.H,; [config.psi0_dims[0], config.psi0_dims[0]],; [config.psi0_shape[0], config.psi0_shape[0]],; fast='mc-dm'). elif config.options.steady_state_average:; states_out[0] = (; states_out[0] +; (out_psi_csr * out_psi_csr.H)). else:; states_out[k] = Qobj(out_psi_csr, config.psi0_dims,; config.psi0_shape, fast='mc'). for jj in range(config.e_num):; expect_out[jj][k] = cy_expect_psi_csr(; config.e_ops_data[jj], config.e_ops_ind[jj],; config.e_ops_ptr[jj], out_psi,; config.e_ops_isherm[jj]). # Run at end of mc_alg function; # -----------------------------; if config.options.steady_state_average:; states_out = np.array([Qobj(states_out[0] / float(len(tlist)),; [config.psi0_dims[0],; config.psi0_dims[0]],; [config.psi0_shape[0],; config.psi0_shape[0]],; fast='mc-dm')]). return (states_out, expect_out,; np.array(collapse_times, dtype=float),; np.array(which_oper, dty",MatchSource.WIKI,docs/4.2/modules/qutip/mcsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html
https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:27884,Modifiability,config,config,27884," operator does collapse and store it; kk = np.cumsum(n_dp / np.sum(n_dp)); j = cinds[kk >= rand_vals[1]][0]; which_oper.append(j); if j in config.c_const_inds:; state = spmv_csr(config.c_ops_data[j],; config.c_ops_ind[j],; config.c_ops_ptr[j], ODE._y); else:; if config.tflag in [1, 11]:; _locals = locals(); # calculates the state vector for collapse by a; # time-dependent collapse operator; exec(_cy_col_spmv_call_func, globals(), _locals); state = _locals['state']; else:; state = \; config.c_funcs[j](ODE.t,; config.c_func_args) * \; spmv_csr(config.c_ops_data[j],; config.c_ops_ind[j],; config.c_ops_ptr[j], ODE._y); state = state / dznrm2(state); ODE._y = state; ODE._integrator.call_args[3] = 1; rand_vals = prng.rand(2). # after while loop; # ----------------; out_psi = ODE._y / dznrm2(ODE._y); if config.e_num == 0 or config.options.store_states:; out_psi_csr = dense2D_to_fastcsr_cmode(np.reshape(out_psi,; (out_psi.shape[0], 1)),; out_psi.shape[0], 1); if (config.options.average_states and; not config.options.steady_state_average):; states_out[k] = Qobj(; out_psi_csr * out_psi_csr.H,; [config.psi0_dims[0], config.psi0_dims[0]],; [config.psi0_shape[0], config.psi0_shape[0]],; fast='mc-dm'). elif config.options.steady_state_average:; states_out[0] = (; states_out[0] +; (out_psi_csr * out_psi_csr.H)). else:; states_out[k] = Qobj(out_psi_csr, config.psi0_dims,; config.psi0_shape, fast='mc'). for jj in range(config.e_num):; expect_out[jj][k] = cy_expect_psi_csr(; config.e_ops_data[jj], config.e_ops_ind[jj],; config.e_ops_ptr[jj], out_psi,; config.e_ops_isherm[jj]). # Run at end of mc_alg function; # -----------------------------; if config.options.steady_state_average:; states_out = np.array([Qobj(states_out[0] / float(len(tlist)),; [config.psi0_dims[0],; config.psi0_dims[0]],; [config.psi0_shape[0],; config.psi0_shape[0]],; fast='mc-dm')]). return (states_out, expect_out,; np.array(collapse_times, dtype=float),; np.array(which_oper, dtype=int)). def _mc_func_load(config):",MatchSource.WIKI,docs/4.2/modules/qutip/mcsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html
https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:27977,Modifiability,config,config,27977,"][0]; which_oper.append(j); if j in config.c_const_inds:; state = spmv_csr(config.c_ops_data[j],; config.c_ops_ind[j],; config.c_ops_ptr[j], ODE._y); else:; if config.tflag in [1, 11]:; _locals = locals(); # calculates the state vector for collapse by a; # time-dependent collapse operator; exec(_cy_col_spmv_call_func, globals(), _locals); state = _locals['state']; else:; state = \; config.c_funcs[j](ODE.t,; config.c_func_args) * \; spmv_csr(config.c_ops_data[j],; config.c_ops_ind[j],; config.c_ops_ptr[j], ODE._y); state = state / dznrm2(state); ODE._y = state; ODE._integrator.call_args[3] = 1; rand_vals = prng.rand(2). # after while loop; # ----------------; out_psi = ODE._y / dznrm2(ODE._y); if config.e_num == 0 or config.options.store_states:; out_psi_csr = dense2D_to_fastcsr_cmode(np.reshape(out_psi,; (out_psi.shape[0], 1)),; out_psi.shape[0], 1); if (config.options.average_states and; not config.options.steady_state_average):; states_out[k] = Qobj(; out_psi_csr * out_psi_csr.H,; [config.psi0_dims[0], config.psi0_dims[0]],; [config.psi0_shape[0], config.psi0_shape[0]],; fast='mc-dm'). elif config.options.steady_state_average:; states_out[0] = (; states_out[0] +; (out_psi_csr * out_psi_csr.H)). else:; states_out[k] = Qobj(out_psi_csr, config.psi0_dims,; config.psi0_shape, fast='mc'). for jj in range(config.e_num):; expect_out[jj][k] = cy_expect_psi_csr(; config.e_ops_data[jj], config.e_ops_ind[jj],; config.e_ops_ptr[jj], out_psi,; config.e_ops_isherm[jj]). # Run at end of mc_alg function; # -----------------------------; if config.options.steady_state_average:; states_out = np.array([Qobj(states_out[0] / float(len(tlist)),; [config.psi0_dims[0],; config.psi0_dims[0]],; [config.psi0_shape[0],; config.psi0_shape[0]],; fast='mc-dm')]). return (states_out, expect_out,; np.array(collapse_times, dtype=float),; np.array(which_oper, dtype=int)). def _mc_func_load(config):; """"""Load cython functions"""""". global _cy_rhs_func; global _cy_col_spmv_func, _cy_col_expect_func; glo",MatchSource.WIKI,docs/4.2/modules/qutip/mcsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html
https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:27998,Modifiability,config,config,27998,".append(j); if j in config.c_const_inds:; state = spmv_csr(config.c_ops_data[j],; config.c_ops_ind[j],; config.c_ops_ptr[j], ODE._y); else:; if config.tflag in [1, 11]:; _locals = locals(); # calculates the state vector for collapse by a; # time-dependent collapse operator; exec(_cy_col_spmv_call_func, globals(), _locals); state = _locals['state']; else:; state = \; config.c_funcs[j](ODE.t,; config.c_func_args) * \; spmv_csr(config.c_ops_data[j],; config.c_ops_ind[j],; config.c_ops_ptr[j], ODE._y); state = state / dznrm2(state); ODE._y = state; ODE._integrator.call_args[3] = 1; rand_vals = prng.rand(2). # after while loop; # ----------------; out_psi = ODE._y / dznrm2(ODE._y); if config.e_num == 0 or config.options.store_states:; out_psi_csr = dense2D_to_fastcsr_cmode(np.reshape(out_psi,; (out_psi.shape[0], 1)),; out_psi.shape[0], 1); if (config.options.average_states and; not config.options.steady_state_average):; states_out[k] = Qobj(; out_psi_csr * out_psi_csr.H,; [config.psi0_dims[0], config.psi0_dims[0]],; [config.psi0_shape[0], config.psi0_shape[0]],; fast='mc-dm'). elif config.options.steady_state_average:; states_out[0] = (; states_out[0] +; (out_psi_csr * out_psi_csr.H)). else:; states_out[k] = Qobj(out_psi_csr, config.psi0_dims,; config.psi0_shape, fast='mc'). for jj in range(config.e_num):; expect_out[jj][k] = cy_expect_psi_csr(; config.e_ops_data[jj], config.e_ops_ind[jj],; config.e_ops_ptr[jj], out_psi,; config.e_ops_isherm[jj]). # Run at end of mc_alg function; # -----------------------------; if config.options.steady_state_average:; states_out = np.array([Qobj(states_out[0] / float(len(tlist)),; [config.psi0_dims[0],; config.psi0_dims[0]],; [config.psi0_shape[0],; config.psi0_shape[0]],; fast='mc-dm')]). return (states_out, expect_out,; np.array(collapse_times, dtype=float),; np.array(which_oper, dtype=int)). def _mc_func_load(config):; """"""Load cython functions"""""". global _cy_rhs_func; global _cy_col_spmv_func, _cy_col_expect_func; global _cy_col_spmv_",MatchSource.WIKI,docs/4.2/modules/qutip/mcsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html
https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:28022,Modifiability,config,config,28022,"fig.c_const_inds:; state = spmv_csr(config.c_ops_data[j],; config.c_ops_ind[j],; config.c_ops_ptr[j], ODE._y); else:; if config.tflag in [1, 11]:; _locals = locals(); # calculates the state vector for collapse by a; # time-dependent collapse operator; exec(_cy_col_spmv_call_func, globals(), _locals); state = _locals['state']; else:; state = \; config.c_funcs[j](ODE.t,; config.c_func_args) * \; spmv_csr(config.c_ops_data[j],; config.c_ops_ind[j],; config.c_ops_ptr[j], ODE._y); state = state / dznrm2(state); ODE._y = state; ODE._integrator.call_args[3] = 1; rand_vals = prng.rand(2). # after while loop; # ----------------; out_psi = ODE._y / dznrm2(ODE._y); if config.e_num == 0 or config.options.store_states:; out_psi_csr = dense2D_to_fastcsr_cmode(np.reshape(out_psi,; (out_psi.shape[0], 1)),; out_psi.shape[0], 1); if (config.options.average_states and; not config.options.steady_state_average):; states_out[k] = Qobj(; out_psi_csr * out_psi_csr.H,; [config.psi0_dims[0], config.psi0_dims[0]],; [config.psi0_shape[0], config.psi0_shape[0]],; fast='mc-dm'). elif config.options.steady_state_average:; states_out[0] = (; states_out[0] +; (out_psi_csr * out_psi_csr.H)). else:; states_out[k] = Qobj(out_psi_csr, config.psi0_dims,; config.psi0_shape, fast='mc'). for jj in range(config.e_num):; expect_out[jj][k] = cy_expect_psi_csr(; config.e_ops_data[jj], config.e_ops_ind[jj],; config.e_ops_ptr[jj], out_psi,; config.e_ops_isherm[jj]). # Run at end of mc_alg function; # -----------------------------; if config.options.steady_state_average:; states_out = np.array([Qobj(states_out[0] / float(len(tlist)),; [config.psi0_dims[0],; config.psi0_dims[0]],; [config.psi0_shape[0],; config.psi0_shape[0]],; fast='mc-dm')]). return (states_out, expect_out,; np.array(collapse_times, dtype=float),; np.array(which_oper, dtype=int)). def _mc_func_load(config):; """"""Load cython functions"""""". global _cy_rhs_func; global _cy_col_spmv_func, _cy_col_expect_func; global _cy_col_spmv_call_func, _cy_col_exp",MatchSource.WIKI,docs/4.2/modules/qutip/mcsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html
https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:28044,Modifiability,config,config,28044,"e = spmv_csr(config.c_ops_data[j],; config.c_ops_ind[j],; config.c_ops_ptr[j], ODE._y); else:; if config.tflag in [1, 11]:; _locals = locals(); # calculates the state vector for collapse by a; # time-dependent collapse operator; exec(_cy_col_spmv_call_func, globals(), _locals); state = _locals['state']; else:; state = \; config.c_funcs[j](ODE.t,; config.c_func_args) * \; spmv_csr(config.c_ops_data[j],; config.c_ops_ind[j],; config.c_ops_ptr[j], ODE._y); state = state / dznrm2(state); ODE._y = state; ODE._integrator.call_args[3] = 1; rand_vals = prng.rand(2). # after while loop; # ----------------; out_psi = ODE._y / dznrm2(ODE._y); if config.e_num == 0 or config.options.store_states:; out_psi_csr = dense2D_to_fastcsr_cmode(np.reshape(out_psi,; (out_psi.shape[0], 1)),; out_psi.shape[0], 1); if (config.options.average_states and; not config.options.steady_state_average):; states_out[k] = Qobj(; out_psi_csr * out_psi_csr.H,; [config.psi0_dims[0], config.psi0_dims[0]],; [config.psi0_shape[0], config.psi0_shape[0]],; fast='mc-dm'). elif config.options.steady_state_average:; states_out[0] = (; states_out[0] +; (out_psi_csr * out_psi_csr.H)). else:; states_out[k] = Qobj(out_psi_csr, config.psi0_dims,; config.psi0_shape, fast='mc'). for jj in range(config.e_num):; expect_out[jj][k] = cy_expect_psi_csr(; config.e_ops_data[jj], config.e_ops_ind[jj],; config.e_ops_ptr[jj], out_psi,; config.e_ops_isherm[jj]). # Run at end of mc_alg function; # -----------------------------; if config.options.steady_state_average:; states_out = np.array([Qobj(states_out[0] / float(len(tlist)),; [config.psi0_dims[0],; config.psi0_dims[0]],; [config.psi0_shape[0],; config.psi0_shape[0]],; fast='mc-dm')]). return (states_out, expect_out,; np.array(collapse_times, dtype=float),; np.array(which_oper, dtype=int)). def _mc_func_load(config):; """"""Load cython functions"""""". global _cy_rhs_func; global _cy_col_spmv_func, _cy_col_expect_func; global _cy_col_spmv_call_func, _cy_col_expect_call_func. if debug",MatchSource.WIKI,docs/4.2/modules/qutip/mcsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html
https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:28088,Modifiability,config,config,28088,"_ind[j],; config.c_ops_ptr[j], ODE._y); else:; if config.tflag in [1, 11]:; _locals = locals(); # calculates the state vector for collapse by a; # time-dependent collapse operator; exec(_cy_col_spmv_call_func, globals(), _locals); state = _locals['state']; else:; state = \; config.c_funcs[j](ODE.t,; config.c_func_args) * \; spmv_csr(config.c_ops_data[j],; config.c_ops_ind[j],; config.c_ops_ptr[j], ODE._y); state = state / dznrm2(state); ODE._y = state; ODE._integrator.call_args[3] = 1; rand_vals = prng.rand(2). # after while loop; # ----------------; out_psi = ODE._y / dznrm2(ODE._y); if config.e_num == 0 or config.options.store_states:; out_psi_csr = dense2D_to_fastcsr_cmode(np.reshape(out_psi,; (out_psi.shape[0], 1)),; out_psi.shape[0], 1); if (config.options.average_states and; not config.options.steady_state_average):; states_out[k] = Qobj(; out_psi_csr * out_psi_csr.H,; [config.psi0_dims[0], config.psi0_dims[0]],; [config.psi0_shape[0], config.psi0_shape[0]],; fast='mc-dm'). elif config.options.steady_state_average:; states_out[0] = (; states_out[0] +; (out_psi_csr * out_psi_csr.H)). else:; states_out[k] = Qobj(out_psi_csr, config.psi0_dims,; config.psi0_shape, fast='mc'). for jj in range(config.e_num):; expect_out[jj][k] = cy_expect_psi_csr(; config.e_ops_data[jj], config.e_ops_ind[jj],; config.e_ops_ptr[jj], out_psi,; config.e_ops_isherm[jj]). # Run at end of mc_alg function; # -----------------------------; if config.options.steady_state_average:; states_out = np.array([Qobj(states_out[0] / float(len(tlist)),; [config.psi0_dims[0],; config.psi0_dims[0]],; [config.psi0_shape[0],; config.psi0_shape[0]],; fast='mc-dm')]). return (states_out, expect_out,; np.array(collapse_times, dtype=float),; np.array(which_oper, dtype=int)). def _mc_func_load(config):; """"""Load cython functions"""""". global _cy_rhs_func; global _cy_col_spmv_func, _cy_col_expect_func; global _cy_col_spmv_call_func, _cy_col_expect_call_func. if debug:; print(inspect.stack()[0][3] + "" in "" + str(os.",MatchSource.WIKI,docs/4.2/modules/qutip/mcsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html
https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:28235,Modifiability,config,config,28235," collapse by a; # time-dependent collapse operator; exec(_cy_col_spmv_call_func, globals(), _locals); state = _locals['state']; else:; state = \; config.c_funcs[j](ODE.t,; config.c_func_args) * \; spmv_csr(config.c_ops_data[j],; config.c_ops_ind[j],; config.c_ops_ptr[j], ODE._y); state = state / dznrm2(state); ODE._y = state; ODE._integrator.call_args[3] = 1; rand_vals = prng.rand(2). # after while loop; # ----------------; out_psi = ODE._y / dznrm2(ODE._y); if config.e_num == 0 or config.options.store_states:; out_psi_csr = dense2D_to_fastcsr_cmode(np.reshape(out_psi,; (out_psi.shape[0], 1)),; out_psi.shape[0], 1); if (config.options.average_states and; not config.options.steady_state_average):; states_out[k] = Qobj(; out_psi_csr * out_psi_csr.H,; [config.psi0_dims[0], config.psi0_dims[0]],; [config.psi0_shape[0], config.psi0_shape[0]],; fast='mc-dm'). elif config.options.steady_state_average:; states_out[0] = (; states_out[0] +; (out_psi_csr * out_psi_csr.H)). else:; states_out[k] = Qobj(out_psi_csr, config.psi0_dims,; config.psi0_shape, fast='mc'). for jj in range(config.e_num):; expect_out[jj][k] = cy_expect_psi_csr(; config.e_ops_data[jj], config.e_ops_ind[jj],; config.e_ops_ptr[jj], out_psi,; config.e_ops_isherm[jj]). # Run at end of mc_alg function; # -----------------------------; if config.options.steady_state_average:; states_out = np.array([Qobj(states_out[0] / float(len(tlist)),; [config.psi0_dims[0],; config.psi0_dims[0]],; [config.psi0_shape[0],; config.psi0_shape[0]],; fast='mc-dm')]). return (states_out, expect_out,; np.array(collapse_times, dtype=float),; np.array(which_oper, dtype=int)). def _mc_func_load(config):; """"""Load cython functions"""""". global _cy_rhs_func; global _cy_col_spmv_func, _cy_col_expect_func; global _cy_col_spmv_call_func, _cy_col_expect_call_func. if debug:; print(inspect.stack()[0][3] + "" in "" + str(os.getpid())). if config.tflag in [1, 10, 11]:; # compile time-depdendent RHS code; if config.tflag in [1, 11]:; code = compile('fro",MatchSource.WIKI,docs/4.2/modules/qutip/mcsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html
https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:28254,Modifiability,config,config,28254,"ollapse operator; exec(_cy_col_spmv_call_func, globals(), _locals); state = _locals['state']; else:; state = \; config.c_funcs[j](ODE.t,; config.c_func_args) * \; spmv_csr(config.c_ops_data[j],; config.c_ops_ind[j],; config.c_ops_ptr[j], ODE._y); state = state / dznrm2(state); ODE._y = state; ODE._integrator.call_args[3] = 1; rand_vals = prng.rand(2). # after while loop; # ----------------; out_psi = ODE._y / dznrm2(ODE._y); if config.e_num == 0 or config.options.store_states:; out_psi_csr = dense2D_to_fastcsr_cmode(np.reshape(out_psi,; (out_psi.shape[0], 1)),; out_psi.shape[0], 1); if (config.options.average_states and; not config.options.steady_state_average):; states_out[k] = Qobj(; out_psi_csr * out_psi_csr.H,; [config.psi0_dims[0], config.psi0_dims[0]],; [config.psi0_shape[0], config.psi0_shape[0]],; fast='mc-dm'). elif config.options.steady_state_average:; states_out[0] = (; states_out[0] +; (out_psi_csr * out_psi_csr.H)). else:; states_out[k] = Qobj(out_psi_csr, config.psi0_dims,; config.psi0_shape, fast='mc'). for jj in range(config.e_num):; expect_out[jj][k] = cy_expect_psi_csr(; config.e_ops_data[jj], config.e_ops_ind[jj],; config.e_ops_ptr[jj], out_psi,; config.e_ops_isherm[jj]). # Run at end of mc_alg function; # -----------------------------; if config.options.steady_state_average:; states_out = np.array([Qobj(states_out[0] / float(len(tlist)),; [config.psi0_dims[0],; config.psi0_dims[0]],; [config.psi0_shape[0],; config.psi0_shape[0]],; fast='mc-dm')]). return (states_out, expect_out,; np.array(collapse_times, dtype=float),; np.array(which_oper, dtype=int)). def _mc_func_load(config):; """"""Load cython functions"""""". global _cy_rhs_func; global _cy_col_spmv_func, _cy_col_expect_func; global _cy_col_spmv_call_func, _cy_col_expect_call_func. if debug:; print(inspect.stack()[0][3] + "" in "" + str(os.getpid())). if config.tflag in [1, 10, 11]:; # compile time-depdendent RHS code; if config.tflag in [1, 11]:; code = compile('from ' + config.tdname +; ' import cy",MatchSource.WIKI,docs/4.2/modules/qutip/mcsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html
https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:28301,Modifiability,config,config,28301,", globals(), _locals); state = _locals['state']; else:; state = \; config.c_funcs[j](ODE.t,; config.c_func_args) * \; spmv_csr(config.c_ops_data[j],; config.c_ops_ind[j],; config.c_ops_ptr[j], ODE._y); state = state / dznrm2(state); ODE._y = state; ODE._integrator.call_args[3] = 1; rand_vals = prng.rand(2). # after while loop; # ----------------; out_psi = ODE._y / dznrm2(ODE._y); if config.e_num == 0 or config.options.store_states:; out_psi_csr = dense2D_to_fastcsr_cmode(np.reshape(out_psi,; (out_psi.shape[0], 1)),; out_psi.shape[0], 1); if (config.options.average_states and; not config.options.steady_state_average):; states_out[k] = Qobj(; out_psi_csr * out_psi_csr.H,; [config.psi0_dims[0], config.psi0_dims[0]],; [config.psi0_shape[0], config.psi0_shape[0]],; fast='mc-dm'). elif config.options.steady_state_average:; states_out[0] = (; states_out[0] +; (out_psi_csr * out_psi_csr.H)). else:; states_out[k] = Qobj(out_psi_csr, config.psi0_dims,; config.psi0_shape, fast='mc'). for jj in range(config.e_num):; expect_out[jj][k] = cy_expect_psi_csr(; config.e_ops_data[jj], config.e_ops_ind[jj],; config.e_ops_ptr[jj], out_psi,; config.e_ops_isherm[jj]). # Run at end of mc_alg function; # -----------------------------; if config.options.steady_state_average:; states_out = np.array([Qobj(states_out[0] / float(len(tlist)),; [config.psi0_dims[0],; config.psi0_dims[0]],; [config.psi0_shape[0],; config.psi0_shape[0]],; fast='mc-dm')]). return (states_out, expect_out,; np.array(collapse_times, dtype=float),; np.array(which_oper, dtype=int)). def _mc_func_load(config):; """"""Load cython functions"""""". global _cy_rhs_func; global _cy_col_spmv_func, _cy_col_expect_func; global _cy_col_spmv_call_func, _cy_col_expect_call_func. if debug:; print(inspect.stack()[0][3] + "" in "" + str(os.getpid())). if config.tflag in [1, 10, 11]:; # compile time-depdendent RHS code; if config.tflag in [1, 11]:; code = compile('from ' + config.tdname +; ' import cy_td_ode_rhs, col_spmv, col_expect',; '<strin",MatchSource.WIKI,docs/4.2/modules/qutip/mcsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html
https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:28357,Modifiability,config,config,28357,"state']; else:; state = \; config.c_funcs[j](ODE.t,; config.c_func_args) * \; spmv_csr(config.c_ops_data[j],; config.c_ops_ind[j],; config.c_ops_ptr[j], ODE._y); state = state / dznrm2(state); ODE._y = state; ODE._integrator.call_args[3] = 1; rand_vals = prng.rand(2). # after while loop; # ----------------; out_psi = ODE._y / dznrm2(ODE._y); if config.e_num == 0 or config.options.store_states:; out_psi_csr = dense2D_to_fastcsr_cmode(np.reshape(out_psi,; (out_psi.shape[0], 1)),; out_psi.shape[0], 1); if (config.options.average_states and; not config.options.steady_state_average):; states_out[k] = Qobj(; out_psi_csr * out_psi_csr.H,; [config.psi0_dims[0], config.psi0_dims[0]],; [config.psi0_shape[0], config.psi0_shape[0]],; fast='mc-dm'). elif config.options.steady_state_average:; states_out[0] = (; states_out[0] +; (out_psi_csr * out_psi_csr.H)). else:; states_out[k] = Qobj(out_psi_csr, config.psi0_dims,; config.psi0_shape, fast='mc'). for jj in range(config.e_num):; expect_out[jj][k] = cy_expect_psi_csr(; config.e_ops_data[jj], config.e_ops_ind[jj],; config.e_ops_ptr[jj], out_psi,; config.e_ops_isherm[jj]). # Run at end of mc_alg function; # -----------------------------; if config.options.steady_state_average:; states_out = np.array([Qobj(states_out[0] / float(len(tlist)),; [config.psi0_dims[0],; config.psi0_dims[0]],; [config.psi0_shape[0],; config.psi0_shape[0]],; fast='mc-dm')]). return (states_out, expect_out,; np.array(collapse_times, dtype=float),; np.array(which_oper, dtype=int)). def _mc_func_load(config):; """"""Load cython functions"""""". global _cy_rhs_func; global _cy_col_spmv_func, _cy_col_expect_func; global _cy_col_spmv_call_func, _cy_col_expect_call_func. if debug:; print(inspect.stack()[0][3] + "" in "" + str(os.getpid())). if config.tflag in [1, 10, 11]:; # compile time-depdendent RHS code; if config.tflag in [1, 11]:; code = compile('from ' + config.tdname +; ' import cy_td_ode_rhs, col_spmv, col_expect',; '<string>', 'exec'); exec(code, globals()); _cy",MatchSource.WIKI,docs/4.2/modules/qutip/mcsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html
https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:28380,Modifiability,config,config,28380,"cs[j](ODE.t,; config.c_func_args) * \; spmv_csr(config.c_ops_data[j],; config.c_ops_ind[j],; config.c_ops_ptr[j], ODE._y); state = state / dznrm2(state); ODE._y = state; ODE._integrator.call_args[3] = 1; rand_vals = prng.rand(2). # after while loop; # ----------------; out_psi = ODE._y / dznrm2(ODE._y); if config.e_num == 0 or config.options.store_states:; out_psi_csr = dense2D_to_fastcsr_cmode(np.reshape(out_psi,; (out_psi.shape[0], 1)),; out_psi.shape[0], 1); if (config.options.average_states and; not config.options.steady_state_average):; states_out[k] = Qobj(; out_psi_csr * out_psi_csr.H,; [config.psi0_dims[0], config.psi0_dims[0]],; [config.psi0_shape[0], config.psi0_shape[0]],; fast='mc-dm'). elif config.options.steady_state_average:; states_out[0] = (; states_out[0] +; (out_psi_csr * out_psi_csr.H)). else:; states_out[k] = Qobj(out_psi_csr, config.psi0_dims,; config.psi0_shape, fast='mc'). for jj in range(config.e_num):; expect_out[jj][k] = cy_expect_psi_csr(; config.e_ops_data[jj], config.e_ops_ind[jj],; config.e_ops_ptr[jj], out_psi,; config.e_ops_isherm[jj]). # Run at end of mc_alg function; # -----------------------------; if config.options.steady_state_average:; states_out = np.array([Qobj(states_out[0] / float(len(tlist)),; [config.psi0_dims[0],; config.psi0_dims[0]],; [config.psi0_shape[0],; config.psi0_shape[0]],; fast='mc-dm')]). return (states_out, expect_out,; np.array(collapse_times, dtype=float),; np.array(which_oper, dtype=int)). def _mc_func_load(config):; """"""Load cython functions"""""". global _cy_rhs_func; global _cy_col_spmv_func, _cy_col_expect_func; global _cy_col_spmv_call_func, _cy_col_expect_call_func. if debug:; print(inspect.stack()[0][3] + "" in "" + str(os.getpid())). if config.tflag in [1, 10, 11]:; # compile time-depdendent RHS code; if config.tflag in [1, 11]:; code = compile('from ' + config.tdname +; ' import cy_td_ode_rhs, col_spmv, col_expect',; '<string>', 'exec'); exec(code, globals()); _cy_rhs_func = cy_td_ode_rhs; _cy_col_spmv_",MatchSource.WIKI,docs/4.2/modules/qutip/mcsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html
https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:28403,Modifiability,config,config,28403,"func_args) * \; spmv_csr(config.c_ops_data[j],; config.c_ops_ind[j],; config.c_ops_ptr[j], ODE._y); state = state / dznrm2(state); ODE._y = state; ODE._integrator.call_args[3] = 1; rand_vals = prng.rand(2). # after while loop; # ----------------; out_psi = ODE._y / dznrm2(ODE._y); if config.e_num == 0 or config.options.store_states:; out_psi_csr = dense2D_to_fastcsr_cmode(np.reshape(out_psi,; (out_psi.shape[0], 1)),; out_psi.shape[0], 1); if (config.options.average_states and; not config.options.steady_state_average):; states_out[k] = Qobj(; out_psi_csr * out_psi_csr.H,; [config.psi0_dims[0], config.psi0_dims[0]],; [config.psi0_shape[0], config.psi0_shape[0]],; fast='mc-dm'). elif config.options.steady_state_average:; states_out[0] = (; states_out[0] +; (out_psi_csr * out_psi_csr.H)). else:; states_out[k] = Qobj(out_psi_csr, config.psi0_dims,; config.psi0_shape, fast='mc'). for jj in range(config.e_num):; expect_out[jj][k] = cy_expect_psi_csr(; config.e_ops_data[jj], config.e_ops_ind[jj],; config.e_ops_ptr[jj], out_psi,; config.e_ops_isherm[jj]). # Run at end of mc_alg function; # -----------------------------; if config.options.steady_state_average:; states_out = np.array([Qobj(states_out[0] / float(len(tlist)),; [config.psi0_dims[0],; config.psi0_dims[0]],; [config.psi0_shape[0],; config.psi0_shape[0]],; fast='mc-dm')]). return (states_out, expect_out,; np.array(collapse_times, dtype=float),; np.array(which_oper, dtype=int)). def _mc_func_load(config):; """"""Load cython functions"""""". global _cy_rhs_func; global _cy_col_spmv_func, _cy_col_expect_func; global _cy_col_spmv_call_func, _cy_col_expect_call_func. if debug:; print(inspect.stack()[0][3] + "" in "" + str(os.getpid())). if config.tflag in [1, 10, 11]:; # compile time-depdendent RHS code; if config.tflag in [1, 11]:; code = compile('from ' + config.tdname +; ' import cy_td_ode_rhs, col_spmv, col_expect',; '<string>', 'exec'); exec(code, globals()); _cy_rhs_func = cy_td_ode_rhs; _cy_col_spmv_func = col_spmv; _cy_co",MatchSource.WIKI,docs/4.2/modules/qutip/mcsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html
https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:28435,Modifiability,config,config,28435,"fig.c_ops_data[j],; config.c_ops_ind[j],; config.c_ops_ptr[j], ODE._y); state = state / dznrm2(state); ODE._y = state; ODE._integrator.call_args[3] = 1; rand_vals = prng.rand(2). # after while loop; # ----------------; out_psi = ODE._y / dznrm2(ODE._y); if config.e_num == 0 or config.options.store_states:; out_psi_csr = dense2D_to_fastcsr_cmode(np.reshape(out_psi,; (out_psi.shape[0], 1)),; out_psi.shape[0], 1); if (config.options.average_states and; not config.options.steady_state_average):; states_out[k] = Qobj(; out_psi_csr * out_psi_csr.H,; [config.psi0_dims[0], config.psi0_dims[0]],; [config.psi0_shape[0], config.psi0_shape[0]],; fast='mc-dm'). elif config.options.steady_state_average:; states_out[0] = (; states_out[0] +; (out_psi_csr * out_psi_csr.H)). else:; states_out[k] = Qobj(out_psi_csr, config.psi0_dims,; config.psi0_shape, fast='mc'). for jj in range(config.e_num):; expect_out[jj][k] = cy_expect_psi_csr(; config.e_ops_data[jj], config.e_ops_ind[jj],; config.e_ops_ptr[jj], out_psi,; config.e_ops_isherm[jj]). # Run at end of mc_alg function; # -----------------------------; if config.options.steady_state_average:; states_out = np.array([Qobj(states_out[0] / float(len(tlist)),; [config.psi0_dims[0],; config.psi0_dims[0]],; [config.psi0_shape[0],; config.psi0_shape[0]],; fast='mc-dm')]). return (states_out, expect_out,; np.array(collapse_times, dtype=float),; np.array(which_oper, dtype=int)). def _mc_func_load(config):; """"""Load cython functions"""""". global _cy_rhs_func; global _cy_col_spmv_func, _cy_col_expect_func; global _cy_col_spmv_call_func, _cy_col_expect_call_func. if debug:; print(inspect.stack()[0][3] + "" in "" + str(os.getpid())). if config.tflag in [1, 10, 11]:; # compile time-depdendent RHS code; if config.tflag in [1, 11]:; code = compile('from ' + config.tdname +; ' import cy_td_ode_rhs, col_spmv, col_expect',; '<string>', 'exec'); exec(code, globals()); _cy_rhs_func = cy_td_ode_rhs; _cy_col_spmv_func = col_spmv; _cy_col_expect_func = col_expect;",MatchSource.WIKI,docs/4.2/modules/qutip/mcsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html
https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:28530,Modifiability,config,config,28530,"state = state / dznrm2(state); ODE._y = state; ODE._integrator.call_args[3] = 1; rand_vals = prng.rand(2). # after while loop; # ----------------; out_psi = ODE._y / dznrm2(ODE._y); if config.e_num == 0 or config.options.store_states:; out_psi_csr = dense2D_to_fastcsr_cmode(np.reshape(out_psi,; (out_psi.shape[0], 1)),; out_psi.shape[0], 1); if (config.options.average_states and; not config.options.steady_state_average):; states_out[k] = Qobj(; out_psi_csr * out_psi_csr.H,; [config.psi0_dims[0], config.psi0_dims[0]],; [config.psi0_shape[0], config.psi0_shape[0]],; fast='mc-dm'). elif config.options.steady_state_average:; states_out[0] = (; states_out[0] +; (out_psi_csr * out_psi_csr.H)). else:; states_out[k] = Qobj(out_psi_csr, config.psi0_dims,; config.psi0_shape, fast='mc'). for jj in range(config.e_num):; expect_out[jj][k] = cy_expect_psi_csr(; config.e_ops_data[jj], config.e_ops_ind[jj],; config.e_ops_ptr[jj], out_psi,; config.e_ops_isherm[jj]). # Run at end of mc_alg function; # -----------------------------; if config.options.steady_state_average:; states_out = np.array([Qobj(states_out[0] / float(len(tlist)),; [config.psi0_dims[0],; config.psi0_dims[0]],; [config.psi0_shape[0],; config.psi0_shape[0]],; fast='mc-dm')]). return (states_out, expect_out,; np.array(collapse_times, dtype=float),; np.array(which_oper, dtype=int)). def _mc_func_load(config):; """"""Load cython functions"""""". global _cy_rhs_func; global _cy_col_spmv_func, _cy_col_expect_func; global _cy_col_spmv_call_func, _cy_col_expect_call_func. if debug:; print(inspect.stack()[0][3] + "" in "" + str(os.getpid())). if config.tflag in [1, 10, 11]:; # compile time-depdendent RHS code; if config.tflag in [1, 11]:; code = compile('from ' + config.tdname +; ' import cy_td_ode_rhs, col_spmv, col_expect',; '<string>', 'exec'); exec(code, globals()); _cy_rhs_func = cy_td_ode_rhs; _cy_col_spmv_func = col_spmv; _cy_col_expect_func = col_expect; else:; code = compile('from ' + config.tdname +; ' import cy_td_ode_rhs'",MatchSource.WIKI,docs/4.2/modules/qutip/mcsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html
https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:28633,Modifiability,config,config,28633," while loop; # ----------------; out_psi = ODE._y / dznrm2(ODE._y); if config.e_num == 0 or config.options.store_states:; out_psi_csr = dense2D_to_fastcsr_cmode(np.reshape(out_psi,; (out_psi.shape[0], 1)),; out_psi.shape[0], 1); if (config.options.average_states and; not config.options.steady_state_average):; states_out[k] = Qobj(; out_psi_csr * out_psi_csr.H,; [config.psi0_dims[0], config.psi0_dims[0]],; [config.psi0_shape[0], config.psi0_shape[0]],; fast='mc-dm'). elif config.options.steady_state_average:; states_out[0] = (; states_out[0] +; (out_psi_csr * out_psi_csr.H)). else:; states_out[k] = Qobj(out_psi_csr, config.psi0_dims,; config.psi0_shape, fast='mc'). for jj in range(config.e_num):; expect_out[jj][k] = cy_expect_psi_csr(; config.e_ops_data[jj], config.e_ops_ind[jj],; config.e_ops_ptr[jj], out_psi,; config.e_ops_isherm[jj]). # Run at end of mc_alg function; # -----------------------------; if config.options.steady_state_average:; states_out = np.array([Qobj(states_out[0] / float(len(tlist)),; [config.psi0_dims[0],; config.psi0_dims[0]],; [config.psi0_shape[0],; config.psi0_shape[0]],; fast='mc-dm')]). return (states_out, expect_out,; np.array(collapse_times, dtype=float),; np.array(which_oper, dtype=int)). def _mc_func_load(config):; """"""Load cython functions"""""". global _cy_rhs_func; global _cy_col_spmv_func, _cy_col_expect_func; global _cy_col_spmv_call_func, _cy_col_expect_call_func. if debug:; print(inspect.stack()[0][3] + "" in "" + str(os.getpid())). if config.tflag in [1, 10, 11]:; # compile time-depdendent RHS code; if config.tflag in [1, 11]:; code = compile('from ' + config.tdname +; ' import cy_td_ode_rhs, col_spmv, col_expect',; '<string>', 'exec'); exec(code, globals()); _cy_rhs_func = cy_td_ode_rhs; _cy_col_spmv_func = col_spmv; _cy_col_expect_func = col_expect; else:; code = compile('from ' + config.tdname +; ' import cy_td_ode_rhs', '<string>', 'exec'); exec(code, globals()); _cy_rhs_func = cy_td_ode_rhs. # compile wrapper functions for calli",MatchSource.WIKI,docs/4.2/modules/qutip/mcsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html
https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:28655,Modifiability,config,config,28655,"i = ODE._y / dznrm2(ODE._y); if config.e_num == 0 or config.options.store_states:; out_psi_csr = dense2D_to_fastcsr_cmode(np.reshape(out_psi,; (out_psi.shape[0], 1)),; out_psi.shape[0], 1); if (config.options.average_states and; not config.options.steady_state_average):; states_out[k] = Qobj(; out_psi_csr * out_psi_csr.H,; [config.psi0_dims[0], config.psi0_dims[0]],; [config.psi0_shape[0], config.psi0_shape[0]],; fast='mc-dm'). elif config.options.steady_state_average:; states_out[0] = (; states_out[0] +; (out_psi_csr * out_psi_csr.H)). else:; states_out[k] = Qobj(out_psi_csr, config.psi0_dims,; config.psi0_shape, fast='mc'). for jj in range(config.e_num):; expect_out[jj][k] = cy_expect_psi_csr(; config.e_ops_data[jj], config.e_ops_ind[jj],; config.e_ops_ptr[jj], out_psi,; config.e_ops_isherm[jj]). # Run at end of mc_alg function; # -----------------------------; if config.options.steady_state_average:; states_out = np.array([Qobj(states_out[0] / float(len(tlist)),; [config.psi0_dims[0],; config.psi0_dims[0]],; [config.psi0_shape[0],; config.psi0_shape[0]],; fast='mc-dm')]). return (states_out, expect_out,; np.array(collapse_times, dtype=float),; np.array(which_oper, dtype=int)). def _mc_func_load(config):; """"""Load cython functions"""""". global _cy_rhs_func; global _cy_col_spmv_func, _cy_col_expect_func; global _cy_col_spmv_call_func, _cy_col_expect_call_func. if debug:; print(inspect.stack()[0][3] + "" in "" + str(os.getpid())). if config.tflag in [1, 10, 11]:; # compile time-depdendent RHS code; if config.tflag in [1, 11]:; code = compile('from ' + config.tdname +; ' import cy_td_ode_rhs, col_spmv, col_expect',; '<string>', 'exec'); exec(code, globals()); _cy_rhs_func = cy_td_ode_rhs; _cy_col_spmv_func = col_spmv; _cy_col_expect_func = col_expect; else:; code = compile('from ' + config.tdname +; ' import cy_td_ode_rhs', '<string>', 'exec'); exec(code, globals()); _cy_rhs_func = cy_td_ode_rhs. # compile wrapper functions for calling cython spmv and expect; if config.co",MatchSource.WIKI,docs/4.2/modules/qutip/mcsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html
https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:28679,Modifiability,config,config,28679,"._y); if config.e_num == 0 or config.options.store_states:; out_psi_csr = dense2D_to_fastcsr_cmode(np.reshape(out_psi,; (out_psi.shape[0], 1)),; out_psi.shape[0], 1); if (config.options.average_states and; not config.options.steady_state_average):; states_out[k] = Qobj(; out_psi_csr * out_psi_csr.H,; [config.psi0_dims[0], config.psi0_dims[0]],; [config.psi0_shape[0], config.psi0_shape[0]],; fast='mc-dm'). elif config.options.steady_state_average:; states_out[0] = (; states_out[0] +; (out_psi_csr * out_psi_csr.H)). else:; states_out[k] = Qobj(out_psi_csr, config.psi0_dims,; config.psi0_shape, fast='mc'). for jj in range(config.e_num):; expect_out[jj][k] = cy_expect_psi_csr(; config.e_ops_data[jj], config.e_ops_ind[jj],; config.e_ops_ptr[jj], out_psi,; config.e_ops_isherm[jj]). # Run at end of mc_alg function; # -----------------------------; if config.options.steady_state_average:; states_out = np.array([Qobj(states_out[0] / float(len(tlist)),; [config.psi0_dims[0],; config.psi0_dims[0]],; [config.psi0_shape[0],; config.psi0_shape[0]],; fast='mc-dm')]). return (states_out, expect_out,; np.array(collapse_times, dtype=float),; np.array(which_oper, dtype=int)). def _mc_func_load(config):; """"""Load cython functions"""""". global _cy_rhs_func; global _cy_col_spmv_func, _cy_col_expect_func; global _cy_col_spmv_call_func, _cy_col_expect_call_func. if debug:; print(inspect.stack()[0][3] + "" in "" + str(os.getpid())). if config.tflag in [1, 10, 11]:; # compile time-depdendent RHS code; if config.tflag in [1, 11]:; code = compile('from ' + config.tdname +; ' import cy_td_ode_rhs, col_spmv, col_expect',; '<string>', 'exec'); exec(code, globals()); _cy_rhs_func = cy_td_ode_rhs; _cy_col_spmv_func = col_spmv; _cy_col_expect_func = col_expect; else:; code = compile('from ' + config.tdname +; ' import cy_td_ode_rhs', '<string>', 'exec'); exec(code, globals()); _cy_rhs_func = cy_td_ode_rhs. # compile wrapper functions for calling cython spmv and expect; if config.col_spmv_code:; _cy_col_s",MatchSource.WIKI,docs/4.2/modules/qutip/mcsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html
https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:28702,Modifiability,config,config,28702,"= 0 or config.options.store_states:; out_psi_csr = dense2D_to_fastcsr_cmode(np.reshape(out_psi,; (out_psi.shape[0], 1)),; out_psi.shape[0], 1); if (config.options.average_states and; not config.options.steady_state_average):; states_out[k] = Qobj(; out_psi_csr * out_psi_csr.H,; [config.psi0_dims[0], config.psi0_dims[0]],; [config.psi0_shape[0], config.psi0_shape[0]],; fast='mc-dm'). elif config.options.steady_state_average:; states_out[0] = (; states_out[0] +; (out_psi_csr * out_psi_csr.H)). else:; states_out[k] = Qobj(out_psi_csr, config.psi0_dims,; config.psi0_shape, fast='mc'). for jj in range(config.e_num):; expect_out[jj][k] = cy_expect_psi_csr(; config.e_ops_data[jj], config.e_ops_ind[jj],; config.e_ops_ptr[jj], out_psi,; config.e_ops_isherm[jj]). # Run at end of mc_alg function; # -----------------------------; if config.options.steady_state_average:; states_out = np.array([Qobj(states_out[0] / float(len(tlist)),; [config.psi0_dims[0],; config.psi0_dims[0]],; [config.psi0_shape[0],; config.psi0_shape[0]],; fast='mc-dm')]). return (states_out, expect_out,; np.array(collapse_times, dtype=float),; np.array(which_oper, dtype=int)). def _mc_func_load(config):; """"""Load cython functions"""""". global _cy_rhs_func; global _cy_col_spmv_func, _cy_col_expect_func; global _cy_col_spmv_call_func, _cy_col_expect_call_func. if debug:; print(inspect.stack()[0][3] + "" in "" + str(os.getpid())). if config.tflag in [1, 10, 11]:; # compile time-depdendent RHS code; if config.tflag in [1, 11]:; code = compile('from ' + config.tdname +; ' import cy_td_ode_rhs, col_spmv, col_expect',; '<string>', 'exec'); exec(code, globals()); _cy_rhs_func = cy_td_ode_rhs; _cy_col_spmv_func = col_spmv; _cy_col_expect_func = col_expect; else:; code = compile('from ' + config.tdname +; ' import cy_td_ode_rhs', '<string>', 'exec'); exec(code, globals()); _cy_rhs_func = cy_td_ode_rhs. # compile wrapper functions for calling cython spmv and expect; if config.col_spmv_code:; _cy_col_spmv_call_func = compile(",MatchSource.WIKI,docs/4.2/modules/qutip/mcsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html
https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:28868,Modifiability,config,config,28868,"d; not config.options.steady_state_average):; states_out[k] = Qobj(; out_psi_csr * out_psi_csr.H,; [config.psi0_dims[0], config.psi0_dims[0]],; [config.psi0_shape[0], config.psi0_shape[0]],; fast='mc-dm'). elif config.options.steady_state_average:; states_out[0] = (; states_out[0] +; (out_psi_csr * out_psi_csr.H)). else:; states_out[k] = Qobj(out_psi_csr, config.psi0_dims,; config.psi0_shape, fast='mc'). for jj in range(config.e_num):; expect_out[jj][k] = cy_expect_psi_csr(; config.e_ops_data[jj], config.e_ops_ind[jj],; config.e_ops_ptr[jj], out_psi,; config.e_ops_isherm[jj]). # Run at end of mc_alg function; # -----------------------------; if config.options.steady_state_average:; states_out = np.array([Qobj(states_out[0] / float(len(tlist)),; [config.psi0_dims[0],; config.psi0_dims[0]],; [config.psi0_shape[0],; config.psi0_shape[0]],; fast='mc-dm')]). return (states_out, expect_out,; np.array(collapse_times, dtype=float),; np.array(which_oper, dtype=int)). def _mc_func_load(config):; """"""Load cython functions"""""". global _cy_rhs_func; global _cy_col_spmv_func, _cy_col_expect_func; global _cy_col_spmv_call_func, _cy_col_expect_call_func. if debug:; print(inspect.stack()[0][3] + "" in "" + str(os.getpid())). if config.tflag in [1, 10, 11]:; # compile time-depdendent RHS code; if config.tflag in [1, 11]:; code = compile('from ' + config.tdname +; ' import cy_td_ode_rhs, col_spmv, col_expect',; '<string>', 'exec'); exec(code, globals()); _cy_rhs_func = cy_td_ode_rhs; _cy_col_spmv_func = col_spmv; _cy_col_expect_func = col_expect; else:; code = compile('from ' + config.tdname +; ' import cy_td_ode_rhs', '<string>', 'exec'); exec(code, globals()); _cy_rhs_func = cy_td_ode_rhs. # compile wrapper functions for calling cython spmv and expect; if config.col_spmv_code:; _cy_col_spmv_call_func = compile(; config.col_spmv_code, '<string>', 'exec'). if config.col_expect_code:; _cy_col_expect_call_func = compile(; config.col_expect_code, '<string>', 'exec'). elif config.tflag == 0:; ",MatchSource.WIKI,docs/4.2/modules/qutip/mcsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html
https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:29104,Modifiability,config,config,29104,"eady_state_average:; states_out[0] = (; states_out[0] +; (out_psi_csr * out_psi_csr.H)). else:; states_out[k] = Qobj(out_psi_csr, config.psi0_dims,; config.psi0_shape, fast='mc'). for jj in range(config.e_num):; expect_out[jj][k] = cy_expect_psi_csr(; config.e_ops_data[jj], config.e_ops_ind[jj],; config.e_ops_ptr[jj], out_psi,; config.e_ops_isherm[jj]). # Run at end of mc_alg function; # -----------------------------; if config.options.steady_state_average:; states_out = np.array([Qobj(states_out[0] / float(len(tlist)),; [config.psi0_dims[0],; config.psi0_dims[0]],; [config.psi0_shape[0],; config.psi0_shape[0]],; fast='mc-dm')]). return (states_out, expect_out,; np.array(collapse_times, dtype=float),; np.array(which_oper, dtype=int)). def _mc_func_load(config):; """"""Load cython functions"""""". global _cy_rhs_func; global _cy_col_spmv_func, _cy_col_expect_func; global _cy_col_spmv_call_func, _cy_col_expect_call_func. if debug:; print(inspect.stack()[0][3] + "" in "" + str(os.getpid())). if config.tflag in [1, 10, 11]:; # compile time-depdendent RHS code; if config.tflag in [1, 11]:; code = compile('from ' + config.tdname +; ' import cy_td_ode_rhs, col_spmv, col_expect',; '<string>', 'exec'); exec(code, globals()); _cy_rhs_func = cy_td_ode_rhs; _cy_col_spmv_func = col_spmv; _cy_col_expect_func = col_expect; else:; code = compile('from ' + config.tdname +; ' import cy_td_ode_rhs', '<string>', 'exec'); exec(code, globals()); _cy_rhs_func = cy_td_ode_rhs. # compile wrapper functions for calling cython spmv and expect; if config.col_spmv_code:; _cy_col_spmv_call_func = compile(; config.col_spmv_code, '<string>', 'exec'). if config.col_expect_code:; _cy_col_expect_call_func = compile(; config.col_expect_code, '<string>', 'exec'). elif config.tflag == 0:; _cy_rhs_func = cy_ode_rhs. def _mc_data_config(H, psi0, h_stuff, c_ops, c_stuff, args, e_ops,; options, config):; """"""Creates the appropriate data structures for the monte carlo solver; based on the given time-dependent, or indep",MatchSource.WIKI,docs/4.2/modules/qutip/mcsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html
https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:29173,Modifiability,config,config,29173,"states_out[0] +; (out_psi_csr * out_psi_csr.H)). else:; states_out[k] = Qobj(out_psi_csr, config.psi0_dims,; config.psi0_shape, fast='mc'). for jj in range(config.e_num):; expect_out[jj][k] = cy_expect_psi_csr(; config.e_ops_data[jj], config.e_ops_ind[jj],; config.e_ops_ptr[jj], out_psi,; config.e_ops_isherm[jj]). # Run at end of mc_alg function; # -----------------------------; if config.options.steady_state_average:; states_out = np.array([Qobj(states_out[0] / float(len(tlist)),; [config.psi0_dims[0],; config.psi0_dims[0]],; [config.psi0_shape[0],; config.psi0_shape[0]],; fast='mc-dm')]). return (states_out, expect_out,; np.array(collapse_times, dtype=float),; np.array(which_oper, dtype=int)). def _mc_func_load(config):; """"""Load cython functions"""""". global _cy_rhs_func; global _cy_col_spmv_func, _cy_col_expect_func; global _cy_col_spmv_call_func, _cy_col_expect_call_func. if debug:; print(inspect.stack()[0][3] + "" in "" + str(os.getpid())). if config.tflag in [1, 10, 11]:; # compile time-depdendent RHS code; if config.tflag in [1, 11]:; code = compile('from ' + config.tdname +; ' import cy_td_ode_rhs, col_spmv, col_expect',; '<string>', 'exec'); exec(code, globals()); _cy_rhs_func = cy_td_ode_rhs; _cy_col_spmv_func = col_spmv; _cy_col_expect_func = col_expect; else:; code = compile('from ' + config.tdname +; ' import cy_td_ode_rhs', '<string>', 'exec'); exec(code, globals()); _cy_rhs_func = cy_td_ode_rhs. # compile wrapper functions for calling cython spmv and expect; if config.col_spmv_code:; _cy_col_spmv_call_func = compile(; config.col_spmv_code, '<string>', 'exec'). if config.col_expect_code:; _cy_col_expect_call_func = compile(; config.col_expect_code, '<string>', 'exec'). elif config.tflag == 0:; _cy_rhs_func = cy_ode_rhs. def _mc_data_config(H, psi0, h_stuff, c_ops, c_stuff, args, e_ops,; options, config):; """"""Creates the appropriate data structures for the monte carlo solver; based on the given time-dependent, or indepdendent, format.; """""". if debug:; print(",MatchSource.WIKI,docs/4.2/modules/qutip/mcsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html
https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:29224,Modifiability,config,config,29224,"es_out[k] = Qobj(out_psi_csr, config.psi0_dims,; config.psi0_shape, fast='mc'). for jj in range(config.e_num):; expect_out[jj][k] = cy_expect_psi_csr(; config.e_ops_data[jj], config.e_ops_ind[jj],; config.e_ops_ptr[jj], out_psi,; config.e_ops_isherm[jj]). # Run at end of mc_alg function; # -----------------------------; if config.options.steady_state_average:; states_out = np.array([Qobj(states_out[0] / float(len(tlist)),; [config.psi0_dims[0],; config.psi0_dims[0]],; [config.psi0_shape[0],; config.psi0_shape[0]],; fast='mc-dm')]). return (states_out, expect_out,; np.array(collapse_times, dtype=float),; np.array(which_oper, dtype=int)). def _mc_func_load(config):; """"""Load cython functions"""""". global _cy_rhs_func; global _cy_col_spmv_func, _cy_col_expect_func; global _cy_col_spmv_call_func, _cy_col_expect_call_func. if debug:; print(inspect.stack()[0][3] + "" in "" + str(os.getpid())). if config.tflag in [1, 10, 11]:; # compile time-depdendent RHS code; if config.tflag in [1, 11]:; code = compile('from ' + config.tdname +; ' import cy_td_ode_rhs, col_spmv, col_expect',; '<string>', 'exec'); exec(code, globals()); _cy_rhs_func = cy_td_ode_rhs; _cy_col_spmv_func = col_spmv; _cy_col_expect_func = col_expect; else:; code = compile('from ' + config.tdname +; ' import cy_td_ode_rhs', '<string>', 'exec'); exec(code, globals()); _cy_rhs_func = cy_td_ode_rhs. # compile wrapper functions for calling cython spmv and expect; if config.col_spmv_code:; _cy_col_spmv_call_func = compile(; config.col_spmv_code, '<string>', 'exec'). if config.col_expect_code:; _cy_col_expect_call_func = compile(; config.col_expect_code, '<string>', 'exec'). elif config.tflag == 0:; _cy_rhs_func = cy_ode_rhs. def _mc_data_config(H, psi0, h_stuff, c_ops, c_stuff, args, e_ops,; options, config):; """"""Creates the appropriate data structures for the monte carlo solver; based on the given time-dependent, or indepdendent, format.; """""". if debug:; print(inspect.stack()[0][3]). config.soft_reset(). # take care of ",MatchSource.WIKI,docs/4.2/modules/qutip/mcsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html
https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:29459,Modifiability,config,config,29459,"si_csr(; config.e_ops_data[jj], config.e_ops_ind[jj],; config.e_ops_ptr[jj], out_psi,; config.e_ops_isherm[jj]). # Run at end of mc_alg function; # -----------------------------; if config.options.steady_state_average:; states_out = np.array([Qobj(states_out[0] / float(len(tlist)),; [config.psi0_dims[0],; config.psi0_dims[0]],; [config.psi0_shape[0],; config.psi0_shape[0]],; fast='mc-dm')]). return (states_out, expect_out,; np.array(collapse_times, dtype=float),; np.array(which_oper, dtype=int)). def _mc_func_load(config):; """"""Load cython functions"""""". global _cy_rhs_func; global _cy_col_spmv_func, _cy_col_expect_func; global _cy_col_spmv_call_func, _cy_col_expect_call_func. if debug:; print(inspect.stack()[0][3] + "" in "" + str(os.getpid())). if config.tflag in [1, 10, 11]:; # compile time-depdendent RHS code; if config.tflag in [1, 11]:; code = compile('from ' + config.tdname +; ' import cy_td_ode_rhs, col_spmv, col_expect',; '<string>', 'exec'); exec(code, globals()); _cy_rhs_func = cy_td_ode_rhs; _cy_col_spmv_func = col_spmv; _cy_col_expect_func = col_expect; else:; code = compile('from ' + config.tdname +; ' import cy_td_ode_rhs', '<string>', 'exec'); exec(code, globals()); _cy_rhs_func = cy_td_ode_rhs. # compile wrapper functions for calling cython spmv and expect; if config.col_spmv_code:; _cy_col_spmv_call_func = compile(; config.col_spmv_code, '<string>', 'exec'). if config.col_expect_code:; _cy_col_expect_call_func = compile(; config.col_expect_code, '<string>', 'exec'). elif config.tflag == 0:; _cy_rhs_func = cy_ode_rhs. def _mc_data_config(H, psi0, h_stuff, c_ops, c_stuff, args, e_ops,; options, config):; """"""Creates the appropriate data structures for the monte carlo solver; based on the given time-dependent, or indepdendent, format.; """""". if debug:; print(inspect.stack()[0][3]). config.soft_reset(). # take care of expectation values, if any; if any(e_ops):; config.e_num = len(e_ops); for op in e_ops:; if isinstance(op, list):; op = op[0]; config.e_ops_dat",MatchSource.WIKI,docs/4.2/modules/qutip/mcsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html
https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:29642,Modifiability,config,config,29642," float(len(tlist)),; [config.psi0_dims[0],; config.psi0_dims[0]],; [config.psi0_shape[0],; config.psi0_shape[0]],; fast='mc-dm')]). return (states_out, expect_out,; np.array(collapse_times, dtype=float),; np.array(which_oper, dtype=int)). def _mc_func_load(config):; """"""Load cython functions"""""". global _cy_rhs_func; global _cy_col_spmv_func, _cy_col_expect_func; global _cy_col_spmv_call_func, _cy_col_expect_call_func. if debug:; print(inspect.stack()[0][3] + "" in "" + str(os.getpid())). if config.tflag in [1, 10, 11]:; # compile time-depdendent RHS code; if config.tflag in [1, 11]:; code = compile('from ' + config.tdname +; ' import cy_td_ode_rhs, col_spmv, col_expect',; '<string>', 'exec'); exec(code, globals()); _cy_rhs_func = cy_td_ode_rhs; _cy_col_spmv_func = col_spmv; _cy_col_expect_func = col_expect; else:; code = compile('from ' + config.tdname +; ' import cy_td_ode_rhs', '<string>', 'exec'); exec(code, globals()); _cy_rhs_func = cy_td_ode_rhs. # compile wrapper functions for calling cython spmv and expect; if config.col_spmv_code:; _cy_col_spmv_call_func = compile(; config.col_spmv_code, '<string>', 'exec'). if config.col_expect_code:; _cy_col_expect_call_func = compile(; config.col_expect_code, '<string>', 'exec'). elif config.tflag == 0:; _cy_rhs_func = cy_ode_rhs. def _mc_data_config(H, psi0, h_stuff, c_ops, c_stuff, args, e_ops,; options, config):; """"""Creates the appropriate data structures for the monte carlo solver; based on the given time-dependent, or indepdendent, format.; """""". if debug:; print(inspect.stack()[0][3]). config.soft_reset(). # take care of expectation values, if any; if any(e_ops):; config.e_num = len(e_ops); for op in e_ops:; if isinstance(op, list):; op = op[0]; config.e_ops_data.append(op.data.data); config.e_ops_ind.append(op.data.indices); config.e_ops_ptr.append(op.data.indptr); config.e_ops_isherm.append(op.isherm). config.e_ops_data = np.array(config.e_ops_data); config.e_ops_ind = np.array(config.e_ops_ind); config.e_ops_ptr = np",MatchSource.WIKI,docs/4.2/modules/qutip/mcsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html
https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:29700,Modifiability,config,config,29700,"[config.psi0_shape[0],; config.psi0_shape[0]],; fast='mc-dm')]). return (states_out, expect_out,; np.array(collapse_times, dtype=float),; np.array(which_oper, dtype=int)). def _mc_func_load(config):; """"""Load cython functions"""""". global _cy_rhs_func; global _cy_col_spmv_func, _cy_col_expect_func; global _cy_col_spmv_call_func, _cy_col_expect_call_func. if debug:; print(inspect.stack()[0][3] + "" in "" + str(os.getpid())). if config.tflag in [1, 10, 11]:; # compile time-depdendent RHS code; if config.tflag in [1, 11]:; code = compile('from ' + config.tdname +; ' import cy_td_ode_rhs, col_spmv, col_expect',; '<string>', 'exec'); exec(code, globals()); _cy_rhs_func = cy_td_ode_rhs; _cy_col_spmv_func = col_spmv; _cy_col_expect_func = col_expect; else:; code = compile('from ' + config.tdname +; ' import cy_td_ode_rhs', '<string>', 'exec'); exec(code, globals()); _cy_rhs_func = cy_td_ode_rhs. # compile wrapper functions for calling cython spmv and expect; if config.col_spmv_code:; _cy_col_spmv_call_func = compile(; config.col_spmv_code, '<string>', 'exec'). if config.col_expect_code:; _cy_col_expect_call_func = compile(; config.col_expect_code, '<string>', 'exec'). elif config.tflag == 0:; _cy_rhs_func = cy_ode_rhs. def _mc_data_config(H, psi0, h_stuff, c_ops, c_stuff, args, e_ops,; options, config):; """"""Creates the appropriate data structures for the monte carlo solver; based on the given time-dependent, or indepdendent, format.; """""". if debug:; print(inspect.stack()[0][3]). config.soft_reset(). # take care of expectation values, if any; if any(e_ops):; config.e_num = len(e_ops); for op in e_ops:; if isinstance(op, list):; op = op[0]; config.e_ops_data.append(op.data.data); config.e_ops_ind.append(op.data.indices); config.e_ops_ptr.append(op.data.indptr); config.e_ops_isherm.append(op.isherm). config.e_ops_data = np.array(config.e_ops_data); config.e_ops_ind = np.array(config.e_ops_ind); config.e_ops_ptr = np.array(config.e_ops_ptr); config.e_ops_isherm = np.array(config.e_",MatchSource.WIKI,docs/4.2/modules/qutip/mcsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html
https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:29746,Modifiability,config,config,29746,"rn (states_out, expect_out,; np.array(collapse_times, dtype=float),; np.array(which_oper, dtype=int)). def _mc_func_load(config):; """"""Load cython functions"""""". global _cy_rhs_func; global _cy_col_spmv_func, _cy_col_expect_func; global _cy_col_spmv_call_func, _cy_col_expect_call_func. if debug:; print(inspect.stack()[0][3] + "" in "" + str(os.getpid())). if config.tflag in [1, 10, 11]:; # compile time-depdendent RHS code; if config.tflag in [1, 11]:; code = compile('from ' + config.tdname +; ' import cy_td_ode_rhs, col_spmv, col_expect',; '<string>', 'exec'); exec(code, globals()); _cy_rhs_func = cy_td_ode_rhs; _cy_col_spmv_func = col_spmv; _cy_col_expect_func = col_expect; else:; code = compile('from ' + config.tdname +; ' import cy_td_ode_rhs', '<string>', 'exec'); exec(code, globals()); _cy_rhs_func = cy_td_ode_rhs. # compile wrapper functions for calling cython spmv and expect; if config.col_spmv_code:; _cy_col_spmv_call_func = compile(; config.col_spmv_code, '<string>', 'exec'). if config.col_expect_code:; _cy_col_expect_call_func = compile(; config.col_expect_code, '<string>', 'exec'). elif config.tflag == 0:; _cy_rhs_func = cy_ode_rhs. def _mc_data_config(H, psi0, h_stuff, c_ops, c_stuff, args, e_ops,; options, config):; """"""Creates the appropriate data structures for the monte carlo solver; based on the given time-dependent, or indepdendent, format.; """""". if debug:; print(inspect.stack()[0][3]). config.soft_reset(). # take care of expectation values, if any; if any(e_ops):; config.e_num = len(e_ops); for op in e_ops:; if isinstance(op, list):; op = op[0]; config.e_ops_data.append(op.data.data); config.e_ops_ind.append(op.data.indices); config.e_ops_ptr.append(op.data.indptr); config.e_ops_isherm.append(op.isherm). config.e_ops_data = np.array(config.e_ops_data); config.e_ops_ind = np.array(config.e_ops_ind); config.e_ops_ptr = np.array(config.e_ops_ptr); config.e_ops_isherm = np.array(config.e_ops_isherm). # take care of collapse operators, if any; if any(c_ops):",MatchSource.WIKI,docs/4.2/modules/qutip/mcsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html
https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:29808,Modifiability,config,config,29808,"(collapse_times, dtype=float),; np.array(which_oper, dtype=int)). def _mc_func_load(config):; """"""Load cython functions"""""". global _cy_rhs_func; global _cy_col_spmv_func, _cy_col_expect_func; global _cy_col_spmv_call_func, _cy_col_expect_call_func. if debug:; print(inspect.stack()[0][3] + "" in "" + str(os.getpid())). if config.tflag in [1, 10, 11]:; # compile time-depdendent RHS code; if config.tflag in [1, 11]:; code = compile('from ' + config.tdname +; ' import cy_td_ode_rhs, col_spmv, col_expect',; '<string>', 'exec'); exec(code, globals()); _cy_rhs_func = cy_td_ode_rhs; _cy_col_spmv_func = col_spmv; _cy_col_expect_func = col_expect; else:; code = compile('from ' + config.tdname +; ' import cy_td_ode_rhs', '<string>', 'exec'); exec(code, globals()); _cy_rhs_func = cy_td_ode_rhs. # compile wrapper functions for calling cython spmv and expect; if config.col_spmv_code:; _cy_col_spmv_call_func = compile(; config.col_spmv_code, '<string>', 'exec'). if config.col_expect_code:; _cy_col_expect_call_func = compile(; config.col_expect_code, '<string>', 'exec'). elif config.tflag == 0:; _cy_rhs_func = cy_ode_rhs. def _mc_data_config(H, psi0, h_stuff, c_ops, c_stuff, args, e_ops,; options, config):; """"""Creates the appropriate data structures for the monte carlo solver; based on the given time-dependent, or indepdendent, format.; """""". if debug:; print(inspect.stack()[0][3]). config.soft_reset(). # take care of expectation values, if any; if any(e_ops):; config.e_num = len(e_ops); for op in e_ops:; if isinstance(op, list):; op = op[0]; config.e_ops_data.append(op.data.data); config.e_ops_ind.append(op.data.indices); config.e_ops_ptr.append(op.data.indptr); config.e_ops_isherm.append(op.isherm). config.e_ops_data = np.array(config.e_ops_data); config.e_ops_ind = np.array(config.e_ops_ind); config.e_ops_ptr = np.array(config.e_ops_ptr); config.e_ops_isherm = np.array(config.e_ops_isherm). # take care of collapse operators, if any; if any(c_ops):; config.c_num = len(c_ops); for c_o",MatchSource.WIKI,docs/4.2/modules/qutip/mcsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html
https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:29858,Modifiability,config,config,29858,"func_load(config):; """"""Load cython functions"""""". global _cy_rhs_func; global _cy_col_spmv_func, _cy_col_expect_func; global _cy_col_spmv_call_func, _cy_col_expect_call_func. if debug:; print(inspect.stack()[0][3] + "" in "" + str(os.getpid())). if config.tflag in [1, 10, 11]:; # compile time-depdendent RHS code; if config.tflag in [1, 11]:; code = compile('from ' + config.tdname +; ' import cy_td_ode_rhs, col_spmv, col_expect',; '<string>', 'exec'); exec(code, globals()); _cy_rhs_func = cy_td_ode_rhs; _cy_col_spmv_func = col_spmv; _cy_col_expect_func = col_expect; else:; code = compile('from ' + config.tdname +; ' import cy_td_ode_rhs', '<string>', 'exec'); exec(code, globals()); _cy_rhs_func = cy_td_ode_rhs. # compile wrapper functions for calling cython spmv and expect; if config.col_spmv_code:; _cy_col_spmv_call_func = compile(; config.col_spmv_code, '<string>', 'exec'). if config.col_expect_code:; _cy_col_expect_call_func = compile(; config.col_expect_code, '<string>', 'exec'). elif config.tflag == 0:; _cy_rhs_func = cy_ode_rhs. def _mc_data_config(H, psi0, h_stuff, c_ops, c_stuff, args, e_ops,; options, config):; """"""Creates the appropriate data structures for the monte carlo solver; based on the given time-dependent, or indepdendent, format.; """""". if debug:; print(inspect.stack()[0][3]). config.soft_reset(). # take care of expectation values, if any; if any(e_ops):; config.e_num = len(e_ops); for op in e_ops:; if isinstance(op, list):; op = op[0]; config.e_ops_data.append(op.data.data); config.e_ops_ind.append(op.data.indices); config.e_ops_ptr.append(op.data.indptr); config.e_ops_isherm.append(op.isherm). config.e_ops_data = np.array(config.e_ops_data); config.e_ops_ind = np.array(config.e_ops_ind); config.e_ops_ptr = np.array(config.e_ops_ptr); config.e_ops_isherm = np.array(config.e_ops_isherm). # take care of collapse operators, if any; if any(c_ops):; config.c_num = len(c_ops); for c_op in c_ops:; if isinstance(c_op, list):; c_op = c_op[0]; n_op = c_op.dag() ",MatchSource.WIKI,docs/4.2/modules/qutip/mcsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html
https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:29982,Modifiability,config,config,29982,"_expect_call_func. if debug:; print(inspect.stack()[0][3] + "" in "" + str(os.getpid())). if config.tflag in [1, 10, 11]:; # compile time-depdendent RHS code; if config.tflag in [1, 11]:; code = compile('from ' + config.tdname +; ' import cy_td_ode_rhs, col_spmv, col_expect',; '<string>', 'exec'); exec(code, globals()); _cy_rhs_func = cy_td_ode_rhs; _cy_col_spmv_func = col_spmv; _cy_col_expect_func = col_expect; else:; code = compile('from ' + config.tdname +; ' import cy_td_ode_rhs', '<string>', 'exec'); exec(code, globals()); _cy_rhs_func = cy_td_ode_rhs. # compile wrapper functions for calling cython spmv and expect; if config.col_spmv_code:; _cy_col_spmv_call_func = compile(; config.col_spmv_code, '<string>', 'exec'). if config.col_expect_code:; _cy_col_expect_call_func = compile(; config.col_expect_code, '<string>', 'exec'). elif config.tflag == 0:; _cy_rhs_func = cy_ode_rhs. def _mc_data_config(H, psi0, h_stuff, c_ops, c_stuff, args, e_ops,; options, config):; """"""Creates the appropriate data structures for the monte carlo solver; based on the given time-dependent, or indepdendent, format.; """""". if debug:; print(inspect.stack()[0][3]). config.soft_reset(). # take care of expectation values, if any; if any(e_ops):; config.e_num = len(e_ops); for op in e_ops:; if isinstance(op, list):; op = op[0]; config.e_ops_data.append(op.data.data); config.e_ops_ind.append(op.data.indices); config.e_ops_ptr.append(op.data.indptr); config.e_ops_isherm.append(op.isherm). config.e_ops_data = np.array(config.e_ops_data); config.e_ops_ind = np.array(config.e_ops_ind); config.e_ops_ptr = np.array(config.e_ops_ptr); config.e_ops_isherm = np.array(config.e_ops_isherm). # take care of collapse operators, if any; if any(c_ops):; config.c_num = len(c_ops); for c_op in c_ops:; if isinstance(c_op, list):; c_op = c_op[0]; n_op = c_op.dag() * c_op; config.c_ops_data.append(c_op.data.data); config.c_ops_ind.append(c_op.data.indices); config.c_ops_ptr.append(c_op.data.indptr); # norm ops; confi",MatchSource.WIKI,docs/4.2/modules/qutip/mcsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html
https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:30170,Modifiability,config,config,30170,"config.tflag in [1, 11]:; code = compile('from ' + config.tdname +; ' import cy_td_ode_rhs, col_spmv, col_expect',; '<string>', 'exec'); exec(code, globals()); _cy_rhs_func = cy_td_ode_rhs; _cy_col_spmv_func = col_spmv; _cy_col_expect_func = col_expect; else:; code = compile('from ' + config.tdname +; ' import cy_td_ode_rhs', '<string>', 'exec'); exec(code, globals()); _cy_rhs_func = cy_td_ode_rhs. # compile wrapper functions for calling cython spmv and expect; if config.col_spmv_code:; _cy_col_spmv_call_func = compile(; config.col_spmv_code, '<string>', 'exec'). if config.col_expect_code:; _cy_col_expect_call_func = compile(; config.col_expect_code, '<string>', 'exec'). elif config.tflag == 0:; _cy_rhs_func = cy_ode_rhs. def _mc_data_config(H, psi0, h_stuff, c_ops, c_stuff, args, e_ops,; options, config):; """"""Creates the appropriate data structures for the monte carlo solver; based on the given time-dependent, or indepdendent, format.; """""". if debug:; print(inspect.stack()[0][3]). config.soft_reset(). # take care of expectation values, if any; if any(e_ops):; config.e_num = len(e_ops); for op in e_ops:; if isinstance(op, list):; op = op[0]; config.e_ops_data.append(op.data.data); config.e_ops_ind.append(op.data.indices); config.e_ops_ptr.append(op.data.indptr); config.e_ops_isherm.append(op.isherm). config.e_ops_data = np.array(config.e_ops_data); config.e_ops_ind = np.array(config.e_ops_ind); config.e_ops_ptr = np.array(config.e_ops_ptr); config.e_ops_isherm = np.array(config.e_ops_isherm). # take care of collapse operators, if any; if any(c_ops):; config.c_num = len(c_ops); for c_op in c_ops:; if isinstance(c_op, list):; c_op = c_op[0]; n_op = c_op.dag() * c_op; config.c_ops_data.append(c_op.data.data); config.c_ops_ind.append(c_op.data.indices); config.c_ops_ptr.append(c_op.data.indptr); # norm ops; config.n_ops_data.append(n_op.data.data); config.n_ops_ind.append(n_op.data.indices); config.n_ops_ptr.append(n_op.data.indptr); # to array; config.c_ops_data = np.a",MatchSource.WIKI,docs/4.2/modules/qutip/mcsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html
https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:30250,Modifiability,config,config,30250," config.tdname +; ' import cy_td_ode_rhs, col_spmv, col_expect',; '<string>', 'exec'); exec(code, globals()); _cy_rhs_func = cy_td_ode_rhs; _cy_col_spmv_func = col_spmv; _cy_col_expect_func = col_expect; else:; code = compile('from ' + config.tdname +; ' import cy_td_ode_rhs', '<string>', 'exec'); exec(code, globals()); _cy_rhs_func = cy_td_ode_rhs. # compile wrapper functions for calling cython spmv and expect; if config.col_spmv_code:; _cy_col_spmv_call_func = compile(; config.col_spmv_code, '<string>', 'exec'). if config.col_expect_code:; _cy_col_expect_call_func = compile(; config.col_expect_code, '<string>', 'exec'). elif config.tflag == 0:; _cy_rhs_func = cy_ode_rhs. def _mc_data_config(H, psi0, h_stuff, c_ops, c_stuff, args, e_ops,; options, config):; """"""Creates the appropriate data structures for the monte carlo solver; based on the given time-dependent, or indepdendent, format.; """""". if debug:; print(inspect.stack()[0][3]). config.soft_reset(). # take care of expectation values, if any; if any(e_ops):; config.e_num = len(e_ops); for op in e_ops:; if isinstance(op, list):; op = op[0]; config.e_ops_data.append(op.data.data); config.e_ops_ind.append(op.data.indices); config.e_ops_ptr.append(op.data.indptr); config.e_ops_isherm.append(op.isherm). config.e_ops_data = np.array(config.e_ops_data); config.e_ops_ind = np.array(config.e_ops_ind); config.e_ops_ptr = np.array(config.e_ops_ptr); config.e_ops_isherm = np.array(config.e_ops_isherm). # take care of collapse operators, if any; if any(c_ops):; config.c_num = len(c_ops); for c_op in c_ops:; if isinstance(c_op, list):; c_op = c_op[0]; n_op = c_op.dag() * c_op; config.c_ops_data.append(c_op.data.data); config.c_ops_ind.append(c_op.data.indices); config.c_ops_ptr.append(c_op.data.indptr); # norm ops; config.n_ops_data.append(n_op.data.data); config.n_ops_ind.append(n_op.data.indices); config.n_ops_ptr.append(n_op.data.indptr); # to array; config.c_ops_data = np.array(config.c_ops_data); config.c_ops_ind = np.arra",MatchSource.WIKI,docs/4.2/modules/qutip/mcsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html
https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:30333,Modifiability,config,config,30333,"', 'exec'); exec(code, globals()); _cy_rhs_func = cy_td_ode_rhs; _cy_col_spmv_func = col_spmv; _cy_col_expect_func = col_expect; else:; code = compile('from ' + config.tdname +; ' import cy_td_ode_rhs', '<string>', 'exec'); exec(code, globals()); _cy_rhs_func = cy_td_ode_rhs. # compile wrapper functions for calling cython spmv and expect; if config.col_spmv_code:; _cy_col_spmv_call_func = compile(; config.col_spmv_code, '<string>', 'exec'). if config.col_expect_code:; _cy_col_expect_call_func = compile(; config.col_expect_code, '<string>', 'exec'). elif config.tflag == 0:; _cy_rhs_func = cy_ode_rhs. def _mc_data_config(H, psi0, h_stuff, c_ops, c_stuff, args, e_ops,; options, config):; """"""Creates the appropriate data structures for the monte carlo solver; based on the given time-dependent, or indepdendent, format.; """""". if debug:; print(inspect.stack()[0][3]). config.soft_reset(). # take care of expectation values, if any; if any(e_ops):; config.e_num = len(e_ops); for op in e_ops:; if isinstance(op, list):; op = op[0]; config.e_ops_data.append(op.data.data); config.e_ops_ind.append(op.data.indices); config.e_ops_ptr.append(op.data.indptr); config.e_ops_isherm.append(op.isherm). config.e_ops_data = np.array(config.e_ops_data); config.e_ops_ind = np.array(config.e_ops_ind); config.e_ops_ptr = np.array(config.e_ops_ptr); config.e_ops_isherm = np.array(config.e_ops_isherm). # take care of collapse operators, if any; if any(c_ops):; config.c_num = len(c_ops); for c_op in c_ops:; if isinstance(c_op, list):; c_op = c_op[0]; n_op = c_op.dag() * c_op; config.c_ops_data.append(c_op.data.data); config.c_ops_ind.append(c_op.data.indices); config.c_ops_ptr.append(c_op.data.indptr); # norm ops; config.n_ops_data.append(n_op.data.data); config.n_ops_ind.append(n_op.data.indices); config.n_ops_ptr.append(n_op.data.indptr); # to array; config.c_ops_data = np.array(config.c_ops_data); config.c_ops_ind = np.array(config.c_ops_ind); config.c_ops_ptr = np.array(config.c_ops_ptr). config.",MatchSource.WIKI,docs/4.2/modules/qutip/mcsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html
https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:30373,Modifiability,config,config,30373,"mv_func = col_spmv; _cy_col_expect_func = col_expect; else:; code = compile('from ' + config.tdname +; ' import cy_td_ode_rhs', '<string>', 'exec'); exec(code, globals()); _cy_rhs_func = cy_td_ode_rhs. # compile wrapper functions for calling cython spmv and expect; if config.col_spmv_code:; _cy_col_spmv_call_func = compile(; config.col_spmv_code, '<string>', 'exec'). if config.col_expect_code:; _cy_col_expect_call_func = compile(; config.col_expect_code, '<string>', 'exec'). elif config.tflag == 0:; _cy_rhs_func = cy_ode_rhs. def _mc_data_config(H, psi0, h_stuff, c_ops, c_stuff, args, e_ops,; options, config):; """"""Creates the appropriate data structures for the monte carlo solver; based on the given time-dependent, or indepdendent, format.; """""". if debug:; print(inspect.stack()[0][3]). config.soft_reset(). # take care of expectation values, if any; if any(e_ops):; config.e_num = len(e_ops); for op in e_ops:; if isinstance(op, list):; op = op[0]; config.e_ops_data.append(op.data.data); config.e_ops_ind.append(op.data.indices); config.e_ops_ptr.append(op.data.indptr); config.e_ops_isherm.append(op.isherm). config.e_ops_data = np.array(config.e_ops_data); config.e_ops_ind = np.array(config.e_ops_ind); config.e_ops_ptr = np.array(config.e_ops_ptr); config.e_ops_isherm = np.array(config.e_ops_isherm). # take care of collapse operators, if any; if any(c_ops):; config.c_num = len(c_ops); for c_op in c_ops:; if isinstance(c_op, list):; c_op = c_op[0]; n_op = c_op.dag() * c_op; config.c_ops_data.append(c_op.data.data); config.c_ops_ind.append(c_op.data.indices); config.c_ops_ptr.append(c_op.data.indptr); # norm ops; config.n_ops_data.append(n_op.data.data); config.n_ops_ind.append(n_op.data.indices); config.n_ops_ptr.append(n_op.data.indptr); # to array; config.c_ops_data = np.array(config.c_ops_data); config.c_ops_ind = np.array(config.c_ops_ind); config.c_ops_ptr = np.array(config.c_ops_ptr). config.n_ops_data = np.array(config.n_ops_data); config.n_ops_ind = np.array(conf",MatchSource.WIKI,docs/4.2/modules/qutip/mcsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html
https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:30415,Modifiability,config,config,30415,"= col_expect; else:; code = compile('from ' + config.tdname +; ' import cy_td_ode_rhs', '<string>', 'exec'); exec(code, globals()); _cy_rhs_func = cy_td_ode_rhs. # compile wrapper functions for calling cython spmv and expect; if config.col_spmv_code:; _cy_col_spmv_call_func = compile(; config.col_spmv_code, '<string>', 'exec'). if config.col_expect_code:; _cy_col_expect_call_func = compile(; config.col_expect_code, '<string>', 'exec'). elif config.tflag == 0:; _cy_rhs_func = cy_ode_rhs. def _mc_data_config(H, psi0, h_stuff, c_ops, c_stuff, args, e_ops,; options, config):; """"""Creates the appropriate data structures for the monte carlo solver; based on the given time-dependent, or indepdendent, format.; """""". if debug:; print(inspect.stack()[0][3]). config.soft_reset(). # take care of expectation values, if any; if any(e_ops):; config.e_num = len(e_ops); for op in e_ops:; if isinstance(op, list):; op = op[0]; config.e_ops_data.append(op.data.data); config.e_ops_ind.append(op.data.indices); config.e_ops_ptr.append(op.data.indptr); config.e_ops_isherm.append(op.isherm). config.e_ops_data = np.array(config.e_ops_data); config.e_ops_ind = np.array(config.e_ops_ind); config.e_ops_ptr = np.array(config.e_ops_ptr); config.e_ops_isherm = np.array(config.e_ops_isherm). # take care of collapse operators, if any; if any(c_ops):; config.c_num = len(c_ops); for c_op in c_ops:; if isinstance(c_op, list):; c_op = c_op[0]; n_op = c_op.dag() * c_op; config.c_ops_data.append(c_op.data.data); config.c_ops_ind.append(c_op.data.indices); config.c_ops_ptr.append(c_op.data.indptr); # norm ops; config.n_ops_data.append(n_op.data.data); config.n_ops_ind.append(n_op.data.indices); config.n_ops_ptr.append(n_op.data.indptr); # to array; config.c_ops_data = np.array(config.c_ops_data); config.c_ops_ind = np.array(config.c_ops_ind); config.c_ops_ptr = np.array(config.c_ops_ptr). config.n_ops_data = np.array(config.n_ops_data); config.n_ops_ind = np.array(config.n_ops_ind); config.n_ops_ptr = np.arra",MatchSource.WIKI,docs/4.2/modules/qutip/mcsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html
https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:30456,Modifiability,config,config,30456,"' + config.tdname +; ' import cy_td_ode_rhs', '<string>', 'exec'); exec(code, globals()); _cy_rhs_func = cy_td_ode_rhs. # compile wrapper functions for calling cython spmv and expect; if config.col_spmv_code:; _cy_col_spmv_call_func = compile(; config.col_spmv_code, '<string>', 'exec'). if config.col_expect_code:; _cy_col_expect_call_func = compile(; config.col_expect_code, '<string>', 'exec'). elif config.tflag == 0:; _cy_rhs_func = cy_ode_rhs. def _mc_data_config(H, psi0, h_stuff, c_ops, c_stuff, args, e_ops,; options, config):; """"""Creates the appropriate data structures for the monte carlo solver; based on the given time-dependent, or indepdendent, format.; """""". if debug:; print(inspect.stack()[0][3]). config.soft_reset(). # take care of expectation values, if any; if any(e_ops):; config.e_num = len(e_ops); for op in e_ops:; if isinstance(op, list):; op = op[0]; config.e_ops_data.append(op.data.data); config.e_ops_ind.append(op.data.indices); config.e_ops_ptr.append(op.data.indptr); config.e_ops_isherm.append(op.isherm). config.e_ops_data = np.array(config.e_ops_data); config.e_ops_ind = np.array(config.e_ops_ind); config.e_ops_ptr = np.array(config.e_ops_ptr); config.e_ops_isherm = np.array(config.e_ops_isherm). # take care of collapse operators, if any; if any(c_ops):; config.c_num = len(c_ops); for c_op in c_ops:; if isinstance(c_op, list):; c_op = c_op[0]; n_op = c_op.dag() * c_op; config.c_ops_data.append(c_op.data.data); config.c_ops_ind.append(c_op.data.indices); config.c_ops_ptr.append(c_op.data.indptr); # norm ops; config.n_ops_data.append(n_op.data.data); config.n_ops_ind.append(n_op.data.indices); config.n_ops_ptr.append(n_op.data.indptr); # to array; config.c_ops_data = np.array(config.c_ops_data); config.c_ops_ind = np.array(config.c_ops_ind); config.c_ops_ptr = np.array(config.c_ops_ptr). config.n_ops_data = np.array(config.n_ops_data); config.n_ops_ind = np.array(config.n_ops_ind); config.n_ops_ptr = np.array(config.n_ops_ptr). if config.tflag == 0",MatchSource.WIKI,docs/4.2/modules/qutip/mcsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html
https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:30495,Modifiability,config,config,30495,"', '<string>', 'exec'); exec(code, globals()); _cy_rhs_func = cy_td_ode_rhs. # compile wrapper functions for calling cython spmv and expect; if config.col_spmv_code:; _cy_col_spmv_call_func = compile(; config.col_spmv_code, '<string>', 'exec'). if config.col_expect_code:; _cy_col_expect_call_func = compile(; config.col_expect_code, '<string>', 'exec'). elif config.tflag == 0:; _cy_rhs_func = cy_ode_rhs. def _mc_data_config(H, psi0, h_stuff, c_ops, c_stuff, args, e_ops,; options, config):; """"""Creates the appropriate data structures for the monte carlo solver; based on the given time-dependent, or indepdendent, format.; """""". if debug:; print(inspect.stack()[0][3]). config.soft_reset(). # take care of expectation values, if any; if any(e_ops):; config.e_num = len(e_ops); for op in e_ops:; if isinstance(op, list):; op = op[0]; config.e_ops_data.append(op.data.data); config.e_ops_ind.append(op.data.indices); config.e_ops_ptr.append(op.data.indptr); config.e_ops_isherm.append(op.isherm). config.e_ops_data = np.array(config.e_ops_data); config.e_ops_ind = np.array(config.e_ops_ind); config.e_ops_ptr = np.array(config.e_ops_ptr); config.e_ops_isherm = np.array(config.e_ops_isherm). # take care of collapse operators, if any; if any(c_ops):; config.c_num = len(c_ops); for c_op in c_ops:; if isinstance(c_op, list):; c_op = c_op[0]; n_op = c_op.dag() * c_op; config.c_ops_data.append(c_op.data.data); config.c_ops_ind.append(c_op.data.indices); config.c_ops_ptr.append(c_op.data.indptr); # norm ops; config.n_ops_data.append(n_op.data.data); config.n_ops_ind.append(n_op.data.indices); config.n_ops_ptr.append(n_op.data.indptr); # to array; config.c_ops_data = np.array(config.c_ops_data); config.c_ops_ind = np.array(config.c_ops_ind); config.c_ops_ptr = np.array(config.c_ops_ptr). config.n_ops_data = np.array(config.n_ops_data); config.n_ops_ind = np.array(config.n_ops_ind); config.n_ops_ptr = np.array(config.n_ops_ptr). if config.tflag == 0:; # CONSTANT H & C_OPS CODE; # -----------",MatchSource.WIKI,docs/4.2/modules/qutip/mcsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html
https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:30524,Modifiability,config,config,30524,"ec(code, globals()); _cy_rhs_func = cy_td_ode_rhs. # compile wrapper functions for calling cython spmv and expect; if config.col_spmv_code:; _cy_col_spmv_call_func = compile(; config.col_spmv_code, '<string>', 'exec'). if config.col_expect_code:; _cy_col_expect_call_func = compile(; config.col_expect_code, '<string>', 'exec'). elif config.tflag == 0:; _cy_rhs_func = cy_ode_rhs. def _mc_data_config(H, psi0, h_stuff, c_ops, c_stuff, args, e_ops,; options, config):; """"""Creates the appropriate data structures for the monte carlo solver; based on the given time-dependent, or indepdendent, format.; """""". if debug:; print(inspect.stack()[0][3]). config.soft_reset(). # take care of expectation values, if any; if any(e_ops):; config.e_num = len(e_ops); for op in e_ops:; if isinstance(op, list):; op = op[0]; config.e_ops_data.append(op.data.data); config.e_ops_ind.append(op.data.indices); config.e_ops_ptr.append(op.data.indptr); config.e_ops_isherm.append(op.isherm). config.e_ops_data = np.array(config.e_ops_data); config.e_ops_ind = np.array(config.e_ops_ind); config.e_ops_ptr = np.array(config.e_ops_ptr); config.e_ops_isherm = np.array(config.e_ops_isherm). # take care of collapse operators, if any; if any(c_ops):; config.c_num = len(c_ops); for c_op in c_ops:; if isinstance(c_op, list):; c_op = c_op[0]; n_op = c_op.dag() * c_op; config.c_ops_data.append(c_op.data.data); config.c_ops_ind.append(c_op.data.indices); config.c_ops_ptr.append(c_op.data.indptr); # norm ops; config.n_ops_data.append(n_op.data.data); config.n_ops_ind.append(n_op.data.indices); config.n_ops_ptr.append(n_op.data.indptr); # to array; config.c_ops_data = np.array(config.c_ops_data); config.c_ops_ind = np.array(config.c_ops_ind); config.c_ops_ptr = np.array(config.c_ops_ptr). config.n_ops_data = np.array(config.n_ops_data); config.n_ops_ind = np.array(config.n_ops_ind); config.n_ops_ptr = np.array(config.n_ops_ptr). if config.tflag == 0:; # CONSTANT H & C_OPS CODE; # -----------------------; if config.cfl",MatchSource.WIKI,docs/4.2/modules/qutip/mcsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html
https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:30544,Modifiability,config,config,30544,")); _cy_rhs_func = cy_td_ode_rhs. # compile wrapper functions for calling cython spmv and expect; if config.col_spmv_code:; _cy_col_spmv_call_func = compile(; config.col_spmv_code, '<string>', 'exec'). if config.col_expect_code:; _cy_col_expect_call_func = compile(; config.col_expect_code, '<string>', 'exec'). elif config.tflag == 0:; _cy_rhs_func = cy_ode_rhs. def _mc_data_config(H, psi0, h_stuff, c_ops, c_stuff, args, e_ops,; options, config):; """"""Creates the appropriate data structures for the monte carlo solver; based on the given time-dependent, or indepdendent, format.; """""". if debug:; print(inspect.stack()[0][3]). config.soft_reset(). # take care of expectation values, if any; if any(e_ops):; config.e_num = len(e_ops); for op in e_ops:; if isinstance(op, list):; op = op[0]; config.e_ops_data.append(op.data.data); config.e_ops_ind.append(op.data.indices); config.e_ops_ptr.append(op.data.indptr); config.e_ops_isherm.append(op.isherm). config.e_ops_data = np.array(config.e_ops_data); config.e_ops_ind = np.array(config.e_ops_ind); config.e_ops_ptr = np.array(config.e_ops_ptr); config.e_ops_isherm = np.array(config.e_ops_isherm). # take care of collapse operators, if any; if any(c_ops):; config.c_num = len(c_ops); for c_op in c_ops:; if isinstance(c_op, list):; c_op = c_op[0]; n_op = c_op.dag() * c_op; config.c_ops_data.append(c_op.data.data); config.c_ops_ind.append(c_op.data.indices); config.c_ops_ptr.append(c_op.data.indptr); # norm ops; config.n_ops_data.append(n_op.data.data); config.n_ops_ind.append(n_op.data.indices); config.n_ops_ptr.append(n_op.data.indptr); # to array; config.c_ops_data = np.array(config.c_ops_data); config.c_ops_ind = np.array(config.c_ops_ind); config.c_ops_ptr = np.array(config.c_ops_ptr). config.n_ops_data = np.array(config.n_ops_data); config.n_ops_ind = np.array(config.n_ops_ind); config.n_ops_ptr = np.array(config.n_ops_ptr). if config.tflag == 0:; # CONSTANT H & C_OPS CODE; # -----------------------; if config.cflag:; config.c_co",MatchSource.WIKI,docs/4.2/modules/qutip/mcsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html
https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:30572,Modifiability,config,config,30572,"s. # compile wrapper functions for calling cython spmv and expect; if config.col_spmv_code:; _cy_col_spmv_call_func = compile(; config.col_spmv_code, '<string>', 'exec'). if config.col_expect_code:; _cy_col_expect_call_func = compile(; config.col_expect_code, '<string>', 'exec'). elif config.tflag == 0:; _cy_rhs_func = cy_ode_rhs. def _mc_data_config(H, psi0, h_stuff, c_ops, c_stuff, args, e_ops,; options, config):; """"""Creates the appropriate data structures for the monte carlo solver; based on the given time-dependent, or indepdendent, format.; """""". if debug:; print(inspect.stack()[0][3]). config.soft_reset(). # take care of expectation values, if any; if any(e_ops):; config.e_num = len(e_ops); for op in e_ops:; if isinstance(op, list):; op = op[0]; config.e_ops_data.append(op.data.data); config.e_ops_ind.append(op.data.indices); config.e_ops_ptr.append(op.data.indptr); config.e_ops_isherm.append(op.isherm). config.e_ops_data = np.array(config.e_ops_data); config.e_ops_ind = np.array(config.e_ops_ind); config.e_ops_ptr = np.array(config.e_ops_ptr); config.e_ops_isherm = np.array(config.e_ops_isherm). # take care of collapse operators, if any; if any(c_ops):; config.c_num = len(c_ops); for c_op in c_ops:; if isinstance(c_op, list):; c_op = c_op[0]; n_op = c_op.dag() * c_op; config.c_ops_data.append(c_op.data.data); config.c_ops_ind.append(c_op.data.indices); config.c_ops_ptr.append(c_op.data.indptr); # norm ops; config.n_ops_data.append(n_op.data.data); config.n_ops_ind.append(n_op.data.indices); config.n_ops_ptr.append(n_op.data.indptr); # to array; config.c_ops_data = np.array(config.c_ops_data); config.c_ops_ind = np.array(config.c_ops_ind); config.c_ops_ptr = np.array(config.c_ops_ptr). config.n_ops_data = np.array(config.n_ops_data); config.n_ops_ind = np.array(config.n_ops_ind); config.n_ops_ptr = np.array(config.n_ops_ptr). if config.tflag == 0:; # CONSTANT H & C_OPS CODE; # -----------------------; if config.cflag:; config.c_const_inds = np.arange(len(c_ops))",MatchSource.WIKI,docs/4.2/modules/qutip/mcsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html
https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:30591,Modifiability,config,config,30591,"pper functions for calling cython spmv and expect; if config.col_spmv_code:; _cy_col_spmv_call_func = compile(; config.col_spmv_code, '<string>', 'exec'). if config.col_expect_code:; _cy_col_expect_call_func = compile(; config.col_expect_code, '<string>', 'exec'). elif config.tflag == 0:; _cy_rhs_func = cy_ode_rhs. def _mc_data_config(H, psi0, h_stuff, c_ops, c_stuff, args, e_ops,; options, config):; """"""Creates the appropriate data structures for the monte carlo solver; based on the given time-dependent, or indepdendent, format.; """""". if debug:; print(inspect.stack()[0][3]). config.soft_reset(). # take care of expectation values, if any; if any(e_ops):; config.e_num = len(e_ops); for op in e_ops:; if isinstance(op, list):; op = op[0]; config.e_ops_data.append(op.data.data); config.e_ops_ind.append(op.data.indices); config.e_ops_ptr.append(op.data.indptr); config.e_ops_isherm.append(op.isherm). config.e_ops_data = np.array(config.e_ops_data); config.e_ops_ind = np.array(config.e_ops_ind); config.e_ops_ptr = np.array(config.e_ops_ptr); config.e_ops_isherm = np.array(config.e_ops_isherm). # take care of collapse operators, if any; if any(c_ops):; config.c_num = len(c_ops); for c_op in c_ops:; if isinstance(c_op, list):; c_op = c_op[0]; n_op = c_op.dag() * c_op; config.c_ops_data.append(c_op.data.data); config.c_ops_ind.append(c_op.data.indices); config.c_ops_ptr.append(c_op.data.indptr); # norm ops; config.n_ops_data.append(n_op.data.data); config.n_ops_ind.append(n_op.data.indices); config.n_ops_ptr.append(n_op.data.indptr); # to array; config.c_ops_data = np.array(config.c_ops_data); config.c_ops_ind = np.array(config.c_ops_ind); config.c_ops_ptr = np.array(config.c_ops_ptr). config.n_ops_data = np.array(config.n_ops_data); config.n_ops_ind = np.array(config.n_ops_ind); config.n_ops_ptr = np.array(config.n_ops_ptr). if config.tflag == 0:; # CONSTANT H & C_OPS CODE; # -----------------------; if config.cflag:; config.c_const_inds = np.arange(len(c_ops)); # combine Hami",MatchSource.WIKI,docs/4.2/modules/qutip/mcsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html
https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:30619,Modifiability,config,config,30619,"on spmv and expect; if config.col_spmv_code:; _cy_col_spmv_call_func = compile(; config.col_spmv_code, '<string>', 'exec'). if config.col_expect_code:; _cy_col_expect_call_func = compile(; config.col_expect_code, '<string>', 'exec'). elif config.tflag == 0:; _cy_rhs_func = cy_ode_rhs. def _mc_data_config(H, psi0, h_stuff, c_ops, c_stuff, args, e_ops,; options, config):; """"""Creates the appropriate data structures for the monte carlo solver; based on the given time-dependent, or indepdendent, format.; """""". if debug:; print(inspect.stack()[0][3]). config.soft_reset(). # take care of expectation values, if any; if any(e_ops):; config.e_num = len(e_ops); for op in e_ops:; if isinstance(op, list):; op = op[0]; config.e_ops_data.append(op.data.data); config.e_ops_ind.append(op.data.indices); config.e_ops_ptr.append(op.data.indptr); config.e_ops_isherm.append(op.isherm). config.e_ops_data = np.array(config.e_ops_data); config.e_ops_ind = np.array(config.e_ops_ind); config.e_ops_ptr = np.array(config.e_ops_ptr); config.e_ops_isherm = np.array(config.e_ops_isherm). # take care of collapse operators, if any; if any(c_ops):; config.c_num = len(c_ops); for c_op in c_ops:; if isinstance(c_op, list):; c_op = c_op[0]; n_op = c_op.dag() * c_op; config.c_ops_data.append(c_op.data.data); config.c_ops_ind.append(c_op.data.indices); config.c_ops_ptr.append(c_op.data.indptr); # norm ops; config.n_ops_data.append(n_op.data.data); config.n_ops_ind.append(n_op.data.indices); config.n_ops_ptr.append(n_op.data.indptr); # to array; config.c_ops_data = np.array(config.c_ops_data); config.c_ops_ind = np.array(config.c_ops_ind); config.c_ops_ptr = np.array(config.c_ops_ptr). config.n_ops_data = np.array(config.n_ops_data); config.n_ops_ind = np.array(config.n_ops_ind); config.n_ops_ptr = np.array(config.n_ops_ptr). if config.tflag == 0:; # CONSTANT H & C_OPS CODE; # -----------------------; if config.cflag:; config.c_const_inds = np.arange(len(c_ops)); # combine Hamiltonian and constant collapse t",MatchSource.WIKI,docs/4.2/modules/qutip/mcsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html
https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:30638,Modifiability,config,config,30638,"ct; if config.col_spmv_code:; _cy_col_spmv_call_func = compile(; config.col_spmv_code, '<string>', 'exec'). if config.col_expect_code:; _cy_col_expect_call_func = compile(; config.col_expect_code, '<string>', 'exec'). elif config.tflag == 0:; _cy_rhs_func = cy_ode_rhs. def _mc_data_config(H, psi0, h_stuff, c_ops, c_stuff, args, e_ops,; options, config):; """"""Creates the appropriate data structures for the monte carlo solver; based on the given time-dependent, or indepdendent, format.; """""". if debug:; print(inspect.stack()[0][3]). config.soft_reset(). # take care of expectation values, if any; if any(e_ops):; config.e_num = len(e_ops); for op in e_ops:; if isinstance(op, list):; op = op[0]; config.e_ops_data.append(op.data.data); config.e_ops_ind.append(op.data.indices); config.e_ops_ptr.append(op.data.indptr); config.e_ops_isherm.append(op.isherm). config.e_ops_data = np.array(config.e_ops_data); config.e_ops_ind = np.array(config.e_ops_ind); config.e_ops_ptr = np.array(config.e_ops_ptr); config.e_ops_isherm = np.array(config.e_ops_isherm). # take care of collapse operators, if any; if any(c_ops):; config.c_num = len(c_ops); for c_op in c_ops:; if isinstance(c_op, list):; c_op = c_op[0]; n_op = c_op.dag() * c_op; config.c_ops_data.append(c_op.data.data); config.c_ops_ind.append(c_op.data.indices); config.c_ops_ptr.append(c_op.data.indptr); # norm ops; config.n_ops_data.append(n_op.data.data); config.n_ops_ind.append(n_op.data.indices); config.n_ops_ptr.append(n_op.data.indptr); # to array; config.c_ops_data = np.array(config.c_ops_data); config.c_ops_ind = np.array(config.c_ops_ind); config.c_ops_ptr = np.array(config.c_ops_ptr). config.n_ops_data = np.array(config.n_ops_data); config.n_ops_ind = np.array(config.n_ops_ind); config.n_ops_ptr = np.array(config.n_ops_ptr). if config.tflag == 0:; # CONSTANT H & C_OPS CODE; # -----------------------; if config.cflag:; config.c_const_inds = np.arange(len(c_ops)); # combine Hamiltonian and constant collapse terms into one; f",MatchSource.WIKI,docs/4.2/modules/qutip/mcsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html
https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:30669,Modifiability,config,config,30669,"col_spmv_call_func = compile(; config.col_spmv_code, '<string>', 'exec'). if config.col_expect_code:; _cy_col_expect_call_func = compile(; config.col_expect_code, '<string>', 'exec'). elif config.tflag == 0:; _cy_rhs_func = cy_ode_rhs. def _mc_data_config(H, psi0, h_stuff, c_ops, c_stuff, args, e_ops,; options, config):; """"""Creates the appropriate data structures for the monte carlo solver; based on the given time-dependent, or indepdendent, format.; """""". if debug:; print(inspect.stack()[0][3]). config.soft_reset(). # take care of expectation values, if any; if any(e_ops):; config.e_num = len(e_ops); for op in e_ops:; if isinstance(op, list):; op = op[0]; config.e_ops_data.append(op.data.data); config.e_ops_ind.append(op.data.indices); config.e_ops_ptr.append(op.data.indptr); config.e_ops_isherm.append(op.isherm). config.e_ops_data = np.array(config.e_ops_data); config.e_ops_ind = np.array(config.e_ops_ind); config.e_ops_ptr = np.array(config.e_ops_ptr); config.e_ops_isherm = np.array(config.e_ops_isherm). # take care of collapse operators, if any; if any(c_ops):; config.c_num = len(c_ops); for c_op in c_ops:; if isinstance(c_op, list):; c_op = c_op[0]; n_op = c_op.dag() * c_op; config.c_ops_data.append(c_op.data.data); config.c_ops_ind.append(c_op.data.indices); config.c_ops_ptr.append(c_op.data.indptr); # norm ops; config.n_ops_data.append(n_op.data.data); config.n_ops_ind.append(n_op.data.indices); config.n_ops_ptr.append(n_op.data.indptr); # to array; config.c_ops_data = np.array(config.c_ops_data); config.c_ops_ind = np.array(config.c_ops_ind); config.c_ops_ptr = np.array(config.c_ops_ptr). config.n_ops_data = np.array(config.n_ops_data); config.n_ops_ind = np.array(config.n_ops_ind); config.n_ops_ptr = np.array(config.n_ops_ptr). if config.tflag == 0:; # CONSTANT H & C_OPS CODE; # -----------------------; if config.cflag:; config.c_const_inds = np.arange(len(c_ops)); # combine Hamiltonian and constant collapse terms into one; for c_op in c_ops:; n_op = c_op.dag",MatchSource.WIKI,docs/4.2/modules/qutip/mcsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html
https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:30750,Modifiability,config,config,30750,"<string>', 'exec'). if config.col_expect_code:; _cy_col_expect_call_func = compile(; config.col_expect_code, '<string>', 'exec'). elif config.tflag == 0:; _cy_rhs_func = cy_ode_rhs. def _mc_data_config(H, psi0, h_stuff, c_ops, c_stuff, args, e_ops,; options, config):; """"""Creates the appropriate data structures for the monte carlo solver; based on the given time-dependent, or indepdendent, format.; """""". if debug:; print(inspect.stack()[0][3]). config.soft_reset(). # take care of expectation values, if any; if any(e_ops):; config.e_num = len(e_ops); for op in e_ops:; if isinstance(op, list):; op = op[0]; config.e_ops_data.append(op.data.data); config.e_ops_ind.append(op.data.indices); config.e_ops_ptr.append(op.data.indptr); config.e_ops_isherm.append(op.isherm). config.e_ops_data = np.array(config.e_ops_data); config.e_ops_ind = np.array(config.e_ops_ind); config.e_ops_ptr = np.array(config.e_ops_ptr); config.e_ops_isherm = np.array(config.e_ops_isherm). # take care of collapse operators, if any; if any(c_ops):; config.c_num = len(c_ops); for c_op in c_ops:; if isinstance(c_op, list):; c_op = c_op[0]; n_op = c_op.dag() * c_op; config.c_ops_data.append(c_op.data.data); config.c_ops_ind.append(c_op.data.indices); config.c_ops_ptr.append(c_op.data.indptr); # norm ops; config.n_ops_data.append(n_op.data.data); config.n_ops_ind.append(n_op.data.indices); config.n_ops_ptr.append(n_op.data.indptr); # to array; config.c_ops_data = np.array(config.c_ops_data); config.c_ops_ind = np.array(config.c_ops_ind); config.c_ops_ptr = np.array(config.c_ops_ptr). config.n_ops_data = np.array(config.n_ops_data); config.n_ops_ind = np.array(config.n_ops_ind); config.n_ops_ptr = np.array(config.n_ops_ptr). if config.tflag == 0:; # CONSTANT H & C_OPS CODE; # -----------------------; if config.cflag:; config.c_const_inds = np.arange(len(c_ops)); # combine Hamiltonian and constant collapse terms into one; for c_op in c_ops:; n_op = c_op.dag() * c_op; H -= 0.5j * \; n_op ; # construct Hamiltoni",MatchSource.WIKI,docs/4.2/modules/qutip/mcsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html
https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:30867,Modifiability,config,config,30867,"g.tflag == 0:; _cy_rhs_func = cy_ode_rhs. def _mc_data_config(H, psi0, h_stuff, c_ops, c_stuff, args, e_ops,; options, config):; """"""Creates the appropriate data structures for the monte carlo solver; based on the given time-dependent, or indepdendent, format.; """""". if debug:; print(inspect.stack()[0][3]). config.soft_reset(). # take care of expectation values, if any; if any(e_ops):; config.e_num = len(e_ops); for op in e_ops:; if isinstance(op, list):; op = op[0]; config.e_ops_data.append(op.data.data); config.e_ops_ind.append(op.data.indices); config.e_ops_ptr.append(op.data.indptr); config.e_ops_isherm.append(op.isherm). config.e_ops_data = np.array(config.e_ops_data); config.e_ops_ind = np.array(config.e_ops_ind); config.e_ops_ptr = np.array(config.e_ops_ptr); config.e_ops_isherm = np.array(config.e_ops_isherm). # take care of collapse operators, if any; if any(c_ops):; config.c_num = len(c_ops); for c_op in c_ops:; if isinstance(c_op, list):; c_op = c_op[0]; n_op = c_op.dag() * c_op; config.c_ops_data.append(c_op.data.data); config.c_ops_ind.append(c_op.data.indices); config.c_ops_ptr.append(c_op.data.indptr); # norm ops; config.n_ops_data.append(n_op.data.data); config.n_ops_ind.append(n_op.data.indices); config.n_ops_ptr.append(n_op.data.indptr); # to array; config.c_ops_data = np.array(config.c_ops_data); config.c_ops_ind = np.array(config.c_ops_ind); config.c_ops_ptr = np.array(config.c_ops_ptr). config.n_ops_data = np.array(config.n_ops_data); config.n_ops_ind = np.array(config.n_ops_ind); config.n_ops_ptr = np.array(config.n_ops_ptr). if config.tflag == 0:; # CONSTANT H & C_OPS CODE; # -----------------------; if config.cflag:; config.c_const_inds = np.arange(len(c_ops)); # combine Hamiltonian and constant collapse terms into one; for c_op in c_ops:; n_op = c_op.dag() * c_op; H -= 0.5j * \; n_op ; # construct Hamiltonian data structures; if options.tidy:; H = H.tidyup(options.atol); config.h_data = -1.0j * H.data.data; config.h_ind = H.data.indices; config",MatchSource.WIKI,docs/4.2/modules/qutip/mcsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html
https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:30909,Modifiability,config,config,30909,"_mc_data_config(H, psi0, h_stuff, c_ops, c_stuff, args, e_ops,; options, config):; """"""Creates the appropriate data structures for the monte carlo solver; based on the given time-dependent, or indepdendent, format.; """""". if debug:; print(inspect.stack()[0][3]). config.soft_reset(). # take care of expectation values, if any; if any(e_ops):; config.e_num = len(e_ops); for op in e_ops:; if isinstance(op, list):; op = op[0]; config.e_ops_data.append(op.data.data); config.e_ops_ind.append(op.data.indices); config.e_ops_ptr.append(op.data.indptr); config.e_ops_isherm.append(op.isherm). config.e_ops_data = np.array(config.e_ops_data); config.e_ops_ind = np.array(config.e_ops_ind); config.e_ops_ptr = np.array(config.e_ops_ptr); config.e_ops_isherm = np.array(config.e_ops_isherm). # take care of collapse operators, if any; if any(c_ops):; config.c_num = len(c_ops); for c_op in c_ops:; if isinstance(c_op, list):; c_op = c_op[0]; n_op = c_op.dag() * c_op; config.c_ops_data.append(c_op.data.data); config.c_ops_ind.append(c_op.data.indices); config.c_ops_ptr.append(c_op.data.indptr); # norm ops; config.n_ops_data.append(n_op.data.data); config.n_ops_ind.append(n_op.data.indices); config.n_ops_ptr.append(n_op.data.indptr); # to array; config.c_ops_data = np.array(config.c_ops_data); config.c_ops_ind = np.array(config.c_ops_ind); config.c_ops_ptr = np.array(config.c_ops_ptr). config.n_ops_data = np.array(config.n_ops_data); config.n_ops_ind = np.array(config.n_ops_ind); config.n_ops_ptr = np.array(config.n_ops_ptr). if config.tflag == 0:; # CONSTANT H & C_OPS CODE; # -----------------------; if config.cflag:; config.c_const_inds = np.arange(len(c_ops)); # combine Hamiltonian and constant collapse terms into one; for c_op in c_ops:; n_op = c_op.dag() * c_op; H -= 0.5j * \; n_op ; # construct Hamiltonian data structures; if options.tidy:; H = H.tidyup(options.atol); config.h_data = -1.0j * H.data.data; config.h_ind = H.data.indices; config.h_ptr = H.data.indptr. elif config.tflag in ",MatchSource.WIKI,docs/4.2/modules/qutip/mcsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html
https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:30953,Modifiability,config,config,30953,"_stuff, args, e_ops,; options, config):; """"""Creates the appropriate data structures for the monte carlo solver; based on the given time-dependent, or indepdendent, format.; """""". if debug:; print(inspect.stack()[0][3]). config.soft_reset(). # take care of expectation values, if any; if any(e_ops):; config.e_num = len(e_ops); for op in e_ops:; if isinstance(op, list):; op = op[0]; config.e_ops_data.append(op.data.data); config.e_ops_ind.append(op.data.indices); config.e_ops_ptr.append(op.data.indptr); config.e_ops_isherm.append(op.isherm). config.e_ops_data = np.array(config.e_ops_data); config.e_ops_ind = np.array(config.e_ops_ind); config.e_ops_ptr = np.array(config.e_ops_ptr); config.e_ops_isherm = np.array(config.e_ops_isherm). # take care of collapse operators, if any; if any(c_ops):; config.c_num = len(c_ops); for c_op in c_ops:; if isinstance(c_op, list):; c_op = c_op[0]; n_op = c_op.dag() * c_op; config.c_ops_data.append(c_op.data.data); config.c_ops_ind.append(c_op.data.indices); config.c_ops_ptr.append(c_op.data.indptr); # norm ops; config.n_ops_data.append(n_op.data.data); config.n_ops_ind.append(n_op.data.indices); config.n_ops_ptr.append(n_op.data.indptr); # to array; config.c_ops_data = np.array(config.c_ops_data); config.c_ops_ind = np.array(config.c_ops_ind); config.c_ops_ptr = np.array(config.c_ops_ptr). config.n_ops_data = np.array(config.n_ops_data); config.n_ops_ind = np.array(config.n_ops_ind); config.n_ops_ptr = np.array(config.n_ops_ptr). if config.tflag == 0:; # CONSTANT H & C_OPS CODE; # -----------------------; if config.cflag:; config.c_const_inds = np.arange(len(c_ops)); # combine Hamiltonian and constant collapse terms into one; for c_op in c_ops:; n_op = c_op.dag() * c_op; H -= 0.5j * \; n_op ; # construct Hamiltonian data structures; if options.tidy:; H = H.tidyup(options.atol); config.h_data = -1.0j * H.data.data; config.h_ind = H.data.indices; config.h_ptr = H.data.indptr. elif config.tflag in [1, 10, 11]:; # STRING BASED TIME-DEPENDENC",MatchSource.WIKI,docs/4.2/modules/qutip/mcsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html
https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:31008,Modifiability,config,config,31008,"s the appropriate data structures for the monte carlo solver; based on the given time-dependent, or indepdendent, format.; """""". if debug:; print(inspect.stack()[0][3]). config.soft_reset(). # take care of expectation values, if any; if any(e_ops):; config.e_num = len(e_ops); for op in e_ops:; if isinstance(op, list):; op = op[0]; config.e_ops_data.append(op.data.data); config.e_ops_ind.append(op.data.indices); config.e_ops_ptr.append(op.data.indptr); config.e_ops_isherm.append(op.isherm). config.e_ops_data = np.array(config.e_ops_data); config.e_ops_ind = np.array(config.e_ops_ind); config.e_ops_ptr = np.array(config.e_ops_ptr); config.e_ops_isherm = np.array(config.e_ops_isherm). # take care of collapse operators, if any; if any(c_ops):; config.c_num = len(c_ops); for c_op in c_ops:; if isinstance(c_op, list):; c_op = c_op[0]; n_op = c_op.dag() * c_op; config.c_ops_data.append(c_op.data.data); config.c_ops_ind.append(c_op.data.indices); config.c_ops_ptr.append(c_op.data.indptr); # norm ops; config.n_ops_data.append(n_op.data.data); config.n_ops_ind.append(n_op.data.indices); config.n_ops_ptr.append(n_op.data.indptr); # to array; config.c_ops_data = np.array(config.c_ops_data); config.c_ops_ind = np.array(config.c_ops_ind); config.c_ops_ptr = np.array(config.c_ops_ptr). config.n_ops_data = np.array(config.n_ops_data); config.n_ops_ind = np.array(config.n_ops_ind); config.n_ops_ptr = np.array(config.n_ops_ptr). if config.tflag == 0:; # CONSTANT H & C_OPS CODE; # -----------------------; if config.cflag:; config.c_const_inds = np.arange(len(c_ops)); # combine Hamiltonian and constant collapse terms into one; for c_op in c_ops:; n_op = c_op.dag() * c_op; H -= 0.5j * \; n_op ; # construct Hamiltonian data structures; if options.tidy:; H = H.tidyup(options.atol); config.h_data = -1.0j * H.data.data; config.h_ind = H.data.indices; config.h_ptr = H.data.indptr. elif config.tflag in [1, 10, 11]:; # STRING BASED TIME-DEPENDENCE; # ----------------------------. # take care of",MatchSource.WIKI,docs/4.2/modules/qutip/mcsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html
https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:31050,Modifiability,config,config,31050,"arlo solver; based on the given time-dependent, or indepdendent, format.; """""". if debug:; print(inspect.stack()[0][3]). config.soft_reset(). # take care of expectation values, if any; if any(e_ops):; config.e_num = len(e_ops); for op in e_ops:; if isinstance(op, list):; op = op[0]; config.e_ops_data.append(op.data.data); config.e_ops_ind.append(op.data.indices); config.e_ops_ptr.append(op.data.indptr); config.e_ops_isherm.append(op.isherm). config.e_ops_data = np.array(config.e_ops_data); config.e_ops_ind = np.array(config.e_ops_ind); config.e_ops_ptr = np.array(config.e_ops_ptr); config.e_ops_isherm = np.array(config.e_ops_isherm). # take care of collapse operators, if any; if any(c_ops):; config.c_num = len(c_ops); for c_op in c_ops:; if isinstance(c_op, list):; c_op = c_op[0]; n_op = c_op.dag() * c_op; config.c_ops_data.append(c_op.data.data); config.c_ops_ind.append(c_op.data.indices); config.c_ops_ptr.append(c_op.data.indptr); # norm ops; config.n_ops_data.append(n_op.data.data); config.n_ops_ind.append(n_op.data.indices); config.n_ops_ptr.append(n_op.data.indptr); # to array; config.c_ops_data = np.array(config.c_ops_data); config.c_ops_ind = np.array(config.c_ops_ind); config.c_ops_ptr = np.array(config.c_ops_ptr). config.n_ops_data = np.array(config.n_ops_data); config.n_ops_ind = np.array(config.n_ops_ind); config.n_ops_ptr = np.array(config.n_ops_ptr). if config.tflag == 0:; # CONSTANT H & C_OPS CODE; # -----------------------; if config.cflag:; config.c_const_inds = np.arange(len(c_ops)); # combine Hamiltonian and constant collapse terms into one; for c_op in c_ops:; n_op = c_op.dag() * c_op; H -= 0.5j * \; n_op ; # construct Hamiltonian data structures; if options.tidy:; H = H.tidyup(options.atol); config.h_data = -1.0j * H.data.data; config.h_ind = H.data.indices; config.h_ptr = H.data.indptr. elif config.tflag in [1, 10, 11]:; # STRING BASED TIME-DEPENDENCE; # ----------------------------. # take care of arguments for collapse operators, if any; if any",MatchSource.WIKI,docs/4.2/modules/qutip/mcsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html
https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:31094,Modifiability,config,config,31094,"dent, or indepdendent, format.; """""". if debug:; print(inspect.stack()[0][3]). config.soft_reset(). # take care of expectation values, if any; if any(e_ops):; config.e_num = len(e_ops); for op in e_ops:; if isinstance(op, list):; op = op[0]; config.e_ops_data.append(op.data.data); config.e_ops_ind.append(op.data.indices); config.e_ops_ptr.append(op.data.indptr); config.e_ops_isherm.append(op.isherm). config.e_ops_data = np.array(config.e_ops_data); config.e_ops_ind = np.array(config.e_ops_ind); config.e_ops_ptr = np.array(config.e_ops_ptr); config.e_ops_isherm = np.array(config.e_ops_isherm). # take care of collapse operators, if any; if any(c_ops):; config.c_num = len(c_ops); for c_op in c_ops:; if isinstance(c_op, list):; c_op = c_op[0]; n_op = c_op.dag() * c_op; config.c_ops_data.append(c_op.data.data); config.c_ops_ind.append(c_op.data.indices); config.c_ops_ptr.append(c_op.data.indptr); # norm ops; config.n_ops_data.append(n_op.data.data); config.n_ops_ind.append(n_op.data.indices); config.n_ops_ptr.append(n_op.data.indptr); # to array; config.c_ops_data = np.array(config.c_ops_data); config.c_ops_ind = np.array(config.c_ops_ind); config.c_ops_ptr = np.array(config.c_ops_ptr). config.n_ops_data = np.array(config.n_ops_data); config.n_ops_ind = np.array(config.n_ops_ind); config.n_ops_ptr = np.array(config.n_ops_ptr). if config.tflag == 0:; # CONSTANT H & C_OPS CODE; # -----------------------; if config.cflag:; config.c_const_inds = np.arange(len(c_ops)); # combine Hamiltonian and constant collapse terms into one; for c_op in c_ops:; n_op = c_op.dag() * c_op; H -= 0.5j * \; n_op ; # construct Hamiltonian data structures; if options.tidy:; H = H.tidyup(options.atol); config.h_data = -1.0j * H.data.data; config.h_ind = H.data.indices; config.h_ptr = H.data.indptr. elif config.tflag in [1, 10, 11]:; # STRING BASED TIME-DEPENDENCE; # ----------------------------. # take care of arguments for collapse operators, if any; if any(args):; for item in args.items():; config.",MatchSource.WIKI,docs/4.2/modules/qutip/mcsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html
https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:31149,Modifiability,config,config,31149,"int(inspect.stack()[0][3]). config.soft_reset(). # take care of expectation values, if any; if any(e_ops):; config.e_num = len(e_ops); for op in e_ops:; if isinstance(op, list):; op = op[0]; config.e_ops_data.append(op.data.data); config.e_ops_ind.append(op.data.indices); config.e_ops_ptr.append(op.data.indptr); config.e_ops_isherm.append(op.isherm). config.e_ops_data = np.array(config.e_ops_data); config.e_ops_ind = np.array(config.e_ops_ind); config.e_ops_ptr = np.array(config.e_ops_ptr); config.e_ops_isherm = np.array(config.e_ops_isherm). # take care of collapse operators, if any; if any(c_ops):; config.c_num = len(c_ops); for c_op in c_ops:; if isinstance(c_op, list):; c_op = c_op[0]; n_op = c_op.dag() * c_op; config.c_ops_data.append(c_op.data.data); config.c_ops_ind.append(c_op.data.indices); config.c_ops_ptr.append(c_op.data.indptr); # norm ops; config.n_ops_data.append(n_op.data.data); config.n_ops_ind.append(n_op.data.indices); config.n_ops_ptr.append(n_op.data.indptr); # to array; config.c_ops_data = np.array(config.c_ops_data); config.c_ops_ind = np.array(config.c_ops_ind); config.c_ops_ptr = np.array(config.c_ops_ptr). config.n_ops_data = np.array(config.n_ops_data); config.n_ops_ind = np.array(config.n_ops_ind); config.n_ops_ptr = np.array(config.n_ops_ptr). if config.tflag == 0:; # CONSTANT H & C_OPS CODE; # -----------------------; if config.cflag:; config.c_const_inds = np.arange(len(c_ops)); # combine Hamiltonian and constant collapse terms into one; for c_op in c_ops:; n_op = c_op.dag() * c_op; H -= 0.5j * \; n_op ; # construct Hamiltonian data structures; if options.tidy:; H = H.tidyup(options.atol); config.h_data = -1.0j * H.data.data; config.h_ind = H.data.indices; config.h_ptr = H.data.indptr. elif config.tflag in [1, 10, 11]:; # STRING BASED TIME-DEPENDENCE; # ----------------------------. # take care of arguments for collapse operators, if any; if any(args):; for item in args.items():; config.c_args.append(item[1]); # constant Hamiltonian / ",MatchSource.WIKI,docs/4.2/modules/qutip/mcsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html
https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:31178,Modifiability,config,config,31178,"oft_reset(). # take care of expectation values, if any; if any(e_ops):; config.e_num = len(e_ops); for op in e_ops:; if isinstance(op, list):; op = op[0]; config.e_ops_data.append(op.data.data); config.e_ops_ind.append(op.data.indices); config.e_ops_ptr.append(op.data.indptr); config.e_ops_isherm.append(op.isherm). config.e_ops_data = np.array(config.e_ops_data); config.e_ops_ind = np.array(config.e_ops_ind); config.e_ops_ptr = np.array(config.e_ops_ptr); config.e_ops_isherm = np.array(config.e_ops_isherm). # take care of collapse operators, if any; if any(c_ops):; config.c_num = len(c_ops); for c_op in c_ops:; if isinstance(c_op, list):; c_op = c_op[0]; n_op = c_op.dag() * c_op; config.c_ops_data.append(c_op.data.data); config.c_ops_ind.append(c_op.data.indices); config.c_ops_ptr.append(c_op.data.indptr); # norm ops; config.n_ops_data.append(n_op.data.data); config.n_ops_ind.append(n_op.data.indices); config.n_ops_ptr.append(n_op.data.indptr); # to array; config.c_ops_data = np.array(config.c_ops_data); config.c_ops_ind = np.array(config.c_ops_ind); config.c_ops_ptr = np.array(config.c_ops_ptr). config.n_ops_data = np.array(config.n_ops_data); config.n_ops_ind = np.array(config.n_ops_ind); config.n_ops_ptr = np.array(config.n_ops_ptr). if config.tflag == 0:; # CONSTANT H & C_OPS CODE; # -----------------------; if config.cflag:; config.c_const_inds = np.arange(len(c_ops)); # combine Hamiltonian and constant collapse terms into one; for c_op in c_ops:; n_op = c_op.dag() * c_op; H -= 0.5j * \; n_op ; # construct Hamiltonian data structures; if options.tidy:; H = H.tidyup(options.atol); config.h_data = -1.0j * H.data.data; config.h_ind = H.data.indices; config.h_ptr = H.data.indptr. elif config.tflag in [1, 10, 11]:; # STRING BASED TIME-DEPENDENCE; # ----------------------------. # take care of arguments for collapse operators, if any; if any(args):; for item in args.items():; config.c_args.append(item[1]); # constant Hamiltonian / string-type collapse operators; if co",MatchSource.WIKI,docs/4.2/modules/qutip/mcsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html
https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:31198,Modifiability,config,config,31198,"ke care of expectation values, if any; if any(e_ops):; config.e_num = len(e_ops); for op in e_ops:; if isinstance(op, list):; op = op[0]; config.e_ops_data.append(op.data.data); config.e_ops_ind.append(op.data.indices); config.e_ops_ptr.append(op.data.indptr); config.e_ops_isherm.append(op.isherm). config.e_ops_data = np.array(config.e_ops_data); config.e_ops_ind = np.array(config.e_ops_ind); config.e_ops_ptr = np.array(config.e_ops_ptr); config.e_ops_isherm = np.array(config.e_ops_isherm). # take care of collapse operators, if any; if any(c_ops):; config.c_num = len(c_ops); for c_op in c_ops:; if isinstance(c_op, list):; c_op = c_op[0]; n_op = c_op.dag() * c_op; config.c_ops_data.append(c_op.data.data); config.c_ops_ind.append(c_op.data.indices); config.c_ops_ptr.append(c_op.data.indptr); # norm ops; config.n_ops_data.append(n_op.data.data); config.n_ops_ind.append(n_op.data.indices); config.n_ops_ptr.append(n_op.data.indptr); # to array; config.c_ops_data = np.array(config.c_ops_data); config.c_ops_ind = np.array(config.c_ops_ind); config.c_ops_ptr = np.array(config.c_ops_ptr). config.n_ops_data = np.array(config.n_ops_data); config.n_ops_ind = np.array(config.n_ops_ind); config.n_ops_ptr = np.array(config.n_ops_ptr). if config.tflag == 0:; # CONSTANT H & C_OPS CODE; # -----------------------; if config.cflag:; config.c_const_inds = np.arange(len(c_ops)); # combine Hamiltonian and constant collapse terms into one; for c_op in c_ops:; n_op = c_op.dag() * c_op; H -= 0.5j * \; n_op ; # construct Hamiltonian data structures; if options.tidy:; H = H.tidyup(options.atol); config.h_data = -1.0j * H.data.data; config.h_ind = H.data.indices; config.h_ptr = H.data.indptr. elif config.tflag in [1, 10, 11]:; # STRING BASED TIME-DEPENDENCE; # ----------------------------. # take care of arguments for collapse operators, if any; if any(args):; for item in args.items():; config.c_args.append(item[1]); # constant Hamiltonian / string-type collapse operators; if config.tflag == 1:",MatchSource.WIKI,docs/4.2/modules/qutip/mcsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html
https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:31226,Modifiability,config,config,31226,"if any; if any(e_ops):; config.e_num = len(e_ops); for op in e_ops:; if isinstance(op, list):; op = op[0]; config.e_ops_data.append(op.data.data); config.e_ops_ind.append(op.data.indices); config.e_ops_ptr.append(op.data.indptr); config.e_ops_isherm.append(op.isherm). config.e_ops_data = np.array(config.e_ops_data); config.e_ops_ind = np.array(config.e_ops_ind); config.e_ops_ptr = np.array(config.e_ops_ptr); config.e_ops_isherm = np.array(config.e_ops_isherm). # take care of collapse operators, if any; if any(c_ops):; config.c_num = len(c_ops); for c_op in c_ops:; if isinstance(c_op, list):; c_op = c_op[0]; n_op = c_op.dag() * c_op; config.c_ops_data.append(c_op.data.data); config.c_ops_ind.append(c_op.data.indices); config.c_ops_ptr.append(c_op.data.indptr); # norm ops; config.n_ops_data.append(n_op.data.data); config.n_ops_ind.append(n_op.data.indices); config.n_ops_ptr.append(n_op.data.indptr); # to array; config.c_ops_data = np.array(config.c_ops_data); config.c_ops_ind = np.array(config.c_ops_ind); config.c_ops_ptr = np.array(config.c_ops_ptr). config.n_ops_data = np.array(config.n_ops_data); config.n_ops_ind = np.array(config.n_ops_ind); config.n_ops_ptr = np.array(config.n_ops_ptr). if config.tflag == 0:; # CONSTANT H & C_OPS CODE; # -----------------------; if config.cflag:; config.c_const_inds = np.arange(len(c_ops)); # combine Hamiltonian and constant collapse terms into one; for c_op in c_ops:; n_op = c_op.dag() * c_op; H -= 0.5j * \; n_op ; # construct Hamiltonian data structures; if options.tidy:; H = H.tidyup(options.atol); config.h_data = -1.0j * H.data.data; config.h_ind = H.data.indices; config.h_ptr = H.data.indptr. elif config.tflag in [1, 10, 11]:; # STRING BASED TIME-DEPENDENCE; # ----------------------------. # take care of arguments for collapse operators, if any; if any(args):; for item in args.items():; config.c_args.append(item[1]); # constant Hamiltonian / string-type collapse operators; if config.tflag == 1:; H_inds = np.arange(1); H_tdter",MatchSource.WIKI,docs/4.2/modules/qutip/mcsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html
https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:31245,Modifiability,config,config,31245,"_ops):; config.e_num = len(e_ops); for op in e_ops:; if isinstance(op, list):; op = op[0]; config.e_ops_data.append(op.data.data); config.e_ops_ind.append(op.data.indices); config.e_ops_ptr.append(op.data.indptr); config.e_ops_isherm.append(op.isherm). config.e_ops_data = np.array(config.e_ops_data); config.e_ops_ind = np.array(config.e_ops_ind); config.e_ops_ptr = np.array(config.e_ops_ptr); config.e_ops_isherm = np.array(config.e_ops_isherm). # take care of collapse operators, if any; if any(c_ops):; config.c_num = len(c_ops); for c_op in c_ops:; if isinstance(c_op, list):; c_op = c_op[0]; n_op = c_op.dag() * c_op; config.c_ops_data.append(c_op.data.data); config.c_ops_ind.append(c_op.data.indices); config.c_ops_ptr.append(c_op.data.indptr); # norm ops; config.n_ops_data.append(n_op.data.data); config.n_ops_ind.append(n_op.data.indices); config.n_ops_ptr.append(n_op.data.indptr); # to array; config.c_ops_data = np.array(config.c_ops_data); config.c_ops_ind = np.array(config.c_ops_ind); config.c_ops_ptr = np.array(config.c_ops_ptr). config.n_ops_data = np.array(config.n_ops_data); config.n_ops_ind = np.array(config.n_ops_ind); config.n_ops_ptr = np.array(config.n_ops_ptr). if config.tflag == 0:; # CONSTANT H & C_OPS CODE; # -----------------------; if config.cflag:; config.c_const_inds = np.arange(len(c_ops)); # combine Hamiltonian and constant collapse terms into one; for c_op in c_ops:; n_op = c_op.dag() * c_op; H -= 0.5j * \; n_op ; # construct Hamiltonian data structures; if options.tidy:; H = H.tidyup(options.atol); config.h_data = -1.0j * H.data.data; config.h_ind = H.data.indices; config.h_ptr = H.data.indptr. elif config.tflag in [1, 10, 11]:; # STRING BASED TIME-DEPENDENCE; # ----------------------------. # take care of arguments for collapse operators, if any; if any(args):; for item in args.items():; config.c_args.append(item[1]); # constant Hamiltonian / string-type collapse operators; if config.tflag == 1:; H_inds = np.arange(1); H_tdterms = 0; len_h = ",MatchSource.WIKI,docs/4.2/modules/qutip/mcsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html
https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:31273,Modifiability,config,config,31273,"s); for op in e_ops:; if isinstance(op, list):; op = op[0]; config.e_ops_data.append(op.data.data); config.e_ops_ind.append(op.data.indices); config.e_ops_ptr.append(op.data.indptr); config.e_ops_isherm.append(op.isherm). config.e_ops_data = np.array(config.e_ops_data); config.e_ops_ind = np.array(config.e_ops_ind); config.e_ops_ptr = np.array(config.e_ops_ptr); config.e_ops_isherm = np.array(config.e_ops_isherm). # take care of collapse operators, if any; if any(c_ops):; config.c_num = len(c_ops); for c_op in c_ops:; if isinstance(c_op, list):; c_op = c_op[0]; n_op = c_op.dag() * c_op; config.c_ops_data.append(c_op.data.data); config.c_ops_ind.append(c_op.data.indices); config.c_ops_ptr.append(c_op.data.indptr); # norm ops; config.n_ops_data.append(n_op.data.data); config.n_ops_ind.append(n_op.data.indices); config.n_ops_ptr.append(n_op.data.indptr); # to array; config.c_ops_data = np.array(config.c_ops_data); config.c_ops_ind = np.array(config.c_ops_ind); config.c_ops_ptr = np.array(config.c_ops_ptr). config.n_ops_data = np.array(config.n_ops_data); config.n_ops_ind = np.array(config.n_ops_ind); config.n_ops_ptr = np.array(config.n_ops_ptr). if config.tflag == 0:; # CONSTANT H & C_OPS CODE; # -----------------------; if config.cflag:; config.c_const_inds = np.arange(len(c_ops)); # combine Hamiltonian and constant collapse terms into one; for c_op in c_ops:; n_op = c_op.dag() * c_op; H -= 0.5j * \; n_op ; # construct Hamiltonian data structures; if options.tidy:; H = H.tidyup(options.atol); config.h_data = -1.0j * H.data.data; config.h_ind = H.data.indices; config.h_ptr = H.data.indptr. elif config.tflag in [1, 10, 11]:; # STRING BASED TIME-DEPENDENCE; # ----------------------------. # take care of arguments for collapse operators, if any; if any(args):; for item in args.items():; config.c_args.append(item[1]); # constant Hamiltonian / string-type collapse operators; if config.tflag == 1:; H_inds = np.arange(1); H_tdterms = 0; len_h = 1; C_inds = np.arange(config.c_",MatchSource.WIKI,docs/4.2/modules/qutip/mcsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html
https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:31292,Modifiability,config,config,31292,"if isinstance(op, list):; op = op[0]; config.e_ops_data.append(op.data.data); config.e_ops_ind.append(op.data.indices); config.e_ops_ptr.append(op.data.indptr); config.e_ops_isherm.append(op.isherm). config.e_ops_data = np.array(config.e_ops_data); config.e_ops_ind = np.array(config.e_ops_ind); config.e_ops_ptr = np.array(config.e_ops_ptr); config.e_ops_isherm = np.array(config.e_ops_isherm). # take care of collapse operators, if any; if any(c_ops):; config.c_num = len(c_ops); for c_op in c_ops:; if isinstance(c_op, list):; c_op = c_op[0]; n_op = c_op.dag() * c_op; config.c_ops_data.append(c_op.data.data); config.c_ops_ind.append(c_op.data.indices); config.c_ops_ptr.append(c_op.data.indptr); # norm ops; config.n_ops_data.append(n_op.data.data); config.n_ops_ind.append(n_op.data.indices); config.n_ops_ptr.append(n_op.data.indptr); # to array; config.c_ops_data = np.array(config.c_ops_data); config.c_ops_ind = np.array(config.c_ops_ind); config.c_ops_ptr = np.array(config.c_ops_ptr). config.n_ops_data = np.array(config.n_ops_data); config.n_ops_ind = np.array(config.n_ops_ind); config.n_ops_ptr = np.array(config.n_ops_ptr). if config.tflag == 0:; # CONSTANT H & C_OPS CODE; # -----------------------; if config.cflag:; config.c_const_inds = np.arange(len(c_ops)); # combine Hamiltonian and constant collapse terms into one; for c_op in c_ops:; n_op = c_op.dag() * c_op; H -= 0.5j * \; n_op ; # construct Hamiltonian data structures; if options.tidy:; H = H.tidyup(options.atol); config.h_data = -1.0j * H.data.data; config.h_ind = H.data.indices; config.h_ptr = H.data.indptr. elif config.tflag in [1, 10, 11]:; # STRING BASED TIME-DEPENDENCE; # ----------------------------. # take care of arguments for collapse operators, if any; if any(args):; for item in args.items():; config.c_args.append(item[1]); # constant Hamiltonian / string-type collapse operators; if config.tflag == 1:; H_inds = np.arange(1); H_tdterms = 0; len_h = 1; C_inds = np.arange(config.c_num); # find inds of ",MatchSource.WIKI,docs/4.2/modules/qutip/mcsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html
https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:31321,Modifiability,config,config,31321,"op = op[0]; config.e_ops_data.append(op.data.data); config.e_ops_ind.append(op.data.indices); config.e_ops_ptr.append(op.data.indptr); config.e_ops_isherm.append(op.isherm). config.e_ops_data = np.array(config.e_ops_data); config.e_ops_ind = np.array(config.e_ops_ind); config.e_ops_ptr = np.array(config.e_ops_ptr); config.e_ops_isherm = np.array(config.e_ops_isherm). # take care of collapse operators, if any; if any(c_ops):; config.c_num = len(c_ops); for c_op in c_ops:; if isinstance(c_op, list):; c_op = c_op[0]; n_op = c_op.dag() * c_op; config.c_ops_data.append(c_op.data.data); config.c_ops_ind.append(c_op.data.indices); config.c_ops_ptr.append(c_op.data.indptr); # norm ops; config.n_ops_data.append(n_op.data.data); config.n_ops_ind.append(n_op.data.indices); config.n_ops_ptr.append(n_op.data.indptr); # to array; config.c_ops_data = np.array(config.c_ops_data); config.c_ops_ind = np.array(config.c_ops_ind); config.c_ops_ptr = np.array(config.c_ops_ptr). config.n_ops_data = np.array(config.n_ops_data); config.n_ops_ind = np.array(config.n_ops_ind); config.n_ops_ptr = np.array(config.n_ops_ptr). if config.tflag == 0:; # CONSTANT H & C_OPS CODE; # -----------------------; if config.cflag:; config.c_const_inds = np.arange(len(c_ops)); # combine Hamiltonian and constant collapse terms into one; for c_op in c_ops:; n_op = c_op.dag() * c_op; H -= 0.5j * \; n_op ; # construct Hamiltonian data structures; if options.tidy:; H = H.tidyup(options.atol); config.h_data = -1.0j * H.data.data; config.h_ind = H.data.indices; config.h_ptr = H.data.indptr. elif config.tflag in [1, 10, 11]:; # STRING BASED TIME-DEPENDENCE; # ----------------------------. # take care of arguments for collapse operators, if any; if any(args):; for item in args.items():; config.c_args.append(item[1]); # constant Hamiltonian / string-type collapse operators; if config.tflag == 1:; H_inds = np.arange(1); H_tdterms = 0; len_h = 1; C_inds = np.arange(config.c_num); # find inds of time-dependent terms; C_td_",MatchSource.WIKI,docs/4.2/modules/qutip/mcsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html
https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:31341,Modifiability,config,config,31341,"g.e_ops_data.append(op.data.data); config.e_ops_ind.append(op.data.indices); config.e_ops_ptr.append(op.data.indptr); config.e_ops_isherm.append(op.isherm). config.e_ops_data = np.array(config.e_ops_data); config.e_ops_ind = np.array(config.e_ops_ind); config.e_ops_ptr = np.array(config.e_ops_ptr); config.e_ops_isherm = np.array(config.e_ops_isherm). # take care of collapse operators, if any; if any(c_ops):; config.c_num = len(c_ops); for c_op in c_ops:; if isinstance(c_op, list):; c_op = c_op[0]; n_op = c_op.dag() * c_op; config.c_ops_data.append(c_op.data.data); config.c_ops_ind.append(c_op.data.indices); config.c_ops_ptr.append(c_op.data.indptr); # norm ops; config.n_ops_data.append(n_op.data.data); config.n_ops_ind.append(n_op.data.indices); config.n_ops_ptr.append(n_op.data.indptr); # to array; config.c_ops_data = np.array(config.c_ops_data); config.c_ops_ind = np.array(config.c_ops_ind); config.c_ops_ptr = np.array(config.c_ops_ptr). config.n_ops_data = np.array(config.n_ops_data); config.n_ops_ind = np.array(config.n_ops_ind); config.n_ops_ptr = np.array(config.n_ops_ptr). if config.tflag == 0:; # CONSTANT H & C_OPS CODE; # -----------------------; if config.cflag:; config.c_const_inds = np.arange(len(c_ops)); # combine Hamiltonian and constant collapse terms into one; for c_op in c_ops:; n_op = c_op.dag() * c_op; H -= 0.5j * \; n_op ; # construct Hamiltonian data structures; if options.tidy:; H = H.tidyup(options.atol); config.h_data = -1.0j * H.data.data; config.h_ind = H.data.indices; config.h_ptr = H.data.indptr. elif config.tflag in [1, 10, 11]:; # STRING BASED TIME-DEPENDENCE; # ----------------------------. # take care of arguments for collapse operators, if any; if any(args):; for item in args.items():; config.c_args.append(item[1]); # constant Hamiltonian / string-type collapse operators; if config.tflag == 1:; H_inds = np.arange(1); H_tdterms = 0; len_h = 1; C_inds = np.arange(config.c_num); # find inds of time-dependent terms; C_td_inds = np.array(",MatchSource.WIKI,docs/4.2/modules/qutip/mcsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html
https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:31369,Modifiability,config,config,31369,"a); config.e_ops_ind.append(op.data.indices); config.e_ops_ptr.append(op.data.indptr); config.e_ops_isherm.append(op.isherm). config.e_ops_data = np.array(config.e_ops_data); config.e_ops_ind = np.array(config.e_ops_ind); config.e_ops_ptr = np.array(config.e_ops_ptr); config.e_ops_isherm = np.array(config.e_ops_isherm). # take care of collapse operators, if any; if any(c_ops):; config.c_num = len(c_ops); for c_op in c_ops:; if isinstance(c_op, list):; c_op = c_op[0]; n_op = c_op.dag() * c_op; config.c_ops_data.append(c_op.data.data); config.c_ops_ind.append(c_op.data.indices); config.c_ops_ptr.append(c_op.data.indptr); # norm ops; config.n_ops_data.append(n_op.data.data); config.n_ops_ind.append(n_op.data.indices); config.n_ops_ptr.append(n_op.data.indptr); # to array; config.c_ops_data = np.array(config.c_ops_data); config.c_ops_ind = np.array(config.c_ops_ind); config.c_ops_ptr = np.array(config.c_ops_ptr). config.n_ops_data = np.array(config.n_ops_data); config.n_ops_ind = np.array(config.n_ops_ind); config.n_ops_ptr = np.array(config.n_ops_ptr). if config.tflag == 0:; # CONSTANT H & C_OPS CODE; # -----------------------; if config.cflag:; config.c_const_inds = np.arange(len(c_ops)); # combine Hamiltonian and constant collapse terms into one; for c_op in c_ops:; n_op = c_op.dag() * c_op; H -= 0.5j * \; n_op ; # construct Hamiltonian data structures; if options.tidy:; H = H.tidyup(options.atol); config.h_data = -1.0j * H.data.data; config.h_ind = H.data.indices; config.h_ptr = H.data.indptr. elif config.tflag in [1, 10, 11]:; # STRING BASED TIME-DEPENDENCE; # ----------------------------. # take care of arguments for collapse operators, if any; if any(args):; for item in args.items():; config.c_args.append(item[1]); # constant Hamiltonian / string-type collapse operators; if config.tflag == 1:; H_inds = np.arange(1); H_tdterms = 0; len_h = 1; C_inds = np.arange(config.c_num); # find inds of time-dependent terms; C_td_inds = np.array(c_stuff[2]); # find inds of cons",MatchSource.WIKI,docs/4.2/modules/qutip/mcsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html
https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:31388,Modifiability,config,config,31388,"_ind.append(op.data.indices); config.e_ops_ptr.append(op.data.indptr); config.e_ops_isherm.append(op.isherm). config.e_ops_data = np.array(config.e_ops_data); config.e_ops_ind = np.array(config.e_ops_ind); config.e_ops_ptr = np.array(config.e_ops_ptr); config.e_ops_isherm = np.array(config.e_ops_isherm). # take care of collapse operators, if any; if any(c_ops):; config.c_num = len(c_ops); for c_op in c_ops:; if isinstance(c_op, list):; c_op = c_op[0]; n_op = c_op.dag() * c_op; config.c_ops_data.append(c_op.data.data); config.c_ops_ind.append(c_op.data.indices); config.c_ops_ptr.append(c_op.data.indptr); # norm ops; config.n_ops_data.append(n_op.data.data); config.n_ops_ind.append(n_op.data.indices); config.n_ops_ptr.append(n_op.data.indptr); # to array; config.c_ops_data = np.array(config.c_ops_data); config.c_ops_ind = np.array(config.c_ops_ind); config.c_ops_ptr = np.array(config.c_ops_ptr). config.n_ops_data = np.array(config.n_ops_data); config.n_ops_ind = np.array(config.n_ops_ind); config.n_ops_ptr = np.array(config.n_ops_ptr). if config.tflag == 0:; # CONSTANT H & C_OPS CODE; # -----------------------; if config.cflag:; config.c_const_inds = np.arange(len(c_ops)); # combine Hamiltonian and constant collapse terms into one; for c_op in c_ops:; n_op = c_op.dag() * c_op; H -= 0.5j * \; n_op ; # construct Hamiltonian data structures; if options.tidy:; H = H.tidyup(options.atol); config.h_data = -1.0j * H.data.data; config.h_ind = H.data.indices; config.h_ptr = H.data.indptr. elif config.tflag in [1, 10, 11]:; # STRING BASED TIME-DEPENDENCE; # ----------------------------. # take care of arguments for collapse operators, if any; if any(args):; for item in args.items():; config.c_args.append(item[1]); # constant Hamiltonian / string-type collapse operators; if config.tflag == 1:; H_inds = np.arange(1); H_tdterms = 0; len_h = 1; C_inds = np.arange(config.c_num); # find inds of time-dependent terms; C_td_inds = np.array(c_stuff[2]); # find inds of constant terms; C_co",MatchSource.WIKI,docs/4.2/modules/qutip/mcsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html
https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:31416,Modifiability,config,config,31416,"onfig.e_ops_ptr.append(op.data.indptr); config.e_ops_isherm.append(op.isherm). config.e_ops_data = np.array(config.e_ops_data); config.e_ops_ind = np.array(config.e_ops_ind); config.e_ops_ptr = np.array(config.e_ops_ptr); config.e_ops_isherm = np.array(config.e_ops_isherm). # take care of collapse operators, if any; if any(c_ops):; config.c_num = len(c_ops); for c_op in c_ops:; if isinstance(c_op, list):; c_op = c_op[0]; n_op = c_op.dag() * c_op; config.c_ops_data.append(c_op.data.data); config.c_ops_ind.append(c_op.data.indices); config.c_ops_ptr.append(c_op.data.indptr); # norm ops; config.n_ops_data.append(n_op.data.data); config.n_ops_ind.append(n_op.data.indices); config.n_ops_ptr.append(n_op.data.indptr); # to array; config.c_ops_data = np.array(config.c_ops_data); config.c_ops_ind = np.array(config.c_ops_ind); config.c_ops_ptr = np.array(config.c_ops_ptr). config.n_ops_data = np.array(config.n_ops_data); config.n_ops_ind = np.array(config.n_ops_ind); config.n_ops_ptr = np.array(config.n_ops_ptr). if config.tflag == 0:; # CONSTANT H & C_OPS CODE; # -----------------------; if config.cflag:; config.c_const_inds = np.arange(len(c_ops)); # combine Hamiltonian and constant collapse terms into one; for c_op in c_ops:; n_op = c_op.dag() * c_op; H -= 0.5j * \; n_op ; # construct Hamiltonian data structures; if options.tidy:; H = H.tidyup(options.atol); config.h_data = -1.0j * H.data.data; config.h_ind = H.data.indices; config.h_ptr = H.data.indptr. elif config.tflag in [1, 10, 11]:; # STRING BASED TIME-DEPENDENCE; # ----------------------------. # take care of arguments for collapse operators, if any; if any(args):; for item in args.items():; config.c_args.append(item[1]); # constant Hamiltonian / string-type collapse operators; if config.tflag == 1:; H_inds = np.arange(1); H_tdterms = 0; len_h = 1; C_inds = np.arange(config.c_num); # find inds of time-dependent terms; C_td_inds = np.array(c_stuff[2]); # find inds of constant terms; C_const_inds = np.setdiff1d(C_inds,",MatchSource.WIKI,docs/4.2/modules/qutip/mcsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html
https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:31438,Modifiability,config,config,31438,"op.data.indptr); config.e_ops_isherm.append(op.isherm). config.e_ops_data = np.array(config.e_ops_data); config.e_ops_ind = np.array(config.e_ops_ind); config.e_ops_ptr = np.array(config.e_ops_ptr); config.e_ops_isherm = np.array(config.e_ops_isherm). # take care of collapse operators, if any; if any(c_ops):; config.c_num = len(c_ops); for c_op in c_ops:; if isinstance(c_op, list):; c_op = c_op[0]; n_op = c_op.dag() * c_op; config.c_ops_data.append(c_op.data.data); config.c_ops_ind.append(c_op.data.indices); config.c_ops_ptr.append(c_op.data.indptr); # norm ops; config.n_ops_data.append(n_op.data.data); config.n_ops_ind.append(n_op.data.indices); config.n_ops_ptr.append(n_op.data.indptr); # to array; config.c_ops_data = np.array(config.c_ops_data); config.c_ops_ind = np.array(config.c_ops_ind); config.c_ops_ptr = np.array(config.c_ops_ptr). config.n_ops_data = np.array(config.n_ops_data); config.n_ops_ind = np.array(config.n_ops_ind); config.n_ops_ptr = np.array(config.n_ops_ptr). if config.tflag == 0:; # CONSTANT H & C_OPS CODE; # -----------------------; if config.cflag:; config.c_const_inds = np.arange(len(c_ops)); # combine Hamiltonian and constant collapse terms into one; for c_op in c_ops:; n_op = c_op.dag() * c_op; H -= 0.5j * \; n_op ; # construct Hamiltonian data structures; if options.tidy:; H = H.tidyup(options.atol); config.h_data = -1.0j * H.data.data; config.h_ind = H.data.indices; config.h_ptr = H.data.indptr. elif config.tflag in [1, 10, 11]:; # STRING BASED TIME-DEPENDENCE; # ----------------------------. # take care of arguments for collapse operators, if any; if any(args):; for item in args.items():; config.c_args.append(item[1]); # constant Hamiltonian / string-type collapse operators; if config.tflag == 1:; H_inds = np.arange(1); H_tdterms = 0; len_h = 1; C_inds = np.arange(config.c_num); # find inds of time-dependent terms; C_td_inds = np.array(c_stuff[2]); # find inds of constant terms; C_const_inds = np.setdiff1d(C_inds, C_td_inds); # extract ",MatchSource.WIKI,docs/4.2/modules/qutip/mcsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html
https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:31515,Modifiability,config,config,31515,"op.isherm). config.e_ops_data = np.array(config.e_ops_data); config.e_ops_ind = np.array(config.e_ops_ind); config.e_ops_ptr = np.array(config.e_ops_ptr); config.e_ops_isherm = np.array(config.e_ops_isherm). # take care of collapse operators, if any; if any(c_ops):; config.c_num = len(c_ops); for c_op in c_ops:; if isinstance(c_op, list):; c_op = c_op[0]; n_op = c_op.dag() * c_op; config.c_ops_data.append(c_op.data.data); config.c_ops_ind.append(c_op.data.indices); config.c_ops_ptr.append(c_op.data.indptr); # norm ops; config.n_ops_data.append(n_op.data.data); config.n_ops_ind.append(n_op.data.indices); config.n_ops_ptr.append(n_op.data.indptr); # to array; config.c_ops_data = np.array(config.c_ops_data); config.c_ops_ind = np.array(config.c_ops_ind); config.c_ops_ptr = np.array(config.c_ops_ptr). config.n_ops_data = np.array(config.n_ops_data); config.n_ops_ind = np.array(config.n_ops_ind); config.n_ops_ptr = np.array(config.n_ops_ptr). if config.tflag == 0:; # CONSTANT H & C_OPS CODE; # -----------------------; if config.cflag:; config.c_const_inds = np.arange(len(c_ops)); # combine Hamiltonian and constant collapse terms into one; for c_op in c_ops:; n_op = c_op.dag() * c_op; H -= 0.5j * \; n_op ; # construct Hamiltonian data structures; if options.tidy:; H = H.tidyup(options.atol); config.h_data = -1.0j * H.data.data; config.h_ind = H.data.indices; config.h_ptr = H.data.indptr. elif config.tflag in [1, 10, 11]:; # STRING BASED TIME-DEPENDENCE; # ----------------------------. # take care of arguments for collapse operators, if any; if any(args):; for item in args.items():; config.c_args.append(item[1]); # constant Hamiltonian / string-type collapse operators; if config.tflag == 1:; H_inds = np.arange(1); H_tdterms = 0; len_h = 1; C_inds = np.arange(config.c_num); # find inds of time-dependent terms; C_td_inds = np.array(c_stuff[2]); # find inds of constant terms; C_const_inds = np.setdiff1d(C_inds, C_td_inds); # extract time-dependent coefficients (strings); C_tdt",MatchSource.WIKI,docs/4.2/modules/qutip/mcsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html
https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:31530,Modifiability,config,config,31530,"g.e_ops_data); config.e_ops_ind = np.array(config.e_ops_ind); config.e_ops_ptr = np.array(config.e_ops_ptr); config.e_ops_isherm = np.array(config.e_ops_isherm). # take care of collapse operators, if any; if any(c_ops):; config.c_num = len(c_ops); for c_op in c_ops:; if isinstance(c_op, list):; c_op = c_op[0]; n_op = c_op.dag() * c_op; config.c_ops_data.append(c_op.data.data); config.c_ops_ind.append(c_op.data.indices); config.c_ops_ptr.append(c_op.data.indptr); # norm ops; config.n_ops_data.append(n_op.data.data); config.n_ops_ind.append(n_op.data.indices); config.n_ops_ptr.append(n_op.data.indptr); # to array; config.c_ops_data = np.array(config.c_ops_data); config.c_ops_ind = np.array(config.c_ops_ind); config.c_ops_ptr = np.array(config.c_ops_ptr). config.n_ops_data = np.array(config.n_ops_data); config.n_ops_ind = np.array(config.n_ops_ind); config.n_ops_ptr = np.array(config.n_ops_ptr). if config.tflag == 0:; # CONSTANT H & C_OPS CODE; # -----------------------; if config.cflag:; config.c_const_inds = np.arange(len(c_ops)); # combine Hamiltonian and constant collapse terms into one; for c_op in c_ops:; n_op = c_op.dag() * c_op; H -= 0.5j * \; n_op ; # construct Hamiltonian data structures; if options.tidy:; H = H.tidyup(options.atol); config.h_data = -1.0j * H.data.data; config.h_ind = H.data.indices; config.h_ptr = H.data.indptr. elif config.tflag in [1, 10, 11]:; # STRING BASED TIME-DEPENDENCE; # ----------------------------. # take care of arguments for collapse operators, if any; if any(args):; for item in args.items():; config.c_args.append(item[1]); # constant Hamiltonian / string-type collapse operators; if config.tflag == 1:; H_inds = np.arange(1); H_tdterms = 0; len_h = 1; C_inds = np.arange(config.c_num); # find inds of time-dependent terms; C_td_inds = np.array(c_stuff[2]); # find inds of constant terms; C_const_inds = np.setdiff1d(C_inds, C_td_inds); # extract time-dependent coefficients (strings); C_tdterms = [c_ops[k][1] for k in C_td_inds]; # sto",MatchSource.WIKI,docs/4.2/modules/qutip/mcsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html
https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:31790,Modifiability,config,config,31790,"_ops:; if isinstance(c_op, list):; c_op = c_op[0]; n_op = c_op.dag() * c_op; config.c_ops_data.append(c_op.data.data); config.c_ops_ind.append(c_op.data.indices); config.c_ops_ptr.append(c_op.data.indptr); # norm ops; config.n_ops_data.append(n_op.data.data); config.n_ops_ind.append(n_op.data.indices); config.n_ops_ptr.append(n_op.data.indptr); # to array; config.c_ops_data = np.array(config.c_ops_data); config.c_ops_ind = np.array(config.c_ops_ind); config.c_ops_ptr = np.array(config.c_ops_ptr). config.n_ops_data = np.array(config.n_ops_data); config.n_ops_ind = np.array(config.n_ops_ind); config.n_ops_ptr = np.array(config.n_ops_ptr). if config.tflag == 0:; # CONSTANT H & C_OPS CODE; # -----------------------; if config.cflag:; config.c_const_inds = np.arange(len(c_ops)); # combine Hamiltonian and constant collapse terms into one; for c_op in c_ops:; n_op = c_op.dag() * c_op; H -= 0.5j * \; n_op ; # construct Hamiltonian data structures; if options.tidy:; H = H.tidyup(options.atol); config.h_data = -1.0j * H.data.data; config.h_ind = H.data.indices; config.h_ptr = H.data.indptr. elif config.tflag in [1, 10, 11]:; # STRING BASED TIME-DEPENDENCE; # ----------------------------. # take care of arguments for collapse operators, if any; if any(args):; for item in args.items():; config.c_args.append(item[1]); # constant Hamiltonian / string-type collapse operators; if config.tflag == 1:; H_inds = np.arange(1); H_tdterms = 0; len_h = 1; C_inds = np.arange(config.c_num); # find inds of time-dependent terms; C_td_inds = np.array(c_stuff[2]); # find inds of constant terms; C_const_inds = np.setdiff1d(C_inds, C_td_inds); # extract time-dependent coefficients (strings); C_tdterms = [c_ops[k][1] for k in C_td_inds]; # store indicies of constant collapse terms; config.c_const_inds = C_const_inds; # store indicies of time-dependent collapse terms; config.c_td_inds = C_td_inds. for k in config.c_const_inds:; H -= 0.5j * (c_ops[k].dag() * c_ops[k]); if options.tidy:; H = H.tidyup(",MatchSource.WIKI,docs/4.2/modules/qutip/mcsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html
https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:31827,Modifiability,config,config,31827,"op = c_op[0]; n_op = c_op.dag() * c_op; config.c_ops_data.append(c_op.data.data); config.c_ops_ind.append(c_op.data.indices); config.c_ops_ptr.append(c_op.data.indptr); # norm ops; config.n_ops_data.append(n_op.data.data); config.n_ops_ind.append(n_op.data.indices); config.n_ops_ptr.append(n_op.data.indptr); # to array; config.c_ops_data = np.array(config.c_ops_data); config.c_ops_ind = np.array(config.c_ops_ind); config.c_ops_ptr = np.array(config.c_ops_ptr). config.n_ops_data = np.array(config.n_ops_data); config.n_ops_ind = np.array(config.n_ops_ind); config.n_ops_ptr = np.array(config.n_ops_ptr). if config.tflag == 0:; # CONSTANT H & C_OPS CODE; # -----------------------; if config.cflag:; config.c_const_inds = np.arange(len(c_ops)); # combine Hamiltonian and constant collapse terms into one; for c_op in c_ops:; n_op = c_op.dag() * c_op; H -= 0.5j * \; n_op ; # construct Hamiltonian data structures; if options.tidy:; H = H.tidyup(options.atol); config.h_data = -1.0j * H.data.data; config.h_ind = H.data.indices; config.h_ptr = H.data.indptr. elif config.tflag in [1, 10, 11]:; # STRING BASED TIME-DEPENDENCE; # ----------------------------. # take care of arguments for collapse operators, if any; if any(args):; for item in args.items():; config.c_args.append(item[1]); # constant Hamiltonian / string-type collapse operators; if config.tflag == 1:; H_inds = np.arange(1); H_tdterms = 0; len_h = 1; C_inds = np.arange(config.c_num); # find inds of time-dependent terms; C_td_inds = np.array(c_stuff[2]); # find inds of constant terms; C_const_inds = np.setdiff1d(C_inds, C_td_inds); # extract time-dependent coefficients (strings); C_tdterms = [c_ops[k][1] for k in C_td_inds]; # store indicies of constant collapse terms; config.c_const_inds = C_const_inds; # store indicies of time-dependent collapse terms; config.c_td_inds = C_td_inds. for k in config.c_const_inds:; H -= 0.5j * (c_ops[k].dag() * c_ops[k]); if options.tidy:; H = H.tidyup(options.atol); config.h_data = [H.data",MatchSource.WIKI,docs/4.2/modules/qutip/mcsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html
https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:31858,Modifiability,config,config,31858,") * c_op; config.c_ops_data.append(c_op.data.data); config.c_ops_ind.append(c_op.data.indices); config.c_ops_ptr.append(c_op.data.indptr); # norm ops; config.n_ops_data.append(n_op.data.data); config.n_ops_ind.append(n_op.data.indices); config.n_ops_ptr.append(n_op.data.indptr); # to array; config.c_ops_data = np.array(config.c_ops_data); config.c_ops_ind = np.array(config.c_ops_ind); config.c_ops_ptr = np.array(config.c_ops_ptr). config.n_ops_data = np.array(config.n_ops_data); config.n_ops_ind = np.array(config.n_ops_ind); config.n_ops_ptr = np.array(config.n_ops_ptr). if config.tflag == 0:; # CONSTANT H & C_OPS CODE; # -----------------------; if config.cflag:; config.c_const_inds = np.arange(len(c_ops)); # combine Hamiltonian and constant collapse terms into one; for c_op in c_ops:; n_op = c_op.dag() * c_op; H -= 0.5j * \; n_op ; # construct Hamiltonian data structures; if options.tidy:; H = H.tidyup(options.atol); config.h_data = -1.0j * H.data.data; config.h_ind = H.data.indices; config.h_ptr = H.data.indptr. elif config.tflag in [1, 10, 11]:; # STRING BASED TIME-DEPENDENCE; # ----------------------------. # take care of arguments for collapse operators, if any; if any(args):; for item in args.items():; config.c_args.append(item[1]); # constant Hamiltonian / string-type collapse operators; if config.tflag == 1:; H_inds = np.arange(1); H_tdterms = 0; len_h = 1; C_inds = np.arange(config.c_num); # find inds of time-dependent terms; C_td_inds = np.array(c_stuff[2]); # find inds of constant terms; C_const_inds = np.setdiff1d(C_inds, C_td_inds); # extract time-dependent coefficients (strings); C_tdterms = [c_ops[k][1] for k in C_td_inds]; # store indicies of constant collapse terms; config.c_const_inds = C_const_inds; # store indicies of time-dependent collapse terms; config.c_td_inds = C_td_inds. for k in config.c_const_inds:; H -= 0.5j * (c_ops[k].dag() * c_ops[k]); if options.tidy:; H = H.tidyup(options.atol); config.h_data = [H.data.data]; config.h_ind = [H.dat",MatchSource.WIKI,docs/4.2/modules/qutip/mcsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html
https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:31893,Modifiability,config,config,31893,"_op.data.data); config.c_ops_ind.append(c_op.data.indices); config.c_ops_ptr.append(c_op.data.indptr); # norm ops; config.n_ops_data.append(n_op.data.data); config.n_ops_ind.append(n_op.data.indices); config.n_ops_ptr.append(n_op.data.indptr); # to array; config.c_ops_data = np.array(config.c_ops_data); config.c_ops_ind = np.array(config.c_ops_ind); config.c_ops_ptr = np.array(config.c_ops_ptr). config.n_ops_data = np.array(config.n_ops_data); config.n_ops_ind = np.array(config.n_ops_ind); config.n_ops_ptr = np.array(config.n_ops_ptr). if config.tflag == 0:; # CONSTANT H & C_OPS CODE; # -----------------------; if config.cflag:; config.c_const_inds = np.arange(len(c_ops)); # combine Hamiltonian and constant collapse terms into one; for c_op in c_ops:; n_op = c_op.dag() * c_op; H -= 0.5j * \; n_op ; # construct Hamiltonian data structures; if options.tidy:; H = H.tidyup(options.atol); config.h_data = -1.0j * H.data.data; config.h_ind = H.data.indices; config.h_ptr = H.data.indptr. elif config.tflag in [1, 10, 11]:; # STRING BASED TIME-DEPENDENCE; # ----------------------------. # take care of arguments for collapse operators, if any; if any(args):; for item in args.items():; config.c_args.append(item[1]); # constant Hamiltonian / string-type collapse operators; if config.tflag == 1:; H_inds = np.arange(1); H_tdterms = 0; len_h = 1; C_inds = np.arange(config.c_num); # find inds of time-dependent terms; C_td_inds = np.array(c_stuff[2]); # find inds of constant terms; C_const_inds = np.setdiff1d(C_inds, C_td_inds); # extract time-dependent coefficients (strings); C_tdterms = [c_ops[k][1] for k in C_td_inds]; # store indicies of constant collapse terms; config.c_const_inds = C_const_inds; # store indicies of time-dependent collapse terms; config.c_td_inds = C_td_inds. for k in config.c_const_inds:; H -= 0.5j * (c_ops[k].dag() * c_ops[k]); if options.tidy:; H = H.tidyup(options.atol); config.h_data = [H.data.data]; config.h_ind = [H.data.indices]; config.h_ptr = [H.data.in",MatchSource.WIKI,docs/4.2/modules/qutip/mcsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html
https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:32086,Modifiability,config,config,32086,"indices); config.n_ops_ptr.append(n_op.data.indptr); # to array; config.c_ops_data = np.array(config.c_ops_data); config.c_ops_ind = np.array(config.c_ops_ind); config.c_ops_ptr = np.array(config.c_ops_ptr). config.n_ops_data = np.array(config.n_ops_data); config.n_ops_ind = np.array(config.n_ops_ind); config.n_ops_ptr = np.array(config.n_ops_ptr). if config.tflag == 0:; # CONSTANT H & C_OPS CODE; # -----------------------; if config.cflag:; config.c_const_inds = np.arange(len(c_ops)); # combine Hamiltonian and constant collapse terms into one; for c_op in c_ops:; n_op = c_op.dag() * c_op; H -= 0.5j * \; n_op ; # construct Hamiltonian data structures; if options.tidy:; H = H.tidyup(options.atol); config.h_data = -1.0j * H.data.data; config.h_ind = H.data.indices; config.h_ptr = H.data.indptr. elif config.tflag in [1, 10, 11]:; # STRING BASED TIME-DEPENDENCE; # ----------------------------. # take care of arguments for collapse operators, if any; if any(args):; for item in args.items():; config.c_args.append(item[1]); # constant Hamiltonian / string-type collapse operators; if config.tflag == 1:; H_inds = np.arange(1); H_tdterms = 0; len_h = 1; C_inds = np.arange(config.c_num); # find inds of time-dependent terms; C_td_inds = np.array(c_stuff[2]); # find inds of constant terms; C_const_inds = np.setdiff1d(C_inds, C_td_inds); # extract time-dependent coefficients (strings); C_tdterms = [c_ops[k][1] for k in C_td_inds]; # store indicies of constant collapse terms; config.c_const_inds = C_const_inds; # store indicies of time-dependent collapse terms; config.c_td_inds = C_td_inds. for k in config.c_const_inds:; H -= 0.5j * (c_ops[k].dag() * c_ops[k]); if options.tidy:; H = H.tidyup(options.atol); config.h_data = [H.data.data]; config.h_ind = [H.data.indices]; config.h_ptr = [H.data.indptr]; for k in config.c_td_inds:; op = c_ops[k][0].dag() * c_ops[k][0]; config.h_data.append(-0.5j * op.data.data); config.h_ind.append(op.data.indices); config.h_ptr.append(op.data.indptr);",MatchSource.WIKI,docs/4.2/modules/qutip/mcsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html
https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:32177,Modifiability,config,config,32177,"array; config.c_ops_data = np.array(config.c_ops_data); config.c_ops_ind = np.array(config.c_ops_ind); config.c_ops_ptr = np.array(config.c_ops_ptr). config.n_ops_data = np.array(config.n_ops_data); config.n_ops_ind = np.array(config.n_ops_ind); config.n_ops_ptr = np.array(config.n_ops_ptr). if config.tflag == 0:; # CONSTANT H & C_OPS CODE; # -----------------------; if config.cflag:; config.c_const_inds = np.arange(len(c_ops)); # combine Hamiltonian and constant collapse terms into one; for c_op in c_ops:; n_op = c_op.dag() * c_op; H -= 0.5j * \; n_op ; # construct Hamiltonian data structures; if options.tidy:; H = H.tidyup(options.atol); config.h_data = -1.0j * H.data.data; config.h_ind = H.data.indices; config.h_ptr = H.data.indptr. elif config.tflag in [1, 10, 11]:; # STRING BASED TIME-DEPENDENCE; # ----------------------------. # take care of arguments for collapse operators, if any; if any(args):; for item in args.items():; config.c_args.append(item[1]); # constant Hamiltonian / string-type collapse operators; if config.tflag == 1:; H_inds = np.arange(1); H_tdterms = 0; len_h = 1; C_inds = np.arange(config.c_num); # find inds of time-dependent terms; C_td_inds = np.array(c_stuff[2]); # find inds of constant terms; C_const_inds = np.setdiff1d(C_inds, C_td_inds); # extract time-dependent coefficients (strings); C_tdterms = [c_ops[k][1] for k in C_td_inds]; # store indicies of constant collapse terms; config.c_const_inds = C_const_inds; # store indicies of time-dependent collapse terms; config.c_td_inds = C_td_inds. for k in config.c_const_inds:; H -= 0.5j * (c_ops[k].dag() * c_ops[k]); if options.tidy:; H = H.tidyup(options.atol); config.h_data = [H.data.data]; config.h_ind = [H.data.indices]; config.h_ptr = [H.data.indptr]; for k in config.c_td_inds:; op = c_ops[k][0].dag() * c_ops[k][0]; config.h_data.append(-0.5j * op.data.data); config.h_ind.append(op.data.indices); config.h_ptr.append(op.data.indptr); config.h_data = -1.0j * np.array(config.h_data); config.",MatchSource.WIKI,docs/4.2/modules/qutip/mcsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html
https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:32265,Modifiability,config,config,32265,"p.array(config.c_ops_ptr). config.n_ops_data = np.array(config.n_ops_data); config.n_ops_ind = np.array(config.n_ops_ind); config.n_ops_ptr = np.array(config.n_ops_ptr). if config.tflag == 0:; # CONSTANT H & C_OPS CODE; # -----------------------; if config.cflag:; config.c_const_inds = np.arange(len(c_ops)); # combine Hamiltonian and constant collapse terms into one; for c_op in c_ops:; n_op = c_op.dag() * c_op; H -= 0.5j * \; n_op ; # construct Hamiltonian data structures; if options.tidy:; H = H.tidyup(options.atol); config.h_data = -1.0j * H.data.data; config.h_ind = H.data.indices; config.h_ptr = H.data.indptr. elif config.tflag in [1, 10, 11]:; # STRING BASED TIME-DEPENDENCE; # ----------------------------. # take care of arguments for collapse operators, if any; if any(args):; for item in args.items():; config.c_args.append(item[1]); # constant Hamiltonian / string-type collapse operators; if config.tflag == 1:; H_inds = np.arange(1); H_tdterms = 0; len_h = 1; C_inds = np.arange(config.c_num); # find inds of time-dependent terms; C_td_inds = np.array(c_stuff[2]); # find inds of constant terms; C_const_inds = np.setdiff1d(C_inds, C_td_inds); # extract time-dependent coefficients (strings); C_tdterms = [c_ops[k][1] for k in C_td_inds]; # store indicies of constant collapse terms; config.c_const_inds = C_const_inds; # store indicies of time-dependent collapse terms; config.c_td_inds = C_td_inds. for k in config.c_const_inds:; H -= 0.5j * (c_ops[k].dag() * c_ops[k]); if options.tidy:; H = H.tidyup(options.atol); config.h_data = [H.data.data]; config.h_ind = [H.data.indices]; config.h_ptr = [H.data.indptr]; for k in config.c_td_inds:; op = c_ops[k][0].dag() * c_ops[k][0]; config.h_data.append(-0.5j * op.data.data); config.h_ind.append(op.data.indices); config.h_ptr.append(op.data.indptr); config.h_data = -1.0j * np.array(config.h_data); config.h_ind = np.array(config.h_ind); config.h_ptr = np.array(config.h_ptr). else:; # string-type Hamiltonian & at least one stri",MatchSource.WIKI,docs/4.2/modules/qutip/mcsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html
https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:32570,Modifiability,config,config,32570,"----------------------; if config.cflag:; config.c_const_inds = np.arange(len(c_ops)); # combine Hamiltonian and constant collapse terms into one; for c_op in c_ops:; n_op = c_op.dag() * c_op; H -= 0.5j * \; n_op ; # construct Hamiltonian data structures; if options.tidy:; H = H.tidyup(options.atol); config.h_data = -1.0j * H.data.data; config.h_ind = H.data.indices; config.h_ptr = H.data.indptr. elif config.tflag in [1, 10, 11]:; # STRING BASED TIME-DEPENDENCE; # ----------------------------. # take care of arguments for collapse operators, if any; if any(args):; for item in args.items():; config.c_args.append(item[1]); # constant Hamiltonian / string-type collapse operators; if config.tflag == 1:; H_inds = np.arange(1); H_tdterms = 0; len_h = 1; C_inds = np.arange(config.c_num); # find inds of time-dependent terms; C_td_inds = np.array(c_stuff[2]); # find inds of constant terms; C_const_inds = np.setdiff1d(C_inds, C_td_inds); # extract time-dependent coefficients (strings); C_tdterms = [c_ops[k][1] for k in C_td_inds]; # store indicies of constant collapse terms; config.c_const_inds = C_const_inds; # store indicies of time-dependent collapse terms; config.c_td_inds = C_td_inds. for k in config.c_const_inds:; H -= 0.5j * (c_ops[k].dag() * c_ops[k]); if options.tidy:; H = H.tidyup(options.atol); config.h_data = [H.data.data]; config.h_ind = [H.data.indices]; config.h_ptr = [H.data.indptr]; for k in config.c_td_inds:; op = c_ops[k][0].dag() * c_ops[k][0]; config.h_data.append(-0.5j * op.data.data); config.h_ind.append(op.data.indices); config.h_ptr.append(op.data.indptr); config.h_data = -1.0j * np.array(config.h_data); config.h_ind = np.array(config.h_ind); config.h_ptr = np.array(config.h_ptr). else:; # string-type Hamiltonian & at least one string-type; # collapse operator; # -----------------. H_inds = np.arange(len(H)); # find inds of time-dependent terms; H_td_inds = np.array(h_stuff[2]); # find inds of constant terms; H_const_inds = np.setdiff1d(H_inds, H_td_in",MatchSource.WIKI,docs/4.2/modules/qutip/mcsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html
https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:32657,Modifiability,config,config,32657,"erms into one; for c_op in c_ops:; n_op = c_op.dag() * c_op; H -= 0.5j * \; n_op ; # construct Hamiltonian data structures; if options.tidy:; H = H.tidyup(options.atol); config.h_data = -1.0j * H.data.data; config.h_ind = H.data.indices; config.h_ptr = H.data.indptr. elif config.tflag in [1, 10, 11]:; # STRING BASED TIME-DEPENDENCE; # ----------------------------. # take care of arguments for collapse operators, if any; if any(args):; for item in args.items():; config.c_args.append(item[1]); # constant Hamiltonian / string-type collapse operators; if config.tflag == 1:; H_inds = np.arange(1); H_tdterms = 0; len_h = 1; C_inds = np.arange(config.c_num); # find inds of time-dependent terms; C_td_inds = np.array(c_stuff[2]); # find inds of constant terms; C_const_inds = np.setdiff1d(C_inds, C_td_inds); # extract time-dependent coefficients (strings); C_tdterms = [c_ops[k][1] for k in C_td_inds]; # store indicies of constant collapse terms; config.c_const_inds = C_const_inds; # store indicies of time-dependent collapse terms; config.c_td_inds = C_td_inds. for k in config.c_const_inds:; H -= 0.5j * (c_ops[k].dag() * c_ops[k]); if options.tidy:; H = H.tidyup(options.atol); config.h_data = [H.data.data]; config.h_ind = [H.data.indices]; config.h_ptr = [H.data.indptr]; for k in config.c_td_inds:; op = c_ops[k][0].dag() * c_ops[k][0]; config.h_data.append(-0.5j * op.data.data); config.h_ind.append(op.data.indices); config.h_ptr.append(op.data.indptr); config.h_data = -1.0j * np.array(config.h_data); config.h_ind = np.array(config.h_ind); config.h_ptr = np.array(config.h_ptr). else:; # string-type Hamiltonian & at least one string-type; # collapse operator; # -----------------. H_inds = np.arange(len(H)); # find inds of time-dependent terms; H_td_inds = np.array(h_stuff[2]); # find inds of constant terms; H_const_inds = np.setdiff1d(H_inds, H_td_inds); # extract time-dependent coefficients (strings or functions); config.h_tdterms = [H[k][1] for k in H_td_inds]; # combine time-I",MatchSource.WIKI,docs/4.2/modules/qutip/mcsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html
https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:32696,Modifiability,config,config,32696,"; n_op ; # construct Hamiltonian data structures; if options.tidy:; H = H.tidyup(options.atol); config.h_data = -1.0j * H.data.data; config.h_ind = H.data.indices; config.h_ptr = H.data.indptr. elif config.tflag in [1, 10, 11]:; # STRING BASED TIME-DEPENDENCE; # ----------------------------. # take care of arguments for collapse operators, if any; if any(args):; for item in args.items():; config.c_args.append(item[1]); # constant Hamiltonian / string-type collapse operators; if config.tflag == 1:; H_inds = np.arange(1); H_tdterms = 0; len_h = 1; C_inds = np.arange(config.c_num); # find inds of time-dependent terms; C_td_inds = np.array(c_stuff[2]); # find inds of constant terms; C_const_inds = np.setdiff1d(C_inds, C_td_inds); # extract time-dependent coefficients (strings); C_tdterms = [c_ops[k][1] for k in C_td_inds]; # store indicies of constant collapse terms; config.c_const_inds = C_const_inds; # store indicies of time-dependent collapse terms; config.c_td_inds = C_td_inds. for k in config.c_const_inds:; H -= 0.5j * (c_ops[k].dag() * c_ops[k]); if options.tidy:; H = H.tidyup(options.atol); config.h_data = [H.data.data]; config.h_ind = [H.data.indices]; config.h_ptr = [H.data.indptr]; for k in config.c_td_inds:; op = c_ops[k][0].dag() * c_ops[k][0]; config.h_data.append(-0.5j * op.data.data); config.h_ind.append(op.data.indices); config.h_ptr.append(op.data.indptr); config.h_data = -1.0j * np.array(config.h_data); config.h_ind = np.array(config.h_ind); config.h_ptr = np.array(config.h_ptr). else:; # string-type Hamiltonian & at least one string-type; # collapse operator; # -----------------. H_inds = np.arange(len(H)); # find inds of time-dependent terms; H_td_inds = np.array(h_stuff[2]); # find inds of constant terms; H_const_inds = np.setdiff1d(H_inds, H_td_inds); # extract time-dependent coefficients (strings or functions); config.h_tdterms = [H[k][1] for k in H_td_inds]; # combine time-INDEPENDENT terms into one.; H = np.array([np.sum(H[k] for k in H_const_ind",MatchSource.WIKI,docs/4.2/modules/qutip/mcsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html
https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:32805,Modifiability,config,config,32805," -1.0j * H.data.data; config.h_ind = H.data.indices; config.h_ptr = H.data.indptr. elif config.tflag in [1, 10, 11]:; # STRING BASED TIME-DEPENDENCE; # ----------------------------. # take care of arguments for collapse operators, if any; if any(args):; for item in args.items():; config.c_args.append(item[1]); # constant Hamiltonian / string-type collapse operators; if config.tflag == 1:; H_inds = np.arange(1); H_tdterms = 0; len_h = 1; C_inds = np.arange(config.c_num); # find inds of time-dependent terms; C_td_inds = np.array(c_stuff[2]); # find inds of constant terms; C_const_inds = np.setdiff1d(C_inds, C_td_inds); # extract time-dependent coefficients (strings); C_tdterms = [c_ops[k][1] for k in C_td_inds]; # store indicies of constant collapse terms; config.c_const_inds = C_const_inds; # store indicies of time-dependent collapse terms; config.c_td_inds = C_td_inds. for k in config.c_const_inds:; H -= 0.5j * (c_ops[k].dag() * c_ops[k]); if options.tidy:; H = H.tidyup(options.atol); config.h_data = [H.data.data]; config.h_ind = [H.data.indices]; config.h_ptr = [H.data.indptr]; for k in config.c_td_inds:; op = c_ops[k][0].dag() * c_ops[k][0]; config.h_data.append(-0.5j * op.data.data); config.h_ind.append(op.data.indices); config.h_ptr.append(op.data.indptr); config.h_data = -1.0j * np.array(config.h_data); config.h_ind = np.array(config.h_ind); config.h_ptr = np.array(config.h_ptr). else:; # string-type Hamiltonian & at least one string-type; # collapse operator; # -----------------. H_inds = np.arange(len(H)); # find inds of time-dependent terms; H_td_inds = np.array(h_stuff[2]); # find inds of constant terms; H_const_inds = np.setdiff1d(H_inds, H_td_inds); # extract time-dependent coefficients (strings or functions); config.h_tdterms = [H[k][1] for k in H_td_inds]; # combine time-INDEPENDENT terms into one.; H = np.array([np.sum(H[k] for k in H_const_inds)] +; [H[k][0] for k in H_td_inds], dtype=object); len_h = len(H); H_inds = np.arange(len_h); # store indicie",MatchSource.WIKI,docs/4.2/modules/qutip/mcsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html
https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:32836,Modifiability,config,config,32836,"ind = H.data.indices; config.h_ptr = H.data.indptr. elif config.tflag in [1, 10, 11]:; # STRING BASED TIME-DEPENDENCE; # ----------------------------. # take care of arguments for collapse operators, if any; if any(args):; for item in args.items():; config.c_args.append(item[1]); # constant Hamiltonian / string-type collapse operators; if config.tflag == 1:; H_inds = np.arange(1); H_tdterms = 0; len_h = 1; C_inds = np.arange(config.c_num); # find inds of time-dependent terms; C_td_inds = np.array(c_stuff[2]); # find inds of constant terms; C_const_inds = np.setdiff1d(C_inds, C_td_inds); # extract time-dependent coefficients (strings); C_tdterms = [c_ops[k][1] for k in C_td_inds]; # store indicies of constant collapse terms; config.c_const_inds = C_const_inds; # store indicies of time-dependent collapse terms; config.c_td_inds = C_td_inds. for k in config.c_const_inds:; H -= 0.5j * (c_ops[k].dag() * c_ops[k]); if options.tidy:; H = H.tidyup(options.atol); config.h_data = [H.data.data]; config.h_ind = [H.data.indices]; config.h_ptr = [H.data.indptr]; for k in config.c_td_inds:; op = c_ops[k][0].dag() * c_ops[k][0]; config.h_data.append(-0.5j * op.data.data); config.h_ind.append(op.data.indices); config.h_ptr.append(op.data.indptr); config.h_data = -1.0j * np.array(config.h_data); config.h_ind = np.array(config.h_ind); config.h_ptr = np.array(config.h_ptr). else:; # string-type Hamiltonian & at least one string-type; # collapse operator; # -----------------. H_inds = np.arange(len(H)); # find inds of time-dependent terms; H_td_inds = np.array(h_stuff[2]); # find inds of constant terms; H_const_inds = np.setdiff1d(H_inds, H_td_inds); # extract time-dependent coefficients (strings or functions); config.h_tdterms = [H[k][1] for k in H_td_inds]; # combine time-INDEPENDENT terms into one.; H = np.array([np.sum(H[k] for k in H_const_inds)] +; [H[k][0] for k in H_td_inds], dtype=object); len_h = len(H); H_inds = np.arange(len_h); # store indicies of time-dependent Hamiltonian",MatchSource.WIKI,docs/4.2/modules/qutip/mcsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html
https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:32869,Modifiability,config,config,32869,"ptr = H.data.indptr. elif config.tflag in [1, 10, 11]:; # STRING BASED TIME-DEPENDENCE; # ----------------------------. # take care of arguments for collapse operators, if any; if any(args):; for item in args.items():; config.c_args.append(item[1]); # constant Hamiltonian / string-type collapse operators; if config.tflag == 1:; H_inds = np.arange(1); H_tdterms = 0; len_h = 1; C_inds = np.arange(config.c_num); # find inds of time-dependent terms; C_td_inds = np.array(c_stuff[2]); # find inds of constant terms; C_const_inds = np.setdiff1d(C_inds, C_td_inds); # extract time-dependent coefficients (strings); C_tdterms = [c_ops[k][1] for k in C_td_inds]; # store indicies of constant collapse terms; config.c_const_inds = C_const_inds; # store indicies of time-dependent collapse terms; config.c_td_inds = C_td_inds. for k in config.c_const_inds:; H -= 0.5j * (c_ops[k].dag() * c_ops[k]); if options.tidy:; H = H.tidyup(options.atol); config.h_data = [H.data.data]; config.h_ind = [H.data.indices]; config.h_ptr = [H.data.indptr]; for k in config.c_td_inds:; op = c_ops[k][0].dag() * c_ops[k][0]; config.h_data.append(-0.5j * op.data.data); config.h_ind.append(op.data.indices); config.h_ptr.append(op.data.indptr); config.h_data = -1.0j * np.array(config.h_data); config.h_ind = np.array(config.h_ind); config.h_ptr = np.array(config.h_ptr). else:; # string-type Hamiltonian & at least one string-type; # collapse operator; # -----------------. H_inds = np.arange(len(H)); # find inds of time-dependent terms; H_td_inds = np.array(h_stuff[2]); # find inds of constant terms; H_const_inds = np.setdiff1d(H_inds, H_td_inds); # extract time-dependent coefficients (strings or functions); config.h_tdterms = [H[k][1] for k in H_td_inds]; # combine time-INDEPENDENT terms into one.; H = np.array([np.sum(H[k] for k in H_const_inds)] +; [H[k][0] for k in H_td_inds], dtype=object); len_h = len(H); H_inds = np.arange(len_h); # store indicies of time-dependent Hamiltonian terms; config.h_td_inds = np.ar",MatchSource.WIKI,docs/4.2/modules/qutip/mcsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html
https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:32910,Modifiability,config,config,32910,"g in [1, 10, 11]:; # STRING BASED TIME-DEPENDENCE; # ----------------------------. # take care of arguments for collapse operators, if any; if any(args):; for item in args.items():; config.c_args.append(item[1]); # constant Hamiltonian / string-type collapse operators; if config.tflag == 1:; H_inds = np.arange(1); H_tdterms = 0; len_h = 1; C_inds = np.arange(config.c_num); # find inds of time-dependent terms; C_td_inds = np.array(c_stuff[2]); # find inds of constant terms; C_const_inds = np.setdiff1d(C_inds, C_td_inds); # extract time-dependent coefficients (strings); C_tdterms = [c_ops[k][1] for k in C_td_inds]; # store indicies of constant collapse terms; config.c_const_inds = C_const_inds; # store indicies of time-dependent collapse terms; config.c_td_inds = C_td_inds. for k in config.c_const_inds:; H -= 0.5j * (c_ops[k].dag() * c_ops[k]); if options.tidy:; H = H.tidyup(options.atol); config.h_data = [H.data.data]; config.h_ind = [H.data.indices]; config.h_ptr = [H.data.indptr]; for k in config.c_td_inds:; op = c_ops[k][0].dag() * c_ops[k][0]; config.h_data.append(-0.5j * op.data.data); config.h_ind.append(op.data.indices); config.h_ptr.append(op.data.indptr); config.h_data = -1.0j * np.array(config.h_data); config.h_ind = np.array(config.h_ind); config.h_ptr = np.array(config.h_ptr). else:; # string-type Hamiltonian & at least one string-type; # collapse operator; # -----------------. H_inds = np.arange(len(H)); # find inds of time-dependent terms; H_td_inds = np.array(h_stuff[2]); # find inds of constant terms; H_const_inds = np.setdiff1d(H_inds, H_td_inds); # extract time-dependent coefficients (strings or functions); config.h_tdterms = [H[k][1] for k in H_td_inds]; # combine time-INDEPENDENT terms into one.; H = np.array([np.sum(H[k] for k in H_const_inds)] +; [H[k][0] for k in H_td_inds], dtype=object); len_h = len(H); H_inds = np.arange(len_h); # store indicies of time-dependent Hamiltonian terms; config.h_td_inds = np.arange(1, len_h); # if there are any co",MatchSource.WIKI,docs/4.2/modules/qutip/mcsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html
https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:32967,Modifiability,config,config,32967,"-------------------------. # take care of arguments for collapse operators, if any; if any(args):; for item in args.items():; config.c_args.append(item[1]); # constant Hamiltonian / string-type collapse operators; if config.tflag == 1:; H_inds = np.arange(1); H_tdterms = 0; len_h = 1; C_inds = np.arange(config.c_num); # find inds of time-dependent terms; C_td_inds = np.array(c_stuff[2]); # find inds of constant terms; C_const_inds = np.setdiff1d(C_inds, C_td_inds); # extract time-dependent coefficients (strings); C_tdterms = [c_ops[k][1] for k in C_td_inds]; # store indicies of constant collapse terms; config.c_const_inds = C_const_inds; # store indicies of time-dependent collapse terms; config.c_td_inds = C_td_inds. for k in config.c_const_inds:; H -= 0.5j * (c_ops[k].dag() * c_ops[k]); if options.tidy:; H = H.tidyup(options.atol); config.h_data = [H.data.data]; config.h_ind = [H.data.indices]; config.h_ptr = [H.data.indptr]; for k in config.c_td_inds:; op = c_ops[k][0].dag() * c_ops[k][0]; config.h_data.append(-0.5j * op.data.data); config.h_ind.append(op.data.indices); config.h_ptr.append(op.data.indptr); config.h_data = -1.0j * np.array(config.h_data); config.h_ind = np.array(config.h_ind); config.h_ptr = np.array(config.h_ptr). else:; # string-type Hamiltonian & at least one string-type; # collapse operator; # -----------------. H_inds = np.arange(len(H)); # find inds of time-dependent terms; H_td_inds = np.array(h_stuff[2]); # find inds of constant terms; H_const_inds = np.setdiff1d(H_inds, H_td_inds); # extract time-dependent coefficients (strings or functions); config.h_tdterms = [H[k][1] for k in H_td_inds]; # combine time-INDEPENDENT terms into one.; H = np.array([np.sum(H[k] for k in H_const_inds)] +; [H[k][0] for k in H_td_inds], dtype=object); len_h = len(H); H_inds = np.arange(len_h); # store indicies of time-dependent Hamiltonian terms; config.h_td_inds = np.arange(1, len_h); # if there are any collapse operators; if config.c_num > 0:; if config.tflag",MatchSource.WIKI,docs/4.2/modules/qutip/mcsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html
https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:33011,Modifiability,config,config,33011," for collapse operators, if any; if any(args):; for item in args.items():; config.c_args.append(item[1]); # constant Hamiltonian / string-type collapse operators; if config.tflag == 1:; H_inds = np.arange(1); H_tdterms = 0; len_h = 1; C_inds = np.arange(config.c_num); # find inds of time-dependent terms; C_td_inds = np.array(c_stuff[2]); # find inds of constant terms; C_const_inds = np.setdiff1d(C_inds, C_td_inds); # extract time-dependent coefficients (strings); C_tdterms = [c_ops[k][1] for k in C_td_inds]; # store indicies of constant collapse terms; config.c_const_inds = C_const_inds; # store indicies of time-dependent collapse terms; config.c_td_inds = C_td_inds. for k in config.c_const_inds:; H -= 0.5j * (c_ops[k].dag() * c_ops[k]); if options.tidy:; H = H.tidyup(options.atol); config.h_data = [H.data.data]; config.h_ind = [H.data.indices]; config.h_ptr = [H.data.indptr]; for k in config.c_td_inds:; op = c_ops[k][0].dag() * c_ops[k][0]; config.h_data.append(-0.5j * op.data.data); config.h_ind.append(op.data.indices); config.h_ptr.append(op.data.indptr); config.h_data = -1.0j * np.array(config.h_data); config.h_ind = np.array(config.h_ind); config.h_ptr = np.array(config.h_ptr). else:; # string-type Hamiltonian & at least one string-type; # collapse operator; # -----------------. H_inds = np.arange(len(H)); # find inds of time-dependent terms; H_td_inds = np.array(h_stuff[2]); # find inds of constant terms; H_const_inds = np.setdiff1d(H_inds, H_td_inds); # extract time-dependent coefficients (strings or functions); config.h_tdterms = [H[k][1] for k in H_td_inds]; # combine time-INDEPENDENT terms into one.; H = np.array([np.sum(H[k] for k in H_const_inds)] +; [H[k][0] for k in H_td_inds], dtype=object); len_h = len(H); H_inds = np.arange(len_h); # store indicies of time-dependent Hamiltonian terms; config.h_td_inds = np.arange(1, len_h); # if there are any collapse operators; if config.c_num > 0:; if config.tflag == 10:; # constant collapse operators; config.c_co",MatchSource.WIKI,docs/4.2/modules/qutip/mcsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html
https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:33049,Modifiability,config,config,33049,"any(args):; for item in args.items():; config.c_args.append(item[1]); # constant Hamiltonian / string-type collapse operators; if config.tflag == 1:; H_inds = np.arange(1); H_tdterms = 0; len_h = 1; C_inds = np.arange(config.c_num); # find inds of time-dependent terms; C_td_inds = np.array(c_stuff[2]); # find inds of constant terms; C_const_inds = np.setdiff1d(C_inds, C_td_inds); # extract time-dependent coefficients (strings); C_tdterms = [c_ops[k][1] for k in C_td_inds]; # store indicies of constant collapse terms; config.c_const_inds = C_const_inds; # store indicies of time-dependent collapse terms; config.c_td_inds = C_td_inds. for k in config.c_const_inds:; H -= 0.5j * (c_ops[k].dag() * c_ops[k]); if options.tidy:; H = H.tidyup(options.atol); config.h_data = [H.data.data]; config.h_ind = [H.data.indices]; config.h_ptr = [H.data.indptr]; for k in config.c_td_inds:; op = c_ops[k][0].dag() * c_ops[k][0]; config.h_data.append(-0.5j * op.data.data); config.h_ind.append(op.data.indices); config.h_ptr.append(op.data.indptr); config.h_data = -1.0j * np.array(config.h_data); config.h_ind = np.array(config.h_ind); config.h_ptr = np.array(config.h_ptr). else:; # string-type Hamiltonian & at least one string-type; # collapse operator; # -----------------. H_inds = np.arange(len(H)); # find inds of time-dependent terms; H_td_inds = np.array(h_stuff[2]); # find inds of constant terms; H_const_inds = np.setdiff1d(H_inds, H_td_inds); # extract time-dependent coefficients (strings or functions); config.h_tdterms = [H[k][1] for k in H_td_inds]; # combine time-INDEPENDENT terms into one.; H = np.array([np.sum(H[k] for k in H_const_inds)] +; [H[k][0] for k in H_td_inds], dtype=object); len_h = len(H); H_inds = np.arange(len_h); # store indicies of time-dependent Hamiltonian terms; config.h_td_inds = np.arange(1, len_h); # if there are any collapse operators; if config.c_num > 0:; if config.tflag == 10:; # constant collapse operators; config.c_const_inds = np.arange(config.c_num); f",MatchSource.WIKI,docs/4.2/modules/qutip/mcsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html
https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:33086,Modifiability,config,config,33086," config.c_args.append(item[1]); # constant Hamiltonian / string-type collapse operators; if config.tflag == 1:; H_inds = np.arange(1); H_tdterms = 0; len_h = 1; C_inds = np.arange(config.c_num); # find inds of time-dependent terms; C_td_inds = np.array(c_stuff[2]); # find inds of constant terms; C_const_inds = np.setdiff1d(C_inds, C_td_inds); # extract time-dependent coefficients (strings); C_tdterms = [c_ops[k][1] for k in C_td_inds]; # store indicies of constant collapse terms; config.c_const_inds = C_const_inds; # store indicies of time-dependent collapse terms; config.c_td_inds = C_td_inds. for k in config.c_const_inds:; H -= 0.5j * (c_ops[k].dag() * c_ops[k]); if options.tidy:; H = H.tidyup(options.atol); config.h_data = [H.data.data]; config.h_ind = [H.data.indices]; config.h_ptr = [H.data.indptr]; for k in config.c_td_inds:; op = c_ops[k][0].dag() * c_ops[k][0]; config.h_data.append(-0.5j * op.data.data); config.h_ind.append(op.data.indices); config.h_ptr.append(op.data.indptr); config.h_data = -1.0j * np.array(config.h_data); config.h_ind = np.array(config.h_ind); config.h_ptr = np.array(config.h_ptr). else:; # string-type Hamiltonian & at least one string-type; # collapse operator; # -----------------. H_inds = np.arange(len(H)); # find inds of time-dependent terms; H_td_inds = np.array(h_stuff[2]); # find inds of constant terms; H_const_inds = np.setdiff1d(H_inds, H_td_inds); # extract time-dependent coefficients (strings or functions); config.h_tdterms = [H[k][1] for k in H_td_inds]; # combine time-INDEPENDENT terms into one.; H = np.array([np.sum(H[k] for k in H_const_inds)] +; [H[k][0] for k in H_td_inds], dtype=object); len_h = len(H); H_inds = np.arange(len_h); # store indicies of time-dependent Hamiltonian terms; config.h_td_inds = np.arange(1, len_h); # if there are any collapse operators; if config.c_num > 0:; if config.tflag == 10:; # constant collapse operators; config.c_const_inds = np.arange(config.c_num); for k in config.c_const_inds:; H[0] -=",MatchSource.WIKI,docs/4.2/modules/qutip/mcsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html
https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:33119,Modifiability,config,config,33119,"constant Hamiltonian / string-type collapse operators; if config.tflag == 1:; H_inds = np.arange(1); H_tdterms = 0; len_h = 1; C_inds = np.arange(config.c_num); # find inds of time-dependent terms; C_td_inds = np.array(c_stuff[2]); # find inds of constant terms; C_const_inds = np.setdiff1d(C_inds, C_td_inds); # extract time-dependent coefficients (strings); C_tdterms = [c_ops[k][1] for k in C_td_inds]; # store indicies of constant collapse terms; config.c_const_inds = C_const_inds; # store indicies of time-dependent collapse terms; config.c_td_inds = C_td_inds. for k in config.c_const_inds:; H -= 0.5j * (c_ops[k].dag() * c_ops[k]); if options.tidy:; H = H.tidyup(options.atol); config.h_data = [H.data.data]; config.h_ind = [H.data.indices]; config.h_ptr = [H.data.indptr]; for k in config.c_td_inds:; op = c_ops[k][0].dag() * c_ops[k][0]; config.h_data.append(-0.5j * op.data.data); config.h_ind.append(op.data.indices); config.h_ptr.append(op.data.indptr); config.h_data = -1.0j * np.array(config.h_data); config.h_ind = np.array(config.h_ind); config.h_ptr = np.array(config.h_ptr). else:; # string-type Hamiltonian & at least one string-type; # collapse operator; # -----------------. H_inds = np.arange(len(H)); # find inds of time-dependent terms; H_td_inds = np.array(h_stuff[2]); # find inds of constant terms; H_const_inds = np.setdiff1d(H_inds, H_td_inds); # extract time-dependent coefficients (strings or functions); config.h_tdterms = [H[k][1] for k in H_td_inds]; # combine time-INDEPENDENT terms into one.; H = np.array([np.sum(H[k] for k in H_const_inds)] +; [H[k][0] for k in H_td_inds], dtype=object); len_h = len(H); H_inds = np.arange(len_h); # store indicies of time-dependent Hamiltonian terms; config.h_td_inds = np.arange(1, len_h); # if there are any collapse operators; if config.c_num > 0:; if config.tflag == 10:; # constant collapse operators; config.c_const_inds = np.arange(config.c_num); for k in config.c_const_inds:; H[0] -= 0.5j * (c_ops[k].dag() * c_ops[k])",MatchSource.WIKI,docs/4.2/modules/qutip/mcsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html
https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:33135,Modifiability,config,config,33135,"onian / string-type collapse operators; if config.tflag == 1:; H_inds = np.arange(1); H_tdterms = 0; len_h = 1; C_inds = np.arange(config.c_num); # find inds of time-dependent terms; C_td_inds = np.array(c_stuff[2]); # find inds of constant terms; C_const_inds = np.setdiff1d(C_inds, C_td_inds); # extract time-dependent coefficients (strings); C_tdterms = [c_ops[k][1] for k in C_td_inds]; # store indicies of constant collapse terms; config.c_const_inds = C_const_inds; # store indicies of time-dependent collapse terms; config.c_td_inds = C_td_inds. for k in config.c_const_inds:; H -= 0.5j * (c_ops[k].dag() * c_ops[k]); if options.tidy:; H = H.tidyup(options.atol); config.h_data = [H.data.data]; config.h_ind = [H.data.indices]; config.h_ptr = [H.data.indptr]; for k in config.c_td_inds:; op = c_ops[k][0].dag() * c_ops[k][0]; config.h_data.append(-0.5j * op.data.data); config.h_ind.append(op.data.indices); config.h_ptr.append(op.data.indptr); config.h_data = -1.0j * np.array(config.h_data); config.h_ind = np.array(config.h_ind); config.h_ptr = np.array(config.h_ptr). else:; # string-type Hamiltonian & at least one string-type; # collapse operator; # -----------------. H_inds = np.arange(len(H)); # find inds of time-dependent terms; H_td_inds = np.array(h_stuff[2]); # find inds of constant terms; H_const_inds = np.setdiff1d(H_inds, H_td_inds); # extract time-dependent coefficients (strings or functions); config.h_tdterms = [H[k][1] for k in H_td_inds]; # combine time-INDEPENDENT terms into one.; H = np.array([np.sum(H[k] for k in H_const_inds)] +; [H[k][0] for k in H_td_inds], dtype=object); len_h = len(H); H_inds = np.arange(len_h); # store indicies of time-dependent Hamiltonian terms; config.h_td_inds = np.arange(1, len_h); # if there are any collapse operators; if config.c_num > 0:; if config.tflag == 10:; # constant collapse operators; config.c_const_inds = np.arange(config.c_num); for k in config.c_const_inds:; H[0] -= 0.5j * (c_ops[k].dag() * c_ops[k]); C_inds = np.",MatchSource.WIKI,docs/4.2/modules/qutip/mcsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html
https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:33159,Modifiability,config,config,33159,"pse operators; if config.tflag == 1:; H_inds = np.arange(1); H_tdterms = 0; len_h = 1; C_inds = np.arange(config.c_num); # find inds of time-dependent terms; C_td_inds = np.array(c_stuff[2]); # find inds of constant terms; C_const_inds = np.setdiff1d(C_inds, C_td_inds); # extract time-dependent coefficients (strings); C_tdterms = [c_ops[k][1] for k in C_td_inds]; # store indicies of constant collapse terms; config.c_const_inds = C_const_inds; # store indicies of time-dependent collapse terms; config.c_td_inds = C_td_inds. for k in config.c_const_inds:; H -= 0.5j * (c_ops[k].dag() * c_ops[k]); if options.tidy:; H = H.tidyup(options.atol); config.h_data = [H.data.data]; config.h_ind = [H.data.indices]; config.h_ptr = [H.data.indptr]; for k in config.c_td_inds:; op = c_ops[k][0].dag() * c_ops[k][0]; config.h_data.append(-0.5j * op.data.data); config.h_ind.append(op.data.indices); config.h_ptr.append(op.data.indptr); config.h_data = -1.0j * np.array(config.h_data); config.h_ind = np.array(config.h_ind); config.h_ptr = np.array(config.h_ptr). else:; # string-type Hamiltonian & at least one string-type; # collapse operator; # -----------------. H_inds = np.arange(len(H)); # find inds of time-dependent terms; H_td_inds = np.array(h_stuff[2]); # find inds of constant terms; H_const_inds = np.setdiff1d(H_inds, H_td_inds); # extract time-dependent coefficients (strings or functions); config.h_tdterms = [H[k][1] for k in H_td_inds]; # combine time-INDEPENDENT terms into one.; H = np.array([np.sum(H[k] for k in H_const_inds)] +; [H[k][0] for k in H_td_inds], dtype=object); len_h = len(H); H_inds = np.arange(len_h); # store indicies of time-dependent Hamiltonian terms; config.h_td_inds = np.arange(1, len_h); # if there are any collapse operators; if config.c_num > 0:; if config.tflag == 10:; # constant collapse operators; config.c_const_inds = np.arange(config.c_num); for k in config.c_const_inds:; H[0] -= 0.5j * (c_ops[k].dag() * c_ops[k]); C_inds = np.arange(config.c_num); C_td",MatchSource.WIKI,docs/4.2/modules/qutip/mcsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html
https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:33174,Modifiability,config,config,33174," if config.tflag == 1:; H_inds = np.arange(1); H_tdterms = 0; len_h = 1; C_inds = np.arange(config.c_num); # find inds of time-dependent terms; C_td_inds = np.array(c_stuff[2]); # find inds of constant terms; C_const_inds = np.setdiff1d(C_inds, C_td_inds); # extract time-dependent coefficients (strings); C_tdterms = [c_ops[k][1] for k in C_td_inds]; # store indicies of constant collapse terms; config.c_const_inds = C_const_inds; # store indicies of time-dependent collapse terms; config.c_td_inds = C_td_inds. for k in config.c_const_inds:; H -= 0.5j * (c_ops[k].dag() * c_ops[k]); if options.tidy:; H = H.tidyup(options.atol); config.h_data = [H.data.data]; config.h_ind = [H.data.indices]; config.h_ptr = [H.data.indptr]; for k in config.c_td_inds:; op = c_ops[k][0].dag() * c_ops[k][0]; config.h_data.append(-0.5j * op.data.data); config.h_ind.append(op.data.indices); config.h_ptr.append(op.data.indptr); config.h_data = -1.0j * np.array(config.h_data); config.h_ind = np.array(config.h_ind); config.h_ptr = np.array(config.h_ptr). else:; # string-type Hamiltonian & at least one string-type; # collapse operator; # -----------------. H_inds = np.arange(len(H)); # find inds of time-dependent terms; H_td_inds = np.array(h_stuff[2]); # find inds of constant terms; H_const_inds = np.setdiff1d(H_inds, H_td_inds); # extract time-dependent coefficients (strings or functions); config.h_tdterms = [H[k][1] for k in H_td_inds]; # combine time-INDEPENDENT terms into one.; H = np.array([np.sum(H[k] for k in H_const_inds)] +; [H[k][0] for k in H_td_inds], dtype=object); len_h = len(H); H_inds = np.arange(len_h); # store indicies of time-dependent Hamiltonian terms; config.h_td_inds = np.arange(1, len_h); # if there are any collapse operators; if config.c_num > 0:; if config.tflag == 10:; # constant collapse operators; config.c_const_inds = np.arange(config.c_num); for k in config.c_const_inds:; H[0] -= 0.5j * (c_ops[k].dag() * c_ops[k]); C_inds = np.arange(config.c_num); C_tdterms = np.arr",MatchSource.WIKI,docs/4.2/modules/qutip/mcsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html
https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:33198,Modifiability,config,config,33198,"_inds = np.arange(1); H_tdterms = 0; len_h = 1; C_inds = np.arange(config.c_num); # find inds of time-dependent terms; C_td_inds = np.array(c_stuff[2]); # find inds of constant terms; C_const_inds = np.setdiff1d(C_inds, C_td_inds); # extract time-dependent coefficients (strings); C_tdterms = [c_ops[k][1] for k in C_td_inds]; # store indicies of constant collapse terms; config.c_const_inds = C_const_inds; # store indicies of time-dependent collapse terms; config.c_td_inds = C_td_inds. for k in config.c_const_inds:; H -= 0.5j * (c_ops[k].dag() * c_ops[k]); if options.tidy:; H = H.tidyup(options.atol); config.h_data = [H.data.data]; config.h_ind = [H.data.indices]; config.h_ptr = [H.data.indptr]; for k in config.c_td_inds:; op = c_ops[k][0].dag() * c_ops[k][0]; config.h_data.append(-0.5j * op.data.data); config.h_ind.append(op.data.indices); config.h_ptr.append(op.data.indptr); config.h_data = -1.0j * np.array(config.h_data); config.h_ind = np.array(config.h_ind); config.h_ptr = np.array(config.h_ptr). else:; # string-type Hamiltonian & at least one string-type; # collapse operator; # -----------------. H_inds = np.arange(len(H)); # find inds of time-dependent terms; H_td_inds = np.array(h_stuff[2]); # find inds of constant terms; H_const_inds = np.setdiff1d(H_inds, H_td_inds); # extract time-dependent coefficients (strings or functions); config.h_tdterms = [H[k][1] for k in H_td_inds]; # combine time-INDEPENDENT terms into one.; H = np.array([np.sum(H[k] for k in H_const_inds)] +; [H[k][0] for k in H_td_inds], dtype=object); len_h = len(H); H_inds = np.arange(len_h); # store indicies of time-dependent Hamiltonian terms; config.h_td_inds = np.arange(1, len_h); # if there are any collapse operators; if config.c_num > 0:; if config.tflag == 10:; # constant collapse operators; config.c_const_inds = np.arange(config.c_num); for k in config.c_const_inds:; H[0] -= 0.5j * (c_ops[k].dag() * c_ops[k]); C_inds = np.arange(config.c_num); C_tdterms = np.array([]); else:; # some tim",MatchSource.WIKI,docs/4.2/modules/qutip/mcsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html
https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:33556,Modifiability,config,config,33556,"C_td_inds]; # store indicies of constant collapse terms; config.c_const_inds = C_const_inds; # store indicies of time-dependent collapse terms; config.c_td_inds = C_td_inds. for k in config.c_const_inds:; H -= 0.5j * (c_ops[k].dag() * c_ops[k]); if options.tidy:; H = H.tidyup(options.atol); config.h_data = [H.data.data]; config.h_ind = [H.data.indices]; config.h_ptr = [H.data.indptr]; for k in config.c_td_inds:; op = c_ops[k][0].dag() * c_ops[k][0]; config.h_data.append(-0.5j * op.data.data); config.h_ind.append(op.data.indices); config.h_ptr.append(op.data.indptr); config.h_data = -1.0j * np.array(config.h_data); config.h_ind = np.array(config.h_ind); config.h_ptr = np.array(config.h_ptr). else:; # string-type Hamiltonian & at least one string-type; # collapse operator; # -----------------. H_inds = np.arange(len(H)); # find inds of time-dependent terms; H_td_inds = np.array(h_stuff[2]); # find inds of constant terms; H_const_inds = np.setdiff1d(H_inds, H_td_inds); # extract time-dependent coefficients (strings or functions); config.h_tdterms = [H[k][1] for k in H_td_inds]; # combine time-INDEPENDENT terms into one.; H = np.array([np.sum(H[k] for k in H_const_inds)] +; [H[k][0] for k in H_td_inds], dtype=object); len_h = len(H); H_inds = np.arange(len_h); # store indicies of time-dependent Hamiltonian terms; config.h_td_inds = np.arange(1, len_h); # if there are any collapse operators; if config.c_num > 0:; if config.tflag == 10:; # constant collapse operators; config.c_const_inds = np.arange(config.c_num); for k in config.c_const_inds:; H[0] -= 0.5j * (c_ops[k].dag() * c_ops[k]); C_inds = np.arange(config.c_num); C_tdterms = np.array([]); else:; # some time-dependent collapse terms; C_inds = np.arange(config.c_num); # find inds of time-dependent terms; C_td_inds = np.array(c_stuff[2]); # find inds of constant terms; C_const_inds = np.setdiff1d(C_inds, C_td_inds); C_tdterms = [c_ops[k][1] for k in C_td_inds]; # extract time-dependent coefficients (strings); # store ",MatchSource.WIKI,docs/4.2/modules/qutip/mcsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html
https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:33844,Modifiability,config,config,33844,"_data = [H.data.data]; config.h_ind = [H.data.indices]; config.h_ptr = [H.data.indptr]; for k in config.c_td_inds:; op = c_ops[k][0].dag() * c_ops[k][0]; config.h_data.append(-0.5j * op.data.data); config.h_ind.append(op.data.indices); config.h_ptr.append(op.data.indptr); config.h_data = -1.0j * np.array(config.h_data); config.h_ind = np.array(config.h_ind); config.h_ptr = np.array(config.h_ptr). else:; # string-type Hamiltonian & at least one string-type; # collapse operator; # -----------------. H_inds = np.arange(len(H)); # find inds of time-dependent terms; H_td_inds = np.array(h_stuff[2]); # find inds of constant terms; H_const_inds = np.setdiff1d(H_inds, H_td_inds); # extract time-dependent coefficients (strings or functions); config.h_tdterms = [H[k][1] for k in H_td_inds]; # combine time-INDEPENDENT terms into one.; H = np.array([np.sum(H[k] for k in H_const_inds)] +; [H[k][0] for k in H_td_inds], dtype=object); len_h = len(H); H_inds = np.arange(len_h); # store indicies of time-dependent Hamiltonian terms; config.h_td_inds = np.arange(1, len_h); # if there are any collapse operators; if config.c_num > 0:; if config.tflag == 10:; # constant collapse operators; config.c_const_inds = np.arange(config.c_num); for k in config.c_const_inds:; H[0] -= 0.5j * (c_ops[k].dag() * c_ops[k]); C_inds = np.arange(config.c_num); C_tdterms = np.array([]); else:; # some time-dependent collapse terms; C_inds = np.arange(config.c_num); # find inds of time-dependent terms; C_td_inds = np.array(c_stuff[2]); # find inds of constant terms; C_const_inds = np.setdiff1d(C_inds, C_td_inds); C_tdterms = [c_ops[k][1] for k in C_td_inds]; # extract time-dependent coefficients (strings); # store indicies of constant collapse terms; config.c_const_inds = C_const_inds; # store indicies of time-dependent collapse terms; config.c_td_inds = C_td_inds; for k in config.c_const_inds:; H[0] -= 0.5j * (c_ops[k].dag() * c_ops[k]); else:; # set empty objects if no collapse operators; C_const_inds = np",MatchSource.WIKI,docs/4.2/modules/qutip/mcsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html
https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:33926,Modifiability,config,config,33926,"; for k in config.c_td_inds:; op = c_ops[k][0].dag() * c_ops[k][0]; config.h_data.append(-0.5j * op.data.data); config.h_ind.append(op.data.indices); config.h_ptr.append(op.data.indptr); config.h_data = -1.0j * np.array(config.h_data); config.h_ind = np.array(config.h_ind); config.h_ptr = np.array(config.h_ptr). else:; # string-type Hamiltonian & at least one string-type; # collapse operator; # -----------------. H_inds = np.arange(len(H)); # find inds of time-dependent terms; H_td_inds = np.array(h_stuff[2]); # find inds of constant terms; H_const_inds = np.setdiff1d(H_inds, H_td_inds); # extract time-dependent coefficients (strings or functions); config.h_tdterms = [H[k][1] for k in H_td_inds]; # combine time-INDEPENDENT terms into one.; H = np.array([np.sum(H[k] for k in H_const_inds)] +; [H[k][0] for k in H_td_inds], dtype=object); len_h = len(H); H_inds = np.arange(len_h); # store indicies of time-dependent Hamiltonian terms; config.h_td_inds = np.arange(1, len_h); # if there are any collapse operators; if config.c_num > 0:; if config.tflag == 10:; # constant collapse operators; config.c_const_inds = np.arange(config.c_num); for k in config.c_const_inds:; H[0] -= 0.5j * (c_ops[k].dag() * c_ops[k]); C_inds = np.arange(config.c_num); C_tdterms = np.array([]); else:; # some time-dependent collapse terms; C_inds = np.arange(config.c_num); # find inds of time-dependent terms; C_td_inds = np.array(c_stuff[2]); # find inds of constant terms; C_const_inds = np.setdiff1d(C_inds, C_td_inds); C_tdterms = [c_ops[k][1] for k in C_td_inds]; # extract time-dependent coefficients (strings); # store indicies of constant collapse terms; config.c_const_inds = C_const_inds; # store indicies of time-dependent collapse terms; config.c_td_inds = C_td_inds; for k in config.c_const_inds:; H[0] -= 0.5j * (c_ops[k].dag() * c_ops[k]); else:; # set empty objects if no collapse operators; C_const_inds = np.arange(config.c_num); config.c_const_inds = np.arange(config.c_num); config.c_td_inds ",MatchSource.WIKI,docs/4.2/modules/qutip/mcsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html
https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:33948,Modifiability,config,config,33948,"].dag() * c_ops[k][0]; config.h_data.append(-0.5j * op.data.data); config.h_ind.append(op.data.indices); config.h_ptr.append(op.data.indptr); config.h_data = -1.0j * np.array(config.h_data); config.h_ind = np.array(config.h_ind); config.h_ptr = np.array(config.h_ptr). else:; # string-type Hamiltonian & at least one string-type; # collapse operator; # -----------------. H_inds = np.arange(len(H)); # find inds of time-dependent terms; H_td_inds = np.array(h_stuff[2]); # find inds of constant terms; H_const_inds = np.setdiff1d(H_inds, H_td_inds); # extract time-dependent coefficients (strings or functions); config.h_tdterms = [H[k][1] for k in H_td_inds]; # combine time-INDEPENDENT terms into one.; H = np.array([np.sum(H[k] for k in H_const_inds)] +; [H[k][0] for k in H_td_inds], dtype=object); len_h = len(H); H_inds = np.arange(len_h); # store indicies of time-dependent Hamiltonian terms; config.h_td_inds = np.arange(1, len_h); # if there are any collapse operators; if config.c_num > 0:; if config.tflag == 10:; # constant collapse operators; config.c_const_inds = np.arange(config.c_num); for k in config.c_const_inds:; H[0] -= 0.5j * (c_ops[k].dag() * c_ops[k]); C_inds = np.arange(config.c_num); C_tdterms = np.array([]); else:; # some time-dependent collapse terms; C_inds = np.arange(config.c_num); # find inds of time-dependent terms; C_td_inds = np.array(c_stuff[2]); # find inds of constant terms; C_const_inds = np.setdiff1d(C_inds, C_td_inds); C_tdterms = [c_ops[k][1] for k in C_td_inds]; # extract time-dependent coefficients (strings); # store indicies of constant collapse terms; config.c_const_inds = C_const_inds; # store indicies of time-dependent collapse terms; config.c_td_inds = C_td_inds; for k in config.c_const_inds:; H[0] -= 0.5j * (c_ops[k].dag() * c_ops[k]); else:; # set empty objects if no collapse operators; C_const_inds = np.arange(config.c_num); config.c_const_inds = np.arange(config.c_num); config.c_td_inds = np.array([]); C_tdterms = np.array([]); C_",MatchSource.WIKI,docs/4.2/modules/qutip/mcsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html
https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:34000,Modifiability,config,config,34000,"append(-0.5j * op.data.data); config.h_ind.append(op.data.indices); config.h_ptr.append(op.data.indptr); config.h_data = -1.0j * np.array(config.h_data); config.h_ind = np.array(config.h_ind); config.h_ptr = np.array(config.h_ptr). else:; # string-type Hamiltonian & at least one string-type; # collapse operator; # -----------------. H_inds = np.arange(len(H)); # find inds of time-dependent terms; H_td_inds = np.array(h_stuff[2]); # find inds of constant terms; H_const_inds = np.setdiff1d(H_inds, H_td_inds); # extract time-dependent coefficients (strings or functions); config.h_tdterms = [H[k][1] for k in H_td_inds]; # combine time-INDEPENDENT terms into one.; H = np.array([np.sum(H[k] for k in H_const_inds)] +; [H[k][0] for k in H_td_inds], dtype=object); len_h = len(H); H_inds = np.arange(len_h); # store indicies of time-dependent Hamiltonian terms; config.h_td_inds = np.arange(1, len_h); # if there are any collapse operators; if config.c_num > 0:; if config.tflag == 10:; # constant collapse operators; config.c_const_inds = np.arange(config.c_num); for k in config.c_const_inds:; H[0] -= 0.5j * (c_ops[k].dag() * c_ops[k]); C_inds = np.arange(config.c_num); C_tdterms = np.array([]); else:; # some time-dependent collapse terms; C_inds = np.arange(config.c_num); # find inds of time-dependent terms; C_td_inds = np.array(c_stuff[2]); # find inds of constant terms; C_const_inds = np.setdiff1d(C_inds, C_td_inds); C_tdterms = [c_ops[k][1] for k in C_td_inds]; # extract time-dependent coefficients (strings); # store indicies of constant collapse terms; config.c_const_inds = C_const_inds; # store indicies of time-dependent collapse terms; config.c_td_inds = C_td_inds; for k in config.c_const_inds:; H[0] -= 0.5j * (c_ops[k].dag() * c_ops[k]); else:; # set empty objects if no collapse operators; C_const_inds = np.arange(config.c_num); config.c_const_inds = np.arange(config.c_num); config.c_td_inds = np.array([]); C_tdterms = np.array([]); C_inds = np.array([]). # tidyup; if opt",MatchSource.WIKI,docs/4.2/modules/qutip/mcsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html
https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:34032,Modifiability,config,config,34032,"p.data.indices); config.h_ptr.append(op.data.indptr); config.h_data = -1.0j * np.array(config.h_data); config.h_ind = np.array(config.h_ind); config.h_ptr = np.array(config.h_ptr). else:; # string-type Hamiltonian & at least one string-type; # collapse operator; # -----------------. H_inds = np.arange(len(H)); # find inds of time-dependent terms; H_td_inds = np.array(h_stuff[2]); # find inds of constant terms; H_const_inds = np.setdiff1d(H_inds, H_td_inds); # extract time-dependent coefficients (strings or functions); config.h_tdterms = [H[k][1] for k in H_td_inds]; # combine time-INDEPENDENT terms into one.; H = np.array([np.sum(H[k] for k in H_const_inds)] +; [H[k][0] for k in H_td_inds], dtype=object); len_h = len(H); H_inds = np.arange(len_h); # store indicies of time-dependent Hamiltonian terms; config.h_td_inds = np.arange(1, len_h); # if there are any collapse operators; if config.c_num > 0:; if config.tflag == 10:; # constant collapse operators; config.c_const_inds = np.arange(config.c_num); for k in config.c_const_inds:; H[0] -= 0.5j * (c_ops[k].dag() * c_ops[k]); C_inds = np.arange(config.c_num); C_tdterms = np.array([]); else:; # some time-dependent collapse terms; C_inds = np.arange(config.c_num); # find inds of time-dependent terms; C_td_inds = np.array(c_stuff[2]); # find inds of constant terms; C_const_inds = np.setdiff1d(C_inds, C_td_inds); C_tdterms = [c_ops[k][1] for k in C_td_inds]; # extract time-dependent coefficients (strings); # store indicies of constant collapse terms; config.c_const_inds = C_const_inds; # store indicies of time-dependent collapse terms; config.c_td_inds = C_td_inds; for k in config.c_const_inds:; H[0] -= 0.5j * (c_ops[k].dag() * c_ops[k]); else:; # set empty objects if no collapse operators; C_const_inds = np.arange(config.c_num); config.c_const_inds = np.arange(config.c_num); config.c_td_inds = np.array([]); C_tdterms = np.array([]); C_inds = np.array([]). # tidyup; if options.tidy:; H = np.array([H[k].tidyup(options.atol)",MatchSource.WIKI,docs/4.2/modules/qutip/mcsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html
https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:34056,Modifiability,config,config,34056,"nfig.h_ptr.append(op.data.indptr); config.h_data = -1.0j * np.array(config.h_data); config.h_ind = np.array(config.h_ind); config.h_ptr = np.array(config.h_ptr). else:; # string-type Hamiltonian & at least one string-type; # collapse operator; # -----------------. H_inds = np.arange(len(H)); # find inds of time-dependent terms; H_td_inds = np.array(h_stuff[2]); # find inds of constant terms; H_const_inds = np.setdiff1d(H_inds, H_td_inds); # extract time-dependent coefficients (strings or functions); config.h_tdterms = [H[k][1] for k in H_td_inds]; # combine time-INDEPENDENT terms into one.; H = np.array([np.sum(H[k] for k in H_const_inds)] +; [H[k][0] for k in H_td_inds], dtype=object); len_h = len(H); H_inds = np.arange(len_h); # store indicies of time-dependent Hamiltonian terms; config.h_td_inds = np.arange(1, len_h); # if there are any collapse operators; if config.c_num > 0:; if config.tflag == 10:; # constant collapse operators; config.c_const_inds = np.arange(config.c_num); for k in config.c_const_inds:; H[0] -= 0.5j * (c_ops[k].dag() * c_ops[k]); C_inds = np.arange(config.c_num); C_tdterms = np.array([]); else:; # some time-dependent collapse terms; C_inds = np.arange(config.c_num); # find inds of time-dependent terms; C_td_inds = np.array(c_stuff[2]); # find inds of constant terms; C_const_inds = np.setdiff1d(C_inds, C_td_inds); C_tdterms = [c_ops[k][1] for k in C_td_inds]; # extract time-dependent coefficients (strings); # store indicies of constant collapse terms; config.c_const_inds = C_const_inds; # store indicies of time-dependent collapse terms; config.c_td_inds = C_td_inds; for k in config.c_const_inds:; H[0] -= 0.5j * (c_ops[k].dag() * c_ops[k]); else:; # set empty objects if no collapse operators; C_const_inds = np.arange(config.c_num); config.c_const_inds = np.arange(config.c_num); config.c_td_inds = np.array([]); C_tdterms = np.array([]); C_inds = np.array([]). # tidyup; if options.tidy:; H = np.array([H[k].tidyup(options.atol); for k in range(le",MatchSource.WIKI,docs/4.2/modules/qutip/mcsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html
https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:34141,Modifiability,config,config,34141,".h_ind = np.array(config.h_ind); config.h_ptr = np.array(config.h_ptr). else:; # string-type Hamiltonian & at least one string-type; # collapse operator; # -----------------. H_inds = np.arange(len(H)); # find inds of time-dependent terms; H_td_inds = np.array(h_stuff[2]); # find inds of constant terms; H_const_inds = np.setdiff1d(H_inds, H_td_inds); # extract time-dependent coefficients (strings or functions); config.h_tdterms = [H[k][1] for k in H_td_inds]; # combine time-INDEPENDENT terms into one.; H = np.array([np.sum(H[k] for k in H_const_inds)] +; [H[k][0] for k in H_td_inds], dtype=object); len_h = len(H); H_inds = np.arange(len_h); # store indicies of time-dependent Hamiltonian terms; config.h_td_inds = np.arange(1, len_h); # if there are any collapse operators; if config.c_num > 0:; if config.tflag == 10:; # constant collapse operators; config.c_const_inds = np.arange(config.c_num); for k in config.c_const_inds:; H[0] -= 0.5j * (c_ops[k].dag() * c_ops[k]); C_inds = np.arange(config.c_num); C_tdterms = np.array([]); else:; # some time-dependent collapse terms; C_inds = np.arange(config.c_num); # find inds of time-dependent terms; C_td_inds = np.array(c_stuff[2]); # find inds of constant terms; C_const_inds = np.setdiff1d(C_inds, C_td_inds); C_tdterms = [c_ops[k][1] for k in C_td_inds]; # extract time-dependent coefficients (strings); # store indicies of constant collapse terms; config.c_const_inds = C_const_inds; # store indicies of time-dependent collapse terms; config.c_td_inds = C_td_inds; for k in config.c_const_inds:; H[0] -= 0.5j * (c_ops[k].dag() * c_ops[k]); else:; # set empty objects if no collapse operators; C_const_inds = np.arange(config.c_num); config.c_const_inds = np.arange(config.c_num); config.c_td_inds = np.array([]); C_tdterms = np.array([]); C_inds = np.array([]). # tidyup; if options.tidy:; H = np.array([H[k].tidyup(options.atol); for k in range(len_h)], dtype=object); # construct data sets; config.h_data = [H[k].data.data for k in rang",MatchSource.WIKI,docs/4.2/modules/qutip/mcsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html
https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:34246,Modifiability,config,config,34246,"& at least one string-type; # collapse operator; # -----------------. H_inds = np.arange(len(H)); # find inds of time-dependent terms; H_td_inds = np.array(h_stuff[2]); # find inds of constant terms; H_const_inds = np.setdiff1d(H_inds, H_td_inds); # extract time-dependent coefficients (strings or functions); config.h_tdterms = [H[k][1] for k in H_td_inds]; # combine time-INDEPENDENT terms into one.; H = np.array([np.sum(H[k] for k in H_const_inds)] +; [H[k][0] for k in H_td_inds], dtype=object); len_h = len(H); H_inds = np.arange(len_h); # store indicies of time-dependent Hamiltonian terms; config.h_td_inds = np.arange(1, len_h); # if there are any collapse operators; if config.c_num > 0:; if config.tflag == 10:; # constant collapse operators; config.c_const_inds = np.arange(config.c_num); for k in config.c_const_inds:; H[0] -= 0.5j * (c_ops[k].dag() * c_ops[k]); C_inds = np.arange(config.c_num); C_tdterms = np.array([]); else:; # some time-dependent collapse terms; C_inds = np.arange(config.c_num); # find inds of time-dependent terms; C_td_inds = np.array(c_stuff[2]); # find inds of constant terms; C_const_inds = np.setdiff1d(C_inds, C_td_inds); C_tdterms = [c_ops[k][1] for k in C_td_inds]; # extract time-dependent coefficients (strings); # store indicies of constant collapse terms; config.c_const_inds = C_const_inds; # store indicies of time-dependent collapse terms; config.c_td_inds = C_td_inds; for k in config.c_const_inds:; H[0] -= 0.5j * (c_ops[k].dag() * c_ops[k]); else:; # set empty objects if no collapse operators; C_const_inds = np.arange(config.c_num); config.c_const_inds = np.arange(config.c_num); config.c_td_inds = np.array([]); C_tdterms = np.array([]); C_inds = np.array([]). # tidyup; if options.tidy:; H = np.array([H[k].tidyup(options.atol); for k in range(len_h)], dtype=object); # construct data sets; config.h_data = [H[k].data.data for k in range(len_h)]; config.h_ind = [H[k].data.indices for k in range(len_h)]; config.h_ptr = [H[k].data.indptr for",MatchSource.WIKI,docs/4.2/modules/qutip/mcsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html
https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:34551,Modifiability,config,config,34551,"ff1d(H_inds, H_td_inds); # extract time-dependent coefficients (strings or functions); config.h_tdterms = [H[k][1] for k in H_td_inds]; # combine time-INDEPENDENT terms into one.; H = np.array([np.sum(H[k] for k in H_const_inds)] +; [H[k][0] for k in H_td_inds], dtype=object); len_h = len(H); H_inds = np.arange(len_h); # store indicies of time-dependent Hamiltonian terms; config.h_td_inds = np.arange(1, len_h); # if there are any collapse operators; if config.c_num > 0:; if config.tflag == 10:; # constant collapse operators; config.c_const_inds = np.arange(config.c_num); for k in config.c_const_inds:; H[0] -= 0.5j * (c_ops[k].dag() * c_ops[k]); C_inds = np.arange(config.c_num); C_tdterms = np.array([]); else:; # some time-dependent collapse terms; C_inds = np.arange(config.c_num); # find inds of time-dependent terms; C_td_inds = np.array(c_stuff[2]); # find inds of constant terms; C_const_inds = np.setdiff1d(C_inds, C_td_inds); C_tdterms = [c_ops[k][1] for k in C_td_inds]; # extract time-dependent coefficients (strings); # store indicies of constant collapse terms; config.c_const_inds = C_const_inds; # store indicies of time-dependent collapse terms; config.c_td_inds = C_td_inds; for k in config.c_const_inds:; H[0] -= 0.5j * (c_ops[k].dag() * c_ops[k]); else:; # set empty objects if no collapse operators; C_const_inds = np.arange(config.c_num); config.c_const_inds = np.arange(config.c_num); config.c_td_inds = np.array([]); C_tdterms = np.array([]); C_inds = np.array([]). # tidyup; if options.tidy:; H = np.array([H[k].tidyup(options.atol); for k in range(len_h)], dtype=object); # construct data sets; config.h_data = [H[k].data.data for k in range(len_h)]; config.h_ind = [H[k].data.indices for k in range(len_h)]; config.h_ptr = [H[k].data.indptr for k in range(len_h)]; for k in config.c_td_inds:; config.h_data.append(-0.5j * config.n_ops_data[k]); config.h_ind.append(config.n_ops_ind[k]); config.h_ptr.append(config.n_ops_ptr[k]); config.h_data = -1.0j * np.array(config",MatchSource.WIKI,docs/4.2/modules/qutip/mcsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html
https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:34638,Modifiability,config,config,34638,"s]; # combine time-INDEPENDENT terms into one.; H = np.array([np.sum(H[k] for k in H_const_inds)] +; [H[k][0] for k in H_td_inds], dtype=object); len_h = len(H); H_inds = np.arange(len_h); # store indicies of time-dependent Hamiltonian terms; config.h_td_inds = np.arange(1, len_h); # if there are any collapse operators; if config.c_num > 0:; if config.tflag == 10:; # constant collapse operators; config.c_const_inds = np.arange(config.c_num); for k in config.c_const_inds:; H[0] -= 0.5j * (c_ops[k].dag() * c_ops[k]); C_inds = np.arange(config.c_num); C_tdterms = np.array([]); else:; # some time-dependent collapse terms; C_inds = np.arange(config.c_num); # find inds of time-dependent terms; C_td_inds = np.array(c_stuff[2]); # find inds of constant terms; C_const_inds = np.setdiff1d(C_inds, C_td_inds); C_tdterms = [c_ops[k][1] for k in C_td_inds]; # extract time-dependent coefficients (strings); # store indicies of constant collapse terms; config.c_const_inds = C_const_inds; # store indicies of time-dependent collapse terms; config.c_td_inds = C_td_inds; for k in config.c_const_inds:; H[0] -= 0.5j * (c_ops[k].dag() * c_ops[k]); else:; # set empty objects if no collapse operators; C_const_inds = np.arange(config.c_num); config.c_const_inds = np.arange(config.c_num); config.c_td_inds = np.array([]); C_tdterms = np.array([]); C_inds = np.array([]). # tidyup; if options.tidy:; H = np.array([H[k].tidyup(options.atol); for k in range(len_h)], dtype=object); # construct data sets; config.h_data = [H[k].data.data for k in range(len_h)]; config.h_ind = [H[k].data.indices for k in range(len_h)]; config.h_ptr = [H[k].data.indptr for k in range(len_h)]; for k in config.c_td_inds:; config.h_data.append(-0.5j * config.n_ops_data[k]); config.h_ind.append(config.n_ops_ind[k]); config.h_ptr.append(config.n_ops_ptr[k]); config.h_data = -1.0j * np.array(config.h_data); config.h_ind = np.array(config.h_ind); config.h_ptr = np.array(config.h_ptr). # set execuatble code for collapse expectati",MatchSource.WIKI,docs/4.2/modules/qutip/mcsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html
https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:34677,Modifiability,config,config,34677,"p.sum(H[k] for k in H_const_inds)] +; [H[k][0] for k in H_td_inds], dtype=object); len_h = len(H); H_inds = np.arange(len_h); # store indicies of time-dependent Hamiltonian terms; config.h_td_inds = np.arange(1, len_h); # if there are any collapse operators; if config.c_num > 0:; if config.tflag == 10:; # constant collapse operators; config.c_const_inds = np.arange(config.c_num); for k in config.c_const_inds:; H[0] -= 0.5j * (c_ops[k].dag() * c_ops[k]); C_inds = np.arange(config.c_num); C_tdterms = np.array([]); else:; # some time-dependent collapse terms; C_inds = np.arange(config.c_num); # find inds of time-dependent terms; C_td_inds = np.array(c_stuff[2]); # find inds of constant terms; C_const_inds = np.setdiff1d(C_inds, C_td_inds); C_tdterms = [c_ops[k][1] for k in C_td_inds]; # extract time-dependent coefficients (strings); # store indicies of constant collapse terms; config.c_const_inds = C_const_inds; # store indicies of time-dependent collapse terms; config.c_td_inds = C_td_inds; for k in config.c_const_inds:; H[0] -= 0.5j * (c_ops[k].dag() * c_ops[k]); else:; # set empty objects if no collapse operators; C_const_inds = np.arange(config.c_num); config.c_const_inds = np.arange(config.c_num); config.c_td_inds = np.array([]); C_tdterms = np.array([]); C_inds = np.array([]). # tidyup; if options.tidy:; H = np.array([H[k].tidyup(options.atol); for k in range(len_h)], dtype=object); # construct data sets; config.h_data = [H[k].data.data for k in range(len_h)]; config.h_ind = [H[k].data.indices for k in range(len_h)]; config.h_ptr = [H[k].data.indptr for k in range(len_h)]; for k in config.c_td_inds:; config.h_data.append(-0.5j * config.n_ops_data[k]); config.h_ind.append(config.n_ops_ind[k]); config.h_ptr.append(config.n_ops_ptr[k]); config.h_data = -1.0j * np.array(config.h_data); config.h_ind = np.array(config.h_ind); config.h_ptr = np.array(config.h_ptr). # set execuatble code for collapse expectation values and spmv; col_spmv_code = (""state = _cy_col_spmv_func",MatchSource.WIKI,docs/4.2/modules/qutip/mcsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html
https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:34821,Modifiability,config,config,34821,"ent Hamiltonian terms; config.h_td_inds = np.arange(1, len_h); # if there are any collapse operators; if config.c_num > 0:; if config.tflag == 10:; # constant collapse operators; config.c_const_inds = np.arange(config.c_num); for k in config.c_const_inds:; H[0] -= 0.5j * (c_ops[k].dag() * c_ops[k]); C_inds = np.arange(config.c_num); C_tdterms = np.array([]); else:; # some time-dependent collapse terms; C_inds = np.arange(config.c_num); # find inds of time-dependent terms; C_td_inds = np.array(c_stuff[2]); # find inds of constant terms; C_const_inds = np.setdiff1d(C_inds, C_td_inds); C_tdterms = [c_ops[k][1] for k in C_td_inds]; # extract time-dependent coefficients (strings); # store indicies of constant collapse terms; config.c_const_inds = C_const_inds; # store indicies of time-dependent collapse terms; config.c_td_inds = C_td_inds; for k in config.c_const_inds:; H[0] -= 0.5j * (c_ops[k].dag() * c_ops[k]); else:; # set empty objects if no collapse operators; C_const_inds = np.arange(config.c_num); config.c_const_inds = np.arange(config.c_num); config.c_td_inds = np.array([]); C_tdterms = np.array([]); C_inds = np.array([]). # tidyup; if options.tidy:; H = np.array([H[k].tidyup(options.atol); for k in range(len_h)], dtype=object); # construct data sets; config.h_data = [H[k].data.data for k in range(len_h)]; config.h_ind = [H[k].data.indices for k in range(len_h)]; config.h_ptr = [H[k].data.indptr for k in range(len_h)]; for k in config.c_td_inds:; config.h_data.append(-0.5j * config.n_ops_data[k]); config.h_ind.append(config.n_ops_ind[k]); config.h_ptr.append(config.n_ops_ptr[k]); config.h_data = -1.0j * np.array(config.h_data); config.h_ind = np.array(config.h_ind); config.h_ptr = np.array(config.h_ptr). # set execuatble code for collapse expectation values and spmv; col_spmv_code = (""state = _cy_col_spmv_func(j, ODE.t, "" +; ""config.c_ops_data[j], config.c_ops_ind[j], "" +; ""config.c_ops_ptr[j], ODE.y""); col_expect_code = (""for i in config.c_td_inds: "" +; ""n_dp.ap",MatchSource.WIKI,docs/4.2/modules/qutip/mcsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html
https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:34836,Modifiability,config,config,34836,"n terms; config.h_td_inds = np.arange(1, len_h); # if there are any collapse operators; if config.c_num > 0:; if config.tflag == 10:; # constant collapse operators; config.c_const_inds = np.arange(config.c_num); for k in config.c_const_inds:; H[0] -= 0.5j * (c_ops[k].dag() * c_ops[k]); C_inds = np.arange(config.c_num); C_tdterms = np.array([]); else:; # some time-dependent collapse terms; C_inds = np.arange(config.c_num); # find inds of time-dependent terms; C_td_inds = np.array(c_stuff[2]); # find inds of constant terms; C_const_inds = np.setdiff1d(C_inds, C_td_inds); C_tdterms = [c_ops[k][1] for k in C_td_inds]; # extract time-dependent coefficients (strings); # store indicies of constant collapse terms; config.c_const_inds = C_const_inds; # store indicies of time-dependent collapse terms; config.c_td_inds = C_td_inds; for k in config.c_const_inds:; H[0] -= 0.5j * (c_ops[k].dag() * c_ops[k]); else:; # set empty objects if no collapse operators; C_const_inds = np.arange(config.c_num); config.c_const_inds = np.arange(config.c_num); config.c_td_inds = np.array([]); C_tdterms = np.array([]); C_inds = np.array([]). # tidyup; if options.tidy:; H = np.array([H[k].tidyup(options.atol); for k in range(len_h)], dtype=object); # construct data sets; config.h_data = [H[k].data.data for k in range(len_h)]; config.h_ind = [H[k].data.indices for k in range(len_h)]; config.h_ptr = [H[k].data.indptr for k in range(len_h)]; for k in config.c_td_inds:; config.h_data.append(-0.5j * config.n_ops_data[k]); config.h_ind.append(config.n_ops_ind[k]); config.h_ptr.append(config.n_ops_ptr[k]); config.h_data = -1.0j * np.array(config.h_data); config.h_ind = np.array(config.h_ind); config.h_ptr = np.array(config.h_ptr). # set execuatble code for collapse expectation values and spmv; col_spmv_code = (""state = _cy_col_spmv_func(j, ODE.t, "" +; ""config.c_ops_data[j], config.c_ops_ind[j], "" +; ""config.c_ops_ptr[j], ODE.y""); col_expect_code = (""for i in config.c_td_inds: "" +; ""n_dp.append(_cy_col_ex",MatchSource.WIKI,docs/4.2/modules/qutip/mcsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html
https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:34868,Modifiability,config,config,34868,"ange(1, len_h); # if there are any collapse operators; if config.c_num > 0:; if config.tflag == 10:; # constant collapse operators; config.c_const_inds = np.arange(config.c_num); for k in config.c_const_inds:; H[0] -= 0.5j * (c_ops[k].dag() * c_ops[k]); C_inds = np.arange(config.c_num); C_tdterms = np.array([]); else:; # some time-dependent collapse terms; C_inds = np.arange(config.c_num); # find inds of time-dependent terms; C_td_inds = np.array(c_stuff[2]); # find inds of constant terms; C_const_inds = np.setdiff1d(C_inds, C_td_inds); C_tdterms = [c_ops[k][1] for k in C_td_inds]; # extract time-dependent coefficients (strings); # store indicies of constant collapse terms; config.c_const_inds = C_const_inds; # store indicies of time-dependent collapse terms; config.c_td_inds = C_td_inds; for k in config.c_const_inds:; H[0] -= 0.5j * (c_ops[k].dag() * c_ops[k]); else:; # set empty objects if no collapse operators; C_const_inds = np.arange(config.c_num); config.c_const_inds = np.arange(config.c_num); config.c_td_inds = np.array([]); C_tdterms = np.array([]); C_inds = np.array([]). # tidyup; if options.tidy:; H = np.array([H[k].tidyup(options.atol); for k in range(len_h)], dtype=object); # construct data sets; config.h_data = [H[k].data.data for k in range(len_h)]; config.h_ind = [H[k].data.indices for k in range(len_h)]; config.h_ptr = [H[k].data.indptr for k in range(len_h)]; for k in config.c_td_inds:; config.h_data.append(-0.5j * config.n_ops_data[k]); config.h_ind.append(config.n_ops_ind[k]); config.h_ptr.append(config.n_ops_ptr[k]); config.h_data = -1.0j * np.array(config.h_data); config.h_ind = np.array(config.h_ind); config.h_ptr = np.array(config.h_ptr). # set execuatble code for collapse expectation values and spmv; col_spmv_code = (""state = _cy_col_spmv_func(j, ODE.t, "" +; ""config.c_ops_data[j], config.c_ops_ind[j], "" +; ""config.c_ops_ptr[j], ODE.y""); col_expect_code = (""for i in config.c_td_inds: "" +; ""n_dp.append(_cy_col_expect_func(i, ODE.t, "" +; ""config",MatchSource.WIKI,docs/4.2/modules/qutip/mcsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html
https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:34883,Modifiability,config,config,34883,"; # if there are any collapse operators; if config.c_num > 0:; if config.tflag == 10:; # constant collapse operators; config.c_const_inds = np.arange(config.c_num); for k in config.c_const_inds:; H[0] -= 0.5j * (c_ops[k].dag() * c_ops[k]); C_inds = np.arange(config.c_num); C_tdterms = np.array([]); else:; # some time-dependent collapse terms; C_inds = np.arange(config.c_num); # find inds of time-dependent terms; C_td_inds = np.array(c_stuff[2]); # find inds of constant terms; C_const_inds = np.setdiff1d(C_inds, C_td_inds); C_tdterms = [c_ops[k][1] for k in C_td_inds]; # extract time-dependent coefficients (strings); # store indicies of constant collapse terms; config.c_const_inds = C_const_inds; # store indicies of time-dependent collapse terms; config.c_td_inds = C_td_inds; for k in config.c_const_inds:; H[0] -= 0.5j * (c_ops[k].dag() * c_ops[k]); else:; # set empty objects if no collapse operators; C_const_inds = np.arange(config.c_num); config.c_const_inds = np.arange(config.c_num); config.c_td_inds = np.array([]); C_tdterms = np.array([]); C_inds = np.array([]). # tidyup; if options.tidy:; H = np.array([H[k].tidyup(options.atol); for k in range(len_h)], dtype=object); # construct data sets; config.h_data = [H[k].data.data for k in range(len_h)]; config.h_ind = [H[k].data.indices for k in range(len_h)]; config.h_ptr = [H[k].data.indptr for k in range(len_h)]; for k in config.c_td_inds:; config.h_data.append(-0.5j * config.n_ops_data[k]); config.h_ind.append(config.n_ops_ind[k]); config.h_ptr.append(config.n_ops_ptr[k]); config.h_data = -1.0j * np.array(config.h_data); config.h_ind = np.array(config.h_ind); config.h_ptr = np.array(config.h_ptr). # set execuatble code for collapse expectation values and spmv; col_spmv_code = (""state = _cy_col_spmv_func(j, ODE.t, "" +; ""config.c_ops_data[j], config.c_ops_ind[j], "" +; ""config.c_ops_ptr[j], ODE.y""); col_expect_code = (""for i in config.c_td_inds: "" +; ""n_dp.append(_cy_col_expect_func(i, ODE.t, "" +; ""config.n_ops_data[i],",MatchSource.WIKI,docs/4.2/modules/qutip/mcsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html
https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:35096,Modifiability,config,config,35096,"const_inds:; H[0] -= 0.5j * (c_ops[k].dag() * c_ops[k]); C_inds = np.arange(config.c_num); C_tdterms = np.array([]); else:; # some time-dependent collapse terms; C_inds = np.arange(config.c_num); # find inds of time-dependent terms; C_td_inds = np.array(c_stuff[2]); # find inds of constant terms; C_const_inds = np.setdiff1d(C_inds, C_td_inds); C_tdterms = [c_ops[k][1] for k in C_td_inds]; # extract time-dependent coefficients (strings); # store indicies of constant collapse terms; config.c_const_inds = C_const_inds; # store indicies of time-dependent collapse terms; config.c_td_inds = C_td_inds; for k in config.c_const_inds:; H[0] -= 0.5j * (c_ops[k].dag() * c_ops[k]); else:; # set empty objects if no collapse operators; C_const_inds = np.arange(config.c_num); config.c_const_inds = np.arange(config.c_num); config.c_td_inds = np.array([]); C_tdterms = np.array([]); C_inds = np.array([]). # tidyup; if options.tidy:; H = np.array([H[k].tidyup(options.atol); for k in range(len_h)], dtype=object); # construct data sets; config.h_data = [H[k].data.data for k in range(len_h)]; config.h_ind = [H[k].data.indices for k in range(len_h)]; config.h_ptr = [H[k].data.indptr for k in range(len_h)]; for k in config.c_td_inds:; config.h_data.append(-0.5j * config.n_ops_data[k]); config.h_ind.append(config.n_ops_ind[k]); config.h_ptr.append(config.n_ops_ptr[k]); config.h_data = -1.0j * np.array(config.h_data); config.h_ind = np.array(config.h_ind); config.h_ptr = np.array(config.h_ptr). # set execuatble code for collapse expectation values and spmv; col_spmv_code = (""state = _cy_col_spmv_func(j, ODE.t, "" +; ""config.c_ops_data[j], config.c_ops_ind[j], "" +; ""config.c_ops_ptr[j], ODE.y""); col_expect_code = (""for i in config.c_td_inds: "" +; ""n_dp.append(_cy_col_expect_func(i, ODE.t, "" +; ""config.n_ops_data[i], "" +; ""config.n_ops_ind[i], "" +; ""config.n_ops_ptr[i], ODE.y""); for kk in range(len(config.c_args)):; col_spmv_code += "",config.c_args["" + str(kk) + ""]""; col_expect_code += "",config.",MatchSource.WIKI,docs/4.2/modules/qutip/mcsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html
https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:35152,Modifiability,config,config,35152,"config.c_num); C_tdterms = np.array([]); else:; # some time-dependent collapse terms; C_inds = np.arange(config.c_num); # find inds of time-dependent terms; C_td_inds = np.array(c_stuff[2]); # find inds of constant terms; C_const_inds = np.setdiff1d(C_inds, C_td_inds); C_tdterms = [c_ops[k][1] for k in C_td_inds]; # extract time-dependent coefficients (strings); # store indicies of constant collapse terms; config.c_const_inds = C_const_inds; # store indicies of time-dependent collapse terms; config.c_td_inds = C_td_inds; for k in config.c_const_inds:; H[0] -= 0.5j * (c_ops[k].dag() * c_ops[k]); else:; # set empty objects if no collapse operators; C_const_inds = np.arange(config.c_num); config.c_const_inds = np.arange(config.c_num); config.c_td_inds = np.array([]); C_tdterms = np.array([]); C_inds = np.array([]). # tidyup; if options.tidy:; H = np.array([H[k].tidyup(options.atol); for k in range(len_h)], dtype=object); # construct data sets; config.h_data = [H[k].data.data for k in range(len_h)]; config.h_ind = [H[k].data.indices for k in range(len_h)]; config.h_ptr = [H[k].data.indptr for k in range(len_h)]; for k in config.c_td_inds:; config.h_data.append(-0.5j * config.n_ops_data[k]); config.h_ind.append(config.n_ops_ind[k]); config.h_ptr.append(config.n_ops_ptr[k]); config.h_data = -1.0j * np.array(config.h_data); config.h_ind = np.array(config.h_ind); config.h_ptr = np.array(config.h_ptr). # set execuatble code for collapse expectation values and spmv; col_spmv_code = (""state = _cy_col_spmv_func(j, ODE.t, "" +; ""config.c_ops_data[j], config.c_ops_ind[j], "" +; ""config.c_ops_ptr[j], ODE.y""); col_expect_code = (""for i in config.c_td_inds: "" +; ""n_dp.append(_cy_col_expect_func(i, ODE.t, "" +; ""config.n_ops_data[i], "" +; ""config.n_ops_ind[i], "" +; ""config.n_ops_ptr[i], ODE.y""); for kk in range(len(config.c_args)):; col_spmv_code += "",config.c_args["" + str(kk) + ""]""; col_expect_code += "",config.c_args["" + str(kk) + ""]""; col_spmv_code += "")""; col_expect_code += ""))"". con",MatchSource.WIKI,docs/4.2/modules/qutip/mcsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html
https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:35210,Modifiability,config,config,35210,"ime-dependent collapse terms; C_inds = np.arange(config.c_num); # find inds of time-dependent terms; C_td_inds = np.array(c_stuff[2]); # find inds of constant terms; C_const_inds = np.setdiff1d(C_inds, C_td_inds); C_tdterms = [c_ops[k][1] for k in C_td_inds]; # extract time-dependent coefficients (strings); # store indicies of constant collapse terms; config.c_const_inds = C_const_inds; # store indicies of time-dependent collapse terms; config.c_td_inds = C_td_inds; for k in config.c_const_inds:; H[0] -= 0.5j * (c_ops[k].dag() * c_ops[k]); else:; # set empty objects if no collapse operators; C_const_inds = np.arange(config.c_num); config.c_const_inds = np.arange(config.c_num); config.c_td_inds = np.array([]); C_tdterms = np.array([]); C_inds = np.array([]). # tidyup; if options.tidy:; H = np.array([H[k].tidyup(options.atol); for k in range(len_h)], dtype=object); # construct data sets; config.h_data = [H[k].data.data for k in range(len_h)]; config.h_ind = [H[k].data.indices for k in range(len_h)]; config.h_ptr = [H[k].data.indptr for k in range(len_h)]; for k in config.c_td_inds:; config.h_data.append(-0.5j * config.n_ops_data[k]); config.h_ind.append(config.n_ops_ind[k]); config.h_ptr.append(config.n_ops_ptr[k]); config.h_data = -1.0j * np.array(config.h_data); config.h_ind = np.array(config.h_ind); config.h_ptr = np.array(config.h_ptr). # set execuatble code for collapse expectation values and spmv; col_spmv_code = (""state = _cy_col_spmv_func(j, ODE.t, "" +; ""config.c_ops_data[j], config.c_ops_ind[j], "" +; ""config.c_ops_ptr[j], ODE.y""); col_expect_code = (""for i in config.c_td_inds: "" +; ""n_dp.append(_cy_col_expect_func(i, ODE.t, "" +; ""config.n_ops_data[i], "" +; ""config.n_ops_ind[i], "" +; ""config.n_ops_ptr[i], ODE.y""); for kk in range(len(config.c_args)):; col_spmv_code += "",config.c_args["" + str(kk) + ""]""; col_expect_code += "",config.c_args["" + str(kk) + ""]""; col_spmv_code += "")""; col_expect_code += ""))"". config.col_spmv_code = col_spmv_code; config.col_expect_code",MatchSource.WIKI,docs/4.2/modules/qutip/mcsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html
https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:35276,Modifiability,config,config,35276,"; # find inds of time-dependent terms; C_td_inds = np.array(c_stuff[2]); # find inds of constant terms; C_const_inds = np.setdiff1d(C_inds, C_td_inds); C_tdterms = [c_ops[k][1] for k in C_td_inds]; # extract time-dependent coefficients (strings); # store indicies of constant collapse terms; config.c_const_inds = C_const_inds; # store indicies of time-dependent collapse terms; config.c_td_inds = C_td_inds; for k in config.c_const_inds:; H[0] -= 0.5j * (c_ops[k].dag() * c_ops[k]); else:; # set empty objects if no collapse operators; C_const_inds = np.arange(config.c_num); config.c_const_inds = np.arange(config.c_num); config.c_td_inds = np.array([]); C_tdterms = np.array([]); C_inds = np.array([]). # tidyup; if options.tidy:; H = np.array([H[k].tidyup(options.atol); for k in range(len_h)], dtype=object); # construct data sets; config.h_data = [H[k].data.data for k in range(len_h)]; config.h_ind = [H[k].data.indices for k in range(len_h)]; config.h_ptr = [H[k].data.indptr for k in range(len_h)]; for k in config.c_td_inds:; config.h_data.append(-0.5j * config.n_ops_data[k]); config.h_ind.append(config.n_ops_ind[k]); config.h_ptr.append(config.n_ops_ptr[k]); config.h_data = -1.0j * np.array(config.h_data); config.h_ind = np.array(config.h_ind); config.h_ptr = np.array(config.h_ptr). # set execuatble code for collapse expectation values and spmv; col_spmv_code = (""state = _cy_col_spmv_func(j, ODE.t, "" +; ""config.c_ops_data[j], config.c_ops_ind[j], "" +; ""config.c_ops_ptr[j], ODE.y""); col_expect_code = (""for i in config.c_td_inds: "" +; ""n_dp.append(_cy_col_expect_func(i, ODE.t, "" +; ""config.n_ops_data[i], "" +; ""config.n_ops_ind[i], "" +; ""config.n_ops_ptr[i], ODE.y""); for kk in range(len(config.c_args)):; col_spmv_code += "",config.c_args["" + str(kk) + ""]""; col_expect_code += "",config.c_args["" + str(kk) + ""]""; col_spmv_code += "")""; col_expect_code += ""))"". config.col_spmv_code = col_spmv_code; config.col_expect_code = col_expect_code. # setup ode args string; config.string = """,MatchSource.WIKI,docs/4.2/modules/qutip/mcsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html
https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:35295,Modifiability,config,config,35295,"erms; C_td_inds = np.array(c_stuff[2]); # find inds of constant terms; C_const_inds = np.setdiff1d(C_inds, C_td_inds); C_tdterms = [c_ops[k][1] for k in C_td_inds]; # extract time-dependent coefficients (strings); # store indicies of constant collapse terms; config.c_const_inds = C_const_inds; # store indicies of time-dependent collapse terms; config.c_td_inds = C_td_inds; for k in config.c_const_inds:; H[0] -= 0.5j * (c_ops[k].dag() * c_ops[k]); else:; # set empty objects if no collapse operators; C_const_inds = np.arange(config.c_num); config.c_const_inds = np.arange(config.c_num); config.c_td_inds = np.array([]); C_tdterms = np.array([]); C_inds = np.array([]). # tidyup; if options.tidy:; H = np.array([H[k].tidyup(options.atol); for k in range(len_h)], dtype=object); # construct data sets; config.h_data = [H[k].data.data for k in range(len_h)]; config.h_ind = [H[k].data.indices for k in range(len_h)]; config.h_ptr = [H[k].data.indptr for k in range(len_h)]; for k in config.c_td_inds:; config.h_data.append(-0.5j * config.n_ops_data[k]); config.h_ind.append(config.n_ops_ind[k]); config.h_ptr.append(config.n_ops_ptr[k]); config.h_data = -1.0j * np.array(config.h_data); config.h_ind = np.array(config.h_ind); config.h_ptr = np.array(config.h_ptr). # set execuatble code for collapse expectation values and spmv; col_spmv_code = (""state = _cy_col_spmv_func(j, ODE.t, "" +; ""config.c_ops_data[j], config.c_ops_ind[j], "" +; ""config.c_ops_ptr[j], ODE.y""); col_expect_code = (""for i in config.c_td_inds: "" +; ""n_dp.append(_cy_col_expect_func(i, ODE.t, "" +; ""config.n_ops_data[i], "" +; ""config.n_ops_ind[i], "" +; ""config.n_ops_ptr[i], ODE.y""); for kk in range(len(config.c_args)):; col_spmv_code += "",config.c_args["" + str(kk) + ""]""; col_expect_code += "",config.c_args["" + str(kk) + ""]""; col_spmv_code += "")""; col_expect_code += ""))"". config.col_spmv_code = col_spmv_code; config.col_expect_code = col_expect_code. # setup ode args string; config.string = """"; data_range = range(len(config.",MatchSource.WIKI,docs/4.2/modules/qutip/mcsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html
https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:35324,Modifiability,config,config,35324,"f[2]); # find inds of constant terms; C_const_inds = np.setdiff1d(C_inds, C_td_inds); C_tdterms = [c_ops[k][1] for k in C_td_inds]; # extract time-dependent coefficients (strings); # store indicies of constant collapse terms; config.c_const_inds = C_const_inds; # store indicies of time-dependent collapse terms; config.c_td_inds = C_td_inds; for k in config.c_const_inds:; H[0] -= 0.5j * (c_ops[k].dag() * c_ops[k]); else:; # set empty objects if no collapse operators; C_const_inds = np.arange(config.c_num); config.c_const_inds = np.arange(config.c_num); config.c_td_inds = np.array([]); C_tdterms = np.array([]); C_inds = np.array([]). # tidyup; if options.tidy:; H = np.array([H[k].tidyup(options.atol); for k in range(len_h)], dtype=object); # construct data sets; config.h_data = [H[k].data.data for k in range(len_h)]; config.h_ind = [H[k].data.indices for k in range(len_h)]; config.h_ptr = [H[k].data.indptr for k in range(len_h)]; for k in config.c_td_inds:; config.h_data.append(-0.5j * config.n_ops_data[k]); config.h_ind.append(config.n_ops_ind[k]); config.h_ptr.append(config.n_ops_ptr[k]); config.h_data = -1.0j * np.array(config.h_data); config.h_ind = np.array(config.h_ind); config.h_ptr = np.array(config.h_ptr). # set execuatble code for collapse expectation values and spmv; col_spmv_code = (""state = _cy_col_spmv_func(j, ODE.t, "" +; ""config.c_ops_data[j], config.c_ops_ind[j], "" +; ""config.c_ops_ptr[j], ODE.y""); col_expect_code = (""for i in config.c_td_inds: "" +; ""n_dp.append(_cy_col_expect_func(i, ODE.t, "" +; ""config.n_ops_data[i], "" +; ""config.n_ops_ind[i], "" +; ""config.n_ops_ptr[i], ODE.y""); for kk in range(len(config.c_args)):; col_spmv_code += "",config.c_args["" + str(kk) + ""]""; col_expect_code += "",config.c_args["" + str(kk) + ""]""; col_spmv_code += "")""; col_expect_code += ""))"". config.col_spmv_code = col_spmv_code; config.col_expect_code = col_expect_code. # setup ode args string; config.string = """"; data_range = range(len(config.h_data)); for k in data_range:; ",MatchSource.WIKI,docs/4.2/modules/qutip/mcsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html
https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:35347,Modifiability,config,config,35347,"s of constant terms; C_const_inds = np.setdiff1d(C_inds, C_td_inds); C_tdterms = [c_ops[k][1] for k in C_td_inds]; # extract time-dependent coefficients (strings); # store indicies of constant collapse terms; config.c_const_inds = C_const_inds; # store indicies of time-dependent collapse terms; config.c_td_inds = C_td_inds; for k in config.c_const_inds:; H[0] -= 0.5j * (c_ops[k].dag() * c_ops[k]); else:; # set empty objects if no collapse operators; C_const_inds = np.arange(config.c_num); config.c_const_inds = np.arange(config.c_num); config.c_td_inds = np.array([]); C_tdterms = np.array([]); C_inds = np.array([]). # tidyup; if options.tidy:; H = np.array([H[k].tidyup(options.atol); for k in range(len_h)], dtype=object); # construct data sets; config.h_data = [H[k].data.data for k in range(len_h)]; config.h_ind = [H[k].data.indices for k in range(len_h)]; config.h_ptr = [H[k].data.indptr for k in range(len_h)]; for k in config.c_td_inds:; config.h_data.append(-0.5j * config.n_ops_data[k]); config.h_ind.append(config.n_ops_ind[k]); config.h_ptr.append(config.n_ops_ptr[k]); config.h_data = -1.0j * np.array(config.h_data); config.h_ind = np.array(config.h_ind); config.h_ptr = np.array(config.h_ptr). # set execuatble code for collapse expectation values and spmv; col_spmv_code = (""state = _cy_col_spmv_func(j, ODE.t, "" +; ""config.c_ops_data[j], config.c_ops_ind[j], "" +; ""config.c_ops_ptr[j], ODE.y""); col_expect_code = (""for i in config.c_td_inds: "" +; ""n_dp.append(_cy_col_expect_func(i, ODE.t, "" +; ""config.n_ops_data[i], "" +; ""config.n_ops_ind[i], "" +; ""config.n_ops_ptr[i], ODE.y""); for kk in range(len(config.c_args)):; col_spmv_code += "",config.c_args["" + str(kk) + ""]""; col_expect_code += "",config.c_args["" + str(kk) + ""]""; col_spmv_code += "")""; col_expect_code += ""))"". config.col_spmv_code = col_spmv_code; config.col_expect_code = col_expect_code. # setup ode args string; config.string = """"; data_range = range(len(config.h_data)); for k in data_range:; config.string += (",MatchSource.WIKI,docs/4.2/modules/qutip/mcsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html
https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:35367,Modifiability,config,config,35367,"nst_inds = np.setdiff1d(C_inds, C_td_inds); C_tdterms = [c_ops[k][1] for k in C_td_inds]; # extract time-dependent coefficients (strings); # store indicies of constant collapse terms; config.c_const_inds = C_const_inds; # store indicies of time-dependent collapse terms; config.c_td_inds = C_td_inds; for k in config.c_const_inds:; H[0] -= 0.5j * (c_ops[k].dag() * c_ops[k]); else:; # set empty objects if no collapse operators; C_const_inds = np.arange(config.c_num); config.c_const_inds = np.arange(config.c_num); config.c_td_inds = np.array([]); C_tdterms = np.array([]); C_inds = np.array([]). # tidyup; if options.tidy:; H = np.array([H[k].tidyup(options.atol); for k in range(len_h)], dtype=object); # construct data sets; config.h_data = [H[k].data.data for k in range(len_h)]; config.h_ind = [H[k].data.indices for k in range(len_h)]; config.h_ptr = [H[k].data.indptr for k in range(len_h)]; for k in config.c_td_inds:; config.h_data.append(-0.5j * config.n_ops_data[k]); config.h_ind.append(config.n_ops_ind[k]); config.h_ptr.append(config.n_ops_ptr[k]); config.h_data = -1.0j * np.array(config.h_data); config.h_ind = np.array(config.h_ind); config.h_ptr = np.array(config.h_ptr). # set execuatble code for collapse expectation values and spmv; col_spmv_code = (""state = _cy_col_spmv_func(j, ODE.t, "" +; ""config.c_ops_data[j], config.c_ops_ind[j], "" +; ""config.c_ops_ptr[j], ODE.y""); col_expect_code = (""for i in config.c_td_inds: "" +; ""n_dp.append(_cy_col_expect_func(i, ODE.t, "" +; ""config.n_ops_data[i], "" +; ""config.n_ops_ind[i], "" +; ""config.n_ops_ptr[i], ODE.y""); for kk in range(len(config.c_args)):; col_spmv_code += "",config.c_args["" + str(kk) + ""]""; col_expect_code += "",config.c_args["" + str(kk) + ""]""; col_spmv_code += "")""; col_expect_code += ""))"". config.col_spmv_code = col_spmv_code; config.col_expect_code = col_expect_code. # setup ode args string; config.string = """"; data_range = range(len(config.h_data)); for k in data_range:; config.string += (""config.h_data["" + str(k",MatchSource.WIKI,docs/4.2/modules/qutip/mcsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html
https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:35389,Modifiability,config,config,35389,"iff1d(C_inds, C_td_inds); C_tdterms = [c_ops[k][1] for k in C_td_inds]; # extract time-dependent coefficients (strings); # store indicies of constant collapse terms; config.c_const_inds = C_const_inds; # store indicies of time-dependent collapse terms; config.c_td_inds = C_td_inds; for k in config.c_const_inds:; H[0] -= 0.5j * (c_ops[k].dag() * c_ops[k]); else:; # set empty objects if no collapse operators; C_const_inds = np.arange(config.c_num); config.c_const_inds = np.arange(config.c_num); config.c_td_inds = np.array([]); C_tdterms = np.array([]); C_inds = np.array([]). # tidyup; if options.tidy:; H = np.array([H[k].tidyup(options.atol); for k in range(len_h)], dtype=object); # construct data sets; config.h_data = [H[k].data.data for k in range(len_h)]; config.h_ind = [H[k].data.indices for k in range(len_h)]; config.h_ptr = [H[k].data.indptr for k in range(len_h)]; for k in config.c_td_inds:; config.h_data.append(-0.5j * config.n_ops_data[k]); config.h_ind.append(config.n_ops_ind[k]); config.h_ptr.append(config.n_ops_ptr[k]); config.h_data = -1.0j * np.array(config.h_data); config.h_ind = np.array(config.h_ind); config.h_ptr = np.array(config.h_ptr). # set execuatble code for collapse expectation values and spmv; col_spmv_code = (""state = _cy_col_spmv_func(j, ODE.t, "" +; ""config.c_ops_data[j], config.c_ops_ind[j], "" +; ""config.c_ops_ptr[j], ODE.y""); col_expect_code = (""for i in config.c_td_inds: "" +; ""n_dp.append(_cy_col_expect_func(i, ODE.t, "" +; ""config.n_ops_data[i], "" +; ""config.n_ops_ind[i], "" +; ""config.n_ops_ptr[i], ODE.y""); for kk in range(len(config.c_args)):; col_spmv_code += "",config.c_args["" + str(kk) + ""]""; col_expect_code += "",config.c_args["" + str(kk) + ""]""; col_spmv_code += "")""; col_expect_code += ""))"". config.col_spmv_code = col_spmv_code; config.col_expect_code = col_expect_code. # setup ode args string; config.string = """"; data_range = range(len(config.h_data)); for k in data_range:; config.string += (""config.h_data["" + str(k) +; ""], config.h_",MatchSource.WIKI,docs/4.2/modules/qutip/mcsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html
https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:35409,Modifiability,config,config,35409,"; C_tdterms = [c_ops[k][1] for k in C_td_inds]; # extract time-dependent coefficients (strings); # store indicies of constant collapse terms; config.c_const_inds = C_const_inds; # store indicies of time-dependent collapse terms; config.c_td_inds = C_td_inds; for k in config.c_const_inds:; H[0] -= 0.5j * (c_ops[k].dag() * c_ops[k]); else:; # set empty objects if no collapse operators; C_const_inds = np.arange(config.c_num); config.c_const_inds = np.arange(config.c_num); config.c_td_inds = np.array([]); C_tdterms = np.array([]); C_inds = np.array([]). # tidyup; if options.tidy:; H = np.array([H[k].tidyup(options.atol); for k in range(len_h)], dtype=object); # construct data sets; config.h_data = [H[k].data.data for k in range(len_h)]; config.h_ind = [H[k].data.indices for k in range(len_h)]; config.h_ptr = [H[k].data.indptr for k in range(len_h)]; for k in config.c_td_inds:; config.h_data.append(-0.5j * config.n_ops_data[k]); config.h_ind.append(config.n_ops_ind[k]); config.h_ptr.append(config.n_ops_ptr[k]); config.h_data = -1.0j * np.array(config.h_data); config.h_ind = np.array(config.h_ind); config.h_ptr = np.array(config.h_ptr). # set execuatble code for collapse expectation values and spmv; col_spmv_code = (""state = _cy_col_spmv_func(j, ODE.t, "" +; ""config.c_ops_data[j], config.c_ops_ind[j], "" +; ""config.c_ops_ptr[j], ODE.y""); col_expect_code = (""for i in config.c_td_inds: "" +; ""n_dp.append(_cy_col_expect_func(i, ODE.t, "" +; ""config.n_ops_data[i], "" +; ""config.n_ops_ind[i], "" +; ""config.n_ops_ptr[i], ODE.y""); for kk in range(len(config.c_args)):; col_spmv_code += "",config.c_args["" + str(kk) + ""]""; col_expect_code += "",config.c_args["" + str(kk) + ""]""; col_spmv_code += "")""; col_expect_code += ""))"". config.col_spmv_code = col_spmv_code; config.col_expect_code = col_expect_code. # setup ode args string; config.string = """"; data_range = range(len(config.h_data)); for k in data_range:; config.string += (""config.h_data["" + str(k) +; ""], config.h_ind["" + str(k) +; ""], co",MatchSource.WIKI,docs/4.2/modules/qutip/mcsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html
https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:35431,Modifiability,config,config,35431,"ps[k][1] for k in C_td_inds]; # extract time-dependent coefficients (strings); # store indicies of constant collapse terms; config.c_const_inds = C_const_inds; # store indicies of time-dependent collapse terms; config.c_td_inds = C_td_inds; for k in config.c_const_inds:; H[0] -= 0.5j * (c_ops[k].dag() * c_ops[k]); else:; # set empty objects if no collapse operators; C_const_inds = np.arange(config.c_num); config.c_const_inds = np.arange(config.c_num); config.c_td_inds = np.array([]); C_tdterms = np.array([]); C_inds = np.array([]). # tidyup; if options.tidy:; H = np.array([H[k].tidyup(options.atol); for k in range(len_h)], dtype=object); # construct data sets; config.h_data = [H[k].data.data for k in range(len_h)]; config.h_ind = [H[k].data.indices for k in range(len_h)]; config.h_ptr = [H[k].data.indptr for k in range(len_h)]; for k in config.c_td_inds:; config.h_data.append(-0.5j * config.n_ops_data[k]); config.h_ind.append(config.n_ops_ind[k]); config.h_ptr.append(config.n_ops_ptr[k]); config.h_data = -1.0j * np.array(config.h_data); config.h_ind = np.array(config.h_ind); config.h_ptr = np.array(config.h_ptr). # set execuatble code for collapse expectation values and spmv; col_spmv_code = (""state = _cy_col_spmv_func(j, ODE.t, "" +; ""config.c_ops_data[j], config.c_ops_ind[j], "" +; ""config.c_ops_ptr[j], ODE.y""); col_expect_code = (""for i in config.c_td_inds: "" +; ""n_dp.append(_cy_col_expect_func(i, ODE.t, "" +; ""config.n_ops_data[i], "" +; ""config.n_ops_ind[i], "" +; ""config.n_ops_ptr[i], ODE.y""); for kk in range(len(config.c_args)):; col_spmv_code += "",config.c_args["" + str(kk) + ""]""; col_expect_code += "",config.c_args["" + str(kk) + ""]""; col_spmv_code += "")""; col_expect_code += ""))"". config.col_spmv_code = col_spmv_code; config.col_expect_code = col_expect_code. # setup ode args string; config.string = """"; data_range = range(len(config.h_data)); for k in data_range:; config.string += (""config.h_data["" + str(k) +; ""], config.h_ind["" + str(k) +; ""], config.h_ptr["" + str",MatchSource.WIKI,docs/4.2/modules/qutip/mcsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html
https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:35464,Modifiability,config,config,35464,"ct time-dependent coefficients (strings); # store indicies of constant collapse terms; config.c_const_inds = C_const_inds; # store indicies of time-dependent collapse terms; config.c_td_inds = C_td_inds; for k in config.c_const_inds:; H[0] -= 0.5j * (c_ops[k].dag() * c_ops[k]); else:; # set empty objects if no collapse operators; C_const_inds = np.arange(config.c_num); config.c_const_inds = np.arange(config.c_num); config.c_td_inds = np.array([]); C_tdterms = np.array([]); C_inds = np.array([]). # tidyup; if options.tidy:; H = np.array([H[k].tidyup(options.atol); for k in range(len_h)], dtype=object); # construct data sets; config.h_data = [H[k].data.data for k in range(len_h)]; config.h_ind = [H[k].data.indices for k in range(len_h)]; config.h_ptr = [H[k].data.indptr for k in range(len_h)]; for k in config.c_td_inds:; config.h_data.append(-0.5j * config.n_ops_data[k]); config.h_ind.append(config.n_ops_ind[k]); config.h_ptr.append(config.n_ops_ptr[k]); config.h_data = -1.0j * np.array(config.h_data); config.h_ind = np.array(config.h_ind); config.h_ptr = np.array(config.h_ptr). # set execuatble code for collapse expectation values and spmv; col_spmv_code = (""state = _cy_col_spmv_func(j, ODE.t, "" +; ""config.c_ops_data[j], config.c_ops_ind[j], "" +; ""config.c_ops_ptr[j], ODE.y""); col_expect_code = (""for i in config.c_td_inds: "" +; ""n_dp.append(_cy_col_expect_func(i, ODE.t, "" +; ""config.n_ops_data[i], "" +; ""config.n_ops_ind[i], "" +; ""config.n_ops_ptr[i], ODE.y""); for kk in range(len(config.c_args)):; col_spmv_code += "",config.c_args["" + str(kk) + ""]""; col_expect_code += "",config.c_args["" + str(kk) + ""]""; col_spmv_code += "")""; col_expect_code += ""))"". config.col_spmv_code = col_spmv_code; config.col_expect_code = col_expect_code. # setup ode args string; config.string = """"; data_range = range(len(config.h_data)); for k in data_range:; config.string += (""config.h_data["" + str(k) +; ""], config.h_ind["" + str(k) +; ""], config.h_ptr["" + str(k) + ""]""); if k != data_range[-1]:; c",MatchSource.WIKI,docs/4.2/modules/qutip/mcsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html
https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:35480,Modifiability,config,config,35480,"nt coefficients (strings); # store indicies of constant collapse terms; config.c_const_inds = C_const_inds; # store indicies of time-dependent collapse terms; config.c_td_inds = C_td_inds; for k in config.c_const_inds:; H[0] -= 0.5j * (c_ops[k].dag() * c_ops[k]); else:; # set empty objects if no collapse operators; C_const_inds = np.arange(config.c_num); config.c_const_inds = np.arange(config.c_num); config.c_td_inds = np.array([]); C_tdterms = np.array([]); C_inds = np.array([]). # tidyup; if options.tidy:; H = np.array([H[k].tidyup(options.atol); for k in range(len_h)], dtype=object); # construct data sets; config.h_data = [H[k].data.data for k in range(len_h)]; config.h_ind = [H[k].data.indices for k in range(len_h)]; config.h_ptr = [H[k].data.indptr for k in range(len_h)]; for k in config.c_td_inds:; config.h_data.append(-0.5j * config.n_ops_data[k]); config.h_ind.append(config.n_ops_ind[k]); config.h_ptr.append(config.n_ops_ptr[k]); config.h_data = -1.0j * np.array(config.h_data); config.h_ind = np.array(config.h_ind); config.h_ptr = np.array(config.h_ptr). # set execuatble code for collapse expectation values and spmv; col_spmv_code = (""state = _cy_col_spmv_func(j, ODE.t, "" +; ""config.c_ops_data[j], config.c_ops_ind[j], "" +; ""config.c_ops_ptr[j], ODE.y""); col_expect_code = (""for i in config.c_td_inds: "" +; ""n_dp.append(_cy_col_expect_func(i, ODE.t, "" +; ""config.n_ops_data[i], "" +; ""config.n_ops_ind[i], "" +; ""config.n_ops_ptr[i], ODE.y""); for kk in range(len(config.c_args)):; col_spmv_code += "",config.c_args["" + str(kk) + ""]""; col_expect_code += "",config.c_args["" + str(kk) + ""]""; col_spmv_code += "")""; col_expect_code += ""))"". config.col_spmv_code = col_spmv_code; config.col_expect_code = col_expect_code. # setup ode args string; config.string = """"; data_range = range(len(config.h_data)); for k in data_range:; config.string += (""config.h_data["" + str(k) +; ""], config.h_ind["" + str(k) +; ""], config.h_ptr["" + str(k) + ""]""); if k != data_range[-1]:; config.string +",MatchSource.WIKI,docs/4.2/modules/qutip/mcsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html
https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:35504,Modifiability,config,config,35504,"; # store indicies of constant collapse terms; config.c_const_inds = C_const_inds; # store indicies of time-dependent collapse terms; config.c_td_inds = C_td_inds; for k in config.c_const_inds:; H[0] -= 0.5j * (c_ops[k].dag() * c_ops[k]); else:; # set empty objects if no collapse operators; C_const_inds = np.arange(config.c_num); config.c_const_inds = np.arange(config.c_num); config.c_td_inds = np.array([]); C_tdterms = np.array([]); C_inds = np.array([]). # tidyup; if options.tidy:; H = np.array([H[k].tidyup(options.atol); for k in range(len_h)], dtype=object); # construct data sets; config.h_data = [H[k].data.data for k in range(len_h)]; config.h_ind = [H[k].data.indices for k in range(len_h)]; config.h_ptr = [H[k].data.indptr for k in range(len_h)]; for k in config.c_td_inds:; config.h_data.append(-0.5j * config.n_ops_data[k]); config.h_ind.append(config.n_ops_ind[k]); config.h_ptr.append(config.n_ops_ptr[k]); config.h_data = -1.0j * np.array(config.h_data); config.h_ind = np.array(config.h_ind); config.h_ptr = np.array(config.h_ptr). # set execuatble code for collapse expectation values and spmv; col_spmv_code = (""state = _cy_col_spmv_func(j, ODE.t, "" +; ""config.c_ops_data[j], config.c_ops_ind[j], "" +; ""config.c_ops_ptr[j], ODE.y""); col_expect_code = (""for i in config.c_td_inds: "" +; ""n_dp.append(_cy_col_expect_func(i, ODE.t, "" +; ""config.n_ops_data[i], "" +; ""config.n_ops_ind[i], "" +; ""config.n_ops_ptr[i], ODE.y""); for kk in range(len(config.c_args)):; col_spmv_code += "",config.c_args["" + str(kk) + ""]""; col_expect_code += "",config.c_args["" + str(kk) + ""]""; col_spmv_code += "")""; col_expect_code += ""))"". config.col_spmv_code = col_spmv_code; config.col_expect_code = col_expect_code. # setup ode args string; config.string = """"; data_range = range(len(config.h_data)); for k in data_range:; config.string += (""config.h_data["" + str(k) +; ""], config.h_ind["" + str(k) +; ""], config.h_ptr["" + str(k) + ""]""); if k != data_range[-1]:; config.string += "",""; ; # Add objects to ",MatchSource.WIKI,docs/4.2/modules/qutip/mcsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html
https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:35519,Modifiability,config,config,35519,"cies of constant collapse terms; config.c_const_inds = C_const_inds; # store indicies of time-dependent collapse terms; config.c_td_inds = C_td_inds; for k in config.c_const_inds:; H[0] -= 0.5j * (c_ops[k].dag() * c_ops[k]); else:; # set empty objects if no collapse operators; C_const_inds = np.arange(config.c_num); config.c_const_inds = np.arange(config.c_num); config.c_td_inds = np.array([]); C_tdterms = np.array([]); C_inds = np.array([]). # tidyup; if options.tidy:; H = np.array([H[k].tidyup(options.atol); for k in range(len_h)], dtype=object); # construct data sets; config.h_data = [H[k].data.data for k in range(len_h)]; config.h_ind = [H[k].data.indices for k in range(len_h)]; config.h_ptr = [H[k].data.indptr for k in range(len_h)]; for k in config.c_td_inds:; config.h_data.append(-0.5j * config.n_ops_data[k]); config.h_ind.append(config.n_ops_ind[k]); config.h_ptr.append(config.n_ops_ptr[k]); config.h_data = -1.0j * np.array(config.h_data); config.h_ind = np.array(config.h_ind); config.h_ptr = np.array(config.h_ptr). # set execuatble code for collapse expectation values and spmv; col_spmv_code = (""state = _cy_col_spmv_func(j, ODE.t, "" +; ""config.c_ops_data[j], config.c_ops_ind[j], "" +; ""config.c_ops_ptr[j], ODE.y""); col_expect_code = (""for i in config.c_td_inds: "" +; ""n_dp.append(_cy_col_expect_func(i, ODE.t, "" +; ""config.n_ops_data[i], "" +; ""config.n_ops_ind[i], "" +; ""config.n_ops_ptr[i], ODE.y""); for kk in range(len(config.c_args)):; col_spmv_code += "",config.c_args["" + str(kk) + ""]""; col_expect_code += "",config.c_args["" + str(kk) + ""]""; col_spmv_code += "")""; col_expect_code += ""))"". config.col_spmv_code = col_spmv_code; config.col_expect_code = col_expect_code. # setup ode args string; config.string = """"; data_range = range(len(config.h_data)); for k in data_range:; config.string += (""config.h_data["" + str(k) +; ""], config.h_ind["" + str(k) +; ""], config.h_ptr["" + str(k) + ""]""); if k != data_range[-1]:; config.string += "",""; ; # Add objects to ode args strin",MatchSource.WIKI,docs/4.2/modules/qutip/mcsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html
https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:35543,Modifiability,config,config,35543," terms; config.c_const_inds = C_const_inds; # store indicies of time-dependent collapse terms; config.c_td_inds = C_td_inds; for k in config.c_const_inds:; H[0] -= 0.5j * (c_ops[k].dag() * c_ops[k]); else:; # set empty objects if no collapse operators; C_const_inds = np.arange(config.c_num); config.c_const_inds = np.arange(config.c_num); config.c_td_inds = np.array([]); C_tdterms = np.array([]); C_inds = np.array([]). # tidyup; if options.tidy:; H = np.array([H[k].tidyup(options.atol); for k in range(len_h)], dtype=object); # construct data sets; config.h_data = [H[k].data.data for k in range(len_h)]; config.h_ind = [H[k].data.indices for k in range(len_h)]; config.h_ptr = [H[k].data.indptr for k in range(len_h)]; for k in config.c_td_inds:; config.h_data.append(-0.5j * config.n_ops_data[k]); config.h_ind.append(config.n_ops_ind[k]); config.h_ptr.append(config.n_ops_ptr[k]); config.h_data = -1.0j * np.array(config.h_data); config.h_ind = np.array(config.h_ind); config.h_ptr = np.array(config.h_ptr). # set execuatble code for collapse expectation values and spmv; col_spmv_code = (""state = _cy_col_spmv_func(j, ODE.t, "" +; ""config.c_ops_data[j], config.c_ops_ind[j], "" +; ""config.c_ops_ptr[j], ODE.y""); col_expect_code = (""for i in config.c_td_inds: "" +; ""n_dp.append(_cy_col_expect_func(i, ODE.t, "" +; ""config.n_ops_data[i], "" +; ""config.n_ops_ind[i], "" +; ""config.n_ops_ptr[i], ODE.y""); for kk in range(len(config.c_args)):; col_spmv_code += "",config.c_args["" + str(kk) + ""]""; col_expect_code += "",config.c_args["" + str(kk) + ""]""; col_spmv_code += "")""; col_expect_code += ""))"". config.col_spmv_code = col_spmv_code; config.col_expect_code = col_expect_code. # setup ode args string; config.string = """"; data_range = range(len(config.h_data)); for k in data_range:; config.string += (""config.h_data["" + str(k) +; ""], config.h_ind["" + str(k) +; ""], config.h_ptr["" + str(k) + ""]""); if k != data_range[-1]:; config.string += "",""; ; # Add objects to ode args string; for k in range(len(con",MatchSource.WIKI,docs/4.2/modules/qutip/mcsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html
https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:35682,Modifiability,config,config,35682,"ig.c_const_inds:; H[0] -= 0.5j * (c_ops[k].dag() * c_ops[k]); else:; # set empty objects if no collapse operators; C_const_inds = np.arange(config.c_num); config.c_const_inds = np.arange(config.c_num); config.c_td_inds = np.array([]); C_tdterms = np.array([]); C_inds = np.array([]). # tidyup; if options.tidy:; H = np.array([H[k].tidyup(options.atol); for k in range(len_h)], dtype=object); # construct data sets; config.h_data = [H[k].data.data for k in range(len_h)]; config.h_ind = [H[k].data.indices for k in range(len_h)]; config.h_ptr = [H[k].data.indptr for k in range(len_h)]; for k in config.c_td_inds:; config.h_data.append(-0.5j * config.n_ops_data[k]); config.h_ind.append(config.n_ops_ind[k]); config.h_ptr.append(config.n_ops_ptr[k]); config.h_data = -1.0j * np.array(config.h_data); config.h_ind = np.array(config.h_ind); config.h_ptr = np.array(config.h_ptr). # set execuatble code for collapse expectation values and spmv; col_spmv_code = (""state = _cy_col_spmv_func(j, ODE.t, "" +; ""config.c_ops_data[j], config.c_ops_ind[j], "" +; ""config.c_ops_ptr[j], ODE.y""); col_expect_code = (""for i in config.c_td_inds: "" +; ""n_dp.append(_cy_col_expect_func(i, ODE.t, "" +; ""config.n_ops_data[i], "" +; ""config.n_ops_ind[i], "" +; ""config.n_ops_ptr[i], ODE.y""); for kk in range(len(config.c_args)):; col_spmv_code += "",config.c_args["" + str(kk) + ""]""; col_expect_code += "",config.c_args["" + str(kk) + ""]""; col_spmv_code += "")""; col_expect_code += ""))"". config.col_spmv_code = col_spmv_code; config.col_expect_code = col_expect_code. # setup ode args string; config.string = """"; data_range = range(len(config.h_data)); for k in data_range:; config.string += (""config.h_data["" + str(k) +; ""], config.h_ind["" + str(k) +; ""], config.h_ptr["" + str(k) + ""]""); if k != data_range[-1]:; config.string += "",""; ; # Add objects to ode args string; for k in range(len(config.h_tdterms)):; if isinstance(config.h_tdterms[k], Cubic_Spline):; config.string += "", config.h_tdterms[""+str(k)+""].coeffs""; ; # attach",MatchSource.WIKI,docs/4.2/modules/qutip/mcsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html
https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:35704,Modifiability,config,config,35704,"[0] -= 0.5j * (c_ops[k].dag() * c_ops[k]); else:; # set empty objects if no collapse operators; C_const_inds = np.arange(config.c_num); config.c_const_inds = np.arange(config.c_num); config.c_td_inds = np.array([]); C_tdterms = np.array([]); C_inds = np.array([]). # tidyup; if options.tidy:; H = np.array([H[k].tidyup(options.atol); for k in range(len_h)], dtype=object); # construct data sets; config.h_data = [H[k].data.data for k in range(len_h)]; config.h_ind = [H[k].data.indices for k in range(len_h)]; config.h_ptr = [H[k].data.indptr for k in range(len_h)]; for k in config.c_td_inds:; config.h_data.append(-0.5j * config.n_ops_data[k]); config.h_ind.append(config.n_ops_ind[k]); config.h_ptr.append(config.n_ops_ptr[k]); config.h_data = -1.0j * np.array(config.h_data); config.h_ind = np.array(config.h_ind); config.h_ptr = np.array(config.h_ptr). # set execuatble code for collapse expectation values and spmv; col_spmv_code = (""state = _cy_col_spmv_func(j, ODE.t, "" +; ""config.c_ops_data[j], config.c_ops_ind[j], "" +; ""config.c_ops_ptr[j], ODE.y""); col_expect_code = (""for i in config.c_td_inds: "" +; ""n_dp.append(_cy_col_expect_func(i, ODE.t, "" +; ""config.n_ops_data[i], "" +; ""config.n_ops_ind[i], "" +; ""config.n_ops_ptr[i], ODE.y""); for kk in range(len(config.c_args)):; col_spmv_code += "",config.c_args["" + str(kk) + ""]""; col_expect_code += "",config.c_args["" + str(kk) + ""]""; col_spmv_code += "")""; col_expect_code += ""))"". config.col_spmv_code = col_spmv_code; config.col_expect_code = col_expect_code. # setup ode args string; config.string = """"; data_range = range(len(config.h_data)); for k in data_range:; config.string += (""config.h_data["" + str(k) +; ""], config.h_ind["" + str(k) +; ""], config.h_ptr["" + str(k) + ""]""); if k != data_range[-1]:; config.string += "",""; ; # Add objects to ode args string; for k in range(len(config.h_tdterms)):; if isinstance(config.h_tdterms[k], Cubic_Spline):; config.string += "", config.h_tdterms[""+str(k)+""].coeffs""; ; # attach args to ode args s",MatchSource.WIKI,docs/4.2/modules/qutip/mcsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html
https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:35731,Modifiability,config,config,35731,"dag() * c_ops[k]); else:; # set empty objects if no collapse operators; C_const_inds = np.arange(config.c_num); config.c_const_inds = np.arange(config.c_num); config.c_td_inds = np.array([]); C_tdterms = np.array([]); C_inds = np.array([]). # tidyup; if options.tidy:; H = np.array([H[k].tidyup(options.atol); for k in range(len_h)], dtype=object); # construct data sets; config.h_data = [H[k].data.data for k in range(len_h)]; config.h_ind = [H[k].data.indices for k in range(len_h)]; config.h_ptr = [H[k].data.indptr for k in range(len_h)]; for k in config.c_td_inds:; config.h_data.append(-0.5j * config.n_ops_data[k]); config.h_ind.append(config.n_ops_ind[k]); config.h_ptr.append(config.n_ops_ptr[k]); config.h_data = -1.0j * np.array(config.h_data); config.h_ind = np.array(config.h_ind); config.h_ptr = np.array(config.h_ptr). # set execuatble code for collapse expectation values and spmv; col_spmv_code = (""state = _cy_col_spmv_func(j, ODE.t, "" +; ""config.c_ops_data[j], config.c_ops_ind[j], "" +; ""config.c_ops_ptr[j], ODE.y""); col_expect_code = (""for i in config.c_td_inds: "" +; ""n_dp.append(_cy_col_expect_func(i, ODE.t, "" +; ""config.n_ops_data[i], "" +; ""config.n_ops_ind[i], "" +; ""config.n_ops_ptr[i], ODE.y""); for kk in range(len(config.c_args)):; col_spmv_code += "",config.c_args["" + str(kk) + ""]""; col_expect_code += "",config.c_args["" + str(kk) + ""]""; col_spmv_code += "")""; col_expect_code += ""))"". config.col_spmv_code = col_spmv_code; config.col_expect_code = col_expect_code. # setup ode args string; config.string = """"; data_range = range(len(config.h_data)); for k in data_range:; config.string += (""config.h_data["" + str(k) +; ""], config.h_ind["" + str(k) +; ""], config.h_ptr["" + str(k) + ""]""); if k != data_range[-1]:; config.string += "",""; ; # Add objects to ode args string; for k in range(len(config.h_tdterms)):; if isinstance(config.h_tdterms[k], Cubic_Spline):; config.string += "", config.h_tdterms[""+str(k)+""].coeffs""; ; # attach args to ode args string; if len(config.c_ar",MatchSource.WIKI,docs/4.2/modules/qutip/mcsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html
https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:35790,Modifiability,config,config,35790,"collapse operators; C_const_inds = np.arange(config.c_num); config.c_const_inds = np.arange(config.c_num); config.c_td_inds = np.array([]); C_tdterms = np.array([]); C_inds = np.array([]). # tidyup; if options.tidy:; H = np.array([H[k].tidyup(options.atol); for k in range(len_h)], dtype=object); # construct data sets; config.h_data = [H[k].data.data for k in range(len_h)]; config.h_ind = [H[k].data.indices for k in range(len_h)]; config.h_ptr = [H[k].data.indptr for k in range(len_h)]; for k in config.c_td_inds:; config.h_data.append(-0.5j * config.n_ops_data[k]); config.h_ind.append(config.n_ops_ind[k]); config.h_ptr.append(config.n_ops_ptr[k]); config.h_data = -1.0j * np.array(config.h_data); config.h_ind = np.array(config.h_ind); config.h_ptr = np.array(config.h_ptr). # set execuatble code for collapse expectation values and spmv; col_spmv_code = (""state = _cy_col_spmv_func(j, ODE.t, "" +; ""config.c_ops_data[j], config.c_ops_ind[j], "" +; ""config.c_ops_ptr[j], ODE.y""); col_expect_code = (""for i in config.c_td_inds: "" +; ""n_dp.append(_cy_col_expect_func(i, ODE.t, "" +; ""config.n_ops_data[i], "" +; ""config.n_ops_ind[i], "" +; ""config.n_ops_ptr[i], ODE.y""); for kk in range(len(config.c_args)):; col_spmv_code += "",config.c_args["" + str(kk) + ""]""; col_expect_code += "",config.c_args["" + str(kk) + ""]""; col_spmv_code += "")""; col_expect_code += ""))"". config.col_spmv_code = col_spmv_code; config.col_expect_code = col_expect_code. # setup ode args string; config.string = """"; data_range = range(len(config.h_data)); for k in data_range:; config.string += (""config.h_data["" + str(k) +; ""], config.h_ind["" + str(k) +; ""], config.h_ptr["" + str(k) + ""]""); if k != data_range[-1]:; config.string += "",""; ; # Add objects to ode args string; for k in range(len(config.h_tdterms)):; if isinstance(config.h_tdterms[k], Cubic_Spline):; config.string += "", config.h_tdterms[""+str(k)+""].coeffs""; ; # attach args to ode args string; if len(config.c_args) > 0:; for kk in range(len(config.c_args)):; conf",MatchSource.WIKI,docs/4.2/modules/qutip/mcsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html
https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:35862,Modifiability,config,config,35862,"arange(config.c_num); config.c_td_inds = np.array([]); C_tdterms = np.array([]); C_inds = np.array([]). # tidyup; if options.tidy:; H = np.array([H[k].tidyup(options.atol); for k in range(len_h)], dtype=object); # construct data sets; config.h_data = [H[k].data.data for k in range(len_h)]; config.h_ind = [H[k].data.indices for k in range(len_h)]; config.h_ptr = [H[k].data.indptr for k in range(len_h)]; for k in config.c_td_inds:; config.h_data.append(-0.5j * config.n_ops_data[k]); config.h_ind.append(config.n_ops_ind[k]); config.h_ptr.append(config.n_ops_ptr[k]); config.h_data = -1.0j * np.array(config.h_data); config.h_ind = np.array(config.h_ind); config.h_ptr = np.array(config.h_ptr). # set execuatble code for collapse expectation values and spmv; col_spmv_code = (""state = _cy_col_spmv_func(j, ODE.t, "" +; ""config.c_ops_data[j], config.c_ops_ind[j], "" +; ""config.c_ops_ptr[j], ODE.y""); col_expect_code = (""for i in config.c_td_inds: "" +; ""n_dp.append(_cy_col_expect_func(i, ODE.t, "" +; ""config.n_ops_data[i], "" +; ""config.n_ops_ind[i], "" +; ""config.n_ops_ptr[i], ODE.y""); for kk in range(len(config.c_args)):; col_spmv_code += "",config.c_args["" + str(kk) + ""]""; col_expect_code += "",config.c_args["" + str(kk) + ""]""; col_spmv_code += "")""; col_expect_code += ""))"". config.col_spmv_code = col_spmv_code; config.col_expect_code = col_expect_code. # setup ode args string; config.string = """"; data_range = range(len(config.h_data)); for k in data_range:; config.string += (""config.h_data["" + str(k) +; ""], config.h_ind["" + str(k) +; ""], config.h_ptr["" + str(k) + ""]""); if k != data_range[-1]:; config.string += "",""; ; # Add objects to ode args string; for k in range(len(config.h_tdterms)):; if isinstance(config.h_tdterms[k], Cubic_Spline):; config.string += "", config.h_tdterms[""+str(k)+""].coeffs""; ; # attach args to ode args string; if len(config.c_args) > 0:; for kk in range(len(config.c_args)):; config.string += "","" + ""config.c_args["" + str(kk) + ""]"". name = ""rhs"" + str(os.getpid())",MatchSource.WIKI,docs/4.2/modules/qutip/mcsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html
https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:35890,Modifiability,config,config,35890,"config.c_td_inds = np.array([]); C_tdterms = np.array([]); C_inds = np.array([]). # tidyup; if options.tidy:; H = np.array([H[k].tidyup(options.atol); for k in range(len_h)], dtype=object); # construct data sets; config.h_data = [H[k].data.data for k in range(len_h)]; config.h_ind = [H[k].data.indices for k in range(len_h)]; config.h_ptr = [H[k].data.indptr for k in range(len_h)]; for k in config.c_td_inds:; config.h_data.append(-0.5j * config.n_ops_data[k]); config.h_ind.append(config.n_ops_ind[k]); config.h_ptr.append(config.n_ops_ptr[k]); config.h_data = -1.0j * np.array(config.h_data); config.h_ind = np.array(config.h_ind); config.h_ptr = np.array(config.h_ptr). # set execuatble code for collapse expectation values and spmv; col_spmv_code = (""state = _cy_col_spmv_func(j, ODE.t, "" +; ""config.c_ops_data[j], config.c_ops_ind[j], "" +; ""config.c_ops_ptr[j], ODE.y""); col_expect_code = (""for i in config.c_td_inds: "" +; ""n_dp.append(_cy_col_expect_func(i, ODE.t, "" +; ""config.n_ops_data[i], "" +; ""config.n_ops_ind[i], "" +; ""config.n_ops_ptr[i], ODE.y""); for kk in range(len(config.c_args)):; col_spmv_code += "",config.c_args["" + str(kk) + ""]""; col_expect_code += "",config.c_args["" + str(kk) + ""]""; col_spmv_code += "")""; col_expect_code += ""))"". config.col_spmv_code = col_spmv_code; config.col_expect_code = col_expect_code. # setup ode args string; config.string = """"; data_range = range(len(config.h_data)); for k in data_range:; config.string += (""config.h_data["" + str(k) +; ""], config.h_ind["" + str(k) +; ""], config.h_ptr["" + str(k) + ""]""); if k != data_range[-1]:; config.string += "",""; ; # Add objects to ode args string; for k in range(len(config.h_tdterms)):; if isinstance(config.h_tdterms[k], Cubic_Spline):; config.string += "", config.h_tdterms[""+str(k)+""].coeffs""; ; # attach args to ode args string; if len(config.c_args) > 0:; for kk in range(len(config.c_args)):; config.string += "","" + ""config.c_args["" + str(kk) + ""]"". name = ""rhs"" + str(os.getpid()) + str(config.cgen_num",MatchSource.WIKI,docs/4.2/modules/qutip/mcsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html
https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:35917,Modifiability,config,config,35917,"([]); C_tdterms = np.array([]); C_inds = np.array([]). # tidyup; if options.tidy:; H = np.array([H[k].tidyup(options.atol); for k in range(len_h)], dtype=object); # construct data sets; config.h_data = [H[k].data.data for k in range(len_h)]; config.h_ind = [H[k].data.indices for k in range(len_h)]; config.h_ptr = [H[k].data.indptr for k in range(len_h)]; for k in config.c_td_inds:; config.h_data.append(-0.5j * config.n_ops_data[k]); config.h_ind.append(config.n_ops_ind[k]); config.h_ptr.append(config.n_ops_ptr[k]); config.h_data = -1.0j * np.array(config.h_data); config.h_ind = np.array(config.h_ind); config.h_ptr = np.array(config.h_ptr). # set execuatble code for collapse expectation values and spmv; col_spmv_code = (""state = _cy_col_spmv_func(j, ODE.t, "" +; ""config.c_ops_data[j], config.c_ops_ind[j], "" +; ""config.c_ops_ptr[j], ODE.y""); col_expect_code = (""for i in config.c_td_inds: "" +; ""n_dp.append(_cy_col_expect_func(i, ODE.t, "" +; ""config.n_ops_data[i], "" +; ""config.n_ops_ind[i], "" +; ""config.n_ops_ptr[i], ODE.y""); for kk in range(len(config.c_args)):; col_spmv_code += "",config.c_args["" + str(kk) + ""]""; col_expect_code += "",config.c_args["" + str(kk) + ""]""; col_spmv_code += "")""; col_expect_code += ""))"". config.col_spmv_code = col_spmv_code; config.col_expect_code = col_expect_code. # setup ode args string; config.string = """"; data_range = range(len(config.h_data)); for k in data_range:; config.string += (""config.h_data["" + str(k) +; ""], config.h_ind["" + str(k) +; ""], config.h_ptr["" + str(k) + ""]""); if k != data_range[-1]:; config.string += "",""; ; # Add objects to ode args string; for k in range(len(config.h_tdterms)):; if isinstance(config.h_tdterms[k], Cubic_Spline):; config.string += "", config.h_tdterms[""+str(k)+""].coeffs""; ; # attach args to ode args string; if len(config.c_args) > 0:; for kk in range(len(config.c_args)):; config.string += "","" + ""config.c_args["" + str(kk) + ""]"". name = ""rhs"" + str(os.getpid()) + str(config.cgen_num); config.tdname = name; cge",MatchSource.WIKI,docs/4.2/modules/qutip/mcsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html
https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:35967,Modifiability,config,config,35967,"y([]). # tidyup; if options.tidy:; H = np.array([H[k].tidyup(options.atol); for k in range(len_h)], dtype=object); # construct data sets; config.h_data = [H[k].data.data for k in range(len_h)]; config.h_ind = [H[k].data.indices for k in range(len_h)]; config.h_ptr = [H[k].data.indptr for k in range(len_h)]; for k in config.c_td_inds:; config.h_data.append(-0.5j * config.n_ops_data[k]); config.h_ind.append(config.n_ops_ind[k]); config.h_ptr.append(config.n_ops_ptr[k]); config.h_data = -1.0j * np.array(config.h_data); config.h_ind = np.array(config.h_ind); config.h_ptr = np.array(config.h_ptr). # set execuatble code for collapse expectation values and spmv; col_spmv_code = (""state = _cy_col_spmv_func(j, ODE.t, "" +; ""config.c_ops_data[j], config.c_ops_ind[j], "" +; ""config.c_ops_ptr[j], ODE.y""); col_expect_code = (""for i in config.c_td_inds: "" +; ""n_dp.append(_cy_col_expect_func(i, ODE.t, "" +; ""config.n_ops_data[i], "" +; ""config.n_ops_ind[i], "" +; ""config.n_ops_ptr[i], ODE.y""); for kk in range(len(config.c_args)):; col_spmv_code += "",config.c_args["" + str(kk) + ""]""; col_expect_code += "",config.c_args["" + str(kk) + ""]""; col_spmv_code += "")""; col_expect_code += ""))"". config.col_spmv_code = col_spmv_code; config.col_expect_code = col_expect_code. # setup ode args string; config.string = """"; data_range = range(len(config.h_data)); for k in data_range:; config.string += (""config.h_data["" + str(k) +; ""], config.h_ind["" + str(k) +; ""], config.h_ptr["" + str(k) + ""]""); if k != data_range[-1]:; config.string += "",""; ; # Add objects to ode args string; for k in range(len(config.h_tdterms)):; if isinstance(config.h_tdterms[k], Cubic_Spline):; config.string += "", config.h_tdterms[""+str(k)+""].coeffs""; ; # attach args to ode args string; if len(config.c_args) > 0:; for kk in range(len(config.c_args)):; config.string += "","" + ""config.c_args["" + str(kk) + ""]"". name = ""rhs"" + str(os.getpid()) + str(config.cgen_num); config.tdname = name; cgen = Codegen(H_inds, config.h_tdterms, config.h_",MatchSource.WIKI,docs/4.2/modules/qutip/mcsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html
https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:36004,Modifiability,config,config,36004," H = np.array([H[k].tidyup(options.atol); for k in range(len_h)], dtype=object); # construct data sets; config.h_data = [H[k].data.data for k in range(len_h)]; config.h_ind = [H[k].data.indices for k in range(len_h)]; config.h_ptr = [H[k].data.indptr for k in range(len_h)]; for k in config.c_td_inds:; config.h_data.append(-0.5j * config.n_ops_data[k]); config.h_ind.append(config.n_ops_ind[k]); config.h_ptr.append(config.n_ops_ptr[k]); config.h_data = -1.0j * np.array(config.h_data); config.h_ind = np.array(config.h_ind); config.h_ptr = np.array(config.h_ptr). # set execuatble code for collapse expectation values and spmv; col_spmv_code = (""state = _cy_col_spmv_func(j, ODE.t, "" +; ""config.c_ops_data[j], config.c_ops_ind[j], "" +; ""config.c_ops_ptr[j], ODE.y""); col_expect_code = (""for i in config.c_td_inds: "" +; ""n_dp.append(_cy_col_expect_func(i, ODE.t, "" +; ""config.n_ops_data[i], "" +; ""config.n_ops_ind[i], "" +; ""config.n_ops_ptr[i], ODE.y""); for kk in range(len(config.c_args)):; col_spmv_code += "",config.c_args["" + str(kk) + ""]""; col_expect_code += "",config.c_args["" + str(kk) + ""]""; col_spmv_code += "")""; col_expect_code += ""))"". config.col_spmv_code = col_spmv_code; config.col_expect_code = col_expect_code. # setup ode args string; config.string = """"; data_range = range(len(config.h_data)); for k in data_range:; config.string += (""config.h_data["" + str(k) +; ""], config.h_ind["" + str(k) +; ""], config.h_ptr["" + str(k) + ""]""); if k != data_range[-1]:; config.string += "",""; ; # Add objects to ode args string; for k in range(len(config.h_tdterms)):; if isinstance(config.h_tdterms[k], Cubic_Spline):; config.string += "", config.h_tdterms[""+str(k)+""].coeffs""; ; # attach args to ode args string; if len(config.c_args) > 0:; for kk in range(len(config.c_args)):; config.string += "","" + ""config.c_args["" + str(kk) + ""]"". name = ""rhs"" + str(os.getpid()) + str(config.cgen_num); config.tdname = name; cgen = Codegen(H_inds, config.h_tdterms, config.h_td_inds, args,; C_inds, C_tdterms, ",MatchSource.WIKI,docs/4.2/modules/qutip/mcsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html
https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:36058,Modifiability,config,config,36058,"k in range(len_h)], dtype=object); # construct data sets; config.h_data = [H[k].data.data for k in range(len_h)]; config.h_ind = [H[k].data.indices for k in range(len_h)]; config.h_ptr = [H[k].data.indptr for k in range(len_h)]; for k in config.c_td_inds:; config.h_data.append(-0.5j * config.n_ops_data[k]); config.h_ind.append(config.n_ops_ind[k]); config.h_ptr.append(config.n_ops_ptr[k]); config.h_data = -1.0j * np.array(config.h_data); config.h_ind = np.array(config.h_ind); config.h_ptr = np.array(config.h_ptr). # set execuatble code for collapse expectation values and spmv; col_spmv_code = (""state = _cy_col_spmv_func(j, ODE.t, "" +; ""config.c_ops_data[j], config.c_ops_ind[j], "" +; ""config.c_ops_ptr[j], ODE.y""); col_expect_code = (""for i in config.c_td_inds: "" +; ""n_dp.append(_cy_col_expect_func(i, ODE.t, "" +; ""config.n_ops_data[i], "" +; ""config.n_ops_ind[i], "" +; ""config.n_ops_ptr[i], ODE.y""); for kk in range(len(config.c_args)):; col_spmv_code += "",config.c_args["" + str(kk) + ""]""; col_expect_code += "",config.c_args["" + str(kk) + ""]""; col_spmv_code += "")""; col_expect_code += ""))"". config.col_spmv_code = col_spmv_code; config.col_expect_code = col_expect_code. # setup ode args string; config.string = """"; data_range = range(len(config.h_data)); for k in data_range:; config.string += (""config.h_data["" + str(k) +; ""], config.h_ind["" + str(k) +; ""], config.h_ptr["" + str(k) + ""]""); if k != data_range[-1]:; config.string += "",""; ; # Add objects to ode args string; for k in range(len(config.h_tdterms)):; if isinstance(config.h_tdterms[k], Cubic_Spline):; config.string += "", config.h_tdterms[""+str(k)+""].coeffs""; ; # attach args to ode args string; if len(config.c_args) > 0:; for kk in range(len(config.c_args)):; config.string += "","" + ""config.c_args["" + str(kk) + ""]"". name = ""rhs"" + str(os.getpid()) + str(config.cgen_num); config.tdname = name; cgen = Codegen(H_inds, config.h_tdterms, config.h_td_inds, args,; C_inds, C_tdterms, config.c_td_inds, type='mc',; config=config);",MatchSource.WIKI,docs/4.2/modules/qutip/mcsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html
https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:36138,Modifiability,config,config,36138,"e(len_h)]; config.h_ind = [H[k].data.indices for k in range(len_h)]; config.h_ptr = [H[k].data.indptr for k in range(len_h)]; for k in config.c_td_inds:; config.h_data.append(-0.5j * config.n_ops_data[k]); config.h_ind.append(config.n_ops_ind[k]); config.h_ptr.append(config.n_ops_ptr[k]); config.h_data = -1.0j * np.array(config.h_data); config.h_ind = np.array(config.h_ind); config.h_ptr = np.array(config.h_ptr). # set execuatble code for collapse expectation values and spmv; col_spmv_code = (""state = _cy_col_spmv_func(j, ODE.t, "" +; ""config.c_ops_data[j], config.c_ops_ind[j], "" +; ""config.c_ops_ptr[j], ODE.y""); col_expect_code = (""for i in config.c_td_inds: "" +; ""n_dp.append(_cy_col_expect_func(i, ODE.t, "" +; ""config.n_ops_data[i], "" +; ""config.n_ops_ind[i], "" +; ""config.n_ops_ptr[i], ODE.y""); for kk in range(len(config.c_args)):; col_spmv_code += "",config.c_args["" + str(kk) + ""]""; col_expect_code += "",config.c_args["" + str(kk) + ""]""; col_spmv_code += "")""; col_expect_code += ""))"". config.col_spmv_code = col_spmv_code; config.col_expect_code = col_expect_code. # setup ode args string; config.string = """"; data_range = range(len(config.h_data)); for k in data_range:; config.string += (""config.h_data["" + str(k) +; ""], config.h_ind["" + str(k) +; ""], config.h_ptr["" + str(k) + ""]""); if k != data_range[-1]:; config.string += "",""; ; # Add objects to ode args string; for k in range(len(config.h_tdterms)):; if isinstance(config.h_tdterms[k], Cubic_Spline):; config.string += "", config.h_tdterms[""+str(k)+""].coeffs""; ; # attach args to ode args string; if len(config.c_args) > 0:; for kk in range(len(config.c_args)):; config.string += "","" + ""config.c_args["" + str(kk) + ""]"". name = ""rhs"" + str(os.getpid()) + str(config.cgen_num); config.tdname = name; cgen = Codegen(H_inds, config.h_tdterms, config.h_td_inds, args,; C_inds, C_tdterms, config.c_td_inds, type='mc',; config=config); cgen.generate(name + "".pyx""). elif config.tflag in [2, 20, 22]:; # PYTHON LIST-FUNCTION BASED TIME-DEP",MatchSource.WIKI,docs/4.2/modules/qutip/mcsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html
https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:36176,Modifiability,config,config,36176," = [H[k].data.indices for k in range(len_h)]; config.h_ptr = [H[k].data.indptr for k in range(len_h)]; for k in config.c_td_inds:; config.h_data.append(-0.5j * config.n_ops_data[k]); config.h_ind.append(config.n_ops_ind[k]); config.h_ptr.append(config.n_ops_ptr[k]); config.h_data = -1.0j * np.array(config.h_data); config.h_ind = np.array(config.h_ind); config.h_ptr = np.array(config.h_ptr). # set execuatble code for collapse expectation values and spmv; col_spmv_code = (""state = _cy_col_spmv_func(j, ODE.t, "" +; ""config.c_ops_data[j], config.c_ops_ind[j], "" +; ""config.c_ops_ptr[j], ODE.y""); col_expect_code = (""for i in config.c_td_inds: "" +; ""n_dp.append(_cy_col_expect_func(i, ODE.t, "" +; ""config.n_ops_data[i], "" +; ""config.n_ops_ind[i], "" +; ""config.n_ops_ptr[i], ODE.y""); for kk in range(len(config.c_args)):; col_spmv_code += "",config.c_args["" + str(kk) + ""]""; col_expect_code += "",config.c_args["" + str(kk) + ""]""; col_spmv_code += "")""; col_expect_code += ""))"". config.col_spmv_code = col_spmv_code; config.col_expect_code = col_expect_code. # setup ode args string; config.string = """"; data_range = range(len(config.h_data)); for k in data_range:; config.string += (""config.h_data["" + str(k) +; ""], config.h_ind["" + str(k) +; ""], config.h_ptr["" + str(k) + ""]""); if k != data_range[-1]:; config.string += "",""; ; # Add objects to ode args string; for k in range(len(config.h_tdterms)):; if isinstance(config.h_tdterms[k], Cubic_Spline):; config.string += "", config.h_tdterms[""+str(k)+""].coeffs""; ; # attach args to ode args string; if len(config.c_args) > 0:; for kk in range(len(config.c_args)):; config.string += "","" + ""config.c_args["" + str(kk) + ""]"". name = ""rhs"" + str(os.getpid()) + str(config.cgen_num); config.tdname = name; cgen = Codegen(H_inds, config.h_tdterms, config.h_td_inds, args,; C_inds, C_tdterms, config.c_td_inds, type='mc',; config=config); cgen.generate(name + "".pyx""). elif config.tflag in [2, 20, 22]:; # PYTHON LIST-FUNCTION BASED TIME-DEPENDENCE; # ------------",MatchSource.WIKI,docs/4.2/modules/qutip/mcsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html
https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:36243,Modifiability,config,config,36243,"ta.indptr for k in range(len_h)]; for k in config.c_td_inds:; config.h_data.append(-0.5j * config.n_ops_data[k]); config.h_ind.append(config.n_ops_ind[k]); config.h_ptr.append(config.n_ops_ptr[k]); config.h_data = -1.0j * np.array(config.h_data); config.h_ind = np.array(config.h_ind); config.h_ptr = np.array(config.h_ptr). # set execuatble code for collapse expectation values and spmv; col_spmv_code = (""state = _cy_col_spmv_func(j, ODE.t, "" +; ""config.c_ops_data[j], config.c_ops_ind[j], "" +; ""config.c_ops_ptr[j], ODE.y""); col_expect_code = (""for i in config.c_td_inds: "" +; ""n_dp.append(_cy_col_expect_func(i, ODE.t, "" +; ""config.n_ops_data[i], "" +; ""config.n_ops_ind[i], "" +; ""config.n_ops_ptr[i], ODE.y""); for kk in range(len(config.c_args)):; col_spmv_code += "",config.c_args["" + str(kk) + ""]""; col_expect_code += "",config.c_args["" + str(kk) + ""]""; col_spmv_code += "")""; col_expect_code += ""))"". config.col_spmv_code = col_spmv_code; config.col_expect_code = col_expect_code. # setup ode args string; config.string = """"; data_range = range(len(config.h_data)); for k in data_range:; config.string += (""config.h_data["" + str(k) +; ""], config.h_ind["" + str(k) +; ""], config.h_ptr["" + str(k) + ""]""); if k != data_range[-1]:; config.string += "",""; ; # Add objects to ode args string; for k in range(len(config.h_tdterms)):; if isinstance(config.h_tdterms[k], Cubic_Spline):; config.string += "", config.h_tdterms[""+str(k)+""].coeffs""; ; # attach args to ode args string; if len(config.c_args) > 0:; for kk in range(len(config.c_args)):; config.string += "","" + ""config.c_args["" + str(kk) + ""]"". name = ""rhs"" + str(os.getpid()) + str(config.cgen_num); config.tdname = name; cgen = Codegen(H_inds, config.h_tdterms, config.h_td_inds, args,; C_inds, C_tdterms, config.c_td_inds, type='mc',; config=config); cgen.generate(name + "".pyx""). elif config.tflag in [2, 20, 22]:; # PYTHON LIST-FUNCTION BASED TIME-DEPENDENCE; # ------------------------------------------. # take care of Hamiltonian; if config.",MatchSource.WIKI,docs/4.2/modules/qutip/mcsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html
https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:36286,Modifiability,config,config,36286,"k in config.c_td_inds:; config.h_data.append(-0.5j * config.n_ops_data[k]); config.h_ind.append(config.n_ops_ind[k]); config.h_ptr.append(config.n_ops_ptr[k]); config.h_data = -1.0j * np.array(config.h_data); config.h_ind = np.array(config.h_ind); config.h_ptr = np.array(config.h_ptr). # set execuatble code for collapse expectation values and spmv; col_spmv_code = (""state = _cy_col_spmv_func(j, ODE.t, "" +; ""config.c_ops_data[j], config.c_ops_ind[j], "" +; ""config.c_ops_ptr[j], ODE.y""); col_expect_code = (""for i in config.c_td_inds: "" +; ""n_dp.append(_cy_col_expect_func(i, ODE.t, "" +; ""config.n_ops_data[i], "" +; ""config.n_ops_ind[i], "" +; ""config.n_ops_ptr[i], ODE.y""); for kk in range(len(config.c_args)):; col_spmv_code += "",config.c_args["" + str(kk) + ""]""; col_expect_code += "",config.c_args["" + str(kk) + ""]""; col_spmv_code += "")""; col_expect_code += ""))"". config.col_spmv_code = col_spmv_code; config.col_expect_code = col_expect_code. # setup ode args string; config.string = """"; data_range = range(len(config.h_data)); for k in data_range:; config.string += (""config.h_data["" + str(k) +; ""], config.h_ind["" + str(k) +; ""], config.h_ptr["" + str(k) + ""]""); if k != data_range[-1]:; config.string += "",""; ; # Add objects to ode args string; for k in range(len(config.h_tdterms)):; if isinstance(config.h_tdterms[k], Cubic_Spline):; config.string += "", config.h_tdterms[""+str(k)+""].coeffs""; ; # attach args to ode args string; if len(config.c_args) > 0:; for kk in range(len(config.c_args)):; config.string += "","" + ""config.c_args["" + str(kk) + ""]"". name = ""rhs"" + str(os.getpid()) + str(config.cgen_num); config.tdname = name; cgen = Codegen(H_inds, config.h_tdterms, config.h_td_inds, args,; C_inds, C_tdterms, config.c_td_inds, type='mc',; config=config); cgen.generate(name + "".pyx""). elif config.tflag in [2, 20, 22]:; # PYTHON LIST-FUNCTION BASED TIME-DEPENDENCE; # ------------------------------------------. # take care of Hamiltonian; if config.tflag == 2:; # constant Hamiltonian, a",MatchSource.WIKI,docs/4.2/modules/qutip/mcsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html
https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:36325,Modifiability,config,config,36325,"end(-0.5j * config.n_ops_data[k]); config.h_ind.append(config.n_ops_ind[k]); config.h_ptr.append(config.n_ops_ptr[k]); config.h_data = -1.0j * np.array(config.h_data); config.h_ind = np.array(config.h_ind); config.h_ptr = np.array(config.h_ptr). # set execuatble code for collapse expectation values and spmv; col_spmv_code = (""state = _cy_col_spmv_func(j, ODE.t, "" +; ""config.c_ops_data[j], config.c_ops_ind[j], "" +; ""config.c_ops_ptr[j], ODE.y""); col_expect_code = (""for i in config.c_td_inds: "" +; ""n_dp.append(_cy_col_expect_func(i, ODE.t, "" +; ""config.n_ops_data[i], "" +; ""config.n_ops_ind[i], "" +; ""config.n_ops_ptr[i], ODE.y""); for kk in range(len(config.c_args)):; col_spmv_code += "",config.c_args["" + str(kk) + ""]""; col_expect_code += "",config.c_args["" + str(kk) + ""]""; col_spmv_code += "")""; col_expect_code += ""))"". config.col_spmv_code = col_spmv_code; config.col_expect_code = col_expect_code. # setup ode args string; config.string = """"; data_range = range(len(config.h_data)); for k in data_range:; config.string += (""config.h_data["" + str(k) +; ""], config.h_ind["" + str(k) +; ""], config.h_ptr["" + str(k) + ""]""); if k != data_range[-1]:; config.string += "",""; ; # Add objects to ode args string; for k in range(len(config.h_tdterms)):; if isinstance(config.h_tdterms[k], Cubic_Spline):; config.string += "", config.h_tdterms[""+str(k)+""].coeffs""; ; # attach args to ode args string; if len(config.c_args) > 0:; for kk in range(len(config.c_args)):; config.string += "","" + ""config.c_args["" + str(kk) + ""]"". name = ""rhs"" + str(os.getpid()) + str(config.cgen_num); config.tdname = name; cgen = Codegen(H_inds, config.h_tdterms, config.h_td_inds, args,; C_inds, C_tdterms, config.c_td_inds, type='mc',; config=config); cgen.generate(name + "".pyx""). elif config.tflag in [2, 20, 22]:; # PYTHON LIST-FUNCTION BASED TIME-DEPENDENCE; # ------------------------------------------. # take care of Hamiltonian; if config.tflag == 2:; # constant Hamiltonian, at least one function based collapse; # op",MatchSource.WIKI,docs/4.2/modules/qutip/mcsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html
https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:36344,Modifiability,config,config,36344,"[k]); config.h_ind.append(config.n_ops_ind[k]); config.h_ptr.append(config.n_ops_ptr[k]); config.h_data = -1.0j * np.array(config.h_data); config.h_ind = np.array(config.h_ind); config.h_ptr = np.array(config.h_ptr). # set execuatble code for collapse expectation values and spmv; col_spmv_code = (""state = _cy_col_spmv_func(j, ODE.t, "" +; ""config.c_ops_data[j], config.c_ops_ind[j], "" +; ""config.c_ops_ptr[j], ODE.y""); col_expect_code = (""for i in config.c_td_inds: "" +; ""n_dp.append(_cy_col_expect_func(i, ODE.t, "" +; ""config.n_ops_data[i], "" +; ""config.n_ops_ind[i], "" +; ""config.n_ops_ptr[i], ODE.y""); for kk in range(len(config.c_args)):; col_spmv_code += "",config.c_args["" + str(kk) + ""]""; col_expect_code += "",config.c_args["" + str(kk) + ""]""; col_spmv_code += "")""; col_expect_code += ""))"". config.col_spmv_code = col_spmv_code; config.col_expect_code = col_expect_code. # setup ode args string; config.string = """"; data_range = range(len(config.h_data)); for k in data_range:; config.string += (""config.h_data["" + str(k) +; ""], config.h_ind["" + str(k) +; ""], config.h_ptr["" + str(k) + ""]""); if k != data_range[-1]:; config.string += "",""; ; # Add objects to ode args string; for k in range(len(config.h_tdterms)):; if isinstance(config.h_tdterms[k], Cubic_Spline):; config.string += "", config.h_tdterms[""+str(k)+""].coeffs""; ; # attach args to ode args string; if len(config.c_args) > 0:; for kk in range(len(config.c_args)):; config.string += "","" + ""config.c_args["" + str(kk) + ""]"". name = ""rhs"" + str(os.getpid()) + str(config.cgen_num); config.tdname = name; cgen = Codegen(H_inds, config.h_tdterms, config.h_td_inds, args,; C_inds, C_tdterms, config.c_td_inds, type='mc',; config=config); cgen.generate(name + "".pyx""). elif config.tflag in [2, 20, 22]:; # PYTHON LIST-FUNCTION BASED TIME-DEPENDENCE; # ------------------------------------------. # take care of Hamiltonian; if config.tflag == 2:; # constant Hamiltonian, at least one function based collapse; # operators; H_inds = np.array([0",MatchSource.WIKI,docs/4.2/modules/qutip/mcsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html
https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:36376,Modifiability,config,config,36376,"config.n_ops_ind[k]); config.h_ptr.append(config.n_ops_ptr[k]); config.h_data = -1.0j * np.array(config.h_data); config.h_ind = np.array(config.h_ind); config.h_ptr = np.array(config.h_ptr). # set execuatble code for collapse expectation values and spmv; col_spmv_code = (""state = _cy_col_spmv_func(j, ODE.t, "" +; ""config.c_ops_data[j], config.c_ops_ind[j], "" +; ""config.c_ops_ptr[j], ODE.y""); col_expect_code = (""for i in config.c_td_inds: "" +; ""n_dp.append(_cy_col_expect_func(i, ODE.t, "" +; ""config.n_ops_data[i], "" +; ""config.n_ops_ind[i], "" +; ""config.n_ops_ptr[i], ODE.y""); for kk in range(len(config.c_args)):; col_spmv_code += "",config.c_args["" + str(kk) + ""]""; col_expect_code += "",config.c_args["" + str(kk) + ""]""; col_spmv_code += "")""; col_expect_code += ""))"". config.col_spmv_code = col_spmv_code; config.col_expect_code = col_expect_code. # setup ode args string; config.string = """"; data_range = range(len(config.h_data)); for k in data_range:; config.string += (""config.h_data["" + str(k) +; ""], config.h_ind["" + str(k) +; ""], config.h_ptr["" + str(k) + ""]""); if k != data_range[-1]:; config.string += "",""; ; # Add objects to ode args string; for k in range(len(config.h_tdterms)):; if isinstance(config.h_tdterms[k], Cubic_Spline):; config.string += "", config.h_tdterms[""+str(k)+""].coeffs""; ; # attach args to ode args string; if len(config.c_args) > 0:; for kk in range(len(config.c_args)):; config.string += "","" + ""config.c_args["" + str(kk) + ""]"". name = ""rhs"" + str(os.getpid()) + str(config.cgen_num); config.tdname = name; cgen = Codegen(H_inds, config.h_tdterms, config.h_td_inds, args,; C_inds, C_tdterms, config.c_td_inds, type='mc',; config=config); cgen.generate(name + "".pyx""). elif config.tflag in [2, 20, 22]:; # PYTHON LIST-FUNCTION BASED TIME-DEPENDENCE; # ------------------------------------------. # take care of Hamiltonian; if config.tflag == 2:; # constant Hamiltonian, at least one function based collapse; # operators; H_inds = np.array([0]); H_tdterms = 0; len_h ",MatchSource.WIKI,docs/4.2/modules/qutip/mcsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html
https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:36407,Modifiability,config,config,36407,"ptr.append(config.n_ops_ptr[k]); config.h_data = -1.0j * np.array(config.h_data); config.h_ind = np.array(config.h_ind); config.h_ptr = np.array(config.h_ptr). # set execuatble code for collapse expectation values and spmv; col_spmv_code = (""state = _cy_col_spmv_func(j, ODE.t, "" +; ""config.c_ops_data[j], config.c_ops_ind[j], "" +; ""config.c_ops_ptr[j], ODE.y""); col_expect_code = (""for i in config.c_td_inds: "" +; ""n_dp.append(_cy_col_expect_func(i, ODE.t, "" +; ""config.n_ops_data[i], "" +; ""config.n_ops_ind[i], "" +; ""config.n_ops_ptr[i], ODE.y""); for kk in range(len(config.c_args)):; col_spmv_code += "",config.c_args["" + str(kk) + ""]""; col_expect_code += "",config.c_args["" + str(kk) + ""]""; col_spmv_code += "")""; col_expect_code += ""))"". config.col_spmv_code = col_spmv_code; config.col_expect_code = col_expect_code. # setup ode args string; config.string = """"; data_range = range(len(config.h_data)); for k in data_range:; config.string += (""config.h_data["" + str(k) +; ""], config.h_ind["" + str(k) +; ""], config.h_ptr["" + str(k) + ""]""); if k != data_range[-1]:; config.string += "",""; ; # Add objects to ode args string; for k in range(len(config.h_tdterms)):; if isinstance(config.h_tdterms[k], Cubic_Spline):; config.string += "", config.h_tdterms[""+str(k)+""].coeffs""; ; # attach args to ode args string; if len(config.c_args) > 0:; for kk in range(len(config.c_args)):; config.string += "","" + ""config.c_args["" + str(kk) + ""]"". name = ""rhs"" + str(os.getpid()) + str(config.cgen_num); config.tdname = name; cgen = Codegen(H_inds, config.h_tdterms, config.h_td_inds, args,; C_inds, C_tdterms, config.c_td_inds, type='mc',; config=config); cgen.generate(name + "".pyx""). elif config.tflag in [2, 20, 22]:; # PYTHON LIST-FUNCTION BASED TIME-DEPENDENCE; # ------------------------------------------. # take care of Hamiltonian; if config.tflag == 2:; # constant Hamiltonian, at least one function based collapse; # operators; H_inds = np.array([0]); H_tdterms = 0; len_h = 1; else:; # function based Ham",MatchSource.WIKI,docs/4.2/modules/qutip/mcsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html
https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:36464,Modifiability,config,config,36464,"ta = -1.0j * np.array(config.h_data); config.h_ind = np.array(config.h_ind); config.h_ptr = np.array(config.h_ptr). # set execuatble code for collapse expectation values and spmv; col_spmv_code = (""state = _cy_col_spmv_func(j, ODE.t, "" +; ""config.c_ops_data[j], config.c_ops_ind[j], "" +; ""config.c_ops_ptr[j], ODE.y""); col_expect_code = (""for i in config.c_td_inds: "" +; ""n_dp.append(_cy_col_expect_func(i, ODE.t, "" +; ""config.n_ops_data[i], "" +; ""config.n_ops_ind[i], "" +; ""config.n_ops_ptr[i], ODE.y""); for kk in range(len(config.c_args)):; col_spmv_code += "",config.c_args["" + str(kk) + ""]""; col_expect_code += "",config.c_args["" + str(kk) + ""]""; col_spmv_code += "")""; col_expect_code += ""))"". config.col_spmv_code = col_spmv_code; config.col_expect_code = col_expect_code. # setup ode args string; config.string = """"; data_range = range(len(config.h_data)); for k in data_range:; config.string += (""config.h_data["" + str(k) +; ""], config.h_ind["" + str(k) +; ""], config.h_ptr["" + str(k) + ""]""); if k != data_range[-1]:; config.string += "",""; ; # Add objects to ode args string; for k in range(len(config.h_tdterms)):; if isinstance(config.h_tdterms[k], Cubic_Spline):; config.string += "", config.h_tdterms[""+str(k)+""].coeffs""; ; # attach args to ode args string; if len(config.c_args) > 0:; for kk in range(len(config.c_args)):; config.string += "","" + ""config.c_args["" + str(kk) + ""]"". name = ""rhs"" + str(os.getpid()) + str(config.cgen_num); config.tdname = name; cgen = Codegen(H_inds, config.h_tdterms, config.h_td_inds, args,; C_inds, C_tdterms, config.c_td_inds, type='mc',; config=config); cgen.generate(name + "".pyx""). elif config.tflag in [2, 20, 22]:; # PYTHON LIST-FUNCTION BASED TIME-DEPENDENCE; # ------------------------------------------. # take care of Hamiltonian; if config.tflag == 2:; # constant Hamiltonian, at least one function based collapse; # operators; H_inds = np.array([0]); H_tdterms = 0; len_h = 1; else:; # function based Hamiltonian; H_inds = np.arange(len(H)); H_td_i",MatchSource.WIKI,docs/4.2/modules/qutip/mcsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html
https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:36541,Modifiability,config,config,36541,"g.h_ind); config.h_ptr = np.array(config.h_ptr). # set execuatble code for collapse expectation values and spmv; col_spmv_code = (""state = _cy_col_spmv_func(j, ODE.t, "" +; ""config.c_ops_data[j], config.c_ops_ind[j], "" +; ""config.c_ops_ptr[j], ODE.y""); col_expect_code = (""for i in config.c_td_inds: "" +; ""n_dp.append(_cy_col_expect_func(i, ODE.t, "" +; ""config.n_ops_data[i], "" +; ""config.n_ops_ind[i], "" +; ""config.n_ops_ptr[i], ODE.y""); for kk in range(len(config.c_args)):; col_spmv_code += "",config.c_args["" + str(kk) + ""]""; col_expect_code += "",config.c_args["" + str(kk) + ""]""; col_spmv_code += "")""; col_expect_code += ""))"". config.col_spmv_code = col_spmv_code; config.col_expect_code = col_expect_code. # setup ode args string; config.string = """"; data_range = range(len(config.h_data)); for k in data_range:; config.string += (""config.h_data["" + str(k) +; ""], config.h_ind["" + str(k) +; ""], config.h_ptr["" + str(k) + ""]""); if k != data_range[-1]:; config.string += "",""; ; # Add objects to ode args string; for k in range(len(config.h_tdterms)):; if isinstance(config.h_tdterms[k], Cubic_Spline):; config.string += "", config.h_tdterms[""+str(k)+""].coeffs""; ; # attach args to ode args string; if len(config.c_args) > 0:; for kk in range(len(config.c_args)):; config.string += "","" + ""config.c_args["" + str(kk) + ""]"". name = ""rhs"" + str(os.getpid()) + str(config.cgen_num); config.tdname = name; cgen = Codegen(H_inds, config.h_tdterms, config.h_td_inds, args,; C_inds, C_tdterms, config.c_td_inds, type='mc',; config=config); cgen.generate(name + "".pyx""). elif config.tflag in [2, 20, 22]:; # PYTHON LIST-FUNCTION BASED TIME-DEPENDENCE; # ------------------------------------------. # take care of Hamiltonian; if config.tflag == 2:; # constant Hamiltonian, at least one function based collapse; # operators; H_inds = np.array([0]); H_tdterms = 0; len_h = 1; else:; # function based Hamiltonian; H_inds = np.arange(len(H)); H_td_inds = np.array(h_stuff[1]); H_const_inds = np.setdiff1d(H_inds, H_t",MatchSource.WIKI,docs/4.2/modules/qutip/mcsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html
https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:36576,Modifiability,config,config,36576,"xecuatble code for collapse expectation values and spmv; col_spmv_code = (""state = _cy_col_spmv_func(j, ODE.t, "" +; ""config.c_ops_data[j], config.c_ops_ind[j], "" +; ""config.c_ops_ptr[j], ODE.y""); col_expect_code = (""for i in config.c_td_inds: "" +; ""n_dp.append(_cy_col_expect_func(i, ODE.t, "" +; ""config.n_ops_data[i], "" +; ""config.n_ops_ind[i], "" +; ""config.n_ops_ptr[i], ODE.y""); for kk in range(len(config.c_args)):; col_spmv_code += "",config.c_args["" + str(kk) + ""]""; col_expect_code += "",config.c_args["" + str(kk) + ""]""; col_spmv_code += "")""; col_expect_code += ""))"". config.col_spmv_code = col_spmv_code; config.col_expect_code = col_expect_code. # setup ode args string; config.string = """"; data_range = range(len(config.h_data)); for k in data_range:; config.string += (""config.h_data["" + str(k) +; ""], config.h_ind["" + str(k) +; ""], config.h_ptr["" + str(k) + ""]""); if k != data_range[-1]:; config.string += "",""; ; # Add objects to ode args string; for k in range(len(config.h_tdterms)):; if isinstance(config.h_tdterms[k], Cubic_Spline):; config.string += "", config.h_tdterms[""+str(k)+""].coeffs""; ; # attach args to ode args string; if len(config.c_args) > 0:; for kk in range(len(config.c_args)):; config.string += "","" + ""config.c_args["" + str(kk) + ""]"". name = ""rhs"" + str(os.getpid()) + str(config.cgen_num); config.tdname = name; cgen = Codegen(H_inds, config.h_tdterms, config.h_td_inds, args,; C_inds, C_tdterms, config.c_td_inds, type='mc',; config=config); cgen.generate(name + "".pyx""). elif config.tflag in [2, 20, 22]:; # PYTHON LIST-FUNCTION BASED TIME-DEPENDENCE; # ------------------------------------------. # take care of Hamiltonian; if config.tflag == 2:; # constant Hamiltonian, at least one function based collapse; # operators; H_inds = np.array([0]); H_tdterms = 0; len_h = 1; else:; # function based Hamiltonian; H_inds = np.arange(len(H)); H_td_inds = np.array(h_stuff[1]); H_const_inds = np.setdiff1d(H_inds, H_td_inds); config.h_funcs = np.array([H[k][1] for k in H_t",MatchSource.WIKI,docs/4.2/modules/qutip/mcsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html
https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:36613,Modifiability,config,config,36613,"ion values and spmv; col_spmv_code = (""state = _cy_col_spmv_func(j, ODE.t, "" +; ""config.c_ops_data[j], config.c_ops_ind[j], "" +; ""config.c_ops_ptr[j], ODE.y""); col_expect_code = (""for i in config.c_td_inds: "" +; ""n_dp.append(_cy_col_expect_func(i, ODE.t, "" +; ""config.n_ops_data[i], "" +; ""config.n_ops_ind[i], "" +; ""config.n_ops_ptr[i], ODE.y""); for kk in range(len(config.c_args)):; col_spmv_code += "",config.c_args["" + str(kk) + ""]""; col_expect_code += "",config.c_args["" + str(kk) + ""]""; col_spmv_code += "")""; col_expect_code += ""))"". config.col_spmv_code = col_spmv_code; config.col_expect_code = col_expect_code. # setup ode args string; config.string = """"; data_range = range(len(config.h_data)); for k in data_range:; config.string += (""config.h_data["" + str(k) +; ""], config.h_ind["" + str(k) +; ""], config.h_ptr["" + str(k) + ""]""); if k != data_range[-1]:; config.string += "",""; ; # Add objects to ode args string; for k in range(len(config.h_tdterms)):; if isinstance(config.h_tdterms[k], Cubic_Spline):; config.string += "", config.h_tdterms[""+str(k)+""].coeffs""; ; # attach args to ode args string; if len(config.c_args) > 0:; for kk in range(len(config.c_args)):; config.string += "","" + ""config.c_args["" + str(kk) + ""]"". name = ""rhs"" + str(os.getpid()) + str(config.cgen_num); config.tdname = name; cgen = Codegen(H_inds, config.h_tdterms, config.h_td_inds, args,; C_inds, C_tdterms, config.c_td_inds, type='mc',; config=config); cgen.generate(name + "".pyx""). elif config.tflag in [2, 20, 22]:; # PYTHON LIST-FUNCTION BASED TIME-DEPENDENCE; # ------------------------------------------. # take care of Hamiltonian; if config.tflag == 2:; # constant Hamiltonian, at least one function based collapse; # operators; H_inds = np.array([0]); H_tdterms = 0; len_h = 1; else:; # function based Hamiltonian; H_inds = np.arange(len(H)); H_td_inds = np.array(h_stuff[1]); H_const_inds = np.setdiff1d(H_inds, H_td_inds); config.h_funcs = np.array([H[k][1] for k in H_td_inds]); config.h_func_args = args;",MatchSource.WIKI,docs/4.2/modules/qutip/mcsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html
https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:36633,Modifiability,config,config,36633,"_code = (""state = _cy_col_spmv_func(j, ODE.t, "" +; ""config.c_ops_data[j], config.c_ops_ind[j], "" +; ""config.c_ops_ptr[j], ODE.y""); col_expect_code = (""for i in config.c_td_inds: "" +; ""n_dp.append(_cy_col_expect_func(i, ODE.t, "" +; ""config.n_ops_data[i], "" +; ""config.n_ops_ind[i], "" +; ""config.n_ops_ptr[i], ODE.y""); for kk in range(len(config.c_args)):; col_spmv_code += "",config.c_args["" + str(kk) + ""]""; col_expect_code += "",config.c_args["" + str(kk) + ""]""; col_spmv_code += "")""; col_expect_code += ""))"". config.col_spmv_code = col_spmv_code; config.col_expect_code = col_expect_code. # setup ode args string; config.string = """"; data_range = range(len(config.h_data)); for k in data_range:; config.string += (""config.h_data["" + str(k) +; ""], config.h_ind["" + str(k) +; ""], config.h_ptr["" + str(k) + ""]""); if k != data_range[-1]:; config.string += "",""; ; # Add objects to ode args string; for k in range(len(config.h_tdterms)):; if isinstance(config.h_tdterms[k], Cubic_Spline):; config.string += "", config.h_tdterms[""+str(k)+""].coeffs""; ; # attach args to ode args string; if len(config.c_args) > 0:; for kk in range(len(config.c_args)):; config.string += "","" + ""config.c_args["" + str(kk) + ""]"". name = ""rhs"" + str(os.getpid()) + str(config.cgen_num); config.tdname = name; cgen = Codegen(H_inds, config.h_tdterms, config.h_td_inds, args,; C_inds, C_tdterms, config.c_td_inds, type='mc',; config=config); cgen.generate(name + "".pyx""). elif config.tflag in [2, 20, 22]:; # PYTHON LIST-FUNCTION BASED TIME-DEPENDENCE; # ------------------------------------------. # take care of Hamiltonian; if config.tflag == 2:; # constant Hamiltonian, at least one function based collapse; # operators; H_inds = np.array([0]); H_tdterms = 0; len_h = 1; else:; # function based Hamiltonian; H_inds = np.arange(len(H)); H_td_inds = np.array(h_stuff[1]); H_const_inds = np.setdiff1d(H_inds, H_td_inds); config.h_funcs = np.array([H[k][1] for k in H_td_inds]); config.h_func_args = args; Htd = np.array([H[k][0] for",MatchSource.WIKI,docs/4.2/modules/qutip/mcsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html
https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:36714,Modifiability,config,config,36714,"ops_data[j], config.c_ops_ind[j], "" +; ""config.c_ops_ptr[j], ODE.y""); col_expect_code = (""for i in config.c_td_inds: "" +; ""n_dp.append(_cy_col_expect_func(i, ODE.t, "" +; ""config.n_ops_data[i], "" +; ""config.n_ops_ind[i], "" +; ""config.n_ops_ptr[i], ODE.y""); for kk in range(len(config.c_args)):; col_spmv_code += "",config.c_args["" + str(kk) + ""]""; col_expect_code += "",config.c_args["" + str(kk) + ""]""; col_spmv_code += "")""; col_expect_code += ""))"". config.col_spmv_code = col_spmv_code; config.col_expect_code = col_expect_code. # setup ode args string; config.string = """"; data_range = range(len(config.h_data)); for k in data_range:; config.string += (""config.h_data["" + str(k) +; ""], config.h_ind["" + str(k) +; ""], config.h_ptr["" + str(k) + ""]""); if k != data_range[-1]:; config.string += "",""; ; # Add objects to ode args string; for k in range(len(config.h_tdterms)):; if isinstance(config.h_tdterms[k], Cubic_Spline):; config.string += "", config.h_tdterms[""+str(k)+""].coeffs""; ; # attach args to ode args string; if len(config.c_args) > 0:; for kk in range(len(config.c_args)):; config.string += "","" + ""config.c_args["" + str(kk) + ""]"". name = ""rhs"" + str(os.getpid()) + str(config.cgen_num); config.tdname = name; cgen = Codegen(H_inds, config.h_tdterms, config.h_td_inds, args,; C_inds, C_tdterms, config.c_td_inds, type='mc',; config=config); cgen.generate(name + "".pyx""). elif config.tflag in [2, 20, 22]:; # PYTHON LIST-FUNCTION BASED TIME-DEPENDENCE; # ------------------------------------------. # take care of Hamiltonian; if config.tflag == 2:; # constant Hamiltonian, at least one function based collapse; # operators; H_inds = np.array([0]); H_tdterms = 0; len_h = 1; else:; # function based Hamiltonian; H_inds = np.arange(len(H)); H_td_inds = np.array(h_stuff[1]); H_const_inds = np.setdiff1d(H_inds, H_td_inds); config.h_funcs = np.array([H[k][1] for k in H_td_inds]); config.h_func_args = args; Htd = np.array([H[k][0] for k in H_td_inds], dtype=object); config.h_td_inds = np.arange(",MatchSource.WIKI,docs/4.2/modules/qutip/mcsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html
https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:36755,Modifiability,config,config,36755,"ps_ptr[j], ODE.y""); col_expect_code = (""for i in config.c_td_inds: "" +; ""n_dp.append(_cy_col_expect_func(i, ODE.t, "" +; ""config.n_ops_data[i], "" +; ""config.n_ops_ind[i], "" +; ""config.n_ops_ptr[i], ODE.y""); for kk in range(len(config.c_args)):; col_spmv_code += "",config.c_args["" + str(kk) + ""]""; col_expect_code += "",config.c_args["" + str(kk) + ""]""; col_spmv_code += "")""; col_expect_code += ""))"". config.col_spmv_code = col_spmv_code; config.col_expect_code = col_expect_code. # setup ode args string; config.string = """"; data_range = range(len(config.h_data)); for k in data_range:; config.string += (""config.h_data["" + str(k) +; ""], config.h_ind["" + str(k) +; ""], config.h_ptr["" + str(k) + ""]""); if k != data_range[-1]:; config.string += "",""; ; # Add objects to ode args string; for k in range(len(config.h_tdterms)):; if isinstance(config.h_tdterms[k], Cubic_Spline):; config.string += "", config.h_tdterms[""+str(k)+""].coeffs""; ; # attach args to ode args string; if len(config.c_args) > 0:; for kk in range(len(config.c_args)):; config.string += "","" + ""config.c_args["" + str(kk) + ""]"". name = ""rhs"" + str(os.getpid()) + str(config.cgen_num); config.tdname = name; cgen = Codegen(H_inds, config.h_tdterms, config.h_td_inds, args,; C_inds, C_tdterms, config.c_td_inds, type='mc',; config=config); cgen.generate(name + "".pyx""). elif config.tflag in [2, 20, 22]:; # PYTHON LIST-FUNCTION BASED TIME-DEPENDENCE; # ------------------------------------------. # take care of Hamiltonian; if config.tflag == 2:; # constant Hamiltonian, at least one function based collapse; # operators; H_inds = np.array([0]); H_tdterms = 0; len_h = 1; else:; # function based Hamiltonian; H_inds = np.arange(len(H)); H_td_inds = np.array(h_stuff[1]); H_const_inds = np.setdiff1d(H_inds, H_td_inds); config.h_funcs = np.array([H[k][1] for k in H_td_inds]); config.h_func_args = args; Htd = np.array([H[k][0] for k in H_td_inds], dtype=object); config.h_td_inds = np.arange(len(Htd)); H = np.sum(H[k] for k in H_const_inds).",MatchSource.WIKI,docs/4.2/modules/qutip/mcsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html
https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:36773,Modifiability,config,config,36773,"_code = (""for i in config.c_td_inds: "" +; ""n_dp.append(_cy_col_expect_func(i, ODE.t, "" +; ""config.n_ops_data[i], "" +; ""config.n_ops_ind[i], "" +; ""config.n_ops_ptr[i], ODE.y""); for kk in range(len(config.c_args)):; col_spmv_code += "",config.c_args["" + str(kk) + ""]""; col_expect_code += "",config.c_args["" + str(kk) + ""]""; col_spmv_code += "")""; col_expect_code += ""))"". config.col_spmv_code = col_spmv_code; config.col_expect_code = col_expect_code. # setup ode args string; config.string = """"; data_range = range(len(config.h_data)); for k in data_range:; config.string += (""config.h_data["" + str(k) +; ""], config.h_ind["" + str(k) +; ""], config.h_ptr["" + str(k) + ""]""); if k != data_range[-1]:; config.string += "",""; ; # Add objects to ode args string; for k in range(len(config.h_tdterms)):; if isinstance(config.h_tdterms[k], Cubic_Spline):; config.string += "", config.h_tdterms[""+str(k)+""].coeffs""; ; # attach args to ode args string; if len(config.c_args) > 0:; for kk in range(len(config.c_args)):; config.string += "","" + ""config.c_args["" + str(kk) + ""]"". name = ""rhs"" + str(os.getpid()) + str(config.cgen_num); config.tdname = name; cgen = Codegen(H_inds, config.h_tdterms, config.h_td_inds, args,; C_inds, C_tdterms, config.c_td_inds, type='mc',; config=config); cgen.generate(name + "".pyx""). elif config.tflag in [2, 20, 22]:; # PYTHON LIST-FUNCTION BASED TIME-DEPENDENCE; # ------------------------------------------. # take care of Hamiltonian; if config.tflag == 2:; # constant Hamiltonian, at least one function based collapse; # operators; H_inds = np.array([0]); H_tdterms = 0; len_h = 1; else:; # function based Hamiltonian; H_inds = np.arange(len(H)); H_td_inds = np.array(h_stuff[1]); H_const_inds = np.setdiff1d(H_inds, H_td_inds); config.h_funcs = np.array([H[k][1] for k in H_td_inds]); config.h_func_args = args; Htd = np.array([H[k][0] for k in H_td_inds], dtype=object); config.h_td_inds = np.arange(len(Htd)); H = np.sum(H[k] for k in H_const_inds). # take care of collapse oper",MatchSource.WIKI,docs/4.2/modules/qutip/mcsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html
https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:36797,Modifiability,config,config,36797,"nfig.c_td_inds: "" +; ""n_dp.append(_cy_col_expect_func(i, ODE.t, "" +; ""config.n_ops_data[i], "" +; ""config.n_ops_ind[i], "" +; ""config.n_ops_ptr[i], ODE.y""); for kk in range(len(config.c_args)):; col_spmv_code += "",config.c_args["" + str(kk) + ""]""; col_expect_code += "",config.c_args["" + str(kk) + ""]""; col_spmv_code += "")""; col_expect_code += ""))"". config.col_spmv_code = col_spmv_code; config.col_expect_code = col_expect_code. # setup ode args string; config.string = """"; data_range = range(len(config.h_data)); for k in data_range:; config.string += (""config.h_data["" + str(k) +; ""], config.h_ind["" + str(k) +; ""], config.h_ptr["" + str(k) + ""]""); if k != data_range[-1]:; config.string += "",""; ; # Add objects to ode args string; for k in range(len(config.h_tdterms)):; if isinstance(config.h_tdterms[k], Cubic_Spline):; config.string += "", config.h_tdterms[""+str(k)+""].coeffs""; ; # attach args to ode args string; if len(config.c_args) > 0:; for kk in range(len(config.c_args)):; config.string += "","" + ""config.c_args["" + str(kk) + ""]"". name = ""rhs"" + str(os.getpid()) + str(config.cgen_num); config.tdname = name; cgen = Codegen(H_inds, config.h_tdterms, config.h_td_inds, args,; C_inds, C_tdterms, config.c_td_inds, type='mc',; config=config); cgen.generate(name + "".pyx""). elif config.tflag in [2, 20, 22]:; # PYTHON LIST-FUNCTION BASED TIME-DEPENDENCE; # ------------------------------------------. # take care of Hamiltonian; if config.tflag == 2:; # constant Hamiltonian, at least one function based collapse; # operators; H_inds = np.array([0]); H_tdterms = 0; len_h = 1; else:; # function based Hamiltonian; H_inds = np.arange(len(H)); H_td_inds = np.array(h_stuff[1]); H_const_inds = np.setdiff1d(H_inds, H_td_inds); config.h_funcs = np.array([H[k][1] for k in H_td_inds]); config.h_func_args = args; Htd = np.array([H[k][0] for k in H_td_inds], dtype=object); config.h_td_inds = np.arange(len(Htd)); H = np.sum(H[k] for k in H_const_inds). # take care of collapse operators; C_inds = np.ar",MatchSource.WIKI,docs/4.2/modules/qutip/mcsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html
https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:36868,Modifiability,config,config,36868,"onfig.n_ops_data[i], "" +; ""config.n_ops_ind[i], "" +; ""config.n_ops_ptr[i], ODE.y""); for kk in range(len(config.c_args)):; col_spmv_code += "",config.c_args["" + str(kk) + ""]""; col_expect_code += "",config.c_args["" + str(kk) + ""]""; col_spmv_code += "")""; col_expect_code += ""))"". config.col_spmv_code = col_spmv_code; config.col_expect_code = col_expect_code. # setup ode args string; config.string = """"; data_range = range(len(config.h_data)); for k in data_range:; config.string += (""config.h_data["" + str(k) +; ""], config.h_ind["" + str(k) +; ""], config.h_ptr["" + str(k) + ""]""); if k != data_range[-1]:; config.string += "",""; ; # Add objects to ode args string; for k in range(len(config.h_tdterms)):; if isinstance(config.h_tdterms[k], Cubic_Spline):; config.string += "", config.h_tdterms[""+str(k)+""].coeffs""; ; # attach args to ode args string; if len(config.c_args) > 0:; for kk in range(len(config.c_args)):; config.string += "","" + ""config.c_args["" + str(kk) + ""]"". name = ""rhs"" + str(os.getpid()) + str(config.cgen_num); config.tdname = name; cgen = Codegen(H_inds, config.h_tdterms, config.h_td_inds, args,; C_inds, C_tdterms, config.c_td_inds, type='mc',; config=config); cgen.generate(name + "".pyx""). elif config.tflag in [2, 20, 22]:; # PYTHON LIST-FUNCTION BASED TIME-DEPENDENCE; # ------------------------------------------. # take care of Hamiltonian; if config.tflag == 2:; # constant Hamiltonian, at least one function based collapse; # operators; H_inds = np.array([0]); H_tdterms = 0; len_h = 1; else:; # function based Hamiltonian; H_inds = np.arange(len(H)); H_td_inds = np.array(h_stuff[1]); H_const_inds = np.setdiff1d(H_inds, H_td_inds); config.h_funcs = np.array([H[k][1] for k in H_td_inds]); config.h_func_args = args; Htd = np.array([H[k][0] for k in H_td_inds], dtype=object); config.h_td_inds = np.arange(len(Htd)); H = np.sum(H[k] for k in H_const_inds). # take care of collapse operators; C_inds = np.arange(config.c_num); # find inds of time-dependent terms; C_td_inds = np.",MatchSource.WIKI,docs/4.2/modules/qutip/mcsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html
https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:36886,Modifiability,config,config,36886,""" +; ""config.n_ops_ind[i], "" +; ""config.n_ops_ptr[i], ODE.y""); for kk in range(len(config.c_args)):; col_spmv_code += "",config.c_args["" + str(kk) + ""]""; col_expect_code += "",config.c_args["" + str(kk) + ""]""; col_spmv_code += "")""; col_expect_code += ""))"". config.col_spmv_code = col_spmv_code; config.col_expect_code = col_expect_code. # setup ode args string; config.string = """"; data_range = range(len(config.h_data)); for k in data_range:; config.string += (""config.h_data["" + str(k) +; ""], config.h_ind["" + str(k) +; ""], config.h_ptr["" + str(k) + ""]""); if k != data_range[-1]:; config.string += "",""; ; # Add objects to ode args string; for k in range(len(config.h_tdterms)):; if isinstance(config.h_tdterms[k], Cubic_Spline):; config.string += "", config.h_tdterms[""+str(k)+""].coeffs""; ; # attach args to ode args string; if len(config.c_args) > 0:; for kk in range(len(config.c_args)):; config.string += "","" + ""config.c_args["" + str(kk) + ""]"". name = ""rhs"" + str(os.getpid()) + str(config.cgen_num); config.tdname = name; cgen = Codegen(H_inds, config.h_tdterms, config.h_td_inds, args,; C_inds, C_tdterms, config.c_td_inds, type='mc',; config=config); cgen.generate(name + "".pyx""). elif config.tflag in [2, 20, 22]:; # PYTHON LIST-FUNCTION BASED TIME-DEPENDENCE; # ------------------------------------------. # take care of Hamiltonian; if config.tflag == 2:; # constant Hamiltonian, at least one function based collapse; # operators; H_inds = np.array([0]); H_tdterms = 0; len_h = 1; else:; # function based Hamiltonian; H_inds = np.arange(len(H)); H_td_inds = np.array(h_stuff[1]); H_const_inds = np.setdiff1d(H_inds, H_td_inds); config.h_funcs = np.array([H[k][1] for k in H_td_inds]); config.h_func_args = args; Htd = np.array([H[k][0] for k in H_td_inds], dtype=object); config.h_td_inds = np.arange(len(Htd)); H = np.sum(H[k] for k in H_const_inds). # take care of collapse operators; C_inds = np.arange(config.c_num); # find inds of time-dependent terms; C_td_inds = np.array(c_stuff[1]); #",MatchSource.WIKI,docs/4.2/modules/qutip/mcsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html
https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:36931,Modifiability,config,config,36931," ""config.n_ops_ptr[i], ODE.y""); for kk in range(len(config.c_args)):; col_spmv_code += "",config.c_args["" + str(kk) + ""]""; col_expect_code += "",config.c_args["" + str(kk) + ""]""; col_spmv_code += "")""; col_expect_code += ""))"". config.col_spmv_code = col_spmv_code; config.col_expect_code = col_expect_code. # setup ode args string; config.string = """"; data_range = range(len(config.h_data)); for k in data_range:; config.string += (""config.h_data["" + str(k) +; ""], config.h_ind["" + str(k) +; ""], config.h_ptr["" + str(k) + ""]""); if k != data_range[-1]:; config.string += "",""; ; # Add objects to ode args string; for k in range(len(config.h_tdterms)):; if isinstance(config.h_tdterms[k], Cubic_Spline):; config.string += "", config.h_tdterms[""+str(k)+""].coeffs""; ; # attach args to ode args string; if len(config.c_args) > 0:; for kk in range(len(config.c_args)):; config.string += "","" + ""config.c_args["" + str(kk) + ""]"". name = ""rhs"" + str(os.getpid()) + str(config.cgen_num); config.tdname = name; cgen = Codegen(H_inds, config.h_tdterms, config.h_td_inds, args,; C_inds, C_tdterms, config.c_td_inds, type='mc',; config=config); cgen.generate(name + "".pyx""). elif config.tflag in [2, 20, 22]:; # PYTHON LIST-FUNCTION BASED TIME-DEPENDENCE; # ------------------------------------------. # take care of Hamiltonian; if config.tflag == 2:; # constant Hamiltonian, at least one function based collapse; # operators; H_inds = np.array([0]); H_tdterms = 0; len_h = 1; else:; # function based Hamiltonian; H_inds = np.arange(len(H)); H_td_inds = np.array(h_stuff[1]); H_const_inds = np.setdiff1d(H_inds, H_td_inds); config.h_funcs = np.array([H[k][1] for k in H_td_inds]); config.h_func_args = args; Htd = np.array([H[k][0] for k in H_td_inds], dtype=object); config.h_td_inds = np.arange(len(Htd)); H = np.sum(H[k] for k in H_const_inds). # take care of collapse operators; C_inds = np.arange(config.c_num); # find inds of time-dependent terms; C_td_inds = np.array(c_stuff[1]); # find inds of constant terms; C_",MatchSource.WIKI,docs/4.2/modules/qutip/mcsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html
https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:36949,Modifiability,config,config,36949,"for kk in range(len(config.c_args)):; col_spmv_code += "",config.c_args["" + str(kk) + ""]""; col_expect_code += "",config.c_args["" + str(kk) + ""]""; col_spmv_code += "")""; col_expect_code += ""))"". config.col_spmv_code = col_spmv_code; config.col_expect_code = col_expect_code. # setup ode args string; config.string = """"; data_range = range(len(config.h_data)); for k in data_range:; config.string += (""config.h_data["" + str(k) +; ""], config.h_ind["" + str(k) +; ""], config.h_ptr["" + str(k) + ""]""); if k != data_range[-1]:; config.string += "",""; ; # Add objects to ode args string; for k in range(len(config.h_tdterms)):; if isinstance(config.h_tdterms[k], Cubic_Spline):; config.string += "", config.h_tdterms[""+str(k)+""].coeffs""; ; # attach args to ode args string; if len(config.c_args) > 0:; for kk in range(len(config.c_args)):; config.string += "","" + ""config.c_args["" + str(kk) + ""]"". name = ""rhs"" + str(os.getpid()) + str(config.cgen_num); config.tdname = name; cgen = Codegen(H_inds, config.h_tdterms, config.h_td_inds, args,; C_inds, C_tdterms, config.c_td_inds, type='mc',; config=config); cgen.generate(name + "".pyx""). elif config.tflag in [2, 20, 22]:; # PYTHON LIST-FUNCTION BASED TIME-DEPENDENCE; # ------------------------------------------. # take care of Hamiltonian; if config.tflag == 2:; # constant Hamiltonian, at least one function based collapse; # operators; H_inds = np.array([0]); H_tdterms = 0; len_h = 1; else:; # function based Hamiltonian; H_inds = np.arange(len(H)); H_td_inds = np.array(h_stuff[1]); H_const_inds = np.setdiff1d(H_inds, H_td_inds); config.h_funcs = np.array([H[k][1] for k in H_td_inds]); config.h_func_args = args; Htd = np.array([H[k][0] for k in H_td_inds], dtype=object); config.h_td_inds = np.arange(len(Htd)); H = np.sum(H[k] for k in H_const_inds). # take care of collapse operators; C_inds = np.arange(config.c_num); # find inds of time-dependent terms; C_td_inds = np.array(c_stuff[1]); # find inds of constant terms; C_const_inds = np.setdiff1d(C_ind",MatchSource.WIKI,docs/4.2/modules/qutip/mcsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html
https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:36993,Modifiability,config,config,36993,"gs)):; col_spmv_code += "",config.c_args["" + str(kk) + ""]""; col_expect_code += "",config.c_args["" + str(kk) + ""]""; col_spmv_code += "")""; col_expect_code += ""))"". config.col_spmv_code = col_spmv_code; config.col_expect_code = col_expect_code. # setup ode args string; config.string = """"; data_range = range(len(config.h_data)); for k in data_range:; config.string += (""config.h_data["" + str(k) +; ""], config.h_ind["" + str(k) +; ""], config.h_ptr["" + str(k) + ""]""); if k != data_range[-1]:; config.string += "",""; ; # Add objects to ode args string; for k in range(len(config.h_tdterms)):; if isinstance(config.h_tdterms[k], Cubic_Spline):; config.string += "", config.h_tdterms[""+str(k)+""].coeffs""; ; # attach args to ode args string; if len(config.c_args) > 0:; for kk in range(len(config.c_args)):; config.string += "","" + ""config.c_args["" + str(kk) + ""]"". name = ""rhs"" + str(os.getpid()) + str(config.cgen_num); config.tdname = name; cgen = Codegen(H_inds, config.h_tdterms, config.h_td_inds, args,; C_inds, C_tdterms, config.c_td_inds, type='mc',; config=config); cgen.generate(name + "".pyx""). elif config.tflag in [2, 20, 22]:; # PYTHON LIST-FUNCTION BASED TIME-DEPENDENCE; # ------------------------------------------. # take care of Hamiltonian; if config.tflag == 2:; # constant Hamiltonian, at least one function based collapse; # operators; H_inds = np.array([0]); H_tdterms = 0; len_h = 1; else:; # function based Hamiltonian; H_inds = np.arange(len(H)); H_td_inds = np.array(h_stuff[1]); H_const_inds = np.setdiff1d(H_inds, H_td_inds); config.h_funcs = np.array([H[k][1] for k in H_td_inds]); config.h_func_args = args; Htd = np.array([H[k][0] for k in H_td_inds], dtype=object); config.h_td_inds = np.arange(len(Htd)); H = np.sum(H[k] for k in H_const_inds). # take care of collapse operators; C_inds = np.arange(config.c_num); # find inds of time-dependent terms; C_td_inds = np.array(c_stuff[1]); # find inds of constant terms; C_const_inds = np.setdiff1d(C_inds, C_td_inds); # store indicies",MatchSource.WIKI,docs/4.2/modules/qutip/mcsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html
https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:37023,Modifiability,config,config,37023,"str(kk) + ""]""; col_expect_code += "",config.c_args["" + str(kk) + ""]""; col_spmv_code += "")""; col_expect_code += ""))"". config.col_spmv_code = col_spmv_code; config.col_expect_code = col_expect_code. # setup ode args string; config.string = """"; data_range = range(len(config.h_data)); for k in data_range:; config.string += (""config.h_data["" + str(k) +; ""], config.h_ind["" + str(k) +; ""], config.h_ptr["" + str(k) + ""]""); if k != data_range[-1]:; config.string += "",""; ; # Add objects to ode args string; for k in range(len(config.h_tdterms)):; if isinstance(config.h_tdterms[k], Cubic_Spline):; config.string += "", config.h_tdterms[""+str(k)+""].coeffs""; ; # attach args to ode args string; if len(config.c_args) > 0:; for kk in range(len(config.c_args)):; config.string += "","" + ""config.c_args["" + str(kk) + ""]"". name = ""rhs"" + str(os.getpid()) + str(config.cgen_num); config.tdname = name; cgen = Codegen(H_inds, config.h_tdterms, config.h_td_inds, args,; C_inds, C_tdterms, config.c_td_inds, type='mc',; config=config); cgen.generate(name + "".pyx""). elif config.tflag in [2, 20, 22]:; # PYTHON LIST-FUNCTION BASED TIME-DEPENDENCE; # ------------------------------------------. # take care of Hamiltonian; if config.tflag == 2:; # constant Hamiltonian, at least one function based collapse; # operators; H_inds = np.array([0]); H_tdterms = 0; len_h = 1; else:; # function based Hamiltonian; H_inds = np.arange(len(H)); H_td_inds = np.array(h_stuff[1]); H_const_inds = np.setdiff1d(H_inds, H_td_inds); config.h_funcs = np.array([H[k][1] for k in H_td_inds]); config.h_func_args = args; Htd = np.array([H[k][0] for k in H_td_inds], dtype=object); config.h_td_inds = np.arange(len(Htd)); H = np.sum(H[k] for k in H_const_inds). # take care of collapse operators; C_inds = np.arange(config.c_num); # find inds of time-dependent terms; C_td_inds = np.array(c_stuff[1]); # find inds of constant terms; C_const_inds = np.setdiff1d(C_inds, C_td_inds); # store indicies of constant collapse terms; config.c_const_",MatchSource.WIKI,docs/4.2/modules/qutip/mcsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html
https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:37030,Modifiability,config,config,37030,"str(kk) + ""]""; col_expect_code += "",config.c_args["" + str(kk) + ""]""; col_spmv_code += "")""; col_expect_code += ""))"". config.col_spmv_code = col_spmv_code; config.col_expect_code = col_expect_code. # setup ode args string; config.string = """"; data_range = range(len(config.h_data)); for k in data_range:; config.string += (""config.h_data["" + str(k) +; ""], config.h_ind["" + str(k) +; ""], config.h_ptr["" + str(k) + ""]""); if k != data_range[-1]:; config.string += "",""; ; # Add objects to ode args string; for k in range(len(config.h_tdterms)):; if isinstance(config.h_tdterms[k], Cubic_Spline):; config.string += "", config.h_tdterms[""+str(k)+""].coeffs""; ; # attach args to ode args string; if len(config.c_args) > 0:; for kk in range(len(config.c_args)):; config.string += "","" + ""config.c_args["" + str(kk) + ""]"". name = ""rhs"" + str(os.getpid()) + str(config.cgen_num); config.tdname = name; cgen = Codegen(H_inds, config.h_tdterms, config.h_td_inds, args,; C_inds, C_tdterms, config.c_td_inds, type='mc',; config=config); cgen.generate(name + "".pyx""). elif config.tflag in [2, 20, 22]:; # PYTHON LIST-FUNCTION BASED TIME-DEPENDENCE; # ------------------------------------------. # take care of Hamiltonian; if config.tflag == 2:; # constant Hamiltonian, at least one function based collapse; # operators; H_inds = np.array([0]); H_tdterms = 0; len_h = 1; else:; # function based Hamiltonian; H_inds = np.arange(len(H)); H_td_inds = np.array(h_stuff[1]); H_const_inds = np.setdiff1d(H_inds, H_td_inds); config.h_funcs = np.array([H[k][1] for k in H_td_inds]); config.h_func_args = args; Htd = np.array([H[k][0] for k in H_td_inds], dtype=object); config.h_td_inds = np.arange(len(Htd)); H = np.sum(H[k] for k in H_const_inds). # take care of collapse operators; C_inds = np.arange(config.c_num); # find inds of time-dependent terms; C_td_inds = np.array(c_stuff[1]); # find inds of constant terms; C_const_inds = np.setdiff1d(C_inds, C_td_inds); # store indicies of constant collapse terms; config.c_const_",MatchSource.WIKI,docs/4.2/modules/qutip/mcsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html
https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:37074,Modifiability,config,config,37074,"+ str(kk) + ""]""; col_spmv_code += "")""; col_expect_code += ""))"". config.col_spmv_code = col_spmv_code; config.col_expect_code = col_expect_code. # setup ode args string; config.string = """"; data_range = range(len(config.h_data)); for k in data_range:; config.string += (""config.h_data["" + str(k) +; ""], config.h_ind["" + str(k) +; ""], config.h_ptr["" + str(k) + ""]""); if k != data_range[-1]:; config.string += "",""; ; # Add objects to ode args string; for k in range(len(config.h_tdterms)):; if isinstance(config.h_tdterms[k], Cubic_Spline):; config.string += "", config.h_tdterms[""+str(k)+""].coeffs""; ; # attach args to ode args string; if len(config.c_args) > 0:; for kk in range(len(config.c_args)):; config.string += "","" + ""config.c_args["" + str(kk) + ""]"". name = ""rhs"" + str(os.getpid()) + str(config.cgen_num); config.tdname = name; cgen = Codegen(H_inds, config.h_tdterms, config.h_td_inds, args,; C_inds, C_tdterms, config.c_td_inds, type='mc',; config=config); cgen.generate(name + "".pyx""). elif config.tflag in [2, 20, 22]:; # PYTHON LIST-FUNCTION BASED TIME-DEPENDENCE; # ------------------------------------------. # take care of Hamiltonian; if config.tflag == 2:; # constant Hamiltonian, at least one function based collapse; # operators; H_inds = np.array([0]); H_tdterms = 0; len_h = 1; else:; # function based Hamiltonian; H_inds = np.arange(len(H)); H_td_inds = np.array(h_stuff[1]); H_const_inds = np.setdiff1d(H_inds, H_td_inds); config.h_funcs = np.array([H[k][1] for k in H_td_inds]); config.h_func_args = args; Htd = np.array([H[k][0] for k in H_td_inds], dtype=object); config.h_td_inds = np.arange(len(Htd)); H = np.sum(H[k] for k in H_const_inds). # take care of collapse operators; C_inds = np.arange(config.c_num); # find inds of time-dependent terms; C_td_inds = np.array(c_stuff[1]); # find inds of constant terms; C_const_inds = np.setdiff1d(C_inds, C_td_inds); # store indicies of constant collapse terms; config.c_const_inds = C_const_inds; # store indicies of time-depende",MatchSource.WIKI,docs/4.2/modules/qutip/mcsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html
https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:37227,Modifiability,config,config,37227,"de. # setup ode args string; config.string = """"; data_range = range(len(config.h_data)); for k in data_range:; config.string += (""config.h_data["" + str(k) +; ""], config.h_ind["" + str(k) +; ""], config.h_ptr["" + str(k) + ""]""); if k != data_range[-1]:; config.string += "",""; ; # Add objects to ode args string; for k in range(len(config.h_tdterms)):; if isinstance(config.h_tdterms[k], Cubic_Spline):; config.string += "", config.h_tdterms[""+str(k)+""].coeffs""; ; # attach args to ode args string; if len(config.c_args) > 0:; for kk in range(len(config.c_args)):; config.string += "","" + ""config.c_args["" + str(kk) + ""]"". name = ""rhs"" + str(os.getpid()) + str(config.cgen_num); config.tdname = name; cgen = Codegen(H_inds, config.h_tdterms, config.h_td_inds, args,; C_inds, C_tdterms, config.c_td_inds, type='mc',; config=config); cgen.generate(name + "".pyx""). elif config.tflag in [2, 20, 22]:; # PYTHON LIST-FUNCTION BASED TIME-DEPENDENCE; # ------------------------------------------. # take care of Hamiltonian; if config.tflag == 2:; # constant Hamiltonian, at least one function based collapse; # operators; H_inds = np.array([0]); H_tdterms = 0; len_h = 1; else:; # function based Hamiltonian; H_inds = np.arange(len(H)); H_td_inds = np.array(h_stuff[1]); H_const_inds = np.setdiff1d(H_inds, H_td_inds); config.h_funcs = np.array([H[k][1] for k in H_td_inds]); config.h_func_args = args; Htd = np.array([H[k][0] for k in H_td_inds], dtype=object); config.h_td_inds = np.arange(len(Htd)); H = np.sum(H[k] for k in H_const_inds). # take care of collapse operators; C_inds = np.arange(config.c_num); # find inds of time-dependent terms; C_td_inds = np.array(c_stuff[1]); # find inds of constant terms; C_const_inds = np.setdiff1d(C_inds, C_td_inds); # store indicies of constant collapse terms; config.c_const_inds = C_const_inds; # store indicies of time-dependent collapse terms; config.c_td_inds = C_td_inds; config.c_funcs = np.zeros(config.c_num, dtype=FunctionType); for k in config.c_td_inds:; co",MatchSource.WIKI,docs/4.2/modules/qutip/mcsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html
https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:37519,Modifiability,config,config,37519,"e args string; for k in range(len(config.h_tdterms)):; if isinstance(config.h_tdterms[k], Cubic_Spline):; config.string += "", config.h_tdterms[""+str(k)+""].coeffs""; ; # attach args to ode args string; if len(config.c_args) > 0:; for kk in range(len(config.c_args)):; config.string += "","" + ""config.c_args["" + str(kk) + ""]"". name = ""rhs"" + str(os.getpid()) + str(config.cgen_num); config.tdname = name; cgen = Codegen(H_inds, config.h_tdterms, config.h_td_inds, args,; C_inds, C_tdterms, config.c_td_inds, type='mc',; config=config); cgen.generate(name + "".pyx""). elif config.tflag in [2, 20, 22]:; # PYTHON LIST-FUNCTION BASED TIME-DEPENDENCE; # ------------------------------------------. # take care of Hamiltonian; if config.tflag == 2:; # constant Hamiltonian, at least one function based collapse; # operators; H_inds = np.array([0]); H_tdterms = 0; len_h = 1; else:; # function based Hamiltonian; H_inds = np.arange(len(H)); H_td_inds = np.array(h_stuff[1]); H_const_inds = np.setdiff1d(H_inds, H_td_inds); config.h_funcs = np.array([H[k][1] for k in H_td_inds]); config.h_func_args = args; Htd = np.array([H[k][0] for k in H_td_inds], dtype=object); config.h_td_inds = np.arange(len(Htd)); H = np.sum(H[k] for k in H_const_inds). # take care of collapse operators; C_inds = np.arange(config.c_num); # find inds of time-dependent terms; C_td_inds = np.array(c_stuff[1]); # find inds of constant terms; C_const_inds = np.setdiff1d(C_inds, C_td_inds); # store indicies of constant collapse terms; config.c_const_inds = C_const_inds; # store indicies of time-dependent collapse terms; config.c_td_inds = C_td_inds; config.c_funcs = np.zeros(config.c_num, dtype=FunctionType); for k in config.c_td_inds:; config.c_funcs[k] = c_ops[k][1]; config.c_func_args = args. # combine constant collapse terms with constant H and construct data; for k in config.c_const_inds:; H -= 0.5j * (c_ops[k].dag() * c_ops[k]); if options.tidy:; H = H.tidyup(options.atol); Htd = np.array([Htd[j].tidyup(options.atol); fo",MatchSource.WIKI,docs/4.2/modules/qutip/mcsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html
https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:37576,Modifiability,config,config,37576," if isinstance(config.h_tdterms[k], Cubic_Spline):; config.string += "", config.h_tdterms[""+str(k)+""].coeffs""; ; # attach args to ode args string; if len(config.c_args) > 0:; for kk in range(len(config.c_args)):; config.string += "","" + ""config.c_args["" + str(kk) + ""]"". name = ""rhs"" + str(os.getpid()) + str(config.cgen_num); config.tdname = name; cgen = Codegen(H_inds, config.h_tdterms, config.h_td_inds, args,; C_inds, C_tdterms, config.c_td_inds, type='mc',; config=config); cgen.generate(name + "".pyx""). elif config.tflag in [2, 20, 22]:; # PYTHON LIST-FUNCTION BASED TIME-DEPENDENCE; # ------------------------------------------. # take care of Hamiltonian; if config.tflag == 2:; # constant Hamiltonian, at least one function based collapse; # operators; H_inds = np.array([0]); H_tdterms = 0; len_h = 1; else:; # function based Hamiltonian; H_inds = np.arange(len(H)); H_td_inds = np.array(h_stuff[1]); H_const_inds = np.setdiff1d(H_inds, H_td_inds); config.h_funcs = np.array([H[k][1] for k in H_td_inds]); config.h_func_args = args; Htd = np.array([H[k][0] for k in H_td_inds], dtype=object); config.h_td_inds = np.arange(len(Htd)); H = np.sum(H[k] for k in H_const_inds). # take care of collapse operators; C_inds = np.arange(config.c_num); # find inds of time-dependent terms; C_td_inds = np.array(c_stuff[1]); # find inds of constant terms; C_const_inds = np.setdiff1d(C_inds, C_td_inds); # store indicies of constant collapse terms; config.c_const_inds = C_const_inds; # store indicies of time-dependent collapse terms; config.c_td_inds = C_td_inds; config.c_funcs = np.zeros(config.c_num, dtype=FunctionType); for k in config.c_td_inds:; config.c_funcs[k] = c_ops[k][1]; config.c_func_args = args. # combine constant collapse terms with constant H and construct data; for k in config.c_const_inds:; H -= 0.5j * (c_ops[k].dag() * c_ops[k]); if options.tidy:; H = H.tidyup(options.atol); Htd = np.array([Htd[j].tidyup(options.atol); for j in config.h_td_inds], dtype=object); # setup cons",MatchSource.WIKI,docs/4.2/modules/qutip/mcsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html
https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:37663,Modifiability,config,config,37663,"_tdterms[""+str(k)+""].coeffs""; ; # attach args to ode args string; if len(config.c_args) > 0:; for kk in range(len(config.c_args)):; config.string += "","" + ""config.c_args["" + str(kk) + ""]"". name = ""rhs"" + str(os.getpid()) + str(config.cgen_num); config.tdname = name; cgen = Codegen(H_inds, config.h_tdterms, config.h_td_inds, args,; C_inds, C_tdterms, config.c_td_inds, type='mc',; config=config); cgen.generate(name + "".pyx""). elif config.tflag in [2, 20, 22]:; # PYTHON LIST-FUNCTION BASED TIME-DEPENDENCE; # ------------------------------------------. # take care of Hamiltonian; if config.tflag == 2:; # constant Hamiltonian, at least one function based collapse; # operators; H_inds = np.array([0]); H_tdterms = 0; len_h = 1; else:; # function based Hamiltonian; H_inds = np.arange(len(H)); H_td_inds = np.array(h_stuff[1]); H_const_inds = np.setdiff1d(H_inds, H_td_inds); config.h_funcs = np.array([H[k][1] for k in H_td_inds]); config.h_func_args = args; Htd = np.array([H[k][0] for k in H_td_inds], dtype=object); config.h_td_inds = np.arange(len(Htd)); H = np.sum(H[k] for k in H_const_inds). # take care of collapse operators; C_inds = np.arange(config.c_num); # find inds of time-dependent terms; C_td_inds = np.array(c_stuff[1]); # find inds of constant terms; C_const_inds = np.setdiff1d(C_inds, C_td_inds); # store indicies of constant collapse terms; config.c_const_inds = C_const_inds; # store indicies of time-dependent collapse terms; config.c_td_inds = C_td_inds; config.c_funcs = np.zeros(config.c_num, dtype=FunctionType); for k in config.c_td_inds:; config.c_funcs[k] = c_ops[k][1]; config.c_func_args = args. # combine constant collapse terms with constant H and construct data; for k in config.c_const_inds:; H -= 0.5j * (c_ops[k].dag() * c_ops[k]); if options.tidy:; H = H.tidyup(options.atol); Htd = np.array([Htd[j].tidyup(options.atol); for j in config.h_td_inds], dtype=object); # setup constant H terms data; config.h_data = -1.0j * H.data.data; config.h_ind = H.data.in",MatchSource.WIKI,docs/4.2/modules/qutip/mcsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html
https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:37797,Modifiability,config,config,37797,"config.c_args["" + str(kk) + ""]"". name = ""rhs"" + str(os.getpid()) + str(config.cgen_num); config.tdname = name; cgen = Codegen(H_inds, config.h_tdterms, config.h_td_inds, args,; C_inds, C_tdterms, config.c_td_inds, type='mc',; config=config); cgen.generate(name + "".pyx""). elif config.tflag in [2, 20, 22]:; # PYTHON LIST-FUNCTION BASED TIME-DEPENDENCE; # ------------------------------------------. # take care of Hamiltonian; if config.tflag == 2:; # constant Hamiltonian, at least one function based collapse; # operators; H_inds = np.array([0]); H_tdterms = 0; len_h = 1; else:; # function based Hamiltonian; H_inds = np.arange(len(H)); H_td_inds = np.array(h_stuff[1]); H_const_inds = np.setdiff1d(H_inds, H_td_inds); config.h_funcs = np.array([H[k][1] for k in H_td_inds]); config.h_func_args = args; Htd = np.array([H[k][0] for k in H_td_inds], dtype=object); config.h_td_inds = np.arange(len(Htd)); H = np.sum(H[k] for k in H_const_inds). # take care of collapse operators; C_inds = np.arange(config.c_num); # find inds of time-dependent terms; C_td_inds = np.array(c_stuff[1]); # find inds of constant terms; C_const_inds = np.setdiff1d(C_inds, C_td_inds); # store indicies of constant collapse terms; config.c_const_inds = C_const_inds; # store indicies of time-dependent collapse terms; config.c_td_inds = C_td_inds; config.c_funcs = np.zeros(config.c_num, dtype=FunctionType); for k in config.c_td_inds:; config.c_funcs[k] = c_ops[k][1]; config.c_func_args = args. # combine constant collapse terms with constant H and construct data; for k in config.c_const_inds:; H -= 0.5j * (c_ops[k].dag() * c_ops[k]); if options.tidy:; H = H.tidyup(options.atol); Htd = np.array([Htd[j].tidyup(options.atol); for j in config.h_td_inds], dtype=object); # setup constant H terms data; config.h_data = -1.0j * H.data.data; config.h_ind = H.data.indices; config.h_ptr = H.data.indptr. # setup td H terms data; config.h_td_data = np.array(; [-1.0j * Htd[k].data.data for k in config.h_td_inds]); config.h_",MatchSource.WIKI,docs/4.2/modules/qutip/mcsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html
https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:38007,Modifiability,config,config,38007," C_inds, C_tdterms, config.c_td_inds, type='mc',; config=config); cgen.generate(name + "".pyx""). elif config.tflag in [2, 20, 22]:; # PYTHON LIST-FUNCTION BASED TIME-DEPENDENCE; # ------------------------------------------. # take care of Hamiltonian; if config.tflag == 2:; # constant Hamiltonian, at least one function based collapse; # operators; H_inds = np.array([0]); H_tdterms = 0; len_h = 1; else:; # function based Hamiltonian; H_inds = np.arange(len(H)); H_td_inds = np.array(h_stuff[1]); H_const_inds = np.setdiff1d(H_inds, H_td_inds); config.h_funcs = np.array([H[k][1] for k in H_td_inds]); config.h_func_args = args; Htd = np.array([H[k][0] for k in H_td_inds], dtype=object); config.h_td_inds = np.arange(len(Htd)); H = np.sum(H[k] for k in H_const_inds). # take care of collapse operators; C_inds = np.arange(config.c_num); # find inds of time-dependent terms; C_td_inds = np.array(c_stuff[1]); # find inds of constant terms; C_const_inds = np.setdiff1d(C_inds, C_td_inds); # store indicies of constant collapse terms; config.c_const_inds = C_const_inds; # store indicies of time-dependent collapse terms; config.c_td_inds = C_td_inds; config.c_funcs = np.zeros(config.c_num, dtype=FunctionType); for k in config.c_td_inds:; config.c_funcs[k] = c_ops[k][1]; config.c_func_args = args. # combine constant collapse terms with constant H and construct data; for k in config.c_const_inds:; H -= 0.5j * (c_ops[k].dag() * c_ops[k]); if options.tidy:; H = H.tidyup(options.atol); Htd = np.array([Htd[j].tidyup(options.atol); for j in config.h_td_inds], dtype=object); # setup constant H terms data; config.h_data = -1.0j * H.data.data; config.h_ind = H.data.indices; config.h_ptr = H.data.indptr. # setup td H terms data; config.h_td_data = np.array(; [-1.0j * Htd[k].data.data for k in config.h_td_inds]); config.h_td_ind = np.array(; [Htd[k].data.indices for k in config.h_td_inds]); config.h_td_ptr = np.array(; [Htd[k].data.indptr for k in config.h_td_inds]). elif config.tflag == 3:; # P",MatchSource.WIKI,docs/4.2/modules/qutip/mcsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html
https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:38094,Modifiability,config,config,38094," + "".pyx""). elif config.tflag in [2, 20, 22]:; # PYTHON LIST-FUNCTION BASED TIME-DEPENDENCE; # ------------------------------------------. # take care of Hamiltonian; if config.tflag == 2:; # constant Hamiltonian, at least one function based collapse; # operators; H_inds = np.array([0]); H_tdterms = 0; len_h = 1; else:; # function based Hamiltonian; H_inds = np.arange(len(H)); H_td_inds = np.array(h_stuff[1]); H_const_inds = np.setdiff1d(H_inds, H_td_inds); config.h_funcs = np.array([H[k][1] for k in H_td_inds]); config.h_func_args = args; Htd = np.array([H[k][0] for k in H_td_inds], dtype=object); config.h_td_inds = np.arange(len(Htd)); H = np.sum(H[k] for k in H_const_inds). # take care of collapse operators; C_inds = np.arange(config.c_num); # find inds of time-dependent terms; C_td_inds = np.array(c_stuff[1]); # find inds of constant terms; C_const_inds = np.setdiff1d(C_inds, C_td_inds); # store indicies of constant collapse terms; config.c_const_inds = C_const_inds; # store indicies of time-dependent collapse terms; config.c_td_inds = C_td_inds; config.c_funcs = np.zeros(config.c_num, dtype=FunctionType); for k in config.c_td_inds:; config.c_funcs[k] = c_ops[k][1]; config.c_func_args = args. # combine constant collapse terms with constant H and construct data; for k in config.c_const_inds:; H -= 0.5j * (c_ops[k].dag() * c_ops[k]); if options.tidy:; H = H.tidyup(options.atol); Htd = np.array([Htd[j].tidyup(options.atol); for j in config.h_td_inds], dtype=object); # setup constant H terms data; config.h_data = -1.0j * H.data.data; config.h_ind = H.data.indices; config.h_ptr = H.data.indptr. # setup td H terms data; config.h_td_data = np.array(; [-1.0j * Htd[k].data.data for k in config.h_td_inds]); config.h_td_ind = np.array(; [Htd[k].data.indices for k in config.h_td_inds]); config.h_td_ptr = np.array(; [Htd[k].data.indptr for k in config.h_td_inds]). elif config.tflag == 3:; # PYTHON FUNCTION BASED HAMILTONIAN; # ---------------------------------. # take care of",MatchSource.WIKI,docs/4.2/modules/qutip/mcsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html
https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:38124,Modifiability,config,config,38124,"T-FUNCTION BASED TIME-DEPENDENCE; # ------------------------------------------. # take care of Hamiltonian; if config.tflag == 2:; # constant Hamiltonian, at least one function based collapse; # operators; H_inds = np.array([0]); H_tdterms = 0; len_h = 1; else:; # function based Hamiltonian; H_inds = np.arange(len(H)); H_td_inds = np.array(h_stuff[1]); H_const_inds = np.setdiff1d(H_inds, H_td_inds); config.h_funcs = np.array([H[k][1] for k in H_td_inds]); config.h_func_args = args; Htd = np.array([H[k][0] for k in H_td_inds], dtype=object); config.h_td_inds = np.arange(len(Htd)); H = np.sum(H[k] for k in H_const_inds). # take care of collapse operators; C_inds = np.arange(config.c_num); # find inds of time-dependent terms; C_td_inds = np.array(c_stuff[1]); # find inds of constant terms; C_const_inds = np.setdiff1d(C_inds, C_td_inds); # store indicies of constant collapse terms; config.c_const_inds = C_const_inds; # store indicies of time-dependent collapse terms; config.c_td_inds = C_td_inds; config.c_funcs = np.zeros(config.c_num, dtype=FunctionType); for k in config.c_td_inds:; config.c_funcs[k] = c_ops[k][1]; config.c_func_args = args. # combine constant collapse terms with constant H and construct data; for k in config.c_const_inds:; H -= 0.5j * (c_ops[k].dag() * c_ops[k]); if options.tidy:; H = H.tidyup(options.atol); Htd = np.array([Htd[j].tidyup(options.atol); for j in config.h_td_inds], dtype=object); # setup constant H terms data; config.h_data = -1.0j * H.data.data; config.h_ind = H.data.indices; config.h_ptr = H.data.indptr. # setup td H terms data; config.h_td_data = np.array(; [-1.0j * Htd[k].data.data for k in config.h_td_inds]); config.h_td_ind = np.array(; [Htd[k].data.indices for k in config.h_td_inds]); config.h_td_ptr = np.array(; [Htd[k].data.indptr for k in config.h_td_inds]). elif config.tflag == 3:; # PYTHON FUNCTION BASED HAMILTONIAN; # ---------------------------------. # take care of Hamiltonian; config.h_funcs = H; config.h_func_args = arg",MatchSource.WIKI,docs/4.2/modules/qutip/mcsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html
https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:38150,Modifiability,config,config,38150,"# ------------------------------------------. # take care of Hamiltonian; if config.tflag == 2:; # constant Hamiltonian, at least one function based collapse; # operators; H_inds = np.array([0]); H_tdterms = 0; len_h = 1; else:; # function based Hamiltonian; H_inds = np.arange(len(H)); H_td_inds = np.array(h_stuff[1]); H_const_inds = np.setdiff1d(H_inds, H_td_inds); config.h_funcs = np.array([H[k][1] for k in H_td_inds]); config.h_func_args = args; Htd = np.array([H[k][0] for k in H_td_inds], dtype=object); config.h_td_inds = np.arange(len(Htd)); H = np.sum(H[k] for k in H_const_inds). # take care of collapse operators; C_inds = np.arange(config.c_num); # find inds of time-dependent terms; C_td_inds = np.array(c_stuff[1]); # find inds of constant terms; C_const_inds = np.setdiff1d(C_inds, C_td_inds); # store indicies of constant collapse terms; config.c_const_inds = C_const_inds; # store indicies of time-dependent collapse terms; config.c_td_inds = C_td_inds; config.c_funcs = np.zeros(config.c_num, dtype=FunctionType); for k in config.c_td_inds:; config.c_funcs[k] = c_ops[k][1]; config.c_func_args = args. # combine constant collapse terms with constant H and construct data; for k in config.c_const_inds:; H -= 0.5j * (c_ops[k].dag() * c_ops[k]); if options.tidy:; H = H.tidyup(options.atol); Htd = np.array([Htd[j].tidyup(options.atol); for j in config.h_td_inds], dtype=object); # setup constant H terms data; config.h_data = -1.0j * H.data.data; config.h_ind = H.data.indices; config.h_ptr = H.data.indptr. # setup td H terms data; config.h_td_data = np.array(; [-1.0j * Htd[k].data.data for k in config.h_td_inds]); config.h_td_ind = np.array(; [Htd[k].data.indices for k in config.h_td_inds]); config.h_td_ptr = np.array(; [Htd[k].data.indptr for k in config.h_td_inds]). elif config.tflag == 3:; # PYTHON FUNCTION BASED HAMILTONIAN; # ---------------------------------. # take care of Hamiltonian; config.h_funcs = H; config.h_func_args = args. # take care of collapse operator",MatchSource.WIKI,docs/4.2/modules/qutip/mcsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html
https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:38194,Modifiability,config,config,38194,"---------------. # take care of Hamiltonian; if config.tflag == 2:; # constant Hamiltonian, at least one function based collapse; # operators; H_inds = np.array([0]); H_tdterms = 0; len_h = 1; else:; # function based Hamiltonian; H_inds = np.arange(len(H)); H_td_inds = np.array(h_stuff[1]); H_const_inds = np.setdiff1d(H_inds, H_td_inds); config.h_funcs = np.array([H[k][1] for k in H_td_inds]); config.h_func_args = args; Htd = np.array([H[k][0] for k in H_td_inds], dtype=object); config.h_td_inds = np.arange(len(Htd)); H = np.sum(H[k] for k in H_const_inds). # take care of collapse operators; C_inds = np.arange(config.c_num); # find inds of time-dependent terms; C_td_inds = np.array(c_stuff[1]); # find inds of constant terms; C_const_inds = np.setdiff1d(C_inds, C_td_inds); # store indicies of constant collapse terms; config.c_const_inds = C_const_inds; # store indicies of time-dependent collapse terms; config.c_td_inds = C_td_inds; config.c_funcs = np.zeros(config.c_num, dtype=FunctionType); for k in config.c_td_inds:; config.c_funcs[k] = c_ops[k][1]; config.c_func_args = args. # combine constant collapse terms with constant H and construct data; for k in config.c_const_inds:; H -= 0.5j * (c_ops[k].dag() * c_ops[k]); if options.tidy:; H = H.tidyup(options.atol); Htd = np.array([Htd[j].tidyup(options.atol); for j in config.h_td_inds], dtype=object); # setup constant H terms data; config.h_data = -1.0j * H.data.data; config.h_ind = H.data.indices; config.h_ptr = H.data.indptr. # setup td H terms data; config.h_td_data = np.array(; [-1.0j * Htd[k].data.data for k in config.h_td_inds]); config.h_td_ind = np.array(; [Htd[k].data.indices for k in config.h_td_inds]); config.h_td_ptr = np.array(; [Htd[k].data.indptr for k in config.h_td_inds]). elif config.tflag == 3:; # PYTHON FUNCTION BASED HAMILTONIAN; # ---------------------------------. # take care of Hamiltonian; config.h_funcs = H; config.h_func_args = args. # take care of collapse operators; config.c_const_inds = np.",MatchSource.WIKI,docs/4.2/modules/qutip/mcsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html
https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:38213,Modifiability,config,config,38213," Hamiltonian; if config.tflag == 2:; # constant Hamiltonian, at least one function based collapse; # operators; H_inds = np.array([0]); H_tdterms = 0; len_h = 1; else:; # function based Hamiltonian; H_inds = np.arange(len(H)); H_td_inds = np.array(h_stuff[1]); H_const_inds = np.setdiff1d(H_inds, H_td_inds); config.h_funcs = np.array([H[k][1] for k in H_td_inds]); config.h_func_args = args; Htd = np.array([H[k][0] for k in H_td_inds], dtype=object); config.h_td_inds = np.arange(len(Htd)); H = np.sum(H[k] for k in H_const_inds). # take care of collapse operators; C_inds = np.arange(config.c_num); # find inds of time-dependent terms; C_td_inds = np.array(c_stuff[1]); # find inds of constant terms; C_const_inds = np.setdiff1d(C_inds, C_td_inds); # store indicies of constant collapse terms; config.c_const_inds = C_const_inds; # store indicies of time-dependent collapse terms; config.c_td_inds = C_td_inds; config.c_funcs = np.zeros(config.c_num, dtype=FunctionType); for k in config.c_td_inds:; config.c_funcs[k] = c_ops[k][1]; config.c_func_args = args. # combine constant collapse terms with constant H and construct data; for k in config.c_const_inds:; H -= 0.5j * (c_ops[k].dag() * c_ops[k]); if options.tidy:; H = H.tidyup(options.atol); Htd = np.array([Htd[j].tidyup(options.atol); for j in config.h_td_inds], dtype=object); # setup constant H terms data; config.h_data = -1.0j * H.data.data; config.h_ind = H.data.indices; config.h_ptr = H.data.indptr. # setup td H terms data; config.h_td_data = np.array(; [-1.0j * Htd[k].data.data for k in config.h_td_inds]); config.h_td_ind = np.array(; [Htd[k].data.indices for k in config.h_td_inds]); config.h_td_ptr = np.array(; [Htd[k].data.indptr for k in config.h_td_inds]). elif config.tflag == 3:; # PYTHON FUNCTION BASED HAMILTONIAN; # ---------------------------------. # take care of Hamiltonian; config.h_funcs = H; config.h_func_args = args. # take care of collapse operators; config.c_const_inds = np.arange(config.c_num); config.c_t",MatchSource.WIKI,docs/4.2/modules/qutip/mcsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html
https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:38246,Modifiability,config,config,38246,"lag == 2:; # constant Hamiltonian, at least one function based collapse; # operators; H_inds = np.array([0]); H_tdterms = 0; len_h = 1; else:; # function based Hamiltonian; H_inds = np.arange(len(H)); H_td_inds = np.array(h_stuff[1]); H_const_inds = np.setdiff1d(H_inds, H_td_inds); config.h_funcs = np.array([H[k][1] for k in H_td_inds]); config.h_func_args = args; Htd = np.array([H[k][0] for k in H_td_inds], dtype=object); config.h_td_inds = np.arange(len(Htd)); H = np.sum(H[k] for k in H_const_inds). # take care of collapse operators; C_inds = np.arange(config.c_num); # find inds of time-dependent terms; C_td_inds = np.array(c_stuff[1]); # find inds of constant terms; C_const_inds = np.setdiff1d(C_inds, C_td_inds); # store indicies of constant collapse terms; config.c_const_inds = C_const_inds; # store indicies of time-dependent collapse terms; config.c_td_inds = C_td_inds; config.c_funcs = np.zeros(config.c_num, dtype=FunctionType); for k in config.c_td_inds:; config.c_funcs[k] = c_ops[k][1]; config.c_func_args = args. # combine constant collapse terms with constant H and construct data; for k in config.c_const_inds:; H -= 0.5j * (c_ops[k].dag() * c_ops[k]); if options.tidy:; H = H.tidyup(options.atol); Htd = np.array([Htd[j].tidyup(options.atol); for j in config.h_td_inds], dtype=object); # setup constant H terms data; config.h_data = -1.0j * H.data.data; config.h_ind = H.data.indices; config.h_ptr = H.data.indptr. # setup td H terms data; config.h_td_data = np.array(; [-1.0j * Htd[k].data.data for k in config.h_td_inds]); config.h_td_ind = np.array(; [Htd[k].data.indices for k in config.h_td_inds]); config.h_td_ptr = np.array(; [Htd[k].data.indptr for k in config.h_td_inds]). elif config.tflag == 3:; # PYTHON FUNCTION BASED HAMILTONIAN; # ---------------------------------. # take care of Hamiltonian; config.h_funcs = H; config.h_func_args = args. # take care of collapse operators; config.c_const_inds = np.arange(config.c_num); config.c_td_inds = np.array([]); if ",MatchSource.WIKI,docs/4.2/modules/qutip/mcsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html
https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:38352,Modifiability,config,config,38352,"ators; H_inds = np.array([0]); H_tdterms = 0; len_h = 1; else:; # function based Hamiltonian; H_inds = np.arange(len(H)); H_td_inds = np.array(h_stuff[1]); H_const_inds = np.setdiff1d(H_inds, H_td_inds); config.h_funcs = np.array([H[k][1] for k in H_td_inds]); config.h_func_args = args; Htd = np.array([H[k][0] for k in H_td_inds], dtype=object); config.h_td_inds = np.arange(len(Htd)); H = np.sum(H[k] for k in H_const_inds). # take care of collapse operators; C_inds = np.arange(config.c_num); # find inds of time-dependent terms; C_td_inds = np.array(c_stuff[1]); # find inds of constant terms; C_const_inds = np.setdiff1d(C_inds, C_td_inds); # store indicies of constant collapse terms; config.c_const_inds = C_const_inds; # store indicies of time-dependent collapse terms; config.c_td_inds = C_td_inds; config.c_funcs = np.zeros(config.c_num, dtype=FunctionType); for k in config.c_td_inds:; config.c_funcs[k] = c_ops[k][1]; config.c_func_args = args. # combine constant collapse terms with constant H and construct data; for k in config.c_const_inds:; H -= 0.5j * (c_ops[k].dag() * c_ops[k]); if options.tidy:; H = H.tidyup(options.atol); Htd = np.array([Htd[j].tidyup(options.atol); for j in config.h_td_inds], dtype=object); # setup constant H terms data; config.h_data = -1.0j * H.data.data; config.h_ind = H.data.indices; config.h_ptr = H.data.indptr. # setup td H terms data; config.h_td_data = np.array(; [-1.0j * Htd[k].data.data for k in config.h_td_inds]); config.h_td_ind = np.array(; [Htd[k].data.indices for k in config.h_td_inds]); config.h_td_ptr = np.array(; [Htd[k].data.indptr for k in config.h_td_inds]). elif config.tflag == 3:; # PYTHON FUNCTION BASED HAMILTONIAN; # ---------------------------------. # take care of Hamiltonian; config.h_funcs = H; config.h_func_args = args. # take care of collapse operators; config.c_const_inds = np.arange(config.c_num); config.c_td_inds = np.array([]); if len(config.c_const_inds) > 0:; H = 0; for k in config.c_const_inds:; H -= 0.5j ",MatchSource.WIKI,docs/4.2/modules/qutip/mcsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html
https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:38515,Modifiability,config,config,38515,"d_inds); config.h_funcs = np.array([H[k][1] for k in H_td_inds]); config.h_func_args = args; Htd = np.array([H[k][0] for k in H_td_inds], dtype=object); config.h_td_inds = np.arange(len(Htd)); H = np.sum(H[k] for k in H_const_inds). # take care of collapse operators; C_inds = np.arange(config.c_num); # find inds of time-dependent terms; C_td_inds = np.array(c_stuff[1]); # find inds of constant terms; C_const_inds = np.setdiff1d(C_inds, C_td_inds); # store indicies of constant collapse terms; config.c_const_inds = C_const_inds; # store indicies of time-dependent collapse terms; config.c_td_inds = C_td_inds; config.c_funcs = np.zeros(config.c_num, dtype=FunctionType); for k in config.c_td_inds:; config.c_funcs[k] = c_ops[k][1]; config.c_func_args = args. # combine constant collapse terms with constant H and construct data; for k in config.c_const_inds:; H -= 0.5j * (c_ops[k].dag() * c_ops[k]); if options.tidy:; H = H.tidyup(options.atol); Htd = np.array([Htd[j].tidyup(options.atol); for j in config.h_td_inds], dtype=object); # setup constant H terms data; config.h_data = -1.0j * H.data.data; config.h_ind = H.data.indices; config.h_ptr = H.data.indptr. # setup td H terms data; config.h_td_data = np.array(; [-1.0j * Htd[k].data.data for k in config.h_td_inds]); config.h_td_ind = np.array(; [Htd[k].data.indices for k in config.h_td_inds]); config.h_td_ptr = np.array(; [Htd[k].data.indptr for k in config.h_td_inds]). elif config.tflag == 3:; # PYTHON FUNCTION BASED HAMILTONIAN; # ---------------------------------. # take care of Hamiltonian; config.h_funcs = H; config.h_func_args = args. # take care of collapse operators; config.c_const_inds = np.arange(config.c_num); config.c_td_inds = np.array([]); if len(config.c_const_inds) > 0:; H = 0; for k in config.c_const_inds:; H -= 0.5j * (c_ops[k].dag() * c_ops[k]); if options.tidy:; H = H.tidyup(options.atol); config.h_data = -1.0j * H.data.data; config.h_ind = H.data.indices; config.h_ptr = H.data.indptr. def _mc_dm_avg(psi_l",MatchSource.WIKI,docs/4.2/modules/qutip/mcsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html
https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:38580,Modifiability,config,config,38580,"for k in H_td_inds]); config.h_func_args = args; Htd = np.array([H[k][0] for k in H_td_inds], dtype=object); config.h_td_inds = np.arange(len(Htd)); H = np.sum(H[k] for k in H_const_inds). # take care of collapse operators; C_inds = np.arange(config.c_num); # find inds of time-dependent terms; C_td_inds = np.array(c_stuff[1]); # find inds of constant terms; C_const_inds = np.setdiff1d(C_inds, C_td_inds); # store indicies of constant collapse terms; config.c_const_inds = C_const_inds; # store indicies of time-dependent collapse terms; config.c_td_inds = C_td_inds; config.c_funcs = np.zeros(config.c_num, dtype=FunctionType); for k in config.c_td_inds:; config.c_funcs[k] = c_ops[k][1]; config.c_func_args = args. # combine constant collapse terms with constant H and construct data; for k in config.c_const_inds:; H -= 0.5j * (c_ops[k].dag() * c_ops[k]); if options.tidy:; H = H.tidyup(options.atol); Htd = np.array([Htd[j].tidyup(options.atol); for j in config.h_td_inds], dtype=object); # setup constant H terms data; config.h_data = -1.0j * H.data.data; config.h_ind = H.data.indices; config.h_ptr = H.data.indptr. # setup td H terms data; config.h_td_data = np.array(; [-1.0j * Htd[k].data.data for k in config.h_td_inds]); config.h_td_ind = np.array(; [Htd[k].data.indices for k in config.h_td_inds]); config.h_td_ptr = np.array(; [Htd[k].data.indptr for k in config.h_td_inds]). elif config.tflag == 3:; # PYTHON FUNCTION BASED HAMILTONIAN; # ---------------------------------. # take care of Hamiltonian; config.h_funcs = H; config.h_func_args = args. # take care of collapse operators; config.c_const_inds = np.arange(config.c_num); config.c_td_inds = np.array([]); if len(config.c_const_inds) > 0:; H = 0; for k in config.c_const_inds:; H -= 0.5j * (c_ops[k].dag() * c_ops[k]); if options.tidy:; H = H.tidyup(options.atol); config.h_data = -1.0j * H.data.data; config.h_ind = H.data.indices; config.h_ptr = H.data.indptr. def _mc_dm_avg(psi_list):; """"""; Private function that averages d",MatchSource.WIKI,docs/4.2/modules/qutip/mcsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html
https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:38617,Modifiability,config,config,38617,"([H[k][0] for k in H_td_inds], dtype=object); config.h_td_inds = np.arange(len(Htd)); H = np.sum(H[k] for k in H_const_inds). # take care of collapse operators; C_inds = np.arange(config.c_num); # find inds of time-dependent terms; C_td_inds = np.array(c_stuff[1]); # find inds of constant terms; C_const_inds = np.setdiff1d(C_inds, C_td_inds); # store indicies of constant collapse terms; config.c_const_inds = C_const_inds; # store indicies of time-dependent collapse terms; config.c_td_inds = C_td_inds; config.c_funcs = np.zeros(config.c_num, dtype=FunctionType); for k in config.c_td_inds:; config.c_funcs[k] = c_ops[k][1]; config.c_func_args = args. # combine constant collapse terms with constant H and construct data; for k in config.c_const_inds:; H -= 0.5j * (c_ops[k].dag() * c_ops[k]); if options.tidy:; H = H.tidyup(options.atol); Htd = np.array([Htd[j].tidyup(options.atol); for j in config.h_td_inds], dtype=object); # setup constant H terms data; config.h_data = -1.0j * H.data.data; config.h_ind = H.data.indices; config.h_ptr = H.data.indptr. # setup td H terms data; config.h_td_data = np.array(; [-1.0j * Htd[k].data.data for k in config.h_td_inds]); config.h_td_ind = np.array(; [Htd[k].data.indices for k in config.h_td_inds]); config.h_td_ptr = np.array(; [Htd[k].data.indptr for k in config.h_td_inds]). elif config.tflag == 3:; # PYTHON FUNCTION BASED HAMILTONIAN; # ---------------------------------. # take care of Hamiltonian; config.h_funcs = H; config.h_func_args = args. # take care of collapse operators; config.c_const_inds = np.arange(config.c_num); config.c_td_inds = np.array([]); if len(config.c_const_inds) > 0:; H = 0; for k in config.c_const_inds:; H -= 0.5j * (c_ops[k].dag() * c_ops[k]); if options.tidy:; H = H.tidyup(options.atol); config.h_data = -1.0j * H.data.data; config.h_ind = H.data.indices; config.h_ptr = H.data.indptr. def _mc_dm_avg(psi_list):; """"""; Private function that averages density matrices in parallel; over all trajectories for a single",MatchSource.WIKI,docs/4.2/modules/qutip/mcsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html
https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:38648,Modifiability,config,config,38648," dtype=object); config.h_td_inds = np.arange(len(Htd)); H = np.sum(H[k] for k in H_const_inds). # take care of collapse operators; C_inds = np.arange(config.c_num); # find inds of time-dependent terms; C_td_inds = np.array(c_stuff[1]); # find inds of constant terms; C_const_inds = np.setdiff1d(C_inds, C_td_inds); # store indicies of constant collapse terms; config.c_const_inds = C_const_inds; # store indicies of time-dependent collapse terms; config.c_td_inds = C_td_inds; config.c_funcs = np.zeros(config.c_num, dtype=FunctionType); for k in config.c_td_inds:; config.c_funcs[k] = c_ops[k][1]; config.c_func_args = args. # combine constant collapse terms with constant H and construct data; for k in config.c_const_inds:; H -= 0.5j * (c_ops[k].dag() * c_ops[k]); if options.tidy:; H = H.tidyup(options.atol); Htd = np.array([Htd[j].tidyup(options.atol); for j in config.h_td_inds], dtype=object); # setup constant H terms data; config.h_data = -1.0j * H.data.data; config.h_ind = H.data.indices; config.h_ptr = H.data.indptr. # setup td H terms data; config.h_td_data = np.array(; [-1.0j * Htd[k].data.data for k in config.h_td_inds]); config.h_td_ind = np.array(; [Htd[k].data.indices for k in config.h_td_inds]); config.h_td_ptr = np.array(; [Htd[k].data.indptr for k in config.h_td_inds]). elif config.tflag == 3:; # PYTHON FUNCTION BASED HAMILTONIAN; # ---------------------------------. # take care of Hamiltonian; config.h_funcs = H; config.h_func_args = args. # take care of collapse operators; config.c_const_inds = np.arange(config.c_num); config.c_td_inds = np.array([]); if len(config.c_const_inds) > 0:; H = 0; for k in config.c_const_inds:; H -= 0.5j * (c_ops[k].dag() * c_ops[k]); if options.tidy:; H = H.tidyup(options.atol); config.h_data = -1.0j * H.data.data; config.h_ind = H.data.indices; config.h_ptr = H.data.indptr. def _mc_dm_avg(psi_list):; """"""; Private function that averages density matrices in parallel; over all trajectories for a single time using parfor.; """"""; ln ",MatchSource.WIKI,docs/4.2/modules/qutip/mcsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html
https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:38703,Modifiability,config,config,38703,"en(Htd)); H = np.sum(H[k] for k in H_const_inds). # take care of collapse operators; C_inds = np.arange(config.c_num); # find inds of time-dependent terms; C_td_inds = np.array(c_stuff[1]); # find inds of constant terms; C_const_inds = np.setdiff1d(C_inds, C_td_inds); # store indicies of constant collapse terms; config.c_const_inds = C_const_inds; # store indicies of time-dependent collapse terms; config.c_td_inds = C_td_inds; config.c_funcs = np.zeros(config.c_num, dtype=FunctionType); for k in config.c_td_inds:; config.c_funcs[k] = c_ops[k][1]; config.c_func_args = args. # combine constant collapse terms with constant H and construct data; for k in config.c_const_inds:; H -= 0.5j * (c_ops[k].dag() * c_ops[k]); if options.tidy:; H = H.tidyup(options.atol); Htd = np.array([Htd[j].tidyup(options.atol); for j in config.h_td_inds], dtype=object); # setup constant H terms data; config.h_data = -1.0j * H.data.data; config.h_ind = H.data.indices; config.h_ptr = H.data.indptr. # setup td H terms data; config.h_td_data = np.array(; [-1.0j * Htd[k].data.data for k in config.h_td_inds]); config.h_td_ind = np.array(; [Htd[k].data.indices for k in config.h_td_inds]); config.h_td_ptr = np.array(; [Htd[k].data.indptr for k in config.h_td_inds]). elif config.tflag == 3:; # PYTHON FUNCTION BASED HAMILTONIAN; # ---------------------------------. # take care of Hamiltonian; config.h_funcs = H; config.h_func_args = args. # take care of collapse operators; config.c_const_inds = np.arange(config.c_num); config.c_td_inds = np.array([]); if len(config.c_const_inds) > 0:; H = 0; for k in config.c_const_inds:; H -= 0.5j * (c_ops[k].dag() * c_ops[k]); if options.tidy:; H = H.tidyup(options.atol); config.h_data = -1.0j * H.data.data; config.h_ind = H.data.indices; config.h_ptr = H.data.indptr. def _mc_dm_avg(psi_list):; """"""; Private function that averages density matrices in parallel; over all trajectories for a single time using parfor.; """"""; ln = len(psi_list); dims = psi_list[0].dims; shape",MatchSource.WIKI,docs/4.2/modules/qutip/mcsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html
https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:38768,Modifiability,config,config,38768,"se operators; C_inds = np.arange(config.c_num); # find inds of time-dependent terms; C_td_inds = np.array(c_stuff[1]); # find inds of constant terms; C_const_inds = np.setdiff1d(C_inds, C_td_inds); # store indicies of constant collapse terms; config.c_const_inds = C_const_inds; # store indicies of time-dependent collapse terms; config.c_td_inds = C_td_inds; config.c_funcs = np.zeros(config.c_num, dtype=FunctionType); for k in config.c_td_inds:; config.c_funcs[k] = c_ops[k][1]; config.c_func_args = args. # combine constant collapse terms with constant H and construct data; for k in config.c_const_inds:; H -= 0.5j * (c_ops[k].dag() * c_ops[k]); if options.tidy:; H = H.tidyup(options.atol); Htd = np.array([Htd[j].tidyup(options.atol); for j in config.h_td_inds], dtype=object); # setup constant H terms data; config.h_data = -1.0j * H.data.data; config.h_ind = H.data.indices; config.h_ptr = H.data.indptr. # setup td H terms data; config.h_td_data = np.array(; [-1.0j * Htd[k].data.data for k in config.h_td_inds]); config.h_td_ind = np.array(; [Htd[k].data.indices for k in config.h_td_inds]); config.h_td_ptr = np.array(; [Htd[k].data.indptr for k in config.h_td_inds]). elif config.tflag == 3:; # PYTHON FUNCTION BASED HAMILTONIAN; # ---------------------------------. # take care of Hamiltonian; config.h_funcs = H; config.h_func_args = args. # take care of collapse operators; config.c_const_inds = np.arange(config.c_num); config.c_td_inds = np.array([]); if len(config.c_const_inds) > 0:; H = 0; for k in config.c_const_inds:; H -= 0.5j * (c_ops[k].dag() * c_ops[k]); if options.tidy:; H = H.tidyup(options.atol); config.h_data = -1.0j * H.data.data; config.h_ind = H.data.indices; config.h_ptr = H.data.indptr. def _mc_dm_avg(psi_list):; """"""; Private function that averages density matrices in parallel; over all trajectories for a single time using parfor.; """"""; ln = len(psi_list); dims = psi_list[0].dims; shape = psi_list[0].shape; out_data = np.sum([psi.data for psi in psi_list])",MatchSource.WIKI,docs/4.2/modules/qutip/mcsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html
https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:38788,Modifiability,config,config,38788,"= np.arange(config.c_num); # find inds of time-dependent terms; C_td_inds = np.array(c_stuff[1]); # find inds of constant terms; C_const_inds = np.setdiff1d(C_inds, C_td_inds); # store indicies of constant collapse terms; config.c_const_inds = C_const_inds; # store indicies of time-dependent collapse terms; config.c_td_inds = C_td_inds; config.c_funcs = np.zeros(config.c_num, dtype=FunctionType); for k in config.c_td_inds:; config.c_funcs[k] = c_ops[k][1]; config.c_func_args = args. # combine constant collapse terms with constant H and construct data; for k in config.c_const_inds:; H -= 0.5j * (c_ops[k].dag() * c_ops[k]); if options.tidy:; H = H.tidyup(options.atol); Htd = np.array([Htd[j].tidyup(options.atol); for j in config.h_td_inds], dtype=object); # setup constant H terms data; config.h_data = -1.0j * H.data.data; config.h_ind = H.data.indices; config.h_ptr = H.data.indptr. # setup td H terms data; config.h_td_data = np.array(; [-1.0j * Htd[k].data.data for k in config.h_td_inds]); config.h_td_ind = np.array(; [Htd[k].data.indices for k in config.h_td_inds]); config.h_td_ptr = np.array(; [Htd[k].data.indptr for k in config.h_td_inds]). elif config.tflag == 3:; # PYTHON FUNCTION BASED HAMILTONIAN; # ---------------------------------. # take care of Hamiltonian; config.h_funcs = H; config.h_func_args = args. # take care of collapse operators; config.c_const_inds = np.arange(config.c_num); config.c_td_inds = np.array([]); if len(config.c_const_inds) > 0:; H = 0; for k in config.c_const_inds:; H -= 0.5j * (c_ops[k].dag() * c_ops[k]); if options.tidy:; H = H.tidyup(options.atol); config.h_data = -1.0j * H.data.data; config.h_ind = H.data.indices; config.h_ptr = H.data.indptr. def _mc_dm_avg(psi_list):; """"""; Private function that averages density matrices in parallel; over all trajectories for a single time using parfor.; """"""; ln = len(psi_list); dims = psi_list[0].dims; shape = psi_list[0].shape; out_data = np.sum([psi.data for psi in psi_list]) / ln; return Qobj(o",MatchSource.WIKI,docs/4.2/modules/qutip/mcsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html
https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:38847,Modifiability,config,config,38847,"terms; C_td_inds = np.array(c_stuff[1]); # find inds of constant terms; C_const_inds = np.setdiff1d(C_inds, C_td_inds); # store indicies of constant collapse terms; config.c_const_inds = C_const_inds; # store indicies of time-dependent collapse terms; config.c_td_inds = C_td_inds; config.c_funcs = np.zeros(config.c_num, dtype=FunctionType); for k in config.c_td_inds:; config.c_funcs[k] = c_ops[k][1]; config.c_func_args = args. # combine constant collapse terms with constant H and construct data; for k in config.c_const_inds:; H -= 0.5j * (c_ops[k].dag() * c_ops[k]); if options.tidy:; H = H.tidyup(options.atol); Htd = np.array([Htd[j].tidyup(options.atol); for j in config.h_td_inds], dtype=object); # setup constant H terms data; config.h_data = -1.0j * H.data.data; config.h_ind = H.data.indices; config.h_ptr = H.data.indptr. # setup td H terms data; config.h_td_data = np.array(; [-1.0j * Htd[k].data.data for k in config.h_td_inds]); config.h_td_ind = np.array(; [Htd[k].data.indices for k in config.h_td_inds]); config.h_td_ptr = np.array(; [Htd[k].data.indptr for k in config.h_td_inds]). elif config.tflag == 3:; # PYTHON FUNCTION BASED HAMILTONIAN; # ---------------------------------. # take care of Hamiltonian; config.h_funcs = H; config.h_func_args = args. # take care of collapse operators; config.c_const_inds = np.arange(config.c_num); config.c_td_inds = np.array([]); if len(config.c_const_inds) > 0:; H = 0; for k in config.c_const_inds:; H -= 0.5j * (c_ops[k].dag() * c_ops[k]); if options.tidy:; H = H.tidyup(options.atol); config.h_data = -1.0j * H.data.data; config.h_ind = H.data.indices; config.h_ptr = H.data.indptr. def _mc_dm_avg(psi_list):; """"""; Private function that averages density matrices in parallel; over all trajectories for a single time using parfor.; """"""; ln = len(psi_list); dims = psi_list[0].dims; shape = psi_list[0].shape; out_data = np.sum([psi.data for psi in psi_list]) / ln; return Qobj(out_data, dims=dims, shape=shape, fast='mc-dm').  Copyrig",MatchSource.WIKI,docs/4.2/modules/qutip/mcsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html
https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:38867,Modifiability,config,config,38867,"array(c_stuff[1]); # find inds of constant terms; C_const_inds = np.setdiff1d(C_inds, C_td_inds); # store indicies of constant collapse terms; config.c_const_inds = C_const_inds; # store indicies of time-dependent collapse terms; config.c_td_inds = C_td_inds; config.c_funcs = np.zeros(config.c_num, dtype=FunctionType); for k in config.c_td_inds:; config.c_funcs[k] = c_ops[k][1]; config.c_func_args = args. # combine constant collapse terms with constant H and construct data; for k in config.c_const_inds:; H -= 0.5j * (c_ops[k].dag() * c_ops[k]); if options.tidy:; H = H.tidyup(options.atol); Htd = np.array([Htd[j].tidyup(options.atol); for j in config.h_td_inds], dtype=object); # setup constant H terms data; config.h_data = -1.0j * H.data.data; config.h_ind = H.data.indices; config.h_ptr = H.data.indptr. # setup td H terms data; config.h_td_data = np.array(; [-1.0j * Htd[k].data.data for k in config.h_td_inds]); config.h_td_ind = np.array(; [Htd[k].data.indices for k in config.h_td_inds]); config.h_td_ptr = np.array(; [Htd[k].data.indptr for k in config.h_td_inds]). elif config.tflag == 3:; # PYTHON FUNCTION BASED HAMILTONIAN; # ---------------------------------. # take care of Hamiltonian; config.h_funcs = H; config.h_func_args = args. # take care of collapse operators; config.c_const_inds = np.arange(config.c_num); config.c_td_inds = np.array([]); if len(config.c_const_inds) > 0:; H = 0; for k in config.c_const_inds:; H -= 0.5j * (c_ops[k].dag() * c_ops[k]); if options.tidy:; H = H.tidyup(options.atol); config.h_data = -1.0j * H.data.data; config.h_ind = H.data.indices; config.h_ptr = H.data.indptr. def _mc_dm_avg(psi_list):; """"""; Private function that averages density matrices in parallel; over all trajectories for a single time using parfor.; """"""; ln = len(psi_list); dims = psi_list[0].dims; shape = psi_list[0].shape; out_data = np.sum([psi.data for psi in psi_list]) / ln; return Qobj(out_data, dims=dims, shape=shape, fast='mc-dm').  Copyright 2011 and later, P.D",MatchSource.WIKI,docs/4.2/modules/qutip/mcsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html
https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:38925,Modifiability,config,config,38925,"t_inds = np.setdiff1d(C_inds, C_td_inds); # store indicies of constant collapse terms; config.c_const_inds = C_const_inds; # store indicies of time-dependent collapse terms; config.c_td_inds = C_td_inds; config.c_funcs = np.zeros(config.c_num, dtype=FunctionType); for k in config.c_td_inds:; config.c_funcs[k] = c_ops[k][1]; config.c_func_args = args. # combine constant collapse terms with constant H and construct data; for k in config.c_const_inds:; H -= 0.5j * (c_ops[k].dag() * c_ops[k]); if options.tidy:; H = H.tidyup(options.atol); Htd = np.array([Htd[j].tidyup(options.atol); for j in config.h_td_inds], dtype=object); # setup constant H terms data; config.h_data = -1.0j * H.data.data; config.h_ind = H.data.indices; config.h_ptr = H.data.indptr. # setup td H terms data; config.h_td_data = np.array(; [-1.0j * Htd[k].data.data for k in config.h_td_inds]); config.h_td_ind = np.array(; [Htd[k].data.indices for k in config.h_td_inds]); config.h_td_ptr = np.array(; [Htd[k].data.indptr for k in config.h_td_inds]). elif config.tflag == 3:; # PYTHON FUNCTION BASED HAMILTONIAN; # ---------------------------------. # take care of Hamiltonian; config.h_funcs = H; config.h_func_args = args. # take care of collapse operators; config.c_const_inds = np.arange(config.c_num); config.c_td_inds = np.array([]); if len(config.c_const_inds) > 0:; H = 0; for k in config.c_const_inds:; H -= 0.5j * (c_ops[k].dag() * c_ops[k]); if options.tidy:; H = H.tidyup(options.atol); config.h_data = -1.0j * H.data.data; config.h_ind = H.data.indices; config.h_ptr = H.data.indptr. def _mc_dm_avg(psi_list):; """"""; Private function that averages density matrices in parallel; over all trajectories for a single time using parfor.; """"""; ln = len(psi_list); dims = psi_list[0].dims; shape = psi_list[0].shape; out_data = np.sum([psi.data for psi in psi_list]) / ln; return Qobj(out_data, dims=dims, shape=shape, fast='mc-dm').  Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, a",MatchSource.WIKI,docs/4.2/modules/qutip/mcsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html
https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:38950,Modifiability,config,config,38950,"C_td_inds); # store indicies of constant collapse terms; config.c_const_inds = C_const_inds; # store indicies of time-dependent collapse terms; config.c_td_inds = C_td_inds; config.c_funcs = np.zeros(config.c_num, dtype=FunctionType); for k in config.c_td_inds:; config.c_funcs[k] = c_ops[k][1]; config.c_func_args = args. # combine constant collapse terms with constant H and construct data; for k in config.c_const_inds:; H -= 0.5j * (c_ops[k].dag() * c_ops[k]); if options.tidy:; H = H.tidyup(options.atol); Htd = np.array([Htd[j].tidyup(options.atol); for j in config.h_td_inds], dtype=object); # setup constant H terms data; config.h_data = -1.0j * H.data.data; config.h_ind = H.data.indices; config.h_ptr = H.data.indptr. # setup td H terms data; config.h_td_data = np.array(; [-1.0j * Htd[k].data.data for k in config.h_td_inds]); config.h_td_ind = np.array(; [Htd[k].data.indices for k in config.h_td_inds]); config.h_td_ptr = np.array(; [Htd[k].data.indptr for k in config.h_td_inds]). elif config.tflag == 3:; # PYTHON FUNCTION BASED HAMILTONIAN; # ---------------------------------. # take care of Hamiltonian; config.h_funcs = H; config.h_func_args = args. # take care of collapse operators; config.c_const_inds = np.arange(config.c_num); config.c_td_inds = np.array([]); if len(config.c_const_inds) > 0:; H = 0; for k in config.c_const_inds:; H -= 0.5j * (c_ops[k].dag() * c_ops[k]); if options.tidy:; H = H.tidyup(options.atol); config.h_data = -1.0j * H.data.data; config.h_ind = H.data.indices; config.h_ptr = H.data.indptr. def _mc_dm_avg(psi_list):; """"""; Private function that averages density matrices in parallel; over all trajectories for a single time using parfor.; """"""; ln = len(psi_list); dims = psi_list[0].dims; shape = psi_list[0].shape; out_data = np.sum([psi.data for psi in psi_list]) / ln; return Qobj(out_data, dims=dims, shape=shape, fast='mc-dm').  Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, and A.L. Grimsmo.; Last updated",MatchSource.WIKI,docs/4.2/modules/qutip/mcsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html
https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:39072,Modifiability,config,config,39072,"onst_inds; # store indicies of time-dependent collapse terms; config.c_td_inds = C_td_inds; config.c_funcs = np.zeros(config.c_num, dtype=FunctionType); for k in config.c_td_inds:; config.c_funcs[k] = c_ops[k][1]; config.c_func_args = args. # combine constant collapse terms with constant H and construct data; for k in config.c_const_inds:; H -= 0.5j * (c_ops[k].dag() * c_ops[k]); if options.tidy:; H = H.tidyup(options.atol); Htd = np.array([Htd[j].tidyup(options.atol); for j in config.h_td_inds], dtype=object); # setup constant H terms data; config.h_data = -1.0j * H.data.data; config.h_ind = H.data.indices; config.h_ptr = H.data.indptr. # setup td H terms data; config.h_td_data = np.array(; [-1.0j * Htd[k].data.data for k in config.h_td_inds]); config.h_td_ind = np.array(; [Htd[k].data.indices for k in config.h_td_inds]); config.h_td_ptr = np.array(; [Htd[k].data.indptr for k in config.h_td_inds]). elif config.tflag == 3:; # PYTHON FUNCTION BASED HAMILTONIAN; # ---------------------------------. # take care of Hamiltonian; config.h_funcs = H; config.h_func_args = args. # take care of collapse operators; config.c_const_inds = np.arange(config.c_num); config.c_td_inds = np.array([]); if len(config.c_const_inds) > 0:; H = 0; for k in config.c_const_inds:; H -= 0.5j * (c_ops[k].dag() * c_ops[k]); if options.tidy:; H = H.tidyup(options.atol); config.h_data = -1.0j * H.data.data; config.h_ind = H.data.indices; config.h_ptr = H.data.indptr. def _mc_dm_avg(psi_list):; """"""; Private function that averages density matrices in parallel; over all trajectories for a single time using parfor.; """"""; ln = len(psi_list); dims = psi_list[0].dims; shape = psi_list[0].shape; out_data = np.sum([psi.data for psi in psi_list]) / ln; return Qobj(out_data, dims=dims, shape=shape, fast='mc-dm').  Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, and A.L. Grimsmo.; Last updated on Jan 17, 2018. . Built with Sphinx using a theme provided by Read the Docs. . ",MatchSource.WIKI,docs/4.2/modules/qutip/mcsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html
https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:39092,Modifiability,config,config,39092,"onst_inds; # store indicies of time-dependent collapse terms; config.c_td_inds = C_td_inds; config.c_funcs = np.zeros(config.c_num, dtype=FunctionType); for k in config.c_td_inds:; config.c_funcs[k] = c_ops[k][1]; config.c_func_args = args. # combine constant collapse terms with constant H and construct data; for k in config.c_const_inds:; H -= 0.5j * (c_ops[k].dag() * c_ops[k]); if options.tidy:; H = H.tidyup(options.atol); Htd = np.array([Htd[j].tidyup(options.atol); for j in config.h_td_inds], dtype=object); # setup constant H terms data; config.h_data = -1.0j * H.data.data; config.h_ind = H.data.indices; config.h_ptr = H.data.indptr. # setup td H terms data; config.h_td_data = np.array(; [-1.0j * Htd[k].data.data for k in config.h_td_inds]); config.h_td_ind = np.array(; [Htd[k].data.indices for k in config.h_td_inds]); config.h_td_ptr = np.array(; [Htd[k].data.indptr for k in config.h_td_inds]). elif config.tflag == 3:; # PYTHON FUNCTION BASED HAMILTONIAN; # ---------------------------------. # take care of Hamiltonian; config.h_funcs = H; config.h_func_args = args. # take care of collapse operators; config.c_const_inds = np.arange(config.c_num); config.c_td_inds = np.array([]); if len(config.c_const_inds) > 0:; H = 0; for k in config.c_const_inds:; H -= 0.5j * (c_ops[k].dag() * c_ops[k]); if options.tidy:; H = H.tidyup(options.atol); config.h_data = -1.0j * H.data.data; config.h_ind = H.data.indices; config.h_ptr = H.data.indptr. def _mc_dm_avg(psi_list):; """"""; Private function that averages density matrices in parallel; over all trajectories for a single time using parfor.; """"""; ln = len(psi_list); dims = psi_list[0].dims; shape = psi_list[0].shape; out_data = np.sum([psi.data for psi in psi_list]) / ln; return Qobj(out_data, dims=dims, shape=shape, fast='mc-dm').  Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, and A.L. Grimsmo.; Last updated on Jan 17, 2018. . Built with Sphinx using a theme provided by Read the Docs. . ",MatchSource.WIKI,docs/4.2/modules/qutip/mcsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html
https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:39154,Modifiability,config,config,39154,"onst_inds; # store indicies of time-dependent collapse terms; config.c_td_inds = C_td_inds; config.c_funcs = np.zeros(config.c_num, dtype=FunctionType); for k in config.c_td_inds:; config.c_funcs[k] = c_ops[k][1]; config.c_func_args = args. # combine constant collapse terms with constant H and construct data; for k in config.c_const_inds:; H -= 0.5j * (c_ops[k].dag() * c_ops[k]); if options.tidy:; H = H.tidyup(options.atol); Htd = np.array([Htd[j].tidyup(options.atol); for j in config.h_td_inds], dtype=object); # setup constant H terms data; config.h_data = -1.0j * H.data.data; config.h_ind = H.data.indices; config.h_ptr = H.data.indptr. # setup td H terms data; config.h_td_data = np.array(; [-1.0j * Htd[k].data.data for k in config.h_td_inds]); config.h_td_ind = np.array(; [Htd[k].data.indices for k in config.h_td_inds]); config.h_td_ptr = np.array(; [Htd[k].data.indptr for k in config.h_td_inds]). elif config.tflag == 3:; # PYTHON FUNCTION BASED HAMILTONIAN; # ---------------------------------. # take care of Hamiltonian; config.h_funcs = H; config.h_func_args = args. # take care of collapse operators; config.c_const_inds = np.arange(config.c_num); config.c_td_inds = np.array([]); if len(config.c_const_inds) > 0:; H = 0; for k in config.c_const_inds:; H -= 0.5j * (c_ops[k].dag() * c_ops[k]); if options.tidy:; H = H.tidyup(options.atol); config.h_data = -1.0j * H.data.data; config.h_ind = H.data.indices; config.h_ptr = H.data.indptr. def _mc_dm_avg(psi_list):; """"""; Private function that averages density matrices in parallel; over all trajectories for a single time using parfor.; """"""; ln = len(psi_list); dims = psi_list[0].dims; shape = psi_list[0].shape; out_data = np.sum([psi.data for psi in psi_list]) / ln; return Qobj(out_data, dims=dims, shape=shape, fast='mc-dm').  Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, and A.L. Grimsmo.; Last updated on Jan 17, 2018. . Built with Sphinx using a theme provided by Read the Docs. . ",MatchSource.WIKI,docs/4.2/modules/qutip/mcsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html
https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:39186,Modifiability,config,config,39186,"onst_inds; # store indicies of time-dependent collapse terms; config.c_td_inds = C_td_inds; config.c_funcs = np.zeros(config.c_num, dtype=FunctionType); for k in config.c_td_inds:; config.c_funcs[k] = c_ops[k][1]; config.c_func_args = args. # combine constant collapse terms with constant H and construct data; for k in config.c_const_inds:; H -= 0.5j * (c_ops[k].dag() * c_ops[k]); if options.tidy:; H = H.tidyup(options.atol); Htd = np.array([Htd[j].tidyup(options.atol); for j in config.h_td_inds], dtype=object); # setup constant H terms data; config.h_data = -1.0j * H.data.data; config.h_ind = H.data.indices; config.h_ptr = H.data.indptr. # setup td H terms data; config.h_td_data = np.array(; [-1.0j * Htd[k].data.data for k in config.h_td_inds]); config.h_td_ind = np.array(; [Htd[k].data.indices for k in config.h_td_inds]); config.h_td_ptr = np.array(; [Htd[k].data.indptr for k in config.h_td_inds]). elif config.tflag == 3:; # PYTHON FUNCTION BASED HAMILTONIAN; # ---------------------------------. # take care of Hamiltonian; config.h_funcs = H; config.h_func_args = args. # take care of collapse operators; config.c_const_inds = np.arange(config.c_num); config.c_td_inds = np.array([]); if len(config.c_const_inds) > 0:; H = 0; for k in config.c_const_inds:; H -= 0.5j * (c_ops[k].dag() * c_ops[k]); if options.tidy:; H = H.tidyup(options.atol); config.h_data = -1.0j * H.data.data; config.h_ind = H.data.indices; config.h_ptr = H.data.indptr. def _mc_dm_avg(psi_list):; """"""; Private function that averages density matrices in parallel; over all trajectories for a single time using parfor.; """"""; ln = len(psi_list); dims = psi_list[0].dims; shape = psi_list[0].shape; out_data = np.sum([psi.data for psi in psi_list]) / ln; return Qobj(out_data, dims=dims, shape=shape, fast='mc-dm').  Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, and A.L. Grimsmo.; Last updated on Jan 17, 2018. . Built with Sphinx using a theme provided by Read the Docs. . ",MatchSource.WIKI,docs/4.2/modules/qutip/mcsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html
https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:39201,Modifiability,config,config,39201,"onst_inds; # store indicies of time-dependent collapse terms; config.c_td_inds = C_td_inds; config.c_funcs = np.zeros(config.c_num, dtype=FunctionType); for k in config.c_td_inds:; config.c_funcs[k] = c_ops[k][1]; config.c_func_args = args. # combine constant collapse terms with constant H and construct data; for k in config.c_const_inds:; H -= 0.5j * (c_ops[k].dag() * c_ops[k]); if options.tidy:; H = H.tidyup(options.atol); Htd = np.array([Htd[j].tidyup(options.atol); for j in config.h_td_inds], dtype=object); # setup constant H terms data; config.h_data = -1.0j * H.data.data; config.h_ind = H.data.indices; config.h_ptr = H.data.indptr. # setup td H terms data; config.h_td_data = np.array(; [-1.0j * Htd[k].data.data for k in config.h_td_inds]); config.h_td_ind = np.array(; [Htd[k].data.indices for k in config.h_td_inds]); config.h_td_ptr = np.array(; [Htd[k].data.indptr for k in config.h_td_inds]). elif config.tflag == 3:; # PYTHON FUNCTION BASED HAMILTONIAN; # ---------------------------------. # take care of Hamiltonian; config.h_funcs = H; config.h_func_args = args. # take care of collapse operators; config.c_const_inds = np.arange(config.c_num); config.c_td_inds = np.array([]); if len(config.c_const_inds) > 0:; H = 0; for k in config.c_const_inds:; H -= 0.5j * (c_ops[k].dag() * c_ops[k]); if options.tidy:; H = H.tidyup(options.atol); config.h_data = -1.0j * H.data.data; config.h_ind = H.data.indices; config.h_ptr = H.data.indptr. def _mc_dm_avg(psi_list):; """"""; Private function that averages density matrices in parallel; over all trajectories for a single time using parfor.; """"""; ln = len(psi_list); dims = psi_list[0].dims; shape = psi_list[0].shape; out_data = np.sum([psi.data for psi in psi_list]) / ln; return Qobj(out_data, dims=dims, shape=shape, fast='mc-dm').  Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, and A.L. Grimsmo.; Last updated on Jan 17, 2018. . Built with Sphinx using a theme provided by Read the Docs. . ",MatchSource.WIKI,docs/4.2/modules/qutip/mcsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html
https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:39241,Modifiability,config,config,39241,"onst_inds; # store indicies of time-dependent collapse terms; config.c_td_inds = C_td_inds; config.c_funcs = np.zeros(config.c_num, dtype=FunctionType); for k in config.c_td_inds:; config.c_funcs[k] = c_ops[k][1]; config.c_func_args = args. # combine constant collapse terms with constant H and construct data; for k in config.c_const_inds:; H -= 0.5j * (c_ops[k].dag() * c_ops[k]); if options.tidy:; H = H.tidyup(options.atol); Htd = np.array([Htd[j].tidyup(options.atol); for j in config.h_td_inds], dtype=object); # setup constant H terms data; config.h_data = -1.0j * H.data.data; config.h_ind = H.data.indices; config.h_ptr = H.data.indptr. # setup td H terms data; config.h_td_data = np.array(; [-1.0j * Htd[k].data.data for k in config.h_td_inds]); config.h_td_ind = np.array(; [Htd[k].data.indices for k in config.h_td_inds]); config.h_td_ptr = np.array(; [Htd[k].data.indptr for k in config.h_td_inds]). elif config.tflag == 3:; # PYTHON FUNCTION BASED HAMILTONIAN; # ---------------------------------. # take care of Hamiltonian; config.h_funcs = H; config.h_func_args = args. # take care of collapse operators; config.c_const_inds = np.arange(config.c_num); config.c_td_inds = np.array([]); if len(config.c_const_inds) > 0:; H = 0; for k in config.c_const_inds:; H -= 0.5j * (c_ops[k].dag() * c_ops[k]); if options.tidy:; H = H.tidyup(options.atol); config.h_data = -1.0j * H.data.data; config.h_ind = H.data.indices; config.h_ptr = H.data.indptr. def _mc_dm_avg(psi_list):; """"""; Private function that averages density matrices in parallel; over all trajectories for a single time using parfor.; """"""; ln = len(psi_list); dims = psi_list[0].dims; shape = psi_list[0].shape; out_data = np.sum([psi.data for psi in psi_list]) / ln; return Qobj(out_data, dims=dims, shape=shape, fast='mc-dm').  Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, and A.L. Grimsmo.; Last updated on Jan 17, 2018. . Built with Sphinx using a theme provided by Read the Docs. . ",MatchSource.WIKI,docs/4.2/modules/qutip/mcsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html
https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:39284,Modifiability,config,config,39284,"onst_inds; # store indicies of time-dependent collapse terms; config.c_td_inds = C_td_inds; config.c_funcs = np.zeros(config.c_num, dtype=FunctionType); for k in config.c_td_inds:; config.c_funcs[k] = c_ops[k][1]; config.c_func_args = args. # combine constant collapse terms with constant H and construct data; for k in config.c_const_inds:; H -= 0.5j * (c_ops[k].dag() * c_ops[k]); if options.tidy:; H = H.tidyup(options.atol); Htd = np.array([Htd[j].tidyup(options.atol); for j in config.h_td_inds], dtype=object); # setup constant H terms data; config.h_data = -1.0j * H.data.data; config.h_ind = H.data.indices; config.h_ptr = H.data.indptr. # setup td H terms data; config.h_td_data = np.array(; [-1.0j * Htd[k].data.data for k in config.h_td_inds]); config.h_td_ind = np.array(; [Htd[k].data.indices for k in config.h_td_inds]); config.h_td_ptr = np.array(; [Htd[k].data.indptr for k in config.h_td_inds]). elif config.tflag == 3:; # PYTHON FUNCTION BASED HAMILTONIAN; # ---------------------------------. # take care of Hamiltonian; config.h_funcs = H; config.h_func_args = args. # take care of collapse operators; config.c_const_inds = np.arange(config.c_num); config.c_td_inds = np.array([]); if len(config.c_const_inds) > 0:; H = 0; for k in config.c_const_inds:; H -= 0.5j * (c_ops[k].dag() * c_ops[k]); if options.tidy:; H = H.tidyup(options.atol); config.h_data = -1.0j * H.data.data; config.h_ind = H.data.indices; config.h_ptr = H.data.indptr. def _mc_dm_avg(psi_list):; """"""; Private function that averages density matrices in parallel; over all trajectories for a single time using parfor.; """"""; ln = len(psi_list); dims = psi_list[0].dims; shape = psi_list[0].shape; out_data = np.sum([psi.data for psi in psi_list]) / ln; return Qobj(out_data, dims=dims, shape=shape, fast='mc-dm').  Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, and A.L. Grimsmo.; Last updated on Jan 17, 2018. . Built with Sphinx using a theme provided by Read the Docs. . ",MatchSource.WIKI,docs/4.2/modules/qutip/mcsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html
https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:39393,Modifiability,config,config,39393,"onst_inds; # store indicies of time-dependent collapse terms; config.c_td_inds = C_td_inds; config.c_funcs = np.zeros(config.c_num, dtype=FunctionType); for k in config.c_td_inds:; config.c_funcs[k] = c_ops[k][1]; config.c_func_args = args. # combine constant collapse terms with constant H and construct data; for k in config.c_const_inds:; H -= 0.5j * (c_ops[k].dag() * c_ops[k]); if options.tidy:; H = H.tidyup(options.atol); Htd = np.array([Htd[j].tidyup(options.atol); for j in config.h_td_inds], dtype=object); # setup constant H terms data; config.h_data = -1.0j * H.data.data; config.h_ind = H.data.indices; config.h_ptr = H.data.indptr. # setup td H terms data; config.h_td_data = np.array(; [-1.0j * Htd[k].data.data for k in config.h_td_inds]); config.h_td_ind = np.array(; [Htd[k].data.indices for k in config.h_td_inds]); config.h_td_ptr = np.array(; [Htd[k].data.indptr for k in config.h_td_inds]). elif config.tflag == 3:; # PYTHON FUNCTION BASED HAMILTONIAN; # ---------------------------------. # take care of Hamiltonian; config.h_funcs = H; config.h_func_args = args. # take care of collapse operators; config.c_const_inds = np.arange(config.c_num); config.c_td_inds = np.array([]); if len(config.c_const_inds) > 0:; H = 0; for k in config.c_const_inds:; H -= 0.5j * (c_ops[k].dag() * c_ops[k]); if options.tidy:; H = H.tidyup(options.atol); config.h_data = -1.0j * H.data.data; config.h_ind = H.data.indices; config.h_ptr = H.data.indptr. def _mc_dm_avg(psi_list):; """"""; Private function that averages density matrices in parallel; over all trajectories for a single time using parfor.; """"""; ln = len(psi_list); dims = psi_list[0].dims; shape = psi_list[0].shape; out_data = np.sum([psi.data for psi in psi_list]) / ln; return Qobj(out_data, dims=dims, shape=shape, fast='mc-dm').  Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, and A.L. Grimsmo.; Last updated on Jan 17, 2018. . Built with Sphinx using a theme provided by Read the Docs. . ",MatchSource.WIKI,docs/4.2/modules/qutip/mcsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html
https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:39430,Modifiability,config,config,39430,"onst_inds; # store indicies of time-dependent collapse terms; config.c_td_inds = C_td_inds; config.c_funcs = np.zeros(config.c_num, dtype=FunctionType); for k in config.c_td_inds:; config.c_funcs[k] = c_ops[k][1]; config.c_func_args = args. # combine constant collapse terms with constant H and construct data; for k in config.c_const_inds:; H -= 0.5j * (c_ops[k].dag() * c_ops[k]); if options.tidy:; H = H.tidyup(options.atol); Htd = np.array([Htd[j].tidyup(options.atol); for j in config.h_td_inds], dtype=object); # setup constant H terms data; config.h_data = -1.0j * H.data.data; config.h_ind = H.data.indices; config.h_ptr = H.data.indptr. # setup td H terms data; config.h_td_data = np.array(; [-1.0j * Htd[k].data.data for k in config.h_td_inds]); config.h_td_ind = np.array(; [Htd[k].data.indices for k in config.h_td_inds]); config.h_td_ptr = np.array(; [Htd[k].data.indptr for k in config.h_td_inds]). elif config.tflag == 3:; # PYTHON FUNCTION BASED HAMILTONIAN; # ---------------------------------. # take care of Hamiltonian; config.h_funcs = H; config.h_func_args = args. # take care of collapse operators; config.c_const_inds = np.arange(config.c_num); config.c_td_inds = np.array([]); if len(config.c_const_inds) > 0:; H = 0; for k in config.c_const_inds:; H -= 0.5j * (c_ops[k].dag() * c_ops[k]); if options.tidy:; H = H.tidyup(options.atol); config.h_data = -1.0j * H.data.data; config.h_ind = H.data.indices; config.h_ptr = H.data.indptr. def _mc_dm_avg(psi_list):; """"""; Private function that averages density matrices in parallel; over all trajectories for a single time using parfor.; """"""; ln = len(psi_list); dims = psi_list[0].dims; shape = psi_list[0].shape; out_data = np.sum([psi.data for psi in psi_list]) / ln; return Qobj(out_data, dims=dims, shape=shape, fast='mc-dm').  Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, and A.L. Grimsmo.; Last updated on Jan 17, 2018. . Built with Sphinx using a theme provided by Read the Docs. . ",MatchSource.WIKI,docs/4.2/modules/qutip/mcsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html
https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:39461,Modifiability,config,config,39461,"onst_inds; # store indicies of time-dependent collapse terms; config.c_td_inds = C_td_inds; config.c_funcs = np.zeros(config.c_num, dtype=FunctionType); for k in config.c_td_inds:; config.c_funcs[k] = c_ops[k][1]; config.c_func_args = args. # combine constant collapse terms with constant H and construct data; for k in config.c_const_inds:; H -= 0.5j * (c_ops[k].dag() * c_ops[k]); if options.tidy:; H = H.tidyup(options.atol); Htd = np.array([Htd[j].tidyup(options.atol); for j in config.h_td_inds], dtype=object); # setup constant H terms data; config.h_data = -1.0j * H.data.data; config.h_ind = H.data.indices; config.h_ptr = H.data.indptr. # setup td H terms data; config.h_td_data = np.array(; [-1.0j * Htd[k].data.data for k in config.h_td_inds]); config.h_td_ind = np.array(; [Htd[k].data.indices for k in config.h_td_inds]); config.h_td_ptr = np.array(; [Htd[k].data.indptr for k in config.h_td_inds]). elif config.tflag == 3:; # PYTHON FUNCTION BASED HAMILTONIAN; # ---------------------------------. # take care of Hamiltonian; config.h_funcs = H; config.h_func_args = args. # take care of collapse operators; config.c_const_inds = np.arange(config.c_num); config.c_td_inds = np.array([]); if len(config.c_const_inds) > 0:; H = 0; for k in config.c_const_inds:; H -= 0.5j * (c_ops[k].dag() * c_ops[k]); if options.tidy:; H = H.tidyup(options.atol); config.h_data = -1.0j * H.data.data; config.h_ind = H.data.indices; config.h_ptr = H.data.indptr. def _mc_dm_avg(psi_list):; """"""; Private function that averages density matrices in parallel; over all trajectories for a single time using parfor.; """"""; ln = len(psi_list); dims = psi_list[0].dims; shape = psi_list[0].shape; out_data = np.sum([psi.data for psi in psi_list]) / ln; return Qobj(out_data, dims=dims, shape=shape, fast='mc-dm').  Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, and A.L. Grimsmo.; Last updated on Jan 17, 2018. . Built with Sphinx using a theme provided by Read the Docs. . ",MatchSource.WIKI,docs/4.2/modules/qutip/mcsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html
https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:3146,Performance,load,loaded,3146,".integrate import ode; import scipy.sparse as sp; from scipy.integrate._ode import zvode; from scipy.linalg.blas import get_blas_funcs; from qutip.qobj import Qobj; from qutip.parallel import parfor, parallel_map, serial_map; from qutip.cy.spmatfuncs import cy_ode_rhs, cy_expect_psi_csr, spmv, spmv_csr; from qutip.cy.codegen import Codegen; from qutip.cy.utilities import _cython_build_cleanup; from qutip.cy.spconvert import dense2D_to_fastcsr_cmode; from qutip.solver import Options, Result, config, _solver_safety_check; from qutip.rhs_generate import _td_format_check, _td_wrap_array_str; from qutip.interpolate import Cubic_Spline; from qutip.settings import debug; from qutip.ui.progressbar import TextProgressBar, BaseProgressBar; from qutip.fastsparse import csr2fast; import qutip.settings. dznrm2 = get_blas_funcs(""znrm2"", dtype=np.float64). if debug:; import inspect. #; # Internal, global variables for storing references to dynamically loaded; # cython functions; #; _cy_col_spmv_func = None; _cy_col_expect_func = None; _cy_col_spmv_call_func = None; _cy_col_expect_call_func = None; _cy_rhs_func = None. class qutip_zvode(zvode):; def step(self, *args):; itask = self.call_args[2]; self.rwork[0] = args[4]; self.call_args[2] = 5; r = self.run(*args); self.call_args[2] = itask; return r. [docs]def mcsolve(H, psi0, tlist, c_ops=[], e_ops=[], ntraj=None,; args={}, options=None, progress_bar=True,; map_func=None, map_kwargs=None,; _safe_mode=True):; """"""Monte Carlo evolution of a state vector :math:`|\psi \\rangle` for a; given Hamiltonian and sets of collapse operators, and possibly, operators; for calculating expectation values. Options for the underlying ODE solver; are given by the Options class. mcsolve supports time-dependent Hamiltonians and collapse operators using; either Python functions of strings to represent time-dependent; coefficients. Note that, the system Hamiltonian MUST have at least one; constant term. As an example of a time-dependent problem, consider ",MatchSource.WIKI,docs/4.2/modules/qutip/mcsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html
https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:8782,Performance,load,load,8782,"array)):; config.ntraj = np.sort(ntraj)[-1]; else:; config.ntraj = ntraj. # set norm finding constants; config.norm_tol = options.norm_tol; config.norm_steps = options.norm_steps. # convert array based time-dependence to string format; H, c_ops, args = _td_wrap_array_str(H, c_ops, args, tlist). # SETUP ODE DATA IF NONE EXISTS OR NOT REUSING; # --------------------------------------------; if not options.rhs_reuse or not config.tdfunc:; # reset config collapse and time-dependence flags to default values; config.soft_reset(). # check for type of time-dependence (if any); time_type, h_stuff, c_stuff = _td_format_check(H, c_ops, 'mc'); c_terms = len(c_stuff[0]) + len(c_stuff[1]) + len(c_stuff[2]); # set time_type for use in multiprocessing; config.tflag = time_type. # check for collapse operators; if c_terms > 0:; config.cflag = 1; else:; config.cflag = 0. # Configure data; _mc_data_config(H, psi0, h_stuff, c_ops, c_stuff, args, e_ops,; options, config). # compile and load cython functions if necessary; _mc_func_load(config). else:; # setup args for new parameters when rhs_reuse=True and tdfunc is given; # string based; if config.tflag in [1, 10, 11]:; if any(args):; config.c_args = []; arg_items = list(args.items()); for k in range(len(arg_items)):; config.c_args.append(arg_items[k][1]); # function based; elif config.tflag in [2, 3, 20, 22]:; config.h_func_args = args. # load monte carlo class; mc = _MC(config). # Run the simulation; mc.run(). # Remove RHS cython file if necessary; if not options.rhs_reuse and config.tdname:; _cython_build_cleanup(config.tdname). # AFTER MCSOLVER IS DONE; # ----------------------. # Store results in the Result object; output = Result(); output.solver = 'mcsolve'; output.seeds = config.options.seeds; # state vectors; if (mc.psi_out is not None and config.options.average_states; and config.cflag and ntraj != 1):; output.states = parfor(_mc_dm_avg, mc.psi_out.T); elif mc.psi_out is not None:; output.states = mc.psi_out. # expectation value",MatchSource.WIKI,docs/4.2/modules/qutip/mcsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html
https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:9194,Performance,load,load,9194,"_reuse or not config.tdfunc:; # reset config collapse and time-dependence flags to default values; config.soft_reset(). # check for type of time-dependence (if any); time_type, h_stuff, c_stuff = _td_format_check(H, c_ops, 'mc'); c_terms = len(c_stuff[0]) + len(c_stuff[1]) + len(c_stuff[2]); # set time_type for use in multiprocessing; config.tflag = time_type. # check for collapse operators; if c_terms > 0:; config.cflag = 1; else:; config.cflag = 0. # Configure data; _mc_data_config(H, psi0, h_stuff, c_ops, c_stuff, args, e_ops,; options, config). # compile and load cython functions if necessary; _mc_func_load(config). else:; # setup args for new parameters when rhs_reuse=True and tdfunc is given; # string based; if config.tflag in [1, 10, 11]:; if any(args):; config.c_args = []; arg_items = list(args.items()); for k in range(len(arg_items)):; config.c_args.append(arg_items[k][1]); # function based; elif config.tflag in [2, 3, 20, 22]:; config.h_func_args = args. # load monte carlo class; mc = _MC(config). # Run the simulation; mc.run(). # Remove RHS cython file if necessary; if not options.rhs_reuse and config.tdname:; _cython_build_cleanup(config.tdname). # AFTER MCSOLVER IS DONE; # ----------------------. # Store results in the Result object; output = Result(); output.solver = 'mcsolve'; output.seeds = config.options.seeds; # state vectors; if (mc.psi_out is not None and config.options.average_states; and config.cflag and ntraj != 1):; output.states = parfor(_mc_dm_avg, mc.psi_out.T); elif mc.psi_out is not None:; output.states = mc.psi_out. # expectation values; if (mc.expect_out is not None and config.cflag; and config.options.average_expect):; # averaging if multiple trajectories; if isinstance(ntraj, int):; output.expect = [np.mean(np.array([mc.expect_out[nt][op]; for nt in range(ntraj)],; dtype=object),; axis=0); for op in range(config.e_num)]; elif isinstance(ntraj, (list, np.ndarray)):; output.expect = []; for num in ntraj:; expt_data = np.mean(mc.expect_",MatchSource.WIKI,docs/4.2/modules/qutip/mcsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html
https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:25075,Testability,log,log,25075,"irst_step=opt.first_step,; min_step=opt.min_step, max_step=opt.max_step). if not len(ODE._y):; ODE.t = 0.0; ODE._y = np.array([0.0], complex); ODE._integrator.reset(len(ODE._y), ODE.jac is not None). # set initial conditions; ODE.set_initial_value(config.psi0, tlist[0]). # make array for collapse operator inds; cinds = np.arange(config.c_num). # RUN ODE UNTIL EACH TIME IN TLIST; for k in range(1, num_times):; # ODE WHILE LOOP FOR INTEGRATE UP TO TIME TLIST[k]; while ODE.t < tlist[k]:; t_prev = ODE.t; y_prev = ODE.y; norm2_prev = dznrm2(ODE._y) ** 2; # integrate up to tlist[k], one step at a time.; ODE.integrate(tlist[k], step=1); if not ODE.successful():; raise Exception(""ZVODE failed!""); norm2_psi = dznrm2(ODE._y) ** 2; if norm2_psi <= rand_vals[0]:; # collapse has occured:; # find collapse time to within specified tolerance; # ------------------------------------------------; ii = 0; t_final = ODE.t; while ii < config.norm_steps:; ii += 1; t_guess = t_prev + \; np.log(norm2_prev / rand_vals[0]) / \; np.log(norm2_prev / norm2_psi) * (t_final - t_prev); ODE._y = y_prev; ODE.t = t_prev; ODE._integrator.call_args[3] = 1; ODE.integrate(t_guess, step=0); if not ODE.successful():; raise Exception(; ""ZVODE failed after adjusting step size!""); norm2_guess = dznrm2(ODE._y)**2; if (np.abs(rand_vals[0] - norm2_guess) <; config.norm_tol * rand_vals[0]):; break; elif (norm2_guess < rand_vals[0]):; # t_guess is still > t_jump; t_final = t_guess; norm2_psi = norm2_guess; else:; # t_guess < t_jump; t_prev = t_guess; y_prev = ODE.y; norm2_prev = norm2_guess; if ii > config.norm_steps:; raise Exception(""Norm tolerance not reached. "" +; ""Increase accuracy of ODE solver or "" +; ""Options.norm_steps.""). collapse_times.append(ODE.t). # some string based collapse operators; if config.tflag in [1, 11]:; n_dp = [cy_expect_psi_csr(config.n_ops_data[i],; config.n_ops_ind[i],; config.n_ops_ptr[i],; ODE._y, 1); for i in config.c_const_inds]. _locals = locals(); # calculates the expectation value",MatchSource.WIKI,docs/4.2/modules/qutip/mcsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html
https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:25114,Testability,log,log,25114,"p, max_step=opt.max_step). if not len(ODE._y):; ODE.t = 0.0; ODE._y = np.array([0.0], complex); ODE._integrator.reset(len(ODE._y), ODE.jac is not None). # set initial conditions; ODE.set_initial_value(config.psi0, tlist[0]). # make array for collapse operator inds; cinds = np.arange(config.c_num). # RUN ODE UNTIL EACH TIME IN TLIST; for k in range(1, num_times):; # ODE WHILE LOOP FOR INTEGRATE UP TO TIME TLIST[k]; while ODE.t < tlist[k]:; t_prev = ODE.t; y_prev = ODE.y; norm2_prev = dznrm2(ODE._y) ** 2; # integrate up to tlist[k], one step at a time.; ODE.integrate(tlist[k], step=1); if not ODE.successful():; raise Exception(""ZVODE failed!""); norm2_psi = dznrm2(ODE._y) ** 2; if norm2_psi <= rand_vals[0]:; # collapse has occured:; # find collapse time to within specified tolerance; # ------------------------------------------------; ii = 0; t_final = ODE.t; while ii < config.norm_steps:; ii += 1; t_guess = t_prev + \; np.log(norm2_prev / rand_vals[0]) / \; np.log(norm2_prev / norm2_psi) * (t_final - t_prev); ODE._y = y_prev; ODE.t = t_prev; ODE._integrator.call_args[3] = 1; ODE.integrate(t_guess, step=0); if not ODE.successful():; raise Exception(; ""ZVODE failed after adjusting step size!""); norm2_guess = dznrm2(ODE._y)**2; if (np.abs(rand_vals[0] - norm2_guess) <; config.norm_tol * rand_vals[0]):; break; elif (norm2_guess < rand_vals[0]):; # t_guess is still > t_jump; t_final = t_guess; norm2_psi = norm2_guess; else:; # t_guess < t_jump; t_prev = t_guess; y_prev = ODE.y; norm2_prev = norm2_guess; if ii > config.norm_steps:; raise Exception(""Norm tolerance not reached. "" +; ""Increase accuracy of ODE solver or "" +; ""Options.norm_steps.""). collapse_times.append(ODE.t). # some string based collapse operators; if config.tflag in [1, 11]:; n_dp = [cy_expect_psi_csr(config.n_ops_data[i],; config.n_ops_ind[i],; config.n_ops_ptr[i],; ODE._y, 1); for i in config.c_const_inds]. _locals = locals(); # calculates the expectation values for time-dependent; # norm collapse operator",MatchSource.WIKI,docs/4.2/modules/qutip/mcsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html
https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:5767,Usability,progress bar,progress bar,5767,"oeff]]. c_ops = [C0, [C1, C1_coeff]]. args={'a': A, 'w': W}. or in String (Cython) format we could write::. H = [H0, [H1, 'sin(w*t)']]. c_ops = [C0, [C1, 'exp(-a*t)']]. args={'a': A, 'w': W}. Constant terms are preferably placed first in the Hamiltonian and collapse; operator lists. Parameters; ----------; H : :class:`qutip.Qobj`; System Hamiltonian. psi0 : :class:`qutip.Qobj`; Initial state vector. tlist : array_like; Times at which results are recorded. ntraj : int; Number of trajectories to run. c_ops : array_like; single collapse operator or ``list`` or ``array`` of collapse; operators. e_ops : array_like; single operator or ``list`` or ``array`` of operators for calculating; expectation values. args : dict; Arguments for time-dependent Hamiltonian and collapse operator terms. options : Options; Instance of ODE solver options. progress_bar: BaseProgressBar; Optional instance of BaseProgressBar, or a subclass thereof, for; showing the progress of the simulation. Set to None to disable the; progress bar. map_func: function; A map function for managing the calls to the single-trajactory solver. map_kwargs: dictionary; Optional keyword arguments to the map_func function. Returns; -------; results : :class:`qutip.solver.Result`; Object storing all results from the simulation. .. note::. It is possible to reuse the random number seeds from a previous run; of the mcsolver by passing the output Result object seeds via the; Options class, i.e. Options(seeds=prev_result.seeds).; """""". if debug:; print(inspect.stack()[0][3]); ; if isinstance(c_ops, Qobj):; c_ops = [c_ops]. if isinstance(e_ops, Qobj):; e_ops = [e_ops]. if isinstance(e_ops, dict):; e_ops_dict = e_ops; e_ops = [e for e in e_ops.values()]; else:; e_ops_dict = None; ; if _safe_mode:; _solver_safety_check(H, psi0, c_ops, e_ops, args); ; if options is None:; options = Options(). if ntraj is None:; ntraj = options.ntraj. config.map_func = map_func if map_func is not None else parallel_map; config.map_kwargs = map_k",MatchSource.WIKI,docs/4.2/modules/qutip/mcsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html
https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:11372,Usability,simpl,simplify,11372,"t.append(np.real(expt_data[k])); else:; data_list.append(expt_data[k]); else:; data_list = [data for data in expt_data]; output.expect.append(data_list); else:; # no averaging for single trajectory or if average_expect flag; # (Options) is off; if mc.expect_out is not None:; output.expect = mc.expect_out. # simulation parameters; output.times = config.tlist; output.num_expect = config.e_num; output.num_collapse = config.c_num; output.ntraj = config.ntraj; output.col_times = mc.collapse_times_out; output.col_which = mc.which_op_out. if e_ops_dict:; output.expect = {e: output.expect[n]; for n, e in enumerate(e_ops_dict.keys())}. return output. # -----------------------------------------------------------------------------; # MONTE CARLO CLASS; # -----------------------------------------------------------------------------; class _MC():; """"""; Private class for solving Monte Carlo evolution from mcsolve; """""". def __init__(self, config):. self.config = config; # set output variables, even if they are not used to simplify output; # code.; self.psi_out = None; self.expect_out = []; self.collapse_times_out = None; self.which_op_out = None. # FOR EVOLUTION WITH COLLAPSE OPERATORS; if config.c_num:; # preallocate ntraj arrays for state vectors, collapse times, and; # which operator; self.collapse_times_out = np.zeros(config.ntraj, dtype=np.ndarray); self.which_op_out = np.zeros(config.ntraj, dtype=np.ndarray); if config.e_num == 0 or config.options.store_states:; self.psi_out = [None] * config.ntraj; if config.e_num > 0:; self.expect_out = [None] * config.ntraj. # setup seeds array; if self.config.options.seeds is None:; self.config.options.seeds = \; randint(1, 100000000.0 + 1, size=config.ntraj); else:; # if ntraj was reduced but reusing seeds; seed_length = len(config.options.seeds); if seed_length > config.ntraj:; self.config.options.seeds = \; config.options.seeds[0:config.ntraj]; # if ntraj was increased but reusing seeds; elif seed_length < config.ntraj:; newseeds = ra",MatchSource.WIKI,docs/4.2/modules/qutip/mcsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html
https://qutip.org/docs/4.2/modules/qutip/mesolve.html:28944,Availability,error,error,28944,"re output array; #; n_tsteps = len(tlist); e_sops_data = []. output = Result(); output.solver = ""mesolve""; output.times = tlist. if opt.store_states:; output.states = []. if isinstance(e_ops, types.FunctionType):; n_expt_op = 0; expt_callback = True. elif isinstance(e_ops, list):. n_expt_op = len(e_ops); expt_callback = False. if n_expt_op == 0:; # fall back on storing states; output.states = []; opt.store_states = True; else:; output.expect = []; output.num_expect = n_expt_op; for op in e_ops:; e_sops_data.append(spre(op).data); if op.isherm and rho0.isherm:; output.expect.append(np.zeros(n_tsteps)); else:; output.expect.append(np.zeros(n_tsteps, dtype=complex)). else:; raise TypeError(""Expectation parameter must be a list or a function""). #; # start evolution; #; progress_bar.start(n_tsteps). rho = Qobj(rho0). dt = np.diff(tlist); for t_idx, t in enumerate(tlist):; progress_bar.update(t_idx). if not r.successful():; raise Exception(""ODE integration error: Try to increase ""; ""the allowed number of substeps by increasing ""; ""the nsteps parameter in the Options class.""). if opt.store_states or expt_callback:; rho.data = dense2D_to_fastcsr_fmode(vec2mat(r.y), rho.shape[0], rho.shape[1]). if opt.store_states:; output.states.append(Qobj(rho, isherm=True)). if expt_callback:; # use callback method; e_ops(t, rho). for m in range(n_expt_op):; if output.expect[m].dtype == complex:; output.expect[m][t_idx] = expect_rho_vec(e_sops_data[m],; r.y, 0); else:; output.expect[m][t_idx] = expect_rho_vec(e_sops_data[m],; r.y, 1). if t_idx < n_tsteps - 1:; r.integrate(r.t + dt[t_idx]). progress_bar.finished(). if (not opt.rhs_reuse) and (config.tdname is not None):; _cython_build_cleanup(config.tdname). if opt.store_final_state:; rho.data = dense2D_to_fastcsr_fmode(vec2mat(r.y), rho.shape[0], rho.shape[1]); output.final_state = Qobj(rho, dims=rho0.dims, isherm=True). return output. # -----------------------------------------------------------------------------; # Old style API below.;",MatchSource.WIKI,docs/4.2/modules/qutip/mesolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mesolve.html
https://qutip.org/docs/4.2/modules/qutip/mesolve.html:2303,Deployability,integrat,integrate,2303," LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A; # PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT; # HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,; # SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT; # LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,; # DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY; # THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT; # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE; # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.; ###############################################################################; """"""; This module provides solvers for the Lindblad master equation and von Neumann; equation.; """""". __all__ = ['mesolve', 'odesolve']. import os; import types; from functools import partial; import numpy as np; import scipy.sparse as sp; import scipy.integrate; import warnings; import qutip.settings as qset; from qutip.qobj import Qobj, isket, isoper, issuper; from qutip.superoperator import spre, spost, liouvillian, mat2vec, vec2mat; from qutip.expect import expect_rho_vec; from qutip.solver import Options, Result, config, _solver_safety_check; from qutip.cy.spmatfuncs import cy_ode_rhs, cy_ode_rho_func_td, spmvpy_csr; from qutip.cy.spconvert import dense2D_to_fastcsr_fmode; from qutip.cy.codegen import Codegen; from qutip.cy.utilities import _cython_build_cleanup; from qutip.rhs_generate import rhs_generate; from qutip.states import ket2dm; from qutip.rhs_generate import _td_format_check, _td_wrap_array_str; from qutip.interpolate import Cubic_Spline; from qutip.settings import debug. from qutip.sesolve import (_sesolve_list_func_td, _sesolve_list_str_td,; _sesolve_list_td, _sesolve_func_td, _sesolve_const). from qutip.ui.progressbar import BaseProgressBar, TextProgressBar. from qutip.cy.openmp.utilities import check_use_openmp, openmp_components; if",MatchSource.WIKI,docs/4.2/modules/qutip/mesolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mesolve.html
https://qutip.org/docs/4.2/modules/qutip/mesolve.html:4013,Deployability,integrat,integrating,4013," qutip.interpolate import Cubic_Spline; from qutip.settings import debug. from qutip.sesolve import (_sesolve_list_func_td, _sesolve_list_str_td,; _sesolve_list_td, _sesolve_func_td, _sesolve_const). from qutip.ui.progressbar import BaseProgressBar, TextProgressBar. from qutip.cy.openmp.utilities import check_use_openmp, openmp_components; if qset.has_openmp:; from qutip.cy.openmp.parfuncs import cy_ode_rhs_openmp. if debug:; import inspect. # -----------------------------------------------------------------------------; # pass on to wavefunction solver or master equation solver depending on whether; # any collapse operators were given.; #; [docs]def mesolve(H, rho0, tlist, c_ops=[], e_ops=[], args={}, options=None,; progress_bar=None, _safe_mode=True):; """"""; Master equation evolution of a density matrix for a given Hamiltonian and; set of collapse operators, or a Liouvillian. Evolve the state vector or density matrix (`rho0`) using a given; Hamiltonian (`H`) and an [optional] set of collapse operators; (`c_ops`), by integrating the set of ordinary differential equations; that define the system. In the absence of collapse operators the system is; evolved according to the unitary evolution of the Hamiltonian. The output is either the state vector at arbitrary points in time; (`tlist`), or the expectation values of the supplied operators; (`e_ops`). If e_ops is a callback function, it is invoked for each; time in `tlist` with time and the state as arguments, and the function; does not use any return values. If either `H` or the Qobj elements in `c_ops` are superoperators, they; will be treated as direct contributions to the total system Liouvillian.; This allows to solve master equations that are not on standard Lindblad; form by passing a custom Liouvillian in place of either the `H` or `c_ops`; elements. **Time-dependent operators**. For time-dependent problems, `H` and `c_ops` can be callback; functions that takes two arguments, time and `args`, and returns the; Ham",MatchSource.WIKI,docs/4.2/modules/qutip/mesolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mesolve.html
https://qutip.org/docs/4.2/modules/qutip/mesolve.html:6357,Deployability,integrat,integration,6357,"g operator, or a NumPy array (*list; array format*) which specifies the value of the coefficient to the; corresponding operator for each value of t in tlist. *Examples*. H = [[H0, 'sin(w*t)'], [H1, 'sin(2*w*t)']]. H = [[H0, f0_t], [H1, f1_t]]. where f0_t and f1_t are python functions with signature f_t(t, args). H = [[H0, np.sin(w*tlist)], [H1, np.sin(2*w*tlist)]]. In the *list string format* and *list callback format*, the string; expression and the callback function must evaluate to a real or complex; number (coefficient for the corresponding operator). In all cases of time-dependent operators, `args` is a dictionary of; parameters that is used when evaluating operators. It is passed to the; callback functions as second argument. **Additional options**. Additional options to mesolve can be set via the `options` argument, which; should be an instance of :class:`qutip.solver.Options`. Many ODE; integration options can be set this way, and the `store_states` and; `store_final_state` options can be used to store states even though; expectation values are requested via the `e_ops` argument. .. note::. If an element in the list-specification of the Hamiltonian or; the list of collapse operators are in superoperator form it will be; added to the total Liouvillian of the problem with out further; transformation. This allows for using mesolve for solving master; equations that are not on standard Lindblad form. .. note::. On using callback function: mesolve transforms all :class:`qutip.qobj`; objects to sparse matrices before handing the problem to the integrator; function. In order for your callback function to work correctly, pass; all :class:`qutip.qobj` objects that are used in constructing the; Hamiltonian via args. mesolve will check for :class:`qutip.qobj` in; `args` and handle the conversion to sparse matrices. All other; :class:`qutip.qobj` objects that are not passed via `args` will be; passed on to the integrator in scipy which will raise an NotImplemented; excep",MatchSource.WIKI,docs/4.2/modules/qutip/mesolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mesolve.html
https://qutip.org/docs/4.2/modules/qutip/mesolve.html:7021,Deployability,integrat,integrator,7021,"ng operator). In all cases of time-dependent operators, `args` is a dictionary of; parameters that is used when evaluating operators. It is passed to the; callback functions as second argument. **Additional options**. Additional options to mesolve can be set via the `options` argument, which; should be an instance of :class:`qutip.solver.Options`. Many ODE; integration options can be set this way, and the `store_states` and; `store_final_state` options can be used to store states even though; expectation values are requested via the `e_ops` argument. .. note::. If an element in the list-specification of the Hamiltonian or; the list of collapse operators are in superoperator form it will be; added to the total Liouvillian of the problem with out further; transformation. This allows for using mesolve for solving master; equations that are not on standard Lindblad form. .. note::. On using callback function: mesolve transforms all :class:`qutip.qobj`; objects to sparse matrices before handing the problem to the integrator; function. In order for your callback function to work correctly, pass; all :class:`qutip.qobj` objects that are used in constructing the; Hamiltonian via args. mesolve will check for :class:`qutip.qobj` in; `args` and handle the conversion to sparse matrices. All other; :class:`qutip.qobj` objects that are not passed via `args` will be; passed on to the integrator in scipy which will raise an NotImplemented; exception. Parameters; ----------. H : :class:`qutip.Qobj`; System Hamiltonian, or a callback function for time-dependent; Hamiltonians, or alternatively a system Liouvillian. rho0 : :class:`qutip.Qobj`; initial density matrix or state vector (ket). tlist : *list* / *array*; list of times for :math:`t`. c_ops : list of :class:`qutip.Qobj`; single collapse operator, or list of collapse operators, or a list; of Liouvillian superoperators. e_ops : list of :class:`qutip.Qobj` / callback function single; single operator or list of operators for which t",MatchSource.WIKI,docs/4.2/modules/qutip/mesolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mesolve.html
https://qutip.org/docs/4.2/modules/qutip/mesolve.html:7389,Deployability,integrat,integrator,7389,"t this way, and the `store_states` and; `store_final_state` options can be used to store states even though; expectation values are requested via the `e_ops` argument. .. note::. If an element in the list-specification of the Hamiltonian or; the list of collapse operators are in superoperator form it will be; added to the total Liouvillian of the problem with out further; transformation. This allows for using mesolve for solving master; equations that are not on standard Lindblad form. .. note::. On using callback function: mesolve transforms all :class:`qutip.qobj`; objects to sparse matrices before handing the problem to the integrator; function. In order for your callback function to work correctly, pass; all :class:`qutip.qobj` objects that are used in constructing the; Hamiltonian via args. mesolve will check for :class:`qutip.qobj` in; `args` and handle the conversion to sparse matrices. All other; :class:`qutip.qobj` objects that are not passed via `args` will be; passed on to the integrator in scipy which will raise an NotImplemented; exception. Parameters; ----------. H : :class:`qutip.Qobj`; System Hamiltonian, or a callback function for time-dependent; Hamiltonians, or alternatively a system Liouvillian. rho0 : :class:`qutip.Qobj`; initial density matrix or state vector (ket). tlist : *list* / *array*; list of times for :math:`t`. c_ops : list of :class:`qutip.Qobj`; single collapse operator, or list of collapse operators, or a list; of Liouvillian superoperators. e_ops : list of :class:`qutip.Qobj` / callback function single; single operator or list of operators for which to evaluate; expectation values. args : *dictionary*; dictionary of parameters for time-dependent Hamiltonians and; collapse operators. options : :class:`qutip.Options`; with options for the solver. progress_bar : BaseProgressBar; Optional instance of BaseProgressBar, or a subclass thereof, for; showing the progress of the simulation. Returns; -------; result: :class:`qutip.Result`. An i",MatchSource.WIKI,docs/4.2/modules/qutip/mesolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mesolve.html
https://qutip.org/docs/4.2/modules/qutip/mesolve.html:14522,Deployability,integrat,integrator,14522," function)""). if isoper(h):; L_list.append([(-1j * (spre(h) - spost(h))).data, h_coeff, False]). elif issuper(h):; L_list.append([h.data, h_coeff, False]). else:; raise TypeError(""Incorrect specification of time-dependent "" +; ""Hamiltonian (expected operator or superoperator)""). # add all collapse operators to the liouvillian list; for c_spec in c_list:. if isinstance(c_spec, Qobj):; c = c_spec; c_coeff = constant_func; c_square = False. elif isinstance(c_spec, list) and isinstance(c_spec[0], Qobj):; c = c_spec[0]; c_coeff = c_spec[1]; c_square = True. else:; raise TypeError(""Incorrect specification of time-dependent "" +; ""collapse operators (expected callback function)""). if isoper(c):; L_list.append([liouvillian(None, [c], data_only=True),; c_coeff, c_square]). elif issuper(c):; L_list.append([c.data, c_coeff, c_square]). else:; raise TypeError(""Incorrect specification of time-dependent "" +; ""collapse operators (expected operator or "" +; ""superoperator)""). #; # setup integrator; #; initial_vector = mat2vec(rho0.full()).ravel('F'); if issuper(rho0):; if opt.rhs_with_state:; r = scipy.integrate.ode(dsuper_list_td_with_state); else:; r = scipy.integrate.ode(dsuper_list_td); else:; if opt.rhs_with_state:; r = scipy.integrate.ode(drho_list_td_with_state); else:; r = scipy.integrate.ode(drho_list_td); r.set_integrator('zvode', method=opt.method, order=opt.order,; atol=opt.atol, rtol=opt.rtol, nsteps=opt.nsteps,; first_step=opt.first_step, min_step=opt.min_step,; max_step=opt.max_step); r.set_initial_value(initial_vector, tlist[0]); r.set_f_params(L_list, args). #; # call generic ODE code; #; return _generic_ode_solve(r, rho0, tlist, e_ops, opt, progress_bar). #; # evaluate drho(t)/dt according to the master equation using the; # [Qobj, function] style time dependence API; #; def drho_list_td(t, rho, L_list, args):; out = np.zeros(rho.shape[0],dtype=complex); L = L_list[0][0]; L_td = L_list[0][1]; spmvpy_csr(L.data, L.indices, L.indptr,; rho, L_td(t, args), out); for n in",MatchSource.WIKI,docs/4.2/modules/qutip/mesolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mesolve.html
https://qutip.org/docs/4.2/modules/qutip/mesolve.html:14640,Deployability,integrat,integrate,14640,"er(h):; L_list.append([h.data, h_coeff, False]). else:; raise TypeError(""Incorrect specification of time-dependent "" +; ""Hamiltonian (expected operator or superoperator)""). # add all collapse operators to the liouvillian list; for c_spec in c_list:. if isinstance(c_spec, Qobj):; c = c_spec; c_coeff = constant_func; c_square = False. elif isinstance(c_spec, list) and isinstance(c_spec[0], Qobj):; c = c_spec[0]; c_coeff = c_spec[1]; c_square = True. else:; raise TypeError(""Incorrect specification of time-dependent "" +; ""collapse operators (expected callback function)""). if isoper(c):; L_list.append([liouvillian(None, [c], data_only=True),; c_coeff, c_square]). elif issuper(c):; L_list.append([c.data, c_coeff, c_square]). else:; raise TypeError(""Incorrect specification of time-dependent "" +; ""collapse operators (expected operator or "" +; ""superoperator)""). #; # setup integrator; #; initial_vector = mat2vec(rho0.full()).ravel('F'); if issuper(rho0):; if opt.rhs_with_state:; r = scipy.integrate.ode(dsuper_list_td_with_state); else:; r = scipy.integrate.ode(dsuper_list_td); else:; if opt.rhs_with_state:; r = scipy.integrate.ode(drho_list_td_with_state); else:; r = scipy.integrate.ode(drho_list_td); r.set_integrator('zvode', method=opt.method, order=opt.order,; atol=opt.atol, rtol=opt.rtol, nsteps=opt.nsteps,; first_step=opt.first_step, min_step=opt.min_step,; max_step=opt.max_step); r.set_initial_value(initial_vector, tlist[0]); r.set_f_params(L_list, args). #; # call generic ODE code; #; return _generic_ode_solve(r, rho0, tlist, e_ops, opt, progress_bar). #; # evaluate drho(t)/dt according to the master equation using the; # [Qobj, function] style time dependence API; #; def drho_list_td(t, rho, L_list, args):; out = np.zeros(rho.shape[0],dtype=complex); L = L_list[0][0]; L_td = L_list[0][1]; spmvpy_csr(L.data, L.indices, L.indptr,; rho, L_td(t, args), out); for n in range(1, len(L_list)):; #; # L_args[n][0] = the sparse data for a Qobj in super-operator form; # L_args[n",MatchSource.WIKI,docs/4.2/modules/qutip/mesolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mesolve.html
https://qutip.org/docs/4.2/modules/qutip/mesolve.html:14699,Deployability,integrat,integrate,14699,"se TypeError(""Incorrect specification of time-dependent "" +; ""Hamiltonian (expected operator or superoperator)""). # add all collapse operators to the liouvillian list; for c_spec in c_list:. if isinstance(c_spec, Qobj):; c = c_spec; c_coeff = constant_func; c_square = False. elif isinstance(c_spec, list) and isinstance(c_spec[0], Qobj):; c = c_spec[0]; c_coeff = c_spec[1]; c_square = True. else:; raise TypeError(""Incorrect specification of time-dependent "" +; ""collapse operators (expected callback function)""). if isoper(c):; L_list.append([liouvillian(None, [c], data_only=True),; c_coeff, c_square]). elif issuper(c):; L_list.append([c.data, c_coeff, c_square]). else:; raise TypeError(""Incorrect specification of time-dependent "" +; ""collapse operators (expected operator or "" +; ""superoperator)""). #; # setup integrator; #; initial_vector = mat2vec(rho0.full()).ravel('F'); if issuper(rho0):; if opt.rhs_with_state:; r = scipy.integrate.ode(dsuper_list_td_with_state); else:; r = scipy.integrate.ode(dsuper_list_td); else:; if opt.rhs_with_state:; r = scipy.integrate.ode(drho_list_td_with_state); else:; r = scipy.integrate.ode(drho_list_td); r.set_integrator('zvode', method=opt.method, order=opt.order,; atol=opt.atol, rtol=opt.rtol, nsteps=opt.nsteps,; first_step=opt.first_step, min_step=opt.min_step,; max_step=opt.max_step); r.set_initial_value(initial_vector, tlist[0]); r.set_f_params(L_list, args). #; # call generic ODE code; #; return _generic_ode_solve(r, rho0, tlist, e_ops, opt, progress_bar). #; # evaluate drho(t)/dt according to the master equation using the; # [Qobj, function] style time dependence API; #; def drho_list_td(t, rho, L_list, args):; out = np.zeros(rho.shape[0],dtype=complex); L = L_list[0][0]; L_td = L_list[0][1]; spmvpy_csr(L.data, L.indices, L.indptr,; rho, L_td(t, args), out); for n in range(1, len(L_list)):; #; # L_args[n][0] = the sparse data for a Qobj in super-operator form; # L_args[n][1] = function callback giving the coefficient; #; L = L_l",MatchSource.WIKI,docs/4.2/modules/qutip/mesolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mesolve.html
https://qutip.org/docs/4.2/modules/qutip/mesolve.html:14771,Deployability,integrat,integrate,14771,"n (expected operator or superoperator)""). # add all collapse operators to the liouvillian list; for c_spec in c_list:. if isinstance(c_spec, Qobj):; c = c_spec; c_coeff = constant_func; c_square = False. elif isinstance(c_spec, list) and isinstance(c_spec[0], Qobj):; c = c_spec[0]; c_coeff = c_spec[1]; c_square = True. else:; raise TypeError(""Incorrect specification of time-dependent "" +; ""collapse operators (expected callback function)""). if isoper(c):; L_list.append([liouvillian(None, [c], data_only=True),; c_coeff, c_square]). elif issuper(c):; L_list.append([c.data, c_coeff, c_square]). else:; raise TypeError(""Incorrect specification of time-dependent "" +; ""collapse operators (expected operator or "" +; ""superoperator)""). #; # setup integrator; #; initial_vector = mat2vec(rho0.full()).ravel('F'); if issuper(rho0):; if opt.rhs_with_state:; r = scipy.integrate.ode(dsuper_list_td_with_state); else:; r = scipy.integrate.ode(dsuper_list_td); else:; if opt.rhs_with_state:; r = scipy.integrate.ode(drho_list_td_with_state); else:; r = scipy.integrate.ode(drho_list_td); r.set_integrator('zvode', method=opt.method, order=opt.order,; atol=opt.atol, rtol=opt.rtol, nsteps=opt.nsteps,; first_step=opt.first_step, min_step=opt.min_step,; max_step=opt.max_step); r.set_initial_value(initial_vector, tlist[0]); r.set_f_params(L_list, args). #; # call generic ODE code; #; return _generic_ode_solve(r, rho0, tlist, e_ops, opt, progress_bar). #; # evaluate drho(t)/dt according to the master equation using the; # [Qobj, function] style time dependence API; #; def drho_list_td(t, rho, L_list, args):; out = np.zeros(rho.shape[0],dtype=complex); L = L_list[0][0]; L_td = L_list[0][1]; spmvpy_csr(L.data, L.indices, L.indptr,; rho, L_td(t, args), out); for n in range(1, len(L_list)):; #; # L_args[n][0] = the sparse data for a Qobj in super-operator form; # L_args[n][1] = function callback giving the coefficient; #; L = L_list[n][0]; L_td = L_list[n][1]; if L_list[n][2]:; spmvpy_csr(L.data, L.i",MatchSource.WIKI,docs/4.2/modules/qutip/mesolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mesolve.html
https://qutip.org/docs/4.2/modules/qutip/mesolve.html:14828,Deployability,integrat,integrate,14828,"pse operators to the liouvillian list; for c_spec in c_list:. if isinstance(c_spec, Qobj):; c = c_spec; c_coeff = constant_func; c_square = False. elif isinstance(c_spec, list) and isinstance(c_spec[0], Qobj):; c = c_spec[0]; c_coeff = c_spec[1]; c_square = True. else:; raise TypeError(""Incorrect specification of time-dependent "" +; ""collapse operators (expected callback function)""). if isoper(c):; L_list.append([liouvillian(None, [c], data_only=True),; c_coeff, c_square]). elif issuper(c):; L_list.append([c.data, c_coeff, c_square]). else:; raise TypeError(""Incorrect specification of time-dependent "" +; ""collapse operators (expected operator or "" +; ""superoperator)""). #; # setup integrator; #; initial_vector = mat2vec(rho0.full()).ravel('F'); if issuper(rho0):; if opt.rhs_with_state:; r = scipy.integrate.ode(dsuper_list_td_with_state); else:; r = scipy.integrate.ode(dsuper_list_td); else:; if opt.rhs_with_state:; r = scipy.integrate.ode(drho_list_td_with_state); else:; r = scipy.integrate.ode(drho_list_td); r.set_integrator('zvode', method=opt.method, order=opt.order,; atol=opt.atol, rtol=opt.rtol, nsteps=opt.nsteps,; first_step=opt.first_step, min_step=opt.min_step,; max_step=opt.max_step); r.set_initial_value(initial_vector, tlist[0]); r.set_f_params(L_list, args). #; # call generic ODE code; #; return _generic_ode_solve(r, rho0, tlist, e_ops, opt, progress_bar). #; # evaluate drho(t)/dt according to the master equation using the; # [Qobj, function] style time dependence API; #; def drho_list_td(t, rho, L_list, args):; out = np.zeros(rho.shape[0],dtype=complex); L = L_list[0][0]; L_td = L_list[0][1]; spmvpy_csr(L.data, L.indices, L.indptr,; rho, L_td(t, args), out); for n in range(1, len(L_list)):; #; # L_args[n][0] = the sparse data for a Qobj in super-operator form; # L_args[n][1] = function callback giving the coefficient; #; L = L_list[n][0]; L_td = L_list[n][1]; if L_list[n][2]:; spmvpy_csr(L.data, L.indices, L.indptr,; rho, L_td(t, args)**2, out); else:; sp",MatchSource.WIKI,docs/4.2/modules/qutip/mesolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mesolve.html
https://qutip.org/docs/4.2/modules/qutip/mesolve.html:21569,Deployability,integrat,integrator,21569,"k in range(n_L_terms):; string_list.append(""Ldata[%d], Linds[%d], Lptrs[%d]"" % (k, k, k)); # Add object terms to end of ode args string; for k in range(len(Lobj)):; string_list.append(""Lobj[%d]"" % k); for name, value in args.items():; if isinstance(value, np.ndarray):; string_list.append(name); else:; string_list.append(str(value)); parameter_string = "","".join(string_list). #; # generate and compile new cython code if necessary; #; if not opt.rhs_reuse or config.tdfunc is None:; if opt.rhs_filename is None:; config.tdname = ""rhs"" + str(os.getpid()) + str(config.cgen_num); else:; config.tdname = opt.rhs_filename; cgen = Codegen(h_terms=n_L_terms, h_tdterms=Lcoeff, args=args,; config=config, use_openmp=opt.use_openmp,; omp_components=omp_components,; omp_threads=opt.openmp_threads); cgen.generate(config.tdname + "".pyx""). code = compile('from ' + config.tdname + ' import cy_td_ode_rhs',; '<string>', 'exec'); exec(code, globals()); config.tdfunc = cy_td_ode_rhs. #; # setup integrator; #; initial_vector = mat2vec(rho0.full()).ravel('F'); if issuper(rho0):; r = scipy.integrate.ode(_td_ode_rhs_super); code = compile('r.set_f_params([' + parameter_string + '])',; '<string>', 'exec'); else:; r = scipy.integrate.ode(config.tdfunc); code = compile('r.set_f_params(' + parameter_string + ')',; '<string>', 'exec'); r.set_integrator('zvode', method=opt.method, order=opt.order,; atol=opt.atol, rtol=opt.rtol, nsteps=opt.nsteps,; first_step=opt.first_step, min_step=opt.min_step,; max_step=opt.max_step); r.set_initial_value(initial_vector, tlist[0]). exec(code, locals(), args). #; # call generic ODE code; #; return _generic_ode_solve(r, rho0, tlist, e_ops, opt, progress_bar). def _td_ode_rhs_super(t, y, arglist):; N = int(np.sqrt(len(y))); out = np.zeros(N, dtype=complex); y2 = np.zeros(len(y), dtype=complex); for i in range(N):; out = cy_td_ode_rhs(t, y[i*N:(i+1)*N], *arglist); y2[i*N:(i+1)*N] = out; return y2. # ------------------------------------------------------------------------",MatchSource.WIKI,docs/4.2/modules/qutip/mesolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mesolve.html
https://qutip.org/docs/4.2/modules/qutip/mesolve.html:21663,Deployability,integrat,integrate,21663,"k, k)); # Add object terms to end of ode args string; for k in range(len(Lobj)):; string_list.append(""Lobj[%d]"" % k); for name, value in args.items():; if isinstance(value, np.ndarray):; string_list.append(name); else:; string_list.append(str(value)); parameter_string = "","".join(string_list). #; # generate and compile new cython code if necessary; #; if not opt.rhs_reuse or config.tdfunc is None:; if opt.rhs_filename is None:; config.tdname = ""rhs"" + str(os.getpid()) + str(config.cgen_num); else:; config.tdname = opt.rhs_filename; cgen = Codegen(h_terms=n_L_terms, h_tdterms=Lcoeff, args=args,; config=config, use_openmp=opt.use_openmp,; omp_components=omp_components,; omp_threads=opt.openmp_threads); cgen.generate(config.tdname + "".pyx""). code = compile('from ' + config.tdname + ' import cy_td_ode_rhs',; '<string>', 'exec'); exec(code, globals()); config.tdfunc = cy_td_ode_rhs. #; # setup integrator; #; initial_vector = mat2vec(rho0.full()).ravel('F'); if issuper(rho0):; r = scipy.integrate.ode(_td_ode_rhs_super); code = compile('r.set_f_params([' + parameter_string + '])',; '<string>', 'exec'); else:; r = scipy.integrate.ode(config.tdfunc); code = compile('r.set_f_params(' + parameter_string + ')',; '<string>', 'exec'); r.set_integrator('zvode', method=opt.method, order=opt.order,; atol=opt.atol, rtol=opt.rtol, nsteps=opt.nsteps,; first_step=opt.first_step, min_step=opt.min_step,; max_step=opt.max_step); r.set_initial_value(initial_vector, tlist[0]). exec(code, locals(), args). #; # call generic ODE code; #; return _generic_ode_solve(r, rho0, tlist, e_ops, opt, progress_bar). def _td_ode_rhs_super(t, y, arglist):; N = int(np.sqrt(len(y))); out = np.zeros(N, dtype=complex); y2 = np.zeros(len(y), dtype=complex); for i in range(N):; out = cy_td_ode_rhs(t, y[i*N:(i+1)*N], *arglist); y2[i*N:(i+1)*N] = out; return y2. # -----------------------------------------------------------------------------; # Master equation solver; #; def _mesolve_const(H, rho0, tlist, c_op_list, ",MatchSource.WIKI,docs/4.2/modules/qutip/mesolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mesolve.html
https://qutip.org/docs/4.2/modules/qutip/mesolve.html:21797,Deployability,integrat,integrate,21797,"in args.items():; if isinstance(value, np.ndarray):; string_list.append(name); else:; string_list.append(str(value)); parameter_string = "","".join(string_list). #; # generate and compile new cython code if necessary; #; if not opt.rhs_reuse or config.tdfunc is None:; if opt.rhs_filename is None:; config.tdname = ""rhs"" + str(os.getpid()) + str(config.cgen_num); else:; config.tdname = opt.rhs_filename; cgen = Codegen(h_terms=n_L_terms, h_tdterms=Lcoeff, args=args,; config=config, use_openmp=opt.use_openmp,; omp_components=omp_components,; omp_threads=opt.openmp_threads); cgen.generate(config.tdname + "".pyx""). code = compile('from ' + config.tdname + ' import cy_td_ode_rhs',; '<string>', 'exec'); exec(code, globals()); config.tdfunc = cy_td_ode_rhs. #; # setup integrator; #; initial_vector = mat2vec(rho0.full()).ravel('F'); if issuper(rho0):; r = scipy.integrate.ode(_td_ode_rhs_super); code = compile('r.set_f_params([' + parameter_string + '])',; '<string>', 'exec'); else:; r = scipy.integrate.ode(config.tdfunc); code = compile('r.set_f_params(' + parameter_string + ')',; '<string>', 'exec'); r.set_integrator('zvode', method=opt.method, order=opt.order,; atol=opt.atol, rtol=opt.rtol, nsteps=opt.nsteps,; first_step=opt.first_step, min_step=opt.min_step,; max_step=opt.max_step); r.set_initial_value(initial_vector, tlist[0]). exec(code, locals(), args). #; # call generic ODE code; #; return _generic_ode_solve(r, rho0, tlist, e_ops, opt, progress_bar). def _td_ode_rhs_super(t, y, arglist):; N = int(np.sqrt(len(y))); out = np.zeros(N, dtype=complex); y2 = np.zeros(len(y), dtype=complex); for i in range(N):; out = cy_td_ode_rhs(t, y[i*N:(i+1)*N], *arglist); y2[i*N:(i+1)*N] = out; return y2. # -----------------------------------------------------------------------------; # Master equation solver; #; def _mesolve_const(H, rho0, tlist, c_op_list, e_ops, args, opt,; progress_bar):; """"""; Evolve the density matrix using an ODE solver, for constant hamiltonian; and collapse operator",MatchSource.WIKI,docs/4.2/modules/qutip/mesolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mesolve.html
https://qutip.org/docs/4.2/modules/qutip/mesolve.html:23334,Deployability,integrat,integrator,23334,"(N, dtype=complex); y2 = np.zeros(len(y), dtype=complex); for i in range(N):; out = cy_td_ode_rhs(t, y[i*N:(i+1)*N], *arglist); y2[i*N:(i+1)*N] = out; return y2. # -----------------------------------------------------------------------------; # Master equation solver; #; def _mesolve_const(H, rho0, tlist, c_op_list, e_ops, args, opt,; progress_bar):; """"""; Evolve the density matrix using an ODE solver, for constant hamiltonian; and collapse operators.; """""". if debug:; print(inspect.stack()[0][3]). #; # check initial state; #; if isket(rho0):; # if initial state is a ket and no collapse operator where given,; # fall back on the unitary schrodinger equation solver; if len(c_op_list) == 0 and isoper(H):; return _sesolve_const(H, rho0, tlist, e_ops, args, opt,; progress_bar). # Got a wave function as initial state: convert to density matrix.; rho0 = ket2dm(rho0). #; # construct liouvillian; #; if opt.tidy:; H = H.tidyup(opt.atol). L = liouvillian(H, c_op_list); . #; # setup integrator; #; initial_vector = mat2vec(rho0.full()).ravel('F'); if issuper(rho0):; r = scipy.integrate.ode(_ode_super_func); r.set_f_params(L.data); else:; if opt.use_openmp and L.data.nnz >= qset.openmp_thresh:; r = scipy.integrate.ode(cy_ode_rhs_openmp); r.set_f_params(L.data.data, L.data.indices, L.data.indptr, ; opt.openmp_threads); else:; r = scipy.integrate.ode(cy_ode_rhs); r.set_f_params(L.data.data, L.data.indices, L.data.indptr); # r = scipy.integrate.ode(_ode_rho_test); # r.set_f_params(L.data); r.set_integrator('zvode', method=opt.method, order=opt.order,; atol=opt.atol, rtol=opt.rtol, nsteps=opt.nsteps,; first_step=opt.first_step, min_step=opt.min_step,; max_step=opt.max_step); r.set_initial_value(initial_vector, tlist[0]). #; # call generic ODE code; #; return _generic_ode_solve(r, rho0, tlist, e_ops, opt, progress_bar). #; # evaluate drho(t)/dt according to the master eqaution; # [no longer used, replaced by cython function]; #; def _ode_rho_func(t, rho, L):; return L * rho. def _ode_rho",MatchSource.WIKI,docs/4.2/modules/qutip/mesolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mesolve.html
https://qutip.org/docs/4.2/modules/qutip/mesolve.html:23428,Deployability,integrat,integrate,23428," cy_td_ode_rhs(t, y[i*N:(i+1)*N], *arglist); y2[i*N:(i+1)*N] = out; return y2. # -----------------------------------------------------------------------------; # Master equation solver; #; def _mesolve_const(H, rho0, tlist, c_op_list, e_ops, args, opt,; progress_bar):; """"""; Evolve the density matrix using an ODE solver, for constant hamiltonian; and collapse operators.; """""". if debug:; print(inspect.stack()[0][3]). #; # check initial state; #; if isket(rho0):; # if initial state is a ket and no collapse operator where given,; # fall back on the unitary schrodinger equation solver; if len(c_op_list) == 0 and isoper(H):; return _sesolve_const(H, rho0, tlist, e_ops, args, opt,; progress_bar). # Got a wave function as initial state: convert to density matrix.; rho0 = ket2dm(rho0). #; # construct liouvillian; #; if opt.tidy:; H = H.tidyup(opt.atol). L = liouvillian(H, c_op_list); . #; # setup integrator; #; initial_vector = mat2vec(rho0.full()).ravel('F'); if issuper(rho0):; r = scipy.integrate.ode(_ode_super_func); r.set_f_params(L.data); else:; if opt.use_openmp and L.data.nnz >= qset.openmp_thresh:; r = scipy.integrate.ode(cy_ode_rhs_openmp); r.set_f_params(L.data.data, L.data.indices, L.data.indptr, ; opt.openmp_threads); else:; r = scipy.integrate.ode(cy_ode_rhs); r.set_f_params(L.data.data, L.data.indices, L.data.indptr); # r = scipy.integrate.ode(_ode_rho_test); # r.set_f_params(L.data); r.set_integrator('zvode', method=opt.method, order=opt.order,; atol=opt.atol, rtol=opt.rtol, nsteps=opt.nsteps,; first_step=opt.first_step, min_step=opt.min_step,; max_step=opt.max_step); r.set_initial_value(initial_vector, tlist[0]). #; # call generic ODE code; #; return _generic_ode_solve(r, rho0, tlist, e_ops, opt, progress_bar). #; # evaluate drho(t)/dt according to the master eqaution; # [no longer used, replaced by cython function]; #; def _ode_rho_func(t, rho, L):; return L * rho. def _ode_rho_test(t, rho, data):; # for performance comparison of cython code; return data*(np",MatchSource.WIKI,docs/4.2/modules/qutip/mesolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mesolve.html
https://qutip.org/docs/4.2/modules/qutip/mesolve.html:23558,Deployability,integrat,integrate,23558,"----------------------------; # Master equation solver; #; def _mesolve_const(H, rho0, tlist, c_op_list, e_ops, args, opt,; progress_bar):; """"""; Evolve the density matrix using an ODE solver, for constant hamiltonian; and collapse operators.; """""". if debug:; print(inspect.stack()[0][3]). #; # check initial state; #; if isket(rho0):; # if initial state is a ket and no collapse operator where given,; # fall back on the unitary schrodinger equation solver; if len(c_op_list) == 0 and isoper(H):; return _sesolve_const(H, rho0, tlist, e_ops, args, opt,; progress_bar). # Got a wave function as initial state: convert to density matrix.; rho0 = ket2dm(rho0). #; # construct liouvillian; #; if opt.tidy:; H = H.tidyup(opt.atol). L = liouvillian(H, c_op_list); . #; # setup integrator; #; initial_vector = mat2vec(rho0.full()).ravel('F'); if issuper(rho0):; r = scipy.integrate.ode(_ode_super_func); r.set_f_params(L.data); else:; if opt.use_openmp and L.data.nnz >= qset.openmp_thresh:; r = scipy.integrate.ode(cy_ode_rhs_openmp); r.set_f_params(L.data.data, L.data.indices, L.data.indptr, ; opt.openmp_threads); else:; r = scipy.integrate.ode(cy_ode_rhs); r.set_f_params(L.data.data, L.data.indices, L.data.indptr); # r = scipy.integrate.ode(_ode_rho_test); # r.set_f_params(L.data); r.set_integrator('zvode', method=opt.method, order=opt.order,; atol=opt.atol, rtol=opt.rtol, nsteps=opt.nsteps,; first_step=opt.first_step, min_step=opt.min_step,; max_step=opt.max_step); r.set_initial_value(initial_vector, tlist[0]). #; # call generic ODE code; #; return _generic_ode_solve(r, rho0, tlist, e_ops, opt, progress_bar). #; # evaluate drho(t)/dt according to the master eqaution; # [no longer used, replaced by cython function]; #; def _ode_rho_func(t, rho, L):; return L * rho. def _ode_rho_test(t, rho, data):; # for performance comparison of cython code; return data*(np.transpose(rho)); #; # Evaluate d E(t)/dt for E a super-operator; #. def _ode_super_func(t, y, data):; ym = vec2mat(y); return (da",MatchSource.WIKI,docs/4.2/modules/qutip/mesolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mesolve.html
https://qutip.org/docs/4.2/modules/qutip/mesolve.html:23691,Deployability,integrat,integrate,23691,"bar):; """"""; Evolve the density matrix using an ODE solver, for constant hamiltonian; and collapse operators.; """""". if debug:; print(inspect.stack()[0][3]). #; # check initial state; #; if isket(rho0):; # if initial state is a ket and no collapse operator where given,; # fall back on the unitary schrodinger equation solver; if len(c_op_list) == 0 and isoper(H):; return _sesolve_const(H, rho0, tlist, e_ops, args, opt,; progress_bar). # Got a wave function as initial state: convert to density matrix.; rho0 = ket2dm(rho0). #; # construct liouvillian; #; if opt.tidy:; H = H.tidyup(opt.atol). L = liouvillian(H, c_op_list); . #; # setup integrator; #; initial_vector = mat2vec(rho0.full()).ravel('F'); if issuper(rho0):; r = scipy.integrate.ode(_ode_super_func); r.set_f_params(L.data); else:; if opt.use_openmp and L.data.nnz >= qset.openmp_thresh:; r = scipy.integrate.ode(cy_ode_rhs_openmp); r.set_f_params(L.data.data, L.data.indices, L.data.indptr, ; opt.openmp_threads); else:; r = scipy.integrate.ode(cy_ode_rhs); r.set_f_params(L.data.data, L.data.indices, L.data.indptr); # r = scipy.integrate.ode(_ode_rho_test); # r.set_f_params(L.data); r.set_integrator('zvode', method=opt.method, order=opt.order,; atol=opt.atol, rtol=opt.rtol, nsteps=opt.nsteps,; first_step=opt.first_step, min_step=opt.min_step,; max_step=opt.max_step); r.set_initial_value(initial_vector, tlist[0]). #; # call generic ODE code; #; return _generic_ode_solve(r, rho0, tlist, e_ops, opt, progress_bar). #; # evaluate drho(t)/dt according to the master eqaution; # [no longer used, replaced by cython function]; #; def _ode_rho_func(t, rho, L):; return L * rho. def _ode_rho_test(t, rho, data):; # for performance comparison of cython code; return data*(np.transpose(rho)); #; # Evaluate d E(t)/dt for E a super-operator; #. def _ode_super_func(t, y, data):; ym = vec2mat(y); return (data*ym).ravel('F'). # -----------------------------------------------------------------------------; # Master equation solver for pyth",MatchSource.WIKI,docs/4.2/modules/qutip/mesolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mesolve.html
https://qutip.org/docs/4.2/modules/qutip/mesolve.html:23790,Deployability,integrat,integrate,23790,"perators.; """""". if debug:; print(inspect.stack()[0][3]). #; # check initial state; #; if isket(rho0):; # if initial state is a ket and no collapse operator where given,; # fall back on the unitary schrodinger equation solver; if len(c_op_list) == 0 and isoper(H):; return _sesolve_const(H, rho0, tlist, e_ops, args, opt,; progress_bar). # Got a wave function as initial state: convert to density matrix.; rho0 = ket2dm(rho0). #; # construct liouvillian; #; if opt.tidy:; H = H.tidyup(opt.atol). L = liouvillian(H, c_op_list); . #; # setup integrator; #; initial_vector = mat2vec(rho0.full()).ravel('F'); if issuper(rho0):; r = scipy.integrate.ode(_ode_super_func); r.set_f_params(L.data); else:; if opt.use_openmp and L.data.nnz >= qset.openmp_thresh:; r = scipy.integrate.ode(cy_ode_rhs_openmp); r.set_f_params(L.data.data, L.data.indices, L.data.indptr, ; opt.openmp_threads); else:; r = scipy.integrate.ode(cy_ode_rhs); r.set_f_params(L.data.data, L.data.indices, L.data.indptr); # r = scipy.integrate.ode(_ode_rho_test); # r.set_f_params(L.data); r.set_integrator('zvode', method=opt.method, order=opt.order,; atol=opt.atol, rtol=opt.rtol, nsteps=opt.nsteps,; first_step=opt.first_step, min_step=opt.min_step,; max_step=opt.max_step); r.set_initial_value(initial_vector, tlist[0]). #; # call generic ODE code; #; return _generic_ode_solve(r, rho0, tlist, e_ops, opt, progress_bar). #; # evaluate drho(t)/dt according to the master eqaution; # [no longer used, replaced by cython function]; #; def _ode_rho_func(t, rho, L):; return L * rho. def _ode_rho_test(t, rho, data):; # for performance comparison of cython code; return data*(np.transpose(rho)); #; # Evaluate d E(t)/dt for E a super-operator; #. def _ode_super_func(t, y, data):; ym = vec2mat(y); return (data*ym).ravel('F'). # -----------------------------------------------------------------------------; # Master equation solver for python-function time-dependence.; #; def _mesolve_func_td(L_func, rho0, tlist, c_op_list, e_ops, args, ",MatchSource.WIKI,docs/4.2/modules/qutip/mesolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mesolve.html
https://qutip.org/docs/4.2/modules/qutip/mesolve.html:25990,Deployability,integrat,integrator,25990,"dm(rho0). #; # construct liouvillian; #; new_args = None. if len(c_op_list) > 0:; L_data = liouvillian(None, c_op_list).data; else:; n, m = rho0.shape; if issuper(rho0):; L_data = sp.csr_matrix((n, m), dtype=complex); else:; L_data = sp.csr_matrix((n ** 2, m ** 2), dtype=complex). if type(args) is dict:; new_args = {}; for key in args:; if isinstance(args[key], Qobj):; if isoper(args[key]):; new_args[key] = (; -1j * (spre(args[key]) - spost(args[key]))); else:; new_args[key] = args[key]; else:; new_args[key] = args[key]. elif type(args) is list or type(args) is tuple:; new_args = []; for arg in args:; if isinstance(arg, Qobj):; if isoper(arg):; new_args.append((-1j * (spre(arg) - spost(arg))).data); else:; new_args.append(arg.data); else:; new_args.append(arg). if type(args) is tuple:; new_args = tuple(new_args); else:; if isinstance(args, Qobj):; if isoper(args):; new_args = (-1j * (spre(args) - spost(args))); else:; new_args = args; else:; new_args = args. #; # setup integrator; #; initial_vector = mat2vec(rho0.full()).ravel('F'); if issuper(rho0):; if not opt.rhs_with_state:; r = scipy.integrate.ode(_ode_super_func_td); else:; r = scipy.integrate.ode(_ode_super_func_td_with_state); else:; if not opt.rhs_with_state:; r = scipy.integrate.ode(cy_ode_rho_func_td); else:; r = scipy.integrate.ode(_ode_rho_func_td_with_state); r.set_integrator('zvode', method=opt.method, order=opt.order,; atol=opt.atol, rtol=opt.rtol, nsteps=opt.nsteps,; first_step=opt.first_step, min_step=opt.min_step,; max_step=opt.max_step); r.set_initial_value(initial_vector, tlist[0]); r.set_f_params(L_data, L_func, new_args). #; # call generic ODE code; #; return _generic_ode_solve(r, rho0, tlist, e_ops, opt, progress_bar). #; # evaluate drho(t)/dt according to the master equation; #; def _ode_rho_func_td(t, rho, L0, L_func, args):; L = L0 + L_func(t, args).data; return L * rho. #; # evaluate drho(t)/dt according to the master equation; #; def _ode_rho_func_td_with_state(t, rho, L0, L_func, args):;",MatchSource.WIKI,docs/4.2/modules/qutip/mesolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mesolve.html
https://qutip.org/docs/4.2/modules/qutip/mesolve.html:26112,Deployability,integrat,integrate,26112,"op_list).data; else:; n, m = rho0.shape; if issuper(rho0):; L_data = sp.csr_matrix((n, m), dtype=complex); else:; L_data = sp.csr_matrix((n ** 2, m ** 2), dtype=complex). if type(args) is dict:; new_args = {}; for key in args:; if isinstance(args[key], Qobj):; if isoper(args[key]):; new_args[key] = (; -1j * (spre(args[key]) - spost(args[key]))); else:; new_args[key] = args[key]; else:; new_args[key] = args[key]. elif type(args) is list or type(args) is tuple:; new_args = []; for arg in args:; if isinstance(arg, Qobj):; if isoper(arg):; new_args.append((-1j * (spre(arg) - spost(arg))).data); else:; new_args.append(arg.data); else:; new_args.append(arg). if type(args) is tuple:; new_args = tuple(new_args); else:; if isinstance(args, Qobj):; if isoper(args):; new_args = (-1j * (spre(args) - spost(args))); else:; new_args = args; else:; new_args = args. #; # setup integrator; #; initial_vector = mat2vec(rho0.full()).ravel('F'); if issuper(rho0):; if not opt.rhs_with_state:; r = scipy.integrate.ode(_ode_super_func_td); else:; r = scipy.integrate.ode(_ode_super_func_td_with_state); else:; if not opt.rhs_with_state:; r = scipy.integrate.ode(cy_ode_rho_func_td); else:; r = scipy.integrate.ode(_ode_rho_func_td_with_state); r.set_integrator('zvode', method=opt.method, order=opt.order,; atol=opt.atol, rtol=opt.rtol, nsteps=opt.nsteps,; first_step=opt.first_step, min_step=opt.min_step,; max_step=opt.max_step); r.set_initial_value(initial_vector, tlist[0]); r.set_f_params(L_data, L_func, new_args). #; # call generic ODE code; #; return _generic_ode_solve(r, rho0, tlist, e_ops, opt, progress_bar). #; # evaluate drho(t)/dt according to the master equation; #; def _ode_rho_func_td(t, rho, L0, L_func, args):; L = L0 + L_func(t, args).data; return L * rho. #; # evaluate drho(t)/dt according to the master equation; #; def _ode_rho_func_td_with_state(t, rho, L0, L_func, args):; L = L0 + L_func(t, rho, args).data; return L * rho. #; # evaluate dE(t)/dt according to the master equation, ",MatchSource.WIKI,docs/4.2/modules/qutip/mesolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mesolve.html
https://qutip.org/docs/4.2/modules/qutip/mesolve.html:26164,Deployability,integrat,integrate,26164,"rho0):; L_data = sp.csr_matrix((n, m), dtype=complex); else:; L_data = sp.csr_matrix((n ** 2, m ** 2), dtype=complex). if type(args) is dict:; new_args = {}; for key in args:; if isinstance(args[key], Qobj):; if isoper(args[key]):; new_args[key] = (; -1j * (spre(args[key]) - spost(args[key]))); else:; new_args[key] = args[key]; else:; new_args[key] = args[key]. elif type(args) is list or type(args) is tuple:; new_args = []; for arg in args:; if isinstance(arg, Qobj):; if isoper(arg):; new_args.append((-1j * (spre(arg) - spost(arg))).data); else:; new_args.append(arg.data); else:; new_args.append(arg). if type(args) is tuple:; new_args = tuple(new_args); else:; if isinstance(args, Qobj):; if isoper(args):; new_args = (-1j * (spre(args) - spost(args))); else:; new_args = args; else:; new_args = args. #; # setup integrator; #; initial_vector = mat2vec(rho0.full()).ravel('F'); if issuper(rho0):; if not opt.rhs_with_state:; r = scipy.integrate.ode(_ode_super_func_td); else:; r = scipy.integrate.ode(_ode_super_func_td_with_state); else:; if not opt.rhs_with_state:; r = scipy.integrate.ode(cy_ode_rho_func_td); else:; r = scipy.integrate.ode(_ode_rho_func_td_with_state); r.set_integrator('zvode', method=opt.method, order=opt.order,; atol=opt.atol, rtol=opt.rtol, nsteps=opt.nsteps,; first_step=opt.first_step, min_step=opt.min_step,; max_step=opt.max_step); r.set_initial_value(initial_vector, tlist[0]); r.set_f_params(L_data, L_func, new_args). #; # call generic ODE code; #; return _generic_ode_solve(r, rho0, tlist, e_ops, opt, progress_bar). #; # evaluate drho(t)/dt according to the master equation; #; def _ode_rho_func_td(t, rho, L0, L_func, args):; L = L0 + L_func(t, args).data; return L * rho. #; # evaluate drho(t)/dt according to the master equation; #; def _ode_rho_func_td_with_state(t, rho, L0, L_func, args):; L = L0 + L_func(t, rho, args).data; return L * rho. #; # evaluate dE(t)/dt according to the master equation, where E is a ; # superoperator; #; def _ode_super_fu",MatchSource.WIKI,docs/4.2/modules/qutip/mesolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mesolve.html
https://qutip.org/docs/4.2/modules/qutip/mesolve.html:26255,Deployability,integrat,integrate,26255,"2, m ** 2), dtype=complex). if type(args) is dict:; new_args = {}; for key in args:; if isinstance(args[key], Qobj):; if isoper(args[key]):; new_args[key] = (; -1j * (spre(args[key]) - spost(args[key]))); else:; new_args[key] = args[key]; else:; new_args[key] = args[key]. elif type(args) is list or type(args) is tuple:; new_args = []; for arg in args:; if isinstance(arg, Qobj):; if isoper(arg):; new_args.append((-1j * (spre(arg) - spost(arg))).data); else:; new_args.append(arg.data); else:; new_args.append(arg). if type(args) is tuple:; new_args = tuple(new_args); else:; if isinstance(args, Qobj):; if isoper(args):; new_args = (-1j * (spre(args) - spost(args))); else:; new_args = args; else:; new_args = args. #; # setup integrator; #; initial_vector = mat2vec(rho0.full()).ravel('F'); if issuper(rho0):; if not opt.rhs_with_state:; r = scipy.integrate.ode(_ode_super_func_td); else:; r = scipy.integrate.ode(_ode_super_func_td_with_state); else:; if not opt.rhs_with_state:; r = scipy.integrate.ode(cy_ode_rho_func_td); else:; r = scipy.integrate.ode(_ode_rho_func_td_with_state); r.set_integrator('zvode', method=opt.method, order=opt.order,; atol=opt.atol, rtol=opt.rtol, nsteps=opt.nsteps,; first_step=opt.first_step, min_step=opt.min_step,; max_step=opt.max_step); r.set_initial_value(initial_vector, tlist[0]); r.set_f_params(L_data, L_func, new_args). #; # call generic ODE code; #; return _generic_ode_solve(r, rho0, tlist, e_ops, opt, progress_bar). #; # evaluate drho(t)/dt according to the master equation; #; def _ode_rho_func_td(t, rho, L0, L_func, args):; L = L0 + L_func(t, args).data; return L * rho. #; # evaluate drho(t)/dt according to the master equation; #; def _ode_rho_func_td_with_state(t, rho, L0, L_func, args):; L = L0 + L_func(t, rho, args).data; return L * rho. #; # evaluate dE(t)/dt according to the master equation, where E is a ; # superoperator; #; def _ode_super_func_td(t, y, L0, L_func, args):; L = L0 + L_func(t, args).data; return _ode_super_func(t, y,",MatchSource.WIKI,docs/4.2/modules/qutip/mesolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mesolve.html
https://qutip.org/docs/4.2/modules/qutip/mesolve.html:26307,Deployability,integrat,integrate,26307,"new_args = {}; for key in args:; if isinstance(args[key], Qobj):; if isoper(args[key]):; new_args[key] = (; -1j * (spre(args[key]) - spost(args[key]))); else:; new_args[key] = args[key]; else:; new_args[key] = args[key]. elif type(args) is list or type(args) is tuple:; new_args = []; for arg in args:; if isinstance(arg, Qobj):; if isoper(arg):; new_args.append((-1j * (spre(arg) - spost(arg))).data); else:; new_args.append(arg.data); else:; new_args.append(arg). if type(args) is tuple:; new_args = tuple(new_args); else:; if isinstance(args, Qobj):; if isoper(args):; new_args = (-1j * (spre(args) - spost(args))); else:; new_args = args; else:; new_args = args. #; # setup integrator; #; initial_vector = mat2vec(rho0.full()).ravel('F'); if issuper(rho0):; if not opt.rhs_with_state:; r = scipy.integrate.ode(_ode_super_func_td); else:; r = scipy.integrate.ode(_ode_super_func_td_with_state); else:; if not opt.rhs_with_state:; r = scipy.integrate.ode(cy_ode_rho_func_td); else:; r = scipy.integrate.ode(_ode_rho_func_td_with_state); r.set_integrator('zvode', method=opt.method, order=opt.order,; atol=opt.atol, rtol=opt.rtol, nsteps=opt.nsteps,; first_step=opt.first_step, min_step=opt.min_step,; max_step=opt.max_step); r.set_initial_value(initial_vector, tlist[0]); r.set_f_params(L_data, L_func, new_args). #; # call generic ODE code; #; return _generic_ode_solve(r, rho0, tlist, e_ops, opt, progress_bar). #; # evaluate drho(t)/dt according to the master equation; #; def _ode_rho_func_td(t, rho, L0, L_func, args):; L = L0 + L_func(t, args).data; return L * rho. #; # evaluate drho(t)/dt according to the master equation; #; def _ode_rho_func_td_with_state(t, rho, L0, L_func, args):; L = L0 + L_func(t, rho, args).data; return L * rho. #; # evaluate dE(t)/dt according to the master equation, where E is a ; # superoperator; #; def _ode_super_func_td(t, y, L0, L_func, args):; L = L0 + L_func(t, args).data; return _ode_super_func(t, y, L). #; # evaluate dE(t)/dt according to the master ",MatchSource.WIKI,docs/4.2/modules/qutip/mesolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mesolve.html
https://qutip.org/docs/4.2/modules/qutip/mesolve.html:28872,Deployability,update,update,28872,"ate the required expectation values or invoke; callback function at each time step.; """""". #; # prepare output array; #; n_tsteps = len(tlist); e_sops_data = []. output = Result(); output.solver = ""mesolve""; output.times = tlist. if opt.store_states:; output.states = []. if isinstance(e_ops, types.FunctionType):; n_expt_op = 0; expt_callback = True. elif isinstance(e_ops, list):. n_expt_op = len(e_ops); expt_callback = False. if n_expt_op == 0:; # fall back on storing states; output.states = []; opt.store_states = True; else:; output.expect = []; output.num_expect = n_expt_op; for op in e_ops:; e_sops_data.append(spre(op).data); if op.isherm and rho0.isherm:; output.expect.append(np.zeros(n_tsteps)); else:; output.expect.append(np.zeros(n_tsteps, dtype=complex)). else:; raise TypeError(""Expectation parameter must be a list or a function""). #; # start evolution; #; progress_bar.start(n_tsteps). rho = Qobj(rho0). dt = np.diff(tlist); for t_idx, t in enumerate(tlist):; progress_bar.update(t_idx). if not r.successful():; raise Exception(""ODE integration error: Try to increase ""; ""the allowed number of substeps by increasing ""; ""the nsteps parameter in the Options class.""). if opt.store_states or expt_callback:; rho.data = dense2D_to_fastcsr_fmode(vec2mat(r.y), rho.shape[0], rho.shape[1]). if opt.store_states:; output.states.append(Qobj(rho, isherm=True)). if expt_callback:; # use callback method; e_ops(t, rho). for m in range(n_expt_op):; if output.expect[m].dtype == complex:; output.expect[m][t_idx] = expect_rho_vec(e_sops_data[m],; r.y, 0); else:; output.expect[m][t_idx] = expect_rho_vec(e_sops_data[m],; r.y, 1). if t_idx < n_tsteps - 1:; r.integrate(r.t + dt[t_idx]). progress_bar.finished(). if (not opt.rhs_reuse) and (config.tdname is not None):; _cython_build_cleanup(config.tdname). if opt.store_final_state:; rho.data = dense2D_to_fastcsr_fmode(vec2mat(r.y), rho.shape[0], rho.shape[1]); output.final_state = Qobj(rho, dims=rho0.dims, isherm=True). return output. # --",MatchSource.WIKI,docs/4.2/modules/qutip/mesolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mesolve.html
https://qutip.org/docs/4.2/modules/qutip/mesolve.html:28932,Deployability,integrat,integration,28932,"re output array; #; n_tsteps = len(tlist); e_sops_data = []. output = Result(); output.solver = ""mesolve""; output.times = tlist. if opt.store_states:; output.states = []. if isinstance(e_ops, types.FunctionType):; n_expt_op = 0; expt_callback = True. elif isinstance(e_ops, list):. n_expt_op = len(e_ops); expt_callback = False. if n_expt_op == 0:; # fall back on storing states; output.states = []; opt.store_states = True; else:; output.expect = []; output.num_expect = n_expt_op; for op in e_ops:; e_sops_data.append(spre(op).data); if op.isherm and rho0.isherm:; output.expect.append(np.zeros(n_tsteps)); else:; output.expect.append(np.zeros(n_tsteps, dtype=complex)). else:; raise TypeError(""Expectation parameter must be a list or a function""). #; # start evolution; #; progress_bar.start(n_tsteps). rho = Qobj(rho0). dt = np.diff(tlist); for t_idx, t in enumerate(tlist):; progress_bar.update(t_idx). if not r.successful():; raise Exception(""ODE integration error: Try to increase ""; ""the allowed number of substeps by increasing ""; ""the nsteps parameter in the Options class.""). if opt.store_states or expt_callback:; rho.data = dense2D_to_fastcsr_fmode(vec2mat(r.y), rho.shape[0], rho.shape[1]). if opt.store_states:; output.states.append(Qobj(rho, isherm=True)). if expt_callback:; # use callback method; e_ops(t, rho). for m in range(n_expt_op):; if output.expect[m].dtype == complex:; output.expect[m][t_idx] = expect_rho_vec(e_sops_data[m],; r.y, 0); else:; output.expect[m][t_idx] = expect_rho_vec(e_sops_data[m],; r.y, 1). if t_idx < n_tsteps - 1:; r.integrate(r.t + dt[t_idx]). progress_bar.finished(). if (not opt.rhs_reuse) and (config.tdname is not None):; _cython_build_cleanup(config.tdname). if opt.store_final_state:; rho.data = dense2D_to_fastcsr_fmode(vec2mat(r.y), rho.shape[0], rho.shape[1]); output.final_state = Qobj(rho, dims=rho0.dims, isherm=True). return output. # -----------------------------------------------------------------------------; # Old style API below.;",MatchSource.WIKI,docs/4.2/modules/qutip/mesolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mesolve.html
https://qutip.org/docs/4.2/modules/qutip/mesolve.html:29545,Deployability,integrat,integrate,29545,"t.expect.append(np.zeros(n_tsteps)); else:; output.expect.append(np.zeros(n_tsteps, dtype=complex)). else:; raise TypeError(""Expectation parameter must be a list or a function""). #; # start evolution; #; progress_bar.start(n_tsteps). rho = Qobj(rho0). dt = np.diff(tlist); for t_idx, t in enumerate(tlist):; progress_bar.update(t_idx). if not r.successful():; raise Exception(""ODE integration error: Try to increase ""; ""the allowed number of substeps by increasing ""; ""the nsteps parameter in the Options class.""). if opt.store_states or expt_callback:; rho.data = dense2D_to_fastcsr_fmode(vec2mat(r.y), rho.shape[0], rho.shape[1]). if opt.store_states:; output.states.append(Qobj(rho, isherm=True)). if expt_callback:; # use callback method; e_ops(t, rho). for m in range(n_expt_op):; if output.expect[m].dtype == complex:; output.expect[m][t_idx] = expect_rho_vec(e_sops_data[m],; r.y, 0); else:; output.expect[m][t_idx] = expect_rho_vec(e_sops_data[m],; r.y, 1). if t_idx < n_tsteps - 1:; r.integrate(r.t + dt[t_idx]). progress_bar.finished(). if (not opt.rhs_reuse) and (config.tdname is not None):; _cython_build_cleanup(config.tdname). if opt.store_final_state:; rho.data = dense2D_to_fastcsr_fmode(vec2mat(r.y), rho.shape[0], rho.shape[1]); output.final_state = Qobj(rho, dims=rho0.dims, isherm=True). return output. # -----------------------------------------------------------------------------; # Old style API below.; # -----------------------------------------------------------------------------. # -----------------------------------------------------------------------------; # Master equation solver: deprecated in 2.0.0. No support for time-dependent; # collapse operators. Only used by the deprecated odesolve function.; #; def _mesolve_list_td(H_func, rho0, tlist, c_op_list, e_ops, args, opt,; progress_bar):; """"""; Evolve the density matrix using an ODE solver with time dependent; Hamiltonian.; """""". if debug:; print(inspect.stack()[0][3]). #; # check initial state; #; if isket(",MatchSource.WIKI,docs/4.2/modules/qutip/mesolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mesolve.html
https://qutip.org/docs/4.2/modules/qutip/mesolve.html:32658,Deployability,integrat,integrator,32658,"(liouvillian(H_func[0][m], [])). # create data arrays for time-dependent RHS function; Ldata = [L_func[0][k].data.data for k in range(lenh)]; Linds = [L_func[0][k].data.indices for k in range(lenh)]; Lptrs = [L_func[0][k].data.indptr for k in range(lenh)]; # setup ode args string; string = """"; for k in range(lenh):; string += (""Ldata[%d], Linds[%d], Lptrs[%d],"" % (k, k, k)). if args:; td_consts = args.items(); for elem in td_consts:; string += str(elem[1]); if elem != td_consts[-1]:; string += ("",""). # run code generator; if not opt.rhs_reuse or config.tdfunc is None:; if opt.rhs_filename is None:; config.tdname = ""rhs"" + str(os.getpid()) + str(config.cgen_num); else:; config.tdname = opt.rhs_filename; cgen = Codegen(h_terms=n_L_terms, h_tdterms=Lcoeff, args=args,; config=config); cgen.generate(config.tdname + "".pyx""). code = compile('from ' + config.tdname + ' import cy_td_ode_rhs',; '<string>', 'exec'); exec(code, globals()); config.tdfunc = cy_td_ode_rhs. #; # setup integrator; #; initial_vector = mat2vec(rho0.full()).ravel(); r = scipy.integrate.ode(config.tdfunc); r.set_integrator('zvode', method=opt.method, order=opt.order,; atol=opt.atol, rtol=opt.rtol, nsteps=opt.nsteps,; first_step=opt.first_step, min_step=opt.min_step,; max_step=opt.max_step); r.set_initial_value(initial_vector, tlist[0]); code = compile('r.set_f_params(' + string + ')', '<string>', 'exec'); exec(code). #; # call generic ODE code; #; return _generic_ode_solve(r, rho0, tlist, e_ops, opt, progress_bar). # -----------------------------------------------------------------------------; # pass on to wavefunction solver or master equation solver depending on whether; # any collapse operators were given.; #; def odesolve(H, rho0, tlist, c_op_list, e_ops, args=None, options=None):; """"""; Master equation evolution of a density matrix for a given Hamiltonian. Evolution of a state vector or density matrix (`rho0`) for a given; Hamiltonian (`H`) and set of collapse operators (`c_op_list`), by; integratin",MatchSource.WIKI,docs/4.2/modules/qutip/mesolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mesolve.html
https://qutip.org/docs/4.2/modules/qutip/mesolve.html:32730,Deployability,integrat,integrate,32730,"e-dependent RHS function; Ldata = [L_func[0][k].data.data for k in range(lenh)]; Linds = [L_func[0][k].data.indices for k in range(lenh)]; Lptrs = [L_func[0][k].data.indptr for k in range(lenh)]; # setup ode args string; string = """"; for k in range(lenh):; string += (""Ldata[%d], Linds[%d], Lptrs[%d],"" % (k, k, k)). if args:; td_consts = args.items(); for elem in td_consts:; string += str(elem[1]); if elem != td_consts[-1]:; string += ("",""). # run code generator; if not opt.rhs_reuse or config.tdfunc is None:; if opt.rhs_filename is None:; config.tdname = ""rhs"" + str(os.getpid()) + str(config.cgen_num); else:; config.tdname = opt.rhs_filename; cgen = Codegen(h_terms=n_L_terms, h_tdterms=Lcoeff, args=args,; config=config); cgen.generate(config.tdname + "".pyx""). code = compile('from ' + config.tdname + ' import cy_td_ode_rhs',; '<string>', 'exec'); exec(code, globals()); config.tdfunc = cy_td_ode_rhs. #; # setup integrator; #; initial_vector = mat2vec(rho0.full()).ravel(); r = scipy.integrate.ode(config.tdfunc); r.set_integrator('zvode', method=opt.method, order=opt.order,; atol=opt.atol, rtol=opt.rtol, nsteps=opt.nsteps,; first_step=opt.first_step, min_step=opt.min_step,; max_step=opt.max_step); r.set_initial_value(initial_vector, tlist[0]); code = compile('r.set_f_params(' + string + ')', '<string>', 'exec'); exec(code). #; # call generic ODE code; #; return _generic_ode_solve(r, rho0, tlist, e_ops, opt, progress_bar). # -----------------------------------------------------------------------------; # pass on to wavefunction solver or master equation solver depending on whether; # any collapse operators were given.; #; def odesolve(H, rho0, tlist, c_op_list, e_ops, args=None, options=None):; """"""; Master equation evolution of a density matrix for a given Hamiltonian. Evolution of a state vector or density matrix (`rho0`) for a given; Hamiltonian (`H`) and set of collapse operators (`c_op_list`), by; integrating the set of ordinary differential equations that define the",MatchSource.WIKI,docs/4.2/modules/qutip/mesolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mesolve.html
https://qutip.org/docs/4.2/modules/qutip/mesolve.html:33665,Deployability,integrat,integrating,33665,"d_ode_rhs. #; # setup integrator; #; initial_vector = mat2vec(rho0.full()).ravel(); r = scipy.integrate.ode(config.tdfunc); r.set_integrator('zvode', method=opt.method, order=opt.order,; atol=opt.atol, rtol=opt.rtol, nsteps=opt.nsteps,; first_step=opt.first_step, min_step=opt.min_step,; max_step=opt.max_step); r.set_initial_value(initial_vector, tlist[0]); code = compile('r.set_f_params(' + string + ')', '<string>', 'exec'); exec(code). #; # call generic ODE code; #; return _generic_ode_solve(r, rho0, tlist, e_ops, opt, progress_bar). # -----------------------------------------------------------------------------; # pass on to wavefunction solver or master equation solver depending on whether; # any collapse operators were given.; #; def odesolve(H, rho0, tlist, c_op_list, e_ops, args=None, options=None):; """"""; Master equation evolution of a density matrix for a given Hamiltonian. Evolution of a state vector or density matrix (`rho0`) for a given; Hamiltonian (`H`) and set of collapse operators (`c_op_list`), by; integrating the set of ordinary differential equations that define the; system. The output is either the state vector at arbitrary points in time; (`tlist`), or the expectation values of the supplied operators; (`e_ops`). For problems with time-dependent Hamiltonians, `H` can be a callback; function that takes two arguments, time and `args`, and returns the; Hamiltonian at that point in time. `args` is a list of parameters that is; passed to the callback function `H` (only used for time-dependent; Hamiltonians). Parameters; ----------. H : :class:`qutip.qobj`; system Hamiltonian, or a callback function for time-dependent; Hamiltonians. rho0 : :class:`qutip.qobj`; initial density matrix or state vector (ket). tlist : *list* / *array*; list of times for :math:`t`. c_op_list : list of :class:`qutip.qobj`; list of collapse operators. e_ops : list of :class:`qutip.qobj` / callback function; list of operators for which to evaluate expectation values. args : *dicti",MatchSource.WIKI,docs/4.2/modules/qutip/mesolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mesolve.html
https://qutip.org/docs/4.2/modules/qutip/mesolve.html:35065,Deployability,integrat,integrator,35065,"that point in time. `args` is a list of parameters that is; passed to the callback function `H` (only used for time-dependent; Hamiltonians). Parameters; ----------. H : :class:`qutip.qobj`; system Hamiltonian, or a callback function for time-dependent; Hamiltonians. rho0 : :class:`qutip.qobj`; initial density matrix or state vector (ket). tlist : *list* / *array*; list of times for :math:`t`. c_op_list : list of :class:`qutip.qobj`; list of collapse operators. e_ops : list of :class:`qutip.qobj` / callback function; list of operators for which to evaluate expectation values. args : *dictionary*; dictionary of parameters for time-dependent Hamiltonians and; collapse operators. options : :class:`qutip.Options`; with options for the ODE solver. Returns; -------; output :array; Expectation values of wavefunctions/density matrices; for the times specified by `tlist`. Notes; -----; On using callback function: odesolve transforms all :class:`qutip.qobj`; objects to sparse matrices before handing the problem to the integrator; function. In order for your callback function to work correctly, pass; all :class:`qutip.qobj` objects that are used in constructing the; Hamiltonian via args. odesolve will check for :class:`qutip.qobj` in; `args` and handle the conversion to sparse matrices. All other; :class:`qutip.qobj` objects that are not passed via `args` will be; passed on to the integrator to scipy who will raise an NotImplemented; exception. Deprecated in QuTiP 2.0.0. Use :func:`mesolve` instead. """""". warnings.warn(""odesolve is deprecated since 2.0.0. Use mesolve instead."",; DeprecationWarning). if debug:; print(inspect.stack()[0][3]). if options is None:; options = Options(). if (c_op_list and len(c_op_list) > 0) or not isket(rho0):; if isinstance(H, list):; output = _mesolve_list_td(H, rho0, tlist,; c_op_list, e_ops, args, options,; BaseProgressBar()); if isinstance(H, (types.FunctionType,; types.BuiltinFunctionType, partial)):; output = _mesolve_func_td(H, rho0, tlist,; c",MatchSource.WIKI,docs/4.2/modules/qutip/mesolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mesolve.html
https://qutip.org/docs/4.2/modules/qutip/mesolve.html:35434,Deployability,integrat,integrator,35434,"th:`t`. c_op_list : list of :class:`qutip.qobj`; list of collapse operators. e_ops : list of :class:`qutip.qobj` / callback function; list of operators for which to evaluate expectation values. args : *dictionary*; dictionary of parameters for time-dependent Hamiltonians and; collapse operators. options : :class:`qutip.Options`; with options for the ODE solver. Returns; -------; output :array; Expectation values of wavefunctions/density matrices; for the times specified by `tlist`. Notes; -----; On using callback function: odesolve transforms all :class:`qutip.qobj`; objects to sparse matrices before handing the problem to the integrator; function. In order for your callback function to work correctly, pass; all :class:`qutip.qobj` objects that are used in constructing the; Hamiltonian via args. odesolve will check for :class:`qutip.qobj` in; `args` and handle the conversion to sparse matrices. All other; :class:`qutip.qobj` objects that are not passed via `args` will be; passed on to the integrator to scipy who will raise an NotImplemented; exception. Deprecated in QuTiP 2.0.0. Use :func:`mesolve` instead. """""". warnings.warn(""odesolve is deprecated since 2.0.0. Use mesolve instead."",; DeprecationWarning). if debug:; print(inspect.stack()[0][3]). if options is None:; options = Options(). if (c_op_list and len(c_op_list) > 0) or not isket(rho0):; if isinstance(H, list):; output = _mesolve_list_td(H, rho0, tlist,; c_op_list, e_ops, args, options,; BaseProgressBar()); if isinstance(H, (types.FunctionType,; types.BuiltinFunctionType, partial)):; output = _mesolve_func_td(H, rho0, tlist,; c_op_list, e_ops, args, options,; BaseProgressBar()); else:; output = _mesolve_const(H, rho0, tlist,; c_op_list, e_ops, args, options,; BaseProgressBar()); else:; if isinstance(H, list):; output = _sesolve_list_td(H, rho0, tlist, e_ops, args, options,; BaseProgressBar()); if isinstance(H, (types.FunctionType,; types.BuiltinFunctionType, partial)):; output = _sesolve_func_td(H, rho0, tlis",MatchSource.WIKI,docs/4.2/modules/qutip/mesolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mesolve.html
https://qutip.org/docs/4.2/modules/qutip/mesolve.html:36749,Deployability,update,updated,36749,"n values of wavefunctions/density matrices; for the times specified by `tlist`. Notes; -----; On using callback function: odesolve transforms all :class:`qutip.qobj`; objects to sparse matrices before handing the problem to the integrator; function. In order for your callback function to work correctly, pass; all :class:`qutip.qobj` objects that are used in constructing the; Hamiltonian via args. odesolve will check for :class:`qutip.qobj` in; `args` and handle the conversion to sparse matrices. All other; :class:`qutip.qobj` objects that are not passed via `args` will be; passed on to the integrator to scipy who will raise an NotImplemented; exception. Deprecated in QuTiP 2.0.0. Use :func:`mesolve` instead. """""". warnings.warn(""odesolve is deprecated since 2.0.0. Use mesolve instead."",; DeprecationWarning). if debug:; print(inspect.stack()[0][3]). if options is None:; options = Options(). if (c_op_list and len(c_op_list) > 0) or not isket(rho0):; if isinstance(H, list):; output = _mesolve_list_td(H, rho0, tlist,; c_op_list, e_ops, args, options,; BaseProgressBar()); if isinstance(H, (types.FunctionType,; types.BuiltinFunctionType, partial)):; output = _mesolve_func_td(H, rho0, tlist,; c_op_list, e_ops, args, options,; BaseProgressBar()); else:; output = _mesolve_const(H, rho0, tlist,; c_op_list, e_ops, args, options,; BaseProgressBar()); else:; if isinstance(H, list):; output = _sesolve_list_td(H, rho0, tlist, e_ops, args, options,; BaseProgressBar()); if isinstance(H, (types.FunctionType,; types.BuiltinFunctionType, partial)):; output = _sesolve_func_td(H, rho0, tlist, e_ops, args, options,; BaseProgressBar()); else:; output = _sesolve_const(H, rho0, tlist, e_ops, args, options,; BaseProgressBar()). if len(e_ops) > 0:; return output.expect; else:; return output.states.  Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, and A.L. Grimsmo.; Last updated on Jan 17, 2018. . Built with Sphinx using a theme provided by Read the Docs. . ",MatchSource.WIKI,docs/4.2/modules/qutip/mesolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mesolve.html
https://qutip.org/docs/4.2/modules/qutip/mesolve.html:2303,Integrability,integrat,integrate,2303," LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A; # PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT; # HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,; # SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT; # LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,; # DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY; # THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT; # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE; # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.; ###############################################################################; """"""; This module provides solvers for the Lindblad master equation and von Neumann; equation.; """""". __all__ = ['mesolve', 'odesolve']. import os; import types; from functools import partial; import numpy as np; import scipy.sparse as sp; import scipy.integrate; import warnings; import qutip.settings as qset; from qutip.qobj import Qobj, isket, isoper, issuper; from qutip.superoperator import spre, spost, liouvillian, mat2vec, vec2mat; from qutip.expect import expect_rho_vec; from qutip.solver import Options, Result, config, _solver_safety_check; from qutip.cy.spmatfuncs import cy_ode_rhs, cy_ode_rho_func_td, spmvpy_csr; from qutip.cy.spconvert import dense2D_to_fastcsr_fmode; from qutip.cy.codegen import Codegen; from qutip.cy.utilities import _cython_build_cleanup; from qutip.rhs_generate import rhs_generate; from qutip.states import ket2dm; from qutip.rhs_generate import _td_format_check, _td_wrap_array_str; from qutip.interpolate import Cubic_Spline; from qutip.settings import debug. from qutip.sesolve import (_sesolve_list_func_td, _sesolve_list_str_td,; _sesolve_list_td, _sesolve_func_td, _sesolve_const). from qutip.ui.progressbar import BaseProgressBar, TextProgressBar. from qutip.cy.openmp.utilities import check_use_openmp, openmp_components; if",MatchSource.WIKI,docs/4.2/modules/qutip/mesolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mesolve.html
https://qutip.org/docs/4.2/modules/qutip/mesolve.html:3566,Integrability,depend,depending,3566,"ho_vec; from qutip.solver import Options, Result, config, _solver_safety_check; from qutip.cy.spmatfuncs import cy_ode_rhs, cy_ode_rho_func_td, spmvpy_csr; from qutip.cy.spconvert import dense2D_to_fastcsr_fmode; from qutip.cy.codegen import Codegen; from qutip.cy.utilities import _cython_build_cleanup; from qutip.rhs_generate import rhs_generate; from qutip.states import ket2dm; from qutip.rhs_generate import _td_format_check, _td_wrap_array_str; from qutip.interpolate import Cubic_Spline; from qutip.settings import debug. from qutip.sesolve import (_sesolve_list_func_td, _sesolve_list_str_td,; _sesolve_list_td, _sesolve_func_td, _sesolve_const). from qutip.ui.progressbar import BaseProgressBar, TextProgressBar. from qutip.cy.openmp.utilities import check_use_openmp, openmp_components; if qset.has_openmp:; from qutip.cy.openmp.parfuncs import cy_ode_rhs_openmp. if debug:; import inspect. # -----------------------------------------------------------------------------; # pass on to wavefunction solver or master equation solver depending on whether; # any collapse operators were given.; #; [docs]def mesolve(H, rho0, tlist, c_ops=[], e_ops=[], args={}, options=None,; progress_bar=None, _safe_mode=True):; """"""; Master equation evolution of a density matrix for a given Hamiltonian and; set of collapse operators, or a Liouvillian. Evolve the state vector or density matrix (`rho0`) using a given; Hamiltonian (`H`) and an [optional] set of collapse operators; (`c_ops`), by integrating the set of ordinary differential equations; that define the system. In the absence of collapse operators the system is; evolved according to the unitary evolution of the Hamiltonian. The output is either the state vector at arbitrary points in time; (`tlist`), or the expectation values of the supplied operators; (`e_ops`). If e_ops is a callback function, it is invoked for each; time in `tlist` with time and the state as arguments, and the function; does not use any return values. If either `H` ",MatchSource.WIKI,docs/4.2/modules/qutip/mesolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mesolve.html
https://qutip.org/docs/4.2/modules/qutip/mesolve.html:4013,Integrability,integrat,integrating,4013," qutip.interpolate import Cubic_Spline; from qutip.settings import debug. from qutip.sesolve import (_sesolve_list_func_td, _sesolve_list_str_td,; _sesolve_list_td, _sesolve_func_td, _sesolve_const). from qutip.ui.progressbar import BaseProgressBar, TextProgressBar. from qutip.cy.openmp.utilities import check_use_openmp, openmp_components; if qset.has_openmp:; from qutip.cy.openmp.parfuncs import cy_ode_rhs_openmp. if debug:; import inspect. # -----------------------------------------------------------------------------; # pass on to wavefunction solver or master equation solver depending on whether; # any collapse operators were given.; #; [docs]def mesolve(H, rho0, tlist, c_ops=[], e_ops=[], args={}, options=None,; progress_bar=None, _safe_mode=True):; """"""; Master equation evolution of a density matrix for a given Hamiltonian and; set of collapse operators, or a Liouvillian. Evolve the state vector or density matrix (`rho0`) using a given; Hamiltonian (`H`) and an [optional] set of collapse operators; (`c_ops`), by integrating the set of ordinary differential equations; that define the system. In the absence of collapse operators the system is; evolved according to the unitary evolution of the Hamiltonian. The output is either the state vector at arbitrary points in time; (`tlist`), or the expectation values of the supplied operators; (`e_ops`). If e_ops is a callback function, it is invoked for each; time in `tlist` with time and the state as arguments, and the function; does not use any return values. If either `H` or the Qobj elements in `c_ops` are superoperators, they; will be treated as direct contributions to the total system Liouvillian.; This allows to solve master equations that are not on standard Lindblad; form by passing a custom Liouvillian in place of either the `H` or `c_ops`; elements. **Time-dependent operators**. For time-dependent problems, `H` and `c_ops` can be callback; functions that takes two arguments, time and `args`, and returns the; Ham",MatchSource.WIKI,docs/4.2/modules/qutip/mesolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mesolve.html
https://qutip.org/docs/4.2/modules/qutip/mesolve.html:4823,Integrability,depend,dependent,4823,"f collapse operators, or a Liouvillian. Evolve the state vector or density matrix (`rho0`) using a given; Hamiltonian (`H`) and an [optional] set of collapse operators; (`c_ops`), by integrating the set of ordinary differential equations; that define the system. In the absence of collapse operators the system is; evolved according to the unitary evolution of the Hamiltonian. The output is either the state vector at arbitrary points in time; (`tlist`), or the expectation values of the supplied operators; (`e_ops`). If e_ops is a callback function, it is invoked for each; time in `tlist` with time and the state as arguments, and the function; does not use any return values. If either `H` or the Qobj elements in `c_ops` are superoperators, they; will be treated as direct contributions to the total system Liouvillian.; This allows to solve master equations that are not on standard Lindblad; form by passing a custom Liouvillian in place of either the `H` or `c_ops`; elements. **Time-dependent operators**. For time-dependent problems, `H` and `c_ops` can be callback; functions that takes two arguments, time and `args`, and returns the; Hamiltonian or Liouvillian for the system at that point in time; (*callback format*). Alternatively, `H` and `c_ops` can be a specified in a nested-list format; where each element in the list is a list of length 2, containing an; operator (:class:`qutip.qobj`) at the first element and where the; second element is either a string (*list string format*), a callback; function (*list callback format*) that evaluates to the time-dependent; coefficient for the corresponding operator, or a NumPy array (*list; array format*) which specifies the value of the coefficient to the; corresponding operator for each value of t in tlist. *Examples*. H = [[H0, 'sin(w*t)'], [H1, 'sin(2*w*t)']]. H = [[H0, f0_t], [H1, f1_t]]. where f0_t and f1_t are python functions with signature f_t(t, args). H = [[H0, np.sin(w*tlist)], [H1, np.sin(2*w*tlist)]]. In the *list ",MatchSource.WIKI,docs/4.2/modules/qutip/mesolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mesolve.html
https://qutip.org/docs/4.2/modules/qutip/mesolve.html:4855,Integrability,depend,dependent,4855,"and an [optional] set of collapse operators; (`c_ops`), by integrating the set of ordinary differential equations; that define the system. In the absence of collapse operators the system is; evolved according to the unitary evolution of the Hamiltonian. The output is either the state vector at arbitrary points in time; (`tlist`), or the expectation values of the supplied operators; (`e_ops`). If e_ops is a callback function, it is invoked for each; time in `tlist` with time and the state as arguments, and the function; does not use any return values. If either `H` or the Qobj elements in `c_ops` are superoperators, they; will be treated as direct contributions to the total system Liouvillian.; This allows to solve master equations that are not on standard Lindblad; form by passing a custom Liouvillian in place of either the `H` or `c_ops`; elements. **Time-dependent operators**. For time-dependent problems, `H` and `c_ops` can be callback; functions that takes two arguments, time and `args`, and returns the; Hamiltonian or Liouvillian for the system at that point in time; (*callback format*). Alternatively, `H` and `c_ops` can be a specified in a nested-list format; where each element in the list is a list of length 2, containing an; operator (:class:`qutip.qobj`) at the first element and where the; second element is either a string (*list string format*), a callback; function (*list callback format*) that evaluates to the time-dependent; coefficient for the corresponding operator, or a NumPy array (*list; array format*) which specifies the value of the coefficient to the; corresponding operator for each value of t in tlist. *Examples*. H = [[H0, 'sin(w*t)'], [H1, 'sin(2*w*t)']]. H = [[H0, f0_t], [H1, f1_t]]. where f0_t and f1_t are python functions with signature f_t(t, args). H = [[H0, np.sin(w*tlist)], [H1, np.sin(2*w*tlist)]]. In the *list string format* and *list callback format*, the string; expression and the callback function must evaluate to a real or compl",MatchSource.WIKI,docs/4.2/modules/qutip/mesolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mesolve.html
https://qutip.org/docs/4.2/modules/qutip/mesolve.html:5406,Integrability,depend,dependent,5406,"st` with time and the state as arguments, and the function; does not use any return values. If either `H` or the Qobj elements in `c_ops` are superoperators, they; will be treated as direct contributions to the total system Liouvillian.; This allows to solve master equations that are not on standard Lindblad; form by passing a custom Liouvillian in place of either the `H` or `c_ops`; elements. **Time-dependent operators**. For time-dependent problems, `H` and `c_ops` can be callback; functions that takes two arguments, time and `args`, and returns the; Hamiltonian or Liouvillian for the system at that point in time; (*callback format*). Alternatively, `H` and `c_ops` can be a specified in a nested-list format; where each element in the list is a list of length 2, containing an; operator (:class:`qutip.qobj`) at the first element and where the; second element is either a string (*list string format*), a callback; function (*list callback format*) that evaluates to the time-dependent; coefficient for the corresponding operator, or a NumPy array (*list; array format*) which specifies the value of the coefficient to the; corresponding operator for each value of t in tlist. *Examples*. H = [[H0, 'sin(w*t)'], [H1, 'sin(2*w*t)']]. H = [[H0, f0_t], [H1, f1_t]]. where f0_t and f1_t are python functions with signature f_t(t, args). H = [[H0, np.sin(w*tlist)], [H1, np.sin(2*w*tlist)]]. In the *list string format* and *list callback format*, the string; expression and the callback function must evaluate to a real or complex; number (coefficient for the corresponding operator). In all cases of time-dependent operators, `args` is a dictionary of; parameters that is used when evaluating operators. It is passed to the; callback functions as second argument. **Additional options**. Additional options to mesolve can be set via the `options` argument, which; should be an instance of :class:`qutip.solver.Options`. Many ODE; integration options can be set this way, and the `store_states",MatchSource.WIKI,docs/4.2/modules/qutip/mesolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mesolve.html
https://qutip.org/docs/4.2/modules/qutip/mesolve.html:6032,Integrability,depend,dependent,6032,"atively, `H` and `c_ops` can be a specified in a nested-list format; where each element in the list is a list of length 2, containing an; operator (:class:`qutip.qobj`) at the first element and where the; second element is either a string (*list string format*), a callback; function (*list callback format*) that evaluates to the time-dependent; coefficient for the corresponding operator, or a NumPy array (*list; array format*) which specifies the value of the coefficient to the; corresponding operator for each value of t in tlist. *Examples*. H = [[H0, 'sin(w*t)'], [H1, 'sin(2*w*t)']]. H = [[H0, f0_t], [H1, f1_t]]. where f0_t and f1_t are python functions with signature f_t(t, args). H = [[H0, np.sin(w*tlist)], [H1, np.sin(2*w*tlist)]]. In the *list string format* and *list callback format*, the string; expression and the callback function must evaluate to a real or complex; number (coefficient for the corresponding operator). In all cases of time-dependent operators, `args` is a dictionary of; parameters that is used when evaluating operators. It is passed to the; callback functions as second argument. **Additional options**. Additional options to mesolve can be set via the `options` argument, which; should be an instance of :class:`qutip.solver.Options`. Many ODE; integration options can be set this way, and the `store_states` and; `store_final_state` options can be used to store states even though; expectation values are requested via the `e_ops` argument. .. note::. If an element in the list-specification of the Hamiltonian or; the list of collapse operators are in superoperator form it will be; added to the total Liouvillian of the problem with out further; transformation. This allows for using mesolve for solving master; equations that are not on standard Lindblad form. .. note::. On using callback function: mesolve transforms all :class:`qutip.qobj`; objects to sparse matrices before handing the problem to the integrator; function. In order for your callback ",MatchSource.WIKI,docs/4.2/modules/qutip/mesolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mesolve.html
https://qutip.org/docs/4.2/modules/qutip/mesolve.html:6357,Integrability,integrat,integration,6357,"g operator, or a NumPy array (*list; array format*) which specifies the value of the coefficient to the; corresponding operator for each value of t in tlist. *Examples*. H = [[H0, 'sin(w*t)'], [H1, 'sin(2*w*t)']]. H = [[H0, f0_t], [H1, f1_t]]. where f0_t and f1_t are python functions with signature f_t(t, args). H = [[H0, np.sin(w*tlist)], [H1, np.sin(2*w*tlist)]]. In the *list string format* and *list callback format*, the string; expression and the callback function must evaluate to a real or complex; number (coefficient for the corresponding operator). In all cases of time-dependent operators, `args` is a dictionary of; parameters that is used when evaluating operators. It is passed to the; callback functions as second argument. **Additional options**. Additional options to mesolve can be set via the `options` argument, which; should be an instance of :class:`qutip.solver.Options`. Many ODE; integration options can be set this way, and the `store_states` and; `store_final_state` options can be used to store states even though; expectation values are requested via the `e_ops` argument. .. note::. If an element in the list-specification of the Hamiltonian or; the list of collapse operators are in superoperator form it will be; added to the total Liouvillian of the problem with out further; transformation. This allows for using mesolve for solving master; equations that are not on standard Lindblad form. .. note::. On using callback function: mesolve transforms all :class:`qutip.qobj`; objects to sparse matrices before handing the problem to the integrator; function. In order for your callback function to work correctly, pass; all :class:`qutip.qobj` objects that are used in constructing the; Hamiltonian via args. mesolve will check for :class:`qutip.qobj` in; `args` and handle the conversion to sparse matrices. All other; :class:`qutip.qobj` objects that are not passed via `args` will be; passed on to the integrator in scipy which will raise an NotImplemented; excep",MatchSource.WIKI,docs/4.2/modules/qutip/mesolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mesolve.html
https://qutip.org/docs/4.2/modules/qutip/mesolve.html:7021,Integrability,integrat,integrator,7021,"ng operator). In all cases of time-dependent operators, `args` is a dictionary of; parameters that is used when evaluating operators. It is passed to the; callback functions as second argument. **Additional options**. Additional options to mesolve can be set via the `options` argument, which; should be an instance of :class:`qutip.solver.Options`. Many ODE; integration options can be set this way, and the `store_states` and; `store_final_state` options can be used to store states even though; expectation values are requested via the `e_ops` argument. .. note::. If an element in the list-specification of the Hamiltonian or; the list of collapse operators are in superoperator form it will be; added to the total Liouvillian of the problem with out further; transformation. This allows for using mesolve for solving master; equations that are not on standard Lindblad form. .. note::. On using callback function: mesolve transforms all :class:`qutip.qobj`; objects to sparse matrices before handing the problem to the integrator; function. In order for your callback function to work correctly, pass; all :class:`qutip.qobj` objects that are used in constructing the; Hamiltonian via args. mesolve will check for :class:`qutip.qobj` in; `args` and handle the conversion to sparse matrices. All other; :class:`qutip.qobj` objects that are not passed via `args` will be; passed on to the integrator in scipy which will raise an NotImplemented; exception. Parameters; ----------. H : :class:`qutip.Qobj`; System Hamiltonian, or a callback function for time-dependent; Hamiltonians, or alternatively a system Liouvillian. rho0 : :class:`qutip.Qobj`; initial density matrix or state vector (ket). tlist : *list* / *array*; list of times for :math:`t`. c_ops : list of :class:`qutip.Qobj`; single collapse operator, or list of collapse operators, or a list; of Liouvillian superoperators. e_ops : list of :class:`qutip.Qobj` / callback function single; single operator or list of operators for which t",MatchSource.WIKI,docs/4.2/modules/qutip/mesolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mesolve.html
https://qutip.org/docs/4.2/modules/qutip/mesolve.html:7389,Integrability,integrat,integrator,7389,"t this way, and the `store_states` and; `store_final_state` options can be used to store states even though; expectation values are requested via the `e_ops` argument. .. note::. If an element in the list-specification of the Hamiltonian or; the list of collapse operators are in superoperator form it will be; added to the total Liouvillian of the problem with out further; transformation. This allows for using mesolve for solving master; equations that are not on standard Lindblad form. .. note::. On using callback function: mesolve transforms all :class:`qutip.qobj`; objects to sparse matrices before handing the problem to the integrator; function. In order for your callback function to work correctly, pass; all :class:`qutip.qobj` objects that are used in constructing the; Hamiltonian via args. mesolve will check for :class:`qutip.qobj` in; `args` and handle the conversion to sparse matrices. All other; :class:`qutip.qobj` objects that are not passed via `args` will be; passed on to the integrator in scipy which will raise an NotImplemented; exception. Parameters; ----------. H : :class:`qutip.Qobj`; System Hamiltonian, or a callback function for time-dependent; Hamiltonians, or alternatively a system Liouvillian. rho0 : :class:`qutip.Qobj`; initial density matrix or state vector (ket). tlist : *list* / *array*; list of times for :math:`t`. c_ops : list of :class:`qutip.Qobj`; single collapse operator, or list of collapse operators, or a list; of Liouvillian superoperators. e_ops : list of :class:`qutip.Qobj` / callback function single; single operator or list of operators for which to evaluate; expectation values. args : *dictionary*; dictionary of parameters for time-dependent Hamiltonians and; collapse operators. options : :class:`qutip.Options`; with options for the solver. progress_bar : BaseProgressBar; Optional instance of BaseProgressBar, or a subclass thereof, for; showing the progress of the simulation. Returns; -------; result: :class:`qutip.Result`. An i",MatchSource.WIKI,docs/4.2/modules/qutip/mesolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mesolve.html
https://qutip.org/docs/4.2/modules/qutip/mesolve.html:7557,Integrability,depend,dependent,7557,"te::. If an element in the list-specification of the Hamiltonian or; the list of collapse operators are in superoperator form it will be; added to the total Liouvillian of the problem with out further; transformation. This allows for using mesolve for solving master; equations that are not on standard Lindblad form. .. note::. On using callback function: mesolve transforms all :class:`qutip.qobj`; objects to sparse matrices before handing the problem to the integrator; function. In order for your callback function to work correctly, pass; all :class:`qutip.qobj` objects that are used in constructing the; Hamiltonian via args. mesolve will check for :class:`qutip.qobj` in; `args` and handle the conversion to sparse matrices. All other; :class:`qutip.qobj` objects that are not passed via `args` will be; passed on to the integrator in scipy which will raise an NotImplemented; exception. Parameters; ----------. H : :class:`qutip.Qobj`; System Hamiltonian, or a callback function for time-dependent; Hamiltonians, or alternatively a system Liouvillian. rho0 : :class:`qutip.Qobj`; initial density matrix or state vector (ket). tlist : *list* / *array*; list of times for :math:`t`. c_ops : list of :class:`qutip.Qobj`; single collapse operator, or list of collapse operators, or a list; of Liouvillian superoperators. e_ops : list of :class:`qutip.Qobj` / callback function single; single operator or list of operators for which to evaluate; expectation values. args : *dictionary*; dictionary of parameters for time-dependent Hamiltonians and; collapse operators. options : :class:`qutip.Options`; with options for the solver. progress_bar : BaseProgressBar; Optional instance of BaseProgressBar, or a subclass thereof, for; showing the progress of the simulation. Returns; -------; result: :class:`qutip.Result`. An instance of the class :class:`qutip.Result`, which contains; either an *array* `result.expect` of expectation values for the times; specified by `tlist`, or an *array* `resu",MatchSource.WIKI,docs/4.2/modules/qutip/mesolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mesolve.html
https://qutip.org/docs/4.2/modules/qutip/mesolve.html:8085,Integrability,depend,dependent,8085,"o work correctly, pass; all :class:`qutip.qobj` objects that are used in constructing the; Hamiltonian via args. mesolve will check for :class:`qutip.qobj` in; `args` and handle the conversion to sparse matrices. All other; :class:`qutip.qobj` objects that are not passed via `args` will be; passed on to the integrator in scipy which will raise an NotImplemented; exception. Parameters; ----------. H : :class:`qutip.Qobj`; System Hamiltonian, or a callback function for time-dependent; Hamiltonians, or alternatively a system Liouvillian. rho0 : :class:`qutip.Qobj`; initial density matrix or state vector (ket). tlist : *list* / *array*; list of times for :math:`t`. c_ops : list of :class:`qutip.Qobj`; single collapse operator, or list of collapse operators, or a list; of Liouvillian superoperators. e_ops : list of :class:`qutip.Qobj` / callback function single; single operator or list of operators for which to evaluate; expectation values. args : *dictionary*; dictionary of parameters for time-dependent Hamiltonians and; collapse operators. options : :class:`qutip.Options`; with options for the solver. progress_bar : BaseProgressBar; Optional instance of BaseProgressBar, or a subclass thereof, for; showing the progress of the simulation. Returns; -------; result: :class:`qutip.Result`. An instance of the class :class:`qutip.Result`, which contains; either an *array* `result.expect` of expectation values for the times; specified by `tlist`, or an *array* `result.states` of state vectors or; density matrices corresponding to the times in `tlist` [if `e_ops` is; an empty list], or nothing if a callback function was given in place of; operators for which to calculate the expectation values. """"""; # check whether c_ops or e_ops is is a single operator; # if so convert it to a list containing only that operator; if isinstance(c_ops, Qobj):; c_ops = [c_ops]. if isinstance(e_ops, Qobj):; e_ops = [e_ops]. if isinstance(e_ops, dict):; e_ops_dict = e_ops; e_ops = [e for e in e_ops.v",MatchSource.WIKI,docs/4.2/modules/qutip/mesolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mesolve.html
https://qutip.org/docs/4.2/modules/qutip/mesolve.html:9574,Integrability,depend,dependence,9574,"ces corresponding to the times in `tlist` [if `e_ops` is; an empty list], or nothing if a callback function was given in place of; operators for which to calculate the expectation values. """"""; # check whether c_ops or e_ops is is a single operator; # if so convert it to a list containing only that operator; if isinstance(c_ops, Qobj):; c_ops = [c_ops]. if isinstance(e_ops, Qobj):; e_ops = [e_ops]. if isinstance(e_ops, dict):; e_ops_dict = e_ops; e_ops = [e for e in e_ops.values()]; else:; e_ops_dict = None; ; if _safe_mode:; _solver_safety_check(H, rho0, c_ops, e_ops, args); ; if progress_bar is None:; progress_bar = BaseProgressBar(); elif progress_bar is True:; progress_bar = TextProgressBar(). # check if rho0 is a superoperator, in which case e_ops argument should; # be empty, i.e., e_ops = []; if issuper(rho0) and not e_ops == []:; raise TypeError(""Must have e_ops = [] when initial condition rho0 is"" +; "" a superoperator.""). # convert array based time-dependence to string format; H, c_ops, args = _td_wrap_array_str(H, c_ops, args, tlist). # check for type (if any) of time-dependent inputs; _, n_func, n_str = _td_format_check(H, c_ops). if options is None:; options = Options(). if (not options.rhs_reuse) or (not config.tdfunc):; # reset config collapse and time-dependence flags to default values; config.reset(); ; #check if should use OPENMP; check_use_openmp(options); ; ; res = None. #; # dispatch the appropriate solver; #; if ((c_ops and len(c_ops) > 0); or (not isket(rho0)); or (isinstance(H, Qobj) and issuper(H)); or (isinstance(H, list) and; isinstance(H[0], Qobj) and issuper(H[0]))):. #; # we have collapse operators, or rho0 is not a ket,; # or H is a Liouvillian; #. #; # find out if we are dealing with all-constant hamiltonian and; # collapse operators or if we have at least one time-dependent; # operator. Then delegate to appropriate solver...; #. if isinstance(H, Qobj):; # constant hamiltonian; if n_func == 0 and n_str == 0:; # constant collapse operator",MatchSource.WIKI,docs/4.2/modules/qutip/mesolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mesolve.html
https://qutip.org/docs/4.2/modules/qutip/mesolve.html:9697,Integrability,depend,dependent,9697," was given in place of; operators for which to calculate the expectation values. """"""; # check whether c_ops or e_ops is is a single operator; # if so convert it to a list containing only that operator; if isinstance(c_ops, Qobj):; c_ops = [c_ops]. if isinstance(e_ops, Qobj):; e_ops = [e_ops]. if isinstance(e_ops, dict):; e_ops_dict = e_ops; e_ops = [e for e in e_ops.values()]; else:; e_ops_dict = None; ; if _safe_mode:; _solver_safety_check(H, rho0, c_ops, e_ops, args); ; if progress_bar is None:; progress_bar = BaseProgressBar(); elif progress_bar is True:; progress_bar = TextProgressBar(). # check if rho0 is a superoperator, in which case e_ops argument should; # be empty, i.e., e_ops = []; if issuper(rho0) and not e_ops == []:; raise TypeError(""Must have e_ops = [] when initial condition rho0 is"" +; "" a superoperator.""). # convert array based time-dependence to string format; H, c_ops, args = _td_wrap_array_str(H, c_ops, args, tlist). # check for type (if any) of time-dependent inputs; _, n_func, n_str = _td_format_check(H, c_ops). if options is None:; options = Options(). if (not options.rhs_reuse) or (not config.tdfunc):; # reset config collapse and time-dependence flags to default values; config.reset(); ; #check if should use OPENMP; check_use_openmp(options); ; ; res = None. #; # dispatch the appropriate solver; #; if ((c_ops and len(c_ops) > 0); or (not isket(rho0)); or (isinstance(H, Qobj) and issuper(H)); or (isinstance(H, list) and; isinstance(H[0], Qobj) and issuper(H[0]))):. #; # we have collapse operators, or rho0 is not a ket,; # or H is a Liouvillian; #. #; # find out if we are dealing with all-constant hamiltonian and; # collapse operators or if we have at least one time-dependent; # operator. Then delegate to appropriate solver...; #. if isinstance(H, Qobj):; # constant hamiltonian; if n_func == 0 and n_str == 0:; # constant collapse operators; res = _mesolve_const(H, rho0, tlist, c_ops,; e_ops, args, options,; progress_bar); elif n_str > 0:; # con",MatchSource.WIKI,docs/4.2/modules/qutip/mesolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mesolve.html
https://qutip.org/docs/4.2/modules/qutip/mesolve.html:9889,Integrability,depend,dependence,9889,"ing only that operator; if isinstance(c_ops, Qobj):; c_ops = [c_ops]. if isinstance(e_ops, Qobj):; e_ops = [e_ops]. if isinstance(e_ops, dict):; e_ops_dict = e_ops; e_ops = [e for e in e_ops.values()]; else:; e_ops_dict = None; ; if _safe_mode:; _solver_safety_check(H, rho0, c_ops, e_ops, args); ; if progress_bar is None:; progress_bar = BaseProgressBar(); elif progress_bar is True:; progress_bar = TextProgressBar(). # check if rho0 is a superoperator, in which case e_ops argument should; # be empty, i.e., e_ops = []; if issuper(rho0) and not e_ops == []:; raise TypeError(""Must have e_ops = [] when initial condition rho0 is"" +; "" a superoperator.""). # convert array based time-dependence to string format; H, c_ops, args = _td_wrap_array_str(H, c_ops, args, tlist). # check for type (if any) of time-dependent inputs; _, n_func, n_str = _td_format_check(H, c_ops). if options is None:; options = Options(). if (not options.rhs_reuse) or (not config.tdfunc):; # reset config collapse and time-dependence flags to default values; config.reset(); ; #check if should use OPENMP; check_use_openmp(options); ; ; res = None. #; # dispatch the appropriate solver; #; if ((c_ops and len(c_ops) > 0); or (not isket(rho0)); or (isinstance(H, Qobj) and issuper(H)); or (isinstance(H, list) and; isinstance(H[0], Qobj) and issuper(H[0]))):. #; # we have collapse operators, or rho0 is not a ket,; # or H is a Liouvillian; #. #; # find out if we are dealing with all-constant hamiltonian and; # collapse operators or if we have at least one time-dependent; # operator. Then delegate to appropriate solver...; #. if isinstance(H, Qobj):; # constant hamiltonian; if n_func == 0 and n_str == 0:; # constant collapse operators; res = _mesolve_const(H, rho0, tlist, c_ops,; e_ops, args, options,; progress_bar); elif n_str > 0:; # constant hamiltonian but time-dependent collapse; # operators in list string format; res = _mesolve_list_str_td([H], rho0, tlist, c_ops,; e_ops, args, options,; progress_bar); elif",MatchSource.WIKI,docs/4.2/modules/qutip/mesolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mesolve.html
https://qutip.org/docs/4.2/modules/qutip/mesolve.html:10429,Integrability,depend,dependent,10429,"ld; # be empty, i.e., e_ops = []; if issuper(rho0) and not e_ops == []:; raise TypeError(""Must have e_ops = [] when initial condition rho0 is"" +; "" a superoperator.""). # convert array based time-dependence to string format; H, c_ops, args = _td_wrap_array_str(H, c_ops, args, tlist). # check for type (if any) of time-dependent inputs; _, n_func, n_str = _td_format_check(H, c_ops). if options is None:; options = Options(). if (not options.rhs_reuse) or (not config.tdfunc):; # reset config collapse and time-dependence flags to default values; config.reset(); ; #check if should use OPENMP; check_use_openmp(options); ; ; res = None. #; # dispatch the appropriate solver; #; if ((c_ops and len(c_ops) > 0); or (not isket(rho0)); or (isinstance(H, Qobj) and issuper(H)); or (isinstance(H, list) and; isinstance(H[0], Qobj) and issuper(H[0]))):. #; # we have collapse operators, or rho0 is not a ket,; # or H is a Liouvillian; #. #; # find out if we are dealing with all-constant hamiltonian and; # collapse operators or if we have at least one time-dependent; # operator. Then delegate to appropriate solver...; #. if isinstance(H, Qobj):; # constant hamiltonian; if n_func == 0 and n_str == 0:; # constant collapse operators; res = _mesolve_const(H, rho0, tlist, c_ops,; e_ops, args, options,; progress_bar); elif n_str > 0:; # constant hamiltonian but time-dependent collapse; # operators in list string format; res = _mesolve_list_str_td([H], rho0, tlist, c_ops,; e_ops, args, options,; progress_bar); elif n_func > 0:; # constant hamiltonian but time-dependent collapse; # operators in list function format; res = _mesolve_list_func_td([H], rho0, tlist, c_ops,; e_ops, args, options,; progress_bar). elif isinstance(H, (types.FunctionType,; types.BuiltinFunctionType, partial)):; # function-callback style time-dependence: must have constant; # collapse operators; if n_str > 0: # or n_func > 0:; raise TypeError(""Incorrect format: function-format "" +; ""Hamiltonian cannot be mixed with "" +; ""tim",MatchSource.WIKI,docs/4.2/modules/qutip/mesolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mesolve.html
https://qutip.org/docs/4.2/modules/qutip/mesolve.html:10739,Integrability,depend,dependent,10739,"ns = Options(). if (not options.rhs_reuse) or (not config.tdfunc):; # reset config collapse and time-dependence flags to default values; config.reset(); ; #check if should use OPENMP; check_use_openmp(options); ; ; res = None. #; # dispatch the appropriate solver; #; if ((c_ops and len(c_ops) > 0); or (not isket(rho0)); or (isinstance(H, Qobj) and issuper(H)); or (isinstance(H, list) and; isinstance(H[0], Qobj) and issuper(H[0]))):. #; # we have collapse operators, or rho0 is not a ket,; # or H is a Liouvillian; #. #; # find out if we are dealing with all-constant hamiltonian and; # collapse operators or if we have at least one time-dependent; # operator. Then delegate to appropriate solver...; #. if isinstance(H, Qobj):; # constant hamiltonian; if n_func == 0 and n_str == 0:; # constant collapse operators; res = _mesolve_const(H, rho0, tlist, c_ops,; e_ops, args, options,; progress_bar); elif n_str > 0:; # constant hamiltonian but time-dependent collapse; # operators in list string format; res = _mesolve_list_str_td([H], rho0, tlist, c_ops,; e_ops, args, options,; progress_bar); elif n_func > 0:; # constant hamiltonian but time-dependent collapse; # operators in list function format; res = _mesolve_list_func_td([H], rho0, tlist, c_ops,; e_ops, args, options,; progress_bar). elif isinstance(H, (types.FunctionType,; types.BuiltinFunctionType, partial)):; # function-callback style time-dependence: must have constant; # collapse operators; if n_str > 0: # or n_func > 0:; raise TypeError(""Incorrect format: function-format "" +; ""Hamiltonian cannot be mixed with "" +; ""time-dependent collapse operators.""); else:; res = _mesolve_func_td(H, rho0, tlist, c_ops,; e_ops, args, options,; progress_bar). elif isinstance(H, list):; # determine if we are dealing with list of [Qobj, string] or; # [Qobj, function] style time-dependencies (for pure python and; # cython, respectively); if n_func > 0:; res = _mesolve_list_func_td(H, rho0, tlist, c_ops,; e_ops, args, options,; progress_bar",MatchSource.WIKI,docs/4.2/modules/qutip/mesolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mesolve.html
https://qutip.org/docs/4.2/modules/qutip/mesolve.html:10935,Integrability,depend,dependent,10935,"ns = Options(). if (not options.rhs_reuse) or (not config.tdfunc):; # reset config collapse and time-dependence flags to default values; config.reset(); ; #check if should use OPENMP; check_use_openmp(options); ; ; res = None. #; # dispatch the appropriate solver; #; if ((c_ops and len(c_ops) > 0); or (not isket(rho0)); or (isinstance(H, Qobj) and issuper(H)); or (isinstance(H, list) and; isinstance(H[0], Qobj) and issuper(H[0]))):. #; # we have collapse operators, or rho0 is not a ket,; # or H is a Liouvillian; #. #; # find out if we are dealing with all-constant hamiltonian and; # collapse operators or if we have at least one time-dependent; # operator. Then delegate to appropriate solver...; #. if isinstance(H, Qobj):; # constant hamiltonian; if n_func == 0 and n_str == 0:; # constant collapse operators; res = _mesolve_const(H, rho0, tlist, c_ops,; e_ops, args, options,; progress_bar); elif n_str > 0:; # constant hamiltonian but time-dependent collapse; # operators in list string format; res = _mesolve_list_str_td([H], rho0, tlist, c_ops,; e_ops, args, options,; progress_bar); elif n_func > 0:; # constant hamiltonian but time-dependent collapse; # operators in list function format; res = _mesolve_list_func_td([H], rho0, tlist, c_ops,; e_ops, args, options,; progress_bar). elif isinstance(H, (types.FunctionType,; types.BuiltinFunctionType, partial)):; # function-callback style time-dependence: must have constant; # collapse operators; if n_str > 0: # or n_func > 0:; raise TypeError(""Incorrect format: function-format "" +; ""Hamiltonian cannot be mixed with "" +; ""time-dependent collapse operators.""); else:; res = _mesolve_func_td(H, rho0, tlist, c_ops,; e_ops, args, options,; progress_bar). elif isinstance(H, list):; # determine if we are dealing with list of [Qobj, string] or; # [Qobj, function] style time-dependencies (for pure python and; # cython, respectively); if n_func > 0:; res = _mesolve_list_func_td(H, rho0, tlist, c_ops,; e_ops, args, options,; progress_bar",MatchSource.WIKI,docs/4.2/modules/qutip/mesolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mesolve.html
https://qutip.org/docs/4.2/modules/qutip/mesolve.html:11195,Integrability,depend,dependence,11195,"t a ket,; # or H is a Liouvillian; #. #; # find out if we are dealing with all-constant hamiltonian and; # collapse operators or if we have at least one time-dependent; # operator. Then delegate to appropriate solver...; #. if isinstance(H, Qobj):; # constant hamiltonian; if n_func == 0 and n_str == 0:; # constant collapse operators; res = _mesolve_const(H, rho0, tlist, c_ops,; e_ops, args, options,; progress_bar); elif n_str > 0:; # constant hamiltonian but time-dependent collapse; # operators in list string format; res = _mesolve_list_str_td([H], rho0, tlist, c_ops,; e_ops, args, options,; progress_bar); elif n_func > 0:; # constant hamiltonian but time-dependent collapse; # operators in list function format; res = _mesolve_list_func_td([H], rho0, tlist, c_ops,; e_ops, args, options,; progress_bar). elif isinstance(H, (types.FunctionType,; types.BuiltinFunctionType, partial)):; # function-callback style time-dependence: must have constant; # collapse operators; if n_str > 0: # or n_func > 0:; raise TypeError(""Incorrect format: function-format "" +; ""Hamiltonian cannot be mixed with "" +; ""time-dependent collapse operators.""); else:; res = _mesolve_func_td(H, rho0, tlist, c_ops,; e_ops, args, options,; progress_bar). elif isinstance(H, list):; # determine if we are dealing with list of [Qobj, string] or; # [Qobj, function] style time-dependencies (for pure python and; # cython, respectively); if n_func > 0:; res = _mesolve_list_func_td(H, rho0, tlist, c_ops,; e_ops, args, options,; progress_bar); else:; res = _mesolve_list_str_td(H, rho0, tlist, c_ops,; e_ops, args, options,; progress_bar). else:; raise TypeError(""Incorrect specification of Hamiltonian "" +; ""or collapse operators.""). else:; #; # no collapse operators: unitary dynamics; #; if n_func > 0:; res = _sesolve_list_func_td(H, rho0, tlist,; e_ops, args, options, progress_bar); elif n_str > 0:; res = _sesolve_list_str_td(H, rho0, tlist,; e_ops, args, options, progress_bar); elif isinstance(H, (types.FunctionTy",MatchSource.WIKI,docs/4.2/modules/qutip/mesolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mesolve.html
https://qutip.org/docs/4.2/modules/qutip/mesolve.html:11382,Integrability,depend,dependent,11382,"t a ket,; # or H is a Liouvillian; #. #; # find out if we are dealing with all-constant hamiltonian and; # collapse operators or if we have at least one time-dependent; # operator. Then delegate to appropriate solver...; #. if isinstance(H, Qobj):; # constant hamiltonian; if n_func == 0 and n_str == 0:; # constant collapse operators; res = _mesolve_const(H, rho0, tlist, c_ops,; e_ops, args, options,; progress_bar); elif n_str > 0:; # constant hamiltonian but time-dependent collapse; # operators in list string format; res = _mesolve_list_str_td([H], rho0, tlist, c_ops,; e_ops, args, options,; progress_bar); elif n_func > 0:; # constant hamiltonian but time-dependent collapse; # operators in list function format; res = _mesolve_list_func_td([H], rho0, tlist, c_ops,; e_ops, args, options,; progress_bar). elif isinstance(H, (types.FunctionType,; types.BuiltinFunctionType, partial)):; # function-callback style time-dependence: must have constant; # collapse operators; if n_str > 0: # or n_func > 0:; raise TypeError(""Incorrect format: function-format "" +; ""Hamiltonian cannot be mixed with "" +; ""time-dependent collapse operators.""); else:; res = _mesolve_func_td(H, rho0, tlist, c_ops,; e_ops, args, options,; progress_bar). elif isinstance(H, list):; # determine if we are dealing with list of [Qobj, string] or; # [Qobj, function] style time-dependencies (for pure python and; # cython, respectively); if n_func > 0:; res = _mesolve_list_func_td(H, rho0, tlist, c_ops,; e_ops, args, options,; progress_bar); else:; res = _mesolve_list_str_td(H, rho0, tlist, c_ops,; e_ops, args, options,; progress_bar). else:; raise TypeError(""Incorrect specification of Hamiltonian "" +; ""or collapse operators.""). else:; #; # no collapse operators: unitary dynamics; #; if n_func > 0:; res = _sesolve_list_func_td(H, rho0, tlist,; e_ops, args, options, progress_bar); elif n_str > 0:; res = _sesolve_list_str_td(H, rho0, tlist,; e_ops, args, options, progress_bar); elif isinstance(H, (types.FunctionTy",MatchSource.WIKI,docs/4.2/modules/qutip/mesolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mesolve.html
https://qutip.org/docs/4.2/modules/qutip/mesolve.html:11626,Integrability,depend,dependencies,11626,"_str > 0:; # constant hamiltonian but time-dependent collapse; # operators in list string format; res = _mesolve_list_str_td([H], rho0, tlist, c_ops,; e_ops, args, options,; progress_bar); elif n_func > 0:; # constant hamiltonian but time-dependent collapse; # operators in list function format; res = _mesolve_list_func_td([H], rho0, tlist, c_ops,; e_ops, args, options,; progress_bar). elif isinstance(H, (types.FunctionType,; types.BuiltinFunctionType, partial)):; # function-callback style time-dependence: must have constant; # collapse operators; if n_str > 0: # or n_func > 0:; raise TypeError(""Incorrect format: function-format "" +; ""Hamiltonian cannot be mixed with "" +; ""time-dependent collapse operators.""); else:; res = _mesolve_func_td(H, rho0, tlist, c_ops,; e_ops, args, options,; progress_bar). elif isinstance(H, list):; # determine if we are dealing with list of [Qobj, string] or; # [Qobj, function] style time-dependencies (for pure python and; # cython, respectively); if n_func > 0:; res = _mesolve_list_func_td(H, rho0, tlist, c_ops,; e_ops, args, options,; progress_bar); else:; res = _mesolve_list_str_td(H, rho0, tlist, c_ops,; e_ops, args, options,; progress_bar). else:; raise TypeError(""Incorrect specification of Hamiltonian "" +; ""or collapse operators.""). else:; #; # no collapse operators: unitary dynamics; #; if n_func > 0:; res = _sesolve_list_func_td(H, rho0, tlist,; e_ops, args, options, progress_bar); elif n_str > 0:; res = _sesolve_list_str_td(H, rho0, tlist,; e_ops, args, options, progress_bar); elif isinstance(H, (types.FunctionType,; types.BuiltinFunctionType, partial)):; res = _sesolve_func_td(H, rho0, tlist,; e_ops, args, options, progress_bar); else:; res = _sesolve_const(H, rho0, tlist,; e_ops, args, options, progress_bar). if e_ops_dict:; res.expect = {e: res.expect[n]; for n, e in enumerate(e_ops_dict.keys())}. return res. # -----------------------------------------------------------------------------; # A time-dependent dissipative master e",MatchSource.WIKI,docs/4.2/modules/qutip/mesolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mesolve.html
https://qutip.org/docs/4.2/modules/qutip/mesolve.html:12667,Integrability,depend,dependent,12667,"(H, rho0, tlist, c_ops,; e_ops, args, options,; progress_bar); else:; res = _mesolve_list_str_td(H, rho0, tlist, c_ops,; e_ops, args, options,; progress_bar). else:; raise TypeError(""Incorrect specification of Hamiltonian "" +; ""or collapse operators.""). else:; #; # no collapse operators: unitary dynamics; #; if n_func > 0:; res = _sesolve_list_func_td(H, rho0, tlist,; e_ops, args, options, progress_bar); elif n_str > 0:; res = _sesolve_list_str_td(H, rho0, tlist,; e_ops, args, options, progress_bar); elif isinstance(H, (types.FunctionType,; types.BuiltinFunctionType, partial)):; res = _sesolve_func_td(H, rho0, tlist,; e_ops, args, options, progress_bar); else:; res = _sesolve_const(H, rho0, tlist,; e_ops, args, options, progress_bar). if e_ops_dict:; res.expect = {e: res.expect[n]; for n, e in enumerate(e_ops_dict.keys())}. return res. # -----------------------------------------------------------------------------; # A time-dependent dissipative master equation on the list-function format; #; def _mesolve_list_func_td(H_list, rho0, tlist, c_list, e_ops, args, opt,; progress_bar):; """"""; Internal function for solving the master equation. See mesolve for usage.; """""". if debug:; print(inspect.stack()[0][3]). #; # check initial state; #; if isket(rho0):; rho0 = rho0 * rho0.dag(). #; # construct liouvillian in list-function format; #; L_list = []; if opt.rhs_with_state:; constant_func = lambda x, y, z: 1.0; else:; constant_func = lambda x, y: 1.0. # add all hamitonian terms to the lagrangian list; for h_spec in H_list:. if isinstance(h_spec, Qobj):; h = h_spec; h_coeff = constant_func. elif isinstance(h_spec, list) and isinstance(h_spec[0], Qobj):; h = h_spec[0]; h_coeff = h_spec[1]. else:; raise TypeError(""Incorrect specification of time-dependent "" +; ""Hamiltonian (expected callback function)""). if isoper(h):; L_list.append([(-1j * (spre(h) - spost(h))).data, h_coeff, False]). elif issuper(h):; L_list.append([h.data, h_coeff, False]). else:; raise TypeError(""Incorrect s",MatchSource.WIKI,docs/4.2/modules/qutip/mesolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mesolve.html
https://qutip.org/docs/4.2/modules/qutip/mesolve.html:13492,Integrability,depend,dependent,13492,".expect = {e: res.expect[n]; for n, e in enumerate(e_ops_dict.keys())}. return res. # -----------------------------------------------------------------------------; # A time-dependent dissipative master equation on the list-function format; #; def _mesolve_list_func_td(H_list, rho0, tlist, c_list, e_ops, args, opt,; progress_bar):; """"""; Internal function for solving the master equation. See mesolve for usage.; """""". if debug:; print(inspect.stack()[0][3]). #; # check initial state; #; if isket(rho0):; rho0 = rho0 * rho0.dag(). #; # construct liouvillian in list-function format; #; L_list = []; if opt.rhs_with_state:; constant_func = lambda x, y, z: 1.0; else:; constant_func = lambda x, y: 1.0. # add all hamitonian terms to the lagrangian list; for h_spec in H_list:. if isinstance(h_spec, Qobj):; h = h_spec; h_coeff = constant_func. elif isinstance(h_spec, list) and isinstance(h_spec[0], Qobj):; h = h_spec[0]; h_coeff = h_spec[1]. else:; raise TypeError(""Incorrect specification of time-dependent "" +; ""Hamiltonian (expected callback function)""). if isoper(h):; L_list.append([(-1j * (spre(h) - spost(h))).data, h_coeff, False]). elif issuper(h):; L_list.append([h.data, h_coeff, False]). else:; raise TypeError(""Incorrect specification of time-dependent "" +; ""Hamiltonian (expected operator or superoperator)""). # add all collapse operators to the liouvillian list; for c_spec in c_list:. if isinstance(c_spec, Qobj):; c = c_spec; c_coeff = constant_func; c_square = False. elif isinstance(c_spec, list) and isinstance(c_spec[0], Qobj):; c = c_spec[0]; c_coeff = c_spec[1]; c_square = True. else:; raise TypeError(""Incorrect specification of time-dependent "" +; ""collapse operators (expected callback function)""). if isoper(c):; L_list.append([liouvillian(None, [c], data_only=True),; c_coeff, c_square]). elif issuper(c):; L_list.append([c.data, c_coeff, c_square]). else:; raise TypeError(""Incorrect specification of time-dependent "" +; ""collapse operators (expected operator or "" +; """,MatchSource.WIKI,docs/4.2/modules/qutip/mesolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mesolve.html
https://qutip.org/docs/4.2/modules/qutip/mesolve.html:13750,Integrability,depend,dependent,13750,"func_td(H_list, rho0, tlist, c_list, e_ops, args, opt,; progress_bar):; """"""; Internal function for solving the master equation. See mesolve for usage.; """""". if debug:; print(inspect.stack()[0][3]). #; # check initial state; #; if isket(rho0):; rho0 = rho0 * rho0.dag(). #; # construct liouvillian in list-function format; #; L_list = []; if opt.rhs_with_state:; constant_func = lambda x, y, z: 1.0; else:; constant_func = lambda x, y: 1.0. # add all hamitonian terms to the lagrangian list; for h_spec in H_list:. if isinstance(h_spec, Qobj):; h = h_spec; h_coeff = constant_func. elif isinstance(h_spec, list) and isinstance(h_spec[0], Qobj):; h = h_spec[0]; h_coeff = h_spec[1]. else:; raise TypeError(""Incorrect specification of time-dependent "" +; ""Hamiltonian (expected callback function)""). if isoper(h):; L_list.append([(-1j * (spre(h) - spost(h))).data, h_coeff, False]). elif issuper(h):; L_list.append([h.data, h_coeff, False]). else:; raise TypeError(""Incorrect specification of time-dependent "" +; ""Hamiltonian (expected operator or superoperator)""). # add all collapse operators to the liouvillian list; for c_spec in c_list:. if isinstance(c_spec, Qobj):; c = c_spec; c_coeff = constant_func; c_square = False. elif isinstance(c_spec, list) and isinstance(c_spec[0], Qobj):; c = c_spec[0]; c_coeff = c_spec[1]; c_square = True. else:; raise TypeError(""Incorrect specification of time-dependent "" +; ""collapse operators (expected callback function)""). if isoper(c):; L_list.append([liouvillian(None, [c], data_only=True),; c_coeff, c_square]). elif issuper(c):; L_list.append([c.data, c_coeff, c_square]). else:; raise TypeError(""Incorrect specification of time-dependent "" +; ""collapse operators (expected operator or "" +; ""superoperator)""). #; # setup integrator; #; initial_vector = mat2vec(rho0.full()).ravel('F'); if issuper(rho0):; if opt.rhs_with_state:; r = scipy.integrate.ode(dsuper_list_td_with_state); else:; r = scipy.integrate.ode(dsuper_list_td); else:; if opt.rhs_with_st",MatchSource.WIKI,docs/4.2/modules/qutip/mesolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mesolve.html
https://qutip.org/docs/4.2/modules/qutip/mesolve.html:14153,Integrability,depend,dependent,14153,"e:; constant_func = lambda x, y: 1.0. # add all hamitonian terms to the lagrangian list; for h_spec in H_list:. if isinstance(h_spec, Qobj):; h = h_spec; h_coeff = constant_func. elif isinstance(h_spec, list) and isinstance(h_spec[0], Qobj):; h = h_spec[0]; h_coeff = h_spec[1]. else:; raise TypeError(""Incorrect specification of time-dependent "" +; ""Hamiltonian (expected callback function)""). if isoper(h):; L_list.append([(-1j * (spre(h) - spost(h))).data, h_coeff, False]). elif issuper(h):; L_list.append([h.data, h_coeff, False]). else:; raise TypeError(""Incorrect specification of time-dependent "" +; ""Hamiltonian (expected operator or superoperator)""). # add all collapse operators to the liouvillian list; for c_spec in c_list:. if isinstance(c_spec, Qobj):; c = c_spec; c_coeff = constant_func; c_square = False. elif isinstance(c_spec, list) and isinstance(c_spec[0], Qobj):; c = c_spec[0]; c_coeff = c_spec[1]; c_square = True. else:; raise TypeError(""Incorrect specification of time-dependent "" +; ""collapse operators (expected callback function)""). if isoper(c):; L_list.append([liouvillian(None, [c], data_only=True),; c_coeff, c_square]). elif issuper(c):; L_list.append([c.data, c_coeff, c_square]). else:; raise TypeError(""Incorrect specification of time-dependent "" +; ""collapse operators (expected operator or "" +; ""superoperator)""). #; # setup integrator; #; initial_vector = mat2vec(rho0.full()).ravel('F'); if issuper(rho0):; if opt.rhs_with_state:; r = scipy.integrate.ode(dsuper_list_td_with_state); else:; r = scipy.integrate.ode(dsuper_list_td); else:; if opt.rhs_with_state:; r = scipy.integrate.ode(drho_list_td_with_state); else:; r = scipy.integrate.ode(drho_list_td); r.set_integrator('zvode', method=opt.method, order=opt.order,; atol=opt.atol, rtol=opt.rtol, nsteps=opt.nsteps,; first_step=opt.first_step, min_step=opt.min_step,; max_step=opt.max_step); r.set_initial_value(initial_vector, tlist[0]); r.set_f_params(L_list, args). #; # call generic ODE code; #; retur",MatchSource.WIKI,docs/4.2/modules/qutip/mesolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mesolve.html
https://qutip.org/docs/4.2/modules/qutip/mesolve.html:14430,Integrability,depend,dependent,14430,"; raise TypeError(""Incorrect specification of time-dependent "" +; ""Hamiltonian (expected callback function)""). if isoper(h):; L_list.append([(-1j * (spre(h) - spost(h))).data, h_coeff, False]). elif issuper(h):; L_list.append([h.data, h_coeff, False]). else:; raise TypeError(""Incorrect specification of time-dependent "" +; ""Hamiltonian (expected operator or superoperator)""). # add all collapse operators to the liouvillian list; for c_spec in c_list:. if isinstance(c_spec, Qobj):; c = c_spec; c_coeff = constant_func; c_square = False. elif isinstance(c_spec, list) and isinstance(c_spec[0], Qobj):; c = c_spec[0]; c_coeff = c_spec[1]; c_square = True. else:; raise TypeError(""Incorrect specification of time-dependent "" +; ""collapse operators (expected callback function)""). if isoper(c):; L_list.append([liouvillian(None, [c], data_only=True),; c_coeff, c_square]). elif issuper(c):; L_list.append([c.data, c_coeff, c_square]). else:; raise TypeError(""Incorrect specification of time-dependent "" +; ""collapse operators (expected operator or "" +; ""superoperator)""). #; # setup integrator; #; initial_vector = mat2vec(rho0.full()).ravel('F'); if issuper(rho0):; if opt.rhs_with_state:; r = scipy.integrate.ode(dsuper_list_td_with_state); else:; r = scipy.integrate.ode(dsuper_list_td); else:; if opt.rhs_with_state:; r = scipy.integrate.ode(drho_list_td_with_state); else:; r = scipy.integrate.ode(drho_list_td); r.set_integrator('zvode', method=opt.method, order=opt.order,; atol=opt.atol, rtol=opt.rtol, nsteps=opt.nsteps,; first_step=opt.first_step, min_step=opt.min_step,; max_step=opt.max_step); r.set_initial_value(initial_vector, tlist[0]); r.set_f_params(L_list, args). #; # call generic ODE code; #; return _generic_ode_solve(r, rho0, tlist, e_ops, opt, progress_bar). #; # evaluate drho(t)/dt according to the master equation using the; # [Qobj, function] style time dependence API; #; def drho_list_td(t, rho, L_list, args):; out = np.zeros(rho.shape[0],dtype=complex); L = L_list[0][0];",MatchSource.WIKI,docs/4.2/modules/qutip/mesolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mesolve.html
https://qutip.org/docs/4.2/modules/qutip/mesolve.html:14522,Integrability,integrat,integrator,14522," function)""). if isoper(h):; L_list.append([(-1j * (spre(h) - spost(h))).data, h_coeff, False]). elif issuper(h):; L_list.append([h.data, h_coeff, False]). else:; raise TypeError(""Incorrect specification of time-dependent "" +; ""Hamiltonian (expected operator or superoperator)""). # add all collapse operators to the liouvillian list; for c_spec in c_list:. if isinstance(c_spec, Qobj):; c = c_spec; c_coeff = constant_func; c_square = False. elif isinstance(c_spec, list) and isinstance(c_spec[0], Qobj):; c = c_spec[0]; c_coeff = c_spec[1]; c_square = True. else:; raise TypeError(""Incorrect specification of time-dependent "" +; ""collapse operators (expected callback function)""). if isoper(c):; L_list.append([liouvillian(None, [c], data_only=True),; c_coeff, c_square]). elif issuper(c):; L_list.append([c.data, c_coeff, c_square]). else:; raise TypeError(""Incorrect specification of time-dependent "" +; ""collapse operators (expected operator or "" +; ""superoperator)""). #; # setup integrator; #; initial_vector = mat2vec(rho0.full()).ravel('F'); if issuper(rho0):; if opt.rhs_with_state:; r = scipy.integrate.ode(dsuper_list_td_with_state); else:; r = scipy.integrate.ode(dsuper_list_td); else:; if opt.rhs_with_state:; r = scipy.integrate.ode(drho_list_td_with_state); else:; r = scipy.integrate.ode(drho_list_td); r.set_integrator('zvode', method=opt.method, order=opt.order,; atol=opt.atol, rtol=opt.rtol, nsteps=opt.nsteps,; first_step=opt.first_step, min_step=opt.min_step,; max_step=opt.max_step); r.set_initial_value(initial_vector, tlist[0]); r.set_f_params(L_list, args). #; # call generic ODE code; #; return _generic_ode_solve(r, rho0, tlist, e_ops, opt, progress_bar). #; # evaluate drho(t)/dt according to the master equation using the; # [Qobj, function] style time dependence API; #; def drho_list_td(t, rho, L_list, args):; out = np.zeros(rho.shape[0],dtype=complex); L = L_list[0][0]; L_td = L_list[0][1]; spmvpy_csr(L.data, L.indices, L.indptr,; rho, L_td(t, args), out); for n in",MatchSource.WIKI,docs/4.2/modules/qutip/mesolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mesolve.html
https://qutip.org/docs/4.2/modules/qutip/mesolve.html:14640,Integrability,integrat,integrate,14640,"er(h):; L_list.append([h.data, h_coeff, False]). else:; raise TypeError(""Incorrect specification of time-dependent "" +; ""Hamiltonian (expected operator or superoperator)""). # add all collapse operators to the liouvillian list; for c_spec in c_list:. if isinstance(c_spec, Qobj):; c = c_spec; c_coeff = constant_func; c_square = False. elif isinstance(c_spec, list) and isinstance(c_spec[0], Qobj):; c = c_spec[0]; c_coeff = c_spec[1]; c_square = True. else:; raise TypeError(""Incorrect specification of time-dependent "" +; ""collapse operators (expected callback function)""). if isoper(c):; L_list.append([liouvillian(None, [c], data_only=True),; c_coeff, c_square]). elif issuper(c):; L_list.append([c.data, c_coeff, c_square]). else:; raise TypeError(""Incorrect specification of time-dependent "" +; ""collapse operators (expected operator or "" +; ""superoperator)""). #; # setup integrator; #; initial_vector = mat2vec(rho0.full()).ravel('F'); if issuper(rho0):; if opt.rhs_with_state:; r = scipy.integrate.ode(dsuper_list_td_with_state); else:; r = scipy.integrate.ode(dsuper_list_td); else:; if opt.rhs_with_state:; r = scipy.integrate.ode(drho_list_td_with_state); else:; r = scipy.integrate.ode(drho_list_td); r.set_integrator('zvode', method=opt.method, order=opt.order,; atol=opt.atol, rtol=opt.rtol, nsteps=opt.nsteps,; first_step=opt.first_step, min_step=opt.min_step,; max_step=opt.max_step); r.set_initial_value(initial_vector, tlist[0]); r.set_f_params(L_list, args). #; # call generic ODE code; #; return _generic_ode_solve(r, rho0, tlist, e_ops, opt, progress_bar). #; # evaluate drho(t)/dt according to the master equation using the; # [Qobj, function] style time dependence API; #; def drho_list_td(t, rho, L_list, args):; out = np.zeros(rho.shape[0],dtype=complex); L = L_list[0][0]; L_td = L_list[0][1]; spmvpy_csr(L.data, L.indices, L.indptr,; rho, L_td(t, args), out); for n in range(1, len(L_list)):; #; # L_args[n][0] = the sparse data for a Qobj in super-operator form; # L_args[n",MatchSource.WIKI,docs/4.2/modules/qutip/mesolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mesolve.html
https://qutip.org/docs/4.2/modules/qutip/mesolve.html:14699,Integrability,integrat,integrate,14699,"se TypeError(""Incorrect specification of time-dependent "" +; ""Hamiltonian (expected operator or superoperator)""). # add all collapse operators to the liouvillian list; for c_spec in c_list:. if isinstance(c_spec, Qobj):; c = c_spec; c_coeff = constant_func; c_square = False. elif isinstance(c_spec, list) and isinstance(c_spec[0], Qobj):; c = c_spec[0]; c_coeff = c_spec[1]; c_square = True. else:; raise TypeError(""Incorrect specification of time-dependent "" +; ""collapse operators (expected callback function)""). if isoper(c):; L_list.append([liouvillian(None, [c], data_only=True),; c_coeff, c_square]). elif issuper(c):; L_list.append([c.data, c_coeff, c_square]). else:; raise TypeError(""Incorrect specification of time-dependent "" +; ""collapse operators (expected operator or "" +; ""superoperator)""). #; # setup integrator; #; initial_vector = mat2vec(rho0.full()).ravel('F'); if issuper(rho0):; if opt.rhs_with_state:; r = scipy.integrate.ode(dsuper_list_td_with_state); else:; r = scipy.integrate.ode(dsuper_list_td); else:; if opt.rhs_with_state:; r = scipy.integrate.ode(drho_list_td_with_state); else:; r = scipy.integrate.ode(drho_list_td); r.set_integrator('zvode', method=opt.method, order=opt.order,; atol=opt.atol, rtol=opt.rtol, nsteps=opt.nsteps,; first_step=opt.first_step, min_step=opt.min_step,; max_step=opt.max_step); r.set_initial_value(initial_vector, tlist[0]); r.set_f_params(L_list, args). #; # call generic ODE code; #; return _generic_ode_solve(r, rho0, tlist, e_ops, opt, progress_bar). #; # evaluate drho(t)/dt according to the master equation using the; # [Qobj, function] style time dependence API; #; def drho_list_td(t, rho, L_list, args):; out = np.zeros(rho.shape[0],dtype=complex); L = L_list[0][0]; L_td = L_list[0][1]; spmvpy_csr(L.data, L.indices, L.indptr,; rho, L_td(t, args), out); for n in range(1, len(L_list)):; #; # L_args[n][0] = the sparse data for a Qobj in super-operator form; # L_args[n][1] = function callback giving the coefficient; #; L = L_l",MatchSource.WIKI,docs/4.2/modules/qutip/mesolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mesolve.html
https://qutip.org/docs/4.2/modules/qutip/mesolve.html:14771,Integrability,integrat,integrate,14771,"n (expected operator or superoperator)""). # add all collapse operators to the liouvillian list; for c_spec in c_list:. if isinstance(c_spec, Qobj):; c = c_spec; c_coeff = constant_func; c_square = False. elif isinstance(c_spec, list) and isinstance(c_spec[0], Qobj):; c = c_spec[0]; c_coeff = c_spec[1]; c_square = True. else:; raise TypeError(""Incorrect specification of time-dependent "" +; ""collapse operators (expected callback function)""). if isoper(c):; L_list.append([liouvillian(None, [c], data_only=True),; c_coeff, c_square]). elif issuper(c):; L_list.append([c.data, c_coeff, c_square]). else:; raise TypeError(""Incorrect specification of time-dependent "" +; ""collapse operators (expected operator or "" +; ""superoperator)""). #; # setup integrator; #; initial_vector = mat2vec(rho0.full()).ravel('F'); if issuper(rho0):; if opt.rhs_with_state:; r = scipy.integrate.ode(dsuper_list_td_with_state); else:; r = scipy.integrate.ode(dsuper_list_td); else:; if opt.rhs_with_state:; r = scipy.integrate.ode(drho_list_td_with_state); else:; r = scipy.integrate.ode(drho_list_td); r.set_integrator('zvode', method=opt.method, order=opt.order,; atol=opt.atol, rtol=opt.rtol, nsteps=opt.nsteps,; first_step=opt.first_step, min_step=opt.min_step,; max_step=opt.max_step); r.set_initial_value(initial_vector, tlist[0]); r.set_f_params(L_list, args). #; # call generic ODE code; #; return _generic_ode_solve(r, rho0, tlist, e_ops, opt, progress_bar). #; # evaluate drho(t)/dt according to the master equation using the; # [Qobj, function] style time dependence API; #; def drho_list_td(t, rho, L_list, args):; out = np.zeros(rho.shape[0],dtype=complex); L = L_list[0][0]; L_td = L_list[0][1]; spmvpy_csr(L.data, L.indices, L.indptr,; rho, L_td(t, args), out); for n in range(1, len(L_list)):; #; # L_args[n][0] = the sparse data for a Qobj in super-operator form; # L_args[n][1] = function callback giving the coefficient; #; L = L_list[n][0]; L_td = L_list[n][1]; if L_list[n][2]:; spmvpy_csr(L.data, L.i",MatchSource.WIKI,docs/4.2/modules/qutip/mesolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mesolve.html
https://qutip.org/docs/4.2/modules/qutip/mesolve.html:14828,Integrability,integrat,integrate,14828,"pse operators to the liouvillian list; for c_spec in c_list:. if isinstance(c_spec, Qobj):; c = c_spec; c_coeff = constant_func; c_square = False. elif isinstance(c_spec, list) and isinstance(c_spec[0], Qobj):; c = c_spec[0]; c_coeff = c_spec[1]; c_square = True. else:; raise TypeError(""Incorrect specification of time-dependent "" +; ""collapse operators (expected callback function)""). if isoper(c):; L_list.append([liouvillian(None, [c], data_only=True),; c_coeff, c_square]). elif issuper(c):; L_list.append([c.data, c_coeff, c_square]). else:; raise TypeError(""Incorrect specification of time-dependent "" +; ""collapse operators (expected operator or "" +; ""superoperator)""). #; # setup integrator; #; initial_vector = mat2vec(rho0.full()).ravel('F'); if issuper(rho0):; if opt.rhs_with_state:; r = scipy.integrate.ode(dsuper_list_td_with_state); else:; r = scipy.integrate.ode(dsuper_list_td); else:; if opt.rhs_with_state:; r = scipy.integrate.ode(drho_list_td_with_state); else:; r = scipy.integrate.ode(drho_list_td); r.set_integrator('zvode', method=opt.method, order=opt.order,; atol=opt.atol, rtol=opt.rtol, nsteps=opt.nsteps,; first_step=opt.first_step, min_step=opt.min_step,; max_step=opt.max_step); r.set_initial_value(initial_vector, tlist[0]); r.set_f_params(L_list, args). #; # call generic ODE code; #; return _generic_ode_solve(r, rho0, tlist, e_ops, opt, progress_bar). #; # evaluate drho(t)/dt according to the master equation using the; # [Qobj, function] style time dependence API; #; def drho_list_td(t, rho, L_list, args):; out = np.zeros(rho.shape[0],dtype=complex); L = L_list[0][0]; L_td = L_list[0][1]; spmvpy_csr(L.data, L.indices, L.indptr,; rho, L_td(t, args), out); for n in range(1, len(L_list)):; #; # L_args[n][0] = the sparse data for a Qobj in super-operator form; # L_args[n][1] = function callback giving the coefficient; #; L = L_list[n][0]; L_td = L_list[n][1]; if L_list[n][2]:; spmvpy_csr(L.data, L.indices, L.indptr,; rho, L_td(t, args)**2, out); else:; sp",MatchSource.WIKI,docs/4.2/modules/qutip/mesolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mesolve.html
https://qutip.org/docs/4.2/modules/qutip/mesolve.html:15321,Integrability,depend,dependence,15321,"are]). elif issuper(c):; L_list.append([c.data, c_coeff, c_square]). else:; raise TypeError(""Incorrect specification of time-dependent "" +; ""collapse operators (expected operator or "" +; ""superoperator)""). #; # setup integrator; #; initial_vector = mat2vec(rho0.full()).ravel('F'); if issuper(rho0):; if opt.rhs_with_state:; r = scipy.integrate.ode(dsuper_list_td_with_state); else:; r = scipy.integrate.ode(dsuper_list_td); else:; if opt.rhs_with_state:; r = scipy.integrate.ode(drho_list_td_with_state); else:; r = scipy.integrate.ode(drho_list_td); r.set_integrator('zvode', method=opt.method, order=opt.order,; atol=opt.atol, rtol=opt.rtol, nsteps=opt.nsteps,; first_step=opt.first_step, min_step=opt.min_step,; max_step=opt.max_step); r.set_initial_value(initial_vector, tlist[0]); r.set_f_params(L_list, args). #; # call generic ODE code; #; return _generic_ode_solve(r, rho0, tlist, e_ops, opt, progress_bar). #; # evaluate drho(t)/dt according to the master equation using the; # [Qobj, function] style time dependence API; #; def drho_list_td(t, rho, L_list, args):; out = np.zeros(rho.shape[0],dtype=complex); L = L_list[0][0]; L_td = L_list[0][1]; spmvpy_csr(L.data, L.indices, L.indptr,; rho, L_td(t, args), out); for n in range(1, len(L_list)):; #; # L_args[n][0] = the sparse data for a Qobj in super-operator form; # L_args[n][1] = function callback giving the coefficient; #; L = L_list[n][0]; L_td = L_list[n][1]; if L_list[n][2]:; spmvpy_csr(L.data, L.indices, L.indptr,; rho, L_td(t, args)**2, out); else:; spmvpy_csr(L.data, L.indices, L.indptr,; rho, L_td(t, args), out); return out. def drho_list_td_with_state(t, rho, L_list, args):. out = np.zeros(rho.shape[0],dtype=complex); L = L_list[0][0]; L_td = L_list[0][1]; spmvpy_csr(L.data, L.indices, L.indptr,; rho, L_td(t, rho, args), out); for n in range(1, len(L_list)):; #; # L_args[n][0] = the sparse data for a Qobj in super-operator form; # L_args[n][1] = function callback giving the coefficient; #; L = L_list[n][0]; L_td ",MatchSource.WIKI,docs/4.2/modules/qutip/mesolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mesolve.html
https://qutip.org/docs/4.2/modules/qutip/mesolve.html:16603,Integrability,depend,dependence,16603,"ta for a Qobj in super-operator form; # L_args[n][1] = function callback giving the coefficient; #; L = L_list[n][0]; L_td = L_list[n][1]; if L_list[n][2]:; spmvpy_csr(L.data, L.indices, L.indptr,; rho, L_td(t, args)**2, out); else:; spmvpy_csr(L.data, L.indices, L.indptr,; rho, L_td(t, args), out); return out. def drho_list_td_with_state(t, rho, L_list, args):. out = np.zeros(rho.shape[0],dtype=complex); L = L_list[0][0]; L_td = L_list[0][1]; spmvpy_csr(L.data, L.indices, L.indptr,; rho, L_td(t, rho, args), out); for n in range(1, len(L_list)):; #; # L_args[n][0] = the sparse data for a Qobj in super-operator form; # L_args[n][1] = function callback giving the coefficient; #; L = L_list[n][0]; L_td = L_list[n][1]; if L_list[n][2]:; spmvpy_csr(L.data, L.indices, L.indptr,; rho, L_td(t, rho, args)**2, out); else:; spmvpy_csr(L.data, L.indices, L.indptr,; rho, L_td(t, rho, args), out). return out. #; # evaluate dE(t)/dt according to the master equation using the; # [Qobj, function] style time dependence API, where E is a superoperator; #; def dsuper_list_td(t, y, L_list, args):. L = L_list[0][0] * L_list[0][1](t, args); for n in range(1, len(L_list)):; #; # L_args[n][0] = the sparse data for a Qobj in super-operator form; # L_args[n][1] = function callback giving the coefficient; #; if L_list[n][2]:; L = L + L_list[n][0] * (L_list[n][1](t, args)) ** 2; else:; L = L + L_list[n][0] * L_list[n][1](t, args). return _ode_super_func(t, y, L). def dsuper_list_td_with_state(t, y, L_list, args):. L = L_list[0][0] * L_list[0][1](t, y, args); for n in range(1, len(L_list)):; #; # L_args[n][0] = the sparse data for a Qobj in super-operator form; # L_args[n][1] = function callback giving the coefficient; #; if L_list[n][2]:; L = L + L_list[n][0] * (L_list[n][1](t, y, args)) ** 2; else:; L = L + L_list[n][0] * L_list[n][1](t, y, args). return _ode_super_func(t, y, L). # -----------------------------------------------------------------------------; # A time-dependent dissipative mast",MatchSource.WIKI,docs/4.2/modules/qutip/mesolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mesolve.html
https://qutip.org/docs/4.2/modules/qutip/mesolve.html:17572,Integrability,depend,dependent,17572,"; #; def dsuper_list_td(t, y, L_list, args):. L = L_list[0][0] * L_list[0][1](t, args); for n in range(1, len(L_list)):; #; # L_args[n][0] = the sparse data for a Qobj in super-operator form; # L_args[n][1] = function callback giving the coefficient; #; if L_list[n][2]:; L = L + L_list[n][0] * (L_list[n][1](t, args)) ** 2; else:; L = L + L_list[n][0] * L_list[n][1](t, args). return _ode_super_func(t, y, L). def dsuper_list_td_with_state(t, y, L_list, args):. L = L_list[0][0] * L_list[0][1](t, y, args); for n in range(1, len(L_list)):; #; # L_args[n][0] = the sparse data for a Qobj in super-operator form; # L_args[n][1] = function callback giving the coefficient; #; if L_list[n][2]:; L = L + L_list[n][0] * (L_list[n][1](t, y, args)) ** 2; else:; L = L + L_list[n][0] * L_list[n][1](t, y, args). return _ode_super_func(t, y, L). # -----------------------------------------------------------------------------; # A time-dependent dissipative master equation on the list-string format for; # cython compilation; #; def _mesolve_list_str_td(H_list, rho0, tlist, c_list, e_ops, args, opt,; progress_bar):; """"""; Internal function for solving the master equation. See mesolve for usage.; """""". if debug:; print(inspect.stack()[0][3]). #; # check initial state: must be a density matrix; #; if isket(rho0):; rho0 = rho0 * rho0.dag(). #; # construct liouvillian; #; Lconst = 0. Ldata = []; Linds = []; Lptrs = []; Lcoeff = []; Lobj = []. # loop over all hamiltonian terms, convert to superoperator form and; # add the data of sparse matrix representation to; for h_spec in H_list:. if isinstance(h_spec, Qobj):; h = h_spec. if isoper(h):; Lconst += -1j * (spre(h) - spost(h)); elif issuper(h):; Lconst += h; else:; raise TypeError(""Incorrect specification of time-dependent "" +; ""Hamiltonian (expected operator or "" +; ""superoperator)""). elif isinstance(h_spec, list):; h = h_spec[0]; h_coeff = h_spec[1]. if isoper(h):; L = -1j * (spre(h) - spost(h)); elif issuper(h):; L = h; else:; raise TypeError(""",MatchSource.WIKI,docs/4.2/modules/qutip/mesolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mesolve.html
https://qutip.org/docs/4.2/modules/qutip/mesolve.html:18408,Integrability,depend,dependent,18408,"t, y, args)) ** 2; else:; L = L + L_list[n][0] * L_list[n][1](t, y, args). return _ode_super_func(t, y, L). # -----------------------------------------------------------------------------; # A time-dependent dissipative master equation on the list-string format for; # cython compilation; #; def _mesolve_list_str_td(H_list, rho0, tlist, c_list, e_ops, args, opt,; progress_bar):; """"""; Internal function for solving the master equation. See mesolve for usage.; """""". if debug:; print(inspect.stack()[0][3]). #; # check initial state: must be a density matrix; #; if isket(rho0):; rho0 = rho0 * rho0.dag(). #; # construct liouvillian; #; Lconst = 0. Ldata = []; Linds = []; Lptrs = []; Lcoeff = []; Lobj = []. # loop over all hamiltonian terms, convert to superoperator form and; # add the data of sparse matrix representation to; for h_spec in H_list:. if isinstance(h_spec, Qobj):; h = h_spec. if isoper(h):; Lconst += -1j * (spre(h) - spost(h)); elif issuper(h):; Lconst += h; else:; raise TypeError(""Incorrect specification of time-dependent "" +; ""Hamiltonian (expected operator or "" +; ""superoperator)""). elif isinstance(h_spec, list):; h = h_spec[0]; h_coeff = h_spec[1]. if isoper(h):; L = -1j * (spre(h) - spost(h)); elif issuper(h):; L = h; else:; raise TypeError(""Incorrect specification of time-dependent "" +; ""Hamiltonian (expected operator or "" +; ""superoperator)""). Ldata.append(L.data.data); Linds.append(L.data.indices); Lptrs.append(L.data.indptr); if isinstance(h_coeff, Cubic_Spline):; Lobj.append(h_coeff.coeffs); Lcoeff.append(h_coeff). else:; raise TypeError(""Incorrect specification of time-dependent "" +; ""Hamiltonian (expected string format)""). # loop over all collapse operators; for c_spec in c_list:. if isinstance(c_spec, Qobj):; c = c_spec. if isoper(c):; cdc = c.dag() * c; Lconst += spre(c) * spost(c.dag()) - 0.5 * spre(cdc) \; - 0.5 * spost(cdc); elif issuper(c):; Lconst += c; else:; raise TypeError(""Incorrect specification of time-dependent "" +; ""Liouvillian (expec",MatchSource.WIKI,docs/4.2/modules/qutip/mesolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mesolve.html
https://qutip.org/docs/4.2/modules/qutip/mesolve.html:18678,Integrability,depend,dependent,18678,"compilation; #; def _mesolve_list_str_td(H_list, rho0, tlist, c_list, e_ops, args, opt,; progress_bar):; """"""; Internal function for solving the master equation. See mesolve for usage.; """""". if debug:; print(inspect.stack()[0][3]). #; # check initial state: must be a density matrix; #; if isket(rho0):; rho0 = rho0 * rho0.dag(). #; # construct liouvillian; #; Lconst = 0. Ldata = []; Linds = []; Lptrs = []; Lcoeff = []; Lobj = []. # loop over all hamiltonian terms, convert to superoperator form and; # add the data of sparse matrix representation to; for h_spec in H_list:. if isinstance(h_spec, Qobj):; h = h_spec. if isoper(h):; Lconst += -1j * (spre(h) - spost(h)); elif issuper(h):; Lconst += h; else:; raise TypeError(""Incorrect specification of time-dependent "" +; ""Hamiltonian (expected operator or "" +; ""superoperator)""). elif isinstance(h_spec, list):; h = h_spec[0]; h_coeff = h_spec[1]. if isoper(h):; L = -1j * (spre(h) - spost(h)); elif issuper(h):; L = h; else:; raise TypeError(""Incorrect specification of time-dependent "" +; ""Hamiltonian (expected operator or "" +; ""superoperator)""). Ldata.append(L.data.data); Linds.append(L.data.indices); Lptrs.append(L.data.indptr); if isinstance(h_coeff, Cubic_Spline):; Lobj.append(h_coeff.coeffs); Lcoeff.append(h_coeff). else:; raise TypeError(""Incorrect specification of time-dependent "" +; ""Hamiltonian (expected string format)""). # loop over all collapse operators; for c_spec in c_list:. if isinstance(c_spec, Qobj):; c = c_spec. if isoper(c):; cdc = c.dag() * c; Lconst += spre(c) * spost(c.dag()) - 0.5 * spre(cdc) \; - 0.5 * spost(cdc); elif issuper(c):; Lconst += c; else:; raise TypeError(""Incorrect specification of time-dependent "" +; ""Liouvillian (expected operator or "" +; ""superoperator)""). elif isinstance(c_spec, list):; c = c_spec[0]; c_coeff = c_spec[1]. if isoper(c):; cdc = c.dag() * c; L = spre(c) * spost(c.dag()) - 0.5 * spre(cdc) \; - 0.5 * spost(cdc); c_coeff = ""("" + c_coeff + "")**2""; elif issuper(c):; L = c; else:",MatchSource.WIKI,docs/4.2/modules/qutip/mesolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mesolve.html
https://qutip.org/docs/4.2/modules/qutip/mesolve.html:18986,Integrability,depend,dependent,18986,"onstruct liouvillian; #; Lconst = 0. Ldata = []; Linds = []; Lptrs = []; Lcoeff = []; Lobj = []. # loop over all hamiltonian terms, convert to superoperator form and; # add the data of sparse matrix representation to; for h_spec in H_list:. if isinstance(h_spec, Qobj):; h = h_spec. if isoper(h):; Lconst += -1j * (spre(h) - spost(h)); elif issuper(h):; Lconst += h; else:; raise TypeError(""Incorrect specification of time-dependent "" +; ""Hamiltonian (expected operator or "" +; ""superoperator)""). elif isinstance(h_spec, list):; h = h_spec[0]; h_coeff = h_spec[1]. if isoper(h):; L = -1j * (spre(h) - spost(h)); elif issuper(h):; L = h; else:; raise TypeError(""Incorrect specification of time-dependent "" +; ""Hamiltonian (expected operator or "" +; ""superoperator)""). Ldata.append(L.data.data); Linds.append(L.data.indices); Lptrs.append(L.data.indptr); if isinstance(h_coeff, Cubic_Spline):; Lobj.append(h_coeff.coeffs); Lcoeff.append(h_coeff). else:; raise TypeError(""Incorrect specification of time-dependent "" +; ""Hamiltonian (expected string format)""). # loop over all collapse operators; for c_spec in c_list:. if isinstance(c_spec, Qobj):; c = c_spec. if isoper(c):; cdc = c.dag() * c; Lconst += spre(c) * spost(c.dag()) - 0.5 * spre(cdc) \; - 0.5 * spost(cdc); elif issuper(c):; Lconst += c; else:; raise TypeError(""Incorrect specification of time-dependent "" +; ""Liouvillian (expected operator or "" +; ""superoperator)""). elif isinstance(c_spec, list):; c = c_spec[0]; c_coeff = c_spec[1]. if isoper(c):; cdc = c.dag() * c; L = spre(c) * spost(c.dag()) - 0.5 * spre(cdc) \; - 0.5 * spost(cdc); c_coeff = ""("" + c_coeff + "")**2""; elif issuper(c):; L = c; else:; raise TypeError(""Incorrect specification of time-dependent "" +; ""Liouvillian (expected operator or "" +; ""superoperator)""). Ldata.append(L.data.data); Linds.append(L.data.indices); Lptrs.append(L.data.indptr); Lcoeff.append(c_coeff). else:; raise TypeError(""Incorrect specification of time-dependent "" +; ""collapse operators (expected",MatchSource.WIKI,docs/4.2/modules/qutip/mesolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mesolve.html
https://qutip.org/docs/4.2/modules/qutip/mesolve.html:19340,Integrability,depend,dependent,19340," issuper(h):; Lconst += h; else:; raise TypeError(""Incorrect specification of time-dependent "" +; ""Hamiltonian (expected operator or "" +; ""superoperator)""). elif isinstance(h_spec, list):; h = h_spec[0]; h_coeff = h_spec[1]. if isoper(h):; L = -1j * (spre(h) - spost(h)); elif issuper(h):; L = h; else:; raise TypeError(""Incorrect specification of time-dependent "" +; ""Hamiltonian (expected operator or "" +; ""superoperator)""). Ldata.append(L.data.data); Linds.append(L.data.indices); Lptrs.append(L.data.indptr); if isinstance(h_coeff, Cubic_Spline):; Lobj.append(h_coeff.coeffs); Lcoeff.append(h_coeff). else:; raise TypeError(""Incorrect specification of time-dependent "" +; ""Hamiltonian (expected string format)""). # loop over all collapse operators; for c_spec in c_list:. if isinstance(c_spec, Qobj):; c = c_spec. if isoper(c):; cdc = c.dag() * c; Lconst += spre(c) * spost(c.dag()) - 0.5 * spre(cdc) \; - 0.5 * spost(cdc); elif issuper(c):; Lconst += c; else:; raise TypeError(""Incorrect specification of time-dependent "" +; ""Liouvillian (expected operator or "" +; ""superoperator)""). elif isinstance(c_spec, list):; c = c_spec[0]; c_coeff = c_spec[1]. if isoper(c):; cdc = c.dag() * c; L = spre(c) * spost(c.dag()) - 0.5 * spre(cdc) \; - 0.5 * spost(cdc); c_coeff = ""("" + c_coeff + "")**2""; elif issuper(c):; L = c; else:; raise TypeError(""Incorrect specification of time-dependent "" +; ""Liouvillian (expected operator or "" +; ""superoperator)""). Ldata.append(L.data.data); Linds.append(L.data.indices); Lptrs.append(L.data.indptr); Lcoeff.append(c_coeff). else:; raise TypeError(""Incorrect specification of time-dependent "" +; ""collapse operators (expected string format)""). # add the constant part of the lagrangian; if Lconst != 0:; Ldata.append(Lconst.data.data); Linds.append(Lconst.data.indices); Lptrs.append(Lconst.data.indptr); Lcoeff.append(""1.0""). # the total number of liouvillian terms (hamiltonian terms +; # collapse operators); n_L_terms = len(Ldata); ; # Check which components sh",MatchSource.WIKI,docs/4.2/modules/qutip/mesolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mesolve.html
https://qutip.org/docs/4.2/modules/qutip/mesolve.html:19701,Integrability,depend,dependent,19701," time-dependent "" +; ""Hamiltonian (expected operator or "" +; ""superoperator)""). Ldata.append(L.data.data); Linds.append(L.data.indices); Lptrs.append(L.data.indptr); if isinstance(h_coeff, Cubic_Spline):; Lobj.append(h_coeff.coeffs); Lcoeff.append(h_coeff). else:; raise TypeError(""Incorrect specification of time-dependent "" +; ""Hamiltonian (expected string format)""). # loop over all collapse operators; for c_spec in c_list:. if isinstance(c_spec, Qobj):; c = c_spec. if isoper(c):; cdc = c.dag() * c; Lconst += spre(c) * spost(c.dag()) - 0.5 * spre(cdc) \; - 0.5 * spost(cdc); elif issuper(c):; Lconst += c; else:; raise TypeError(""Incorrect specification of time-dependent "" +; ""Liouvillian (expected operator or "" +; ""superoperator)""). elif isinstance(c_spec, list):; c = c_spec[0]; c_coeff = c_spec[1]. if isoper(c):; cdc = c.dag() * c; L = spre(c) * spost(c.dag()) - 0.5 * spre(cdc) \; - 0.5 * spost(cdc); c_coeff = ""("" + c_coeff + "")**2""; elif issuper(c):; L = c; else:; raise TypeError(""Incorrect specification of time-dependent "" +; ""Liouvillian (expected operator or "" +; ""superoperator)""). Ldata.append(L.data.data); Linds.append(L.data.indices); Lptrs.append(L.data.indptr); Lcoeff.append(c_coeff). else:; raise TypeError(""Incorrect specification of time-dependent "" +; ""collapse operators (expected string format)""). # add the constant part of the lagrangian; if Lconst != 0:; Ldata.append(Lconst.data.data); Linds.append(Lconst.data.indices); Lptrs.append(Lconst.data.indptr); Lcoeff.append(""1.0""). # the total number of liouvillian terms (hamiltonian terms +; # collapse operators); n_L_terms = len(Ldata); ; # Check which components should use OPENMP; omp_components = None; if qset.has_openmp:; if opt.use_openmp:; omp_components = openmp_components(Lptrs). #; # setup ode args string: we expand the list Ldata, Linds and Lptrs into; # and explicit list of parameters; #; string_list = []; for k in range(n_L_terms):; string_list.append(""Ldata[%d], Linds[%d], Lptrs[%d]"" % (k, k, k",MatchSource.WIKI,docs/4.2/modules/qutip/mesolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mesolve.html
https://qutip.org/docs/4.2/modules/qutip/mesolve.html:19941,Integrability,depend,dependent,19941,"TypeError(""Incorrect specification of time-dependent "" +; ""Hamiltonian (expected string format)""). # loop over all collapse operators; for c_spec in c_list:. if isinstance(c_spec, Qobj):; c = c_spec. if isoper(c):; cdc = c.dag() * c; Lconst += spre(c) * spost(c.dag()) - 0.5 * spre(cdc) \; - 0.5 * spost(cdc); elif issuper(c):; Lconst += c; else:; raise TypeError(""Incorrect specification of time-dependent "" +; ""Liouvillian (expected operator or "" +; ""superoperator)""). elif isinstance(c_spec, list):; c = c_spec[0]; c_coeff = c_spec[1]. if isoper(c):; cdc = c.dag() * c; L = spre(c) * spost(c.dag()) - 0.5 * spre(cdc) \; - 0.5 * spost(cdc); c_coeff = ""("" + c_coeff + "")**2""; elif issuper(c):; L = c; else:; raise TypeError(""Incorrect specification of time-dependent "" +; ""Liouvillian (expected operator or "" +; ""superoperator)""). Ldata.append(L.data.data); Linds.append(L.data.indices); Lptrs.append(L.data.indptr); Lcoeff.append(c_coeff). else:; raise TypeError(""Incorrect specification of time-dependent "" +; ""collapse operators (expected string format)""). # add the constant part of the lagrangian; if Lconst != 0:; Ldata.append(Lconst.data.data); Linds.append(Lconst.data.indices); Lptrs.append(Lconst.data.indptr); Lcoeff.append(""1.0""). # the total number of liouvillian terms (hamiltonian terms +; # collapse operators); n_L_terms = len(Ldata); ; # Check which components should use OPENMP; omp_components = None; if qset.has_openmp:; if opt.use_openmp:; omp_components = openmp_components(Lptrs). #; # setup ode args string: we expand the list Ldata, Linds and Lptrs into; # and explicit list of parameters; #; string_list = []; for k in range(n_L_terms):; string_list.append(""Ldata[%d], Linds[%d], Lptrs[%d]"" % (k, k, k)); # Add object terms to end of ode args string; for k in range(len(Lobj)):; string_list.append(""Lobj[%d]"" % k); for name, value in args.items():; if isinstance(value, np.ndarray):; string_list.append(name); else:; string_list.append(str(value)); parameter_string = "","".j",MatchSource.WIKI,docs/4.2/modules/qutip/mesolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mesolve.html
https://qutip.org/docs/4.2/modules/qutip/mesolve.html:21569,Integrability,integrat,integrator,21569,"k in range(n_L_terms):; string_list.append(""Ldata[%d], Linds[%d], Lptrs[%d]"" % (k, k, k)); # Add object terms to end of ode args string; for k in range(len(Lobj)):; string_list.append(""Lobj[%d]"" % k); for name, value in args.items():; if isinstance(value, np.ndarray):; string_list.append(name); else:; string_list.append(str(value)); parameter_string = "","".join(string_list). #; # generate and compile new cython code if necessary; #; if not opt.rhs_reuse or config.tdfunc is None:; if opt.rhs_filename is None:; config.tdname = ""rhs"" + str(os.getpid()) + str(config.cgen_num); else:; config.tdname = opt.rhs_filename; cgen = Codegen(h_terms=n_L_terms, h_tdterms=Lcoeff, args=args,; config=config, use_openmp=opt.use_openmp,; omp_components=omp_components,; omp_threads=opt.openmp_threads); cgen.generate(config.tdname + "".pyx""). code = compile('from ' + config.tdname + ' import cy_td_ode_rhs',; '<string>', 'exec'); exec(code, globals()); config.tdfunc = cy_td_ode_rhs. #; # setup integrator; #; initial_vector = mat2vec(rho0.full()).ravel('F'); if issuper(rho0):; r = scipy.integrate.ode(_td_ode_rhs_super); code = compile('r.set_f_params([' + parameter_string + '])',; '<string>', 'exec'); else:; r = scipy.integrate.ode(config.tdfunc); code = compile('r.set_f_params(' + parameter_string + ')',; '<string>', 'exec'); r.set_integrator('zvode', method=opt.method, order=opt.order,; atol=opt.atol, rtol=opt.rtol, nsteps=opt.nsteps,; first_step=opt.first_step, min_step=opt.min_step,; max_step=opt.max_step); r.set_initial_value(initial_vector, tlist[0]). exec(code, locals(), args). #; # call generic ODE code; #; return _generic_ode_solve(r, rho0, tlist, e_ops, opt, progress_bar). def _td_ode_rhs_super(t, y, arglist):; N = int(np.sqrt(len(y))); out = np.zeros(N, dtype=complex); y2 = np.zeros(len(y), dtype=complex); for i in range(N):; out = cy_td_ode_rhs(t, y[i*N:(i+1)*N], *arglist); y2[i*N:(i+1)*N] = out; return y2. # ------------------------------------------------------------------------",MatchSource.WIKI,docs/4.2/modules/qutip/mesolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mesolve.html
https://qutip.org/docs/4.2/modules/qutip/mesolve.html:21663,Integrability,integrat,integrate,21663,"k, k)); # Add object terms to end of ode args string; for k in range(len(Lobj)):; string_list.append(""Lobj[%d]"" % k); for name, value in args.items():; if isinstance(value, np.ndarray):; string_list.append(name); else:; string_list.append(str(value)); parameter_string = "","".join(string_list). #; # generate and compile new cython code if necessary; #; if not opt.rhs_reuse or config.tdfunc is None:; if opt.rhs_filename is None:; config.tdname = ""rhs"" + str(os.getpid()) + str(config.cgen_num); else:; config.tdname = opt.rhs_filename; cgen = Codegen(h_terms=n_L_terms, h_tdterms=Lcoeff, args=args,; config=config, use_openmp=opt.use_openmp,; omp_components=omp_components,; omp_threads=opt.openmp_threads); cgen.generate(config.tdname + "".pyx""). code = compile('from ' + config.tdname + ' import cy_td_ode_rhs',; '<string>', 'exec'); exec(code, globals()); config.tdfunc = cy_td_ode_rhs. #; # setup integrator; #; initial_vector = mat2vec(rho0.full()).ravel('F'); if issuper(rho0):; r = scipy.integrate.ode(_td_ode_rhs_super); code = compile('r.set_f_params([' + parameter_string + '])',; '<string>', 'exec'); else:; r = scipy.integrate.ode(config.tdfunc); code = compile('r.set_f_params(' + parameter_string + ')',; '<string>', 'exec'); r.set_integrator('zvode', method=opt.method, order=opt.order,; atol=opt.atol, rtol=opt.rtol, nsteps=opt.nsteps,; first_step=opt.first_step, min_step=opt.min_step,; max_step=opt.max_step); r.set_initial_value(initial_vector, tlist[0]). exec(code, locals(), args). #; # call generic ODE code; #; return _generic_ode_solve(r, rho0, tlist, e_ops, opt, progress_bar). def _td_ode_rhs_super(t, y, arglist):; N = int(np.sqrt(len(y))); out = np.zeros(N, dtype=complex); y2 = np.zeros(len(y), dtype=complex); for i in range(N):; out = cy_td_ode_rhs(t, y[i*N:(i+1)*N], *arglist); y2[i*N:(i+1)*N] = out; return y2. # -----------------------------------------------------------------------------; # Master equation solver; #; def _mesolve_const(H, rho0, tlist, c_op_list, ",MatchSource.WIKI,docs/4.2/modules/qutip/mesolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mesolve.html
https://qutip.org/docs/4.2/modules/qutip/mesolve.html:21797,Integrability,integrat,integrate,21797,"in args.items():; if isinstance(value, np.ndarray):; string_list.append(name); else:; string_list.append(str(value)); parameter_string = "","".join(string_list). #; # generate and compile new cython code if necessary; #; if not opt.rhs_reuse or config.tdfunc is None:; if opt.rhs_filename is None:; config.tdname = ""rhs"" + str(os.getpid()) + str(config.cgen_num); else:; config.tdname = opt.rhs_filename; cgen = Codegen(h_terms=n_L_terms, h_tdterms=Lcoeff, args=args,; config=config, use_openmp=opt.use_openmp,; omp_components=omp_components,; omp_threads=opt.openmp_threads); cgen.generate(config.tdname + "".pyx""). code = compile('from ' + config.tdname + ' import cy_td_ode_rhs',; '<string>', 'exec'); exec(code, globals()); config.tdfunc = cy_td_ode_rhs. #; # setup integrator; #; initial_vector = mat2vec(rho0.full()).ravel('F'); if issuper(rho0):; r = scipy.integrate.ode(_td_ode_rhs_super); code = compile('r.set_f_params([' + parameter_string + '])',; '<string>', 'exec'); else:; r = scipy.integrate.ode(config.tdfunc); code = compile('r.set_f_params(' + parameter_string + ')',; '<string>', 'exec'); r.set_integrator('zvode', method=opt.method, order=opt.order,; atol=opt.atol, rtol=opt.rtol, nsteps=opt.nsteps,; first_step=opt.first_step, min_step=opt.min_step,; max_step=opt.max_step); r.set_initial_value(initial_vector, tlist[0]). exec(code, locals(), args). #; # call generic ODE code; #; return _generic_ode_solve(r, rho0, tlist, e_ops, opt, progress_bar). def _td_ode_rhs_super(t, y, arglist):; N = int(np.sqrt(len(y))); out = np.zeros(N, dtype=complex); y2 = np.zeros(len(y), dtype=complex); for i in range(N):; out = cy_td_ode_rhs(t, y[i*N:(i+1)*N], *arglist); y2[i*N:(i+1)*N] = out; return y2. # -----------------------------------------------------------------------------; # Master equation solver; #; def _mesolve_const(H, rho0, tlist, c_op_list, e_ops, args, opt,; progress_bar):; """"""; Evolve the density matrix using an ODE solver, for constant hamiltonian; and collapse operator",MatchSource.WIKI,docs/4.2/modules/qutip/mesolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mesolve.html
https://qutip.org/docs/4.2/modules/qutip/mesolve.html:23334,Integrability,integrat,integrator,23334,"(N, dtype=complex); y2 = np.zeros(len(y), dtype=complex); for i in range(N):; out = cy_td_ode_rhs(t, y[i*N:(i+1)*N], *arglist); y2[i*N:(i+1)*N] = out; return y2. # -----------------------------------------------------------------------------; # Master equation solver; #; def _mesolve_const(H, rho0, tlist, c_op_list, e_ops, args, opt,; progress_bar):; """"""; Evolve the density matrix using an ODE solver, for constant hamiltonian; and collapse operators.; """""". if debug:; print(inspect.stack()[0][3]). #; # check initial state; #; if isket(rho0):; # if initial state is a ket and no collapse operator where given,; # fall back on the unitary schrodinger equation solver; if len(c_op_list) == 0 and isoper(H):; return _sesolve_const(H, rho0, tlist, e_ops, args, opt,; progress_bar). # Got a wave function as initial state: convert to density matrix.; rho0 = ket2dm(rho0). #; # construct liouvillian; #; if opt.tidy:; H = H.tidyup(opt.atol). L = liouvillian(H, c_op_list); . #; # setup integrator; #; initial_vector = mat2vec(rho0.full()).ravel('F'); if issuper(rho0):; r = scipy.integrate.ode(_ode_super_func); r.set_f_params(L.data); else:; if opt.use_openmp and L.data.nnz >= qset.openmp_thresh:; r = scipy.integrate.ode(cy_ode_rhs_openmp); r.set_f_params(L.data.data, L.data.indices, L.data.indptr, ; opt.openmp_threads); else:; r = scipy.integrate.ode(cy_ode_rhs); r.set_f_params(L.data.data, L.data.indices, L.data.indptr); # r = scipy.integrate.ode(_ode_rho_test); # r.set_f_params(L.data); r.set_integrator('zvode', method=opt.method, order=opt.order,; atol=opt.atol, rtol=opt.rtol, nsteps=opt.nsteps,; first_step=opt.first_step, min_step=opt.min_step,; max_step=opt.max_step); r.set_initial_value(initial_vector, tlist[0]). #; # call generic ODE code; #; return _generic_ode_solve(r, rho0, tlist, e_ops, opt, progress_bar). #; # evaluate drho(t)/dt according to the master eqaution; # [no longer used, replaced by cython function]; #; def _ode_rho_func(t, rho, L):; return L * rho. def _ode_rho",MatchSource.WIKI,docs/4.2/modules/qutip/mesolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mesolve.html
https://qutip.org/docs/4.2/modules/qutip/mesolve.html:23428,Integrability,integrat,integrate,23428," cy_td_ode_rhs(t, y[i*N:(i+1)*N], *arglist); y2[i*N:(i+1)*N] = out; return y2. # -----------------------------------------------------------------------------; # Master equation solver; #; def _mesolve_const(H, rho0, tlist, c_op_list, e_ops, args, opt,; progress_bar):; """"""; Evolve the density matrix using an ODE solver, for constant hamiltonian; and collapse operators.; """""". if debug:; print(inspect.stack()[0][3]). #; # check initial state; #; if isket(rho0):; # if initial state is a ket and no collapse operator where given,; # fall back on the unitary schrodinger equation solver; if len(c_op_list) == 0 and isoper(H):; return _sesolve_const(H, rho0, tlist, e_ops, args, opt,; progress_bar). # Got a wave function as initial state: convert to density matrix.; rho0 = ket2dm(rho0). #; # construct liouvillian; #; if opt.tidy:; H = H.tidyup(opt.atol). L = liouvillian(H, c_op_list); . #; # setup integrator; #; initial_vector = mat2vec(rho0.full()).ravel('F'); if issuper(rho0):; r = scipy.integrate.ode(_ode_super_func); r.set_f_params(L.data); else:; if opt.use_openmp and L.data.nnz >= qset.openmp_thresh:; r = scipy.integrate.ode(cy_ode_rhs_openmp); r.set_f_params(L.data.data, L.data.indices, L.data.indptr, ; opt.openmp_threads); else:; r = scipy.integrate.ode(cy_ode_rhs); r.set_f_params(L.data.data, L.data.indices, L.data.indptr); # r = scipy.integrate.ode(_ode_rho_test); # r.set_f_params(L.data); r.set_integrator('zvode', method=opt.method, order=opt.order,; atol=opt.atol, rtol=opt.rtol, nsteps=opt.nsteps,; first_step=opt.first_step, min_step=opt.min_step,; max_step=opt.max_step); r.set_initial_value(initial_vector, tlist[0]). #; # call generic ODE code; #; return _generic_ode_solve(r, rho0, tlist, e_ops, opt, progress_bar). #; # evaluate drho(t)/dt according to the master eqaution; # [no longer used, replaced by cython function]; #; def _ode_rho_func(t, rho, L):; return L * rho. def _ode_rho_test(t, rho, data):; # for performance comparison of cython code; return data*(np",MatchSource.WIKI,docs/4.2/modules/qutip/mesolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mesolve.html
https://qutip.org/docs/4.2/modules/qutip/mesolve.html:23558,Integrability,integrat,integrate,23558,"----------------------------; # Master equation solver; #; def _mesolve_const(H, rho0, tlist, c_op_list, e_ops, args, opt,; progress_bar):; """"""; Evolve the density matrix using an ODE solver, for constant hamiltonian; and collapse operators.; """""". if debug:; print(inspect.stack()[0][3]). #; # check initial state; #; if isket(rho0):; # if initial state is a ket and no collapse operator where given,; # fall back on the unitary schrodinger equation solver; if len(c_op_list) == 0 and isoper(H):; return _sesolve_const(H, rho0, tlist, e_ops, args, opt,; progress_bar). # Got a wave function as initial state: convert to density matrix.; rho0 = ket2dm(rho0). #; # construct liouvillian; #; if opt.tidy:; H = H.tidyup(opt.atol). L = liouvillian(H, c_op_list); . #; # setup integrator; #; initial_vector = mat2vec(rho0.full()).ravel('F'); if issuper(rho0):; r = scipy.integrate.ode(_ode_super_func); r.set_f_params(L.data); else:; if opt.use_openmp and L.data.nnz >= qset.openmp_thresh:; r = scipy.integrate.ode(cy_ode_rhs_openmp); r.set_f_params(L.data.data, L.data.indices, L.data.indptr, ; opt.openmp_threads); else:; r = scipy.integrate.ode(cy_ode_rhs); r.set_f_params(L.data.data, L.data.indices, L.data.indptr); # r = scipy.integrate.ode(_ode_rho_test); # r.set_f_params(L.data); r.set_integrator('zvode', method=opt.method, order=opt.order,; atol=opt.atol, rtol=opt.rtol, nsteps=opt.nsteps,; first_step=opt.first_step, min_step=opt.min_step,; max_step=opt.max_step); r.set_initial_value(initial_vector, tlist[0]). #; # call generic ODE code; #; return _generic_ode_solve(r, rho0, tlist, e_ops, opt, progress_bar). #; # evaluate drho(t)/dt according to the master eqaution; # [no longer used, replaced by cython function]; #; def _ode_rho_func(t, rho, L):; return L * rho. def _ode_rho_test(t, rho, data):; # for performance comparison of cython code; return data*(np.transpose(rho)); #; # Evaluate d E(t)/dt for E a super-operator; #. def _ode_super_func(t, y, data):; ym = vec2mat(y); return (da",MatchSource.WIKI,docs/4.2/modules/qutip/mesolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mesolve.html
https://qutip.org/docs/4.2/modules/qutip/mesolve.html:23691,Integrability,integrat,integrate,23691,"bar):; """"""; Evolve the density matrix using an ODE solver, for constant hamiltonian; and collapse operators.; """""". if debug:; print(inspect.stack()[0][3]). #; # check initial state; #; if isket(rho0):; # if initial state is a ket and no collapse operator where given,; # fall back on the unitary schrodinger equation solver; if len(c_op_list) == 0 and isoper(H):; return _sesolve_const(H, rho0, tlist, e_ops, args, opt,; progress_bar). # Got a wave function as initial state: convert to density matrix.; rho0 = ket2dm(rho0). #; # construct liouvillian; #; if opt.tidy:; H = H.tidyup(opt.atol). L = liouvillian(H, c_op_list); . #; # setup integrator; #; initial_vector = mat2vec(rho0.full()).ravel('F'); if issuper(rho0):; r = scipy.integrate.ode(_ode_super_func); r.set_f_params(L.data); else:; if opt.use_openmp and L.data.nnz >= qset.openmp_thresh:; r = scipy.integrate.ode(cy_ode_rhs_openmp); r.set_f_params(L.data.data, L.data.indices, L.data.indptr, ; opt.openmp_threads); else:; r = scipy.integrate.ode(cy_ode_rhs); r.set_f_params(L.data.data, L.data.indices, L.data.indptr); # r = scipy.integrate.ode(_ode_rho_test); # r.set_f_params(L.data); r.set_integrator('zvode', method=opt.method, order=opt.order,; atol=opt.atol, rtol=opt.rtol, nsteps=opt.nsteps,; first_step=opt.first_step, min_step=opt.min_step,; max_step=opt.max_step); r.set_initial_value(initial_vector, tlist[0]). #; # call generic ODE code; #; return _generic_ode_solve(r, rho0, tlist, e_ops, opt, progress_bar). #; # evaluate drho(t)/dt according to the master eqaution; # [no longer used, replaced by cython function]; #; def _ode_rho_func(t, rho, L):; return L * rho. def _ode_rho_test(t, rho, data):; # for performance comparison of cython code; return data*(np.transpose(rho)); #; # Evaluate d E(t)/dt for E a super-operator; #. def _ode_super_func(t, y, data):; ym = vec2mat(y); return (data*ym).ravel('F'). # -----------------------------------------------------------------------------; # Master equation solver for pyth",MatchSource.WIKI,docs/4.2/modules/qutip/mesolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mesolve.html
https://qutip.org/docs/4.2/modules/qutip/mesolve.html:23790,Integrability,integrat,integrate,23790,"perators.; """""". if debug:; print(inspect.stack()[0][3]). #; # check initial state; #; if isket(rho0):; # if initial state is a ket and no collapse operator where given,; # fall back on the unitary schrodinger equation solver; if len(c_op_list) == 0 and isoper(H):; return _sesolve_const(H, rho0, tlist, e_ops, args, opt,; progress_bar). # Got a wave function as initial state: convert to density matrix.; rho0 = ket2dm(rho0). #; # construct liouvillian; #; if opt.tidy:; H = H.tidyup(opt.atol). L = liouvillian(H, c_op_list); . #; # setup integrator; #; initial_vector = mat2vec(rho0.full()).ravel('F'); if issuper(rho0):; r = scipy.integrate.ode(_ode_super_func); r.set_f_params(L.data); else:; if opt.use_openmp and L.data.nnz >= qset.openmp_thresh:; r = scipy.integrate.ode(cy_ode_rhs_openmp); r.set_f_params(L.data.data, L.data.indices, L.data.indptr, ; opt.openmp_threads); else:; r = scipy.integrate.ode(cy_ode_rhs); r.set_f_params(L.data.data, L.data.indices, L.data.indptr); # r = scipy.integrate.ode(_ode_rho_test); # r.set_f_params(L.data); r.set_integrator('zvode', method=opt.method, order=opt.order,; atol=opt.atol, rtol=opt.rtol, nsteps=opt.nsteps,; first_step=opt.first_step, min_step=opt.min_step,; max_step=opt.max_step); r.set_initial_value(initial_vector, tlist[0]). #; # call generic ODE code; #; return _generic_ode_solve(r, rho0, tlist, e_ops, opt, progress_bar). #; # evaluate drho(t)/dt according to the master eqaution; # [no longer used, replaced by cython function]; #; def _ode_rho_func(t, rho, L):; return L * rho. def _ode_rho_test(t, rho, data):; # for performance comparison of cython code; return data*(np.transpose(rho)); #; # Evaluate d E(t)/dt for E a super-operator; #. def _ode_super_func(t, y, data):; ym = vec2mat(y); return (data*ym).ravel('F'). # -----------------------------------------------------------------------------; # Master equation solver for python-function time-dependence.; #; def _mesolve_func_td(L_func, rho0, tlist, c_op_list, e_ops, args, ",MatchSource.WIKI,docs/4.2/modules/qutip/mesolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mesolve.html
https://qutip.org/docs/4.2/modules/qutip/mesolve.html:24713,Integrability,depend,dependence,24713," opt.openmp_threads); else:; r = scipy.integrate.ode(cy_ode_rhs); r.set_f_params(L.data.data, L.data.indices, L.data.indptr); # r = scipy.integrate.ode(_ode_rho_test); # r.set_f_params(L.data); r.set_integrator('zvode', method=opt.method, order=opt.order,; atol=opt.atol, rtol=opt.rtol, nsteps=opt.nsteps,; first_step=opt.first_step, min_step=opt.min_step,; max_step=opt.max_step); r.set_initial_value(initial_vector, tlist[0]). #; # call generic ODE code; #; return _generic_ode_solve(r, rho0, tlist, e_ops, opt, progress_bar). #; # evaluate drho(t)/dt according to the master eqaution; # [no longer used, replaced by cython function]; #; def _ode_rho_func(t, rho, L):; return L * rho. def _ode_rho_test(t, rho, data):; # for performance comparison of cython code; return data*(np.transpose(rho)); #; # Evaluate d E(t)/dt for E a super-operator; #. def _ode_super_func(t, y, data):; ym = vec2mat(y); return (data*ym).ravel('F'). # -----------------------------------------------------------------------------; # Master equation solver for python-function time-dependence.; #; def _mesolve_func_td(L_func, rho0, tlist, c_op_list, e_ops, args, opt,; progress_bar):; """"""; Evolve the density matrix using an ODE solver with time dependent; Hamiltonian.; """""". if debug:; print(inspect.stack()[0][3]). #; # check initial state; #; if isket(rho0):; rho0 = ket2dm(rho0). #; # construct liouvillian; #; new_args = None. if len(c_op_list) > 0:; L_data = liouvillian(None, c_op_list).data; else:; n, m = rho0.shape; if issuper(rho0):; L_data = sp.csr_matrix((n, m), dtype=complex); else:; L_data = sp.csr_matrix((n ** 2, m ** 2), dtype=complex). if type(args) is dict:; new_args = {}; for key in args:; if isinstance(args[key], Qobj):; if isoper(args[key]):; new_args[key] = (; -1j * (spre(args[key]) - spost(args[key]))); else:; new_args[key] = args[key]; else:; new_args[key] = args[key]. elif type(args) is list or type(args) is tuple:; new_args = []; for arg in args:; if isinstance(arg, Qobj):; if isoper(a",MatchSource.WIKI,docs/4.2/modules/qutip/mesolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mesolve.html
https://qutip.org/docs/4.2/modules/qutip/mesolve.html:24878,Integrability,depend,dependent,24878,"_test); # r.set_f_params(L.data); r.set_integrator('zvode', method=opt.method, order=opt.order,; atol=opt.atol, rtol=opt.rtol, nsteps=opt.nsteps,; first_step=opt.first_step, min_step=opt.min_step,; max_step=opt.max_step); r.set_initial_value(initial_vector, tlist[0]). #; # call generic ODE code; #; return _generic_ode_solve(r, rho0, tlist, e_ops, opt, progress_bar). #; # evaluate drho(t)/dt according to the master eqaution; # [no longer used, replaced by cython function]; #; def _ode_rho_func(t, rho, L):; return L * rho. def _ode_rho_test(t, rho, data):; # for performance comparison of cython code; return data*(np.transpose(rho)); #; # Evaluate d E(t)/dt for E a super-operator; #. def _ode_super_func(t, y, data):; ym = vec2mat(y); return (data*ym).ravel('F'). # -----------------------------------------------------------------------------; # Master equation solver for python-function time-dependence.; #; def _mesolve_func_td(L_func, rho0, tlist, c_op_list, e_ops, args, opt,; progress_bar):; """"""; Evolve the density matrix using an ODE solver with time dependent; Hamiltonian.; """""". if debug:; print(inspect.stack()[0][3]). #; # check initial state; #; if isket(rho0):; rho0 = ket2dm(rho0). #; # construct liouvillian; #; new_args = None. if len(c_op_list) > 0:; L_data = liouvillian(None, c_op_list).data; else:; n, m = rho0.shape; if issuper(rho0):; L_data = sp.csr_matrix((n, m), dtype=complex); else:; L_data = sp.csr_matrix((n ** 2, m ** 2), dtype=complex). if type(args) is dict:; new_args = {}; for key in args:; if isinstance(args[key], Qobj):; if isoper(args[key]):; new_args[key] = (; -1j * (spre(args[key]) - spost(args[key]))); else:; new_args[key] = args[key]; else:; new_args[key] = args[key]. elif type(args) is list or type(args) is tuple:; new_args = []; for arg in args:; if isinstance(arg, Qobj):; if isoper(arg):; new_args.append((-1j * (spre(arg) - spost(arg))).data); else:; new_args.append(arg.data); else:; new_args.append(arg). if type(args) is tuple:; new_args =",MatchSource.WIKI,docs/4.2/modules/qutip/mesolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mesolve.html
https://qutip.org/docs/4.2/modules/qutip/mesolve.html:25990,Integrability,integrat,integrator,25990,"dm(rho0). #; # construct liouvillian; #; new_args = None. if len(c_op_list) > 0:; L_data = liouvillian(None, c_op_list).data; else:; n, m = rho0.shape; if issuper(rho0):; L_data = sp.csr_matrix((n, m), dtype=complex); else:; L_data = sp.csr_matrix((n ** 2, m ** 2), dtype=complex). if type(args) is dict:; new_args = {}; for key in args:; if isinstance(args[key], Qobj):; if isoper(args[key]):; new_args[key] = (; -1j * (spre(args[key]) - spost(args[key]))); else:; new_args[key] = args[key]; else:; new_args[key] = args[key]. elif type(args) is list or type(args) is tuple:; new_args = []; for arg in args:; if isinstance(arg, Qobj):; if isoper(arg):; new_args.append((-1j * (spre(arg) - spost(arg))).data); else:; new_args.append(arg.data); else:; new_args.append(arg). if type(args) is tuple:; new_args = tuple(new_args); else:; if isinstance(args, Qobj):; if isoper(args):; new_args = (-1j * (spre(args) - spost(args))); else:; new_args = args; else:; new_args = args. #; # setup integrator; #; initial_vector = mat2vec(rho0.full()).ravel('F'); if issuper(rho0):; if not opt.rhs_with_state:; r = scipy.integrate.ode(_ode_super_func_td); else:; r = scipy.integrate.ode(_ode_super_func_td_with_state); else:; if not opt.rhs_with_state:; r = scipy.integrate.ode(cy_ode_rho_func_td); else:; r = scipy.integrate.ode(_ode_rho_func_td_with_state); r.set_integrator('zvode', method=opt.method, order=opt.order,; atol=opt.atol, rtol=opt.rtol, nsteps=opt.nsteps,; first_step=opt.first_step, min_step=opt.min_step,; max_step=opt.max_step); r.set_initial_value(initial_vector, tlist[0]); r.set_f_params(L_data, L_func, new_args). #; # call generic ODE code; #; return _generic_ode_solve(r, rho0, tlist, e_ops, opt, progress_bar). #; # evaluate drho(t)/dt according to the master equation; #; def _ode_rho_func_td(t, rho, L0, L_func, args):; L = L0 + L_func(t, args).data; return L * rho. #; # evaluate drho(t)/dt according to the master equation; #; def _ode_rho_func_td_with_state(t, rho, L0, L_func, args):;",MatchSource.WIKI,docs/4.2/modules/qutip/mesolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mesolve.html
https://qutip.org/docs/4.2/modules/qutip/mesolve.html:26112,Integrability,integrat,integrate,26112,"op_list).data; else:; n, m = rho0.shape; if issuper(rho0):; L_data = sp.csr_matrix((n, m), dtype=complex); else:; L_data = sp.csr_matrix((n ** 2, m ** 2), dtype=complex). if type(args) is dict:; new_args = {}; for key in args:; if isinstance(args[key], Qobj):; if isoper(args[key]):; new_args[key] = (; -1j * (spre(args[key]) - spost(args[key]))); else:; new_args[key] = args[key]; else:; new_args[key] = args[key]. elif type(args) is list or type(args) is tuple:; new_args = []; for arg in args:; if isinstance(arg, Qobj):; if isoper(arg):; new_args.append((-1j * (spre(arg) - spost(arg))).data); else:; new_args.append(arg.data); else:; new_args.append(arg). if type(args) is tuple:; new_args = tuple(new_args); else:; if isinstance(args, Qobj):; if isoper(args):; new_args = (-1j * (spre(args) - spost(args))); else:; new_args = args; else:; new_args = args. #; # setup integrator; #; initial_vector = mat2vec(rho0.full()).ravel('F'); if issuper(rho0):; if not opt.rhs_with_state:; r = scipy.integrate.ode(_ode_super_func_td); else:; r = scipy.integrate.ode(_ode_super_func_td_with_state); else:; if not opt.rhs_with_state:; r = scipy.integrate.ode(cy_ode_rho_func_td); else:; r = scipy.integrate.ode(_ode_rho_func_td_with_state); r.set_integrator('zvode', method=opt.method, order=opt.order,; atol=opt.atol, rtol=opt.rtol, nsteps=opt.nsteps,; first_step=opt.first_step, min_step=opt.min_step,; max_step=opt.max_step); r.set_initial_value(initial_vector, tlist[0]); r.set_f_params(L_data, L_func, new_args). #; # call generic ODE code; #; return _generic_ode_solve(r, rho0, tlist, e_ops, opt, progress_bar). #; # evaluate drho(t)/dt according to the master equation; #; def _ode_rho_func_td(t, rho, L0, L_func, args):; L = L0 + L_func(t, args).data; return L * rho. #; # evaluate drho(t)/dt according to the master equation; #; def _ode_rho_func_td_with_state(t, rho, L0, L_func, args):; L = L0 + L_func(t, rho, args).data; return L * rho. #; # evaluate dE(t)/dt according to the master equation, ",MatchSource.WIKI,docs/4.2/modules/qutip/mesolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mesolve.html
https://qutip.org/docs/4.2/modules/qutip/mesolve.html:26164,Integrability,integrat,integrate,26164,"rho0):; L_data = sp.csr_matrix((n, m), dtype=complex); else:; L_data = sp.csr_matrix((n ** 2, m ** 2), dtype=complex). if type(args) is dict:; new_args = {}; for key in args:; if isinstance(args[key], Qobj):; if isoper(args[key]):; new_args[key] = (; -1j * (spre(args[key]) - spost(args[key]))); else:; new_args[key] = args[key]; else:; new_args[key] = args[key]. elif type(args) is list or type(args) is tuple:; new_args = []; for arg in args:; if isinstance(arg, Qobj):; if isoper(arg):; new_args.append((-1j * (spre(arg) - spost(arg))).data); else:; new_args.append(arg.data); else:; new_args.append(arg). if type(args) is tuple:; new_args = tuple(new_args); else:; if isinstance(args, Qobj):; if isoper(args):; new_args = (-1j * (spre(args) - spost(args))); else:; new_args = args; else:; new_args = args. #; # setup integrator; #; initial_vector = mat2vec(rho0.full()).ravel('F'); if issuper(rho0):; if not opt.rhs_with_state:; r = scipy.integrate.ode(_ode_super_func_td); else:; r = scipy.integrate.ode(_ode_super_func_td_with_state); else:; if not opt.rhs_with_state:; r = scipy.integrate.ode(cy_ode_rho_func_td); else:; r = scipy.integrate.ode(_ode_rho_func_td_with_state); r.set_integrator('zvode', method=opt.method, order=opt.order,; atol=opt.atol, rtol=opt.rtol, nsteps=opt.nsteps,; first_step=opt.first_step, min_step=opt.min_step,; max_step=opt.max_step); r.set_initial_value(initial_vector, tlist[0]); r.set_f_params(L_data, L_func, new_args). #; # call generic ODE code; #; return _generic_ode_solve(r, rho0, tlist, e_ops, opt, progress_bar). #; # evaluate drho(t)/dt according to the master equation; #; def _ode_rho_func_td(t, rho, L0, L_func, args):; L = L0 + L_func(t, args).data; return L * rho. #; # evaluate drho(t)/dt according to the master equation; #; def _ode_rho_func_td_with_state(t, rho, L0, L_func, args):; L = L0 + L_func(t, rho, args).data; return L * rho. #; # evaluate dE(t)/dt according to the master equation, where E is a ; # superoperator; #; def _ode_super_fu",MatchSource.WIKI,docs/4.2/modules/qutip/mesolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mesolve.html
https://qutip.org/docs/4.2/modules/qutip/mesolve.html:26255,Integrability,integrat,integrate,26255,"2, m ** 2), dtype=complex). if type(args) is dict:; new_args = {}; for key in args:; if isinstance(args[key], Qobj):; if isoper(args[key]):; new_args[key] = (; -1j * (spre(args[key]) - spost(args[key]))); else:; new_args[key] = args[key]; else:; new_args[key] = args[key]. elif type(args) is list or type(args) is tuple:; new_args = []; for arg in args:; if isinstance(arg, Qobj):; if isoper(arg):; new_args.append((-1j * (spre(arg) - spost(arg))).data); else:; new_args.append(arg.data); else:; new_args.append(arg). if type(args) is tuple:; new_args = tuple(new_args); else:; if isinstance(args, Qobj):; if isoper(args):; new_args = (-1j * (spre(args) - spost(args))); else:; new_args = args; else:; new_args = args. #; # setup integrator; #; initial_vector = mat2vec(rho0.full()).ravel('F'); if issuper(rho0):; if not opt.rhs_with_state:; r = scipy.integrate.ode(_ode_super_func_td); else:; r = scipy.integrate.ode(_ode_super_func_td_with_state); else:; if not opt.rhs_with_state:; r = scipy.integrate.ode(cy_ode_rho_func_td); else:; r = scipy.integrate.ode(_ode_rho_func_td_with_state); r.set_integrator('zvode', method=opt.method, order=opt.order,; atol=opt.atol, rtol=opt.rtol, nsteps=opt.nsteps,; first_step=opt.first_step, min_step=opt.min_step,; max_step=opt.max_step); r.set_initial_value(initial_vector, tlist[0]); r.set_f_params(L_data, L_func, new_args). #; # call generic ODE code; #; return _generic_ode_solve(r, rho0, tlist, e_ops, opt, progress_bar). #; # evaluate drho(t)/dt according to the master equation; #; def _ode_rho_func_td(t, rho, L0, L_func, args):; L = L0 + L_func(t, args).data; return L * rho. #; # evaluate drho(t)/dt according to the master equation; #; def _ode_rho_func_td_with_state(t, rho, L0, L_func, args):; L = L0 + L_func(t, rho, args).data; return L * rho. #; # evaluate dE(t)/dt according to the master equation, where E is a ; # superoperator; #; def _ode_super_func_td(t, y, L0, L_func, args):; L = L0 + L_func(t, args).data; return _ode_super_func(t, y,",MatchSource.WIKI,docs/4.2/modules/qutip/mesolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mesolve.html
https://qutip.org/docs/4.2/modules/qutip/mesolve.html:26307,Integrability,integrat,integrate,26307,"new_args = {}; for key in args:; if isinstance(args[key], Qobj):; if isoper(args[key]):; new_args[key] = (; -1j * (spre(args[key]) - spost(args[key]))); else:; new_args[key] = args[key]; else:; new_args[key] = args[key]. elif type(args) is list or type(args) is tuple:; new_args = []; for arg in args:; if isinstance(arg, Qobj):; if isoper(arg):; new_args.append((-1j * (spre(arg) - spost(arg))).data); else:; new_args.append(arg.data); else:; new_args.append(arg). if type(args) is tuple:; new_args = tuple(new_args); else:; if isinstance(args, Qobj):; if isoper(args):; new_args = (-1j * (spre(args) - spost(args))); else:; new_args = args; else:; new_args = args. #; # setup integrator; #; initial_vector = mat2vec(rho0.full()).ravel('F'); if issuper(rho0):; if not opt.rhs_with_state:; r = scipy.integrate.ode(_ode_super_func_td); else:; r = scipy.integrate.ode(_ode_super_func_td_with_state); else:; if not opt.rhs_with_state:; r = scipy.integrate.ode(cy_ode_rho_func_td); else:; r = scipy.integrate.ode(_ode_rho_func_td_with_state); r.set_integrator('zvode', method=opt.method, order=opt.order,; atol=opt.atol, rtol=opt.rtol, nsteps=opt.nsteps,; first_step=opt.first_step, min_step=opt.min_step,; max_step=opt.max_step); r.set_initial_value(initial_vector, tlist[0]); r.set_f_params(L_data, L_func, new_args). #; # call generic ODE code; #; return _generic_ode_solve(r, rho0, tlist, e_ops, opt, progress_bar). #; # evaluate drho(t)/dt according to the master equation; #; def _ode_rho_func_td(t, rho, L0, L_func, args):; L = L0 + L_func(t, args).data; return L * rho. #; # evaluate drho(t)/dt according to the master equation; #; def _ode_rho_func_td_with_state(t, rho, L0, L_func, args):; L = L0 + L_func(t, rho, args).data; return L * rho. #; # evaluate dE(t)/dt according to the master equation, where E is a ; # superoperator; #; def _ode_super_func_td(t, y, L0, L_func, args):; L = L0 + L_func(t, args).data; return _ode_super_func(t, y, L). #; # evaluate dE(t)/dt according to the master ",MatchSource.WIKI,docs/4.2/modules/qutip/mesolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mesolve.html
https://qutip.org/docs/4.2/modules/qutip/mesolve.html:28932,Integrability,integrat,integration,28932,"re output array; #; n_tsteps = len(tlist); e_sops_data = []. output = Result(); output.solver = ""mesolve""; output.times = tlist. if opt.store_states:; output.states = []. if isinstance(e_ops, types.FunctionType):; n_expt_op = 0; expt_callback = True. elif isinstance(e_ops, list):. n_expt_op = len(e_ops); expt_callback = False. if n_expt_op == 0:; # fall back on storing states; output.states = []; opt.store_states = True; else:; output.expect = []; output.num_expect = n_expt_op; for op in e_ops:; e_sops_data.append(spre(op).data); if op.isherm and rho0.isherm:; output.expect.append(np.zeros(n_tsteps)); else:; output.expect.append(np.zeros(n_tsteps, dtype=complex)). else:; raise TypeError(""Expectation parameter must be a list or a function""). #; # start evolution; #; progress_bar.start(n_tsteps). rho = Qobj(rho0). dt = np.diff(tlist); for t_idx, t in enumerate(tlist):; progress_bar.update(t_idx). if not r.successful():; raise Exception(""ODE integration error: Try to increase ""; ""the allowed number of substeps by increasing ""; ""the nsteps parameter in the Options class.""). if opt.store_states or expt_callback:; rho.data = dense2D_to_fastcsr_fmode(vec2mat(r.y), rho.shape[0], rho.shape[1]). if opt.store_states:; output.states.append(Qobj(rho, isherm=True)). if expt_callback:; # use callback method; e_ops(t, rho). for m in range(n_expt_op):; if output.expect[m].dtype == complex:; output.expect[m][t_idx] = expect_rho_vec(e_sops_data[m],; r.y, 0); else:; output.expect[m][t_idx] = expect_rho_vec(e_sops_data[m],; r.y, 1). if t_idx < n_tsteps - 1:; r.integrate(r.t + dt[t_idx]). progress_bar.finished(). if (not opt.rhs_reuse) and (config.tdname is not None):; _cython_build_cleanup(config.tdname). if opt.store_final_state:; rho.data = dense2D_to_fastcsr_fmode(vec2mat(r.y), rho.shape[0], rho.shape[1]); output.final_state = Qobj(rho, dims=rho0.dims, isherm=True). return output. # -----------------------------------------------------------------------------; # Old style API below.;",MatchSource.WIKI,docs/4.2/modules/qutip/mesolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mesolve.html
https://qutip.org/docs/4.2/modules/qutip/mesolve.html:29545,Integrability,integrat,integrate,29545,"t.expect.append(np.zeros(n_tsteps)); else:; output.expect.append(np.zeros(n_tsteps, dtype=complex)). else:; raise TypeError(""Expectation parameter must be a list or a function""). #; # start evolution; #; progress_bar.start(n_tsteps). rho = Qobj(rho0). dt = np.diff(tlist); for t_idx, t in enumerate(tlist):; progress_bar.update(t_idx). if not r.successful():; raise Exception(""ODE integration error: Try to increase ""; ""the allowed number of substeps by increasing ""; ""the nsteps parameter in the Options class.""). if opt.store_states or expt_callback:; rho.data = dense2D_to_fastcsr_fmode(vec2mat(r.y), rho.shape[0], rho.shape[1]). if opt.store_states:; output.states.append(Qobj(rho, isherm=True)). if expt_callback:; # use callback method; e_ops(t, rho). for m in range(n_expt_op):; if output.expect[m].dtype == complex:; output.expect[m][t_idx] = expect_rho_vec(e_sops_data[m],; r.y, 0); else:; output.expect[m][t_idx] = expect_rho_vec(e_sops_data[m],; r.y, 1). if t_idx < n_tsteps - 1:; r.integrate(r.t + dt[t_idx]). progress_bar.finished(). if (not opt.rhs_reuse) and (config.tdname is not None):; _cython_build_cleanup(config.tdname). if opt.store_final_state:; rho.data = dense2D_to_fastcsr_fmode(vec2mat(r.y), rho.shape[0], rho.shape[1]); output.final_state = Qobj(rho, dims=rho0.dims, isherm=True). return output. # -----------------------------------------------------------------------------; # Old style API below.; # -----------------------------------------------------------------------------. # -----------------------------------------------------------------------------; # Master equation solver: deprecated in 2.0.0. No support for time-dependent; # collapse operators. Only used by the deprecated odesolve function.; #; def _mesolve_list_td(H_func, rho0, tlist, c_op_list, e_ops, args, opt,; progress_bar):; """"""; Evolve the density matrix using an ODE solver with time dependent; Hamiltonian.; """""". if debug:; print(inspect.stack()[0][3]). #; # check initial state; #; if isket(",MatchSource.WIKI,docs/4.2/modules/qutip/mesolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mesolve.html
https://qutip.org/docs/4.2/modules/qutip/mesolve.html:30209,Integrability,depend,dependent,30209,"tates.append(Qobj(rho, isherm=True)). if expt_callback:; # use callback method; e_ops(t, rho). for m in range(n_expt_op):; if output.expect[m].dtype == complex:; output.expect[m][t_idx] = expect_rho_vec(e_sops_data[m],; r.y, 0); else:; output.expect[m][t_idx] = expect_rho_vec(e_sops_data[m],; r.y, 1). if t_idx < n_tsteps - 1:; r.integrate(r.t + dt[t_idx]). progress_bar.finished(). if (not opt.rhs_reuse) and (config.tdname is not None):; _cython_build_cleanup(config.tdname). if opt.store_final_state:; rho.data = dense2D_to_fastcsr_fmode(vec2mat(r.y), rho.shape[0], rho.shape[1]); output.final_state = Qobj(rho, dims=rho0.dims, isherm=True). return output. # -----------------------------------------------------------------------------; # Old style API below.; # -----------------------------------------------------------------------------. # -----------------------------------------------------------------------------; # Master equation solver: deprecated in 2.0.0. No support for time-dependent; # collapse operators. Only used by the deprecated odesolve function.; #; def _mesolve_list_td(H_func, rho0, tlist, c_op_list, e_ops, args, opt,; progress_bar):; """"""; Evolve the density matrix using an ODE solver with time dependent; Hamiltonian.; """""". if debug:; print(inspect.stack()[0][3]). #; # check initial state; #; if isket(rho0):; # if initial state is a ket and no collapse operator where given,; # fall back on the unitary schrodinger equation solver; if len(c_op_list) == 0:; return _sesolve_list_td(H_func, rho0, tlist, e_ops, args, opt,; progress_bar). # Got a wave function as initial state: convert to density matrix.; rho0 = ket2dm(rho0). #; # construct liouvillian; #; if len(H_func) != 2:; raise TypeError('Time-dependent Hamiltonian list must have two terms.'); if not isinstance(H_func[0], (list, np.ndarray)) or len(H_func[0]) <= 1:; raise TypeError('Time-dependent Hamiltonians must be a list ' +; 'with two or more terms'); if (not isinstance(H_func[1], (list, np.ndarray)",MatchSource.WIKI,docs/4.2/modules/qutip/mesolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mesolve.html
https://qutip.org/docs/4.2/modules/qutip/mesolve.html:30442,Integrability,depend,dependent,30442,"output.expect[m][t_idx] = expect_rho_vec(e_sops_data[m],; r.y, 0); else:; output.expect[m][t_idx] = expect_rho_vec(e_sops_data[m],; r.y, 1). if t_idx < n_tsteps - 1:; r.integrate(r.t + dt[t_idx]). progress_bar.finished(). if (not opt.rhs_reuse) and (config.tdname is not None):; _cython_build_cleanup(config.tdname). if opt.store_final_state:; rho.data = dense2D_to_fastcsr_fmode(vec2mat(r.y), rho.shape[0], rho.shape[1]); output.final_state = Qobj(rho, dims=rho0.dims, isherm=True). return output. # -----------------------------------------------------------------------------; # Old style API below.; # -----------------------------------------------------------------------------. # -----------------------------------------------------------------------------; # Master equation solver: deprecated in 2.0.0. No support for time-dependent; # collapse operators. Only used by the deprecated odesolve function.; #; def _mesolve_list_td(H_func, rho0, tlist, c_op_list, e_ops, args, opt,; progress_bar):; """"""; Evolve the density matrix using an ODE solver with time dependent; Hamiltonian.; """""". if debug:; print(inspect.stack()[0][3]). #; # check initial state; #; if isket(rho0):; # if initial state is a ket and no collapse operator where given,; # fall back on the unitary schrodinger equation solver; if len(c_op_list) == 0:; return _sesolve_list_td(H_func, rho0, tlist, e_ops, args, opt,; progress_bar). # Got a wave function as initial state: convert to density matrix.; rho0 = ket2dm(rho0). #; # construct liouvillian; #; if len(H_func) != 2:; raise TypeError('Time-dependent Hamiltonian list must have two terms.'); if not isinstance(H_func[0], (list, np.ndarray)) or len(H_func[0]) <= 1:; raise TypeError('Time-dependent Hamiltonians must be a list ' +; 'with two or more terms'); if (not isinstance(H_func[1], (list, np.ndarray))) or \; (len(H_func[1]) != (len(H_func[0]) - 1)):; raise TypeError('Time-dependent coefficients must be list with ' +; 'length N-1 where N is the number of ' +; ",MatchSource.WIKI,docs/4.2/modules/qutip/mesolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mesolve.html
https://qutip.org/docs/4.2/modules/qutip/mesolve.html:30950,Integrability,depend,dependent,30950,"-------------------; # Old style API below.; # -----------------------------------------------------------------------------. # -----------------------------------------------------------------------------; # Master equation solver: deprecated in 2.0.0. No support for time-dependent; # collapse operators. Only used by the deprecated odesolve function.; #; def _mesolve_list_td(H_func, rho0, tlist, c_op_list, e_ops, args, opt,; progress_bar):; """"""; Evolve the density matrix using an ODE solver with time dependent; Hamiltonian.; """""". if debug:; print(inspect.stack()[0][3]). #; # check initial state; #; if isket(rho0):; # if initial state is a ket and no collapse operator where given,; # fall back on the unitary schrodinger equation solver; if len(c_op_list) == 0:; return _sesolve_list_td(H_func, rho0, tlist, e_ops, args, opt,; progress_bar). # Got a wave function as initial state: convert to density matrix.; rho0 = ket2dm(rho0). #; # construct liouvillian; #; if len(H_func) != 2:; raise TypeError('Time-dependent Hamiltonian list must have two terms.'); if not isinstance(H_func[0], (list, np.ndarray)) or len(H_func[0]) <= 1:; raise TypeError('Time-dependent Hamiltonians must be a list ' +; 'with two or more terms'); if (not isinstance(H_func[1], (list, np.ndarray))) or \; (len(H_func[1]) != (len(H_func[0]) - 1)):; raise TypeError('Time-dependent coefficients must be list with ' +; 'length N-1 where N is the number of ' +; 'Hamiltonian terms.'). if opt.rhs_reuse and config.tdfunc is None:; rhs_generate(H_func, args). lenh = len(H_func[0]); if opt.tidy:; H_func[0] = [(H_func[0][k]).tidyup() for k in range(lenh)]; L_func = [[liouvillian(H_func[0][0], c_op_list)], H_func[1]]; for m in range(1, lenh):; L_func[0].append(liouvillian(H_func[0][m], [])). # create data arrays for time-dependent RHS function; Ldata = [L_func[0][k].data.data for k in range(lenh)]; Linds = [L_func[0][k].data.indices for k in range(lenh)]; Lptrs = [L_func[0][k].data.indptr for k in range(lenh)]; # set",MatchSource.WIKI,docs/4.2/modules/qutip/mesolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mesolve.html
https://qutip.org/docs/4.2/modules/qutip/mesolve.html:31097,Integrability,depend,dependent,31097,"-----------------; # Master equation solver: deprecated in 2.0.0. No support for time-dependent; # collapse operators. Only used by the deprecated odesolve function.; #; def _mesolve_list_td(H_func, rho0, tlist, c_op_list, e_ops, args, opt,; progress_bar):; """"""; Evolve the density matrix using an ODE solver with time dependent; Hamiltonian.; """""". if debug:; print(inspect.stack()[0][3]). #; # check initial state; #; if isket(rho0):; # if initial state is a ket and no collapse operator where given,; # fall back on the unitary schrodinger equation solver; if len(c_op_list) == 0:; return _sesolve_list_td(H_func, rho0, tlist, e_ops, args, opt,; progress_bar). # Got a wave function as initial state: convert to density matrix.; rho0 = ket2dm(rho0). #; # construct liouvillian; #; if len(H_func) != 2:; raise TypeError('Time-dependent Hamiltonian list must have two terms.'); if not isinstance(H_func[0], (list, np.ndarray)) or len(H_func[0]) <= 1:; raise TypeError('Time-dependent Hamiltonians must be a list ' +; 'with two or more terms'); if (not isinstance(H_func[1], (list, np.ndarray))) or \; (len(H_func[1]) != (len(H_func[0]) - 1)):; raise TypeError('Time-dependent coefficients must be list with ' +; 'length N-1 where N is the number of ' +; 'Hamiltonian terms.'). if opt.rhs_reuse and config.tdfunc is None:; rhs_generate(H_func, args). lenh = len(H_func[0]); if opt.tidy:; H_func[0] = [(H_func[0][k]).tidyup() for k in range(lenh)]; L_func = [[liouvillian(H_func[0][0], c_op_list)], H_func[1]]; for m in range(1, lenh):; L_func[0].append(liouvillian(H_func[0][m], [])). # create data arrays for time-dependent RHS function; Ldata = [L_func[0][k].data.data for k in range(lenh)]; Linds = [L_func[0][k].data.indices for k in range(lenh)]; Lptrs = [L_func[0][k].data.indptr for k in range(lenh)]; # setup ode args string; string = """"; for k in range(lenh):; string += (""Ldata[%d], Linds[%d], Lptrs[%d],"" % (k, k, k)). if args:; td_consts = args.items(); for elem in td_consts:; string += st",MatchSource.WIKI,docs/4.2/modules/qutip/mesolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mesolve.html
https://qutip.org/docs/4.2/modules/qutip/mesolve.html:31289,Integrability,depend,dependent,31289,"olve_list_td(H_func, rho0, tlist, c_op_list, e_ops, args, opt,; progress_bar):; """"""; Evolve the density matrix using an ODE solver with time dependent; Hamiltonian.; """""". if debug:; print(inspect.stack()[0][3]). #; # check initial state; #; if isket(rho0):; # if initial state is a ket and no collapse operator where given,; # fall back on the unitary schrodinger equation solver; if len(c_op_list) == 0:; return _sesolve_list_td(H_func, rho0, tlist, e_ops, args, opt,; progress_bar). # Got a wave function as initial state: convert to density matrix.; rho0 = ket2dm(rho0). #; # construct liouvillian; #; if len(H_func) != 2:; raise TypeError('Time-dependent Hamiltonian list must have two terms.'); if not isinstance(H_func[0], (list, np.ndarray)) or len(H_func[0]) <= 1:; raise TypeError('Time-dependent Hamiltonians must be a list ' +; 'with two or more terms'); if (not isinstance(H_func[1], (list, np.ndarray))) or \; (len(H_func[1]) != (len(H_func[0]) - 1)):; raise TypeError('Time-dependent coefficients must be list with ' +; 'length N-1 where N is the number of ' +; 'Hamiltonian terms.'). if opt.rhs_reuse and config.tdfunc is None:; rhs_generate(H_func, args). lenh = len(H_func[0]); if opt.tidy:; H_func[0] = [(H_func[0][k]).tidyup() for k in range(lenh)]; L_func = [[liouvillian(H_func[0][0], c_op_list)], H_func[1]]; for m in range(1, lenh):; L_func[0].append(liouvillian(H_func[0][m], [])). # create data arrays for time-dependent RHS function; Ldata = [L_func[0][k].data.data for k in range(lenh)]; Linds = [L_func[0][k].data.indices for k in range(lenh)]; Lptrs = [L_func[0][k].data.indptr for k in range(lenh)]; # setup ode args string; string = """"; for k in range(lenh):; string += (""Ldata[%d], Linds[%d], Lptrs[%d],"" % (k, k, k)). if args:; td_consts = args.items(); for elem in td_consts:; string += str(elem[1]); if elem != td_consts[-1]:; string += ("",""). # run code generator; if not opt.rhs_reuse or config.tdfunc is None:; if opt.rhs_filename is None:; config.tdname = ""rhs"" ",MatchSource.WIKI,docs/4.2/modules/qutip/mesolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mesolve.html
https://qutip.org/docs/4.2/modules/qutip/mesolve.html:31737,Integrability,depend,dependent,31737," tlist, e_ops, args, opt,; progress_bar). # Got a wave function as initial state: convert to density matrix.; rho0 = ket2dm(rho0). #; # construct liouvillian; #; if len(H_func) != 2:; raise TypeError('Time-dependent Hamiltonian list must have two terms.'); if not isinstance(H_func[0], (list, np.ndarray)) or len(H_func[0]) <= 1:; raise TypeError('Time-dependent Hamiltonians must be a list ' +; 'with two or more terms'); if (not isinstance(H_func[1], (list, np.ndarray))) or \; (len(H_func[1]) != (len(H_func[0]) - 1)):; raise TypeError('Time-dependent coefficients must be list with ' +; 'length N-1 where N is the number of ' +; 'Hamiltonian terms.'). if opt.rhs_reuse and config.tdfunc is None:; rhs_generate(H_func, args). lenh = len(H_func[0]); if opt.tidy:; H_func[0] = [(H_func[0][k]).tidyup() for k in range(lenh)]; L_func = [[liouvillian(H_func[0][0], c_op_list)], H_func[1]]; for m in range(1, lenh):; L_func[0].append(liouvillian(H_func[0][m], [])). # create data arrays for time-dependent RHS function; Ldata = [L_func[0][k].data.data for k in range(lenh)]; Linds = [L_func[0][k].data.indices for k in range(lenh)]; Lptrs = [L_func[0][k].data.indptr for k in range(lenh)]; # setup ode args string; string = """"; for k in range(lenh):; string += (""Ldata[%d], Linds[%d], Lptrs[%d],"" % (k, k, k)). if args:; td_consts = args.items(); for elem in td_consts:; string += str(elem[1]); if elem != td_consts[-1]:; string += ("",""). # run code generator; if not opt.rhs_reuse or config.tdfunc is None:; if opt.rhs_filename is None:; config.tdname = ""rhs"" + str(os.getpid()) + str(config.cgen_num); else:; config.tdname = opt.rhs_filename; cgen = Codegen(h_terms=n_L_terms, h_tdterms=Lcoeff, args=args,; config=config); cgen.generate(config.tdname + "".pyx""). code = compile('from ' + config.tdname + ' import cy_td_ode_rhs',; '<string>', 'exec'); exec(code, globals()); config.tdfunc = cy_td_ode_rhs. #; # setup integrator; #; initial_vector = mat2vec(rho0.full()).ravel(); r = scipy.integrate.ode(c",MatchSource.WIKI,docs/4.2/modules/qutip/mesolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mesolve.html
https://qutip.org/docs/4.2/modules/qutip/mesolve.html:32658,Integrability,integrat,integrator,32658,"(liouvillian(H_func[0][m], [])). # create data arrays for time-dependent RHS function; Ldata = [L_func[0][k].data.data for k in range(lenh)]; Linds = [L_func[0][k].data.indices for k in range(lenh)]; Lptrs = [L_func[0][k].data.indptr for k in range(lenh)]; # setup ode args string; string = """"; for k in range(lenh):; string += (""Ldata[%d], Linds[%d], Lptrs[%d],"" % (k, k, k)). if args:; td_consts = args.items(); for elem in td_consts:; string += str(elem[1]); if elem != td_consts[-1]:; string += ("",""). # run code generator; if not opt.rhs_reuse or config.tdfunc is None:; if opt.rhs_filename is None:; config.tdname = ""rhs"" + str(os.getpid()) + str(config.cgen_num); else:; config.tdname = opt.rhs_filename; cgen = Codegen(h_terms=n_L_terms, h_tdterms=Lcoeff, args=args,; config=config); cgen.generate(config.tdname + "".pyx""). code = compile('from ' + config.tdname + ' import cy_td_ode_rhs',; '<string>', 'exec'); exec(code, globals()); config.tdfunc = cy_td_ode_rhs. #; # setup integrator; #; initial_vector = mat2vec(rho0.full()).ravel(); r = scipy.integrate.ode(config.tdfunc); r.set_integrator('zvode', method=opt.method, order=opt.order,; atol=opt.atol, rtol=opt.rtol, nsteps=opt.nsteps,; first_step=opt.first_step, min_step=opt.min_step,; max_step=opt.max_step); r.set_initial_value(initial_vector, tlist[0]); code = compile('r.set_f_params(' + string + ')', '<string>', 'exec'); exec(code). #; # call generic ODE code; #; return _generic_ode_solve(r, rho0, tlist, e_ops, opt, progress_bar). # -----------------------------------------------------------------------------; # pass on to wavefunction solver or master equation solver depending on whether; # any collapse operators were given.; #; def odesolve(H, rho0, tlist, c_op_list, e_ops, args=None, options=None):; """"""; Master equation evolution of a density matrix for a given Hamiltonian. Evolution of a state vector or density matrix (`rho0`) for a given; Hamiltonian (`H`) and set of collapse operators (`c_op_list`), by; integratin",MatchSource.WIKI,docs/4.2/modules/qutip/mesolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mesolve.html
https://qutip.org/docs/4.2/modules/qutip/mesolve.html:32730,Integrability,integrat,integrate,32730,"e-dependent RHS function; Ldata = [L_func[0][k].data.data for k in range(lenh)]; Linds = [L_func[0][k].data.indices for k in range(lenh)]; Lptrs = [L_func[0][k].data.indptr for k in range(lenh)]; # setup ode args string; string = """"; for k in range(lenh):; string += (""Ldata[%d], Linds[%d], Lptrs[%d],"" % (k, k, k)). if args:; td_consts = args.items(); for elem in td_consts:; string += str(elem[1]); if elem != td_consts[-1]:; string += ("",""). # run code generator; if not opt.rhs_reuse or config.tdfunc is None:; if opt.rhs_filename is None:; config.tdname = ""rhs"" + str(os.getpid()) + str(config.cgen_num); else:; config.tdname = opt.rhs_filename; cgen = Codegen(h_terms=n_L_terms, h_tdterms=Lcoeff, args=args,; config=config); cgen.generate(config.tdname + "".pyx""). code = compile('from ' + config.tdname + ' import cy_td_ode_rhs',; '<string>', 'exec'); exec(code, globals()); config.tdfunc = cy_td_ode_rhs. #; # setup integrator; #; initial_vector = mat2vec(rho0.full()).ravel(); r = scipy.integrate.ode(config.tdfunc); r.set_integrator('zvode', method=opt.method, order=opt.order,; atol=opt.atol, rtol=opt.rtol, nsteps=opt.nsteps,; first_step=opt.first_step, min_step=opt.min_step,; max_step=opt.max_step); r.set_initial_value(initial_vector, tlist[0]); code = compile('r.set_f_params(' + string + ')', '<string>', 'exec'); exec(code). #; # call generic ODE code; #; return _generic_ode_solve(r, rho0, tlist, e_ops, opt, progress_bar). # -----------------------------------------------------------------------------; # pass on to wavefunction solver or master equation solver depending on whether; # any collapse operators were given.; #; def odesolve(H, rho0, tlist, c_op_list, e_ops, args=None, options=None):; """"""; Master equation evolution of a density matrix for a given Hamiltonian. Evolution of a state vector or density matrix (`rho0`) for a given; Hamiltonian (`H`) and set of collapse operators (`c_op_list`), by; integrating the set of ordinary differential equations that define the",MatchSource.WIKI,docs/4.2/modules/qutip/mesolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mesolve.html
https://qutip.org/docs/4.2/modules/qutip/mesolve.html:33317,Integrability,depend,depending,33317,"ne:; config.tdname = ""rhs"" + str(os.getpid()) + str(config.cgen_num); else:; config.tdname = opt.rhs_filename; cgen = Codegen(h_terms=n_L_terms, h_tdterms=Lcoeff, args=args,; config=config); cgen.generate(config.tdname + "".pyx""). code = compile('from ' + config.tdname + ' import cy_td_ode_rhs',; '<string>', 'exec'); exec(code, globals()); config.tdfunc = cy_td_ode_rhs. #; # setup integrator; #; initial_vector = mat2vec(rho0.full()).ravel(); r = scipy.integrate.ode(config.tdfunc); r.set_integrator('zvode', method=opt.method, order=opt.order,; atol=opt.atol, rtol=opt.rtol, nsteps=opt.nsteps,; first_step=opt.first_step, min_step=opt.min_step,; max_step=opt.max_step); r.set_initial_value(initial_vector, tlist[0]); code = compile('r.set_f_params(' + string + ')', '<string>', 'exec'); exec(code). #; # call generic ODE code; #; return _generic_ode_solve(r, rho0, tlist, e_ops, opt, progress_bar). # -----------------------------------------------------------------------------; # pass on to wavefunction solver or master equation solver depending on whether; # any collapse operators were given.; #; def odesolve(H, rho0, tlist, c_op_list, e_ops, args=None, options=None):; """"""; Master equation evolution of a density matrix for a given Hamiltonian. Evolution of a state vector or density matrix (`rho0`) for a given; Hamiltonian (`H`) and set of collapse operators (`c_op_list`), by; integrating the set of ordinary differential equations that define the; system. The output is either the state vector at arbitrary points in time; (`tlist`), or the expectation values of the supplied operators; (`e_ops`). For problems with time-dependent Hamiltonians, `H` can be a callback; function that takes two arguments, time and `args`, and returns the; Hamiltonian at that point in time. `args` is a list of parameters that is; passed to the callback function `H` (only used for time-dependent; Hamiltonians). Parameters; ----------. H : :class:`qutip.qobj`; system Hamiltonian, or a callback function f",MatchSource.WIKI,docs/4.2/modules/qutip/mesolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mesolve.html
https://qutip.org/docs/4.2/modules/qutip/mesolve.html:33665,Integrability,integrat,integrating,33665,"d_ode_rhs. #; # setup integrator; #; initial_vector = mat2vec(rho0.full()).ravel(); r = scipy.integrate.ode(config.tdfunc); r.set_integrator('zvode', method=opt.method, order=opt.order,; atol=opt.atol, rtol=opt.rtol, nsteps=opt.nsteps,; first_step=opt.first_step, min_step=opt.min_step,; max_step=opt.max_step); r.set_initial_value(initial_vector, tlist[0]); code = compile('r.set_f_params(' + string + ')', '<string>', 'exec'); exec(code). #; # call generic ODE code; #; return _generic_ode_solve(r, rho0, tlist, e_ops, opt, progress_bar). # -----------------------------------------------------------------------------; # pass on to wavefunction solver or master equation solver depending on whether; # any collapse operators were given.; #; def odesolve(H, rho0, tlist, c_op_list, e_ops, args=None, options=None):; """"""; Master equation evolution of a density matrix for a given Hamiltonian. Evolution of a state vector or density matrix (`rho0`) for a given; Hamiltonian (`H`) and set of collapse operators (`c_op_list`), by; integrating the set of ordinary differential equations that define the; system. The output is either the state vector at arbitrary points in time; (`tlist`), or the expectation values of the supplied operators; (`e_ops`). For problems with time-dependent Hamiltonians, `H` can be a callback; function that takes two arguments, time and `args`, and returns the; Hamiltonian at that point in time. `args` is a list of parameters that is; passed to the callback function `H` (only used for time-dependent; Hamiltonians). Parameters; ----------. H : :class:`qutip.qobj`; system Hamiltonian, or a callback function for time-dependent; Hamiltonians. rho0 : :class:`qutip.qobj`; initial density matrix or state vector (ket). tlist : *list* / *array*; list of times for :math:`t`. c_op_list : list of :class:`qutip.qobj`; list of collapse operators. e_ops : list of :class:`qutip.qobj` / callback function; list of operators for which to evaluate expectation values. args : *dicti",MatchSource.WIKI,docs/4.2/modules/qutip/mesolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mesolve.html
https://qutip.org/docs/4.2/modules/qutip/mesolve.html:33910,Integrability,depend,dependent,33910,"al_vector, tlist[0]); code = compile('r.set_f_params(' + string + ')', '<string>', 'exec'); exec(code). #; # call generic ODE code; #; return _generic_ode_solve(r, rho0, tlist, e_ops, opt, progress_bar). # -----------------------------------------------------------------------------; # pass on to wavefunction solver or master equation solver depending on whether; # any collapse operators were given.; #; def odesolve(H, rho0, tlist, c_op_list, e_ops, args=None, options=None):; """"""; Master equation evolution of a density matrix for a given Hamiltonian. Evolution of a state vector or density matrix (`rho0`) for a given; Hamiltonian (`H`) and set of collapse operators (`c_op_list`), by; integrating the set of ordinary differential equations that define the; system. The output is either the state vector at arbitrary points in time; (`tlist`), or the expectation values of the supplied operators; (`e_ops`). For problems with time-dependent Hamiltonians, `H` can be a callback; function that takes two arguments, time and `args`, and returns the; Hamiltonian at that point in time. `args` is a list of parameters that is; passed to the callback function `H` (only used for time-dependent; Hamiltonians). Parameters; ----------. H : :class:`qutip.qobj`; system Hamiltonian, or a callback function for time-dependent; Hamiltonians. rho0 : :class:`qutip.qobj`; initial density matrix or state vector (ket). tlist : *list* / *array*; list of times for :math:`t`. c_op_list : list of :class:`qutip.qobj`; list of collapse operators. e_ops : list of :class:`qutip.qobj` / callback function; list of operators for which to evaluate expectation values. args : *dictionary*; dictionary of parameters for time-dependent Hamiltonians and; collapse operators. options : :class:`qutip.Options`; with options for the ODE solver. Returns; -------; output :array; Expectation values of wavefunctions/density matrices; for the times specified by `tlist`. Notes; -----; On using callback function: odesolve trans",MatchSource.WIKI,docs/4.2/modules/qutip/mesolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mesolve.html
https://qutip.org/docs/4.2/modules/qutip/mesolve.html:34157,Integrability,depend,dependent,34157,"ic_ode_solve(r, rho0, tlist, e_ops, opt, progress_bar). # -----------------------------------------------------------------------------; # pass on to wavefunction solver or master equation solver depending on whether; # any collapse operators were given.; #; def odesolve(H, rho0, tlist, c_op_list, e_ops, args=None, options=None):; """"""; Master equation evolution of a density matrix for a given Hamiltonian. Evolution of a state vector or density matrix (`rho0`) for a given; Hamiltonian (`H`) and set of collapse operators (`c_op_list`), by; integrating the set of ordinary differential equations that define the; system. The output is either the state vector at arbitrary points in time; (`tlist`), or the expectation values of the supplied operators; (`e_ops`). For problems with time-dependent Hamiltonians, `H` can be a callback; function that takes two arguments, time and `args`, and returns the; Hamiltonian at that point in time. `args` is a list of parameters that is; passed to the callback function `H` (only used for time-dependent; Hamiltonians). Parameters; ----------. H : :class:`qutip.qobj`; system Hamiltonian, or a callback function for time-dependent; Hamiltonians. rho0 : :class:`qutip.qobj`; initial density matrix or state vector (ket). tlist : *list* / *array*; list of times for :math:`t`. c_op_list : list of :class:`qutip.qobj`; list of collapse operators. e_ops : list of :class:`qutip.qobj` / callback function; list of operators for which to evaluate expectation values. args : *dictionary*; dictionary of parameters for time-dependent Hamiltonians and; collapse operators. options : :class:`qutip.Options`; with options for the ODE solver. Returns; -------; output :array; Expectation values of wavefunctions/density matrices; for the times specified by `tlist`. Notes; -----; On using callback function: odesolve transforms all :class:`qutip.qobj`; objects to sparse matrices before handing the problem to the integrator; function. In order for your callback functio",MatchSource.WIKI,docs/4.2/modules/qutip/mesolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mesolve.html
https://qutip.org/docs/4.2/modules/qutip/mesolve.html:34284,Integrability,depend,dependent,34284,"n to wavefunction solver or master equation solver depending on whether; # any collapse operators were given.; #; def odesolve(H, rho0, tlist, c_op_list, e_ops, args=None, options=None):; """"""; Master equation evolution of a density matrix for a given Hamiltonian. Evolution of a state vector or density matrix (`rho0`) for a given; Hamiltonian (`H`) and set of collapse operators (`c_op_list`), by; integrating the set of ordinary differential equations that define the; system. The output is either the state vector at arbitrary points in time; (`tlist`), or the expectation values of the supplied operators; (`e_ops`). For problems with time-dependent Hamiltonians, `H` can be a callback; function that takes two arguments, time and `args`, and returns the; Hamiltonian at that point in time. `args` is a list of parameters that is; passed to the callback function `H` (only used for time-dependent; Hamiltonians). Parameters; ----------. H : :class:`qutip.qobj`; system Hamiltonian, or a callback function for time-dependent; Hamiltonians. rho0 : :class:`qutip.qobj`; initial density matrix or state vector (ket). tlist : *list* / *array*; list of times for :math:`t`. c_op_list : list of :class:`qutip.qobj`; list of collapse operators. e_ops : list of :class:`qutip.qobj` / callback function; list of operators for which to evaluate expectation values. args : *dictionary*; dictionary of parameters for time-dependent Hamiltonians and; collapse operators. options : :class:`qutip.Options`; with options for the ODE solver. Returns; -------; output :array; Expectation values of wavefunctions/density matrices; for the times specified by `tlist`. Notes; -----; On using callback function: odesolve transforms all :class:`qutip.qobj`; objects to sparse matrices before handing the problem to the integrator; function. In order for your callback function to work correctly, pass; all :class:`qutip.qobj` objects that are used in constructing the; Hamiltonian via args. odesolve will check for :class",MatchSource.WIKI,docs/4.2/modules/qutip/mesolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mesolve.html
https://qutip.org/docs/4.2/modules/qutip/mesolve.html:34679,Integrability,depend,dependent,34679,"ng the set of ordinary differential equations that define the; system. The output is either the state vector at arbitrary points in time; (`tlist`), or the expectation values of the supplied operators; (`e_ops`). For problems with time-dependent Hamiltonians, `H` can be a callback; function that takes two arguments, time and `args`, and returns the; Hamiltonian at that point in time. `args` is a list of parameters that is; passed to the callback function `H` (only used for time-dependent; Hamiltonians). Parameters; ----------. H : :class:`qutip.qobj`; system Hamiltonian, or a callback function for time-dependent; Hamiltonians. rho0 : :class:`qutip.qobj`; initial density matrix or state vector (ket). tlist : *list* / *array*; list of times for :math:`t`. c_op_list : list of :class:`qutip.qobj`; list of collapse operators. e_ops : list of :class:`qutip.qobj` / callback function; list of operators for which to evaluate expectation values. args : *dictionary*; dictionary of parameters for time-dependent Hamiltonians and; collapse operators. options : :class:`qutip.Options`; with options for the ODE solver. Returns; -------; output :array; Expectation values of wavefunctions/density matrices; for the times specified by `tlist`. Notes; -----; On using callback function: odesolve transforms all :class:`qutip.qobj`; objects to sparse matrices before handing the problem to the integrator; function. In order for your callback function to work correctly, pass; all :class:`qutip.qobj` objects that are used in constructing the; Hamiltonian via args. odesolve will check for :class:`qutip.qobj` in; `args` and handle the conversion to sparse matrices. All other; :class:`qutip.qobj` objects that are not passed via `args` will be; passed on to the integrator to scipy who will raise an NotImplemented; exception. Deprecated in QuTiP 2.0.0. Use :func:`mesolve` instead. """""". warnings.warn(""odesolve is deprecated since 2.0.0. Use mesolve instead."",; DeprecationWarning). if debug:; print(in",MatchSource.WIKI,docs/4.2/modules/qutip/mesolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mesolve.html
https://qutip.org/docs/4.2/modules/qutip/mesolve.html:35065,Integrability,integrat,integrator,35065,"that point in time. `args` is a list of parameters that is; passed to the callback function `H` (only used for time-dependent; Hamiltonians). Parameters; ----------. H : :class:`qutip.qobj`; system Hamiltonian, or a callback function for time-dependent; Hamiltonians. rho0 : :class:`qutip.qobj`; initial density matrix or state vector (ket). tlist : *list* / *array*; list of times for :math:`t`. c_op_list : list of :class:`qutip.qobj`; list of collapse operators. e_ops : list of :class:`qutip.qobj` / callback function; list of operators for which to evaluate expectation values. args : *dictionary*; dictionary of parameters for time-dependent Hamiltonians and; collapse operators. options : :class:`qutip.Options`; with options for the ODE solver. Returns; -------; output :array; Expectation values of wavefunctions/density matrices; for the times specified by `tlist`. Notes; -----; On using callback function: odesolve transforms all :class:`qutip.qobj`; objects to sparse matrices before handing the problem to the integrator; function. In order for your callback function to work correctly, pass; all :class:`qutip.qobj` objects that are used in constructing the; Hamiltonian via args. odesolve will check for :class:`qutip.qobj` in; `args` and handle the conversion to sparse matrices. All other; :class:`qutip.qobj` objects that are not passed via `args` will be; passed on to the integrator to scipy who will raise an NotImplemented; exception. Deprecated in QuTiP 2.0.0. Use :func:`mesolve` instead. """""". warnings.warn(""odesolve is deprecated since 2.0.0. Use mesolve instead."",; DeprecationWarning). if debug:; print(inspect.stack()[0][3]). if options is None:; options = Options(). if (c_op_list and len(c_op_list) > 0) or not isket(rho0):; if isinstance(H, list):; output = _mesolve_list_td(H, rho0, tlist,; c_op_list, e_ops, args, options,; BaseProgressBar()); if isinstance(H, (types.FunctionType,; types.BuiltinFunctionType, partial)):; output = _mesolve_func_td(H, rho0, tlist,; c",MatchSource.WIKI,docs/4.2/modules/qutip/mesolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mesolve.html
https://qutip.org/docs/4.2/modules/qutip/mesolve.html:35434,Integrability,integrat,integrator,35434,"th:`t`. c_op_list : list of :class:`qutip.qobj`; list of collapse operators. e_ops : list of :class:`qutip.qobj` / callback function; list of operators for which to evaluate expectation values. args : *dictionary*; dictionary of parameters for time-dependent Hamiltonians and; collapse operators. options : :class:`qutip.Options`; with options for the ODE solver. Returns; -------; output :array; Expectation values of wavefunctions/density matrices; for the times specified by `tlist`. Notes; -----; On using callback function: odesolve transforms all :class:`qutip.qobj`; objects to sparse matrices before handing the problem to the integrator; function. In order for your callback function to work correctly, pass; all :class:`qutip.qobj` objects that are used in constructing the; Hamiltonian via args. odesolve will check for :class:`qutip.qobj` in; `args` and handle the conversion to sparse matrices. All other; :class:`qutip.qobj` objects that are not passed via `args` will be; passed on to the integrator to scipy who will raise an NotImplemented; exception. Deprecated in QuTiP 2.0.0. Use :func:`mesolve` instead. """""". warnings.warn(""odesolve is deprecated since 2.0.0. Use mesolve instead."",; DeprecationWarning). if debug:; print(inspect.stack()[0][3]). if options is None:; options = Options(). if (c_op_list and len(c_op_list) > 0) or not isket(rho0):; if isinstance(H, list):; output = _mesolve_list_td(H, rho0, tlist,; c_op_list, e_ops, args, options,; BaseProgressBar()); if isinstance(H, (types.FunctionType,; types.BuiltinFunctionType, partial)):; output = _mesolve_func_td(H, rho0, tlist,; c_op_list, e_ops, args, options,; BaseProgressBar()); else:; output = _mesolve_const(H, rho0, tlist,; c_op_list, e_ops, args, options,; BaseProgressBar()); else:; if isinstance(H, list):; output = _sesolve_list_td(H, rho0, tlist, e_ops, args, options,; BaseProgressBar()); if isinstance(H, (types.FunctionType,; types.BuiltinFunctionType, partial)):; output = _sesolve_func_td(H, rho0, tlis",MatchSource.WIKI,docs/4.2/modules/qutip/mesolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mesolve.html
https://qutip.org/docs/4.2/modules/qutip/mesolve.html:2574,Modifiability,config,config,2574," DAMAGES (INCLUDING, BUT NOT; # LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,; # DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY; # THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT; # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE; # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.; ###############################################################################; """"""; This module provides solvers for the Lindblad master equation and von Neumann; equation.; """""". __all__ = ['mesolve', 'odesolve']. import os; import types; from functools import partial; import numpy as np; import scipy.sparse as sp; import scipy.integrate; import warnings; import qutip.settings as qset; from qutip.qobj import Qobj, isket, isoper, issuper; from qutip.superoperator import spre, spost, liouvillian, mat2vec, vec2mat; from qutip.expect import expect_rho_vec; from qutip.solver import Options, Result, config, _solver_safety_check; from qutip.cy.spmatfuncs import cy_ode_rhs, cy_ode_rho_func_td, spmvpy_csr; from qutip.cy.spconvert import dense2D_to_fastcsr_fmode; from qutip.cy.codegen import Codegen; from qutip.cy.utilities import _cython_build_cleanup; from qutip.rhs_generate import rhs_generate; from qutip.states import ket2dm; from qutip.rhs_generate import _td_format_check, _td_wrap_array_str; from qutip.interpolate import Cubic_Spline; from qutip.settings import debug. from qutip.sesolve import (_sesolve_list_func_td, _sesolve_list_str_td,; _sesolve_list_td, _sesolve_func_td, _sesolve_const). from qutip.ui.progressbar import BaseProgressBar, TextProgressBar. from qutip.cy.openmp.utilities import check_use_openmp, openmp_components; if qset.has_openmp:; from qutip.cy.openmp.parfuncs import cy_ode_rhs_openmp. if debug:; import inspect. # -----------------------------------------------------------------------------; # pass on to wavefunction solver or master equation solver depending on ",MatchSource.WIKI,docs/4.2/modules/qutip/mesolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mesolve.html
https://qutip.org/docs/4.2/modules/qutip/mesolve.html:4145,Modifiability,evolve,evolved,4145,"olve_func_td, _sesolve_const). from qutip.ui.progressbar import BaseProgressBar, TextProgressBar. from qutip.cy.openmp.utilities import check_use_openmp, openmp_components; if qset.has_openmp:; from qutip.cy.openmp.parfuncs import cy_ode_rhs_openmp. if debug:; import inspect. # -----------------------------------------------------------------------------; # pass on to wavefunction solver or master equation solver depending on whether; # any collapse operators were given.; #; [docs]def mesolve(H, rho0, tlist, c_ops=[], e_ops=[], args={}, options=None,; progress_bar=None, _safe_mode=True):; """"""; Master equation evolution of a density matrix for a given Hamiltonian and; set of collapse operators, or a Liouvillian. Evolve the state vector or density matrix (`rho0`) using a given; Hamiltonian (`H`) and an [optional] set of collapse operators; (`c_ops`), by integrating the set of ordinary differential equations; that define the system. In the absence of collapse operators the system is; evolved according to the unitary evolution of the Hamiltonian. The output is either the state vector at arbitrary points in time; (`tlist`), or the expectation values of the supplied operators; (`e_ops`). If e_ops is a callback function, it is invoked for each; time in `tlist` with time and the state as arguments, and the function; does not use any return values. If either `H` or the Qobj elements in `c_ops` are superoperators, they; will be treated as direct contributions to the total system Liouvillian.; This allows to solve master equations that are not on standard Lindblad; form by passing a custom Liouvillian in place of either the `H` or `c_ops`; elements. **Time-dependent operators**. For time-dependent problems, `H` and `c_ops` can be callback; functions that takes two arguments, time and `args`, and returns the; Hamiltonian or Liouvillian for the system at that point in time; (*callback format*). Alternatively, `H` and `c_ops` can be a specified in a nested-list format; where each ",MatchSource.WIKI,docs/4.2/modules/qutip/mesolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mesolve.html
https://qutip.org/docs/4.2/modules/qutip/mesolve.html:9839,Modifiability,config,config,9839," a single operator; # if so convert it to a list containing only that operator; if isinstance(c_ops, Qobj):; c_ops = [c_ops]. if isinstance(e_ops, Qobj):; e_ops = [e_ops]. if isinstance(e_ops, dict):; e_ops_dict = e_ops; e_ops = [e for e in e_ops.values()]; else:; e_ops_dict = None; ; if _safe_mode:; _solver_safety_check(H, rho0, c_ops, e_ops, args); ; if progress_bar is None:; progress_bar = BaseProgressBar(); elif progress_bar is True:; progress_bar = TextProgressBar(). # check if rho0 is a superoperator, in which case e_ops argument should; # be empty, i.e., e_ops = []; if issuper(rho0) and not e_ops == []:; raise TypeError(""Must have e_ops = [] when initial condition rho0 is"" +; "" a superoperator.""). # convert array based time-dependence to string format; H, c_ops, args = _td_wrap_array_str(H, c_ops, args, tlist). # check for type (if any) of time-dependent inputs; _, n_func, n_str = _td_format_check(H, c_ops). if options is None:; options = Options(). if (not options.rhs_reuse) or (not config.tdfunc):; # reset config collapse and time-dependence flags to default values; config.reset(); ; #check if should use OPENMP; check_use_openmp(options); ; ; res = None. #; # dispatch the appropriate solver; #; if ((c_ops and len(c_ops) > 0); or (not isket(rho0)); or (isinstance(H, Qobj) and issuper(H)); or (isinstance(H, list) and; isinstance(H[0], Qobj) and issuper(H[0]))):. #; # we have collapse operators, or rho0 is not a ket,; # or H is a Liouvillian; #. #; # find out if we are dealing with all-constant hamiltonian and; # collapse operators or if we have at least one time-dependent; # operator. Then delegate to appropriate solver...; #. if isinstance(H, Qobj):; # constant hamiltonian; if n_func == 0 and n_str == 0:; # constant collapse operators; res = _mesolve_const(H, rho0, tlist, c_ops,; e_ops, args, options,; progress_bar); elif n_str > 0:; # constant hamiltonian but time-dependent collapse; # operators in list string format; res = _mesolve_list_str_td([H], rho0, t",MatchSource.WIKI,docs/4.2/modules/qutip/mesolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mesolve.html
https://qutip.org/docs/4.2/modules/qutip/mesolve.html:9864,Modifiability,config,config,9864,"ing only that operator; if isinstance(c_ops, Qobj):; c_ops = [c_ops]. if isinstance(e_ops, Qobj):; e_ops = [e_ops]. if isinstance(e_ops, dict):; e_ops_dict = e_ops; e_ops = [e for e in e_ops.values()]; else:; e_ops_dict = None; ; if _safe_mode:; _solver_safety_check(H, rho0, c_ops, e_ops, args); ; if progress_bar is None:; progress_bar = BaseProgressBar(); elif progress_bar is True:; progress_bar = TextProgressBar(). # check if rho0 is a superoperator, in which case e_ops argument should; # be empty, i.e., e_ops = []; if issuper(rho0) and not e_ops == []:; raise TypeError(""Must have e_ops = [] when initial condition rho0 is"" +; "" a superoperator.""). # convert array based time-dependence to string format; H, c_ops, args = _td_wrap_array_str(H, c_ops, args, tlist). # check for type (if any) of time-dependent inputs; _, n_func, n_str = _td_format_check(H, c_ops). if options is None:; options = Options(). if (not options.rhs_reuse) or (not config.tdfunc):; # reset config collapse and time-dependence flags to default values; config.reset(); ; #check if should use OPENMP; check_use_openmp(options); ; ; res = None. #; # dispatch the appropriate solver; #; if ((c_ops and len(c_ops) > 0); or (not isket(rho0)); or (isinstance(H, Qobj) and issuper(H)); or (isinstance(H, list) and; isinstance(H[0], Qobj) and issuper(H[0]))):. #; # we have collapse operators, or rho0 is not a ket,; # or H is a Liouvillian; #. #; # find out if we are dealing with all-constant hamiltonian and; # collapse operators or if we have at least one time-dependent; # operator. Then delegate to appropriate solver...; #. if isinstance(H, Qobj):; # constant hamiltonian; if n_func == 0 and n_str == 0:; # constant collapse operators; res = _mesolve_const(H, rho0, tlist, c_ops,; e_ops, args, options,; progress_bar); elif n_str > 0:; # constant hamiltonian but time-dependent collapse; # operators in list string format; res = _mesolve_list_str_td([H], rho0, tlist, c_ops,; e_ops, args, options,; progress_bar); elif",MatchSource.WIKI,docs/4.2/modules/qutip/mesolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mesolve.html
https://qutip.org/docs/4.2/modules/qutip/mesolve.html:9925,Modifiability,config,config,9925,"ing only that operator; if isinstance(c_ops, Qobj):; c_ops = [c_ops]. if isinstance(e_ops, Qobj):; e_ops = [e_ops]. if isinstance(e_ops, dict):; e_ops_dict = e_ops; e_ops = [e for e in e_ops.values()]; else:; e_ops_dict = None; ; if _safe_mode:; _solver_safety_check(H, rho0, c_ops, e_ops, args); ; if progress_bar is None:; progress_bar = BaseProgressBar(); elif progress_bar is True:; progress_bar = TextProgressBar(). # check if rho0 is a superoperator, in which case e_ops argument should; # be empty, i.e., e_ops = []; if issuper(rho0) and not e_ops == []:; raise TypeError(""Must have e_ops = [] when initial condition rho0 is"" +; "" a superoperator.""). # convert array based time-dependence to string format; H, c_ops, args = _td_wrap_array_str(H, c_ops, args, tlist). # check for type (if any) of time-dependent inputs; _, n_func, n_str = _td_format_check(H, c_ops). if options is None:; options = Options(). if (not options.rhs_reuse) or (not config.tdfunc):; # reset config collapse and time-dependence flags to default values; config.reset(); ; #check if should use OPENMP; check_use_openmp(options); ; ; res = None. #; # dispatch the appropriate solver; #; if ((c_ops and len(c_ops) > 0); or (not isket(rho0)); or (isinstance(H, Qobj) and issuper(H)); or (isinstance(H, list) and; isinstance(H[0], Qobj) and issuper(H[0]))):. #; # we have collapse operators, or rho0 is not a ket,; # or H is a Liouvillian; #. #; # find out if we are dealing with all-constant hamiltonian and; # collapse operators or if we have at least one time-dependent; # operator. Then delegate to appropriate solver...; #. if isinstance(H, Qobj):; # constant hamiltonian; if n_func == 0 and n_str == 0:; # constant collapse operators; res = _mesolve_const(H, rho0, tlist, c_ops,; e_ops, args, options,; progress_bar); elif n_str > 0:; # constant hamiltonian but time-dependent collapse; # operators in list string format; res = _mesolve_list_str_td([H], rho0, tlist, c_ops,; e_ops, args, options,; progress_bar); elif",MatchSource.WIKI,docs/4.2/modules/qutip/mesolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mesolve.html
https://qutip.org/docs/4.2/modules/qutip/mesolve.html:21045,Modifiability,config,config,21045,"ian; if Lconst != 0:; Ldata.append(Lconst.data.data); Linds.append(Lconst.data.indices); Lptrs.append(Lconst.data.indptr); Lcoeff.append(""1.0""). # the total number of liouvillian terms (hamiltonian terms +; # collapse operators); n_L_terms = len(Ldata); ; # Check which components should use OPENMP; omp_components = None; if qset.has_openmp:; if opt.use_openmp:; omp_components = openmp_components(Lptrs). #; # setup ode args string: we expand the list Ldata, Linds and Lptrs into; # and explicit list of parameters; #; string_list = []; for k in range(n_L_terms):; string_list.append(""Ldata[%d], Linds[%d], Lptrs[%d]"" % (k, k, k)); # Add object terms to end of ode args string; for k in range(len(Lobj)):; string_list.append(""Lobj[%d]"" % k); for name, value in args.items():; if isinstance(value, np.ndarray):; string_list.append(name); else:; string_list.append(str(value)); parameter_string = "","".join(string_list). #; # generate and compile new cython code if necessary; #; if not opt.rhs_reuse or config.tdfunc is None:; if opt.rhs_filename is None:; config.tdname = ""rhs"" + str(os.getpid()) + str(config.cgen_num); else:; config.tdname = opt.rhs_filename; cgen = Codegen(h_terms=n_L_terms, h_tdterms=Lcoeff, args=args,; config=config, use_openmp=opt.use_openmp,; omp_components=omp_components,; omp_threads=opt.openmp_threads); cgen.generate(config.tdname + "".pyx""). code = compile('from ' + config.tdname + ' import cy_td_ode_rhs',; '<string>', 'exec'); exec(code, globals()); config.tdfunc = cy_td_ode_rhs. #; # setup integrator; #; initial_vector = mat2vec(rho0.full()).ravel('F'); if issuper(rho0):; r = scipy.integrate.ode(_td_ode_rhs_super); code = compile('r.set_f_params([' + parameter_string + '])',; '<string>', 'exec'); else:; r = scipy.integrate.ode(config.tdfunc); code = compile('r.set_f_params(' + parameter_string + ')',; '<string>', 'exec'); r.set_integrator('zvode', method=opt.method, order=opt.order,; atol=opt.atol, rtol=opt.rtol, nsteps=opt.nsteps,; first_step=opt.first_",MatchSource.WIKI,docs/4.2/modules/qutip/mesolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mesolve.html
https://qutip.org/docs/4.2/modules/qutip/mesolve.html:21099,Modifiability,config,config,21099,"ta); Linds.append(Lconst.data.indices); Lptrs.append(Lconst.data.indptr); Lcoeff.append(""1.0""). # the total number of liouvillian terms (hamiltonian terms +; # collapse operators); n_L_terms = len(Ldata); ; # Check which components should use OPENMP; omp_components = None; if qset.has_openmp:; if opt.use_openmp:; omp_components = openmp_components(Lptrs). #; # setup ode args string: we expand the list Ldata, Linds and Lptrs into; # and explicit list of parameters; #; string_list = []; for k in range(n_L_terms):; string_list.append(""Ldata[%d], Linds[%d], Lptrs[%d]"" % (k, k, k)); # Add object terms to end of ode args string; for k in range(len(Lobj)):; string_list.append(""Lobj[%d]"" % k); for name, value in args.items():; if isinstance(value, np.ndarray):; string_list.append(name); else:; string_list.append(str(value)); parameter_string = "","".join(string_list). #; # generate and compile new cython code if necessary; #; if not opt.rhs_reuse or config.tdfunc is None:; if opt.rhs_filename is None:; config.tdname = ""rhs"" + str(os.getpid()) + str(config.cgen_num); else:; config.tdname = opt.rhs_filename; cgen = Codegen(h_terms=n_L_terms, h_tdterms=Lcoeff, args=args,; config=config, use_openmp=opt.use_openmp,; omp_components=omp_components,; omp_threads=opt.openmp_threads); cgen.generate(config.tdname + "".pyx""). code = compile('from ' + config.tdname + ' import cy_td_ode_rhs',; '<string>', 'exec'); exec(code, globals()); config.tdfunc = cy_td_ode_rhs. #; # setup integrator; #; initial_vector = mat2vec(rho0.full()).ravel('F'); if issuper(rho0):; r = scipy.integrate.ode(_td_ode_rhs_super); code = compile('r.set_f_params([' + parameter_string + '])',; '<string>', 'exec'); else:; r = scipy.integrate.ode(config.tdfunc); code = compile('r.set_f_params(' + parameter_string + ')',; '<string>', 'exec'); r.set_integrator('zvode', method=opt.method, order=opt.order,; atol=opt.atol, rtol=opt.rtol, nsteps=opt.nsteps,; first_step=opt.first_step, min_step=opt.min_step,; max_step=opt.max_st",MatchSource.WIKI,docs/4.2/modules/qutip/mesolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mesolve.html
https://qutip.org/docs/4.2/modules/qutip/mesolve.html:21146,Modifiability,config,config,21146,"nd(Lconst.data.indptr); Lcoeff.append(""1.0""). # the total number of liouvillian terms (hamiltonian terms +; # collapse operators); n_L_terms = len(Ldata); ; # Check which components should use OPENMP; omp_components = None; if qset.has_openmp:; if opt.use_openmp:; omp_components = openmp_components(Lptrs). #; # setup ode args string: we expand the list Ldata, Linds and Lptrs into; # and explicit list of parameters; #; string_list = []; for k in range(n_L_terms):; string_list.append(""Ldata[%d], Linds[%d], Lptrs[%d]"" % (k, k, k)); # Add object terms to end of ode args string; for k in range(len(Lobj)):; string_list.append(""Lobj[%d]"" % k); for name, value in args.items():; if isinstance(value, np.ndarray):; string_list.append(name); else:; string_list.append(str(value)); parameter_string = "","".join(string_list). #; # generate and compile new cython code if necessary; #; if not opt.rhs_reuse or config.tdfunc is None:; if opt.rhs_filename is None:; config.tdname = ""rhs"" + str(os.getpid()) + str(config.cgen_num); else:; config.tdname = opt.rhs_filename; cgen = Codegen(h_terms=n_L_terms, h_tdterms=Lcoeff, args=args,; config=config, use_openmp=opt.use_openmp,; omp_components=omp_components,; omp_threads=opt.openmp_threads); cgen.generate(config.tdname + "".pyx""). code = compile('from ' + config.tdname + ' import cy_td_ode_rhs',; '<string>', 'exec'); exec(code, globals()); config.tdfunc = cy_td_ode_rhs. #; # setup integrator; #; initial_vector = mat2vec(rho0.full()).ravel('F'); if issuper(rho0):; r = scipy.integrate.ode(_td_ode_rhs_super); code = compile('r.set_f_params([' + parameter_string + '])',; '<string>', 'exec'); else:; r = scipy.integrate.ode(config.tdfunc); code = compile('r.set_f_params(' + parameter_string + ')',; '<string>', 'exec'); r.set_integrator('zvode', method=opt.method, order=opt.order,; atol=opt.atol, rtol=opt.rtol, nsteps=opt.nsteps,; first_step=opt.first_step, min_step=opt.min_step,; max_step=opt.max_step); r.set_initial_value(initial_vector, tlist[0]).",MatchSource.WIKI,docs/4.2/modules/qutip/mesolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mesolve.html
https://qutip.org/docs/4.2/modules/qutip/mesolve.html:21171,Modifiability,config,config,21171,"Lcoeff.append(""1.0""). # the total number of liouvillian terms (hamiltonian terms +; # collapse operators); n_L_terms = len(Ldata); ; # Check which components should use OPENMP; omp_components = None; if qset.has_openmp:; if opt.use_openmp:; omp_components = openmp_components(Lptrs). #; # setup ode args string: we expand the list Ldata, Linds and Lptrs into; # and explicit list of parameters; #; string_list = []; for k in range(n_L_terms):; string_list.append(""Ldata[%d], Linds[%d], Lptrs[%d]"" % (k, k, k)); # Add object terms to end of ode args string; for k in range(len(Lobj)):; string_list.append(""Lobj[%d]"" % k); for name, value in args.items():; if isinstance(value, np.ndarray):; string_list.append(name); else:; string_list.append(str(value)); parameter_string = "","".join(string_list). #; # generate and compile new cython code if necessary; #; if not opt.rhs_reuse or config.tdfunc is None:; if opt.rhs_filename is None:; config.tdname = ""rhs"" + str(os.getpid()) + str(config.cgen_num); else:; config.tdname = opt.rhs_filename; cgen = Codegen(h_terms=n_L_terms, h_tdterms=Lcoeff, args=args,; config=config, use_openmp=opt.use_openmp,; omp_components=omp_components,; omp_threads=opt.openmp_threads); cgen.generate(config.tdname + "".pyx""). code = compile('from ' + config.tdname + ' import cy_td_ode_rhs',; '<string>', 'exec'); exec(code, globals()); config.tdfunc = cy_td_ode_rhs. #; # setup integrator; #; initial_vector = mat2vec(rho0.full()).ravel('F'); if issuper(rho0):; r = scipy.integrate.ode(_td_ode_rhs_super); code = compile('r.set_f_params([' + parameter_string + '])',; '<string>', 'exec'); else:; r = scipy.integrate.ode(config.tdfunc); code = compile('r.set_f_params(' + parameter_string + ')',; '<string>', 'exec'); r.set_integrator('zvode', method=opt.method, order=opt.order,; atol=opt.atol, rtol=opt.rtol, nsteps=opt.nsteps,; first_step=opt.first_step, min_step=opt.min_step,; max_step=opt.max_step); r.set_initial_value(initial_vector, tlist[0]). exec(code, locals(), ar",MatchSource.WIKI,docs/4.2/modules/qutip/mesolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mesolve.html
https://qutip.org/docs/4.2/modules/qutip/mesolve.html:21269,Modifiability,config,config,21269," +; # collapse operators); n_L_terms = len(Ldata); ; # Check which components should use OPENMP; omp_components = None; if qset.has_openmp:; if opt.use_openmp:; omp_components = openmp_components(Lptrs). #; # setup ode args string: we expand the list Ldata, Linds and Lptrs into; # and explicit list of parameters; #; string_list = []; for k in range(n_L_terms):; string_list.append(""Ldata[%d], Linds[%d], Lptrs[%d]"" % (k, k, k)); # Add object terms to end of ode args string; for k in range(len(Lobj)):; string_list.append(""Lobj[%d]"" % k); for name, value in args.items():; if isinstance(value, np.ndarray):; string_list.append(name); else:; string_list.append(str(value)); parameter_string = "","".join(string_list). #; # generate and compile new cython code if necessary; #; if not opt.rhs_reuse or config.tdfunc is None:; if opt.rhs_filename is None:; config.tdname = ""rhs"" + str(os.getpid()) + str(config.cgen_num); else:; config.tdname = opt.rhs_filename; cgen = Codegen(h_terms=n_L_terms, h_tdterms=Lcoeff, args=args,; config=config, use_openmp=opt.use_openmp,; omp_components=omp_components,; omp_threads=opt.openmp_threads); cgen.generate(config.tdname + "".pyx""). code = compile('from ' + config.tdname + ' import cy_td_ode_rhs',; '<string>', 'exec'); exec(code, globals()); config.tdfunc = cy_td_ode_rhs. #; # setup integrator; #; initial_vector = mat2vec(rho0.full()).ravel('F'); if issuper(rho0):; r = scipy.integrate.ode(_td_ode_rhs_super); code = compile('r.set_f_params([' + parameter_string + '])',; '<string>', 'exec'); else:; r = scipy.integrate.ode(config.tdfunc); code = compile('r.set_f_params(' + parameter_string + ')',; '<string>', 'exec'); r.set_integrator('zvode', method=opt.method, order=opt.order,; atol=opt.atol, rtol=opt.rtol, nsteps=opt.nsteps,; first_step=opt.first_step, min_step=opt.min_step,; max_step=opt.max_step); r.set_initial_value(initial_vector, tlist[0]). exec(code, locals(), args). #; # call generic ODE code; #; return _generic_ode_solve(r, rho0, tlist, e",MatchSource.WIKI,docs/4.2/modules/qutip/mesolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mesolve.html
https://qutip.org/docs/4.2/modules/qutip/mesolve.html:21276,Modifiability,config,config,21276," +; # collapse operators); n_L_terms = len(Ldata); ; # Check which components should use OPENMP; omp_components = None; if qset.has_openmp:; if opt.use_openmp:; omp_components = openmp_components(Lptrs). #; # setup ode args string: we expand the list Ldata, Linds and Lptrs into; # and explicit list of parameters; #; string_list = []; for k in range(n_L_terms):; string_list.append(""Ldata[%d], Linds[%d], Lptrs[%d]"" % (k, k, k)); # Add object terms to end of ode args string; for k in range(len(Lobj)):; string_list.append(""Lobj[%d]"" % k); for name, value in args.items():; if isinstance(value, np.ndarray):; string_list.append(name); else:; string_list.append(str(value)); parameter_string = "","".join(string_list). #; # generate and compile new cython code if necessary; #; if not opt.rhs_reuse or config.tdfunc is None:; if opt.rhs_filename is None:; config.tdname = ""rhs"" + str(os.getpid()) + str(config.cgen_num); else:; config.tdname = opt.rhs_filename; cgen = Codegen(h_terms=n_L_terms, h_tdterms=Lcoeff, args=args,; config=config, use_openmp=opt.use_openmp,; omp_components=omp_components,; omp_threads=opt.openmp_threads); cgen.generate(config.tdname + "".pyx""). code = compile('from ' + config.tdname + ' import cy_td_ode_rhs',; '<string>', 'exec'); exec(code, globals()); config.tdfunc = cy_td_ode_rhs. #; # setup integrator; #; initial_vector = mat2vec(rho0.full()).ravel('F'); if issuper(rho0):; r = scipy.integrate.ode(_td_ode_rhs_super); code = compile('r.set_f_params([' + parameter_string + '])',; '<string>', 'exec'); else:; r = scipy.integrate.ode(config.tdfunc); code = compile('r.set_f_params(' + parameter_string + ')',; '<string>', 'exec'); r.set_integrator('zvode', method=opt.method, order=opt.order,; atol=opt.atol, rtol=opt.rtol, nsteps=opt.nsteps,; first_step=opt.first_step, min_step=opt.min_step,; max_step=opt.max_step); r.set_initial_value(initial_vector, tlist[0]). exec(code, locals(), args). #; # call generic ODE code; #; return _generic_ode_solve(r, rho0, tlist, e",MatchSource.WIKI,docs/4.2/modules/qutip/mesolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mesolve.html
https://qutip.org/docs/4.2/modules/qutip/mesolve.html:21391,Modifiability,config,config,21391,"pt.use_openmp:; omp_components = openmp_components(Lptrs). #; # setup ode args string: we expand the list Ldata, Linds and Lptrs into; # and explicit list of parameters; #; string_list = []; for k in range(n_L_terms):; string_list.append(""Ldata[%d], Linds[%d], Lptrs[%d]"" % (k, k, k)); # Add object terms to end of ode args string; for k in range(len(Lobj)):; string_list.append(""Lobj[%d]"" % k); for name, value in args.items():; if isinstance(value, np.ndarray):; string_list.append(name); else:; string_list.append(str(value)); parameter_string = "","".join(string_list). #; # generate and compile new cython code if necessary; #; if not opt.rhs_reuse or config.tdfunc is None:; if opt.rhs_filename is None:; config.tdname = ""rhs"" + str(os.getpid()) + str(config.cgen_num); else:; config.tdname = opt.rhs_filename; cgen = Codegen(h_terms=n_L_terms, h_tdterms=Lcoeff, args=args,; config=config, use_openmp=opt.use_openmp,; omp_components=omp_components,; omp_threads=opt.openmp_threads); cgen.generate(config.tdname + "".pyx""). code = compile('from ' + config.tdname + ' import cy_td_ode_rhs',; '<string>', 'exec'); exec(code, globals()); config.tdfunc = cy_td_ode_rhs. #; # setup integrator; #; initial_vector = mat2vec(rho0.full()).ravel('F'); if issuper(rho0):; r = scipy.integrate.ode(_td_ode_rhs_super); code = compile('r.set_f_params([' + parameter_string + '])',; '<string>', 'exec'); else:; r = scipy.integrate.ode(config.tdfunc); code = compile('r.set_f_params(' + parameter_string + ')',; '<string>', 'exec'); r.set_integrator('zvode', method=opt.method, order=opt.order,; atol=opt.atol, rtol=opt.rtol, nsteps=opt.nsteps,; first_step=opt.first_step, min_step=opt.min_step,; max_step=opt.max_step); r.set_initial_value(initial_vector, tlist[0]). exec(code, locals(), args). #; # call generic ODE code; #; return _generic_ode_solve(r, rho0, tlist, e_ops, opt, progress_bar). def _td_ode_rhs_super(t, y, arglist):; N = int(np.sqrt(len(y))); out = np.zeros(N, dtype=complex); y2 = np.zeros(len(y)",MatchSource.WIKI,docs/4.2/modules/qutip/mesolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mesolve.html
https://qutip.org/docs/4.2/modules/qutip/mesolve.html:21441,Modifiability,config,config,21441,"omponents(Lptrs). #; # setup ode args string: we expand the list Ldata, Linds and Lptrs into; # and explicit list of parameters; #; string_list = []; for k in range(n_L_terms):; string_list.append(""Ldata[%d], Linds[%d], Lptrs[%d]"" % (k, k, k)); # Add object terms to end of ode args string; for k in range(len(Lobj)):; string_list.append(""Lobj[%d]"" % k); for name, value in args.items():; if isinstance(value, np.ndarray):; string_list.append(name); else:; string_list.append(str(value)); parameter_string = "","".join(string_list). #; # generate and compile new cython code if necessary; #; if not opt.rhs_reuse or config.tdfunc is None:; if opt.rhs_filename is None:; config.tdname = ""rhs"" + str(os.getpid()) + str(config.cgen_num); else:; config.tdname = opt.rhs_filename; cgen = Codegen(h_terms=n_L_terms, h_tdterms=Lcoeff, args=args,; config=config, use_openmp=opt.use_openmp,; omp_components=omp_components,; omp_threads=opt.openmp_threads); cgen.generate(config.tdname + "".pyx""). code = compile('from ' + config.tdname + ' import cy_td_ode_rhs',; '<string>', 'exec'); exec(code, globals()); config.tdfunc = cy_td_ode_rhs. #; # setup integrator; #; initial_vector = mat2vec(rho0.full()).ravel('F'); if issuper(rho0):; r = scipy.integrate.ode(_td_ode_rhs_super); code = compile('r.set_f_params([' + parameter_string + '])',; '<string>', 'exec'); else:; r = scipy.integrate.ode(config.tdfunc); code = compile('r.set_f_params(' + parameter_string + ')',; '<string>', 'exec'); r.set_integrator('zvode', method=opt.method, order=opt.order,; atol=opt.atol, rtol=opt.rtol, nsteps=opt.nsteps,; first_step=opt.first_step, min_step=opt.min_step,; max_step=opt.max_step); r.set_initial_value(initial_vector, tlist[0]). exec(code, locals(), args). #; # call generic ODE code; #; return _generic_ode_solve(r, rho0, tlist, e_ops, opt, progress_bar). def _td_ode_rhs_super(t, y, arglist):; N = int(np.sqrt(len(y))); out = np.zeros(N, dtype=complex); y2 = np.zeros(len(y), dtype=complex); for i in range(N):; out ",MatchSource.WIKI,docs/4.2/modules/qutip/mesolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mesolve.html
https://qutip.org/docs/4.2/modules/qutip/mesolve.html:21527,Modifiability,config,config,21527,"list Ldata, Linds and Lptrs into; # and explicit list of parameters; #; string_list = []; for k in range(n_L_terms):; string_list.append(""Ldata[%d], Linds[%d], Lptrs[%d]"" % (k, k, k)); # Add object terms to end of ode args string; for k in range(len(Lobj)):; string_list.append(""Lobj[%d]"" % k); for name, value in args.items():; if isinstance(value, np.ndarray):; string_list.append(name); else:; string_list.append(str(value)); parameter_string = "","".join(string_list). #; # generate and compile new cython code if necessary; #; if not opt.rhs_reuse or config.tdfunc is None:; if opt.rhs_filename is None:; config.tdname = ""rhs"" + str(os.getpid()) + str(config.cgen_num); else:; config.tdname = opt.rhs_filename; cgen = Codegen(h_terms=n_L_terms, h_tdterms=Lcoeff, args=args,; config=config, use_openmp=opt.use_openmp,; omp_components=omp_components,; omp_threads=opt.openmp_threads); cgen.generate(config.tdname + "".pyx""). code = compile('from ' + config.tdname + ' import cy_td_ode_rhs',; '<string>', 'exec'); exec(code, globals()); config.tdfunc = cy_td_ode_rhs. #; # setup integrator; #; initial_vector = mat2vec(rho0.full()).ravel('F'); if issuper(rho0):; r = scipy.integrate.ode(_td_ode_rhs_super); code = compile('r.set_f_params([' + parameter_string + '])',; '<string>', 'exec'); else:; r = scipy.integrate.ode(config.tdfunc); code = compile('r.set_f_params(' + parameter_string + ')',; '<string>', 'exec'); r.set_integrator('zvode', method=opt.method, order=opt.order,; atol=opt.atol, rtol=opt.rtol, nsteps=opt.nsteps,; first_step=opt.first_step, min_step=opt.min_step,; max_step=opt.max_step); r.set_initial_value(initial_vector, tlist[0]). exec(code, locals(), args). #; # call generic ODE code; #; return _generic_ode_solve(r, rho0, tlist, e_ops, opt, progress_bar). def _td_ode_rhs_super(t, y, arglist):; N = int(np.sqrt(len(y))); out = np.zeros(N, dtype=complex); y2 = np.zeros(len(y), dtype=complex); for i in range(N):; out = cy_td_ode_rhs(t, y[i*N:(i+1)*N], *arglist); y2[i*N:(i+1)*",MatchSource.WIKI,docs/4.2/modules/qutip/mesolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mesolve.html
https://qutip.org/docs/4.2/modules/qutip/mesolve.html:21811,Modifiability,config,config,21811,"ems():; if isinstance(value, np.ndarray):; string_list.append(name); else:; string_list.append(str(value)); parameter_string = "","".join(string_list). #; # generate and compile new cython code if necessary; #; if not opt.rhs_reuse or config.tdfunc is None:; if opt.rhs_filename is None:; config.tdname = ""rhs"" + str(os.getpid()) + str(config.cgen_num); else:; config.tdname = opt.rhs_filename; cgen = Codegen(h_terms=n_L_terms, h_tdterms=Lcoeff, args=args,; config=config, use_openmp=opt.use_openmp,; omp_components=omp_components,; omp_threads=opt.openmp_threads); cgen.generate(config.tdname + "".pyx""). code = compile('from ' + config.tdname + ' import cy_td_ode_rhs',; '<string>', 'exec'); exec(code, globals()); config.tdfunc = cy_td_ode_rhs. #; # setup integrator; #; initial_vector = mat2vec(rho0.full()).ravel('F'); if issuper(rho0):; r = scipy.integrate.ode(_td_ode_rhs_super); code = compile('r.set_f_params([' + parameter_string + '])',; '<string>', 'exec'); else:; r = scipy.integrate.ode(config.tdfunc); code = compile('r.set_f_params(' + parameter_string + ')',; '<string>', 'exec'); r.set_integrator('zvode', method=opt.method, order=opt.order,; atol=opt.atol, rtol=opt.rtol, nsteps=opt.nsteps,; first_step=opt.first_step, min_step=opt.min_step,; max_step=opt.max_step); r.set_initial_value(initial_vector, tlist[0]). exec(code, locals(), args). #; # call generic ODE code; #; return _generic_ode_solve(r, rho0, tlist, e_ops, opt, progress_bar). def _td_ode_rhs_super(t, y, arglist):; N = int(np.sqrt(len(y))); out = np.zeros(N, dtype=complex); y2 = np.zeros(len(y), dtype=complex); for i in range(N):; out = cy_td_ode_rhs(t, y[i*N:(i+1)*N], *arglist); y2[i*N:(i+1)*N] = out; return y2. # -----------------------------------------------------------------------------; # Master equation solver; #; def _mesolve_const(H, rho0, tlist, c_op_list, e_ops, args, opt,; progress_bar):; """"""; Evolve the density matrix using an ODE solver, for constant hamiltonian; and collapse operators.; """""". if",MatchSource.WIKI,docs/4.2/modules/qutip/mesolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mesolve.html
https://qutip.org/docs/4.2/modules/qutip/mesolve.html:29626,Modifiability,config,config,29626,"ros(n_tsteps, dtype=complex)). else:; raise TypeError(""Expectation parameter must be a list or a function""). #; # start evolution; #; progress_bar.start(n_tsteps). rho = Qobj(rho0). dt = np.diff(tlist); for t_idx, t in enumerate(tlist):; progress_bar.update(t_idx). if not r.successful():; raise Exception(""ODE integration error: Try to increase ""; ""the allowed number of substeps by increasing ""; ""the nsteps parameter in the Options class.""). if opt.store_states or expt_callback:; rho.data = dense2D_to_fastcsr_fmode(vec2mat(r.y), rho.shape[0], rho.shape[1]). if opt.store_states:; output.states.append(Qobj(rho, isherm=True)). if expt_callback:; # use callback method; e_ops(t, rho). for m in range(n_expt_op):; if output.expect[m].dtype == complex:; output.expect[m][t_idx] = expect_rho_vec(e_sops_data[m],; r.y, 0); else:; output.expect[m][t_idx] = expect_rho_vec(e_sops_data[m],; r.y, 1). if t_idx < n_tsteps - 1:; r.integrate(r.t + dt[t_idx]). progress_bar.finished(). if (not opt.rhs_reuse) and (config.tdname is not None):; _cython_build_cleanup(config.tdname). if opt.store_final_state:; rho.data = dense2D_to_fastcsr_fmode(vec2mat(r.y), rho.shape[0], rho.shape[1]); output.final_state = Qobj(rho, dims=rho0.dims, isherm=True). return output. # -----------------------------------------------------------------------------; # Old style API below.; # -----------------------------------------------------------------------------. # -----------------------------------------------------------------------------; # Master equation solver: deprecated in 2.0.0. No support for time-dependent; # collapse operators. Only used by the deprecated odesolve function.; #; def _mesolve_list_td(H_func, rho0, tlist, c_op_list, e_ops, args, opt,; progress_bar):; """"""; Evolve the density matrix using an ODE solver with time dependent; Hamiltonian.; """""". if debug:; print(inspect.stack()[0][3]). #; # check initial state; #; if isket(rho0):; # if initial state is a ket and no collapse operator where give",MatchSource.WIKI,docs/4.2/modules/qutip/mesolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mesolve.html
https://qutip.org/docs/4.2/modules/qutip/mesolve.html:29677,Modifiability,config,config,29677," raise TypeError(""Expectation parameter must be a list or a function""). #; # start evolution; #; progress_bar.start(n_tsteps). rho = Qobj(rho0). dt = np.diff(tlist); for t_idx, t in enumerate(tlist):; progress_bar.update(t_idx). if not r.successful():; raise Exception(""ODE integration error: Try to increase ""; ""the allowed number of substeps by increasing ""; ""the nsteps parameter in the Options class.""). if opt.store_states or expt_callback:; rho.data = dense2D_to_fastcsr_fmode(vec2mat(r.y), rho.shape[0], rho.shape[1]). if opt.store_states:; output.states.append(Qobj(rho, isherm=True)). if expt_callback:; # use callback method; e_ops(t, rho). for m in range(n_expt_op):; if output.expect[m].dtype == complex:; output.expect[m][t_idx] = expect_rho_vec(e_sops_data[m],; r.y, 0); else:; output.expect[m][t_idx] = expect_rho_vec(e_sops_data[m],; r.y, 1). if t_idx < n_tsteps - 1:; r.integrate(r.t + dt[t_idx]). progress_bar.finished(). if (not opt.rhs_reuse) and (config.tdname is not None):; _cython_build_cleanup(config.tdname). if opt.store_final_state:; rho.data = dense2D_to_fastcsr_fmode(vec2mat(r.y), rho.shape[0], rho.shape[1]); output.final_state = Qobj(rho, dims=rho0.dims, isherm=True). return output. # -----------------------------------------------------------------------------; # Old style API below.; # -----------------------------------------------------------------------------. # -----------------------------------------------------------------------------; # Master equation solver: deprecated in 2.0.0. No support for time-dependent; # collapse operators. Only used by the deprecated odesolve function.; #; def _mesolve_list_td(H_func, rho0, tlist, c_op_list, e_ops, args, opt,; progress_bar):; """"""; Evolve the density matrix using an ODE solver with time dependent; Hamiltonian.; """""". if debug:; print(inspect.stack()[0][3]). #; # check initial state; #; if isket(rho0):; # if initial state is a ket and no collapse operator where given,; # fall back on the unitary schrod",MatchSource.WIKI,docs/4.2/modules/qutip/mesolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mesolve.html
https://qutip.org/docs/4.2/modules/qutip/mesolve.html:31421,Modifiability,config,config,31421," an ODE solver with time dependent; Hamiltonian.; """""". if debug:; print(inspect.stack()[0][3]). #; # check initial state; #; if isket(rho0):; # if initial state is a ket and no collapse operator where given,; # fall back on the unitary schrodinger equation solver; if len(c_op_list) == 0:; return _sesolve_list_td(H_func, rho0, tlist, e_ops, args, opt,; progress_bar). # Got a wave function as initial state: convert to density matrix.; rho0 = ket2dm(rho0). #; # construct liouvillian; #; if len(H_func) != 2:; raise TypeError('Time-dependent Hamiltonian list must have two terms.'); if not isinstance(H_func[0], (list, np.ndarray)) or len(H_func[0]) <= 1:; raise TypeError('Time-dependent Hamiltonians must be a list ' +; 'with two or more terms'); if (not isinstance(H_func[1], (list, np.ndarray))) or \; (len(H_func[1]) != (len(H_func[0]) - 1)):; raise TypeError('Time-dependent coefficients must be list with ' +; 'length N-1 where N is the number of ' +; 'Hamiltonian terms.'). if opt.rhs_reuse and config.tdfunc is None:; rhs_generate(H_func, args). lenh = len(H_func[0]); if opt.tidy:; H_func[0] = [(H_func[0][k]).tidyup() for k in range(lenh)]; L_func = [[liouvillian(H_func[0][0], c_op_list)], H_func[1]]; for m in range(1, lenh):; L_func[0].append(liouvillian(H_func[0][m], [])). # create data arrays for time-dependent RHS function; Ldata = [L_func[0][k].data.data for k in range(lenh)]; Linds = [L_func[0][k].data.indices for k in range(lenh)]; Lptrs = [L_func[0][k].data.indptr for k in range(lenh)]; # setup ode args string; string = """"; for k in range(lenh):; string += (""Ldata[%d], Linds[%d], Lptrs[%d],"" % (k, k, k)). if args:; td_consts = args.items(); for elem in td_consts:; string += str(elem[1]); if elem != td_consts[-1]:; string += ("",""). # run code generator; if not opt.rhs_reuse or config.tdfunc is None:; if opt.rhs_filename is None:; config.tdname = ""rhs"" + str(os.getpid()) + str(config.cgen_num); else:; config.tdname = opt.rhs_filename; cgen = Codegen(h_terms=n_L_terms",MatchSource.WIKI,docs/4.2/modules/qutip/mesolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mesolve.html
https://qutip.org/docs/4.2/modules/qutip/mesolve.html:32226,Modifiability,config,config,32226," (len(H_func[1]) != (len(H_func[0]) - 1)):; raise TypeError('Time-dependent coefficients must be list with ' +; 'length N-1 where N is the number of ' +; 'Hamiltonian terms.'). if opt.rhs_reuse and config.tdfunc is None:; rhs_generate(H_func, args). lenh = len(H_func[0]); if opt.tidy:; H_func[0] = [(H_func[0][k]).tidyup() for k in range(lenh)]; L_func = [[liouvillian(H_func[0][0], c_op_list)], H_func[1]]; for m in range(1, lenh):; L_func[0].append(liouvillian(H_func[0][m], [])). # create data arrays for time-dependent RHS function; Ldata = [L_func[0][k].data.data for k in range(lenh)]; Linds = [L_func[0][k].data.indices for k in range(lenh)]; Lptrs = [L_func[0][k].data.indptr for k in range(lenh)]; # setup ode args string; string = """"; for k in range(lenh):; string += (""Ldata[%d], Linds[%d], Lptrs[%d],"" % (k, k, k)). if args:; td_consts = args.items(); for elem in td_consts:; string += str(elem[1]); if elem != td_consts[-1]:; string += ("",""). # run code generator; if not opt.rhs_reuse or config.tdfunc is None:; if opt.rhs_filename is None:; config.tdname = ""rhs"" + str(os.getpid()) + str(config.cgen_num); else:; config.tdname = opt.rhs_filename; cgen = Codegen(h_terms=n_L_terms, h_tdterms=Lcoeff, args=args,; config=config); cgen.generate(config.tdname + "".pyx""). code = compile('from ' + config.tdname + ' import cy_td_ode_rhs',; '<string>', 'exec'); exec(code, globals()); config.tdfunc = cy_td_ode_rhs. #; # setup integrator; #; initial_vector = mat2vec(rho0.full()).ravel(); r = scipy.integrate.ode(config.tdfunc); r.set_integrator('zvode', method=opt.method, order=opt.order,; atol=opt.atol, rtol=opt.rtol, nsteps=opt.nsteps,; first_step=opt.first_step, min_step=opt.min_step,; max_step=opt.max_step); r.set_initial_value(initial_vector, tlist[0]); code = compile('r.set_f_params(' + string + ')', '<string>', 'exec'); exec(code). #; # call generic ODE code; #; return _generic_ode_solve(r, rho0, tlist, e_ops, opt, progress_bar). # --------------------------------------------",MatchSource.WIKI,docs/4.2/modules/qutip/mesolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mesolve.html
https://qutip.org/docs/4.2/modules/qutip/mesolve.html:32280,Modifiability,config,config,32280," TypeError('Time-dependent coefficients must be list with ' +; 'length N-1 where N is the number of ' +; 'Hamiltonian terms.'). if opt.rhs_reuse and config.tdfunc is None:; rhs_generate(H_func, args). lenh = len(H_func[0]); if opt.tidy:; H_func[0] = [(H_func[0][k]).tidyup() for k in range(lenh)]; L_func = [[liouvillian(H_func[0][0], c_op_list)], H_func[1]]; for m in range(1, lenh):; L_func[0].append(liouvillian(H_func[0][m], [])). # create data arrays for time-dependent RHS function; Ldata = [L_func[0][k].data.data for k in range(lenh)]; Linds = [L_func[0][k].data.indices for k in range(lenh)]; Lptrs = [L_func[0][k].data.indptr for k in range(lenh)]; # setup ode args string; string = """"; for k in range(lenh):; string += (""Ldata[%d], Linds[%d], Lptrs[%d],"" % (k, k, k)). if args:; td_consts = args.items(); for elem in td_consts:; string += str(elem[1]); if elem != td_consts[-1]:; string += ("",""). # run code generator; if not opt.rhs_reuse or config.tdfunc is None:; if opt.rhs_filename is None:; config.tdname = ""rhs"" + str(os.getpid()) + str(config.cgen_num); else:; config.tdname = opt.rhs_filename; cgen = Codegen(h_terms=n_L_terms, h_tdterms=Lcoeff, args=args,; config=config); cgen.generate(config.tdname + "".pyx""). code = compile('from ' + config.tdname + ' import cy_td_ode_rhs',; '<string>', 'exec'); exec(code, globals()); config.tdfunc = cy_td_ode_rhs. #; # setup integrator; #; initial_vector = mat2vec(rho0.full()).ravel(); r = scipy.integrate.ode(config.tdfunc); r.set_integrator('zvode', method=opt.method, order=opt.order,; atol=opt.atol, rtol=opt.rtol, nsteps=opt.nsteps,; first_step=opt.first_step, min_step=opt.min_step,; max_step=opt.max_step); r.set_initial_value(initial_vector, tlist[0]); code = compile('r.set_f_params(' + string + ')', '<string>', 'exec'); exec(code). #; # call generic ODE code; #; return _generic_ode_solve(r, rho0, tlist, e_ops, opt, progress_bar). # -----------------------------------------------------------------------------; # pass on to w",MatchSource.WIKI,docs/4.2/modules/qutip/mesolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mesolve.html
https://qutip.org/docs/4.2/modules/qutip/mesolve.html:32327,Modifiability,config,config,32327,"st with ' +; 'length N-1 where N is the number of ' +; 'Hamiltonian terms.'). if opt.rhs_reuse and config.tdfunc is None:; rhs_generate(H_func, args). lenh = len(H_func[0]); if opt.tidy:; H_func[0] = [(H_func[0][k]).tidyup() for k in range(lenh)]; L_func = [[liouvillian(H_func[0][0], c_op_list)], H_func[1]]; for m in range(1, lenh):; L_func[0].append(liouvillian(H_func[0][m], [])). # create data arrays for time-dependent RHS function; Ldata = [L_func[0][k].data.data for k in range(lenh)]; Linds = [L_func[0][k].data.indices for k in range(lenh)]; Lptrs = [L_func[0][k].data.indptr for k in range(lenh)]; # setup ode args string; string = """"; for k in range(lenh):; string += (""Ldata[%d], Linds[%d], Lptrs[%d],"" % (k, k, k)). if args:; td_consts = args.items(); for elem in td_consts:; string += str(elem[1]); if elem != td_consts[-1]:; string += ("",""). # run code generator; if not opt.rhs_reuse or config.tdfunc is None:; if opt.rhs_filename is None:; config.tdname = ""rhs"" + str(os.getpid()) + str(config.cgen_num); else:; config.tdname = opt.rhs_filename; cgen = Codegen(h_terms=n_L_terms, h_tdterms=Lcoeff, args=args,; config=config); cgen.generate(config.tdname + "".pyx""). code = compile('from ' + config.tdname + ' import cy_td_ode_rhs',; '<string>', 'exec'); exec(code, globals()); config.tdfunc = cy_td_ode_rhs. #; # setup integrator; #; initial_vector = mat2vec(rho0.full()).ravel(); r = scipy.integrate.ode(config.tdfunc); r.set_integrator('zvode', method=opt.method, order=opt.order,; atol=opt.atol, rtol=opt.rtol, nsteps=opt.nsteps,; first_step=opt.first_step, min_step=opt.min_step,; max_step=opt.max_step); r.set_initial_value(initial_vector, tlist[0]); code = compile('r.set_f_params(' + string + ')', '<string>', 'exec'); exec(code). #; # call generic ODE code; #; return _generic_ode_solve(r, rho0, tlist, e_ops, opt, progress_bar). # -----------------------------------------------------------------------------; # pass on to wavefunction solver or master equation solver depend",MatchSource.WIKI,docs/4.2/modules/qutip/mesolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mesolve.html
https://qutip.org/docs/4.2/modules/qutip/mesolve.html:32352,Modifiability,config,config,32352," where N is the number of ' +; 'Hamiltonian terms.'). if opt.rhs_reuse and config.tdfunc is None:; rhs_generate(H_func, args). lenh = len(H_func[0]); if opt.tidy:; H_func[0] = [(H_func[0][k]).tidyup() for k in range(lenh)]; L_func = [[liouvillian(H_func[0][0], c_op_list)], H_func[1]]; for m in range(1, lenh):; L_func[0].append(liouvillian(H_func[0][m], [])). # create data arrays for time-dependent RHS function; Ldata = [L_func[0][k].data.data for k in range(lenh)]; Linds = [L_func[0][k].data.indices for k in range(lenh)]; Lptrs = [L_func[0][k].data.indptr for k in range(lenh)]; # setup ode args string; string = """"; for k in range(lenh):; string += (""Ldata[%d], Linds[%d], Lptrs[%d],"" % (k, k, k)). if args:; td_consts = args.items(); for elem in td_consts:; string += str(elem[1]); if elem != td_consts[-1]:; string += ("",""). # run code generator; if not opt.rhs_reuse or config.tdfunc is None:; if opt.rhs_filename is None:; config.tdname = ""rhs"" + str(os.getpid()) + str(config.cgen_num); else:; config.tdname = opt.rhs_filename; cgen = Codegen(h_terms=n_L_terms, h_tdterms=Lcoeff, args=args,; config=config); cgen.generate(config.tdname + "".pyx""). code = compile('from ' + config.tdname + ' import cy_td_ode_rhs',; '<string>', 'exec'); exec(code, globals()); config.tdfunc = cy_td_ode_rhs. #; # setup integrator; #; initial_vector = mat2vec(rho0.full()).ravel(); r = scipy.integrate.ode(config.tdfunc); r.set_integrator('zvode', method=opt.method, order=opt.order,; atol=opt.atol, rtol=opt.rtol, nsteps=opt.nsteps,; first_step=opt.first_step, min_step=opt.min_step,; max_step=opt.max_step); r.set_initial_value(initial_vector, tlist[0]); code = compile('r.set_f_params(' + string + ')', '<string>', 'exec'); exec(code). #; # call generic ODE code; #; return _generic_ode_solve(r, rho0, tlist, e_ops, opt, progress_bar). # -----------------------------------------------------------------------------; # pass on to wavefunction solver or master equation solver depending on whether; # any co",MatchSource.WIKI,docs/4.2/modules/qutip/mesolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mesolve.html
https://qutip.org/docs/4.2/modules/qutip/mesolve.html:32450,Modifiability,config,config,32450,"config.tdfunc is None:; rhs_generate(H_func, args). lenh = len(H_func[0]); if opt.tidy:; H_func[0] = [(H_func[0][k]).tidyup() for k in range(lenh)]; L_func = [[liouvillian(H_func[0][0], c_op_list)], H_func[1]]; for m in range(1, lenh):; L_func[0].append(liouvillian(H_func[0][m], [])). # create data arrays for time-dependent RHS function; Ldata = [L_func[0][k].data.data for k in range(lenh)]; Linds = [L_func[0][k].data.indices for k in range(lenh)]; Lptrs = [L_func[0][k].data.indptr for k in range(lenh)]; # setup ode args string; string = """"; for k in range(lenh):; string += (""Ldata[%d], Linds[%d], Lptrs[%d],"" % (k, k, k)). if args:; td_consts = args.items(); for elem in td_consts:; string += str(elem[1]); if elem != td_consts[-1]:; string += ("",""). # run code generator; if not opt.rhs_reuse or config.tdfunc is None:; if opt.rhs_filename is None:; config.tdname = ""rhs"" + str(os.getpid()) + str(config.cgen_num); else:; config.tdname = opt.rhs_filename; cgen = Codegen(h_terms=n_L_terms, h_tdterms=Lcoeff, args=args,; config=config); cgen.generate(config.tdname + "".pyx""). code = compile('from ' + config.tdname + ' import cy_td_ode_rhs',; '<string>', 'exec'); exec(code, globals()); config.tdfunc = cy_td_ode_rhs. #; # setup integrator; #; initial_vector = mat2vec(rho0.full()).ravel(); r = scipy.integrate.ode(config.tdfunc); r.set_integrator('zvode', method=opt.method, order=opt.order,; atol=opt.atol, rtol=opt.rtol, nsteps=opt.nsteps,; first_step=opt.first_step, min_step=opt.min_step,; max_step=opt.max_step); r.set_initial_value(initial_vector, tlist[0]); code = compile('r.set_f_params(' + string + ')', '<string>', 'exec'); exec(code). #; # call generic ODE code; #; return _generic_ode_solve(r, rho0, tlist, e_ops, opt, progress_bar). # -----------------------------------------------------------------------------; # pass on to wavefunction solver or master equation solver depending on whether; # any collapse operators were given.; #; def odesolve(H, rho0, tlist, c_op_list, e_",MatchSource.WIKI,docs/4.2/modules/qutip/mesolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mesolve.html
https://qutip.org/docs/4.2/modules/qutip/mesolve.html:32457,Modifiability,config,config,32457,"config.tdfunc is None:; rhs_generate(H_func, args). lenh = len(H_func[0]); if opt.tidy:; H_func[0] = [(H_func[0][k]).tidyup() for k in range(lenh)]; L_func = [[liouvillian(H_func[0][0], c_op_list)], H_func[1]]; for m in range(1, lenh):; L_func[0].append(liouvillian(H_func[0][m], [])). # create data arrays for time-dependent RHS function; Ldata = [L_func[0][k].data.data for k in range(lenh)]; Linds = [L_func[0][k].data.indices for k in range(lenh)]; Lptrs = [L_func[0][k].data.indptr for k in range(lenh)]; # setup ode args string; string = """"; for k in range(lenh):; string += (""Ldata[%d], Linds[%d], Lptrs[%d],"" % (k, k, k)). if args:; td_consts = args.items(); for elem in td_consts:; string += str(elem[1]); if elem != td_consts[-1]:; string += ("",""). # run code generator; if not opt.rhs_reuse or config.tdfunc is None:; if opt.rhs_filename is None:; config.tdname = ""rhs"" + str(os.getpid()) + str(config.cgen_num); else:; config.tdname = opt.rhs_filename; cgen = Codegen(h_terms=n_L_terms, h_tdterms=Lcoeff, args=args,; config=config); cgen.generate(config.tdname + "".pyx""). code = compile('from ' + config.tdname + ' import cy_td_ode_rhs',; '<string>', 'exec'); exec(code, globals()); config.tdfunc = cy_td_ode_rhs. #; # setup integrator; #; initial_vector = mat2vec(rho0.full()).ravel(); r = scipy.integrate.ode(config.tdfunc); r.set_integrator('zvode', method=opt.method, order=opt.order,; atol=opt.atol, rtol=opt.rtol, nsteps=opt.nsteps,; first_step=opt.first_step, min_step=opt.min_step,; max_step=opt.max_step); r.set_initial_value(initial_vector, tlist[0]); code = compile('r.set_f_params(' + string + ')', '<string>', 'exec'); exec(code). #; # call generic ODE code; #; return _generic_ode_solve(r, rho0, tlist, e_ops, opt, progress_bar). # -----------------------------------------------------------------------------; # pass on to wavefunction solver or master equation solver depending on whether; # any collapse operators were given.; #; def odesolve(H, rho0, tlist, c_op_list, e_",MatchSource.WIKI,docs/4.2/modules/qutip/mesolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mesolve.html
https://qutip.org/docs/4.2/modules/qutip/mesolve.html:32480,Modifiability,config,config,32480," len(H_func[0]); if opt.tidy:; H_func[0] = [(H_func[0][k]).tidyup() for k in range(lenh)]; L_func = [[liouvillian(H_func[0][0], c_op_list)], H_func[1]]; for m in range(1, lenh):; L_func[0].append(liouvillian(H_func[0][m], [])). # create data arrays for time-dependent RHS function; Ldata = [L_func[0][k].data.data for k in range(lenh)]; Linds = [L_func[0][k].data.indices for k in range(lenh)]; Lptrs = [L_func[0][k].data.indptr for k in range(lenh)]; # setup ode args string; string = """"; for k in range(lenh):; string += (""Ldata[%d], Linds[%d], Lptrs[%d],"" % (k, k, k)). if args:; td_consts = args.items(); for elem in td_consts:; string += str(elem[1]); if elem != td_consts[-1]:; string += ("",""). # run code generator; if not opt.rhs_reuse or config.tdfunc is None:; if opt.rhs_filename is None:; config.tdname = ""rhs"" + str(os.getpid()) + str(config.cgen_num); else:; config.tdname = opt.rhs_filename; cgen = Codegen(h_terms=n_L_terms, h_tdterms=Lcoeff, args=args,; config=config); cgen.generate(config.tdname + "".pyx""). code = compile('from ' + config.tdname + ' import cy_td_ode_rhs',; '<string>', 'exec'); exec(code, globals()); config.tdfunc = cy_td_ode_rhs. #; # setup integrator; #; initial_vector = mat2vec(rho0.full()).ravel(); r = scipy.integrate.ode(config.tdfunc); r.set_integrator('zvode', method=opt.method, order=opt.order,; atol=opt.atol, rtol=opt.rtol, nsteps=opt.nsteps,; first_step=opt.first_step, min_step=opt.min_step,; max_step=opt.max_step); r.set_initial_value(initial_vector, tlist[0]); code = compile('r.set_f_params(' + string + ')', '<string>', 'exec'); exec(code). #; # call generic ODE code; #; return _generic_ode_solve(r, rho0, tlist, e_ops, opt, progress_bar). # -----------------------------------------------------------------------------; # pass on to wavefunction solver or master equation solver depending on whether; # any collapse operators were given.; #; def odesolve(H, rho0, tlist, c_op_list, e_ops, args=None, options=None):; """"""; Master equation evol",MatchSource.WIKI,docs/4.2/modules/qutip/mesolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mesolve.html
https://qutip.org/docs/4.2/modules/qutip/mesolve.html:32530,Modifiability,config,config,32530,"= [(H_func[0][k]).tidyup() for k in range(lenh)]; L_func = [[liouvillian(H_func[0][0], c_op_list)], H_func[1]]; for m in range(1, lenh):; L_func[0].append(liouvillian(H_func[0][m], [])). # create data arrays for time-dependent RHS function; Ldata = [L_func[0][k].data.data for k in range(lenh)]; Linds = [L_func[0][k].data.indices for k in range(lenh)]; Lptrs = [L_func[0][k].data.indptr for k in range(lenh)]; # setup ode args string; string = """"; for k in range(lenh):; string += (""Ldata[%d], Linds[%d], Lptrs[%d],"" % (k, k, k)). if args:; td_consts = args.items(); for elem in td_consts:; string += str(elem[1]); if elem != td_consts[-1]:; string += ("",""). # run code generator; if not opt.rhs_reuse or config.tdfunc is None:; if opt.rhs_filename is None:; config.tdname = ""rhs"" + str(os.getpid()) + str(config.cgen_num); else:; config.tdname = opt.rhs_filename; cgen = Codegen(h_terms=n_L_terms, h_tdterms=Lcoeff, args=args,; config=config); cgen.generate(config.tdname + "".pyx""). code = compile('from ' + config.tdname + ' import cy_td_ode_rhs',; '<string>', 'exec'); exec(code, globals()); config.tdfunc = cy_td_ode_rhs. #; # setup integrator; #; initial_vector = mat2vec(rho0.full()).ravel(); r = scipy.integrate.ode(config.tdfunc); r.set_integrator('zvode', method=opt.method, order=opt.order,; atol=opt.atol, rtol=opt.rtol, nsteps=opt.nsteps,; first_step=opt.first_step, min_step=opt.min_step,; max_step=opt.max_step); r.set_initial_value(initial_vector, tlist[0]); code = compile('r.set_f_params(' + string + ')', '<string>', 'exec'); exec(code). #; # call generic ODE code; #; return _generic_ode_solve(r, rho0, tlist, e_ops, opt, progress_bar). # -----------------------------------------------------------------------------; # pass on to wavefunction solver or master equation solver depending on whether; # any collapse operators were given.; #; def odesolve(H, rho0, tlist, c_op_list, e_ops, args=None, options=None):; """"""; Master equation evolution of a density matrix for a given Hami",MatchSource.WIKI,docs/4.2/modules/qutip/mesolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mesolve.html
https://qutip.org/docs/4.2/modules/qutip/mesolve.html:32616,Modifiability,config,config,32616,"[liouvillian(H_func[0][0], c_op_list)], H_func[1]]; for m in range(1, lenh):; L_func[0].append(liouvillian(H_func[0][m], [])). # create data arrays for time-dependent RHS function; Ldata = [L_func[0][k].data.data for k in range(lenh)]; Linds = [L_func[0][k].data.indices for k in range(lenh)]; Lptrs = [L_func[0][k].data.indptr for k in range(lenh)]; # setup ode args string; string = """"; for k in range(lenh):; string += (""Ldata[%d], Linds[%d], Lptrs[%d],"" % (k, k, k)). if args:; td_consts = args.items(); for elem in td_consts:; string += str(elem[1]); if elem != td_consts[-1]:; string += ("",""). # run code generator; if not opt.rhs_reuse or config.tdfunc is None:; if opt.rhs_filename is None:; config.tdname = ""rhs"" + str(os.getpid()) + str(config.cgen_num); else:; config.tdname = opt.rhs_filename; cgen = Codegen(h_terms=n_L_terms, h_tdterms=Lcoeff, args=args,; config=config); cgen.generate(config.tdname + "".pyx""). code = compile('from ' + config.tdname + ' import cy_td_ode_rhs',; '<string>', 'exec'); exec(code, globals()); config.tdfunc = cy_td_ode_rhs. #; # setup integrator; #; initial_vector = mat2vec(rho0.full()).ravel(); r = scipy.integrate.ode(config.tdfunc); r.set_integrator('zvode', method=opt.method, order=opt.order,; atol=opt.atol, rtol=opt.rtol, nsteps=opt.nsteps,; first_step=opt.first_step, min_step=opt.min_step,; max_step=opt.max_step); r.set_initial_value(initial_vector, tlist[0]); code = compile('r.set_f_params(' + string + ')', '<string>', 'exec'); exec(code). #; # call generic ODE code; #; return _generic_ode_solve(r, rho0, tlist, e_ops, opt, progress_bar). # -----------------------------------------------------------------------------; # pass on to wavefunction solver or master equation solver depending on whether; # any collapse operators were given.; #; def odesolve(H, rho0, tlist, c_op_list, e_ops, args=None, options=None):; """"""; Master equation evolution of a density matrix for a given Hamiltonian. Evolution of a state vector or density matrix (`rh",MatchSource.WIKI,docs/4.2/modules/qutip/mesolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mesolve.html
https://qutip.org/docs/4.2/modules/qutip/mesolve.html:32744,Modifiability,config,config,32744,"t RHS function; Ldata = [L_func[0][k].data.data for k in range(lenh)]; Linds = [L_func[0][k].data.indices for k in range(lenh)]; Lptrs = [L_func[0][k].data.indptr for k in range(lenh)]; # setup ode args string; string = """"; for k in range(lenh):; string += (""Ldata[%d], Linds[%d], Lptrs[%d],"" % (k, k, k)). if args:; td_consts = args.items(); for elem in td_consts:; string += str(elem[1]); if elem != td_consts[-1]:; string += ("",""). # run code generator; if not opt.rhs_reuse or config.tdfunc is None:; if opt.rhs_filename is None:; config.tdname = ""rhs"" + str(os.getpid()) + str(config.cgen_num); else:; config.tdname = opt.rhs_filename; cgen = Codegen(h_terms=n_L_terms, h_tdterms=Lcoeff, args=args,; config=config); cgen.generate(config.tdname + "".pyx""). code = compile('from ' + config.tdname + ' import cy_td_ode_rhs',; '<string>', 'exec'); exec(code, globals()); config.tdfunc = cy_td_ode_rhs. #; # setup integrator; #; initial_vector = mat2vec(rho0.full()).ravel(); r = scipy.integrate.ode(config.tdfunc); r.set_integrator('zvode', method=opt.method, order=opt.order,; atol=opt.atol, rtol=opt.rtol, nsteps=opt.nsteps,; first_step=opt.first_step, min_step=opt.min_step,; max_step=opt.max_step); r.set_initial_value(initial_vector, tlist[0]); code = compile('r.set_f_params(' + string + ')', '<string>', 'exec'); exec(code). #; # call generic ODE code; #; return _generic_ode_solve(r, rho0, tlist, e_ops, opt, progress_bar). # -----------------------------------------------------------------------------; # pass on to wavefunction solver or master equation solver depending on whether; # any collapse operators were given.; #; def odesolve(H, rho0, tlist, c_op_list, e_ops, args=None, options=None):; """"""; Master equation evolution of a density matrix for a given Hamiltonian. Evolution of a state vector or density matrix (`rho0`) for a given; Hamiltonian (`H`) and set of collapse operators (`c_op_list`), by; integrating the set of ordinary differential equations that define the; system. T",MatchSource.WIKI,docs/4.2/modules/qutip/mesolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mesolve.html
https://qutip.org/docs/4.2/modules/qutip/mesolve.html:24379,Performance,perform,performance,24379,".ravel('F'); if issuper(rho0):; r = scipy.integrate.ode(_ode_super_func); r.set_f_params(L.data); else:; if opt.use_openmp and L.data.nnz >= qset.openmp_thresh:; r = scipy.integrate.ode(cy_ode_rhs_openmp); r.set_f_params(L.data.data, L.data.indices, L.data.indptr, ; opt.openmp_threads); else:; r = scipy.integrate.ode(cy_ode_rhs); r.set_f_params(L.data.data, L.data.indices, L.data.indptr); # r = scipy.integrate.ode(_ode_rho_test); # r.set_f_params(L.data); r.set_integrator('zvode', method=opt.method, order=opt.order,; atol=opt.atol, rtol=opt.rtol, nsteps=opt.nsteps,; first_step=opt.first_step, min_step=opt.min_step,; max_step=opt.max_step); r.set_initial_value(initial_vector, tlist[0]). #; # call generic ODE code; #; return _generic_ode_solve(r, rho0, tlist, e_ops, opt, progress_bar). #; # evaluate drho(t)/dt according to the master eqaution; # [no longer used, replaced by cython function]; #; def _ode_rho_func(t, rho, L):; return L * rho. def _ode_rho_test(t, rho, data):; # for performance comparison of cython code; return data*(np.transpose(rho)); #; # Evaluate d E(t)/dt for E a super-operator; #. def _ode_super_func(t, y, data):; ym = vec2mat(y); return (data*ym).ravel('F'). # -----------------------------------------------------------------------------; # Master equation solver for python-function time-dependence.; #; def _mesolve_func_td(L_func, rho0, tlist, c_op_list, e_ops, args, opt,; progress_bar):; """"""; Evolve the density matrix using an ODE solver with time dependent; Hamiltonian.; """""". if debug:; print(inspect.stack()[0][3]). #; # check initial state; #; if isket(rho0):; rho0 = ket2dm(rho0). #; # construct liouvillian; #; new_args = None. if len(c_op_list) > 0:; L_data = liouvillian(None, c_op_list).data; else:; n, m = rho0.shape; if issuper(rho0):; L_data = sp.csr_matrix((n, m), dtype=complex); else:; L_data = sp.csr_matrix((n ** 2, m ** 2), dtype=complex). if type(args) is dict:; new_args = {}; for key in args:; if isinstance(args[key], Qobj):; if isope",MatchSource.WIKI,docs/4.2/modules/qutip/mesolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mesolve.html
https://qutip.org/docs/4.2/modules/qutip/metrics.html:10396,Availability,error,error,10396,"Ti and SchattenNorms.jl. (By contrast,; # QETLAB uses the dual problem.). # Check if A and B are both unitaries. If so, then we can without; # loss of generality choose B to be the identity by using the; # unitary invariance of the diamond norm,; # || A - B ||_ = || A B - I ||_.; # Then, using the technique mentioned by each of Johnston and; # da Silva,; # || A B - I ||_ = max_{i, j} | \lambda_i(A B) - \lambda_j(A B) |,; # where \lambda_i(U) is the ith eigenvalue of U. if (; # There's a lot of conditions to check for this path.; not force_solve and B is not None and; # Only check if they aren't superoperators.; A.type == ""oper"" and B.type == ""oper"" and; # The difference of unitaries optimization is currently; # only implemented for d == 2. Much of the code below is more general,; # though, in anticipation of generalizing the optimization.; A.shape[0] == 2; ):; # Make an identity the same size as A and B to; # compare against.; I = qeye(A.dims[0]); # Compare to B first, so that an error is raised; # as soon as possible.; Bd = B.dag(); if (; (B * Bd - I).norm() < 1e-6 and; (A * A.dag() - I).norm() < 1e-6; ):; # Now we are on the fast path, so let's compute the; # eigenvalues, then find the diameter of the smallest circle; # containing all of them.; #; # For now, this is only implemented for dim = 2, such that; # generalizing here will allow for generalizing the optimization.; # A reasonable approach would probably be to use Welzl's algorithm; # (https://en.wikipedia.org/wiki/Smallest-circle_problem).; U = A * B.dag(); eigs = U.eigenenergies(); eig_distances = np.abs(eigs[:, None] - eigs[None, :]); return np.max(eig_distances). # Force the input superoperator to be a Choi matrix.; J = to_choi(A); ; if B is not None:; J -= to_choi(B). # Watrous 2012 also points out that the diamond norm of Lambda; # is the same as the completely-bounded operator-norm (-norm); # of the dual map of Lambda. We can evaluate that norm much more; # easily if Lambda is completely posit",MatchSource.WIKI,docs/4.2/modules/qutip/metrics.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/metrics.html
https://qutip.org/docs/4.2/modules/qutip/metrics.html:9224,Deployability,install,installed,9224,"me dimensions.'). return np.arccos(fidelity(A, B)). def dnorm(A, B=None, solver=""CVXOPT"", verbose=False, force_solve=False):; """"""; Calculates the diamond norm of the quantum map q_oper, using; the simplified semidefinite program of [Wat12]_. The diamond norm SDP is solved by using CVXPY_. Parameters; ----------; A : Qobj; Quantum map to take the diamond norm of.; B : Qobj or None; If provided, the diamond norm of :math:`A - B` is; taken instead.; solver : str; Solver to use with CVXPY. One of ""CVXOPT"" (default); or ""SCS"". The latter tends to be significantly faster,; but somewhat less accurate.; verbose : bool; If True, prints additional information about the; solution.; force_solve : bool; If True, forces dnorm to solve the associated SDP, even if a special; case is known for the argument. Returns; -------; dn : float; Diamond norm of q_oper. Raises; ------; ImportError; If CVXPY cannot be imported. .. _cvxpy: http://www.cvxpy.org/en/latest/; """"""; if cvxpy is None: # pragma: no cover; raise ImportError(""dnorm() requires CVXPY to be installed.""). # We follow the strategy of using Watrous' simpler semidefinite; # program in its primal form. This is the same strategy used,; # for instance, by both pyGSTi and SchattenNorms.jl. (By contrast,; # QETLAB uses the dual problem.). # Check if A and B are both unitaries. If so, then we can without; # loss of generality choose B to be the identity by using the; # unitary invariance of the diamond norm,; # || A - B ||_ = || A B - I ||_.; # Then, using the technique mentioned by each of Johnston and; # da Silva,; # || A B - I ||_ = max_{i, j} | \lambda_i(A B) - \lambda_j(A B) |,; # where \lambda_i(U) is the ith eigenvalue of U. if (; # There's a lot of conditions to check for this path.; not force_solve and B is not None and; # Only check if they aren't superoperators.; A.type == ""oper"" and B.type == ""oper"" and; # The difference of unitaries optimization is currently; # only implemented for d == 2. Much of the code below is",MatchSource.WIKI,docs/4.2/modules/qutip/metrics.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/metrics.html
https://qutip.org/docs/4.2/modules/qutip/metrics.html:12843,Deployability,update,updated,12843," * B.dag(); eigs = U.eigenenergies(); eig_distances = np.abs(eigs[:, None] - eigs[None, :]); return np.max(eig_distances). # Force the input superoperator to be a Choi matrix.; J = to_choi(A); ; if B is not None:; J -= to_choi(B). # Watrous 2012 also points out that the diamond norm of Lambda; # is the same as the completely-bounded operator-norm (-norm); # of the dual map of Lambda. We can evaluate that norm much more; # easily if Lambda is completely positive, since then the largest; # eigenvalue is the same as the largest singular value. if not force_solve and J.iscp:; S_dual = to_super(J.dual_chan()); vec_eye = operator_to_vector(qeye(S_dual.dims[1][1])); op = vector_to_operator(S_dual * vec_eye); # The 2-norm was not implemented for sparse matrices as of the time; # of this writing. Thus, we must yet again go dense.; return la.norm(op.data.todense(), 2). # If we're still here, we need to actually solve the problem. # Assume square...; dim = np.prod(J.dims[0][0]); ; # The constraints only depend on the dimension, so; # we can cache them efficiently.; problem, Jr, Ji, X, rho0, rho1 = dnorm_problem(dim); ; # Load the parameters with the Choi matrix passed in.; J_dat = J.data; Jr.value, Ji.value = J_dat.real, J_dat.imag; ; # Finally, set up and run the problem.; problem.solve(solver=solver, verbose=verbose). return problem.value. def unitarity(oper):; """"""; Returns the unitarity of a quantum map, defined as the Frobenius norm; of the unital block of that map's superoperator representation. Parameters; ----------; oper : Qobj; Quantum map under consideration. Returns; -------; u : float; Unitarity of ``oper``.; """"""; Eu = _super_to_superpauli(oper).full()[1:, 1:]; #return np.real(np.trace(np.dot(Eu, Eu.conj().T))) / len(Eu); return np.linalg.norm(Eu, 'fro')**2 / len(Eu).  Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, and A.L. Grimsmo.; Last updated on Jan 17, 2018. . Built with Sphinx using a theme provided by Read the Docs. . ",MatchSource.WIKI,docs/4.2/modules/qutip/metrics.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/metrics.html
https://qutip.org/docs/4.2/modules/qutip/metrics.html:11989,Energy Efficiency,efficient,efficiently,11989," * B.dag(); eigs = U.eigenenergies(); eig_distances = np.abs(eigs[:, None] - eigs[None, :]); return np.max(eig_distances). # Force the input superoperator to be a Choi matrix.; J = to_choi(A); ; if B is not None:; J -= to_choi(B). # Watrous 2012 also points out that the diamond norm of Lambda; # is the same as the completely-bounded operator-norm (-norm); # of the dual map of Lambda. We can evaluate that norm much more; # easily if Lambda is completely positive, since then the largest; # eigenvalue is the same as the largest singular value. if not force_solve and J.iscp:; S_dual = to_super(J.dual_chan()); vec_eye = operator_to_vector(qeye(S_dual.dims[1][1])); op = vector_to_operator(S_dual * vec_eye); # The 2-norm was not implemented for sparse matrices as of the time; # of this writing. Thus, we must yet again go dense.; return la.norm(op.data.todense(), 2). # If we're still here, we need to actually solve the problem. # Assume square...; dim = np.prod(J.dims[0][0]); ; # The constraints only depend on the dimension, so; # we can cache them efficiently.; problem, Jr, Ji, X, rho0, rho1 = dnorm_problem(dim); ; # Load the parameters with the Choi matrix passed in.; J_dat = J.data; Jr.value, Ji.value = J_dat.real, J_dat.imag; ; # Finally, set up and run the problem.; problem.solve(solver=solver, verbose=verbose). return problem.value. def unitarity(oper):; """"""; Returns the unitarity of a quantum map, defined as the Frobenius norm; of the unital block of that map's superoperator representation. Parameters; ----------; oper : Qobj; Quantum map under consideration. Returns; -------; u : float; Unitarity of ``oper``.; """"""; Eu = _super_to_superpauli(oper).full()[1:, 1:]; #return np.real(np.trace(np.dot(Eu, Eu.conj().T))) / len(Eu); return np.linalg.norm(Eu, 'fro')**2 / len(Eu).  Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, and A.L. Grimsmo.; Last updated on Jan 17, 2018. . Built with Sphinx using a theme provided by Read the Docs. . ",MatchSource.WIKI,docs/4.2/modules/qutip/metrics.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/metrics.html
https://qutip.org/docs/4.2/modules/qutip/metrics.html:11940,Integrability,depend,depend,11940," * B.dag(); eigs = U.eigenenergies(); eig_distances = np.abs(eigs[:, None] - eigs[None, :]); return np.max(eig_distances). # Force the input superoperator to be a Choi matrix.; J = to_choi(A); ; if B is not None:; J -= to_choi(B). # Watrous 2012 also points out that the diamond norm of Lambda; # is the same as the completely-bounded operator-norm (-norm); # of the dual map of Lambda. We can evaluate that norm much more; # easily if Lambda is completely positive, since then the largest; # eigenvalue is the same as the largest singular value. if not force_solve and J.iscp:; S_dual = to_super(J.dual_chan()); vec_eye = operator_to_vector(qeye(S_dual.dims[1][1])); op = vector_to_operator(S_dual * vec_eye); # The 2-norm was not implemented for sparse matrices as of the time; # of this writing. Thus, we must yet again go dense.; return la.norm(op.data.todense(), 2). # If we're still here, we need to actually solve the problem. # Assume square...; dim = np.prod(J.dims[0][0]); ; # The constraints only depend on the dimension, so; # we can cache them efficiently.; problem, Jr, Ji, X, rho0, rho1 = dnorm_problem(dim); ; # Load the parameters with the Choi matrix passed in.; J_dat = J.data; Jr.value, Ji.value = J_dat.real, J_dat.imag; ; # Finally, set up and run the problem.; problem.solve(solver=solver, verbose=verbose). return problem.value. def unitarity(oper):; """"""; Returns the unitarity of a quantum map, defined as the Frobenius norm; of the unital block of that map's superoperator representation. Parameters; ----------; oper : Qobj; Quantum map under consideration. Returns; -------; u : float; Unitarity of ``oper``.; """"""; Eu = _super_to_superpauli(oper).full()[1:, 1:]; #return np.real(np.trace(np.dot(Eu, Eu.conj().T))) / len(Eu); return np.linalg.norm(Eu, 'fro')**2 / len(Eu).  Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, and A.L. Grimsmo.; Last updated on Jan 17, 2018. . Built with Sphinx using a theme provided by Read the Docs. . ",MatchSource.WIKI,docs/4.2/modules/qutip/metrics.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/metrics.html
https://qutip.org/docs/4.2/modules/qutip/metrics.html:10093,Performance,optimiz,optimization,10093,"py: http://www.cvxpy.org/en/latest/; """"""; if cvxpy is None: # pragma: no cover; raise ImportError(""dnorm() requires CVXPY to be installed.""). # We follow the strategy of using Watrous' simpler semidefinite; # program in its primal form. This is the same strategy used,; # for instance, by both pyGSTi and SchattenNorms.jl. (By contrast,; # QETLAB uses the dual problem.). # Check if A and B are both unitaries. If so, then we can without; # loss of generality choose B to be the identity by using the; # unitary invariance of the diamond norm,; # || A - B ||_ = || A B - I ||_.; # Then, using the technique mentioned by each of Johnston and; # da Silva,; # || A B - I ||_ = max_{i, j} | \lambda_i(A B) - \lambda_j(A B) |,; # where \lambda_i(U) is the ith eigenvalue of U. if (; # There's a lot of conditions to check for this path.; not force_solve and B is not None and; # Only check if they aren't superoperators.; A.type == ""oper"" and B.type == ""oper"" and; # The difference of unitaries optimization is currently; # only implemented for d == 2. Much of the code below is more general,; # though, in anticipation of generalizing the optimization.; A.shape[0] == 2; ):; # Make an identity the same size as A and B to; # compare against.; I = qeye(A.dims[0]); # Compare to B first, so that an error is raised; # as soon as possible.; Bd = B.dag(); if (; (B * Bd - I).norm() < 1e-6 and; (A * A.dag() - I).norm() < 1e-6; ):; # Now we are on the fast path, so let's compute the; # eigenvalues, then find the diameter of the smallest circle; # containing all of them.; #; # For now, this is only implemented for dim = 2, such that; # generalizing here will allow for generalizing the optimization.; # A reasonable approach would probably be to use Welzl's algorithm; # (https://en.wikipedia.org/wiki/Smallest-circle_problem).; U = A * B.dag(); eigs = U.eigenenergies(); eig_distances = np.abs(eigs[:, None] - eigs[None, :]); return np.max(eig_distances). # Force the input superoperator to be a Cho",MatchSource.WIKI,docs/4.2/modules/qutip/metrics.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/metrics.html
https://qutip.org/docs/4.2/modules/qutip/metrics.html:10238,Performance,optimiz,optimization,10238,"() requires CVXPY to be installed.""). # We follow the strategy of using Watrous' simpler semidefinite; # program in its primal form. This is the same strategy used,; # for instance, by both pyGSTi and SchattenNorms.jl. (By contrast,; # QETLAB uses the dual problem.). # Check if A and B are both unitaries. If so, then we can without; # loss of generality choose B to be the identity by using the; # unitary invariance of the diamond norm,; # || A - B ||_ = || A B - I ||_.; # Then, using the technique mentioned by each of Johnston and; # da Silva,; # || A B - I ||_ = max_{i, j} | \lambda_i(A B) - \lambda_j(A B) |,; # where \lambda_i(U) is the ith eigenvalue of U. if (; # There's a lot of conditions to check for this path.; not force_solve and B is not None and; # Only check if they aren't superoperators.; A.type == ""oper"" and B.type == ""oper"" and; # The difference of unitaries optimization is currently; # only implemented for d == 2. Much of the code below is more general,; # though, in anticipation of generalizing the optimization.; A.shape[0] == 2; ):; # Make an identity the same size as A and B to; # compare against.; I = qeye(A.dims[0]); # Compare to B first, so that an error is raised; # as soon as possible.; Bd = B.dag(); if (; (B * Bd - I).norm() < 1e-6 and; (A * A.dag() - I).norm() < 1e-6; ):; # Now we are on the fast path, so let's compute the; # eigenvalues, then find the diameter of the smallest circle; # containing all of them.; #; # For now, this is only implemented for dim = 2, such that; # generalizing here will allow for generalizing the optimization.; # A reasonable approach would probably be to use Welzl's algorithm; # (https://en.wikipedia.org/wiki/Smallest-circle_problem).; U = A * B.dag(); eigs = U.eigenenergies(); eig_distances = np.abs(eigs[:, None] - eigs[None, :]); return np.max(eig_distances). # Force the input superoperator to be a Choi matrix.; J = to_choi(A); ; if B is not None:; J -= to_choi(B). # Watrous 2012 also points out that the",MatchSource.WIKI,docs/4.2/modules/qutip/metrics.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/metrics.html
https://qutip.org/docs/4.2/modules/qutip/metrics.html:10783,Performance,optimiz,optimization,10783,"ston and; # da Silva,; # || A B - I ||_ = max_{i, j} | \lambda_i(A B) - \lambda_j(A B) |,; # where \lambda_i(U) is the ith eigenvalue of U. if (; # There's a lot of conditions to check for this path.; not force_solve and B is not None and; # Only check if they aren't superoperators.; A.type == ""oper"" and B.type == ""oper"" and; # The difference of unitaries optimization is currently; # only implemented for d == 2. Much of the code below is more general,; # though, in anticipation of generalizing the optimization.; A.shape[0] == 2; ):; # Make an identity the same size as A and B to; # compare against.; I = qeye(A.dims[0]); # Compare to B first, so that an error is raised; # as soon as possible.; Bd = B.dag(); if (; (B * Bd - I).norm() < 1e-6 and; (A * A.dag() - I).norm() < 1e-6; ):; # Now we are on the fast path, so let's compute the; # eigenvalues, then find the diameter of the smallest circle; # containing all of them.; #; # For now, this is only implemented for dim = 2, such that; # generalizing here will allow for generalizing the optimization.; # A reasonable approach would probably be to use Welzl's algorithm; # (https://en.wikipedia.org/wiki/Smallest-circle_problem).; U = A * B.dag(); eigs = U.eigenenergies(); eig_distances = np.abs(eigs[:, None] - eigs[None, :]); return np.max(eig_distances). # Force the input superoperator to be a Choi matrix.; J = to_choi(A); ; if B is not None:; J -= to_choi(B). # Watrous 2012 also points out that the diamond norm of Lambda; # is the same as the completely-bounded operator-norm (-norm); # of the dual map of Lambda. We can evaluate that norm much more; # easily if Lambda is completely positive, since then the largest; # eigenvalue is the same as the largest singular value. if not force_solve and J.iscp:; S_dual = to_super(J.dual_chan()); vec_eye = operator_to_vector(qeye(S_dual.dims[1][1])); op = vector_to_operator(S_dual * vec_eye); # The 2-norm was not implemented for sparse matrices as of the time; # of this writing. ",MatchSource.WIKI,docs/4.2/modules/qutip/metrics.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/metrics.html
https://qutip.org/docs/4.2/modules/qutip/metrics.html:11978,Performance,cache,cache,11978," * B.dag(); eigs = U.eigenenergies(); eig_distances = np.abs(eigs[:, None] - eigs[None, :]); return np.max(eig_distances). # Force the input superoperator to be a Choi matrix.; J = to_choi(A); ; if B is not None:; J -= to_choi(B). # Watrous 2012 also points out that the diamond norm of Lambda; # is the same as the completely-bounded operator-norm (-norm); # of the dual map of Lambda. We can evaluate that norm much more; # easily if Lambda is completely positive, since then the largest; # eigenvalue is the same as the largest singular value. if not force_solve and J.iscp:; S_dual = to_super(J.dual_chan()); vec_eye = operator_to_vector(qeye(S_dual.dims[1][1])); op = vector_to_operator(S_dual * vec_eye); # The 2-norm was not implemented for sparse matrices as of the time; # of this writing. Thus, we must yet again go dense.; return la.norm(op.data.todense(), 2). # If we're still here, we need to actually solve the problem. # Assume square...; dim = np.prod(J.dims[0][0]); ; # The constraints only depend on the dimension, so; # we can cache them efficiently.; problem, Jr, Ji, X, rho0, rho1 = dnorm_problem(dim); ; # Load the parameters with the Choi matrix passed in.; J_dat = J.data; Jr.value, Ji.value = J_dat.real, J_dat.imag; ; # Finally, set up and run the problem.; problem.solve(solver=solver, verbose=verbose). return problem.value. def unitarity(oper):; """"""; Returns the unitarity of a quantum map, defined as the Frobenius norm; of the unital block of that map's superoperator representation. Parameters; ----------; oper : Qobj; Quantum map under consideration. Returns; -------; u : float; Unitarity of ``oper``.; """"""; Eu = _super_to_superpauli(oper).full()[1:, 1:]; #return np.real(np.trace(np.dot(Eu, Eu.conj().T))) / len(Eu); return np.linalg.norm(Eu, 'fro')**2 / len(Eu).  Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, and A.L. Grimsmo.; Last updated on Jan 17, 2018. . Built with Sphinx using a theme provided by Read the Docs. . ",MatchSource.WIKI,docs/4.2/modules/qutip/metrics.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/metrics.html
https://qutip.org/docs/4.2/modules/qutip/metrics.html:3476,Safety,avoid,avoid,3476,"_eigs; from qutip.states import ket2dm; from qutip.superop_reps import to_kraus, to_stinespring, to_choi, _super_to_superpauli, to_super; from qutip.superoperator import operator_to_vector, vector_to_operator; from qutip.operators import qeye; from qutip.semidefinite import dnorm_problem; import qutip.settings as settings. import qutip.logging_utils as logging; logger = logging.get_logger(). try:; import cvxpy; except:; cvxpy = None. [docs]def fidelity(A, B):; """"""; Calculates the fidelity (pseudo-metric) between two density matrices.; See: Nielsen & Chuang, ""Quantum Computation and Quantum Information"". Parameters; ----------; A : qobj; Density matrix or state vector.; B : qobj; Density matrix or state vector with same dimensions as A. Returns; -------; fid : float; Fidelity pseudo-metric between A and B. Examples; --------; >>> x = fock_dm(5,3); >>> y = coherent_dm(5,1); >>> fidelity(x,y); 0.24104350624628332. """"""; if A.isket or A.isbra:; # Take advantage of the fact that the density operator for A; # is a projector to avoid a sqrtm call.; sqrtmA = ket2dm(A); # Check whether we have to turn B into a density operator, too.; if B.isket or B.isbra:; B = ket2dm(B); else:; if B.isket or B.isbra:; # Swap the order so that we can take a more numerically; # stable square root of B.; return fidelity(B, A); # If we made it here, both A and B are operators, so; # we have to take the sqrtm of one of them.; sqrtmA = A.sqrtm(). if sqrtmA.dims != B.dims:; raise TypeError('Density matrices do not have same dimensions.'). # We don't actually need the whole matrix here, just the trace; # of its square root, so let's just get its eigenenergies instead.; # We also truncate negative eigenvalues to avoid nan propagation;; # even for positive semidefinite matrices, small negative eigenvalues; # can be reported.; eig_vals = (sqrtmA * B * sqrtmA).eigenenergies(); return float(np.real(np.sqrt(eig_vals[eig_vals > 0]).sum())). [docs]def process_fidelity(U1, U2, normalize=True):; """"""; Calculate",MatchSource.WIKI,docs/4.2/modules/qutip/metrics.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/metrics.html
https://qutip.org/docs/4.2/modules/qutip/metrics.html:4147,Safety,avoid,avoid,4147,"s A. Returns; -------; fid : float; Fidelity pseudo-metric between A and B. Examples; --------; >>> x = fock_dm(5,3); >>> y = coherent_dm(5,1); >>> fidelity(x,y); 0.24104350624628332. """"""; if A.isket or A.isbra:; # Take advantage of the fact that the density operator for A; # is a projector to avoid a sqrtm call.; sqrtmA = ket2dm(A); # Check whether we have to turn B into a density operator, too.; if B.isket or B.isbra:; B = ket2dm(B); else:; if B.isket or B.isbra:; # Swap the order so that we can take a more numerically; # stable square root of B.; return fidelity(B, A); # If we made it here, both A and B are operators, so; # we have to take the sqrtm of one of them.; sqrtmA = A.sqrtm(). if sqrtmA.dims != B.dims:; raise TypeError('Density matrices do not have same dimensions.'). # We don't actually need the whole matrix here, just the trace; # of its square root, so let's just get its eigenenergies instead.; # We also truncate negative eigenvalues to avoid nan propagation;; # even for positive semidefinite matrices, small negative eigenvalues; # can be reported.; eig_vals = (sqrtmA * B * sqrtmA).eigenenergies(); return float(np.real(np.sqrt(eig_vals[eig_vals > 0]).sum())). [docs]def process_fidelity(U1, U2, normalize=True):; """"""; Calculate the process fidelity given two process operators.; """"""; if normalize:; return (U1 * U2).tr() / (U1.tr() * U2.tr()); else:; return (U1 * U2).tr(). [docs]def average_gate_fidelity(oper, target=None):; """"""; Given a Qobj representing the supermatrix form of a map, returns the; average gate fidelity (pseudo-metric) of that map. Parameters; ----------; A : Qobj; Quantum object representing a superoperator.; target : Qobj; Quantum object representing the target unitary; the inverse; is applied before evaluating the fidelity. Returns; -------; fid : float; Fidelity pseudo-metric between A and the identity superoperator,; or between A and the target superunitary.; """"""; kraus_form = to_kraus(oper); d = kraus_form[0].shape[0]. if kraus_form",MatchSource.WIKI,docs/4.2/modules/qutip/metrics.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/metrics.html
https://qutip.org/docs/4.2/modules/qutip/metrics.html:2795,Testability,log,logging,2795,"TY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT; # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE; # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.; ###############################################################################; """"""; This module contains a collection of functions for calculating metrics; (distance measures) between states and operators.; """""". __all__ = ['fidelity', 'tracedist', 'bures_dist', 'bures_angle',; 'hilbert_dist', 'average_gate_fidelity', 'process_fidelity',; 'unitarity', 'dnorm']. import numpy as np; from scipy import linalg as la; from qutip.sparse import sp_eigs; from qutip.states import ket2dm; from qutip.superop_reps import to_kraus, to_stinespring, to_choi, _super_to_superpauli, to_super; from qutip.superoperator import operator_to_vector, vector_to_operator; from qutip.operators import qeye; from qutip.semidefinite import dnorm_problem; import qutip.settings as settings. import qutip.logging_utils as logging; logger = logging.get_logger(). try:; import cvxpy; except:; cvxpy = None. [docs]def fidelity(A, B):; """"""; Calculates the fidelity (pseudo-metric) between two density matrices.; See: Nielsen & Chuang, ""Quantum Computation and Quantum Information"". Parameters; ----------; A : qobj; Density matrix or state vector.; B : qobj; Density matrix or state vector with same dimensions as A. Returns; -------; fid : float; Fidelity pseudo-metric between A and B. Examples; --------; >>> x = fock_dm(5,3); >>> y = coherent_dm(5,1); >>> fidelity(x,y); 0.24104350624628332. """"""; if A.isket or A.isbra:; # Take advantage of the fact that the density operator for A; # is a projector to avoid a sqrtm call.; sqrtmA = ket2dm(A); # Check whether we have to turn B into a density operator, too.; if B.isket or B.isbra:; B = ket2dm(B); else:; if B.isket or B.isbra:; # Swap the order so that we can take a more numerically; # stable square root of B.; return fidelity(B, A); # If we made it here, both A and B are o",MatchSource.WIKI,docs/4.2/modules/qutip/metrics.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/metrics.html
https://qutip.org/docs/4.2/modules/qutip/metrics.html:2804,Testability,log,logger,2804,"TY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT; # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE; # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.; ###############################################################################; """"""; This module contains a collection of functions for calculating metrics; (distance measures) between states and operators.; """""". __all__ = ['fidelity', 'tracedist', 'bures_dist', 'bures_angle',; 'hilbert_dist', 'average_gate_fidelity', 'process_fidelity',; 'unitarity', 'dnorm']. import numpy as np; from scipy import linalg as la; from qutip.sparse import sp_eigs; from qutip.states import ket2dm; from qutip.superop_reps import to_kraus, to_stinespring, to_choi, _super_to_superpauli, to_super; from qutip.superoperator import operator_to_vector, vector_to_operator; from qutip.operators import qeye; from qutip.semidefinite import dnorm_problem; import qutip.settings as settings. import qutip.logging_utils as logging; logger = logging.get_logger(). try:; import cvxpy; except:; cvxpy = None. [docs]def fidelity(A, B):; """"""; Calculates the fidelity (pseudo-metric) between two density matrices.; See: Nielsen & Chuang, ""Quantum Computation and Quantum Information"". Parameters; ----------; A : qobj; Density matrix or state vector.; B : qobj; Density matrix or state vector with same dimensions as A. Returns; -------; fid : float; Fidelity pseudo-metric between A and B. Examples; --------; >>> x = fock_dm(5,3); >>> y = coherent_dm(5,1); >>> fidelity(x,y); 0.24104350624628332. """"""; if A.isket or A.isbra:; # Take advantage of the fact that the density operator for A; # is a projector to avoid a sqrtm call.; sqrtmA = ket2dm(A); # Check whether we have to turn B into a density operator, too.; if B.isket or B.isbra:; B = ket2dm(B); else:; if B.isket or B.isbra:; # Swap the order so that we can take a more numerically; # stable square root of B.; return fidelity(B, A); # If we made it here, both A and B are o",MatchSource.WIKI,docs/4.2/modules/qutip/metrics.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/metrics.html
https://qutip.org/docs/4.2/modules/qutip/metrics.html:2813,Testability,log,logging,2813,"TY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT; # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE; # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.; ###############################################################################; """"""; This module contains a collection of functions for calculating metrics; (distance measures) between states and operators.; """""". __all__ = ['fidelity', 'tracedist', 'bures_dist', 'bures_angle',; 'hilbert_dist', 'average_gate_fidelity', 'process_fidelity',; 'unitarity', 'dnorm']. import numpy as np; from scipy import linalg as la; from qutip.sparse import sp_eigs; from qutip.states import ket2dm; from qutip.superop_reps import to_kraus, to_stinespring, to_choi, _super_to_superpauli, to_super; from qutip.superoperator import operator_to_vector, vector_to_operator; from qutip.operators import qeye; from qutip.semidefinite import dnorm_problem; import qutip.settings as settings. import qutip.logging_utils as logging; logger = logging.get_logger(). try:; import cvxpy; except:; cvxpy = None. [docs]def fidelity(A, B):; """"""; Calculates the fidelity (pseudo-metric) between two density matrices.; See: Nielsen & Chuang, ""Quantum Computation and Quantum Information"". Parameters; ----------; A : qobj; Density matrix or state vector.; B : qobj; Density matrix or state vector with same dimensions as A. Returns; -------; fid : float; Fidelity pseudo-metric between A and B. Examples; --------; >>> x = fock_dm(5,3); >>> y = coherent_dm(5,1); >>> fidelity(x,y); 0.24104350624628332. """"""; if A.isket or A.isbra:; # Take advantage of the fact that the density operator for A; # is a projector to avoid a sqrtm call.; sqrtmA = ket2dm(A); # Check whether we have to turn B into a density operator, too.; if B.isket or B.isbra:; B = ket2dm(B); else:; if B.isket or B.isbra:; # Swap the order so that we can take a more numerically; # stable square root of B.; return fidelity(B, A); # If we made it here, both A and B are o",MatchSource.WIKI,docs/4.2/modules/qutip/metrics.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/metrics.html
https://qutip.org/docs/4.2/modules/qutip/metrics.html:8372,Usability,simpl,simplified,8372,"r state vector with same dimensions as A. Returns; -------; dist : float; Bures distance between density matrices.; """"""; if A.isket or A.isbra:; A = ket2dm(A); if B.isket or B.isbra:; B = ket2dm(B). if A.dims != B.dims:; raise TypeError('A and B do not have same dimensions.'). dist = np.sqrt(2.0 * (1.0 - fidelity(A, B))); return dist. [docs]def bures_angle(A, B):; """"""; Returns the Bures Angle between two density matrices A & B. The Bures angle ranges from 0, for states with unit fidelity, to pi/2. Parameters; ----------; A : qobj; Density matrix or state vector.; B : qobj; Density matrix or state vector with same dimensions as A. Returns; -------; angle : float; Bures angle between density matrices.; """"""; if A.isket or A.isbra:; A = ket2dm(A); if B.isket or B.isbra:; B = ket2dm(B). if A.dims != B.dims:; raise TypeError('A and B do not have same dimensions.'). return np.arccos(fidelity(A, B)). def dnorm(A, B=None, solver=""CVXOPT"", verbose=False, force_solve=False):; """"""; Calculates the diamond norm of the quantum map q_oper, using; the simplified semidefinite program of [Wat12]_. The diamond norm SDP is solved by using CVXPY_. Parameters; ----------; A : Qobj; Quantum map to take the diamond norm of.; B : Qobj or None; If provided, the diamond norm of :math:`A - B` is; taken instead.; solver : str; Solver to use with CVXPY. One of ""CVXOPT"" (default); or ""SCS"". The latter tends to be significantly faster,; but somewhat less accurate.; verbose : bool; If True, prints additional information about the; solution.; force_solve : bool; If True, forces dnorm to solve the associated SDP, even if a special; case is known for the argument. Returns; -------; dn : float; Diamond norm of q_oper. Raises; ------; ImportError; If CVXPY cannot be imported. .. _cvxpy: http://www.cvxpy.org/en/latest/; """"""; if cvxpy is None: # pragma: no cover; raise ImportError(""dnorm() requires CVXPY to be installed.""). # We follow the strategy of using Watrous' simpler semidefinite; # program in its p",MatchSource.WIKI,docs/4.2/modules/qutip/metrics.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/metrics.html
https://qutip.org/docs/4.2/modules/qutip/metrics.html:9281,Usability,simpl,simpler,9281,"e_solve=False):; """"""; Calculates the diamond norm of the quantum map q_oper, using; the simplified semidefinite program of [Wat12]_. The diamond norm SDP is solved by using CVXPY_. Parameters; ----------; A : Qobj; Quantum map to take the diamond norm of.; B : Qobj or None; If provided, the diamond norm of :math:`A - B` is; taken instead.; solver : str; Solver to use with CVXPY. One of ""CVXOPT"" (default); or ""SCS"". The latter tends to be significantly faster,; but somewhat less accurate.; verbose : bool; If True, prints additional information about the; solution.; force_solve : bool; If True, forces dnorm to solve the associated SDP, even if a special; case is known for the argument. Returns; -------; dn : float; Diamond norm of q_oper. Raises; ------; ImportError; If CVXPY cannot be imported. .. _cvxpy: http://www.cvxpy.org/en/latest/; """"""; if cvxpy is None: # pragma: no cover; raise ImportError(""dnorm() requires CVXPY to be installed.""). # We follow the strategy of using Watrous' simpler semidefinite; # program in its primal form. This is the same strategy used,; # for instance, by both pyGSTi and SchattenNorms.jl. (By contrast,; # QETLAB uses the dual problem.). # Check if A and B are both unitaries. If so, then we can without; # loss of generality choose B to be the identity by using the; # unitary invariance of the diamond norm,; # || A - B ||_ = || A B - I ||_.; # Then, using the technique mentioned by each of Johnston and; # da Silva,; # || A B - I ||_ = max_{i, j} | \lambda_i(A B) - \lambda_j(A B) |,; # where \lambda_i(U) is the ith eigenvalue of U. if (; # There's a lot of conditions to check for this path.; not force_solve and B is not None and; # Only check if they aren't superoperators.; A.type == ""oper"" and B.type == ""oper"" and; # The difference of unitaries optimization is currently; # only implemented for d == 2. Much of the code below is more general,; # though, in anticipation of generalizing the optimization.; A.shape[0] == 2; ):; # Make an i",MatchSource.WIKI,docs/4.2/modules/qutip/metrics.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/metrics.html
https://qutip.org/docs/4.2/modules/qutip/operators.html:8483,Availability,error,error,8483,"Qobj data =; [[ 1. 0.]; [ 0. -1.]]. """"""; return 2.0 * jmat(1.0 / 2, 'z'). #; # DESTROY returns annihilation operator for N dimensional Hilbert space; # out = destroy(N), N is integer value & N>0; #; [docs]def destroy(N, offset=0):; '''Destruction (lowering) operator. Parameters; ----------; N : int; Dimension of Hilbert space. offset : int (default 0); The lowest number state that is included in the finite number state; representation of the operator. Returns; -------; oper : qobj; Qobj for lowering operator. Examples; --------; >>> destroy(4); Quantum object: dims = [[4], [4]], \; shape = [4, 4], type = oper, isHerm = False; Qobj data =; [[ 0.00000000+0.j 1.00000000+0.j 0.00000000+0.j 0.00000000+0.j]; [ 0.00000000+0.j 0.00000000+0.j 1.41421356+0.j 0.00000000+0.j]; [ 0.00000000+0.j 0.00000000+0.j 0.00000000+0.j 1.73205081+0.j]; [ 0.00000000+0.j 0.00000000+0.j 0.00000000+0.j 0.00000000+0.j]]. '''; if not isinstance(N, (int, np.integer)): # raise error if N not integer; raise ValueError(""Hilbert space dimension must be integer value""); data = np.sqrt(np.arange(offset+1, N+offset, dtype=complex)); ind = np.arange(1,N, dtype=np.int32); ptr = np.arange(N+1, dtype=np.int32); ptr[-1] = N-1; return Qobj(fast_csr_matrix((data,ind,ptr),shape=(N,N)), isherm=False). #; # create returns creation operator for N dimensional Hilbert space; # out = create(N), N is integer value & N>0; #; [docs]def create(N, offset=0):; '''Creation (raising) operator. Parameters; ----------; N : int; Dimension of Hilbert space. Returns; -------; oper : qobj; Qobj for raising operator. offset : int (default 0); The lowest number state that is included in the finite number state; representation of the operator. Examples; --------; >>> create(4); Quantum object: dims = [[4], [4]], \; shape = [4, 4], type = oper, isHerm = False; Qobj data =; [[ 0.00000000+0.j 0.00000000+0.j 0.00000000+0.j 0.00000000+0.j]; [ 1.00000000+0.j 0.00000000+0.j 0.00000000+0.j 0.00000000+0.j]; [ 0.00000000+0.j 1.41421356+0.j 0.00",MatchSource.WIKI,docs/4.2/modules/qutip/operators.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/operators.html
https://qutip.org/docs/4.2/modules/qutip/operators.html:9671,Availability,error,error,9671,"matrix((data,ind,ptr),shape=(N,N)), isherm=False). #; # create returns creation operator for N dimensional Hilbert space; # out = create(N), N is integer value & N>0; #; [docs]def create(N, offset=0):; '''Creation (raising) operator. Parameters; ----------; N : int; Dimension of Hilbert space. Returns; -------; oper : qobj; Qobj for raising operator. offset : int (default 0); The lowest number state that is included in the finite number state; representation of the operator. Examples; --------; >>> create(4); Quantum object: dims = [[4], [4]], \; shape = [4, 4], type = oper, isHerm = False; Qobj data =; [[ 0.00000000+0.j 0.00000000+0.j 0.00000000+0.j 0.00000000+0.j]; [ 1.00000000+0.j 0.00000000+0.j 0.00000000+0.j 0.00000000+0.j]; [ 0.00000000+0.j 1.41421356+0.j 0.00000000+0.j 0.00000000+0.j]; [ 0.00000000+0.j 0.00000000+0.j 1.73205081+0.j 0.00000000+0.j]]. '''; if not isinstance(N, (int, np.integer)): # raise error if N not integer; raise ValueError(""Hilbert space dimension must be integer value""); qo = destroy(N, offset=offset) # create operator using destroy function; return qo.dag(). #; # QEYE returns identity operator for an N dimensional space; # a = qeye(N), N is integer & N>0; #; [docs]def qeye(N):; """"""; Identity operator. Parameters; ----------; N : int or list of ints; Dimension of Hilbert space. If provided as a list of ints,; then the dimension is the product over this list, but the; ``dims`` property of the new Qobj are set to this list. Returns; -------; oper : qobj; Identity operator Qobj. Examples; --------; >>> qeye(3); Quantum object: dims = [[3], [3]], \; shape = [3, 3], type = oper, isHerm = True; Qobj data =; [[ 1. 0. 0.]; [ 0. 1. 0.]; [ 0. 0. 1.]]. """"""; if isinstance(N, list):; return tensor(*[identity(n) for n in N]); N = int(N); if N < 0:; raise ValueError(""N must be integer N>=0""); return Qobj(fast_identity(N), isherm=True). [docs]def identity(N):; """"""Identity operator. Alternative name to :func:`qeye`. Parameters; ----------; N : int or list ",MatchSource.WIKI,docs/4.2/modules/qutip/operators.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/operators.html
https://qutip.org/docs/4.2/modules/qutip/operators.html:22177,Deployability,update,updated,22177,"in the; state space. state : list of integers; The state in the number basis representation. Returns; -------; op : Qobj; A Qobj instance that represent the identity operator in the; exication-number-restricted state space defined by `dims` and; `exciations`.; """"""; from qutip.states import enr_state_dictionaries. nstates, _, _ = enr_state_dictionaries(dims, excitations); data = sp.eye(nstates, nstates, dtype=np.complex); return Qobj(data, dims=[dims, dims]). [docs]def charge(Nmax, Nmin=None, frac = 1):; """"""; Generate the diagonal charge operator over charge states; from Nmin to Nmax.; ; Parameters; ----------; Nmax : int; Maximum charge state to consider.; ; Nmin : int (default = -Nmax); Lowest charge state to consider.; ; frac : float (default = 1); Specify fractional charge if needed.; ; Returns; -------; C : Qobj; Charge operator over [Nmin,Nmax].; ; Notes; -----; .. versionadded:: 3.2; ; """"""; if Nmin is None:; Nmin = -Nmax; diag = np.arange(Nmin, Nmax+1, dtype=float); if frac != 1:; diag *= frac; C = sp.diags(diag, 0, format='csr', dtype=complex); return Qobj(C, isherm=True). [docs]def tunneling(N, m=1):; """"""; Tunneling operator with elements of the form ; :math:`\sum |N><N+m| + |N+m><N|`.; ; Parameters; ----------; N : int; Number of basis states in Hilbert space.; m : int (default = 1); Number of excitations in tunneling event.; ; Returns; -------; T : Qobj; Tunneling operator.; ; Notes; -----; .. versionadded:: 3.2; ; """"""; diags = [np.ones(N-m,dtype=int),np.ones(N-m,dtype=int)]; T = sp.diags(diags,[m,-m],format='csr', dtype=complex); return Qobj(T, isherm=True). # Break circular dependencies by a trailing import.; # Note that we use a relative import here to deal with that; # qutip.tensor is the *function* tensor, not the module.; from qutip.tensor import tensor.  Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, and A.L. Grimsmo.; Last updated on Jan 17, 2018. . Built with Sphinx using a theme provided by Read the Docs. . ",MatchSource.WIKI,docs/4.2/modules/qutip/operators.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/operators.html
https://qutip.org/docs/4.2/modules/qutip/operators.html:2528,Energy Efficiency,charge,charge,2528,"ERCHANTABILITY AND FITNESS FOR A; # PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT; # HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,; # SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT; # LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,; # DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY; # THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT; # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE; # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.; ###############################################################################; """"""; This module contains functions for generating Qobj representation of a variety; of commonly occuring quantum operators.; """""". __all__ = ['jmat', 'spin_Jx', 'spin_Jy', 'spin_Jz', 'spin_Jm', 'spin_Jp',; 'spin_J_set', 'sigmap', 'sigmam', 'sigmax', 'sigmay', 'sigmaz',; 'destroy', 'create', 'qeye', 'identity', 'position', 'momentum',; 'num', 'squeeze', 'squeezing', 'displace', 'commutator',; 'qutrit_ops', 'qdiags', 'phase', 'qzero', 'enr_destroy',; 'enr_identity', 'charge', 'tunneling']. import numpy as np; import scipy; import scipy.sparse as sp; from qutip.qobj import Qobj; from qutip.fastsparse import fast_csr_matrix, fast_identity. #; # Spin operators; #; [docs]def jmat(j, *args):; """"""Higher-order spin operators:. Parameters; ----------; j : float; Spin of operator. args : str; Which operator to return 'x','y','z','+','-'.; If no args given, then output is ['x','y','z']. Returns; -------; jmat : qobj / ndarray; ``qobj`` for requested spin operator(s). Examples; --------; >>> jmat(1); [ Quantum object: dims = [[3], [3]], \; shape = [3, 3], type = oper, isHerm = True; Qobj data =; [[ 0. 0.70710678 0. ]; [ 0.70710678 0. 0.70710678]; [ 0. 0.70710678 0. ]]; Quantum object: dims = [[3], [3]], \; shape = [3, 3], type = oper, isHerm = True; Qobj data =; [[ 0.+0.j 0.-0.70710678j 0.+0.j ]; [ 0.+0",MatchSource.WIKI,docs/4.2/modules/qutip/operators.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/operators.html
https://qutip.org/docs/4.2/modules/qutip/operators.html:20738,Energy Efficiency,charge,charge,20738,"for a in a_ops]. [docs]def enr_identity(dims, excitations):; """"""; Generate the identity operator for the excitation-number restricted; state space defined by the `dims` and `exciations` arguments. See the; docstring for enr_fock for a more detailed description of these arguments. Parameters; ----------; dims : list; A list of the dimensions of each subsystem of a composite quantum; system. excitations : integer; The maximum number of excitations that are to be included in the; state space. state : list of integers; The state in the number basis representation. Returns; -------; op : Qobj; A Qobj instance that represent the identity operator in the; exication-number-restricted state space defined by `dims` and; `exciations`.; """"""; from qutip.states import enr_state_dictionaries. nstates, _, _ = enr_state_dictionaries(dims, excitations); data = sp.eye(nstates, nstates, dtype=np.complex); return Qobj(data, dims=[dims, dims]). [docs]def charge(Nmax, Nmin=None, frac = 1):; """"""; Generate the diagonal charge operator over charge states; from Nmin to Nmax.; ; Parameters; ----------; Nmax : int; Maximum charge state to consider.; ; Nmin : int (default = -Nmax); Lowest charge state to consider.; ; frac : float (default = 1); Specify fractional charge if needed.; ; Returns; -------; C : Qobj; Charge operator over [Nmin,Nmax].; ; Notes; -----; .. versionadded:: 3.2; ; """"""; if Nmin is None:; Nmin = -Nmax; diag = np.arange(Nmin, Nmax+1, dtype=float); if frac != 1:; diag *= frac; C = sp.diags(diag, 0, format='csr', dtype=complex); return Qobj(C, isherm=True). [docs]def tunneling(N, m=1):; """"""; Tunneling operator with elements of the form ; :math:`\sum |N><N+m| + |N+m><N|`.; ; Parameters; ----------; N : int; Number of basis states in Hilbert space.; m : int (default = 1); Number of excitations in tunneling event.; ; Returns; -------; T : Qobj; Tunneling operator.; ; Notes; -----; .. versionadded:: 3.2; ; """"""; diags = [np.ones(N-m,dtype=int),np.ones(N-m,dtype=int)]; T = sp.diags(di",MatchSource.WIKI,docs/4.2/modules/qutip/operators.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/operators.html
https://qutip.org/docs/4.2/modules/qutip/operators.html:20801,Energy Efficiency,charge,charge,20801,"for a in a_ops]. [docs]def enr_identity(dims, excitations):; """"""; Generate the identity operator for the excitation-number restricted; state space defined by the `dims` and `exciations` arguments. See the; docstring for enr_fock for a more detailed description of these arguments. Parameters; ----------; dims : list; A list of the dimensions of each subsystem of a composite quantum; system. excitations : integer; The maximum number of excitations that are to be included in the; state space. state : list of integers; The state in the number basis representation. Returns; -------; op : Qobj; A Qobj instance that represent the identity operator in the; exication-number-restricted state space defined by `dims` and; `exciations`.; """"""; from qutip.states import enr_state_dictionaries. nstates, _, _ = enr_state_dictionaries(dims, excitations); data = sp.eye(nstates, nstates, dtype=np.complex); return Qobj(data, dims=[dims, dims]). [docs]def charge(Nmax, Nmin=None, frac = 1):; """"""; Generate the diagonal charge operator over charge states; from Nmin to Nmax.; ; Parameters; ----------; Nmax : int; Maximum charge state to consider.; ; Nmin : int (default = -Nmax); Lowest charge state to consider.; ; frac : float (default = 1); Specify fractional charge if needed.; ; Returns; -------; C : Qobj; Charge operator over [Nmin,Nmax].; ; Notes; -----; .. versionadded:: 3.2; ; """"""; if Nmin is None:; Nmin = -Nmax; diag = np.arange(Nmin, Nmax+1, dtype=float); if frac != 1:; diag *= frac; C = sp.diags(diag, 0, format='csr', dtype=complex); return Qobj(C, isherm=True). [docs]def tunneling(N, m=1):; """"""; Tunneling operator with elements of the form ; :math:`\sum |N><N+m| + |N+m><N|`.; ; Parameters; ----------; N : int; Number of basis states in Hilbert space.; m : int (default = 1); Number of excitations in tunneling event.; ; Returns; -------; T : Qobj; Tunneling operator.; ; Notes; -----; .. versionadded:: 3.2; ; """"""; diags = [np.ones(N-m,dtype=int),np.ones(N-m,dtype=int)]; T = sp.diags(di",MatchSource.WIKI,docs/4.2/modules/qutip/operators.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/operators.html
https://qutip.org/docs/4.2/modules/qutip/operators.html:20822,Energy Efficiency,charge,charge,20822,"for a in a_ops]. [docs]def enr_identity(dims, excitations):; """"""; Generate the identity operator for the excitation-number restricted; state space defined by the `dims` and `exciations` arguments. See the; docstring for enr_fock for a more detailed description of these arguments. Parameters; ----------; dims : list; A list of the dimensions of each subsystem of a composite quantum; system. excitations : integer; The maximum number of excitations that are to be included in the; state space. state : list of integers; The state in the number basis representation. Returns; -------; op : Qobj; A Qobj instance that represent the identity operator in the; exication-number-restricted state space defined by `dims` and; `exciations`.; """"""; from qutip.states import enr_state_dictionaries. nstates, _, _ = enr_state_dictionaries(dims, excitations); data = sp.eye(nstates, nstates, dtype=np.complex); return Qobj(data, dims=[dims, dims]). [docs]def charge(Nmax, Nmin=None, frac = 1):; """"""; Generate the diagonal charge operator over charge states; from Nmin to Nmax.; ; Parameters; ----------; Nmax : int; Maximum charge state to consider.; ; Nmin : int (default = -Nmax); Lowest charge state to consider.; ; frac : float (default = 1); Specify fractional charge if needed.; ; Returns; -------; C : Qobj; Charge operator over [Nmin,Nmax].; ; Notes; -----; .. versionadded:: 3.2; ; """"""; if Nmin is None:; Nmin = -Nmax; diag = np.arange(Nmin, Nmax+1, dtype=float); if frac != 1:; diag *= frac; C = sp.diags(diag, 0, format='csr', dtype=complex); return Qobj(C, isherm=True). [docs]def tunneling(N, m=1):; """"""; Tunneling operator with elements of the form ; :math:`\sum |N><N+m| + |N+m><N|`.; ; Parameters; ----------; N : int; Number of basis states in Hilbert space.; m : int (default = 1); Number of excitations in tunneling event.; ; Returns; -------; T : Qobj; Tunneling operator.; ; Notes; -----; .. versionadded:: 3.2; ; """"""; diags = [np.ones(N-m,dtype=int),np.ones(N-m,dtype=int)]; T = sp.diags(di",MatchSource.WIKI,docs/4.2/modules/qutip/operators.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/operators.html
https://qutip.org/docs/4.2/modules/qutip/operators.html:20903,Energy Efficiency,charge,charge,20903," the excitation-number restricted; state space defined by the `dims` and `exciations` arguments. See the; docstring for enr_fock for a more detailed description of these arguments. Parameters; ----------; dims : list; A list of the dimensions of each subsystem of a composite quantum; system. excitations : integer; The maximum number of excitations that are to be included in the; state space. state : list of integers; The state in the number basis representation. Returns; -------; op : Qobj; A Qobj instance that represent the identity operator in the; exication-number-restricted state space defined by `dims` and; `exciations`.; """"""; from qutip.states import enr_state_dictionaries. nstates, _, _ = enr_state_dictionaries(dims, excitations); data = sp.eye(nstates, nstates, dtype=np.complex); return Qobj(data, dims=[dims, dims]). [docs]def charge(Nmax, Nmin=None, frac = 1):; """"""; Generate the diagonal charge operator over charge states; from Nmin to Nmax.; ; Parameters; ----------; Nmax : int; Maximum charge state to consider.; ; Nmin : int (default = -Nmax); Lowest charge state to consider.; ; frac : float (default = 1); Specify fractional charge if needed.; ; Returns; -------; C : Qobj; Charge operator over [Nmin,Nmax].; ; Notes; -----; .. versionadded:: 3.2; ; """"""; if Nmin is None:; Nmin = -Nmax; diag = np.arange(Nmin, Nmax+1, dtype=float); if frac != 1:; diag *= frac; C = sp.diags(diag, 0, format='csr', dtype=complex); return Qobj(C, isherm=True). [docs]def tunneling(N, m=1):; """"""; Tunneling operator with elements of the form ; :math:`\sum |N><N+m| + |N+m><N|`.; ; Parameters; ----------; N : int; Number of basis states in Hilbert space.; m : int (default = 1); Number of excitations in tunneling event.; ; Returns; -------; T : Qobj; Tunneling operator.; ; Notes; -----; .. versionadded:: 3.2; ; """"""; diags = [np.ones(N-m,dtype=int),np.ones(N-m,dtype=int)]; T = sp.diags(diags,[m,-m],format='csr', dtype=complex); return Qobj(T, isherm=True). # Break circular dependencies b",MatchSource.WIKI,docs/4.2/modules/qutip/operators.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/operators.html
https://qutip.org/docs/4.2/modules/qutip/operators.html:20969,Energy Efficiency,charge,charge,20969,"nd `exciations` arguments. See the; docstring for enr_fock for a more detailed description of these arguments. Parameters; ----------; dims : list; A list of the dimensions of each subsystem of a composite quantum; system. excitations : integer; The maximum number of excitations that are to be included in the; state space. state : list of integers; The state in the number basis representation. Returns; -------; op : Qobj; A Qobj instance that represent the identity operator in the; exication-number-restricted state space defined by `dims` and; `exciations`.; """"""; from qutip.states import enr_state_dictionaries. nstates, _, _ = enr_state_dictionaries(dims, excitations); data = sp.eye(nstates, nstates, dtype=np.complex); return Qobj(data, dims=[dims, dims]). [docs]def charge(Nmax, Nmin=None, frac = 1):; """"""; Generate the diagonal charge operator over charge states; from Nmin to Nmax.; ; Parameters; ----------; Nmax : int; Maximum charge state to consider.; ; Nmin : int (default = -Nmax); Lowest charge state to consider.; ; frac : float (default = 1); Specify fractional charge if needed.; ; Returns; -------; C : Qobj; Charge operator over [Nmin,Nmax].; ; Notes; -----; .. versionadded:: 3.2; ; """"""; if Nmin is None:; Nmin = -Nmax; diag = np.arange(Nmin, Nmax+1, dtype=float); if frac != 1:; diag *= frac; C = sp.diags(diag, 0, format='csr', dtype=complex); return Qobj(C, isherm=True). [docs]def tunneling(N, m=1):; """"""; Tunneling operator with elements of the form ; :math:`\sum |N><N+m| + |N+m><N|`.; ; Parameters; ----------; N : int; Number of basis states in Hilbert space.; m : int (default = 1); Number of excitations in tunneling event.; ; Returns; -------; T : Qobj; Tunneling operator.; ; Notes; -----; .. versionadded:: 3.2; ; """"""; diags = [np.ones(N-m,dtype=int),np.ones(N-m,dtype=int)]; T = sp.diags(diags,[m,-m],format='csr', dtype=complex); return Qobj(T, isherm=True). # Break circular dependencies by a trailing import.; # Note that we use a relative import here to de",MatchSource.WIKI,docs/4.2/modules/qutip/operators.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/operators.html
https://qutip.org/docs/4.2/modules/qutip/operators.html:21045,Energy Efficiency,charge,charge,21045,"re detailed description of these arguments. Parameters; ----------; dims : list; A list of the dimensions of each subsystem of a composite quantum; system. excitations : integer; The maximum number of excitations that are to be included in the; state space. state : list of integers; The state in the number basis representation. Returns; -------; op : Qobj; A Qobj instance that represent the identity operator in the; exication-number-restricted state space defined by `dims` and; `exciations`.; """"""; from qutip.states import enr_state_dictionaries. nstates, _, _ = enr_state_dictionaries(dims, excitations); data = sp.eye(nstates, nstates, dtype=np.complex); return Qobj(data, dims=[dims, dims]). [docs]def charge(Nmax, Nmin=None, frac = 1):; """"""; Generate the diagonal charge operator over charge states; from Nmin to Nmax.; ; Parameters; ----------; Nmax : int; Maximum charge state to consider.; ; Nmin : int (default = -Nmax); Lowest charge state to consider.; ; frac : float (default = 1); Specify fractional charge if needed.; ; Returns; -------; C : Qobj; Charge operator over [Nmin,Nmax].; ; Notes; -----; .. versionadded:: 3.2; ; """"""; if Nmin is None:; Nmin = -Nmax; diag = np.arange(Nmin, Nmax+1, dtype=float); if frac != 1:; diag *= frac; C = sp.diags(diag, 0, format='csr', dtype=complex); return Qobj(C, isherm=True). [docs]def tunneling(N, m=1):; """"""; Tunneling operator with elements of the form ; :math:`\sum |N><N+m| + |N+m><N|`.; ; Parameters; ----------; N : int; Number of basis states in Hilbert space.; m : int (default = 1); Number of excitations in tunneling event.; ; Returns; -------; T : Qobj; Tunneling operator.; ; Notes; -----; .. versionadded:: 3.2; ; """"""; diags = [np.ones(N-m,dtype=int),np.ones(N-m,dtype=int)]; T = sp.diags(diags,[m,-m],format='csr', dtype=complex); return Qobj(T, isherm=True). # Break circular dependencies by a trailing import.; # Note that we use a relative import here to deal with that; # qutip.tensor is the *function* tensor, not the modu",MatchSource.WIKI,docs/4.2/modules/qutip/operators.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/operators.html
https://qutip.org/docs/4.2/modules/qutip/operators.html:21878,Integrability,depend,dependencies,21878,"in the; state space. state : list of integers; The state in the number basis representation. Returns; -------; op : Qobj; A Qobj instance that represent the identity operator in the; exication-number-restricted state space defined by `dims` and; `exciations`.; """"""; from qutip.states import enr_state_dictionaries. nstates, _, _ = enr_state_dictionaries(dims, excitations); data = sp.eye(nstates, nstates, dtype=np.complex); return Qobj(data, dims=[dims, dims]). [docs]def charge(Nmax, Nmin=None, frac = 1):; """"""; Generate the diagonal charge operator over charge states; from Nmin to Nmax.; ; Parameters; ----------; Nmax : int; Maximum charge state to consider.; ; Nmin : int (default = -Nmax); Lowest charge state to consider.; ; frac : float (default = 1); Specify fractional charge if needed.; ; Returns; -------; C : Qobj; Charge operator over [Nmin,Nmax].; ; Notes; -----; .. versionadded:: 3.2; ; """"""; if Nmin is None:; Nmin = -Nmax; diag = np.arange(Nmin, Nmax+1, dtype=float); if frac != 1:; diag *= frac; C = sp.diags(diag, 0, format='csr', dtype=complex); return Qobj(C, isherm=True). [docs]def tunneling(N, m=1):; """"""; Tunneling operator with elements of the form ; :math:`\sum |N><N+m| + |N+m><N|`.; ; Parameters; ----------; N : int; Number of basis states in Hilbert space.; m : int (default = 1); Number of excitations in tunneling event.; ; Returns; -------; T : Qobj; Tunneling operator.; ; Notes; -----; .. versionadded:: 3.2; ; """"""; diags = [np.ones(N-m,dtype=int),np.ones(N-m,dtype=int)]; T = sp.diags(diags,[m,-m],format='csr', dtype=complex); return Qobj(T, isherm=True). # Break circular dependencies by a trailing import.; # Note that we use a relative import here to deal with that; # qutip.tensor is the *function* tensor, not the module.; from qutip.tensor import tensor.  Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, and A.L. Grimsmo.; Last updated on Jan 17, 2018. . Built with Sphinx using a theme provided by Read the Docs. . ",MatchSource.WIKI,docs/4.2/modules/qutip/operators.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/operators.html
https://qutip.org/docs/4.2/modules/qutip/orbital.html:4724,Deployability,update,updated,4724," args[0]. for k in range(len(args)):; ket = args[k]; if not ket.type == 'ket':; raise TypeError('Invalid input ket in orbital'); sk = ket.shape; nchk = (sk[0] - 1) / 2.0; if nchk != np.floor(nchk):; raise ValueError(; 'Kets must have odd number of components in orbital'); l = int((sk[0] - 1) / 2); if l == 0:; SPlm = np.sqrt(2) * np.ones((np.size(theta), 1), dtype=complex); else:; SPlm = _sch_lpmv(l, np.cos(theta)); fac = np.sqrt((2.0 * l + 1) / (8 * np.pi)); kf = ket.full(); psi += np.sqrt(2) * fac * kf[l, 0] * np.ones((np.size(phi),; np.size(theta)),; dtype=complex) * SPlm[0]; for m in range(1, l + 1):; psi += ((-1.0) ** m * fac * kf[l - m, 0]) * \; np.array([np.exp(1.0j * 1 * phi)]).T * \; np.ones((np.size(phi), np.size(theta)),; dtype=complex) * SPlm[1]; for m in range(-l, 0):; psi = psi + (fac * kf[l - m, 0]) * \; np.array([np.exp(1.0j * 1 * phi)]).T * \; np.ones((np.size(phi), np.size(theta)), dtype=complex) * \; SPlm[abs(m)]; return psi. # Schmidt Semi-normalized Associated Legendre Functions; def _sch_lpmv(n, x):; '''; Outputs array of Schmidt Seminormalized Associated Legendre Functions; S_{n}^{m} for m<=n. Parameters; ----------; n : int; Degree of polynomial. x : float; Point at which to evaluate. Returns; -------; array of values for Legendre functions. '''; from scipy.special import lpmv; n = int(n); sch = np.array([1.0]); sch2 = np.array([(-1.0) ** m * np.sqrt(; (2.0 * factorial(n - m)) / factorial(n + m)) for m in range(1, n + 1)]); sch = np.append(sch, sch2); if isinstance(x, float) or len(x) == 1:; leg = lpmv(np.arange(0, n + 1), n, x); return np.array([sch * leg]).T; else:; for j in range(0, len(x)):; leg = lpmv(range(0, n + 1), n, x[j]); if j == 0:; out = np.array([sch * leg]).T; else:; out = np.append(out, np.array([sch * leg]).T, axis=1); return out.  Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, and A.L. Grimsmo.; Last updated on Jan 17, 2018. . Built with Sphinx using a theme provided by Read the Docs. . ",MatchSource.WIKI,docs/4.2/modules/qutip/orbital.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/orbital.html
https://qutip.org/docs/4.2/modules/qutip/parallel.html:6365,Deployability,update,update,6365,"This function work as a drop-in replacement of :func:`qutip.parallel_map`. Parameters; ----------; task : a Python function; The function that is to be called for each value in ``task_vec``.; values : array / list; The list or array of values for which the ``task`` function is to be; evaluated.; task_args : list / dictionary; The optional additional argument to the ``task`` function.; task_kwargs : list / dictionary; The optional additional keyword argument to the ``task`` function.; progress_bar : ProgressBar; Progress bar class instance for showing progress. Returns; --------; result : list; The result list contains the value of; ``task(value, *task_args, **task_kwargs)`` for each; value in ``values``.; ; """"""; try:; progress_bar = kwargs['progress_bar']; if progress_bar is True:; progress_bar = TextProgressBar(); except:; progress_bar = BaseProgressBar(). progress_bar.start(len(values)); results = []; for n, value in enumerate(values):; progress_bar.update(n); result = task(value, *task_args, **task_kwargs); results.append(result); progress_bar.finished(). return results. [docs]def parallel_map(task, values, task_args=tuple(), task_kwargs={}, **kwargs):; """"""; Parallel execution of a mapping of `values` to the function `task`. This; is functionally equivalent to::. result = [task(value, *task_args, **task_kwargs) for value in values]. Parameters; ----------; task : a Python function; The function that is to be called for each value in ``task_vec``.; values : array / list; The list or array of values for which the ``task`` function is to be; evaluated.; task_args : list / dictionary; The optional additional argument to the ``task`` function.; task_kwargs : list / dictionary; The optional additional keyword argument to the ``task`` function.; progress_bar : ProgressBar; Progress bar class instance for showing progress. Returns; --------; result : list; The result list contains the value of ; ``task(value, *task_args, **task_kwargs)`` for ; each value in ``values``. """,MatchSource.WIKI,docs/4.2/modules/qutip/parallel.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/parallel.html
https://qutip.org/docs/4.2/modules/qutip/parallel.html:7792,Deployability,update,update,7792,"mapping of `values` to the function `task`. This; is functionally equivalent to::. result = [task(value, *task_args, **task_kwargs) for value in values]. Parameters; ----------; task : a Python function; The function that is to be called for each value in ``task_vec``.; values : array / list; The list or array of values for which the ``task`` function is to be; evaluated.; task_args : list / dictionary; The optional additional argument to the ``task`` function.; task_kwargs : list / dictionary; The optional additional keyword argument to the ``task`` function.; progress_bar : ProgressBar; Progress bar class instance for showing progress. Returns; --------; result : list; The result list contains the value of ; ``task(value, *task_args, **task_kwargs)`` for ; each value in ``values``. """"""; os.environ['QUTIP_IN_PARALLEL'] = 'TRUE'; kw = _default_kwargs(); if 'num_cpus' in kwargs:; kw['num_cpus'] = kwargs['num_cpus']. try:; progress_bar = kwargs['progress_bar']; if progress_bar is True:; progress_bar = TextProgressBar(); except:; progress_bar = BaseProgressBar(). progress_bar.start(len(values)); nfinished = [0]. def _update_progress_bar(x):; nfinished[0] += 1; progress_bar.update(nfinished[0]). try:; pool = Pool(processes=kw['num_cpus']). async_res = [pool.apply_async(task, (value,) + task_args, task_kwargs,; _update_progress_bar); for value in values]. while not all([ar.ready() for ar in async_res]):; for ar in async_res:; ar.wait(timeout=0.1). pool.terminate(); pool.join(). except KeyboardInterrupt as e:; os.environ['QUTIP_IN_PARALLEL'] = 'FALSE'; pool.terminate(); pool.join(); raise e. progress_bar.finished(); os.environ['QUTIP_IN_PARALLEL'] = 'FALSE'; return [ar.get() for ar in async_res]. def _default_kwargs():; settings = {'num_cpus': qset.num_cpus}; return settings.  Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, and A.L. Grimsmo.; Last updated on Jan 17, 2018. . Built with Sphinx using a theme provided by Read the Docs. . ",MatchSource.WIKI,docs/4.2/modules/qutip/parallel.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/parallel.html
https://qutip.org/docs/4.2/modules/qutip/parallel.html:8515,Deployability,update,updated,8515,"mapping of `values` to the function `task`. This; is functionally equivalent to::. result = [task(value, *task_args, **task_kwargs) for value in values]. Parameters; ----------; task : a Python function; The function that is to be called for each value in ``task_vec``.; values : array / list; The list or array of values for which the ``task`` function is to be; evaluated.; task_args : list / dictionary; The optional additional argument to the ``task`` function.; task_kwargs : list / dictionary; The optional additional keyword argument to the ``task`` function.; progress_bar : ProgressBar; Progress bar class instance for showing progress. Returns; --------; result : list; The result list contains the value of ; ``task(value, *task_args, **task_kwargs)`` for ; each value in ``values``. """"""; os.environ['QUTIP_IN_PARALLEL'] = 'TRUE'; kw = _default_kwargs(); if 'num_cpus' in kwargs:; kw['num_cpus'] = kwargs['num_cpus']. try:; progress_bar = kwargs['progress_bar']; if progress_bar is True:; progress_bar = TextProgressBar(); except:; progress_bar = BaseProgressBar(). progress_bar.start(len(values)); nfinished = [0]. def _update_progress_bar(x):; nfinished[0] += 1; progress_bar.update(nfinished[0]). try:; pool = Pool(processes=kw['num_cpus']). async_res = [pool.apply_async(task, (value,) + task_args, task_kwargs,; _update_progress_bar); for value in values]. while not all([ar.ready() for ar in async_res]):; for ar in async_res:; ar.wait(timeout=0.1). pool.terminate(); pool.join(). except KeyboardInterrupt as e:; os.environ['QUTIP_IN_PARALLEL'] = 'FALSE'; pool.terminate(); pool.join(); raise e. progress_bar.finished(); os.environ['QUTIP_IN_PARALLEL'] = 'FALSE'; return [ar.get() for ar in async_res]. def _default_kwargs():; settings = {'num_cpus': qset.num_cpus}; return settings.  Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, and A.L. Grimsmo.; Last updated on Jan 17, 2018. . Built with Sphinx using a theme provided by Read the Docs. . ",MatchSource.WIKI,docs/4.2/modules/qutip/parallel.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/parallel.html
https://qutip.org/docs/4.2/modules/qutip/parallel.html:2840,Modifiability,variab,variable,2840,"CLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE; # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.; ###############################################################################; """"""; This function provides functions for parallel execution of loops and function; mappings, using the builtin Python module multiprocessing.; """"""; __all__ = ['parfor', 'parallel_map', 'serial_map']. from scipy import array; from multiprocessing import Pool; from functools import partial; import os; import sys; import signal; import qutip.settings as qset; from qutip.ui.progressbar import BaseProgressBar, TextProgressBar. def _task_wrapper(args):; try:; return args[0](*args[1]); except KeyboardInterrupt:; os.kill(args[2], signal.SIGINT); sys.exit(1). def _task_wrapper_with_args(args, user_args):; try:; return args[0](*args[1], **user_args); except KeyboardInterrupt:; os.kill(args[2], signal.SIGINT); sys.exit(1). [docs]def parfor(func, *args, **kwargs):; """"""Executes a multi-variable function in parallel on the local machine. Parallel execution of a for-loop over function `func` for multiple input; arguments and keyword arguments. .. note::. From QuTiP 3.1, we recommend to use :func:`qutip.parallel_map`; instead of this function. Parameters; ----------; func : function_type; A function to run in parallel on the local machine. The function 'func'; accepts a series of arguments that are passed to the function as; variables. In general, the function can have multiple input variables,; and these arguments must be passed in the same order as they are; defined in the function definition. In addition, the user can pass; multiple keyword arguments to the function. The following keyword argument is reserved:. num_cpus : int; Number of CPU's to use. Default uses maximum number of CPU's.; Performance degrades if num_cpus is larger than the physical CPU; count of your machine. Returns; -------; result : list; A ``list`` with length equal to number of input param",MatchSource.WIKI,docs/4.2/modules/qutip/parallel.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/parallel.html
https://qutip.org/docs/4.2/modules/qutip/parallel.html:3285,Modifiability,variab,variables,3285,"al_map']. from scipy import array; from multiprocessing import Pool; from functools import partial; import os; import sys; import signal; import qutip.settings as qset; from qutip.ui.progressbar import BaseProgressBar, TextProgressBar. def _task_wrapper(args):; try:; return args[0](*args[1]); except KeyboardInterrupt:; os.kill(args[2], signal.SIGINT); sys.exit(1). def _task_wrapper_with_args(args, user_args):; try:; return args[0](*args[1], **user_args); except KeyboardInterrupt:; os.kill(args[2], signal.SIGINT); sys.exit(1). [docs]def parfor(func, *args, **kwargs):; """"""Executes a multi-variable function in parallel on the local machine. Parallel execution of a for-loop over function `func` for multiple input; arguments and keyword arguments. .. note::. From QuTiP 3.1, we recommend to use :func:`qutip.parallel_map`; instead of this function. Parameters; ----------; func : function_type; A function to run in parallel on the local machine. The function 'func'; accepts a series of arguments that are passed to the function as; variables. In general, the function can have multiple input variables,; and these arguments must be passed in the same order as they are; defined in the function definition. In addition, the user can pass; multiple keyword arguments to the function. The following keyword argument is reserved:. num_cpus : int; Number of CPU's to use. Default uses maximum number of CPU's.; Performance degrades if num_cpus is larger than the physical CPU; count of your machine. Returns; -------; result : list; A ``list`` with length equal to number of input parameters; containing the output from `func`. """"""; os.environ['QUTIP_IN_PARALLEL'] = 'TRUE'; kw = _default_kwargs(); if 'num_cpus' in kwargs.keys():; kw['num_cpus'] = kwargs['num_cpus']; del kwargs['num_cpus']; if len(kwargs) != 0:; task_func = partial(_task_wrapper_with_args, user_args=kwargs); else:; task_func = _task_wrapper. if kw['num_cpus'] > qset.num_cpus:; print(""Requested number of CPUs (%s) "" % kw['num_",MatchSource.WIKI,docs/4.2/modules/qutip/parallel.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/parallel.html
https://qutip.org/docs/4.2/modules/qutip/parallel.html:3345,Modifiability,variab,variables,3345,"signal; import qutip.settings as qset; from qutip.ui.progressbar import BaseProgressBar, TextProgressBar. def _task_wrapper(args):; try:; return args[0](*args[1]); except KeyboardInterrupt:; os.kill(args[2], signal.SIGINT); sys.exit(1). def _task_wrapper_with_args(args, user_args):; try:; return args[0](*args[1], **user_args); except KeyboardInterrupt:; os.kill(args[2], signal.SIGINT); sys.exit(1). [docs]def parfor(func, *args, **kwargs):; """"""Executes a multi-variable function in parallel on the local machine. Parallel execution of a for-loop over function `func` for multiple input; arguments and keyword arguments. .. note::. From QuTiP 3.1, we recommend to use :func:`qutip.parallel_map`; instead of this function. Parameters; ----------; func : function_type; A function to run in parallel on the local machine. The function 'func'; accepts a series of arguments that are passed to the function as; variables. In general, the function can have multiple input variables,; and these arguments must be passed in the same order as they are; defined in the function definition. In addition, the user can pass; multiple keyword arguments to the function. The following keyword argument is reserved:. num_cpus : int; Number of CPU's to use. Default uses maximum number of CPU's.; Performance degrades if num_cpus is larger than the physical CPU; count of your machine. Returns; -------; result : list; A ``list`` with length equal to number of input parameters; containing the output from `func`. """"""; os.environ['QUTIP_IN_PARALLEL'] = 'TRUE'; kw = _default_kwargs(); if 'num_cpus' in kwargs.keys():; kw['num_cpus'] = kwargs['num_cpus']; del kwargs['num_cpus']; if len(kwargs) != 0:; task_func = partial(_task_wrapper_with_args, user_args=kwargs); else:; task_func = _task_wrapper. if kw['num_cpus'] > qset.num_cpus:; print(""Requested number of CPUs (%s) "" % kw['num_cpus'] +; ""is larger than physical number (%s)."" % qset.num_cpus); print(""Reduce 'num_cpus' for greater performance.""). pool = Pool",MatchSource.WIKI,docs/4.2/modules/qutip/parallel.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/parallel.html
https://qutip.org/docs/4.2/modules/qutip/parallel.html:4350,Performance,perform,performance,4350,"ltiple input variables,; and these arguments must be passed in the same order as they are; defined in the function definition. In addition, the user can pass; multiple keyword arguments to the function. The following keyword argument is reserved:. num_cpus : int; Number of CPU's to use. Default uses maximum number of CPU's.; Performance degrades if num_cpus is larger than the physical CPU; count of your machine. Returns; -------; result : list; A ``list`` with length equal to number of input parameters; containing the output from `func`. """"""; os.environ['QUTIP_IN_PARALLEL'] = 'TRUE'; kw = _default_kwargs(); if 'num_cpus' in kwargs.keys():; kw['num_cpus'] = kwargs['num_cpus']; del kwargs['num_cpus']; if len(kwargs) != 0:; task_func = partial(_task_wrapper_with_args, user_args=kwargs); else:; task_func = _task_wrapper. if kw['num_cpus'] > qset.num_cpus:; print(""Requested number of CPUs (%s) "" % kw['num_cpus'] +; ""is larger than physical number (%s)."" % qset.num_cpus); print(""Reduce 'num_cpus' for greater performance.""). pool = Pool(processes=kw['num_cpus']); args = [list(arg) for arg in args]; var = [[args[j][i] for j in range(len(args))]; for i in range(len(list(args[0])))]; try:; map_args = ((func, v, os.getpid()) for v in var); par_return = list(pool.map(task_func, map_args)). pool.terminate(); pool.join(); os.environ['QUTIP_IN_PARALLEL'] = 'FALSE'; if isinstance(par_return[0], tuple):; par_return = [elem for elem in par_return]; num_elems = len(par_return[0]); dt = [type(ii) for ii in par_return[0]]; return [array([elem[ii] for elem in par_return], dtype=dt[ii]); for ii in range(num_elems)]; else:; return list(par_return). except KeyboardInterrupt:; os.environ['QUTIP_IN_PARALLEL'] = 'FALSE'; pool.terminate(). [docs]def serial_map(task, values, task_args=tuple(), task_kwargs={}, **kwargs):; """"""; Serial mapping function with the same call signature as parallel_map, for; easy switching between serial and parallel execution. This; is functionally equivalent to::. resu",MatchSource.WIKI,docs/4.2/modules/qutip/parallel.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/parallel.html
https://qutip.org/docs/4.2/modules/qutip/parallel.html:8056,Safety,timeout,timeout,8056,"mapping of `values` to the function `task`. This; is functionally equivalent to::. result = [task(value, *task_args, **task_kwargs) for value in values]. Parameters; ----------; task : a Python function; The function that is to be called for each value in ``task_vec``.; values : array / list; The list or array of values for which the ``task`` function is to be; evaluated.; task_args : list / dictionary; The optional additional argument to the ``task`` function.; task_kwargs : list / dictionary; The optional additional keyword argument to the ``task`` function.; progress_bar : ProgressBar; Progress bar class instance for showing progress. Returns; --------; result : list; The result list contains the value of ; ``task(value, *task_args, **task_kwargs)`` for ; each value in ``values``. """"""; os.environ['QUTIP_IN_PARALLEL'] = 'TRUE'; kw = _default_kwargs(); if 'num_cpus' in kwargs:; kw['num_cpus'] = kwargs['num_cpus']. try:; progress_bar = kwargs['progress_bar']; if progress_bar is True:; progress_bar = TextProgressBar(); except:; progress_bar = BaseProgressBar(). progress_bar.start(len(values)); nfinished = [0]. def _update_progress_bar(x):; nfinished[0] += 1; progress_bar.update(nfinished[0]). try:; pool = Pool(processes=kw['num_cpus']). async_res = [pool.apply_async(task, (value,) + task_args, task_kwargs,; _update_progress_bar); for value in values]. while not all([ar.ready() for ar in async_res]):; for ar in async_res:; ar.wait(timeout=0.1). pool.terminate(); pool.join(). except KeyboardInterrupt as e:; os.environ['QUTIP_IN_PARALLEL'] = 'FALSE'; pool.terminate(); pool.join(); raise e. progress_bar.finished(); os.environ['QUTIP_IN_PARALLEL'] = 'FALSE'; return [ar.get() for ar in async_res]. def _default_kwargs():; settings = {'num_cpus': qset.num_cpus}; return settings.  Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, and A.L. Grimsmo.; Last updated on Jan 17, 2018. . Built with Sphinx using a theme provided by Read the Docs. . ",MatchSource.WIKI,docs/4.2/modules/qutip/parallel.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/parallel.html
https://qutip.org/docs/4.2/modules/qutip/partial_transpose.html:2396,Availability,mask,mask,2396," THE COPYRIGHT; # HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,; # SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT; # LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,; # DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY; # THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT; # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE; # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.; #; # Significant parts of this code was contributed by Jonas Neergaard-Nielsen; ###############################################################################. __all__ = ['partial_transpose']. import numpy as np; import scipy.sparse as sp. from qutip.qobj import Qobj; from qutip.states import (state_index_number, state_number_index,; state_number_enumerate). [docs]def partial_transpose(rho, mask, method='dense'):; """"""; Return the partial transpose of a Qobj instance `rho`,; where `mask` is an array/list with length that equals; the number of components of `rho` (that is, the length of; `rho.dims[0]`), and the values in `mask` indicates whether; or not the corresponding subsystem is to be transposed.; The elements in `mask` can be boolean or integers `0` or `1`,; where `True`/`1` indicates that the corresponding subsystem; should be tranposed. Parameters; ----------. rho : :class:`qutip.qobj`; A density matrix. mask : *list* / *array*; A mask that selects which subsystems should be transposed. method : str; choice of method, `dense` or `sparse`. The default method; is `dense`. The `sparse` implementation can be faster for; large and sparse systems (hundreds of quantum states). Returns; -------. rho_pr: :class:`qutip.qobj`. A density matrix with the selected subsystems transposed. """"""; if method == 'sparse':; return _partial_transpose_sparse(rho, mask); else:; return _partial_transpose_dense(rho, mask). def _partial_transpose_dense(rho, mask):; """"""; Based o",MatchSource.WIKI,docs/4.2/modules/qutip/partial_transpose.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/partial_transpose.html
https://qutip.org/docs/4.2/modules/qutip/partial_transpose.html:2488,Availability,mask,mask,2488," THE COPYRIGHT; # HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,; # SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT; # LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,; # DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY; # THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT; # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE; # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.; #; # Significant parts of this code was contributed by Jonas Neergaard-Nielsen; ###############################################################################. __all__ = ['partial_transpose']. import numpy as np; import scipy.sparse as sp. from qutip.qobj import Qobj; from qutip.states import (state_index_number, state_number_index,; state_number_enumerate). [docs]def partial_transpose(rho, mask, method='dense'):; """"""; Return the partial transpose of a Qobj instance `rho`,; where `mask` is an array/list with length that equals; the number of components of `rho` (that is, the length of; `rho.dims[0]`), and the values in `mask` indicates whether; or not the corresponding subsystem is to be transposed.; The elements in `mask` can be boolean or integers `0` or `1`,; where `True`/`1` indicates that the corresponding subsystem; should be tranposed. Parameters; ----------. rho : :class:`qutip.qobj`; A density matrix. mask : *list* / *array*; A mask that selects which subsystems should be transposed. method : str; choice of method, `dense` or `sparse`. The default method; is `dense`. The `sparse` implementation can be faster for; large and sparse systems (hundreds of quantum states). Returns; -------. rho_pr: :class:`qutip.qobj`. A density matrix with the selected subsystems transposed. """"""; if method == 'sparse':; return _partial_transpose_sparse(rho, mask); else:; return _partial_transpose_dense(rho, mask). def _partial_transpose_dense(rho, mask):; """"""; Based o",MatchSource.WIKI,docs/4.2/modules/qutip/partial_transpose.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/partial_transpose.html
https://qutip.org/docs/4.2/modules/qutip/partial_transpose.html:2630,Availability,mask,mask,2630,"OCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,; # DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY; # THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT; # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE; # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.; #; # Significant parts of this code was contributed by Jonas Neergaard-Nielsen; ###############################################################################. __all__ = ['partial_transpose']. import numpy as np; import scipy.sparse as sp. from qutip.qobj import Qobj; from qutip.states import (state_index_number, state_number_index,; state_number_enumerate). [docs]def partial_transpose(rho, mask, method='dense'):; """"""; Return the partial transpose of a Qobj instance `rho`,; where `mask` is an array/list with length that equals; the number of components of `rho` (that is, the length of; `rho.dims[0]`), and the values in `mask` indicates whether; or not the corresponding subsystem is to be transposed.; The elements in `mask` can be boolean or integers `0` or `1`,; where `True`/`1` indicates that the corresponding subsystem; should be tranposed. Parameters; ----------. rho : :class:`qutip.qobj`; A density matrix. mask : *list* / *array*; A mask that selects which subsystems should be transposed. method : str; choice of method, `dense` or `sparse`. The default method; is `dense`. The `sparse` implementation can be faster for; large and sparse systems (hundreds of quantum states). Returns; -------. rho_pr: :class:`qutip.qobj`. A density matrix with the selected subsystems transposed. """"""; if method == 'sparse':; return _partial_transpose_sparse(rho, mask); else:; return _partial_transpose_dense(rho, mask). def _partial_transpose_dense(rho, mask):; """"""; Based on Jonas' implementation using numpy.; Very fast for dense problems.; """"""; nsys = len(mask); pt_dims = np.arange(2 * nsys).reshape(2, nsys).T; pt_idx = np.concatenate([[pt_dim",MatchSource.WIKI,docs/4.2/modules/qutip/partial_transpose.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/partial_transpose.html
https://qutip.org/docs/4.2/modules/qutip/partial_transpose.html:2729,Availability,mask,mask,2729,"; # THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT; # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE; # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.; #; # Significant parts of this code was contributed by Jonas Neergaard-Nielsen; ###############################################################################. __all__ = ['partial_transpose']. import numpy as np; import scipy.sparse as sp. from qutip.qobj import Qobj; from qutip.states import (state_index_number, state_number_index,; state_number_enumerate). [docs]def partial_transpose(rho, mask, method='dense'):; """"""; Return the partial transpose of a Qobj instance `rho`,; where `mask` is an array/list with length that equals; the number of components of `rho` (that is, the length of; `rho.dims[0]`), and the values in `mask` indicates whether; or not the corresponding subsystem is to be transposed.; The elements in `mask` can be boolean or integers `0` or `1`,; where `True`/`1` indicates that the corresponding subsystem; should be tranposed. Parameters; ----------. rho : :class:`qutip.qobj`; A density matrix. mask : *list* / *array*; A mask that selects which subsystems should be transposed. method : str; choice of method, `dense` or `sparse`. The default method; is `dense`. The `sparse` implementation can be faster for; large and sparse systems (hundreds of quantum states). Returns; -------. rho_pr: :class:`qutip.qobj`. A density matrix with the selected subsystems transposed. """"""; if method == 'sparse':; return _partial_transpose_sparse(rho, mask); else:; return _partial_transpose_dense(rho, mask). def _partial_transpose_dense(rho, mask):; """"""; Based on Jonas' implementation using numpy.; Very fast for dense problems.; """"""; nsys = len(mask); pt_dims = np.arange(2 * nsys).reshape(2, nsys).T; pt_idx = np.concatenate([[pt_dims[n, mask[n]] for n in range(nsys)],; [pt_dims[n, 1 - mask[n]] for n in range(nsys)]]). data = rho.data.toarray().reshape(; np.a",MatchSource.WIKI,docs/4.2/modules/qutip/partial_transpose.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/partial_transpose.html
https://qutip.org/docs/4.2/modules/qutip/partial_transpose.html:2926,Availability,mask,mask,2926," THE POSSIBILITY OF SUCH DAMAGE.; #; # Significant parts of this code was contributed by Jonas Neergaard-Nielsen; ###############################################################################. __all__ = ['partial_transpose']. import numpy as np; import scipy.sparse as sp. from qutip.qobj import Qobj; from qutip.states import (state_index_number, state_number_index,; state_number_enumerate). [docs]def partial_transpose(rho, mask, method='dense'):; """"""; Return the partial transpose of a Qobj instance `rho`,; where `mask` is an array/list with length that equals; the number of components of `rho` (that is, the length of; `rho.dims[0]`), and the values in `mask` indicates whether; or not the corresponding subsystem is to be transposed.; The elements in `mask` can be boolean or integers `0` or `1`,; where `True`/`1` indicates that the corresponding subsystem; should be tranposed. Parameters; ----------. rho : :class:`qutip.qobj`; A density matrix. mask : *list* / *array*; A mask that selects which subsystems should be transposed. method : str; choice of method, `dense` or `sparse`. The default method; is `dense`. The `sparse` implementation can be faster for; large and sparse systems (hundreds of quantum states). Returns; -------. rho_pr: :class:`qutip.qobj`. A density matrix with the selected subsystems transposed. """"""; if method == 'sparse':; return _partial_transpose_sparse(rho, mask); else:; return _partial_transpose_dense(rho, mask). def _partial_transpose_dense(rho, mask):; """"""; Based on Jonas' implementation using numpy.; Very fast for dense problems.; """"""; nsys = len(mask); pt_dims = np.arange(2 * nsys).reshape(2, nsys).T; pt_idx = np.concatenate([[pt_dims[n, mask[n]] for n in range(nsys)],; [pt_dims[n, 1 - mask[n]] for n in range(nsys)]]). data = rho.data.toarray().reshape(; np.array(rho.dims).flatten()).transpose(pt_idx).reshape(rho.shape). return Qobj(data, dims=rho.dims). def _partial_transpose_sparse(rho, mask):; """"""; Implement the partial transpose using ",MatchSource.WIKI,docs/4.2/modules/qutip/partial_transpose.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/partial_transpose.html
https://qutip.org/docs/4.2/modules/qutip/partial_transpose.html:2953,Availability,mask,mask,2953," THE POSSIBILITY OF SUCH DAMAGE.; #; # Significant parts of this code was contributed by Jonas Neergaard-Nielsen; ###############################################################################. __all__ = ['partial_transpose']. import numpy as np; import scipy.sparse as sp. from qutip.qobj import Qobj; from qutip.states import (state_index_number, state_number_index,; state_number_enumerate). [docs]def partial_transpose(rho, mask, method='dense'):; """"""; Return the partial transpose of a Qobj instance `rho`,; where `mask` is an array/list with length that equals; the number of components of `rho` (that is, the length of; `rho.dims[0]`), and the values in `mask` indicates whether; or not the corresponding subsystem is to be transposed.; The elements in `mask` can be boolean or integers `0` or `1`,; where `True`/`1` indicates that the corresponding subsystem; should be tranposed. Parameters; ----------. rho : :class:`qutip.qobj`; A density matrix. mask : *list* / *array*; A mask that selects which subsystems should be transposed. method : str; choice of method, `dense` or `sparse`. The default method; is `dense`. The `sparse` implementation can be faster for; large and sparse systems (hundreds of quantum states). Returns; -------. rho_pr: :class:`qutip.qobj`. A density matrix with the selected subsystems transposed. """"""; if method == 'sparse':; return _partial_transpose_sparse(rho, mask); else:; return _partial_transpose_dense(rho, mask). def _partial_transpose_dense(rho, mask):; """"""; Based on Jonas' implementation using numpy.; Very fast for dense problems.; """"""; nsys = len(mask); pt_dims = np.arange(2 * nsys).reshape(2, nsys).T; pt_idx = np.concatenate([[pt_dims[n, mask[n]] for n in range(nsys)],; [pt_dims[n, 1 - mask[n]] for n in range(nsys)]]). data = rho.data.toarray().reshape(; np.array(rho.dims).flatten()).transpose(pt_idx).reshape(rho.shape). return Qobj(data, dims=rho.dims). def _partial_transpose_sparse(rho, mask):; """"""; Implement the partial transpose using ",MatchSource.WIKI,docs/4.2/modules/qutip/partial_transpose.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/partial_transpose.html
https://qutip.org/docs/4.2/modules/qutip/partial_transpose.html:3369,Availability,mask,mask,3369,"[docs]def partial_transpose(rho, mask, method='dense'):; """"""; Return the partial transpose of a Qobj instance `rho`,; where `mask` is an array/list with length that equals; the number of components of `rho` (that is, the length of; `rho.dims[0]`), and the values in `mask` indicates whether; or not the corresponding subsystem is to be transposed.; The elements in `mask` can be boolean or integers `0` or `1`,; where `True`/`1` indicates that the corresponding subsystem; should be tranposed. Parameters; ----------. rho : :class:`qutip.qobj`; A density matrix. mask : *list* / *array*; A mask that selects which subsystems should be transposed. method : str; choice of method, `dense` or `sparse`. The default method; is `dense`. The `sparse` implementation can be faster for; large and sparse systems (hundreds of quantum states). Returns; -------. rho_pr: :class:`qutip.qobj`. A density matrix with the selected subsystems transposed. """"""; if method == 'sparse':; return _partial_transpose_sparse(rho, mask); else:; return _partial_transpose_dense(rho, mask). def _partial_transpose_dense(rho, mask):; """"""; Based on Jonas' implementation using numpy.; Very fast for dense problems.; """"""; nsys = len(mask); pt_dims = np.arange(2 * nsys).reshape(2, nsys).T; pt_idx = np.concatenate([[pt_dims[n, mask[n]] for n in range(nsys)],; [pt_dims[n, 1 - mask[n]] for n in range(nsys)]]). data = rho.data.toarray().reshape(; np.array(rho.dims).flatten()).transpose(pt_idx).reshape(rho.shape). return Qobj(data, dims=rho.dims). def _partial_transpose_sparse(rho, mask):; """"""; Implement the partial transpose using the CSR sparse matrix.; """""". data = sp.lil_matrix((rho.shape[0], rho.shape[1]), dtype=complex). for m in range(len(rho.data.indptr) - 1):. n1 = rho.data.indptr[m]; n2 = rho.data.indptr[m + 1]. psi_A = state_index_number(rho.dims[0], m). for idx, n in enumerate(rho.data.indices[n1:n2]):. psi_B = state_index_number(rho.dims[1], n). m_pt = state_number_index(; rho.dims[1], np.choose(mask, [psi_A, ",MatchSource.WIKI,docs/4.2/modules/qutip/partial_transpose.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/partial_transpose.html
https://qutip.org/docs/4.2/modules/qutip/partial_transpose.html:3420,Availability,mask,mask,3420,"[docs]def partial_transpose(rho, mask, method='dense'):; """"""; Return the partial transpose of a Qobj instance `rho`,; where `mask` is an array/list with length that equals; the number of components of `rho` (that is, the length of; `rho.dims[0]`), and the values in `mask` indicates whether; or not the corresponding subsystem is to be transposed.; The elements in `mask` can be boolean or integers `0` or `1`,; where `True`/`1` indicates that the corresponding subsystem; should be tranposed. Parameters; ----------. rho : :class:`qutip.qobj`; A density matrix. mask : *list* / *array*; A mask that selects which subsystems should be transposed. method : str; choice of method, `dense` or `sparse`. The default method; is `dense`. The `sparse` implementation can be faster for; large and sparse systems (hundreds of quantum states). Returns; -------. rho_pr: :class:`qutip.qobj`. A density matrix with the selected subsystems transposed. """"""; if method == 'sparse':; return _partial_transpose_sparse(rho, mask); else:; return _partial_transpose_dense(rho, mask). def _partial_transpose_dense(rho, mask):; """"""; Based on Jonas' implementation using numpy.; Very fast for dense problems.; """"""; nsys = len(mask); pt_dims = np.arange(2 * nsys).reshape(2, nsys).T; pt_idx = np.concatenate([[pt_dims[n, mask[n]] for n in range(nsys)],; [pt_dims[n, 1 - mask[n]] for n in range(nsys)]]). data = rho.data.toarray().reshape(; np.array(rho.dims).flatten()).transpose(pt_idx).reshape(rho.shape). return Qobj(data, dims=rho.dims). def _partial_transpose_sparse(rho, mask):; """"""; Implement the partial transpose using the CSR sparse matrix.; """""". data = sp.lil_matrix((rho.shape[0], rho.shape[1]), dtype=complex). for m in range(len(rho.data.indptr) - 1):. n1 = rho.data.indptr[m]; n2 = rho.data.indptr[m + 1]. psi_A = state_index_number(rho.dims[0], m). for idx, n in enumerate(rho.data.indices[n1:n2]):. psi_B = state_index_number(rho.dims[1], n). m_pt = state_number_index(; rho.dims[1], np.choose(mask, [psi_A, ",MatchSource.WIKI,docs/4.2/modules/qutip/partial_transpose.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/partial_transpose.html
https://qutip.org/docs/4.2/modules/qutip/partial_transpose.html:3461,Availability,mask,mask,3461,"e `rho`,; where `mask` is an array/list with length that equals; the number of components of `rho` (that is, the length of; `rho.dims[0]`), and the values in `mask` indicates whether; or not the corresponding subsystem is to be transposed.; The elements in `mask` can be boolean or integers `0` or `1`,; where `True`/`1` indicates that the corresponding subsystem; should be tranposed. Parameters; ----------. rho : :class:`qutip.qobj`; A density matrix. mask : *list* / *array*; A mask that selects which subsystems should be transposed. method : str; choice of method, `dense` or `sparse`. The default method; is `dense`. The `sparse` implementation can be faster for; large and sparse systems (hundreds of quantum states). Returns; -------. rho_pr: :class:`qutip.qobj`. A density matrix with the selected subsystems transposed. """"""; if method == 'sparse':; return _partial_transpose_sparse(rho, mask); else:; return _partial_transpose_dense(rho, mask). def _partial_transpose_dense(rho, mask):; """"""; Based on Jonas' implementation using numpy.; Very fast for dense problems.; """"""; nsys = len(mask); pt_dims = np.arange(2 * nsys).reshape(2, nsys).T; pt_idx = np.concatenate([[pt_dims[n, mask[n]] for n in range(nsys)],; [pt_dims[n, 1 - mask[n]] for n in range(nsys)]]). data = rho.data.toarray().reshape(; np.array(rho.dims).flatten()).transpose(pt_idx).reshape(rho.shape). return Qobj(data, dims=rho.dims). def _partial_transpose_sparse(rho, mask):; """"""; Implement the partial transpose using the CSR sparse matrix.; """""". data = sp.lil_matrix((rho.shape[0], rho.shape[1]), dtype=complex). for m in range(len(rho.data.indptr) - 1):. n1 = rho.data.indptr[m]; n2 = rho.data.indptr[m + 1]. psi_A = state_index_number(rho.dims[0], m). for idx, n in enumerate(rho.data.indices[n1:n2]):. psi_B = state_index_number(rho.dims[1], n). m_pt = state_number_index(; rho.dims[1], np.choose(mask, [psi_A, psi_B])); n_pt = state_number_index(; rho.dims[0], np.choose(mask, [psi_B, psi_A])). data[m_pt, n_pt] = rho.",MatchSource.WIKI,docs/4.2/modules/qutip/partial_transpose.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/partial_transpose.html
https://qutip.org/docs/4.2/modules/qutip/partial_transpose.html:3566,Availability,mask,mask,3566,"o` (that is, the length of; `rho.dims[0]`), and the values in `mask` indicates whether; or not the corresponding subsystem is to be transposed.; The elements in `mask` can be boolean or integers `0` or `1`,; where `True`/`1` indicates that the corresponding subsystem; should be tranposed. Parameters; ----------. rho : :class:`qutip.qobj`; A density matrix. mask : *list* / *array*; A mask that selects which subsystems should be transposed. method : str; choice of method, `dense` or `sparse`. The default method; is `dense`. The `sparse` implementation can be faster for; large and sparse systems (hundreds of quantum states). Returns; -------. rho_pr: :class:`qutip.qobj`. A density matrix with the selected subsystems transposed. """"""; if method == 'sparse':; return _partial_transpose_sparse(rho, mask); else:; return _partial_transpose_dense(rho, mask). def _partial_transpose_dense(rho, mask):; """"""; Based on Jonas' implementation using numpy.; Very fast for dense problems.; """"""; nsys = len(mask); pt_dims = np.arange(2 * nsys).reshape(2, nsys).T; pt_idx = np.concatenate([[pt_dims[n, mask[n]] for n in range(nsys)],; [pt_dims[n, 1 - mask[n]] for n in range(nsys)]]). data = rho.data.toarray().reshape(; np.array(rho.dims).flatten()).transpose(pt_idx).reshape(rho.shape). return Qobj(data, dims=rho.dims). def _partial_transpose_sparse(rho, mask):; """"""; Implement the partial transpose using the CSR sparse matrix.; """""". data = sp.lil_matrix((rho.shape[0], rho.shape[1]), dtype=complex). for m in range(len(rho.data.indptr) - 1):. n1 = rho.data.indptr[m]; n2 = rho.data.indptr[m + 1]. psi_A = state_index_number(rho.dims[0], m). for idx, n in enumerate(rho.data.indices[n1:n2]):. psi_B = state_index_number(rho.dims[1], n). m_pt = state_number_index(; rho.dims[1], np.choose(mask, [psi_A, psi_B])); n_pt = state_number_index(; rho.dims[0], np.choose(mask, [psi_B, psi_A])). data[m_pt, n_pt] = rho.data.data[n1 + idx]. return Qobj(data.tocsr(), dims=rho.dims). def _partial_transpose_reference",MatchSource.WIKI,docs/4.2/modules/qutip/partial_transpose.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/partial_transpose.html
https://qutip.org/docs/4.2/modules/qutip/partial_transpose.html:3660,Availability,mask,mask,3660,"m is to be transposed.; The elements in `mask` can be boolean or integers `0` or `1`,; where `True`/`1` indicates that the corresponding subsystem; should be tranposed. Parameters; ----------. rho : :class:`qutip.qobj`; A density matrix. mask : *list* / *array*; A mask that selects which subsystems should be transposed. method : str; choice of method, `dense` or `sparse`. The default method; is `dense`. The `sparse` implementation can be faster for; large and sparse systems (hundreds of quantum states). Returns; -------. rho_pr: :class:`qutip.qobj`. A density matrix with the selected subsystems transposed. """"""; if method == 'sparse':; return _partial_transpose_sparse(rho, mask); else:; return _partial_transpose_dense(rho, mask). def _partial_transpose_dense(rho, mask):; """"""; Based on Jonas' implementation using numpy.; Very fast for dense problems.; """"""; nsys = len(mask); pt_dims = np.arange(2 * nsys).reshape(2, nsys).T; pt_idx = np.concatenate([[pt_dims[n, mask[n]] for n in range(nsys)],; [pt_dims[n, 1 - mask[n]] for n in range(nsys)]]). data = rho.data.toarray().reshape(; np.array(rho.dims).flatten()).transpose(pt_idx).reshape(rho.shape). return Qobj(data, dims=rho.dims). def _partial_transpose_sparse(rho, mask):; """"""; Implement the partial transpose using the CSR sparse matrix.; """""". data = sp.lil_matrix((rho.shape[0], rho.shape[1]), dtype=complex). for m in range(len(rho.data.indptr) - 1):. n1 = rho.data.indptr[m]; n2 = rho.data.indptr[m + 1]. psi_A = state_index_number(rho.dims[0], m). for idx, n in enumerate(rho.data.indices[n1:n2]):. psi_B = state_index_number(rho.dims[1], n). m_pt = state_number_index(; rho.dims[1], np.choose(mask, [psi_A, psi_B])); n_pt = state_number_index(; rho.dims[0], np.choose(mask, [psi_B, psi_A])). data[m_pt, n_pt] = rho.data.data[n1 + idx]. return Qobj(data.tocsr(), dims=rho.dims). def _partial_transpose_reference(rho, mask):; """"""; This is a reference implementation that explicitly loops over; all states and performs the transpose. I",MatchSource.WIKI,docs/4.2/modules/qutip/partial_transpose.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/partial_transpose.html
https://qutip.org/docs/4.2/modules/qutip/partial_transpose.html:3709,Availability,mask,mask,3709,"m is to be transposed.; The elements in `mask` can be boolean or integers `0` or `1`,; where `True`/`1` indicates that the corresponding subsystem; should be tranposed. Parameters; ----------. rho : :class:`qutip.qobj`; A density matrix. mask : *list* / *array*; A mask that selects which subsystems should be transposed. method : str; choice of method, `dense` or `sparse`. The default method; is `dense`. The `sparse` implementation can be faster for; large and sparse systems (hundreds of quantum states). Returns; -------. rho_pr: :class:`qutip.qobj`. A density matrix with the selected subsystems transposed. """"""; if method == 'sparse':; return _partial_transpose_sparse(rho, mask); else:; return _partial_transpose_dense(rho, mask). def _partial_transpose_dense(rho, mask):; """"""; Based on Jonas' implementation using numpy.; Very fast for dense problems.; """"""; nsys = len(mask); pt_dims = np.arange(2 * nsys).reshape(2, nsys).T; pt_idx = np.concatenate([[pt_dims[n, mask[n]] for n in range(nsys)],; [pt_dims[n, 1 - mask[n]] for n in range(nsys)]]). data = rho.data.toarray().reshape(; np.array(rho.dims).flatten()).transpose(pt_idx).reshape(rho.shape). return Qobj(data, dims=rho.dims). def _partial_transpose_sparse(rho, mask):; """"""; Implement the partial transpose using the CSR sparse matrix.; """""". data = sp.lil_matrix((rho.shape[0], rho.shape[1]), dtype=complex). for m in range(len(rho.data.indptr) - 1):. n1 = rho.data.indptr[m]; n2 = rho.data.indptr[m + 1]. psi_A = state_index_number(rho.dims[0], m). for idx, n in enumerate(rho.data.indices[n1:n2]):. psi_B = state_index_number(rho.dims[1], n). m_pt = state_number_index(; rho.dims[1], np.choose(mask, [psi_A, psi_B])); n_pt = state_number_index(; rho.dims[0], np.choose(mask, [psi_B, psi_A])). data[m_pt, n_pt] = rho.data.data[n1 + idx]. return Qobj(data.tocsr(), dims=rho.dims). def _partial_transpose_reference(rho, mask):; """"""; This is a reference implementation that explicitly loops over; all states and performs the transpose. I",MatchSource.WIKI,docs/4.2/modules/qutip/partial_transpose.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/partial_transpose.html
https://qutip.org/docs/4.2/modules/qutip/partial_transpose.html:3916,Availability,mask,mask,3916,"list* / *array*; A mask that selects which subsystems should be transposed. method : str; choice of method, `dense` or `sparse`. The default method; is `dense`. The `sparse` implementation can be faster for; large and sparse systems (hundreds of quantum states). Returns; -------. rho_pr: :class:`qutip.qobj`. A density matrix with the selected subsystems transposed. """"""; if method == 'sparse':; return _partial_transpose_sparse(rho, mask); else:; return _partial_transpose_dense(rho, mask). def _partial_transpose_dense(rho, mask):; """"""; Based on Jonas' implementation using numpy.; Very fast for dense problems.; """"""; nsys = len(mask); pt_dims = np.arange(2 * nsys).reshape(2, nsys).T; pt_idx = np.concatenate([[pt_dims[n, mask[n]] for n in range(nsys)],; [pt_dims[n, 1 - mask[n]] for n in range(nsys)]]). data = rho.data.toarray().reshape(; np.array(rho.dims).flatten()).transpose(pt_idx).reshape(rho.shape). return Qobj(data, dims=rho.dims). def _partial_transpose_sparse(rho, mask):; """"""; Implement the partial transpose using the CSR sparse matrix.; """""". data = sp.lil_matrix((rho.shape[0], rho.shape[1]), dtype=complex). for m in range(len(rho.data.indptr) - 1):. n1 = rho.data.indptr[m]; n2 = rho.data.indptr[m + 1]. psi_A = state_index_number(rho.dims[0], m). for idx, n in enumerate(rho.data.indices[n1:n2]):. psi_B = state_index_number(rho.dims[1], n). m_pt = state_number_index(; rho.dims[1], np.choose(mask, [psi_A, psi_B])); n_pt = state_number_index(; rho.dims[0], np.choose(mask, [psi_B, psi_A])). data[m_pt, n_pt] = rho.data.data[n1 + idx]. return Qobj(data.tocsr(), dims=rho.dims). def _partial_transpose_reference(rho, mask):; """"""; This is a reference implementation that explicitly loops over; all states and performs the transpose. It's slow but easy to; understand and useful for testing.; """""". A_pt = np.zeros(rho.shape, dtype=complex). for psi_A in state_number_enumerate(rho.dims[0]):; m = state_number_index(rho.dims[0], psi_A). for psi_B in state_number_enumerate(rho.dims[",MatchSource.WIKI,docs/4.2/modules/qutip/partial_transpose.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/partial_transpose.html
https://qutip.org/docs/4.2/modules/qutip/partial_transpose.html:4350,Availability,mask,mask,4350,"; else:; return _partial_transpose_dense(rho, mask). def _partial_transpose_dense(rho, mask):; """"""; Based on Jonas' implementation using numpy.; Very fast for dense problems.; """"""; nsys = len(mask); pt_dims = np.arange(2 * nsys).reshape(2, nsys).T; pt_idx = np.concatenate([[pt_dims[n, mask[n]] for n in range(nsys)],; [pt_dims[n, 1 - mask[n]] for n in range(nsys)]]). data = rho.data.toarray().reshape(; np.array(rho.dims).flatten()).transpose(pt_idx).reshape(rho.shape). return Qobj(data, dims=rho.dims). def _partial_transpose_sparse(rho, mask):; """"""; Implement the partial transpose using the CSR sparse matrix.; """""". data = sp.lil_matrix((rho.shape[0], rho.shape[1]), dtype=complex). for m in range(len(rho.data.indptr) - 1):. n1 = rho.data.indptr[m]; n2 = rho.data.indptr[m + 1]. psi_A = state_index_number(rho.dims[0], m). for idx, n in enumerate(rho.data.indices[n1:n2]):. psi_B = state_index_number(rho.dims[1], n). m_pt = state_number_index(; rho.dims[1], np.choose(mask, [psi_A, psi_B])); n_pt = state_number_index(; rho.dims[0], np.choose(mask, [psi_B, psi_A])). data[m_pt, n_pt] = rho.data.data[n1 + idx]. return Qobj(data.tocsr(), dims=rho.dims). def _partial_transpose_reference(rho, mask):; """"""; This is a reference implementation that explicitly loops over; all states and performs the transpose. It's slow but easy to; understand and useful for testing.; """""". A_pt = np.zeros(rho.shape, dtype=complex). for psi_A in state_number_enumerate(rho.dims[0]):; m = state_number_index(rho.dims[0], psi_A). for psi_B in state_number_enumerate(rho.dims[1]):; n = state_number_index(rho.dims[1], psi_B). m_pt = state_number_index(; rho.dims[1], np.choose(mask, [psi_A, psi_B])); n_pt = state_number_index(; rho.dims[0], np.choose(mask, [psi_B, psi_A])). A_pt[m_pt, n_pt] = rho.data[m, n]. return Qobj(A_pt, dims=rho.dims).  Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, and A.L. Grimsmo.; Last updated on Jan 17, 2018. . Built with Sphinx using a theme p",MatchSource.WIKI,docs/4.2/modules/qutip/partial_transpose.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/partial_transpose.html
https://qutip.org/docs/4.2/modules/qutip/partial_transpose.html:4425,Availability,mask,mask,4425,"spose_dense(rho, mask). def _partial_transpose_dense(rho, mask):; """"""; Based on Jonas' implementation using numpy.; Very fast for dense problems.; """"""; nsys = len(mask); pt_dims = np.arange(2 * nsys).reshape(2, nsys).T; pt_idx = np.concatenate([[pt_dims[n, mask[n]] for n in range(nsys)],; [pt_dims[n, 1 - mask[n]] for n in range(nsys)]]). data = rho.data.toarray().reshape(; np.array(rho.dims).flatten()).transpose(pt_idx).reshape(rho.shape). return Qobj(data, dims=rho.dims). def _partial_transpose_sparse(rho, mask):; """"""; Implement the partial transpose using the CSR sparse matrix.; """""". data = sp.lil_matrix((rho.shape[0], rho.shape[1]), dtype=complex). for m in range(len(rho.data.indptr) - 1):. n1 = rho.data.indptr[m]; n2 = rho.data.indptr[m + 1]. psi_A = state_index_number(rho.dims[0], m). for idx, n in enumerate(rho.data.indices[n1:n2]):. psi_B = state_index_number(rho.dims[1], n). m_pt = state_number_index(; rho.dims[1], np.choose(mask, [psi_A, psi_B])); n_pt = state_number_index(; rho.dims[0], np.choose(mask, [psi_B, psi_A])). data[m_pt, n_pt] = rho.data.data[n1 + idx]. return Qobj(data.tocsr(), dims=rho.dims). def _partial_transpose_reference(rho, mask):; """"""; This is a reference implementation that explicitly loops over; all states and performs the transpose. It's slow but easy to; understand and useful for testing.; """""". A_pt = np.zeros(rho.shape, dtype=complex). for psi_A in state_number_enumerate(rho.dims[0]):; m = state_number_index(rho.dims[0], psi_A). for psi_B in state_number_enumerate(rho.dims[1]):; n = state_number_index(rho.dims[1], psi_B). m_pt = state_number_index(; rho.dims[1], np.choose(mask, [psi_A, psi_B])); n_pt = state_number_index(; rho.dims[0], np.choose(mask, [psi_B, psi_A])). A_pt[m_pt, n_pt] = rho.data[m, n]. return Qobj(A_pt, dims=rho.dims).  Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, and A.L. Grimsmo.; Last updated on Jan 17, 2018. . Built with Sphinx using a theme provided by Read the Docs. . ",MatchSource.WIKI,docs/4.2/modules/qutip/partial_transpose.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/partial_transpose.html
https://qutip.org/docs/4.2/modules/qutip/partial_transpose.html:4573,Availability,mask,mask,4573,"spose_dense(rho, mask). def _partial_transpose_dense(rho, mask):; """"""; Based on Jonas' implementation using numpy.; Very fast for dense problems.; """"""; nsys = len(mask); pt_dims = np.arange(2 * nsys).reshape(2, nsys).T; pt_idx = np.concatenate([[pt_dims[n, mask[n]] for n in range(nsys)],; [pt_dims[n, 1 - mask[n]] for n in range(nsys)]]). data = rho.data.toarray().reshape(; np.array(rho.dims).flatten()).transpose(pt_idx).reshape(rho.shape). return Qobj(data, dims=rho.dims). def _partial_transpose_sparse(rho, mask):; """"""; Implement the partial transpose using the CSR sparse matrix.; """""". data = sp.lil_matrix((rho.shape[0], rho.shape[1]), dtype=complex). for m in range(len(rho.data.indptr) - 1):. n1 = rho.data.indptr[m]; n2 = rho.data.indptr[m + 1]. psi_A = state_index_number(rho.dims[0], m). for idx, n in enumerate(rho.data.indices[n1:n2]):. psi_B = state_index_number(rho.dims[1], n). m_pt = state_number_index(; rho.dims[1], np.choose(mask, [psi_A, psi_B])); n_pt = state_number_index(; rho.dims[0], np.choose(mask, [psi_B, psi_A])). data[m_pt, n_pt] = rho.data.data[n1 + idx]. return Qobj(data.tocsr(), dims=rho.dims). def _partial_transpose_reference(rho, mask):; """"""; This is a reference implementation that explicitly loops over; all states and performs the transpose. It's slow but easy to; understand and useful for testing.; """""". A_pt = np.zeros(rho.shape, dtype=complex). for psi_A in state_number_enumerate(rho.dims[0]):; m = state_number_index(rho.dims[0], psi_A). for psi_B in state_number_enumerate(rho.dims[1]):; n = state_number_index(rho.dims[1], psi_B). m_pt = state_number_index(; rho.dims[1], np.choose(mask, [psi_A, psi_B])); n_pt = state_number_index(; rho.dims[0], np.choose(mask, [psi_B, psi_A])). A_pt[m_pt, n_pt] = rho.data[m, n]. return Qobj(A_pt, dims=rho.dims).  Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, and A.L. Grimsmo.; Last updated on Jan 17, 2018. . Built with Sphinx using a theme provided by Read the Docs. . ",MatchSource.WIKI,docs/4.2/modules/qutip/partial_transpose.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/partial_transpose.html
https://qutip.org/docs/4.2/modules/qutip/partial_transpose.html:5036,Availability,mask,mask,5036,"spose_dense(rho, mask). def _partial_transpose_dense(rho, mask):; """"""; Based on Jonas' implementation using numpy.; Very fast for dense problems.; """"""; nsys = len(mask); pt_dims = np.arange(2 * nsys).reshape(2, nsys).T; pt_idx = np.concatenate([[pt_dims[n, mask[n]] for n in range(nsys)],; [pt_dims[n, 1 - mask[n]] for n in range(nsys)]]). data = rho.data.toarray().reshape(; np.array(rho.dims).flatten()).transpose(pt_idx).reshape(rho.shape). return Qobj(data, dims=rho.dims). def _partial_transpose_sparse(rho, mask):; """"""; Implement the partial transpose using the CSR sparse matrix.; """""". data = sp.lil_matrix((rho.shape[0], rho.shape[1]), dtype=complex). for m in range(len(rho.data.indptr) - 1):. n1 = rho.data.indptr[m]; n2 = rho.data.indptr[m + 1]. psi_A = state_index_number(rho.dims[0], m). for idx, n in enumerate(rho.data.indices[n1:n2]):. psi_B = state_index_number(rho.dims[1], n). m_pt = state_number_index(; rho.dims[1], np.choose(mask, [psi_A, psi_B])); n_pt = state_number_index(; rho.dims[0], np.choose(mask, [psi_B, psi_A])). data[m_pt, n_pt] = rho.data.data[n1 + idx]. return Qobj(data.tocsr(), dims=rho.dims). def _partial_transpose_reference(rho, mask):; """"""; This is a reference implementation that explicitly loops over; all states and performs the transpose. It's slow but easy to; understand and useful for testing.; """""". A_pt = np.zeros(rho.shape, dtype=complex). for psi_A in state_number_enumerate(rho.dims[0]):; m = state_number_index(rho.dims[0], psi_A). for psi_B in state_number_enumerate(rho.dims[1]):; n = state_number_index(rho.dims[1], psi_B). m_pt = state_number_index(; rho.dims[1], np.choose(mask, [psi_A, psi_B])); n_pt = state_number_index(; rho.dims[0], np.choose(mask, [psi_B, psi_A])). A_pt[m_pt, n_pt] = rho.data[m, n]. return Qobj(A_pt, dims=rho.dims).  Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, and A.L. Grimsmo.; Last updated on Jan 17, 2018. . Built with Sphinx using a theme provided by Read the Docs. . ",MatchSource.WIKI,docs/4.2/modules/qutip/partial_transpose.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/partial_transpose.html
https://qutip.org/docs/4.2/modules/qutip/partial_transpose.html:5111,Availability,mask,mask,5111,"spose_dense(rho, mask). def _partial_transpose_dense(rho, mask):; """"""; Based on Jonas' implementation using numpy.; Very fast for dense problems.; """"""; nsys = len(mask); pt_dims = np.arange(2 * nsys).reshape(2, nsys).T; pt_idx = np.concatenate([[pt_dims[n, mask[n]] for n in range(nsys)],; [pt_dims[n, 1 - mask[n]] for n in range(nsys)]]). data = rho.data.toarray().reshape(; np.array(rho.dims).flatten()).transpose(pt_idx).reshape(rho.shape). return Qobj(data, dims=rho.dims). def _partial_transpose_sparse(rho, mask):; """"""; Implement the partial transpose using the CSR sparse matrix.; """""". data = sp.lil_matrix((rho.shape[0], rho.shape[1]), dtype=complex). for m in range(len(rho.data.indptr) - 1):. n1 = rho.data.indptr[m]; n2 = rho.data.indptr[m + 1]. psi_A = state_index_number(rho.dims[0], m). for idx, n in enumerate(rho.data.indices[n1:n2]):. psi_B = state_index_number(rho.dims[1], n). m_pt = state_number_index(; rho.dims[1], np.choose(mask, [psi_A, psi_B])); n_pt = state_number_index(; rho.dims[0], np.choose(mask, [psi_B, psi_A])). data[m_pt, n_pt] = rho.data.data[n1 + idx]. return Qobj(data.tocsr(), dims=rho.dims). def _partial_transpose_reference(rho, mask):; """"""; This is a reference implementation that explicitly loops over; all states and performs the transpose. It's slow but easy to; understand and useful for testing.; """""". A_pt = np.zeros(rho.shape, dtype=complex). for psi_A in state_number_enumerate(rho.dims[0]):; m = state_number_index(rho.dims[0], psi_A). for psi_B in state_number_enumerate(rho.dims[1]):; n = state_number_index(rho.dims[1], psi_B). m_pt = state_number_index(; rho.dims[1], np.choose(mask, [psi_A, psi_B])); n_pt = state_number_index(; rho.dims[0], np.choose(mask, [psi_B, psi_A])). A_pt[m_pt, n_pt] = rho.data[m, n]. return Qobj(A_pt, dims=rho.dims).  Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, and A.L. Grimsmo.; Last updated on Jan 17, 2018. . Built with Sphinx using a theme provided by Read the Docs. . ",MatchSource.WIKI,docs/4.2/modules/qutip/partial_transpose.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/partial_transpose.html
https://qutip.org/docs/4.2/modules/qutip/partial_transpose.html:5315,Deployability,update,updated,5315,"spose_dense(rho, mask). def _partial_transpose_dense(rho, mask):; """"""; Based on Jonas' implementation using numpy.; Very fast for dense problems.; """"""; nsys = len(mask); pt_dims = np.arange(2 * nsys).reshape(2, nsys).T; pt_idx = np.concatenate([[pt_dims[n, mask[n]] for n in range(nsys)],; [pt_dims[n, 1 - mask[n]] for n in range(nsys)]]). data = rho.data.toarray().reshape(; np.array(rho.dims).flatten()).transpose(pt_idx).reshape(rho.shape). return Qobj(data, dims=rho.dims). def _partial_transpose_sparse(rho, mask):; """"""; Implement the partial transpose using the CSR sparse matrix.; """""". data = sp.lil_matrix((rho.shape[0], rho.shape[1]), dtype=complex). for m in range(len(rho.data.indptr) - 1):. n1 = rho.data.indptr[m]; n2 = rho.data.indptr[m + 1]. psi_A = state_index_number(rho.dims[0], m). for idx, n in enumerate(rho.data.indices[n1:n2]):. psi_B = state_index_number(rho.dims[1], n). m_pt = state_number_index(; rho.dims[1], np.choose(mask, [psi_A, psi_B])); n_pt = state_number_index(; rho.dims[0], np.choose(mask, [psi_B, psi_A])). data[m_pt, n_pt] = rho.data.data[n1 + idx]. return Qobj(data.tocsr(), dims=rho.dims). def _partial_transpose_reference(rho, mask):; """"""; This is a reference implementation that explicitly loops over; all states and performs the transpose. It's slow but easy to; understand and useful for testing.; """""". A_pt = np.zeros(rho.shape, dtype=complex). for psi_A in state_number_enumerate(rho.dims[0]):; m = state_number_index(rho.dims[0], psi_A). for psi_B in state_number_enumerate(rho.dims[1]):; n = state_number_index(rho.dims[1], psi_B). m_pt = state_number_index(; rho.dims[1], np.choose(mask, [psi_A, psi_B])); n_pt = state_number_index(; rho.dims[0], np.choose(mask, [psi_B, psi_A])). A_pt[m_pt, n_pt] = rho.data[m, n]. return Qobj(A_pt, dims=rho.dims).  Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, and A.L. Grimsmo.; Last updated on Jan 17, 2018. . Built with Sphinx using a theme provided by Read the Docs. . ",MatchSource.WIKI,docs/4.2/modules/qutip/partial_transpose.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/partial_transpose.html
https://qutip.org/docs/4.2/modules/qutip/partial_transpose.html:4664,Performance,perform,performs,4664,"spose_dense(rho, mask). def _partial_transpose_dense(rho, mask):; """"""; Based on Jonas' implementation using numpy.; Very fast for dense problems.; """"""; nsys = len(mask); pt_dims = np.arange(2 * nsys).reshape(2, nsys).T; pt_idx = np.concatenate([[pt_dims[n, mask[n]] for n in range(nsys)],; [pt_dims[n, 1 - mask[n]] for n in range(nsys)]]). data = rho.data.toarray().reshape(; np.array(rho.dims).flatten()).transpose(pt_idx).reshape(rho.shape). return Qobj(data, dims=rho.dims). def _partial_transpose_sparse(rho, mask):; """"""; Implement the partial transpose using the CSR sparse matrix.; """""". data = sp.lil_matrix((rho.shape[0], rho.shape[1]), dtype=complex). for m in range(len(rho.data.indptr) - 1):. n1 = rho.data.indptr[m]; n2 = rho.data.indptr[m + 1]. psi_A = state_index_number(rho.dims[0], m). for idx, n in enumerate(rho.data.indices[n1:n2]):. psi_B = state_index_number(rho.dims[1], n). m_pt = state_number_index(; rho.dims[1], np.choose(mask, [psi_A, psi_B])); n_pt = state_number_index(; rho.dims[0], np.choose(mask, [psi_B, psi_A])). data[m_pt, n_pt] = rho.data.data[n1 + idx]. return Qobj(data.tocsr(), dims=rho.dims). def _partial_transpose_reference(rho, mask):; """"""; This is a reference implementation that explicitly loops over; all states and performs the transpose. It's slow but easy to; understand and useful for testing.; """""". A_pt = np.zeros(rho.shape, dtype=complex). for psi_A in state_number_enumerate(rho.dims[0]):; m = state_number_index(rho.dims[0], psi_A). for psi_B in state_number_enumerate(rho.dims[1]):; n = state_number_index(rho.dims[1], psi_B). m_pt = state_number_index(; rho.dims[1], np.choose(mask, [psi_A, psi_B])); n_pt = state_number_index(; rho.dims[0], np.choose(mask, [psi_B, psi_A])). A_pt[m_pt, n_pt] = rho.data[m, n]. return Qobj(A_pt, dims=rho.dims).  Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, and A.L. Grimsmo.; Last updated on Jan 17, 2018. . Built with Sphinx using a theme provided by Read the Docs. . ",MatchSource.WIKI,docs/4.2/modules/qutip/partial_transpose.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/partial_transpose.html
https://qutip.org/docs/4.2/modules/qutip/partial_transpose.html:4737,Testability,test,testing,4737,"spose_dense(rho, mask). def _partial_transpose_dense(rho, mask):; """"""; Based on Jonas' implementation using numpy.; Very fast for dense problems.; """"""; nsys = len(mask); pt_dims = np.arange(2 * nsys).reshape(2, nsys).T; pt_idx = np.concatenate([[pt_dims[n, mask[n]] for n in range(nsys)],; [pt_dims[n, 1 - mask[n]] for n in range(nsys)]]). data = rho.data.toarray().reshape(; np.array(rho.dims).flatten()).transpose(pt_idx).reshape(rho.shape). return Qobj(data, dims=rho.dims). def _partial_transpose_sparse(rho, mask):; """"""; Implement the partial transpose using the CSR sparse matrix.; """""". data = sp.lil_matrix((rho.shape[0], rho.shape[1]), dtype=complex). for m in range(len(rho.data.indptr) - 1):. n1 = rho.data.indptr[m]; n2 = rho.data.indptr[m + 1]. psi_A = state_index_number(rho.dims[0], m). for idx, n in enumerate(rho.data.indices[n1:n2]):. psi_B = state_index_number(rho.dims[1], n). m_pt = state_number_index(; rho.dims[1], np.choose(mask, [psi_A, psi_B])); n_pt = state_number_index(; rho.dims[0], np.choose(mask, [psi_B, psi_A])). data[m_pt, n_pt] = rho.data.data[n1 + idx]. return Qobj(data.tocsr(), dims=rho.dims). def _partial_transpose_reference(rho, mask):; """"""; This is a reference implementation that explicitly loops over; all states and performs the transpose. It's slow but easy to; understand and useful for testing.; """""". A_pt = np.zeros(rho.shape, dtype=complex). for psi_A in state_number_enumerate(rho.dims[0]):; m = state_number_index(rho.dims[0], psi_A). for psi_B in state_number_enumerate(rho.dims[1]):; n = state_number_index(rho.dims[1], psi_B). m_pt = state_number_index(; rho.dims[1], np.choose(mask, [psi_A, psi_B])); n_pt = state_number_index(; rho.dims[0], np.choose(mask, [psi_B, psi_A])). A_pt[m_pt, n_pt] = rho.data[m, n]. return Qobj(A_pt, dims=rho.dims).  Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, and A.L. Grimsmo.; Last updated on Jan 17, 2018. . Built with Sphinx using a theme provided by Read the Docs. . ",MatchSource.WIKI,docs/4.2/modules/qutip/partial_transpose.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/partial_transpose.html
https://qutip.org/docs/4.2/modules/qutip/propagator.html:5648,Deployability,update,update,5648,", (int, float, np.integer, np.floating)):; tlist = [0, t]; else:; tlist = t. td_type = _td_format_check(H, c_op_list, solver='me'); ; if isinstance(H, (types.FunctionType, types.BuiltinFunctionType,; functools.partial)):; H0 = H(0.0, args); elif isinstance(H, list):; H0 = H[0][0] if isinstance(H[0], list) else H[0]; else:; H0 = H; ; if len(c_op_list) == 0 and H0.isoper:; # calculate propagator for the wave function. N = H0.shape[0]; dims = H0.dims; ; if parallel:; unitary_mode = 'single'; u = np.zeros([N, N, len(tlist)], dtype=complex); output = parallel_map(_parallel_sesolve, range(N),; task_args=(N, H, tlist, args, options),; progress_bar=progress_bar, num_cpus=num_cpus); for n in range(N):; for k, t in enumerate(tlist):; u[:, n, k] = output[n].states[k].full().T ; else:; if unitary_mode == 'single':; u = np.zeros([N, N, len(tlist)], dtype=complex); progress_bar.start(N); for n in range(0, N):; progress_bar.update(n); psi0 = basis(N, n); output = sesolve(H, psi0, tlist, [], args, options,; _safe_mode=False); for k, t in enumerate(tlist):; u[:, n, k] = output.states[k].full().T; progress_bar.finished(). elif unitary_mode =='batch':; u = np.zeros(len(tlist), dtype=object); _rows = np.array([(N+1)*m for m in range(N)]); _cols = np.zeros_like(_rows); _data = np.ones_like(_rows, dtype=complex); psi0 = Qobj(sp.coo_matrix((_data, (_rows, _cols))).tocsr()); if td_type[1] > 0 or td_type[2] > 0:; H2 = []; for k in range(len(H)):; if isinstance(H[k], list):; H2.append([tensor(qeye(N), H[k][0]), H[k][1]]); else:; H2.append(tensor(qeye(N), H[k])); else:; H2 = tensor(qeye(N), H); output = sesolve(H2, psi0, tlist, [],; args=args, _safe_mode=False,; options=Options(normalize_output=False)); for k, t in enumerate(tlist):; u[k] = sp_reshape(output.states[k].data, (N, N)); unit_row_norm(u[k].data, u[k].indptr, u[k].shape[0]); u[k] = u[k].T.tocsr(). else:; raise Exception('Invalid unitary mode.'); . elif len(c_op_list) == 0 and H0.issuper:; # calculate the propagator for the vector r",MatchSource.WIKI,docs/4.2/modules/qutip/propagator.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/propagator.html
https://qutip.org/docs/4.2/modules/qutip/propagator.html:7278,Deployability,update,update,7278," H2 = tensor(qeye(N), H); output = sesolve(H2, psi0, tlist, [],; args=args, _safe_mode=False,; options=Options(normalize_output=False)); for k, t in enumerate(tlist):; u[k] = sp_reshape(output.states[k].data, (N, N)); unit_row_norm(u[k].data, u[k].indptr, u[k].shape[0]); u[k] = u[k].T.tocsr(). else:; raise Exception('Invalid unitary mode.'); . elif len(c_op_list) == 0 and H0.issuper:; # calculate the propagator for the vector representation of the; # density matrix (a superoperator propagator); unitary_mode = 'single'; N = H0.shape[0]; sqrt_N = int(np.sqrt(N)); dims = H0.dims; ; u = np.zeros([N, N, len(tlist)], dtype=complex). if parallel:; output = parallel_map(_parallel_mesolve,range(N * N),; task_args=(; sqrt_N, H, tlist, c_op_list, args,; options),; progress_bar=progress_bar, num_cpus=num_cpus); for n in range(N * N):; for k, t in enumerate(tlist):; u[:, n, k] = mat2vec(output[n].states[k].full()).T; else:; progress_bar.start(N); for n in range(0, N):; progress_bar.update(n); col_idx, row_idx = np.unravel_index(n, (sqrt_N, sqrt_N)); rho0 = Qobj(sp.csr_matrix(([1], ([row_idx], [col_idx])),; shape=(sqrt_N,sqrt_N), dtype=complex); ); output = mesolve(H, rho0, tlist, [], [], args, options,; _safe_mode=False); for k, t in enumerate(tlist):; u[:, n, k] = mat2vec(output.states[k].full()).T; progress_bar.finished(). else:; # calculate the propagator for the vector representation of the; # density matrix (a superoperator propagator); unitary_mode = 'single'; N = H0.shape[0]; dims = [H0.dims, H0.dims]. u = np.zeros([N * N, N * N, len(tlist)], dtype=complex); ; if parallel:; output = parallel_map(_parallel_mesolve, range(N * N),; task_args=(; N, H, tlist, c_op_list, args, options),; progress_bar=progress_bar, num_cpus=num_cpus); for n in range(N * N):; for k, t in enumerate(tlist):; u[:, n, k] = mat2vec(output[n].states[k].full()).T; else:; progress_bar.start(N * N); for n in range(N * N):; progress_bar.update(n); col_idx, row_idx = np.unravel_index(n, (N, N)); rho0 = Qobj(",MatchSource.WIKI,docs/4.2/modules/qutip/propagator.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/propagator.html
https://qutip.org/docs/4.2/modules/qutip/propagator.html:8224,Deployability,update,update,8224,"; for n in range(0, N):; progress_bar.update(n); col_idx, row_idx = np.unravel_index(n, (sqrt_N, sqrt_N)); rho0 = Qobj(sp.csr_matrix(([1], ([row_idx], [col_idx])),; shape=(sqrt_N,sqrt_N), dtype=complex); ); output = mesolve(H, rho0, tlist, [], [], args, options,; _safe_mode=False); for k, t in enumerate(tlist):; u[:, n, k] = mat2vec(output.states[k].full()).T; progress_bar.finished(). else:; # calculate the propagator for the vector representation of the; # density matrix (a superoperator propagator); unitary_mode = 'single'; N = H0.shape[0]; dims = [H0.dims, H0.dims]. u = np.zeros([N * N, N * N, len(tlist)], dtype=complex); ; if parallel:; output = parallel_map(_parallel_mesolve, range(N * N),; task_args=(; N, H, tlist, c_op_list, args, options),; progress_bar=progress_bar, num_cpus=num_cpus); for n in range(N * N):; for k, t in enumerate(tlist):; u[:, n, k] = mat2vec(output[n].states[k].full()).T; else:; progress_bar.start(N * N); for n in range(N * N):; progress_bar.update(n); col_idx, row_idx = np.unravel_index(n, (N, N)); rho0 = Qobj(sp.csr_matrix(([1], ([row_idx], [col_idx])),; shape=(N,N), dtype=complex)); output = mesolve(H, rho0, tlist, c_op_list, [], args, options,; _safe_mode=False); for k, t in enumerate(tlist):; u[:, n, k] = mat2vec(output.states[k].full()).T; progress_bar.finished(). if len(tlist) == 2:; if unitary_mode == 'batch':; return Qobj(u[-1], dims=dims); else:; return Qobj(u[:, :, 1], dims=dims); else:; if unitary_mode == 'batch':; return np.array([Qobj(u[k], dims=dims); for k in range(len(tlist))], dtype=object); else:; return np.array([Qobj(u[:, :, k], dims=dims); for k in range(len(tlist))], dtype=object). def _get_min_and_index(lst):; """"""; Private function for obtaining min and max indicies.; """"""; minval, minidx = lst[0], 0; for i, v in enumerate(lst[1:]):; if v < minval:; minval, minidx = v, i + 1; return minval, minidx. [docs]def propagator_steadystate(U):; """"""Find the steady state for successive applications of the propagator; :math:`U`.",MatchSource.WIKI,docs/4.2/modules/qutip/propagator.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/propagator.html
https://qutip.org/docs/4.2/modules/qutip/propagator.html:10295,Deployability,update,updated,10295,"olve(H, rho0, tlist, c_op_list, [], args, options,; _safe_mode=False); for k, t in enumerate(tlist):; u[:, n, k] = mat2vec(output.states[k].full()).T; progress_bar.finished(). if len(tlist) == 2:; if unitary_mode == 'batch':; return Qobj(u[-1], dims=dims); else:; return Qobj(u[:, :, 1], dims=dims); else:; if unitary_mode == 'batch':; return np.array([Qobj(u[k], dims=dims); for k in range(len(tlist))], dtype=object); else:; return np.array([Qobj(u[:, :, k], dims=dims); for k in range(len(tlist))], dtype=object). def _get_min_and_index(lst):; """"""; Private function for obtaining min and max indicies.; """"""; minval, minidx = lst[0], 0; for i, v in enumerate(lst[1:]):; if v < minval:; minval, minidx = v, i + 1; return minval, minidx. [docs]def propagator_steadystate(U):; """"""Find the steady state for successive applications of the propagator; :math:`U`. Parameters; ----------; U : qobj; Operator representing the propagator. Returns; -------; a : qobj; Instance representing the steady-state density matrix. """""". evals, evecs = la.eig(U.full()); ; shifted_vals = np.abs(evals - 1.0); ev_idx = np.argmin(shifted_vals); ev_min = shifted_vals[ev_idx]; evecs = evecs.T; rho = Qobj(vec2mat(evecs[ev_idx]), dims=U.dims[0]); rho = rho * (1.0 / rho.tr()); rho = 0.5 * (rho + rho.dag()) # make sure rho is herm; rho.isherm = True; return rho. def _parallel_sesolve(n, N, H, tlist, args, options):; psi0 = basis(N, n); output = sesolve(H, psi0, tlist, [], args, options, _safe_mode=False); return output. def _parallel_mesolve(n, N, H, tlist, c_op_list, args, options):; col_idx, row_idx = np.unravel_index(n, (N, N)); rho0 = Qobj(sp.csr_matrix(([1], ([row_idx], [col_idx])),; shape=(N,N), dtype=complex)); output = mesolve(H, rho0, tlist, c_op_list, [], args, options,; _safe_mode=False); return output.  Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, and A.L. Grimsmo.; Last updated on Jan 17, 2018. . Built with Sphinx using a theme provided by Read the Docs. . ",MatchSource.WIKI,docs/4.2/modules/qutip/propagator.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/propagator.html
https://qutip.org/docs/4.2/modules/qutip/propagator.html:3436,Integrability,depend,dependent,3436,"rmat_check); from qutip.superoperator import (vec2mat, mat2vec,; vector_to_operator, operator_to_vector); from qutip.sparse import sp_reshape; from qutip.cy.sparse_utils import unit_row_norm; from qutip.mesolve import mesolve; from qutip.sesolve import sesolve; from qutip.states import basis; from qutip.solver import Options, _solver_safety_check, config; from qutip.parallel import parallel_map, _default_kwargs; from qutip.ui.progressbar import BaseProgressBar, TextProgressBar. [docs]def propagator(H, t, c_op_list=[], args={}, options=None,; unitary_mode='batch', parallel=False, ; progress_bar=None, **kwargs):; """"""; Calculate the propagator U(t) for the density matrix or wave function such; that :math:`\psi(t) = U(t)\psi(0)` or; :math:`\\rho_{\mathrm vec}(t) = U(t) \\rho_{\mathrm vec}(0)`; where :math:`\\rho_{\mathrm vec}` is the vector representation of the; density matrix. Parameters; ----------; H : qobj or list; Hamiltonian as a Qobj instance of a nested list of Qobjs and; coefficients in the list-string or list-function format for; time-dependent Hamiltonians (see description in :func:`qutip.mesolve`). t : float or array-like; Time or list of times for which to evaluate the propagator. c_op_list : list; List of qobj collapse operators. args : list/array/dictionary; Parameters to callback functions for time-dependent Hamiltonians and; collapse operators. options : :class:`qutip.Options`; with options for the ODE solver. unitary_mode = str ('batch', 'single'); Solve all basis vectors simulaneously ('batch') or individually ; ('single').; ; parallel : bool {False, True}; Run the propagator in parallel mode. This will override the ; unitary_mode settings if set to True.; ; progress_bar: BaseProgressBar; Optional instance of BaseProgressBar, or a subclass thereof, for; showing the progress of the simulation. By default no progress bar; is used, and if set to True a TextProgressBar will be used. Returns; -------; a : qobj; Instance representing the propagator :math:`U",MatchSource.WIKI,docs/4.2/modules/qutip/propagator.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/propagator.html
https://qutip.org/docs/4.2/modules/qutip/propagator.html:3711,Integrability,depend,dependent,3711,"ptions, _solver_safety_check, config; from qutip.parallel import parallel_map, _default_kwargs; from qutip.ui.progressbar import BaseProgressBar, TextProgressBar. [docs]def propagator(H, t, c_op_list=[], args={}, options=None,; unitary_mode='batch', parallel=False, ; progress_bar=None, **kwargs):; """"""; Calculate the propagator U(t) for the density matrix or wave function such; that :math:`\psi(t) = U(t)\psi(0)` or; :math:`\\rho_{\mathrm vec}(t) = U(t) \\rho_{\mathrm vec}(0)`; where :math:`\\rho_{\mathrm vec}` is the vector representation of the; density matrix. Parameters; ----------; H : qobj or list; Hamiltonian as a Qobj instance of a nested list of Qobjs and; coefficients in the list-string or list-function format for; time-dependent Hamiltonians (see description in :func:`qutip.mesolve`). t : float or array-like; Time or list of times for which to evaluate the propagator. c_op_list : list; List of qobj collapse operators. args : list/array/dictionary; Parameters to callback functions for time-dependent Hamiltonians and; collapse operators. options : :class:`qutip.Options`; with options for the ODE solver. unitary_mode = str ('batch', 'single'); Solve all basis vectors simulaneously ('batch') or individually ; ('single').; ; parallel : bool {False, True}; Run the propagator in parallel mode. This will override the ; unitary_mode settings if set to True.; ; progress_bar: BaseProgressBar; Optional instance of BaseProgressBar, or a subclass thereof, for; showing the progress of the simulation. By default no progress bar; is used, and if set to True a TextProgressBar will be used. Returns; -------; a : qobj; Instance representing the propagator :math:`U(t)`. """"""; kw = _default_kwargs(); if 'num_cpus' in kwargs:; num_cpus = kwargs['num_cpus']; else:; num_cpus = kw['num_cpus']; ; if progress_bar is None:; progress_bar = BaseProgressBar(); elif progress_bar is True:; progress_bar = TextProgressBar(). if options is None:; options = Options(); options.rhs_reuse = True; r",MatchSource.WIKI,docs/4.2/modules/qutip/propagator.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/propagator.html
https://qutip.org/docs/4.2/modules/qutip/propagator.html:2728,Modifiability,config,config,2728,"USINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY; # THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT; # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE; # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.; ###############################################################################. __all__ = ['propagator', 'propagator_steadystate']. import types; import numpy as np; import scipy.linalg as la; import functools; import scipy.sparse as sp; from qutip.qobj import Qobj; from qutip.tensor import tensor; from qutip.operators import qeye; from qutip.rhs_generate import (rhs_generate, rhs_clear, _td_format_check); from qutip.superoperator import (vec2mat, mat2vec,; vector_to_operator, operator_to_vector); from qutip.sparse import sp_reshape; from qutip.cy.sparse_utils import unit_row_norm; from qutip.mesolve import mesolve; from qutip.sesolve import sesolve; from qutip.states import basis; from qutip.solver import Options, _solver_safety_check, config; from qutip.parallel import parallel_map, _default_kwargs; from qutip.ui.progressbar import BaseProgressBar, TextProgressBar. [docs]def propagator(H, t, c_op_list=[], args={}, options=None,; unitary_mode='batch', parallel=False, ; progress_bar=None, **kwargs):; """"""; Calculate the propagator U(t) for the density matrix or wave function such; that :math:`\psi(t) = U(t)\psi(0)` or; :math:`\\rho_{\mathrm vec}(t) = U(t) \\rho_{\mathrm vec}(0)`; where :math:`\\rho_{\mathrm vec}` is the vector representation of the; density matrix. Parameters; ----------; H : qobj or list; Hamiltonian as a Qobj instance of a nested list of Qobjs and; coefficients in the list-string or list-function format for; time-dependent Hamiltonians (see description in :func:`qutip.mesolve`). t : float or array-like; Time or list of times for which to evaluate the propagator. c_op_list : list; List of qobj collapse operators. args : list/array/dictionary; Parameters to callback functions for time-depe",MatchSource.WIKI,docs/4.2/modules/qutip/propagator.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/propagator.html
https://qutip.org/docs/4.2/modules/qutip/propagator.html:4232,Usability,progress bar,progress bar,4232,"rix. Parameters; ----------; H : qobj or list; Hamiltonian as a Qobj instance of a nested list of Qobjs and; coefficients in the list-string or list-function format for; time-dependent Hamiltonians (see description in :func:`qutip.mesolve`). t : float or array-like; Time or list of times for which to evaluate the propagator. c_op_list : list; List of qobj collapse operators. args : list/array/dictionary; Parameters to callback functions for time-dependent Hamiltonians and; collapse operators. options : :class:`qutip.Options`; with options for the ODE solver. unitary_mode = str ('batch', 'single'); Solve all basis vectors simulaneously ('batch') or individually ; ('single').; ; parallel : bool {False, True}; Run the propagator in parallel mode. This will override the ; unitary_mode settings if set to True.; ; progress_bar: BaseProgressBar; Optional instance of BaseProgressBar, or a subclass thereof, for; showing the progress of the simulation. By default no progress bar; is used, and if set to True a TextProgressBar will be used. Returns; -------; a : qobj; Instance representing the propagator :math:`U(t)`. """"""; kw = _default_kwargs(); if 'num_cpus' in kwargs:; num_cpus = kwargs['num_cpus']; else:; num_cpus = kw['num_cpus']; ; if progress_bar is None:; progress_bar = BaseProgressBar(); elif progress_bar is True:; progress_bar = TextProgressBar(). if options is None:; options = Options(); options.rhs_reuse = True; rhs_clear(). if isinstance(t, (int, float, np.integer, np.floating)):; tlist = [0, t]; else:; tlist = t. td_type = _td_format_check(H, c_op_list, solver='me'); ; if isinstance(H, (types.FunctionType, types.BuiltinFunctionType,; functools.partial)):; H0 = H(0.0, args); elif isinstance(H, list):; H0 = H[0][0] if isinstance(H[0], list) else H[0]; else:; H0 = H; ; if len(c_op_list) == 0 and H0.isoper:; # calculate propagator for the wave function. N = H0.shape[0]; dims = H0.dims; ; if parallel:; unitary_mode = 'single'; u = np.zeros([N, N, len(tlist)], dtype=com",MatchSource.WIKI,docs/4.2/modules/qutip/propagator.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/propagator.html
https://qutip.org/docs/4.2/modules/qutip/qobj.html:14346,Availability,mask,mask,14346,"ith Qobj on LEFT [ ex. Qobj-4 ]; """"""; return self + (-other). def __rsub__(self, other):; """"""; SUBTRACTION with Qobj on RIGHT [ ex. 4-Qobj ]; """"""; return (-self) + other. def __mul__(self, other):; """"""; MULTIPLICATION with Qobj on LEFT [ ex. Qobj*4 ]; """"""; if isinstance(other, Qobj):; if self.dims[1] == other.dims[0]:; out = Qobj(); out.data = self.data * other.data; dims = [self.dims[0], other.dims[1]]; out.dims = dims; if settings.auto_tidyup: out.tidyup(); if (not isinstance(dims[0][0], list) and; not isinstance(dims[1][0], list)):; # If neither left or right is a superoperator,; # we should implicitly partial trace over; # matching dimensions of 1.; # Using izip_longest allows for the left and right dims; # to have uneven length (non-square Qobjs).; # We use None as padding so that it doesn't match anything,; # and will never cause a partial trace on the other side.; mask = [l == r == 1 for l, r in zip_longest(dims[0], dims[1],; fillvalue=None)]; # To ensure that there are still any dimensions left, we; # use max() to add a dimensions list of [1] if all matching dims; # are traced out of that side.; out.dims = [max([1],; [dim for dim, m in zip(dims[0], mask); if not m]),; max([1],; [dim for dim, m in zip(dims[1], mask); if not m])]. else:; out.dims = dims. out._isherm = None. if self.superrep and other.superrep:; if self.superrep != other.superrep:; msg = (""Multiplying superoperators with different "" +; ""representations""); warnings.warn(msg). out.superrep = self.superrep. return out. elif np.prod(self.shape) == 1:; out = Qobj(other); out.data *= self.data[0, 0]; out.superrep = other.superrep; return out.tidyup() if settings.auto_tidyup else out. elif np.prod(other.shape) == 1:; out = Qobj(self); out.data *= other.data[0, 0]; out.superrep = self.superrep; return out.tidyup() if settings.auto_tidyup else out. else:; raise TypeError(""Incompatible Qobj shapes""). elif isinstance(other, np.ndarray):; if other.dtype=='object':; return np.array([self * item for item in o",MatchSource.WIKI,docs/4.2/modules/qutip/qobj.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/qobj.html
https://qutip.org/docs/4.2/modules/qutip/qobj.html:14637,Availability,mask,mask,14637,"ther):; """"""; MULTIPLICATION with Qobj on LEFT [ ex. Qobj*4 ]; """"""; if isinstance(other, Qobj):; if self.dims[1] == other.dims[0]:; out = Qobj(); out.data = self.data * other.data; dims = [self.dims[0], other.dims[1]]; out.dims = dims; if settings.auto_tidyup: out.tidyup(); if (not isinstance(dims[0][0], list) and; not isinstance(dims[1][0], list)):; # If neither left or right is a superoperator,; # we should implicitly partial trace over; # matching dimensions of 1.; # Using izip_longest allows for the left and right dims; # to have uneven length (non-square Qobjs).; # We use None as padding so that it doesn't match anything,; # and will never cause a partial trace on the other side.; mask = [l == r == 1 for l, r in zip_longest(dims[0], dims[1],; fillvalue=None)]; # To ensure that there are still any dimensions left, we; # use max() to add a dimensions list of [1] if all matching dims; # are traced out of that side.; out.dims = [max([1],; [dim for dim, m in zip(dims[0], mask); if not m]),; max([1],; [dim for dim, m in zip(dims[1], mask); if not m])]. else:; out.dims = dims. out._isherm = None. if self.superrep and other.superrep:; if self.superrep != other.superrep:; msg = (""Multiplying superoperators with different "" +; ""representations""); warnings.warn(msg). out.superrep = self.superrep. return out. elif np.prod(self.shape) == 1:; out = Qobj(other); out.data *= self.data[0, 0]; out.superrep = other.superrep; return out.tidyup() if settings.auto_tidyup else out. elif np.prod(other.shape) == 1:; out = Qobj(self); out.data *= other.data[0, 0]; out.superrep = self.superrep; return out.tidyup() if settings.auto_tidyup else out. else:; raise TypeError(""Incompatible Qobj shapes""). elif isinstance(other, np.ndarray):; if other.dtype=='object':; return np.array([self * item for item in other],; dtype=object); else:; return self.data * other. elif isinstance(other, list):; # if other is a list, do element-wise multiplication; return np.array([self * item for item in other],;",MatchSource.WIKI,docs/4.2/modules/qutip/qobj.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/qobj.html
https://qutip.org/docs/4.2/modules/qutip/qobj.html:14699,Availability,mask,mask,14699,"ther):; """"""; MULTIPLICATION with Qobj on LEFT [ ex. Qobj*4 ]; """"""; if isinstance(other, Qobj):; if self.dims[1] == other.dims[0]:; out = Qobj(); out.data = self.data * other.data; dims = [self.dims[0], other.dims[1]]; out.dims = dims; if settings.auto_tidyup: out.tidyup(); if (not isinstance(dims[0][0], list) and; not isinstance(dims[1][0], list)):; # If neither left or right is a superoperator,; # we should implicitly partial trace over; # matching dimensions of 1.; # Using izip_longest allows for the left and right dims; # to have uneven length (non-square Qobjs).; # We use None as padding so that it doesn't match anything,; # and will never cause a partial trace on the other side.; mask = [l == r == 1 for l, r in zip_longest(dims[0], dims[1],; fillvalue=None)]; # To ensure that there are still any dimensions left, we; # use max() to add a dimensions list of [1] if all matching dims; # are traced out of that side.; out.dims = [max([1],; [dim for dim, m in zip(dims[0], mask); if not m]),; max([1],; [dim for dim, m in zip(dims[1], mask); if not m])]. else:; out.dims = dims. out._isherm = None. if self.superrep and other.superrep:; if self.superrep != other.superrep:; msg = (""Multiplying superoperators with different "" +; ""representations""); warnings.warn(msg). out.superrep = self.superrep. return out. elif np.prod(self.shape) == 1:; out = Qobj(other); out.data *= self.data[0, 0]; out.superrep = other.superrep; return out.tidyup() if settings.auto_tidyup else out. elif np.prod(other.shape) == 1:; out = Qobj(self); out.data *= other.data[0, 0]; out.superrep = self.superrep; return out.tidyup() if settings.auto_tidyup else out. else:; raise TypeError(""Incompatible Qobj shapes""). elif isinstance(other, np.ndarray):; if other.dtype=='object':; return np.array([self * item for item in other],; dtype=object); else:; return self.data * other. elif isinstance(other, list):; # if other is a list, do element-wise multiplication; return np.array([self * item for item in other],;",MatchSource.WIKI,docs/4.2/modules/qutip/qobj.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/qobj.html
https://qutip.org/docs/4.2/modules/qutip/qobj.html:19607,Availability,error,errors,19607,"works only for "" +; ""operators and super-operators (square matrices).""). if m is not None:; raise NotImplementedError(""modulo is not implemented for Qobj""). try:; data = self.data ** n; out = Qobj(data, dims=self.dims); out.superrep = self.superrep; return out.tidyup() if settings.auto_tidyup else out. except:; raise ValueError('Invalid choice of exponent.'). def __abs__(self):; return abs(self.data). def __str__(self):; s = """"; t = self.type; shape = self.shape; if self.type in ['oper', 'super']:; s += (""Quantum object: "" +; ""dims = "" + str(self.dims) +; "", shape = "" + str(shape) +; "", type = "" + t +; "", isherm = "" + str(self.isherm) +; (; "", superrep = {0.superrep}"".format(self); if t == ""super"" and self.superrep != ""super""; else """"; ) + ""\n""); else:; s += (""Quantum object: "" +; ""dims = "" + str(self.dims) +; "", shape = "" + str(shape) +; "", type = "" + t + ""\n""); s += ""Qobj data =\n"". if shape[0] > 10000 or shape[1] > 10000:; # if the system is huge, don't attempt to convert to a; # dense matrix and then to string, because it is pointless; # and is likely going to produce memory errors. Instead print the; # sparse data string representation; s += str(self.data). elif all(np.imag(self.data.data) == 0):; s += str(np.real(self.full())). else:; s += str(self.full()). return s. def __repr__(self):; # give complete information on Qobj without print statement in; # command-line we cant realistically serialize a Qobj into a string,; # so we simply return the informal __str__ representation instead.); return self.__str__(). def __call__(self, other):; """"""; Acts this Qobj on another Qobj either by left-multiplication,; or by vectorization and devectorization, as; appropriate.; """"""; if not isinstance(other, Qobj):; raise TypeError(""Only defined for quantum objects.""). if self.type == ""super"":; if other.type == ""ket"":; other = qutip.states.ket2dm(other). if other.type == ""oper"":; return qutip.superoperator.vector_to_operator(; self * qutip.superoperator.operator_to_vector(other",MatchSource.WIKI,docs/4.2/modules/qutip/qobj.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/qobj.html
https://qutip.org/docs/4.2/modules/qutip/qobj.html:25373,Availability,toler,tolerance,25373,"merate_flat(J.dims); J_dual = tensor.tensor_swap(J, *(; list(zip(tensor_idxs[0][1], tensor_idxs[0][0])) +; list(zip(tensor_idxs[1][1], tensor_idxs[1][0])); )).trans(); J_dual.superrep = 'choi'; return J_dual. [docs] def conj(self):; """"""Conjugate operator of quantum object.; """"""; out = Qobj(); out.data = self.data.conj(); out.dims = [self.dims[0], self.dims[1]]; return out. [docs] def norm(self, norm=None, sparse=False, tol=0, maxiter=100000):; """"""Norm of a quantum object. Default norm is L2-norm for kets and trace-norm for operators.; Other ket and operator norms may be specified using the `norm` and; argument. Parameters; ----------; norm : str; Which norm to use for ket/bra vectors: L2 'l2', max norm 'max',; or for operators: trace 'tr', Frobius 'fro', one 'one', or max; 'max'. sparse : bool; Use sparse eigenvalue solver for trace norm. Other norms are not; affected by this parameter. tol : float; Tolerance for sparse solver (if used) for trace norm. The sparse; solver may not converge if the tolerance is set too low. maxiter : int; Maximum number of iterations performed by sparse solver (if used); for trace norm. Returns; -------; norm : float; The requested norm of the operator or state quantum object. Notes; -----; The sparse eigensolver is much slower than the dense version.; Use sparse only if memory requirements demand it. """"""; if self.type in ['oper', 'super']:; if norm is None or norm == 'tr':; vals = sp_eigs(self.data, self.isherm, vecs=False,; sparse=sparse, tol=tol, maxiter=maxiter); return np.sum(sqrt(abs(vals) ** 2)); elif norm == 'fro':; return sp_fro_norm(self.data); elif norm == 'one':; return sp_one_norm(self.data); elif norm == 'max':; return sp_max_norm(self.data); else:; raise ValueError(; ""For matrices, norm must be 'tr', 'fro', 'one', or 'max'.""); else:; if norm is None or norm == 'l2':; return sp_L2_norm(self.data); elif norm == 'max':; return sp_max_norm(self.data); else:; raise ValueError(""For vectors, norm must be 'l2', or 'max'.""). [docs]",MatchSource.WIKI,docs/4.2/modules/qutip/qobj.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/qobj.html
https://qutip.org/docs/4.2/modules/qutip/qobj.html:27666,Availability,avail,available,27666,"False):; """"""Dense array from quantum object. Parameters; ----------; order : str {'C', 'F'}; Return array in C (default) or Fortran ordering.; squeeze : bool {False, True}; Squeeze output array.; ; Returns; -------; data : array; Array of complex data from quantum objects `data` attribute.; """"""; if squeeze:; return self.data.toarray(order=order).squeeze(); else:; return self.data.toarray(order=order). [docs] def diag(self):; """"""Diagonal elements of quantum object. Returns; -------; diags : array; Returns array of ``real`` values if operators is Hermitian,; otherwise ``complex`` values are returned. """"""; out = self.data.diagonal(); if np.any(np.imag(out) > settings.atol) or not self.isherm:; return out; else:; return np.real(out). [docs] def expm(self, method='dense'):; """"""Matrix exponential of quantum operator. Input operator must be square. Parameters; ----------; method : str {'dense', 'sparse'}; Use set method to use to calculate the matrix exponentiation. The; available choices includes 'dense' and 'sparse'. Since the; exponential of a matrix is nearly always dense, method='dense'; is set as default.s. Returns; -------; oper : qobj; Exponentiated quantum operator. Raises; ------; TypeError; Quantum operator is not square. """"""; if self.dims[0][0] != self.dims[1][0]:; raise TypeError('Invalid operand for matrix exponential'). if method == 'dense':; F = sp_expm(self.data, sparse=False). elif method == 'sparse':; F = sp_expm(self.data, sparse=True). else:; raise ValueError(""method must be 'dense' or 'sparse'.""). out = Qobj(F, dims=self.dims); return out.tidyup() if settings.auto_tidyup else out. [docs] def check_herm(self):; """"""Check if the quantum object is hermitian. Returns; -------; isherm : bool; Returns the new value of isherm property.; """"""; self._isherm = None; return self.isherm. [docs] def sqrtm(self, sparse=False, tol=0, maxiter=100000):; """"""Sqrt of a quantum operator. Operator must be square. Parameters; ----------; sparse : bool; Use sparse eigenvalue/v",MatchSource.WIKI,docs/4.2/modules/qutip/qobj.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/qobj.html
https://qutip.org/docs/4.2/modules/qutip/qobj.html:31990,Availability,toler,tolerance,31990,"ttings.auto_tidyup:; return out.tidyup(); else:; return out. [docs] def ptrace(self, sel):; """"""Partial trace of the quantum object. Parameters; ----------; sel : int/list; An ``int`` or ``list`` of components to keep after partial trace. Returns; -------; oper : qobj; Quantum object representing partial trace with selected components; remaining. Notes; -----; This function is identical to the :func:`qutip.qobj.ptrace` function; that has been deprecated. """"""; q = Qobj(); q.data, q.dims, _ = _ptrace(self, sel); return q.tidyup() if settings.auto_tidyup else q. [docs] def permute(self, order):; """"""Permutes a composite quantum object. Parameters; ----------; order : list/array; List specifying new tensor order. Returns; -------; P : qobj; Permuted quantum object. """"""; q = Qobj(); q.data, q.dims = _permute(self, order); return q.tidyup() if settings.auto_tidyup else q. [docs] def tidyup(self, atol=None):; """"""Removes small elements from the quantum object. Parameters; ----------; atol : float; Absolute tolerance used by tidyup. Default is set; via qutip global settings parameters. Returns; -------; oper : qobj; Quantum object with small elements removed. """"""; if atol is None:; atol = settings.auto_tidyup_atol. if self.data.nnz:; cy_tidyup(self.data.data,atol,self.data.nnz); self.data.eliminate_zeros(); return self; else:; return self. [docs] def transform(self, inpt, inverse=False, sparse=True):; """"""Basis transform defined by input array. Input array can be a ``matrix`` defining the transformation,; or a ``list`` of kets that defines the new basis. Parameters; ----------; inpt : array_like; A ``matrix`` or ``list`` of kets defining the transformation.; inverse : bool; Whether to return inverse transformation.; sparse : bool; Use sparse matrices when possible. Can be slower. Returns; -------; oper : qobj; Operator in new basis. Notes; -----; This function is still in development. """"""; if isinstance(inpt, list) or (isinstance(inpt, np.ndarray) and; len(inpt.shape) == 1):; if",MatchSource.WIKI,docs/4.2/modules/qutip/qobj.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/qobj.html
https://qutip.org/docs/4.2/modules/qutip/qobj.html:37640,Availability,toler,tolerance,37640,". Raises; ------; TypeError; Can only calculate overlap between a bra and ket quantum objects. """""". if isinstance(state, Qobj):. if self.isbra:; if state.isket:; return (self.data * state.data)[0, 0]; elif state.isbra:; return (self.data * state.data.H)[0, 0]. elif self.isket:; if state.isbra:; return (self.data.H * state.data.H)[0, 0]; elif state.isket:; return (self.data.H * state.data)[0, 0]. raise TypeError(""Can only calculate overlap for state vector Qobjs""). [docs] def eigenstates(self, sparse=False, sort='low',; eigvals=0, tol=0, maxiter=100000):; """"""Eigenstates and eigenenergies. Eigenstates and eigenenergies are defined for operators and; superoperators only. Parameters; ----------; sparse : bool; Use sparse Eigensolver. sort : str; Sort eigenvalues (and vectors) 'low' to high, or 'high' to low. eigvals : int; Number of requested eigenvalues. Default is all eigenvalues. tol : float; Tolerance used by sparse Eigensolver (0 = machine precision).; The sparse solver may not converge if the tolerance is set too low. maxiter : int; Maximum number of iterations performed by sparse solver (if used). Returns; -------; eigvals : array; Array of eigenvalues for operator. eigvecs : array; Array of quantum operators representing the oprator eigenkets.; Order of eigenkets is determined by order of eigenvalues. Notes; -----; The sparse eigensolver is much slower than the dense version.; Use sparse only if memory requirements demand it. """"""; evals, evecs = sp_eigs(self.data, self.isherm, sparse=sparse,; sort=sort, eigvals=eigvals, tol=tol,; maxiter=maxiter); new_dims = [self.dims[0], [1] * len(self.dims[0])]; ekets = np.array([Qobj(vec, dims=new_dims) for vec in evecs],; dtype=object); norms = np.array([ket.norm() for ket in ekets]); return evals, ekets / norms. [docs] def eigenenergies(self, sparse=False, sort='low',; eigvals=0, tol=0, maxiter=100000):; """"""Eigenenergies of a quantum object. Eigenenergies (eigenvalues) are defined for operators or superoperators; only. Para",MatchSource.WIKI,docs/4.2/modules/qutip/qobj.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/qobj.html
https://qutip.org/docs/4.2/modules/qutip/qobj.html:38946,Availability,toler,tolerance,38946,"rder of eigenvalues. Notes; -----; The sparse eigensolver is much slower than the dense version.; Use sparse only if memory requirements demand it. """"""; evals, evecs = sp_eigs(self.data, self.isherm, sparse=sparse,; sort=sort, eigvals=eigvals, tol=tol,; maxiter=maxiter); new_dims = [self.dims[0], [1] * len(self.dims[0])]; ekets = np.array([Qobj(vec, dims=new_dims) for vec in evecs],; dtype=object); norms = np.array([ket.norm() for ket in ekets]); return evals, ekets / norms. [docs] def eigenenergies(self, sparse=False, sort='low',; eigvals=0, tol=0, maxiter=100000):; """"""Eigenenergies of a quantum object. Eigenenergies (eigenvalues) are defined for operators or superoperators; only. Parameters; ----------; sparse : bool; Use sparse Eigensolver; sort : str; Sort eigenvalues 'low' to high, or 'high' to low.; eigvals : int; Number of requested eigenvalues. Default is all eigenvalues.; tol : float; Tolerance used by sparse Eigensolver (0=machine precision).; The sparse solver may not converge if the tolerance is set too low.; maxiter : int; Maximum number of iterations performed by sparse solver (if used). Returns; -------; eigvals : array; Array of eigenvalues for operator. Notes; -----; The sparse eigensolver is much slower than the dense version.; Use sparse only if memory requirements demand it. """"""; return sp_eigs(self.data, self.isherm, vecs=False, sparse=sparse,; sort=sort, eigvals=eigvals, tol=tol, maxiter=maxiter). [docs] def groundstate(self, sparse=False, tol=0, maxiter=100000, safe=True):; """"""Ground state Eigenvalue and Eigenvector. Defined for quantum operators or superoperators only. Parameters; ----------; sparse : bool; Use sparse Eigensolver; tol : float; Tolerance used by sparse Eigensolver (0 = machine precision).; The sparse solver may not converge if the tolerance is set too low.; maxiter : int; Maximum number of iterations performed by sparse solver (if used).; safe : bool (default=True); Check for degenerate ground state. Returns; -------; eigval : ",MatchSource.WIKI,docs/4.2/modules/qutip/qobj.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/qobj.html
https://qutip.org/docs/4.2/modules/qutip/qobj.html:39737,Availability,toler,tolerance,39737," high, or 'high' to low.; eigvals : int; Number of requested eigenvalues. Default is all eigenvalues.; tol : float; Tolerance used by sparse Eigensolver (0=machine precision).; The sparse solver may not converge if the tolerance is set too low.; maxiter : int; Maximum number of iterations performed by sparse solver (if used). Returns; -------; eigvals : array; Array of eigenvalues for operator. Notes; -----; The sparse eigensolver is much slower than the dense version.; Use sparse only if memory requirements demand it. """"""; return sp_eigs(self.data, self.isherm, vecs=False, sparse=sparse,; sort=sort, eigvals=eigvals, tol=tol, maxiter=maxiter). [docs] def groundstate(self, sparse=False, tol=0, maxiter=100000, safe=True):; """"""Ground state Eigenvalue and Eigenvector. Defined for quantum operators or superoperators only. Parameters; ----------; sparse : bool; Use sparse Eigensolver; tol : float; Tolerance used by sparse Eigensolver (0 = machine precision).; The sparse solver may not converge if the tolerance is set too low.; maxiter : int; Maximum number of iterations performed by sparse solver (if used).; safe : bool (default=True); Check for degenerate ground state. Returns; -------; eigval : float; Eigenvalue for the ground state of quantum operator.; eigvec : qobj; Eigenket for the ground state of quantum operator. Notes; -----; The sparse eigensolver is much slower than the dense version.; Use sparse only if memory requirements demand it. """"""; if safe:; evals = 2; else:; evals = 1; grndval, grndvec = sp_eigs(self.data, self.isherm, sparse=sparse,; eigvals=evals, tol=tol, maxiter=maxiter); if safe:; if tol == 0: tol = 1e-15; if (grndval[1]-grndval[0]) <= 10*tol:; print(""WARNING: Ground state may be degenerate. ""; ""Use Q.eigenstates()""); new_dims = [self.dims[0], [1] * len(self.dims[0])]; grndvec = Qobj(grndvec[0], dims=new_dims); grndvec = grndvec / grndvec.norm(); return grndval[0], grndvec. [docs] def trans(self):; """"""Transposed operator. Returns; -------; oper : q",MatchSource.WIKI,docs/4.2/modules/qutip/qobj.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/qobj.html
https://qutip.org/docs/4.2/modules/qutip/qobj.html:52801,Availability,toler,tolerance,52801," only. Using the `Qobj.isoperbra`; attribute is recommended. """"""; return True if isinstance(Q, Qobj) and Q.isoperbra else False. def isoper(Q):; """"""Determines if given quantum object is a operator. Parameters; ----------; Q : qobj; Quantum object. Returns; -------; isoper : bool; True if Qobj is operator, False otherwise. Examples; --------; >>> a = destroy(5); >>> isoper(a); True. Notes; -----; This function is for legacy compatibility only. Using the `Qobj.isoper`; attribute is recommended. """"""; return True if isinstance(Q, Qobj) and Q.isoper else False. def issuper(Q):; """"""Determines if given quantum object is a super-operator. Parameters; ----------; Q : qobj; Quantum object. Returns; -------; issuper : bool; True if Qobj is superoperator, False otherwise. Notes; -----; This function is for legacy compatibility only. Using the `Qobj.issuper`; attribute is recommended. """"""; return True if isinstance(Q, Qobj) and Q.issuper else False. def isequal(A, B, tol=None):; """"""Determines if two qobj objects are equal to within given tolerance. Parameters; ----------; A : qobj; Qobj one; B : qobj; Qobj two; tol : float; Tolerence for equality to be valid. Returns; -------; isequal : bool; True if qobjs are equal, False otherwise. Notes; -----; This function is for legacy compatibility only. Instead, it is recommended; to use the equality operator of Qobj instances instead: A == B. """"""; if tol is None:; tol = settings.atol. if not isinstance(A, Qobj) or not isinstance(B, Qobj):; return False. if A.dims != B.dims:; return False. Adat = A.data; Bdat = B.data; elems = (Adat - Bdat).data; if np.any(np.abs(elems) > tol):; return False. return True. def isherm(Q):; """"""Determines if given operator is Hermitian. Parameters; ----------; Q : qobj; Quantum object. Returns; -------; isherm : bool; True if operator is Hermitian, False otherwise. Examples; --------; >>> a = destroy(4); >>> isherm(a); False. Notes; -----; This function is for legacy compatibility only. Using the `Qobj.isherm",MatchSource.WIKI,docs/4.2/modules/qutip/qobj.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/qobj.html
https://qutip.org/docs/4.2/modules/qutip/qobj.html:20798,Deployability,update,update,20798,"# give complete information on Qobj without print statement in; # command-line we cant realistically serialize a Qobj into a string,; # so we simply return the informal __str__ representation instead.); return self.__str__(). def __call__(self, other):; """"""; Acts this Qobj on another Qobj either by left-multiplication,; or by vectorization and devectorization, as; appropriate.; """"""; if not isinstance(other, Qobj):; raise TypeError(""Only defined for quantum objects.""). if self.type == ""super"":; if other.type == ""ket"":; other = qutip.states.ket2dm(other). if other.type == ""oper"":; return qutip.superoperator.vector_to_operator(; self * qutip.superoperator.operator_to_vector(other); ); else:; raise TypeError(""Can only act super on oper or ket.""). elif self.type == ""oper"":; if other.type == ""ket"":; return self * other; else:; raise TypeError(""Can only act oper on ket.""). def __getstate__(self):; # defines what happens when Qobj object gets pickled; self.__dict__.update({'qutip_version': __version__[:5]}); return self.__dict__. def __setstate__(self, state):; # defines what happens when loading a pickled Qobj; if 'qutip_version' in state.keys():; del state['qutip_version']; (self.__dict__).update(state). def _repr_latex_(self):; """"""; Generate a LaTeX representation of the Qobj instance. Can be used for; formatted output in ipython notebook.; """"""; t = self.type; shape = self.shape; s = r''; if self.type in ['oper', 'super']:; s += (""Quantum object: "" +; ""dims = "" + str(self.dims) +; "", shape = "" + str(shape) +; "", type = "" + t +; "", isherm = "" + str(self.isherm) +; (; "", superrep = {0.superrep}"".format(self); if t == ""super"" and self.superrep != ""super""; else """"; )); else:; s += (""Quantum object: "" +; ""dims = "" + str(self.dims) +; "", shape = "" + str(shape) +; "", type = "" + t). M, N = self.data.shape. s += r'\begin{equation*}\left(\begin{array}{*{11}c}'. def _format_float(value):; if value == 0.0:; return ""0.0""; elif abs(value) > 1000.0 or abs(value) < 0.001:; return (""%.3e",MatchSource.WIKI,docs/4.2/modules/qutip/qobj.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/qobj.html
https://qutip.org/docs/4.2/modules/qutip/qobj.html:21029,Deployability,update,update,21029,"self.__str__(). def __call__(self, other):; """"""; Acts this Qobj on another Qobj either by left-multiplication,; or by vectorization and devectorization, as; appropriate.; """"""; if not isinstance(other, Qobj):; raise TypeError(""Only defined for quantum objects.""). if self.type == ""super"":; if other.type == ""ket"":; other = qutip.states.ket2dm(other). if other.type == ""oper"":; return qutip.superoperator.vector_to_operator(; self * qutip.superoperator.operator_to_vector(other); ); else:; raise TypeError(""Can only act super on oper or ket.""). elif self.type == ""oper"":; if other.type == ""ket"":; return self * other; else:; raise TypeError(""Can only act oper on ket.""). def __getstate__(self):; # defines what happens when Qobj object gets pickled; self.__dict__.update({'qutip_version': __version__[:5]}); return self.__dict__. def __setstate__(self, state):; # defines what happens when loading a pickled Qobj; if 'qutip_version' in state.keys():; del state['qutip_version']; (self.__dict__).update(state). def _repr_latex_(self):; """"""; Generate a LaTeX representation of the Qobj instance. Can be used for; formatted output in ipython notebook.; """"""; t = self.type; shape = self.shape; s = r''; if self.type in ['oper', 'super']:; s += (""Quantum object: "" +; ""dims = "" + str(self.dims) +; "", shape = "" + str(shape) +; "", type = "" + t +; "", isherm = "" + str(self.isherm) +; (; "", superrep = {0.superrep}"".format(self); if t == ""super"" and self.superrep != ""super""; else """"; )); else:; s += (""Quantum object: "" +; ""dims = "" + str(self.dims) +; "", shape = "" + str(shape) +; "", type = "" + t). M, N = self.data.shape. s += r'\begin{equation*}\left(\begin{array}{*{11}c}'. def _format_float(value):; if value == 0.0:; return ""0.0""; elif abs(value) > 1000.0 or abs(value) < 0.001:; return (""%.3e"" % value).replace(""e"", r""\times10^{"") + ""}""; elif abs(value - int(value)) < 0.001:; return ""%.1f"" % value; else:; return ""%.3f"" % value. def _format_element(m, n, d):; s = "" & "" if n > 0 else """"; if type(d) ==",MatchSource.WIKI,docs/4.2/modules/qutip/qobj.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/qobj.html
https://qutip.org/docs/4.2/modules/qutip/qobj.html:54254,Deployability,update,updated,54254,"""Determines if given quantum object is a super-operator. Parameters; ----------; Q : qobj; Quantum object. Returns; -------; issuper : bool; True if Qobj is superoperator, False otherwise. Notes; -----; This function is for legacy compatibility only. Using the `Qobj.issuper`; attribute is recommended. """"""; return True if isinstance(Q, Qobj) and Q.issuper else False. def isequal(A, B, tol=None):; """"""Determines if two qobj objects are equal to within given tolerance. Parameters; ----------; A : qobj; Qobj one; B : qobj; Qobj two; tol : float; Tolerence for equality to be valid. Returns; -------; isequal : bool; True if qobjs are equal, False otherwise. Notes; -----; This function is for legacy compatibility only. Instead, it is recommended; to use the equality operator of Qobj instances instead: A == B. """"""; if tol is None:; tol = settings.atol. if not isinstance(A, Qobj) or not isinstance(B, Qobj):; return False. if A.dims != B.dims:; return False. Adat = A.data; Bdat = B.data; elems = (Adat - Bdat).data; if np.any(np.abs(elems) > tol):; return False. return True. def isherm(Q):; """"""Determines if given operator is Hermitian. Parameters; ----------; Q : qobj; Quantum object. Returns; -------; isherm : bool; True if operator is Hermitian, False otherwise. Examples; --------; >>> a = destroy(4); >>> isherm(a); False. Notes; -----; This function is for legacy compatibility only. Using the `Qobj.isherm`; attribute is recommended. """"""; return True if isinstance(Q, Qobj) and Q.isherm else False. # TRAILING IMPORTS; # We do a few imports here to avoid circular dependencies.; from qutip.eseries import eseries; import qutip.superop_reps as sr; import qutip.tensor as tensor; import qutip.operators as ops; import qutip.metrics as mts; import qutip.states; import qutip.superoperator.  Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, and A.L. Grimsmo.; Last updated on Jan 17, 2018. . Built with Sphinx using a theme provided by Read the Docs. . ",MatchSource.WIKI,docs/4.2/modules/qutip/qobj.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/qobj.html
https://qutip.org/docs/4.2/modules/qutip/qobj.html:18381,Energy Efficiency,power,powers,18381," = self.data / other; out.dims = self.dims; if settings.auto_tidyup: out.tidyup(); if isinstance(other, complex):; out._isherm = out.isherm; else:; out._isherm = self._isherm. out.superrep = self.superrep. return out. else:; raise TypeError(""Incompatible object for division""). def __neg__(self):; """"""; NEGATION operation.; """"""; out = Qobj(); out.data = -self.data; out.dims = self.dims; out.superrep = self.superrep; if settings.auto_tidyup: out.tidyup(); out._isherm = self._isherm; return out. def __getitem__(self, ind):; """"""; GET qobj elements.; """"""; out = self.data[ind]; if sp.issparse(out):; return np.asarray(out.todense()); else:; return out. def __eq__(self, other):; """"""; EQUALITY operator.; """"""; if (isinstance(other, Qobj) and; self.dims == other.dims and; not np.any(np.abs((self.data - other.data).data) >; settings.atol)):; return True; else:; return False. def __ne__(self, other):; """"""; INEQUALITY operator.; """"""; return not (self == other). def __pow__(self, n, m=None): # calculates powers of Qobj; """"""; POWER operation.; """"""; if self.type not in ['oper', 'super']:; raise Exception(""Raising a qobj to some power works only for "" +; ""operators and super-operators (square matrices).""). if m is not None:; raise NotImplementedError(""modulo is not implemented for Qobj""). try:; data = self.data ** n; out = Qobj(data, dims=self.dims); out.superrep = self.superrep; return out.tidyup() if settings.auto_tidyup else out. except:; raise ValueError('Invalid choice of exponent.'). def __abs__(self):; return abs(self.data). def __str__(self):; s = """"; t = self.type; shape = self.shape; if self.type in ['oper', 'super']:; s += (""Quantum object: "" +; ""dims = "" + str(self.dims) +; "", shape = "" + str(shape) +; "", type = "" + t +; "", isherm = "" + str(self.isherm) +; (; "", superrep = {0.superrep}"".format(self); if t == ""super"" and self.superrep != ""super""; else """"; ) + ""\n""); else:; s += (""Quantum object: "" +; ""dims = "" + str(self.dims) +; "", shape = "" + str(shape) +; "", type = "" + t ",MatchSource.WIKI,docs/4.2/modules/qutip/qobj.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/qobj.html
https://qutip.org/docs/4.2/modules/qutip/qobj.html:18505,Energy Efficiency,power,power,18505,"out.isherm; else:; out._isherm = self._isherm. out.superrep = self.superrep. return out. else:; raise TypeError(""Incompatible object for division""). def __neg__(self):; """"""; NEGATION operation.; """"""; out = Qobj(); out.data = -self.data; out.dims = self.dims; out.superrep = self.superrep; if settings.auto_tidyup: out.tidyup(); out._isherm = self._isherm; return out. def __getitem__(self, ind):; """"""; GET qobj elements.; """"""; out = self.data[ind]; if sp.issparse(out):; return np.asarray(out.todense()); else:; return out. def __eq__(self, other):; """"""; EQUALITY operator.; """"""; if (isinstance(other, Qobj) and; self.dims == other.dims and; not np.any(np.abs((self.data - other.data).data) >; settings.atol)):; return True; else:; return False. def __ne__(self, other):; """"""; INEQUALITY operator.; """"""; return not (self == other). def __pow__(self, n, m=None): # calculates powers of Qobj; """"""; POWER operation.; """"""; if self.type not in ['oper', 'super']:; raise Exception(""Raising a qobj to some power works only for "" +; ""operators and super-operators (square matrices).""). if m is not None:; raise NotImplementedError(""modulo is not implemented for Qobj""). try:; data = self.data ** n; out = Qobj(data, dims=self.dims); out.superrep = self.superrep; return out.tidyup() if settings.auto_tidyup else out. except:; raise ValueError('Invalid choice of exponent.'). def __abs__(self):; return abs(self.data). def __str__(self):; s = """"; t = self.type; shape = self.shape; if self.type in ['oper', 'super']:; s += (""Quantum object: "" +; ""dims = "" + str(self.dims) +; "", shape = "" + str(shape) +; "", type = "" + t +; "", isherm = "" + str(self.isherm) +; (; "", superrep = {0.superrep}"".format(self); if t == ""super"" and self.superrep != ""super""; else """"; ) + ""\n""); else:; s += (""Quantum object: "" +; ""dims = "" + str(self.dims) +; "", shape = "" + str(shape) +; "", type = "" + t + ""\n""); s += ""Qobj data =\n"". if shape[0] > 10000 or shape[1] > 10000:; # if the system is huge, don't attempt to convert to a; ",MatchSource.WIKI,docs/4.2/modules/qutip/qobj.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/qobj.html
https://qutip.org/docs/4.2/modules/qutip/qobj.html:46141,Integrability,depend,dependent,46141,"lf; return q_oper.iscp and q_oper.istp; else:; return False. @property; def isherm(self):. if self._isherm is not None:; # used previously computed value; return self._isherm. self._isherm = bool(zcsr_isherm(self.data)). return self._isherm. @isherm.setter; def isherm(self, isherm):; self._isherm = isherm. @property; def type(self):; if not self._type:; self._type = type_from_dims(self.dims). return self._type. @property; def shape(self):; if self.data.shape == (1, 1):; return tuple([np.prod(self.dims[0]), np.prod(self.dims[1])]); else:; return tuple(self.data.shape). @property; def isbra(self):; return self.type == 'bra'. @property; def isket(self):; return self.type == 'ket'. @property; def isoperbra(self):; return self.type == 'operator-bra'. @property; def isoperket(self):; return self.type == 'operator-ket'. @property; def isoper(self):; return self.type == 'oper'. @property; def issuper(self):; return self.type == 'super'. @staticmethod; [docs] def evaluate(qobj_list, t, args):; """"""Evaluate a time-dependent quantum object in list format. For; example,. qobj_list = [H0, [H1, func_t]]. is evaluated to. Qobj(t) = H0 + H1 * func_t(t, args). and. qobj_list = [H0, [H1, 'sin(w * t)']]. is evaluated to. Qobj(t) = H0 + H1 * sin(args['w'] * t). Parameters; ----------; qobj_list : list; A nested list of Qobj instances and corresponding time-dependent; coefficients.; t : float; The time for which to evaluate the time-dependent Qobj instance.; args : dictionary; A dictionary with parameter values required to evaluate the; time-dependent Qobj intance. Returns; -------; output : Qobj; A Qobj instance that represents the value of qobj_list at time t. """""". q_sum = 0; if isinstance(qobj_list, Qobj):; q_sum = qobj_list; elif isinstance(qobj_list, list):; for q in qobj_list:; if isinstance(q, Qobj):; q_sum += q; elif (isinstance(q, list) and len(q) == 2 and; isinstance(q[0], Qobj)):; if isinstance(q[1], types.FunctionType):; q_sum += q[0] * q[1](t, args); elif isinstance(q[1], str",MatchSource.WIKI,docs/4.2/modules/qutip/qobj.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/qobj.html
https://qutip.org/docs/4.2/modules/qutip/qobj.html:46480,Integrability,depend,dependent,46480,"f type(self):; if not self._type:; self._type = type_from_dims(self.dims). return self._type. @property; def shape(self):; if self.data.shape == (1, 1):; return tuple([np.prod(self.dims[0]), np.prod(self.dims[1])]); else:; return tuple(self.data.shape). @property; def isbra(self):; return self.type == 'bra'. @property; def isket(self):; return self.type == 'ket'. @property; def isoperbra(self):; return self.type == 'operator-bra'. @property; def isoperket(self):; return self.type == 'operator-ket'. @property; def isoper(self):; return self.type == 'oper'. @property; def issuper(self):; return self.type == 'super'. @staticmethod; [docs] def evaluate(qobj_list, t, args):; """"""Evaluate a time-dependent quantum object in list format. For; example,. qobj_list = [H0, [H1, func_t]]. is evaluated to. Qobj(t) = H0 + H1 * func_t(t, args). and. qobj_list = [H0, [H1, 'sin(w * t)']]. is evaluated to. Qobj(t) = H0 + H1 * sin(args['w'] * t). Parameters; ----------; qobj_list : list; A nested list of Qobj instances and corresponding time-dependent; coefficients.; t : float; The time for which to evaluate the time-dependent Qobj instance.; args : dictionary; A dictionary with parameter values required to evaluate the; time-dependent Qobj intance. Returns; -------; output : Qobj; A Qobj instance that represents the value of qobj_list at time t. """""". q_sum = 0; if isinstance(qobj_list, Qobj):; q_sum = qobj_list; elif isinstance(qobj_list, list):; for q in qobj_list:; if isinstance(q, Qobj):; q_sum += q; elif (isinstance(q, list) and len(q) == 2 and; isinstance(q[0], Qobj)):; if isinstance(q[1], types.FunctionType):; q_sum += q[0] * q[1](t, args); elif isinstance(q[1], str):; args['t'] = t; q_sum += q[0] * float(eval(q[1], globals(), args)); else:; raise TypeError('Unrecognized format for ' +; 'specification of time-dependent Qobj'); else:; raise TypeError('Unrecognized format for specification ' +; 'of time-dependent Qobj'); else:; raise TypeError(; 'Unrecongized format for specificati",MatchSource.WIKI,docs/4.2/modules/qutip/qobj.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/qobj.html
https://qutip.org/docs/4.2/modules/qutip/qobj.html:46557,Integrability,depend,dependent,46557,"erty; def shape(self):; if self.data.shape == (1, 1):; return tuple([np.prod(self.dims[0]), np.prod(self.dims[1])]); else:; return tuple(self.data.shape). @property; def isbra(self):; return self.type == 'bra'. @property; def isket(self):; return self.type == 'ket'. @property; def isoperbra(self):; return self.type == 'operator-bra'. @property; def isoperket(self):; return self.type == 'operator-ket'. @property; def isoper(self):; return self.type == 'oper'. @property; def issuper(self):; return self.type == 'super'. @staticmethod; [docs] def evaluate(qobj_list, t, args):; """"""Evaluate a time-dependent quantum object in list format. For; example,. qobj_list = [H0, [H1, func_t]]. is evaluated to. Qobj(t) = H0 + H1 * func_t(t, args). and. qobj_list = [H0, [H1, 'sin(w * t)']]. is evaluated to. Qobj(t) = H0 + H1 * sin(args['w'] * t). Parameters; ----------; qobj_list : list; A nested list of Qobj instances and corresponding time-dependent; coefficients.; t : float; The time for which to evaluate the time-dependent Qobj instance.; args : dictionary; A dictionary with parameter values required to evaluate the; time-dependent Qobj intance. Returns; -------; output : Qobj; A Qobj instance that represents the value of qobj_list at time t. """""". q_sum = 0; if isinstance(qobj_list, Qobj):; q_sum = qobj_list; elif isinstance(qobj_list, list):; for q in qobj_list:; if isinstance(q, Qobj):; q_sum += q; elif (isinstance(q, list) and len(q) == 2 and; isinstance(q[0], Qobj)):; if isinstance(q[1], types.FunctionType):; q_sum += q[0] * q[1](t, args); elif isinstance(q[1], str):; args['t'] = t; q_sum += q[0] * float(eval(q[1], globals(), args)); else:; raise TypeError('Unrecognized format for ' +; 'specification of time-dependent Qobj'); else:; raise TypeError('Unrecognized format for specification ' +; 'of time-dependent Qobj'); else:; raise TypeError(; 'Unrecongized format for specification of time-dependent Qobj'). return q_sum. # -------------------------------------------------------",MatchSource.WIKI,docs/4.2/modules/qutip/qobj.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/qobj.html
https://qutip.org/docs/4.2/modules/qutip/qobj.html:46668,Integrability,depend,dependent,46668,".prod(self.dims[1])]); else:; return tuple(self.data.shape). @property; def isbra(self):; return self.type == 'bra'. @property; def isket(self):; return self.type == 'ket'. @property; def isoperbra(self):; return self.type == 'operator-bra'. @property; def isoperket(self):; return self.type == 'operator-ket'. @property; def isoper(self):; return self.type == 'oper'. @property; def issuper(self):; return self.type == 'super'. @staticmethod; [docs] def evaluate(qobj_list, t, args):; """"""Evaluate a time-dependent quantum object in list format. For; example,. qobj_list = [H0, [H1, func_t]]. is evaluated to. Qobj(t) = H0 + H1 * func_t(t, args). and. qobj_list = [H0, [H1, 'sin(w * t)']]. is evaluated to. Qobj(t) = H0 + H1 * sin(args['w'] * t). Parameters; ----------; qobj_list : list; A nested list of Qobj instances and corresponding time-dependent; coefficients.; t : float; The time for which to evaluate the time-dependent Qobj instance.; args : dictionary; A dictionary with parameter values required to evaluate the; time-dependent Qobj intance. Returns; -------; output : Qobj; A Qobj instance that represents the value of qobj_list at time t. """""". q_sum = 0; if isinstance(qobj_list, Qobj):; q_sum = qobj_list; elif isinstance(qobj_list, list):; for q in qobj_list:; if isinstance(q, Qobj):; q_sum += q; elif (isinstance(q, list) and len(q) == 2 and; isinstance(q[0], Qobj)):; if isinstance(q[1], types.FunctionType):; q_sum += q[0] * q[1](t, args); elif isinstance(q[1], str):; args['t'] = t; q_sum += q[0] * float(eval(q[1], globals(), args)); else:; raise TypeError('Unrecognized format for ' +; 'specification of time-dependent Qobj'); else:; raise TypeError('Unrecognized format for specification ' +; 'of time-dependent Qobj'); else:; raise TypeError(; 'Unrecongized format for specification of time-dependent Qobj'). return q_sum. # -----------------------------------------------------------------------------; # This functions evaluates a time-dependent quantum object on the lis",MatchSource.WIKI,docs/4.2/modules/qutip/qobj.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/qobj.html
https://qutip.org/docs/4.2/modules/qutip/qobj.html:47270,Integrability,depend,dependent,47270,"H1 * func_t(t, args). and. qobj_list = [H0, [H1, 'sin(w * t)']]. is evaluated to. Qobj(t) = H0 + H1 * sin(args['w'] * t). Parameters; ----------; qobj_list : list; A nested list of Qobj instances and corresponding time-dependent; coefficients.; t : float; The time for which to evaluate the time-dependent Qobj instance.; args : dictionary; A dictionary with parameter values required to evaluate the; time-dependent Qobj intance. Returns; -------; output : Qobj; A Qobj instance that represents the value of qobj_list at time t. """""". q_sum = 0; if isinstance(qobj_list, Qobj):; q_sum = qobj_list; elif isinstance(qobj_list, list):; for q in qobj_list:; if isinstance(q, Qobj):; q_sum += q; elif (isinstance(q, list) and len(q) == 2 and; isinstance(q[0], Qobj)):; if isinstance(q[1], types.FunctionType):; q_sum += q[0] * q[1](t, args); elif isinstance(q[1], str):; args['t'] = t; q_sum += q[0] * float(eval(q[1], globals(), args)); else:; raise TypeError('Unrecognized format for ' +; 'specification of time-dependent Qobj'); else:; raise TypeError('Unrecognized format for specification ' +; 'of time-dependent Qobj'); else:; raise TypeError(; 'Unrecongized format for specification of time-dependent Qobj'). return q_sum. # -----------------------------------------------------------------------------; # This functions evaluates a time-dependent quantum object on the list-string; # and list-function formats that are used by the time-dependent solvers.; # Although not used directly in by those solvers, it can for test purposes be; # conventient to be able to evaluate the expressions passed to the solver for; # arbitrary value of time. This function provides this functionality.; #; def qobj_list_evaluate(qobj_list, t, args):; """"""; Depracated: See Qobj.evaluate; """"""; warnings.warn(""Deprecated: Use Qobj.evaluate"", DeprecationWarning); return Qobj.evaluate(qobj_list, t, args). # -----------------------------------------------------------------------------; #; # A collection of tests used ",MatchSource.WIKI,docs/4.2/modules/qutip/qobj.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/qobj.html
https://qutip.org/docs/4.2/modules/qutip/qobj.html:47364,Integrability,depend,dependent,47364,"H1 * func_t(t, args). and. qobj_list = [H0, [H1, 'sin(w * t)']]. is evaluated to. Qobj(t) = H0 + H1 * sin(args['w'] * t). Parameters; ----------; qobj_list : list; A nested list of Qobj instances and corresponding time-dependent; coefficients.; t : float; The time for which to evaluate the time-dependent Qobj instance.; args : dictionary; A dictionary with parameter values required to evaluate the; time-dependent Qobj intance. Returns; -------; output : Qobj; A Qobj instance that represents the value of qobj_list at time t. """""". q_sum = 0; if isinstance(qobj_list, Qobj):; q_sum = qobj_list; elif isinstance(qobj_list, list):; for q in qobj_list:; if isinstance(q, Qobj):; q_sum += q; elif (isinstance(q, list) and len(q) == 2 and; isinstance(q[0], Qobj)):; if isinstance(q[1], types.FunctionType):; q_sum += q[0] * q[1](t, args); elif isinstance(q[1], str):; args['t'] = t; q_sum += q[0] * float(eval(q[1], globals(), args)); else:; raise TypeError('Unrecognized format for ' +; 'specification of time-dependent Qobj'); else:; raise TypeError('Unrecognized format for specification ' +; 'of time-dependent Qobj'); else:; raise TypeError(; 'Unrecongized format for specification of time-dependent Qobj'). return q_sum. # -----------------------------------------------------------------------------; # This functions evaluates a time-dependent quantum object on the list-string; # and list-function formats that are used by the time-dependent solvers.; # Although not used directly in by those solvers, it can for test purposes be; # conventient to be able to evaluate the expressions passed to the solver for; # arbitrary value of time. This function provides this functionality.; #; def qobj_list_evaluate(qobj_list, t, args):; """"""; Depracated: See Qobj.evaluate; """"""; warnings.warn(""Deprecated: Use Qobj.evaluate"", DeprecationWarning); return Qobj.evaluate(qobj_list, t, args). # -----------------------------------------------------------------------------; #; # A collection of tests used ",MatchSource.WIKI,docs/4.2/modules/qutip/qobj.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/qobj.html
https://qutip.org/docs/4.2/modules/qutip/qobj.html:47454,Integrability,depend,dependent,47454,"H1 * func_t(t, args). and. qobj_list = [H0, [H1, 'sin(w * t)']]. is evaluated to. Qobj(t) = H0 + H1 * sin(args['w'] * t). Parameters; ----------; qobj_list : list; A nested list of Qobj instances and corresponding time-dependent; coefficients.; t : float; The time for which to evaluate the time-dependent Qobj instance.; args : dictionary; A dictionary with parameter values required to evaluate the; time-dependent Qobj intance. Returns; -------; output : Qobj; A Qobj instance that represents the value of qobj_list at time t. """""". q_sum = 0; if isinstance(qobj_list, Qobj):; q_sum = qobj_list; elif isinstance(qobj_list, list):; for q in qobj_list:; if isinstance(q, Qobj):; q_sum += q; elif (isinstance(q, list) and len(q) == 2 and; isinstance(q[0], Qobj)):; if isinstance(q[1], types.FunctionType):; q_sum += q[0] * q[1](t, args); elif isinstance(q[1], str):; args['t'] = t; q_sum += q[0] * float(eval(q[1], globals(), args)); else:; raise TypeError('Unrecognized format for ' +; 'specification of time-dependent Qobj'); else:; raise TypeError('Unrecognized format for specification ' +; 'of time-dependent Qobj'); else:; raise TypeError(; 'Unrecongized format for specification of time-dependent Qobj'). return q_sum. # -----------------------------------------------------------------------------; # This functions evaluates a time-dependent quantum object on the list-string; # and list-function formats that are used by the time-dependent solvers.; # Although not used directly in by those solvers, it can for test purposes be; # conventient to be able to evaluate the expressions passed to the solver for; # arbitrary value of time. This function provides this functionality.; #; def qobj_list_evaluate(qobj_list, t, args):; """"""; Depracated: See Qobj.evaluate; """"""; warnings.warn(""Deprecated: Use Qobj.evaluate"", DeprecationWarning); return Qobj.evaluate(qobj_list, t, args). # -----------------------------------------------------------------------------; #; # A collection of tests used ",MatchSource.WIKI,docs/4.2/modules/qutip/qobj.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/qobj.html
https://qutip.org/docs/4.2/modules/qutip/qobj.html:47601,Integrability,depend,dependent,47601," A dictionary with parameter values required to evaluate the; time-dependent Qobj intance. Returns; -------; output : Qobj; A Qobj instance that represents the value of qobj_list at time t. """""". q_sum = 0; if isinstance(qobj_list, Qobj):; q_sum = qobj_list; elif isinstance(qobj_list, list):; for q in qobj_list:; if isinstance(q, Qobj):; q_sum += q; elif (isinstance(q, list) and len(q) == 2 and; isinstance(q[0], Qobj)):; if isinstance(q[1], types.FunctionType):; q_sum += q[0] * q[1](t, args); elif isinstance(q[1], str):; args['t'] = t; q_sum += q[0] * float(eval(q[1], globals(), args)); else:; raise TypeError('Unrecognized format for ' +; 'specification of time-dependent Qobj'); else:; raise TypeError('Unrecognized format for specification ' +; 'of time-dependent Qobj'); else:; raise TypeError(; 'Unrecongized format for specification of time-dependent Qobj'). return q_sum. # -----------------------------------------------------------------------------; # This functions evaluates a time-dependent quantum object on the list-string; # and list-function formats that are used by the time-dependent solvers.; # Although not used directly in by those solvers, it can for test purposes be; # conventient to be able to evaluate the expressions passed to the solver for; # arbitrary value of time. This function provides this functionality.; #; def qobj_list_evaluate(qobj_list, t, args):; """"""; Depracated: See Qobj.evaluate; """"""; warnings.warn(""Deprecated: Use Qobj.evaluate"", DeprecationWarning); return Qobj.evaluate(qobj_list, t, args). # -----------------------------------------------------------------------------; #; # A collection of tests used to determine the type of quantum objects, and some; # functions for increased compatibility with quantum optics toolbox.; #. def dag(A):; """"""Adjont operator (dagger) of a quantum object. Parameters; ----------; A : qobj; Input quantum object. Returns; -------; oper : qobj; Adjoint of input operator. Notes; -----; This function is for legac",MatchSource.WIKI,docs/4.2/modules/qutip/qobj.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/qobj.html
https://qutip.org/docs/4.2/modules/qutip/qobj.html:47700,Integrability,depend,dependent,47700," A dictionary with parameter values required to evaluate the; time-dependent Qobj intance. Returns; -------; output : Qobj; A Qobj instance that represents the value of qobj_list at time t. """""". q_sum = 0; if isinstance(qobj_list, Qobj):; q_sum = qobj_list; elif isinstance(qobj_list, list):; for q in qobj_list:; if isinstance(q, Qobj):; q_sum += q; elif (isinstance(q, list) and len(q) == 2 and; isinstance(q[0], Qobj)):; if isinstance(q[1], types.FunctionType):; q_sum += q[0] * q[1](t, args); elif isinstance(q[1], str):; args['t'] = t; q_sum += q[0] * float(eval(q[1], globals(), args)); else:; raise TypeError('Unrecognized format for ' +; 'specification of time-dependent Qobj'); else:; raise TypeError('Unrecognized format for specification ' +; 'of time-dependent Qobj'); else:; raise TypeError(; 'Unrecongized format for specification of time-dependent Qobj'). return q_sum. # -----------------------------------------------------------------------------; # This functions evaluates a time-dependent quantum object on the list-string; # and list-function formats that are used by the time-dependent solvers.; # Although not used directly in by those solvers, it can for test purposes be; # conventient to be able to evaluate the expressions passed to the solver for; # arbitrary value of time. This function provides this functionality.; #; def qobj_list_evaluate(qobj_list, t, args):; """"""; Depracated: See Qobj.evaluate; """"""; warnings.warn(""Deprecated: Use Qobj.evaluate"", DeprecationWarning); return Qobj.evaluate(qobj_list, t, args). # -----------------------------------------------------------------------------; #; # A collection of tests used to determine the type of quantum objects, and some; # functions for increased compatibility with quantum optics toolbox.; #. def dag(A):; """"""Adjont operator (dagger) of a quantum object. Parameters; ----------; A : qobj; Input quantum object. Returns; -------; oper : qobj; Adjoint of input operator. Notes; -----; This function is for legac",MatchSource.WIKI,docs/4.2/modules/qutip/qobj.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/qobj.html
https://qutip.org/docs/4.2/modules/qutip/qobj.html:53920,Integrability,depend,dependencies,53920,"""Determines if given quantum object is a super-operator. Parameters; ----------; Q : qobj; Quantum object. Returns; -------; issuper : bool; True if Qobj is superoperator, False otherwise. Notes; -----; This function is for legacy compatibility only. Using the `Qobj.issuper`; attribute is recommended. """"""; return True if isinstance(Q, Qobj) and Q.issuper else False. def isequal(A, B, tol=None):; """"""Determines if two qobj objects are equal to within given tolerance. Parameters; ----------; A : qobj; Qobj one; B : qobj; Qobj two; tol : float; Tolerence for equality to be valid. Returns; -------; isequal : bool; True if qobjs are equal, False otherwise. Notes; -----; This function is for legacy compatibility only. Instead, it is recommended; to use the equality operator of Qobj instances instead: A == B. """"""; if tol is None:; tol = settings.atol. if not isinstance(A, Qobj) or not isinstance(B, Qobj):; return False. if A.dims != B.dims:; return False. Adat = A.data; Bdat = B.data; elems = (Adat - Bdat).data; if np.any(np.abs(elems) > tol):; return False. return True. def isherm(Q):; """"""Determines if given operator is Hermitian. Parameters; ----------; Q : qobj; Quantum object. Returns; -------; isherm : bool; True if operator is Hermitian, False otherwise. Examples; --------; >>> a = destroy(4); >>> isherm(a); False. Notes; -----; This function is for legacy compatibility only. Using the `Qobj.isherm`; attribute is recommended. """"""; return True if isinstance(Q, Qobj) and Q.isherm else False. # TRAILING IMPORTS; # We do a few imports here to avoid circular dependencies.; from qutip.eseries import eseries; import qutip.superop_reps as sr; import qutip.tensor as tensor; import qutip.operators as ops; import qutip.metrics as mts; import qutip.states; import qutip.superoperator.  Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, and A.L. Grimsmo.; Last updated on Jan 17, 2018. . Built with Sphinx using a theme provided by Read the Docs. . ",MatchSource.WIKI,docs/4.2/modules/qutip/qobj.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/qobj.html
https://qutip.org/docs/4.2/modules/qutip/qobj.html:6956,Performance,perform,performing,6956,"sm(); Cosine of quantum object.; dag(); Adjoint (dagger) of quantum object.; dnorm(); Diamond norm of quantum operator.; dual_chan(); Dual channel of quantum object representing a CP map.; eigenenergies(sparse=False, sort='low', eigvals=0, tol=0, maxiter=100000); Returns eigenenergies (eigenvalues) of a quantum object.; eigenstates(sparse=False, sort='low', eigvals=0, tol=0, maxiter=100000); Returns eigenenergies and eigenstates of quantum object.; expm(); Matrix exponential of quantum object.; full(order='C'); Returns dense array of quantum object `data` attribute.; groundstate(sparse=False, tol=0, maxiter=100000); Returns eigenvalue and eigenket for the groundstate of a quantum; object.; matrix_element(bra, ket); Returns the matrix element of operator between `bra` and `ket` vectors.; norm(norm='tr', sparse=False, tol=0, maxiter=100000); Returns norm of a ket or an operator.; permute(order); Returns composite qobj with indices reordered.; ptrace(sel); Returns quantum object for selected dimensions after performing; partial trace.; sinm(); Sine of quantum object.; sqrtm(); Matrix square root of quantum object.; tidyup(atol=1e-12); Removes small elements from quantum object.; tr(); Trace of quantum object.; trans(); Transpose of quantum object.; transform(inpt, inverse=False); Performs a basis transformation defined by `inpt` matrix.; trunc_neg(method='clip'); Removes negative eigenvalues and returns a new Qobj that is; a valid density operator.; unit(norm='tr', sparse=False, tol=0, maxiter=100000); Returns normalized quantum object. """"""; __array_priority__ = 100 # sets Qobj priority above numpy arrays. def __init__(self, inpt=None, dims=[[], []], shape=[],; type=None, isherm=None, copy=True,; fast=False, superrep=None):; """"""; Qobj constructor.; """"""; self._isherm = isherm; self._type = type; self.superrep = superrep. if fast == 'mc':; # fast Qobj construction for use in mcsolve with ket output; self._data = inpt; self.dims = dims; self._isherm = False; return. if fa",MatchSource.WIKI,docs/4.2/modules/qutip/qobj.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/qobj.html
https://qutip.org/docs/4.2/modules/qutip/qobj.html:10685,Performance,cache,cache,10685,"(inpt.shape[0])], [int(inpt.shape[1])]]; else:; self.dims = dims. elif isinstance(inpt, (int, float, complex,; np.integer, np.floating, np.complexfloating)):; # if input is int, float, or complex then convert to array; _tmp = sp.csr_matrix([[inpt]], dtype=complex); self._data = fast_csr_matrix((_tmp.data, _tmp.indices, _tmp.indptr),; shape=_tmp.shape); if not np.any(dims):; self.dims = [[1], [1]]; else:; self.dims = dims. else:; warnings.warn(""Initializing Qobj from unsupported type: %s"" %; builtins.type(inpt)); inpt = np.array([[0]]); _tmp = sp.csr_matrix(inpt, dtype=complex, copy=copy); self._data = fast_csr_matrix((_tmp.data, _tmp.indices, _tmp.indptr),; shape = _tmp.shape); self.dims = [[int(inpt.shape[0])], [int(inpt.shape[1])]]. if type == 'super':; if self.type == 'oper':; self.dims = [[[d] for d in self.dims[0]],; [[d] for d in self.dims[1]]]. if superrep:; self.superrep = superrep; else:; if self.type == 'super' and self.superrep is None:; self.superrep = 'super'. # clear type cache; self._type = None. [docs] def copy(self):; """"""Create identical copy""""""; return Qobj(inpt=self). def get_data(self):; return self._data; #Here we perfrom a check of the csr matrix type during setting of Q.data; def set_data(self, data):; if not isinstance(data, fast_csr_matrix):; raise TypeError('Qobj data must be in fast_csr format.'); else:; self._data = data; data = property(get_data, set_data). def __add__(self, other):; """"""; ADDITION with Qobj on LEFT [ ex. Qobj+4 ]; """"""; if isinstance(other, eseries):; return other.__radd__(self). if not isinstance(other, Qobj):; other = Qobj(other). if np.prod(other.shape) == 1 and np.prod(self.shape) != 1:; # case for scalar quantum object; dat = other.data[0, 0]; if dat == 0:; return self. out = Qobj(). if self.type in ['oper', 'super']:; out.data = self.data + dat * fast_identity(; self.shape[0]); else:; out.data = self.data; out.data.data = out.data.data + dat. out.dims = self.dims; ; if settings.auto_tidyup: out.tidyup(); ; if isinst",MatchSource.WIKI,docs/4.2/modules/qutip/qobj.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/qobj.html
https://qutip.org/docs/4.2/modules/qutip/qobj.html:20924,Performance,load,loading,20924,"tically serialize a Qobj into a string,; # so we simply return the informal __str__ representation instead.); return self.__str__(). def __call__(self, other):; """"""; Acts this Qobj on another Qobj either by left-multiplication,; or by vectorization and devectorization, as; appropriate.; """"""; if not isinstance(other, Qobj):; raise TypeError(""Only defined for quantum objects.""). if self.type == ""super"":; if other.type == ""ket"":; other = qutip.states.ket2dm(other). if other.type == ""oper"":; return qutip.superoperator.vector_to_operator(; self * qutip.superoperator.operator_to_vector(other); ); else:; raise TypeError(""Can only act super on oper or ket.""). elif self.type == ""oper"":; if other.type == ""ket"":; return self * other; else:; raise TypeError(""Can only act oper on ket.""). def __getstate__(self):; # defines what happens when Qobj object gets pickled; self.__dict__.update({'qutip_version': __version__[:5]}); return self.__dict__. def __setstate__(self, state):; # defines what happens when loading a pickled Qobj; if 'qutip_version' in state.keys():; del state['qutip_version']; (self.__dict__).update(state). def _repr_latex_(self):; """"""; Generate a LaTeX representation of the Qobj instance. Can be used for; formatted output in ipython notebook.; """"""; t = self.type; shape = self.shape; s = r''; if self.type in ['oper', 'super']:; s += (""Quantum object: "" +; ""dims = "" + str(self.dims) +; "", shape = "" + str(shape) +; "", type = "" + t +; "", isherm = "" + str(self.isherm) +; (; "", superrep = {0.superrep}"".format(self); if t == ""super"" and self.superrep != ""super""; else """"; )); else:; s += (""Quantum object: "" +; ""dims = "" + str(self.dims) +; "", shape = "" + str(shape) +; "", type = "" + t). M, N = self.data.shape. s += r'\begin{equation*}\left(\begin{array}{*{11}c}'. def _format_float(value):; if value == 0.0:; return ""0.0""; elif abs(value) > 1000.0 or abs(value) < 0.001:; return (""%.3e"" % value).replace(""e"", r""\times10^{"") + ""}""; elif abs(value - int(value)) < 0.001:; return ""%",MatchSource.WIKI,docs/4.2/modules/qutip/qobj.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/qobj.html
https://qutip.org/docs/4.2/modules/qutip/qobj.html:25443,Performance,perform,performed,25443,"tensor_idxs[0][0])) +; list(zip(tensor_idxs[1][1], tensor_idxs[1][0])); )).trans(); J_dual.superrep = 'choi'; return J_dual. [docs] def conj(self):; """"""Conjugate operator of quantum object.; """"""; out = Qobj(); out.data = self.data.conj(); out.dims = [self.dims[0], self.dims[1]]; return out. [docs] def norm(self, norm=None, sparse=False, tol=0, maxiter=100000):; """"""Norm of a quantum object. Default norm is L2-norm for kets and trace-norm for operators.; Other ket and operator norms may be specified using the `norm` and; argument. Parameters; ----------; norm : str; Which norm to use for ket/bra vectors: L2 'l2', max norm 'max',; or for operators: trace 'tr', Frobius 'fro', one 'one', or max; 'max'. sparse : bool; Use sparse eigenvalue solver for trace norm. Other norms are not; affected by this parameter. tol : float; Tolerance for sparse solver (if used) for trace norm. The sparse; solver may not converge if the tolerance is set too low. maxiter : int; Maximum number of iterations performed by sparse solver (if used); for trace norm. Returns; -------; norm : float; The requested norm of the operator or state quantum object. Notes; -----; The sparse eigensolver is much slower than the dense version.; Use sparse only if memory requirements demand it. """"""; if self.type in ['oper', 'super']:; if norm is None or norm == 'tr':; vals = sp_eigs(self.data, self.isherm, vecs=False,; sparse=sparse, tol=tol, maxiter=maxiter); return np.sum(sqrt(abs(vals) ** 2)); elif norm == 'fro':; return sp_fro_norm(self.data); elif norm == 'one':; return sp_one_norm(self.data); elif norm == 'max':; return sp_max_norm(self.data); else:; raise ValueError(; ""For matrices, norm must be 'tr', 'fro', 'one', or 'max'.""); else:; if norm is None or norm == 'l2':; return sp_L2_norm(self.data); elif norm == 'max':; return sp_max_norm(self.data); else:; raise ValueError(""For vectors, norm must be 'l2', or 'max'.""). [docs] def tr(self):; """"""Trace of a quantum object. Returns; -------; trace : float; Retu",MatchSource.WIKI,docs/4.2/modules/qutip/qobj.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/qobj.html
https://qutip.org/docs/4.2/modules/qutip/qobj.html:30800,Performance,perform,performed,30800,"tes; -----; Uses the Q.expm() method. """"""; if self.dims[0][0] == self.dims[1][0]:; return 0.5 * ((1j * self).expm() + (-1j * self).expm()); else:; raise TypeError('Invalid operand for matrix square root'). [docs] def sinm(self):; """"""Sine of a quantum operator. Operator must be square. Returns; -------; oper : qobj; Matrix sine of operator. Raises; ------; TypeError; Quantum object is not square. Notes; -----; Uses the Q.expm() method. """"""; if self.dims[0][0] == self.dims[1][0]:; return -0.5j * ((1j * self).expm() - (-1j * self).expm()); else:; raise TypeError('Invalid operand for matrix square root'). [docs] def unit(self, norm=None, sparse=False, tol=0, maxiter=100000):; """"""Operator or state normalized to unity. Uses norm from Qobj.norm(). Parameters; ----------; norm : str; Requested norm for states / operators.; sparse : bool; Use sparse eigensolver for trace norm. Does not affect other norms.; tol : float; Tolerance used by sparse eigensolver.; maxiter : int; Number of maximum iterations performed by sparse eigensolver. Returns; -------; oper : qobj; Normalized quantum object. """"""; out = self / self.norm(norm=norm, sparse=sparse,; tol=tol, maxiter=maxiter); if settings.auto_tidyup:; return out.tidyup(); else:; return out. [docs] def ptrace(self, sel):; """"""Partial trace of the quantum object. Parameters; ----------; sel : int/list; An ``int`` or ``list`` of components to keep after partial trace. Returns; -------; oper : qobj; Quantum object representing partial trace with selected components; remaining. Notes; -----; This function is identical to the :func:`qutip.qobj.ptrace` function; that has been deprecated. """"""; q = Qobj(); q.data, q.dims, _ = _ptrace(self, sel); return q.tidyup() if settings.auto_tidyup else q. [docs] def permute(self, order):; """"""Permutes a composite quantum object. Parameters; ----------; order : list/array; List specifying new tensor order. Returns; -------; P : qobj; Permuted quantum object. """"""; q = Qobj(); q.data, q.dims = _permute(se",MatchSource.WIKI,docs/4.2/modules/qutip/qobj.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/qobj.html
https://qutip.org/docs/4.2/modules/qutip/qobj.html:37710,Performance,perform,performed,37710,"t quantum objects. """""". if isinstance(state, Qobj):. if self.isbra:; if state.isket:; return (self.data * state.data)[0, 0]; elif state.isbra:; return (self.data * state.data.H)[0, 0]. elif self.isket:; if state.isbra:; return (self.data.H * state.data.H)[0, 0]; elif state.isket:; return (self.data.H * state.data)[0, 0]. raise TypeError(""Can only calculate overlap for state vector Qobjs""). [docs] def eigenstates(self, sparse=False, sort='low',; eigvals=0, tol=0, maxiter=100000):; """"""Eigenstates and eigenenergies. Eigenstates and eigenenergies are defined for operators and; superoperators only. Parameters; ----------; sparse : bool; Use sparse Eigensolver. sort : str; Sort eigenvalues (and vectors) 'low' to high, or 'high' to low. eigvals : int; Number of requested eigenvalues. Default is all eigenvalues. tol : float; Tolerance used by sparse Eigensolver (0 = machine precision).; The sparse solver may not converge if the tolerance is set too low. maxiter : int; Maximum number of iterations performed by sparse solver (if used). Returns; -------; eigvals : array; Array of eigenvalues for operator. eigvecs : array; Array of quantum operators representing the oprator eigenkets.; Order of eigenkets is determined by order of eigenvalues. Notes; -----; The sparse eigensolver is much slower than the dense version.; Use sparse only if memory requirements demand it. """"""; evals, evecs = sp_eigs(self.data, self.isherm, sparse=sparse,; sort=sort, eigvals=eigvals, tol=tol,; maxiter=maxiter); new_dims = [self.dims[0], [1] * len(self.dims[0])]; ekets = np.array([Qobj(vec, dims=new_dims) for vec in evecs],; dtype=object); norms = np.array([ket.norm() for ket in ekets]); return evals, ekets / norms. [docs] def eigenenergies(self, sparse=False, sort='low',; eigvals=0, tol=0, maxiter=100000):; """"""Eigenenergies of a quantum object. Eigenenergies (eigenvalues) are defined for operators or superoperators; only. Parameters; ----------; sparse : bool; Use sparse Eigensolver; sort : str; Sort",MatchSource.WIKI,docs/4.2/modules/qutip/qobj.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/qobj.html
https://qutip.org/docs/4.2/modules/qutip/qobj.html:39017,Performance,perform,performed,39017,"n the dense version.; Use sparse only if memory requirements demand it. """"""; evals, evecs = sp_eigs(self.data, self.isherm, sparse=sparse,; sort=sort, eigvals=eigvals, tol=tol,; maxiter=maxiter); new_dims = [self.dims[0], [1] * len(self.dims[0])]; ekets = np.array([Qobj(vec, dims=new_dims) for vec in evecs],; dtype=object); norms = np.array([ket.norm() for ket in ekets]); return evals, ekets / norms. [docs] def eigenenergies(self, sparse=False, sort='low',; eigvals=0, tol=0, maxiter=100000):; """"""Eigenenergies of a quantum object. Eigenenergies (eigenvalues) are defined for operators or superoperators; only. Parameters; ----------; sparse : bool; Use sparse Eigensolver; sort : str; Sort eigenvalues 'low' to high, or 'high' to low.; eigvals : int; Number of requested eigenvalues. Default is all eigenvalues.; tol : float; Tolerance used by sparse Eigensolver (0=machine precision).; The sparse solver may not converge if the tolerance is set too low.; maxiter : int; Maximum number of iterations performed by sparse solver (if used). Returns; -------; eigvals : array; Array of eigenvalues for operator. Notes; -----; The sparse eigensolver is much slower than the dense version.; Use sparse only if memory requirements demand it. """"""; return sp_eigs(self.data, self.isherm, vecs=False, sparse=sparse,; sort=sort, eigvals=eigvals, tol=tol, maxiter=maxiter). [docs] def groundstate(self, sparse=False, tol=0, maxiter=100000, safe=True):; """"""Ground state Eigenvalue and Eigenvector. Defined for quantum operators or superoperators only. Parameters; ----------; sparse : bool; Use sparse Eigensolver; tol : float; Tolerance used by sparse Eigensolver (0 = machine precision).; The sparse solver may not converge if the tolerance is set too low.; maxiter : int; Maximum number of iterations performed by sparse solver (if used).; safe : bool (default=True); Check for degenerate ground state. Returns; -------; eigval : float; Eigenvalue for the ground state of quantum operator.; eigvec : qobj; ",MatchSource.WIKI,docs/4.2/modules/qutip/qobj.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/qobj.html
https://qutip.org/docs/4.2/modules/qutip/qobj.html:39808,Performance,perform,performed,39808,"fault is all eigenvalues.; tol : float; Tolerance used by sparse Eigensolver (0=machine precision).; The sparse solver may not converge if the tolerance is set too low.; maxiter : int; Maximum number of iterations performed by sparse solver (if used). Returns; -------; eigvals : array; Array of eigenvalues for operator. Notes; -----; The sparse eigensolver is much slower than the dense version.; Use sparse only if memory requirements demand it. """"""; return sp_eigs(self.data, self.isherm, vecs=False, sparse=sparse,; sort=sort, eigvals=eigvals, tol=tol, maxiter=maxiter). [docs] def groundstate(self, sparse=False, tol=0, maxiter=100000, safe=True):; """"""Ground state Eigenvalue and Eigenvector. Defined for quantum operators or superoperators only. Parameters; ----------; sparse : bool; Use sparse Eigensolver; tol : float; Tolerance used by sparse Eigensolver (0 = machine precision).; The sparse solver may not converge if the tolerance is set too low.; maxiter : int; Maximum number of iterations performed by sparse solver (if used).; safe : bool (default=True); Check for degenerate ground state. Returns; -------; eigval : float; Eigenvalue for the ground state of quantum operator.; eigvec : qobj; Eigenket for the ground state of quantum operator. Notes; -----; The sparse eigensolver is much slower than the dense version.; Use sparse only if memory requirements demand it. """"""; if safe:; evals = 2; else:; evals = 1; grndval, grndvec = sp_eigs(self.data, self.isherm, sparse=sparse,; eigvals=evals, tol=tol, maxiter=maxiter); if safe:; if tol == 0: tol = 1e-15; if (grndval[1]-grndval[0]) <= 10*tol:; print(""WARNING: Ground state may be degenerate. ""; ""Use Q.eigenstates()""); new_dims = [self.dims[0], [1] * len(self.dims[0])]; grndvec = Qobj(grndvec[0], dims=new_dims); grndvec = grndvec / grndvec.norm(); return grndval[0], grndvec. [docs] def trans(self):; """"""Transposed operator. Returns; -------; oper : qobj; Transpose of input operator. """"""; out = Qobj(); out.data = zcsr_transpo",MatchSource.WIKI,docs/4.2/modules/qutip/qobj.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/qobj.html
https://qutip.org/docs/4.2/modules/qutip/qobj.html:43228,Performance,cache,cached,43228,"ity matrices or state; vectors normalized should probably be set to True, but for Qobjs; that represents operators in for example an Hamiltonian, normalize; should be False. Returns; -------; q : Qobj; A new instance of :class:`qutip.Qobj` that contains only the states; corresponding to indices that are **not** in `state_inds`. Notes; -----; Experimental. """"""; keep_indices = np.array([s not in states_inds; for s in range(self.shape[0])]).nonzero()[0]. return self.extract_states(keep_indices, normalize=normalize). [docs] def dnorm(self, B=None):; """"""Calculates the diamond norm, or the diamond distance to another; operator. Parameters; ----------; B : Qobj or None; If B is not None, the diamond distance d(A, B) = dnorm(A - B) between; this operator and B is returned instead of the diamond norm. Returns; -------; d : float; Either the diamond norm of this operator, or the diamond distance; from this operator to B. """"""; return mts.dnorm(self, B). @property; def ishp(self):; # FIXME: this needs to be cached in the same ways as isherm.; if self.type in [""super"", ""oper""]:; try:; J = sr.to_choi(self); return J.isherm; except:; return False; else:; return False. @property; def iscp(self):; # FIXME: this needs to be cached in the same ways as isherm.; if self.type in [""super"", ""oper""]:; try:; J = (; self; # We can test with either Choi or chi, since the basis; # transformation between them is unitary and hence; # preserves the CP and TP conditions.; if self.superrep in ('choi', 'chi'); else sr.to_choi(self); ); # If J isn't hermitian, then that could indicate either; # that J is not normal, or is normal, but has complex eigenvalues.; # In either case, it makes no sense to then demand that the; # eigenvalues be non-negative.; if not J.isherm:; return False; eigs = J.eigenenergies(); return all(eigs >= -settings.atol); except:; return False; else:; return False. @property; def istp(self):; import qutip.superop_reps as sr; if self.type in [""super"", ""oper""]:; try:; # Normalize to ",MatchSource.WIKI,docs/4.2/modules/qutip/qobj.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/qobj.html
https://qutip.org/docs/4.2/modules/qutip/qobj.html:43443,Performance,cache,cached,43443,"e of :class:`qutip.Qobj` that contains only the states; corresponding to indices that are **not** in `state_inds`. Notes; -----; Experimental. """"""; keep_indices = np.array([s not in states_inds; for s in range(self.shape[0])]).nonzero()[0]. return self.extract_states(keep_indices, normalize=normalize). [docs] def dnorm(self, B=None):; """"""Calculates the diamond norm, or the diamond distance to another; operator. Parameters; ----------; B : Qobj or None; If B is not None, the diamond distance d(A, B) = dnorm(A - B) between; this operator and B is returned instead of the diamond norm. Returns; -------; d : float; Either the diamond norm of this operator, or the diamond distance; from this operator to B. """"""; return mts.dnorm(self, B). @property; def ishp(self):; # FIXME: this needs to be cached in the same ways as isherm.; if self.type in [""super"", ""oper""]:; try:; J = sr.to_choi(self); return J.isherm; except:; return False; else:; return False. @property; def iscp(self):; # FIXME: this needs to be cached in the same ways as isherm.; if self.type in [""super"", ""oper""]:; try:; J = (; self; # We can test with either Choi or chi, since the basis; # transformation between them is unitary and hence; # preserves the CP and TP conditions.; if self.superrep in ('choi', 'chi'); else sr.to_choi(self); ); # If J isn't hermitian, then that could indicate either; # that J is not normal, or is normal, but has complex eigenvalues.; # In either case, it makes no sense to then demand that the; # eigenvalues be non-negative.; if not J.isherm:; return False; eigs = J.eigenenergies(); return all(eigs >= -settings.atol); except:; return False; else:; return False. @property; def istp(self):; import qutip.superop_reps as sr; if self.type in [""super"", ""oper""]:; try:; # Normalize to a super of type choi or chi.; # We can test with either Choi or chi, since the basis; # transformation between them is unitary and hence; # preserves the CP and TP conditions.; if self.type == ""super"" and self.super",MatchSource.WIKI,docs/4.2/modules/qutip/qobj.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/qobj.html
https://qutip.org/docs/4.2/modules/qutip/qobj.html:39445,Safety,safe,safe,39445,"s(self, sparse=False, sort='low',; eigvals=0, tol=0, maxiter=100000):; """"""Eigenenergies of a quantum object. Eigenenergies (eigenvalues) are defined for operators or superoperators; only. Parameters; ----------; sparse : bool; Use sparse Eigensolver; sort : str; Sort eigenvalues 'low' to high, or 'high' to low.; eigvals : int; Number of requested eigenvalues. Default is all eigenvalues.; tol : float; Tolerance used by sparse Eigensolver (0=machine precision).; The sparse solver may not converge if the tolerance is set too low.; maxiter : int; Maximum number of iterations performed by sparse solver (if used). Returns; -------; eigvals : array; Array of eigenvalues for operator. Notes; -----; The sparse eigensolver is much slower than the dense version.; Use sparse only if memory requirements demand it. """"""; return sp_eigs(self.data, self.isherm, vecs=False, sparse=sparse,; sort=sort, eigvals=eigvals, tol=tol, maxiter=maxiter). [docs] def groundstate(self, sparse=False, tol=0, maxiter=100000, safe=True):; """"""Ground state Eigenvalue and Eigenvector. Defined for quantum operators or superoperators only. Parameters; ----------; sparse : bool; Use sparse Eigensolver; tol : float; Tolerance used by sparse Eigensolver (0 = machine precision).; The sparse solver may not converge if the tolerance is set too low.; maxiter : int; Maximum number of iterations performed by sparse solver (if used).; safe : bool (default=True); Check for degenerate ground state. Returns; -------; eigval : float; Eigenvalue for the ground state of quantum operator.; eigvec : qobj; Eigenket for the ground state of quantum operator. Notes; -----; The sparse eigensolver is much slower than the dense version.; Use sparse only if memory requirements demand it. """"""; if safe:; evals = 2; else:; evals = 1; grndval, grndvec = sp_eigs(self.data, self.isherm, sparse=sparse,; eigvals=evals, tol=tol, maxiter=maxiter); if safe:; if tol == 0: tol = 1e-15; if (grndval[1]-grndval[0]) <= 10*tol:; print(""WARNING: Groun",MatchSource.WIKI,docs/4.2/modules/qutip/qobj.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/qobj.html
https://qutip.org/docs/4.2/modules/qutip/qobj.html:39847,Safety,safe,safe,39847,"er (0=machine precision).; The sparse solver may not converge if the tolerance is set too low.; maxiter : int; Maximum number of iterations performed by sparse solver (if used). Returns; -------; eigvals : array; Array of eigenvalues for operator. Notes; -----; The sparse eigensolver is much slower than the dense version.; Use sparse only if memory requirements demand it. """"""; return sp_eigs(self.data, self.isherm, vecs=False, sparse=sparse,; sort=sort, eigvals=eigvals, tol=tol, maxiter=maxiter). [docs] def groundstate(self, sparse=False, tol=0, maxiter=100000, safe=True):; """"""Ground state Eigenvalue and Eigenvector. Defined for quantum operators or superoperators only. Parameters; ----------; sparse : bool; Use sparse Eigensolver; tol : float; Tolerance used by sparse Eigensolver (0 = machine precision).; The sparse solver may not converge if the tolerance is set too low.; maxiter : int; Maximum number of iterations performed by sparse solver (if used).; safe : bool (default=True); Check for degenerate ground state. Returns; -------; eigval : float; Eigenvalue for the ground state of quantum operator.; eigvec : qobj; Eigenket for the ground state of quantum operator. Notes; -----; The sparse eigensolver is much slower than the dense version.; Use sparse only if memory requirements demand it. """"""; if safe:; evals = 2; else:; evals = 1; grndval, grndvec = sp_eigs(self.data, self.isherm, sparse=sparse,; eigvals=evals, tol=tol, maxiter=maxiter); if safe:; if tol == 0: tol = 1e-15; if (grndval[1]-grndval[0]) <= 10*tol:; print(""WARNING: Ground state may be degenerate. ""; ""Use Q.eigenstates()""); new_dims = [self.dims[0], [1] * len(self.dims[0])]; grndvec = Qobj(grndvec[0], dims=new_dims); grndvec = grndvec / grndvec.norm(); return grndval[0], grndvec. [docs] def trans(self):; """"""Transposed operator. Returns; -------; oper : qobj; Transpose of input operator. """"""; out = Qobj(); out.data = zcsr_transpose(self.data); out.dims = [self.dims[1], self.dims[0]]; return out. [docs",MatchSource.WIKI,docs/4.2/modules/qutip/qobj.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/qobj.html
https://qutip.org/docs/4.2/modules/qutip/qobj.html:40199,Safety,safe,safe,40199,"requirements demand it. """"""; return sp_eigs(self.data, self.isherm, vecs=False, sparse=sparse,; sort=sort, eigvals=eigvals, tol=tol, maxiter=maxiter). [docs] def groundstate(self, sparse=False, tol=0, maxiter=100000, safe=True):; """"""Ground state Eigenvalue and Eigenvector. Defined for quantum operators or superoperators only. Parameters; ----------; sparse : bool; Use sparse Eigensolver; tol : float; Tolerance used by sparse Eigensolver (0 = machine precision).; The sparse solver may not converge if the tolerance is set too low.; maxiter : int; Maximum number of iterations performed by sparse solver (if used).; safe : bool (default=True); Check for degenerate ground state. Returns; -------; eigval : float; Eigenvalue for the ground state of quantum operator.; eigvec : qobj; Eigenket for the ground state of quantum operator. Notes; -----; The sparse eigensolver is much slower than the dense version.; Use sparse only if memory requirements demand it. """"""; if safe:; evals = 2; else:; evals = 1; grndval, grndvec = sp_eigs(self.data, self.isherm, sparse=sparse,; eigvals=evals, tol=tol, maxiter=maxiter); if safe:; if tol == 0: tol = 1e-15; if (grndval[1]-grndval[0]) <= 10*tol:; print(""WARNING: Ground state may be degenerate. ""; ""Use Q.eigenstates()""); new_dims = [self.dims[0], [1] * len(self.dims[0])]; grndvec = Qobj(grndvec[0], dims=new_dims); grndvec = grndvec / grndvec.norm(); return grndval[0], grndvec. [docs] def trans(self):; """"""Transposed operator. Returns; -------; oper : qobj; Transpose of input operator. """"""; out = Qobj(); out.data = zcsr_transpose(self.data); out.dims = [self.dims[1], self.dims[0]]; return out. [docs] def extract_states(self, states_inds, normalize=False):; """"""Qobj with states in state_inds only. Parameters; ----------; states_inds : list of integer; The states that should be kept. normalize : True / False; Weather or not the new Qobj instance should be normalized (default; is False). For Qobjs that represents density matrices or state; vectors ",MatchSource.WIKI,docs/4.2/modules/qutip/qobj.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/qobj.html
https://qutip.org/docs/4.2/modules/qutip/qobj.html:40347,Safety,safe,safe,40347,"iter). [docs] def groundstate(self, sparse=False, tol=0, maxiter=100000, safe=True):; """"""Ground state Eigenvalue and Eigenvector. Defined for quantum operators or superoperators only. Parameters; ----------; sparse : bool; Use sparse Eigensolver; tol : float; Tolerance used by sparse Eigensolver (0 = machine precision).; The sparse solver may not converge if the tolerance is set too low.; maxiter : int; Maximum number of iterations performed by sparse solver (if used).; safe : bool (default=True); Check for degenerate ground state. Returns; -------; eigval : float; Eigenvalue for the ground state of quantum operator.; eigvec : qobj; Eigenket for the ground state of quantum operator. Notes; -----; The sparse eigensolver is much slower than the dense version.; Use sparse only if memory requirements demand it. """"""; if safe:; evals = 2; else:; evals = 1; grndval, grndvec = sp_eigs(self.data, self.isherm, sparse=sparse,; eigvals=evals, tol=tol, maxiter=maxiter); if safe:; if tol == 0: tol = 1e-15; if (grndval[1]-grndval[0]) <= 10*tol:; print(""WARNING: Ground state may be degenerate. ""; ""Use Q.eigenstates()""); new_dims = [self.dims[0], [1] * len(self.dims[0])]; grndvec = Qobj(grndvec[0], dims=new_dims); grndvec = grndvec / grndvec.norm(); return grndval[0], grndvec. [docs] def trans(self):; """"""Transposed operator. Returns; -------; oper : qobj; Transpose of input operator. """"""; out = Qobj(); out.data = zcsr_transpose(self.data); out.dims = [self.dims[1], self.dims[0]]; return out. [docs] def extract_states(self, states_inds, normalize=False):; """"""Qobj with states in state_inds only. Parameters; ----------; states_inds : list of integer; The states that should be kept. normalize : True / False; Weather or not the new Qobj instance should be normalized (default; is False). For Qobjs that represents density matrices or state; vectors normalized should probably be set to True, but for Qobjs; that represents operators in for example an Hamiltonian, normalize; should be False. ",MatchSource.WIKI,docs/4.2/modules/qutip/qobj.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/qobj.html
https://qutip.org/docs/4.2/modules/qutip/qobj.html:53905,Safety,avoid,avoid,53905,"""Determines if given quantum object is a super-operator. Parameters; ----------; Q : qobj; Quantum object. Returns; -------; issuper : bool; True if Qobj is superoperator, False otherwise. Notes; -----; This function is for legacy compatibility only. Using the `Qobj.issuper`; attribute is recommended. """"""; return True if isinstance(Q, Qobj) and Q.issuper else False. def isequal(A, B, tol=None):; """"""Determines if two qobj objects are equal to within given tolerance. Parameters; ----------; A : qobj; Qobj one; B : qobj; Qobj two; tol : float; Tolerence for equality to be valid. Returns; -------; isequal : bool; True if qobjs are equal, False otherwise. Notes; -----; This function is for legacy compatibility only. Instead, it is recommended; to use the equality operator of Qobj instances instead: A == B. """"""; if tol is None:; tol = settings.atol. if not isinstance(A, Qobj) or not isinstance(B, Qobj):; return False. if A.dims != B.dims:; return False. Adat = A.data; Bdat = B.data; elems = (Adat - Bdat).data; if np.any(np.abs(elems) > tol):; return False. return True. def isherm(Q):; """"""Determines if given operator is Hermitian. Parameters; ----------; Q : qobj; Quantum object. Returns; -------; isherm : bool; True if operator is Hermitian, False otherwise. Examples; --------; >>> a = destroy(4); >>> isherm(a); False. Notes; -----; This function is for legacy compatibility only. Using the `Qobj.isherm`; attribute is recommended. """"""; return True if isinstance(Q, Qobj) and Q.isherm else False. # TRAILING IMPORTS; # We do a few imports here to avoid circular dependencies.; from qutip.eseries import eseries; import qutip.superop_reps as sr; import qutip.tensor as tensor; import qutip.operators as ops; import qutip.metrics as mts; import qutip.states; import qutip.superoperator.  Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, and A.L. Grimsmo.; Last updated on Jan 17, 2018. . Built with Sphinx using a theme provided by Read the Docs. . ",MatchSource.WIKI,docs/4.2/modules/qutip/qobj.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/qobj.html
https://qutip.org/docs/4.2/modules/qutip/qobj.html:2677,Testability,log,log,2677,"# LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,; # DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY; # THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT; # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE; # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.; ###############################################################################; """"""The Quantum Object (Qobj) class, for representing quantum states and; operators, and related functions.; """""". __all__ = ['Qobj', 'qobj_list_evaluate', 'ptrace', 'dag', 'isequal',; 'issuper', 'isoper', 'isoperket', 'isoperbra', 'isket', 'isbra',; 'isherm', 'shape', 'dims']. import warnings; import types. try:; import builtins; except:; import __builtin__ as builtins. # import math functions from numpy.math: required for td string evaluation; from numpy import (arccos, arccosh, arcsin, arcsinh, arctan, arctan2, arctanh,; ceil, copysign, cos, cosh, degrees, e, exp, expm1, fabs,; floor, fmod, frexp, hypot, isinf, isnan, ldexp, log, log10,; log1p, modf, pi, radians, sin, sinh, sqrt, tan, tanh, trunc). import numpy as np; import scipy.sparse as sp; import scipy.linalg as la; import qutip.settings as settings; from qutip import __version__; from qutip.fastsparse import fast_csr_matrix, fast_identity; from qutip.cy.ptrace import _ptrace; from qutip.permute import _permute; from qutip.sparse import (sp_eigs, sp_expm, sp_fro_norm, sp_max_norm,; sp_one_norm, sp_L2_norm); from qutip.dimensions import type_from_dims, enumerate_flat, collapse_dims_super; from qutip.cy.spmath import (zcsr_transpose, zcsr_adjoint, zcsr_isherm); from qutip.cy.sparse_utils import cy_tidyup; import sys; if sys.version_info.major >= 3:; from itertools import zip_longest; elif sys.version_info.major < 3:; from itertools import izip_longest; zip_longest = izip_longest. [docs]class Qobj(object):; """"""A class for representing quantum objects, such as quantum operators; a",MatchSource.WIKI,docs/4.2/modules/qutip/qobj.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/qobj.html
https://qutip.org/docs/4.2/modules/qutip/qobj.html:43543,Testability,test,test,43543,"p_indices = np.array([s not in states_inds; for s in range(self.shape[0])]).nonzero()[0]. return self.extract_states(keep_indices, normalize=normalize). [docs] def dnorm(self, B=None):; """"""Calculates the diamond norm, or the diamond distance to another; operator. Parameters; ----------; B : Qobj or None; If B is not None, the diamond distance d(A, B) = dnorm(A - B) between; this operator and B is returned instead of the diamond norm. Returns; -------; d : float; Either the diamond norm of this operator, or the diamond distance; from this operator to B. """"""; return mts.dnorm(self, B). @property; def ishp(self):; # FIXME: this needs to be cached in the same ways as isherm.; if self.type in [""super"", ""oper""]:; try:; J = sr.to_choi(self); return J.isherm; except:; return False; else:; return False. @property; def iscp(self):; # FIXME: this needs to be cached in the same ways as isherm.; if self.type in [""super"", ""oper""]:; try:; J = (; self; # We can test with either Choi or chi, since the basis; # transformation between them is unitary and hence; # preserves the CP and TP conditions.; if self.superrep in ('choi', 'chi'); else sr.to_choi(self); ); # If J isn't hermitian, then that could indicate either; # that J is not normal, or is normal, but has complex eigenvalues.; # In either case, it makes no sense to then demand that the; # eigenvalues be non-negative.; if not J.isherm:; return False; eigs = J.eigenenergies(); return all(eigs >= -settings.atol); except:; return False; else:; return False. @property; def istp(self):; import qutip.superop_reps as sr; if self.type in [""super"", ""oper""]:; try:; # Normalize to a super of type choi or chi.; # We can test with either Choi or chi, since the basis; # transformation between them is unitary and hence; # preserves the CP and TP conditions.; if self.type == ""super"" and self.superrep in ('choi', 'chi'):; qobj = self; else:; qobj = sr.to_choi(self). # Possibly collapse dims.; if any([len(index) > 1 for super_index in qobj.dims; ",MatchSource.WIKI,docs/4.2/modules/qutip/qobj.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/qobj.html
https://qutip.org/docs/4.2/modules/qutip/qobj.html:44257,Testability,test,test,44257,"i(self); return J.isherm; except:; return False; else:; return False. @property; def iscp(self):; # FIXME: this needs to be cached in the same ways as isherm.; if self.type in [""super"", ""oper""]:; try:; J = (; self; # We can test with either Choi or chi, since the basis; # transformation between them is unitary and hence; # preserves the CP and TP conditions.; if self.superrep in ('choi', 'chi'); else sr.to_choi(self); ); # If J isn't hermitian, then that could indicate either; # that J is not normal, or is normal, but has complex eigenvalues.; # In either case, it makes no sense to then demand that the; # eigenvalues be non-negative.; if not J.isherm:; return False; eigs = J.eigenenergies(); return all(eigs >= -settings.atol); except:; return False; else:; return False. @property; def istp(self):; import qutip.superop_reps as sr; if self.type in [""super"", ""oper""]:; try:; # Normalize to a super of type choi or chi.; # We can test with either Choi or chi, since the basis; # transformation between them is unitary and hence; # preserves the CP and TP conditions.; if self.type == ""super"" and self.superrep in ('choi', 'chi'):; qobj = self; else:; qobj = sr.to_choi(self). # Possibly collapse dims.; if any([len(index) > 1 for super_index in qobj.dims; for index in super_index]):; qobj = Qobj(qobj, dims=collapse_dims_super(qobj.dims)); else:; qobj = qobj. # We use the condition from John Watrous' lecture notes,; # Tr_1(J(Phi)) = identity_2.; tr_oper = qobj.ptrace([0]); ident = ops.identity(tr_oper.shape[0]); return isequal(tr_oper, ident); except:; return False; else:; return False. @property; def iscptp(self):; from qutip.superop_reps import to_choi; if self.type == ""super"" or self.type == ""oper"":; reps = ('choi', 'chi'); q_oper = to_choi(self) if self.superrep not in reps else self; return q_oper.iscp and q_oper.istp; else:; return False. @property; def isherm(self):. if self._isherm is not None:; # used previously computed value; return self._isherm. self._isherm = bool(zc",MatchSource.WIKI,docs/4.2/modules/qutip/qobj.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/qobj.html
https://qutip.org/docs/4.2/modules/qutip/qobj.html:47781,Testability,test,test,47781,"sinstance(qobj_list, Qobj):; q_sum = qobj_list; elif isinstance(qobj_list, list):; for q in qobj_list:; if isinstance(q, Qobj):; q_sum += q; elif (isinstance(q, list) and len(q) == 2 and; isinstance(q[0], Qobj)):; if isinstance(q[1], types.FunctionType):; q_sum += q[0] * q[1](t, args); elif isinstance(q[1], str):; args['t'] = t; q_sum += q[0] * float(eval(q[1], globals(), args)); else:; raise TypeError('Unrecognized format for ' +; 'specification of time-dependent Qobj'); else:; raise TypeError('Unrecognized format for specification ' +; 'of time-dependent Qobj'); else:; raise TypeError(; 'Unrecongized format for specification of time-dependent Qobj'). return q_sum. # -----------------------------------------------------------------------------; # This functions evaluates a time-dependent quantum object on the list-string; # and list-function formats that are used by the time-dependent solvers.; # Although not used directly in by those solvers, it can for test purposes be; # conventient to be able to evaluate the expressions passed to the solver for; # arbitrary value of time. This function provides this functionality.; #; def qobj_list_evaluate(qobj_list, t, args):; """"""; Depracated: See Qobj.evaluate; """"""; warnings.warn(""Deprecated: Use Qobj.evaluate"", DeprecationWarning); return Qobj.evaluate(qobj_list, t, args). # -----------------------------------------------------------------------------; #; # A collection of tests used to determine the type of quantum objects, and some; # functions for increased compatibility with quantum optics toolbox.; #. def dag(A):; """"""Adjont operator (dagger) of a quantum object. Parameters; ----------; A : qobj; Input quantum object. Returns; -------; oper : qobj; Adjoint of input operator. Notes; -----; This function is for legacy compatibility only. It is recommended to use; the ``dag()`` Qobj method. """"""; if not isinstance(A, Qobj):; raise TypeError(""Input is not a quantum object""). return A.dag(). def ptrace(Q, sel):; """"""Partial tr",MatchSource.WIKI,docs/4.2/modules/qutip/qobj.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/qobj.html
https://qutip.org/docs/4.2/modules/qutip/qobj.html:48250,Testability,test,tests,48250," time-dependent Qobj'); else:; raise TypeError('Unrecognized format for specification ' +; 'of time-dependent Qobj'); else:; raise TypeError(; 'Unrecongized format for specification of time-dependent Qobj'). return q_sum. # -----------------------------------------------------------------------------; # This functions evaluates a time-dependent quantum object on the list-string; # and list-function formats that are used by the time-dependent solvers.; # Although not used directly in by those solvers, it can for test purposes be; # conventient to be able to evaluate the expressions passed to the solver for; # arbitrary value of time. This function provides this functionality.; #; def qobj_list_evaluate(qobj_list, t, args):; """"""; Depracated: See Qobj.evaluate; """"""; warnings.warn(""Deprecated: Use Qobj.evaluate"", DeprecationWarning); return Qobj.evaluate(qobj_list, t, args). # -----------------------------------------------------------------------------; #; # A collection of tests used to determine the type of quantum objects, and some; # functions for increased compatibility with quantum optics toolbox.; #. def dag(A):; """"""Adjont operator (dagger) of a quantum object. Parameters; ----------; A : qobj; Input quantum object. Returns; -------; oper : qobj; Adjoint of input operator. Notes; -----; This function is for legacy compatibility only. It is recommended to use; the ``dag()`` Qobj method. """"""; if not isinstance(A, Qobj):; raise TypeError(""Input is not a quantum object""). return A.dag(). def ptrace(Q, sel):; """"""Partial trace of the Qobj with selected components remaining. Parameters; ----------; Q : qobj; Composite quantum object.; sel : int/list; An ``int`` or ``list`` of components to keep after partial trace. Returns; -------; oper : qobj; Quantum object representing partial trace with selected components; remaining. Notes; -----; This function is for legacy compatibility only. It is recommended to use; the ``ptrace()`` Qobj method. """"""; if not isinstance(Q, Qobj",MatchSource.WIKI,docs/4.2/modules/qutip/qobj.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/qobj.html
https://qutip.org/docs/4.2/modules/qutip/qobj.html:10674,Usability,clear,clear,10674,"(inpt.shape[0])], [int(inpt.shape[1])]]; else:; self.dims = dims. elif isinstance(inpt, (int, float, complex,; np.integer, np.floating, np.complexfloating)):; # if input is int, float, or complex then convert to array; _tmp = sp.csr_matrix([[inpt]], dtype=complex); self._data = fast_csr_matrix((_tmp.data, _tmp.indices, _tmp.indptr),; shape=_tmp.shape); if not np.any(dims):; self.dims = [[1], [1]]; else:; self.dims = dims. else:; warnings.warn(""Initializing Qobj from unsupported type: %s"" %; builtins.type(inpt)); inpt = np.array([[0]]); _tmp = sp.csr_matrix(inpt, dtype=complex, copy=copy); self._data = fast_csr_matrix((_tmp.data, _tmp.indices, _tmp.indptr),; shape = _tmp.shape); self.dims = [[int(inpt.shape[0])], [int(inpt.shape[1])]]. if type == 'super':; if self.type == 'oper':; self.dims = [[[d] for d in self.dims[0]],; [[d] for d in self.dims[1]]]. if superrep:; self.superrep = superrep; else:; if self.type == 'super' and self.superrep is None:; self.superrep = 'super'. # clear type cache; self._type = None. [docs] def copy(self):; """"""Create identical copy""""""; return Qobj(inpt=self). def get_data(self):; return self._data; #Here we perfrom a check of the csr matrix type during setting of Q.data; def set_data(self, data):; if not isinstance(data, fast_csr_matrix):; raise TypeError('Qobj data must be in fast_csr format.'); else:; self._data = data; data = property(get_data, set_data). def __add__(self, other):; """"""; ADDITION with Qobj on LEFT [ ex. Qobj+4 ]; """"""; if isinstance(other, eseries):; return other.__radd__(self). if not isinstance(other, Qobj):; other = Qobj(other). if np.prod(other.shape) == 1 and np.prod(self.shape) != 1:; # case for scalar quantum object; dat = other.data[0, 0]; if dat == 0:; return self. out = Qobj(). if self.type in ['oper', 'super']:; out.data = self.data + dat * fast_identity(; self.shape[0]); else:; out.data = self.data; out.data.data = out.data.data + dat. out.dims = self.dims; ; if settings.auto_tidyup: out.tidyup(); ; if isinst",MatchSource.WIKI,docs/4.2/modules/qutip/qobj.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/qobj.html
https://qutip.org/docs/4.2/modules/qutip/qobj.html:19968,Usability,simpl,simply,19968," def __str__(self):; s = """"; t = self.type; shape = self.shape; if self.type in ['oper', 'super']:; s += (""Quantum object: "" +; ""dims = "" + str(self.dims) +; "", shape = "" + str(shape) +; "", type = "" + t +; "", isherm = "" + str(self.isherm) +; (; "", superrep = {0.superrep}"".format(self); if t == ""super"" and self.superrep != ""super""; else """"; ) + ""\n""); else:; s += (""Quantum object: "" +; ""dims = "" + str(self.dims) +; "", shape = "" + str(shape) +; "", type = "" + t + ""\n""); s += ""Qobj data =\n"". if shape[0] > 10000 or shape[1] > 10000:; # if the system is huge, don't attempt to convert to a; # dense matrix and then to string, because it is pointless; # and is likely going to produce memory errors. Instead print the; # sparse data string representation; s += str(self.data). elif all(np.imag(self.data.data) == 0):; s += str(np.real(self.full())). else:; s += str(self.full()). return s. def __repr__(self):; # give complete information on Qobj without print statement in; # command-line we cant realistically serialize a Qobj into a string,; # so we simply return the informal __str__ representation instead.); return self.__str__(). def __call__(self, other):; """"""; Acts this Qobj on another Qobj either by left-multiplication,; or by vectorization and devectorization, as; appropriate.; """"""; if not isinstance(other, Qobj):; raise TypeError(""Only defined for quantum objects.""). if self.type == ""super"":; if other.type == ""ket"":; other = qutip.states.ket2dm(other). if other.type == ""oper"":; return qutip.superoperator.vector_to_operator(; self * qutip.superoperator.operator_to_vector(other); ); else:; raise TypeError(""Can only act super on oper or ket.""). elif self.type == ""oper"":; if other.type == ""ket"":; return self * other; else:; raise TypeError(""Can only act oper on ket.""). def __getstate__(self):; # defines what happens when Qobj object gets pickled; self.__dict__.update({'qutip_version': __version__[:5]}); return self.__dict__. def __setstate__(self, state):; # defines what happ",MatchSource.WIKI,docs/4.2/modules/qutip/qobj.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/qobj.html
https://qutip.org/docs/4.2/modules/qutip/qobj.html:34362,Usability,simpl,simply,34362,"lse:; raise TypeError('Invalid operand for basis transformation'). # transform data; if inverse:; if self.isket:; data = (S.conj().T) * self.data; elif self.isbra:; data = self.data.dot(S); else:; if sparse:; data = (S.conj().T) * self.data * S; else:; data = (S.conj().T).dot(self.data.dot(S)); else:; if self.isket:; data = S * self.data; elif self.isbra:; data = self.data.dot(S.conj().T); else:; if sparse:; data = S * self.data * (S.conj().T); else:; data = S.dot(self.data.dot(S.conj().T)). out = Qobj(data, dims=self.dims); out._isherm = self._isherm; out.superrep = self.superrep. if settings.auto_tidyup:; return out.tidyup(); else:; return out. [docs] def trunc_neg(self, method=""clip""):; """"""Truncates negative eigenvalues and renormalizes. Returns a new Qobj by removing the negative eigenvalues; of this instance, then renormalizing to obtain a valid density; operator. Parameters; ----------; method : str; Algorithm to use to remove negative eigenvalues. ""clip""; simply discards negative eigenvalues, then renormalizes.; ""sgs"" uses the SGS algorithm (doi:10/bb76) to find the; positive operator that is nearest in the Shatten 2-norm. Returns; -------; oper : qobj; A valid density operator. """"""; if not self.isherm:; raise ValueError(""Must be a Hermitian operator to remove negative ""; ""eigenvalues.""). if method not in ('clip', 'sgs'):; raise ValueError(""Method {} not recognized."".format(method)). eigvals, eigstates = self.eigenstates(); if all([eigval >= 0 for eigval in eigvals]):; # All positive, so just renormalize.; return self.unit(); idx_nonzero = eigvals != 0; eigvals = eigvals[idx_nonzero]; eigstates = eigstates[idx_nonzero]. if method == 'clip':; eigvals[eigvals < 0] = 0; elif method == 'sgs':; eigvals = eigvals[::-1]; eigstates = eigstates[::-1]. acc = 0.0; dim = self.shape[0]; n_eigs = len(eigvals). for idx in reversed(range(n_eigs)):; if eigvals[idx] + acc / (idx + 1) >= 0:; break; else:; acc += eigvals[idx]; eigvals[idx] = 0.0. eigvals[:idx+1] += acc / (idx + 1",MatchSource.WIKI,docs/4.2/modules/qutip/qobj.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/qobj.html
https://qutip.org/docs/4.2/modules/qutip/random_objects.html:10129,Availability,error,error,10129,"te. Parameters; ----------; N : int; Dimension of the state vector to be returned. dims : list of ints, or None; Left-dimensions of the resultant quantum object.; If None, [N] is used. Returns; -------; psi : Qobj; A random state vector drawn from the Haar measure.; """"""; if dims:; _check_ket_dims(dims, N); else:; dims = [[N],[1]]; psi = rand_unitary_haar(N) * basis(N, 0); psi.dims = dims; return psi. [docs]def rand_dm(N, density=0.75, pure=False, dims=None):; """"""Creates a random NxN density matrix. Parameters; ----------; N : int, ndarray, list; If int, then shape of output operator. If list/ndarray then eigenvalues; of generated density matrix.; density : float; Density between [0,1] of output density matrix.; dims : list; Dimensions of quantum object. Used for specifying; tensor structure. Default is dims=[[N],[N]]. Returns; -------; oper : qobj; NxN density matrix quantum operator. Notes; -----; For small density matrices., choosing a low density will result in an error; as no diagonal elements will be generated such that :math:`Tr(\\rho)=1`. """"""; if isinstance(N,(np.ndarray,list)):; if np.abs(np.sum(N)-1.0) > 1e-15:; raise ValueError('Eigenvalues of a density matrix must sum to one.'); H = sp.diags(N,0, dtype=complex, format='csr'); N = len(N); if dims:; _check_dims(dims, N, N); nvals = N**2*density; while H.nnz < 0.95*nvals:; H = rand_jacobi_rotation(H); H.sort_indices(); elif isinstance(N, (int, np.int32, np.int64)):; if dims:; _check_dims(dims, N, N); if pure:; dm_density = sqrt(density); psi = rand_ket(N, dm_density); H = psi * psi.dag(); H.data.sort_indices(); else:; non_zero = 0; tries = 0; while non_zero == 0 and tries < 10:; H = rand_herm(N, density); H = H.dag() * H; non_zero = H.tr(); tries += 1; if tries >= 10:; raise ValueError(; ""Requested density is too low to generate density matrix.""); H = H / H.tr(); H.data.sort_indices(); else:; raise TypeError('Input N must be an integer or array_like.'); if dims:; return Qobj(H, dims=dims); else:; return Qobj",MatchSource.WIKI,docs/4.2/modules/qutip/random_objects.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/random_objects.html
https://qutip.org/docs/4.2/modules/qutip/random_objects.html:19095,Deployability,update,updated,19095," N); num_elems = np.int(np.ceil(N*(N+1)*density)/2); data = np.random.rand(num_elems); row_idx = np.random.choice(N, num_elems); col_idx = np.random.choice(N, num_elems); if kind=='left':; M = sp.coo_matrix((data, (row_idx,col_idx)), dtype=float, shape=(N,N)).tocsc(); else:; M = sp.coo_matrix((data, (row_idx,col_idx)), dtype=float, shape=(N,N)).tocsr(); M = 0.5*(M+M.conj().transpose()); if kind=='left':; num_cols = M.indptr.shape[0]-1; for col in range(num_cols):; col_start = M.indptr[col]; col_end = M.indptr[col+1]; col_sum = np.sum(M.data[col_start:col_end]); M.data[col_start:col_end] /= col_sum; M = M.tocsr(); else:; num_rows = M.indptr.shape[0]-1; for row in range(num_rows):; row_start = M.indptr[row]; row_end = M.indptr[row+1]; row_sum = np.sum(M.data[row_start:row_end]); M.data[row_start:row_end] /= row_sum; if dims:; return Qobj(M, dims=dims, shape=[N, N]); else:; return Qobj(M). def _check_ket_dims(dims, N1):; if (not isinstance(dims, list)) or (not isinstance(dims[0], list)):; raise TypeError(""Left and right Qobj dimensions must be lists of ints. E.g.: [2, 3].""); if np.prod(dims) != N1:; raise ValueError(""Qobj dimensions must match matrix shape.""). def _check_dims(dims, N1, N2):; if len(dims) != 2:; raise Exception(""Qobj dimensions must be list of length 2.""); if (not isinstance(dims[0], list)) or (not isinstance(dims[1], list)):; raise TypeError(; ""Qobj dimension components must be lists. i.e. dims=[[N],[N]]""); if np.prod(dims[0]) != N1 or np.prod(dims[1]) != N2:; raise ValueError(""Qobj dimensions must match matrix shape.""); if len(dims[0]) != len(dims[1]):; raise TypeError(""Qobj dimension components must have same length.""). # TRAILING IMPORTS; # qutip.propagator depends on rand_dm, so we need to put this import last.; from qutip.propagator import propagator.  Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, and A.L. Grimsmo.; Last updated on Jan 17, 2018. . Built with Sphinx using a theme provided by Read the Docs. . ",MatchSource.WIKI,docs/4.2/modules/qutip/random_objects.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/random_objects.html
https://qutip.org/docs/4.2/modules/qutip/random_objects.html:18886,Integrability,depend,depends,18886," N); num_elems = np.int(np.ceil(N*(N+1)*density)/2); data = np.random.rand(num_elems); row_idx = np.random.choice(N, num_elems); col_idx = np.random.choice(N, num_elems); if kind=='left':; M = sp.coo_matrix((data, (row_idx,col_idx)), dtype=float, shape=(N,N)).tocsc(); else:; M = sp.coo_matrix((data, (row_idx,col_idx)), dtype=float, shape=(N,N)).tocsr(); M = 0.5*(M+M.conj().transpose()); if kind=='left':; num_cols = M.indptr.shape[0]-1; for col in range(num_cols):; col_start = M.indptr[col]; col_end = M.indptr[col+1]; col_sum = np.sum(M.data[col_start:col_end]); M.data[col_start:col_end] /= col_sum; M = M.tocsr(); else:; num_rows = M.indptr.shape[0]-1; for row in range(num_rows):; row_start = M.indptr[row]; row_end = M.indptr[row+1]; row_sum = np.sum(M.data[row_start:row_end]); M.data[row_start:row_end] /= row_sum; if dims:; return Qobj(M, dims=dims, shape=[N, N]); else:; return Qobj(M). def _check_ket_dims(dims, N1):; if (not isinstance(dims, list)) or (not isinstance(dims[0], list)):; raise TypeError(""Left and right Qobj dimensions must be lists of ints. E.g.: [2, 3].""); if np.prod(dims) != N1:; raise ValueError(""Qobj dimensions must match matrix shape.""). def _check_dims(dims, N1, N2):; if len(dims) != 2:; raise Exception(""Qobj dimensions must be list of length 2.""); if (not isinstance(dims[0], list)) or (not isinstance(dims[1], list)):; raise TypeError(; ""Qobj dimension components must be lists. i.e. dims=[[N],[N]]""); if np.prod(dims[0]) != N1 or np.prod(dims[1]) != N2:; raise ValueError(""Qobj dimensions must match matrix shape.""); if len(dims[0]) != len(dims[1]):; raise TypeError(""Qobj dimension components must have same length.""). # TRAILING IMPORTS; # qutip.propagator depends on rand_dm, so we need to put this import last.; from qutip.propagator import propagator.  Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, and A.L. Grimsmo.; Last updated on Jan 17, 2018. . Built with Sphinx using a theme provided by Read the Docs. . ",MatchSource.WIKI,docs/4.2/modules/qutip/random_objects.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/random_objects.html
https://qutip.org/docs/4.2/modules/qutip/random_objects.html:15588,Safety,avoid,avoid,15588,"erated.; dims : list; Dimensions of quantum object. Used for specifying; tensor structure. Default is dims=[[[N],[N]], [[N],[N]]]. Returns; -------; rho : Qobj; A superoperator acting on vectorized dim  dim density operators,; sampled from the BCSZ distribution.; """"""; if dims is not None:; # TODO: check!; pass; else:; dims = [[[N],[N]], [[N],[N]]]. if rank is None:; rank = N**2; if rank > N**2:; raise ValueError(""Rank cannot exceed superoperator dimension.""). # We use mainly dense matrices here for speed in low; # dimensions. In the future, it would likely be better to switch off; # between sparse and dense matrices as the dimension grows. # We start with a Ginibre uniform matrix X of the appropriate rank,; # and use it to construct a positive semidefinite matrix X X.; X = randnz((N**2, rank), norm='ginibre'); ; # Precompute X X, as we'll need it in two different places.; XXdag = np.dot(X, X.T.conj()); ; if enforce_tp:; # We do the partial trace over the first index by using dense reshape; # operations, so that we can avoid bouncing to a sparse representation; # and back.; Y = np.einsum('ijik->jk', XXdag.reshape((N, N, N, N))). # Now we have the matrix   Y^{-1/2}, which we can find by doing; # the square root and the inverse separately. As a possible improvement,; # iterative methods exist to find inverse square root matrices directly,; # as this is important in statistics.; Z = np.kron(; np.eye(N),; sqrtm(la.inv(Y)); ). # Finally, we dot everything together and pack it into a Qobj,; # marking the dimensions as that of a type=super (that is,; # with left and right compound indices, each representing; # left and right indices on the underlying Hilbert space).; D = Qobj(np.dot(Z, np.dot(XXdag, Z))); else:; D = N * Qobj(XXdag / np.trace(XXdag)). D.dims = [; # Left dims; [[N], [N]],; # Right dims; [[N], [N]]; ]. # Since [BCSZ08] gives a row-stacking Choi matrix, but QuTiP; # expects a column-stacking Choi matrix, we must permute the indices.; D = D.permute([[1], [0]",MatchSource.WIKI,docs/4.2/modules/qutip/random_objects.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/random_objects.html
https://qutip.org/docs/4.2/modules/qutip/rhs_generate.html:3670,Availability,error,error,3670,"-dependent (TD) function stuff; config.tdfunc = None # Placeholder for TD RHS function.; config.colspmv = None # Placeholder for TD col-spmv function.; config.colexpect = None # Placeholder for TD col_expect function.; config.string = None # Holds string of variables to be passed to solver; config.tdname = None # Name of td .pyx file (used in parallel mc code). [docs]def rhs_generate(H, c_ops, args={}, options=Options(), name=None,; cleanup=True):; """"""; Generates the Cython functions needed for solving the dynamics of a; given system using the mesolve function inside a parfor loop. Parameters; ----------; H : qobj; System Hamiltonian. c_ops : list; ``list`` of collapse operators. args : dict; Arguments for time-dependent Hamiltonian and collapse operator terms. options : Options; Instance of ODE solver options. name: str; Name of generated RHS. cleanup: bool; Whether the generated cython file should be automatically removed or; not. Notes; -----; Using this function with any solver other than the mesolve function; will result in an error. """"""; config.reset(); config.options = options. if name:; config.tdname = name; else:; config.tdname = ""rhs"" + str(os.getpid()) + str(config.cgen_num). Lconst = 0. Ldata = []; Linds = []; Lptrs = []; Lcoeff = []; Lobj = []. # loop over all hamiltonian terms, convert to superoperator form and; # add the data of sparse matrix represenation to. msg = ""Incorrect specification of time-dependence: "". for h_spec in H:; if isinstance(h_spec, Qobj):; h = h_spec. if not isinstance(h, Qobj):; raise TypeError(msg + ""expected Qobj""). if h.isoper:; Lconst += -1j * (spre(h) - spost(h)); elif h.issuper:; Lconst += h; else:; raise TypeError(msg + ""expected operator or superoperator""). elif isinstance(h_spec, list):; h = h_spec[0]; h_coeff = h_spec[1]. if not isinstance(h, Qobj):; raise TypeError(msg + ""expected Qobj""). if h.isoper:; L = -1j * (spre(h) - spost(h)); elif h.issuper:; L = h; else:; raise TypeError(msg + ""expected operator or superoperat",MatchSource.WIKI,docs/4.2/modules/qutip/rhs_generate.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/rhs_generate.html
https://qutip.org/docs/4.2/modules/qutip/rhs_generate.html:8362,Deployability,install,installed,8362,"]; c_str = []; c_obj = []; if isinstance(c_ops, list):; for k in range(len(c_ops)):; if isinstance(c_ops[k], Qobj):; c_const.append(k); elif isinstance(c_ops[k], list):; if len(c_ops[k]) != 2:; raise TypeError(; ""Incorrect collapse operator specification.""); else:; if isinstance(c_ops[k][1], (FunctionType,; BuiltinFunctionType, partial)):; c_func.append(k); elif isinstance(c_ops[k][1], str):; c_str.append(k); elif isinstance(c_ops[k][1], Cubic_Spline):; c_obj.append(k); elif isinstance(c_ops[k][1], np.ndarray):; c_str.append(k); elif isinstance(c_ops[k][1], tuple):; c_str.append(k); else:; raise TypeError(; ""Incorrect collapse operator specification""); else:; raise TypeError(""Incorrect collapse operator specification""). #; # if n_str == 0 and n_func == 0:; # # no time-dependence at all; #; if ((len(h_str) > 0 and len(h_func) > 0) or; (len(c_str) > 0 and len(c_func) > 0)):; raise TypeError(; ""Cannot mix string and function type time-dependence formats""). # check to see if Cython is installed and version is high enough.; if len(h_str) > 0 or len(c_str) > 0:; try:; import Cython; except:; raise Exception(; ""Unable to load Cython. Use Python function format.""); else:; if Cython.__version__ < '0.21':; raise Exception(""Cython version (%s) is too old. Upgrade to "" +; ""version 0.21+"" % Cython.__version__); ; # If only time-dependence is in Objects, then prefer string based format; if (len(h_func) + len(c_func) + len(h_str) + len(c_str)) == 0:; h_str += h_obj #Does nothing if not objects; c_str += c_obj; else:; # Combine Hamiltonian objects; if len(h_func) > 0:; h_func += h_obj; elif len(h_str) > 0:; h_str += h_obj; ; #Combine collapse objects; if len(c_func) > 0:; c_func += c_obj; elif len(c_str) > 0:; c_str += c_obj. if solver == 'me':; return (len(h_const + c_const),; len(h_func) + len(c_func),; len(h_str) + len(c_str)); ; elif solver == 'mc':. # H C_ops #; # -- ----- --; # NO NO 00; # NO STR 01; # NO FUNC 02; #; # STR NO 10; # STR STR 11; #; # FUNC NO 20; #; # FUNC FUNC ",MatchSource.WIKI,docs/4.2/modules/qutip/rhs_generate.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/rhs_generate.html
https://qutip.org/docs/4.2/modules/qutip/rhs_generate.html:11329,Deployability,update,update,11329,"elif len(c_func) > 0:; time_type = 2; else:; raise Exception(""Error determining time-dependence.""). # list style Hamiltonian; elif len(h_str) > 0:; if len(c_func) == len(c_str) == 0:; time_type = 10; elif len(c_str) > 0:; time_type = 11; else:; raise Exception(""Error determining time-dependence.""). # Python function style Hamiltonian; elif len(h_func) > 0:; if len(c_func) == len(c_str) == 0:; time_type = 20; elif len(c_func) > 0:; time_type = 22; else:; raise Exception(""Error determining time-dependence.""). return time_type, [h_const, h_func, h_str], [c_const, c_func, c_str]. def _td_wrap_array_str(H, c_ops, args, times):; """"""; Wrap numpy-array based time-dependence in the string-based time dependence; format; """"""; n = 0; H_new = []; c_ops_new = []; args_new = {}. if not isinstance(H, list):; H_new = H; else:; for Hk in H:; if isinstance(Hk, list) and isinstance(Hk[1], np.ndarray):; H_op, H_td = Hk; td_array_name = ""_td_array_%d"" % n; H_td_str = '(0 if (t > %f) else %s[int(round(%d * (t/%f)))])' %\; (times[-1], td_array_name, len(times) - 1, times[-1]); args_new[td_array_name] = H_td; H_new.append([H_op, H_td_str]); n += 1; else:; H_new.append(Hk). if not isinstance(c_ops, list):; c_ops_new = c_ops; else:; for ck in c_ops:; if isinstance(ck, list) and isinstance(ck[1], np.ndarray):; c_op, c_td = ck; td_array_name = ""_td_array_%d"" % n; c_td_str = '(0 if (t > %f) else %s[int(round(%d * (t/%f)))])' %\; (times[-1], td_array_name, len(times) - 1, times[-1]); args_new[td_array_name] = c_td; c_ops_new.append([c_op, c_td_str]); n += 1; else:; c_ops_new.append(ck). if not args_new:; args_new = args; elif isinstance(args, dict):; args_new.update(args); else:; raise ValueError(""Time-dependent array format requires args to "" +; ""be a dictionary""). return H_new, c_ops_new, args_new.  Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, and A.L. Grimsmo.; Last updated on Jan 17, 2018. . Built with Sphinx using a theme provided by Read the Docs. . ",MatchSource.WIKI,docs/4.2/modules/qutip/rhs_generate.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/rhs_generate.html
https://qutip.org/docs/4.2/modules/qutip/rhs_generate.html:11584,Deployability,update,updated,11584,"elif len(c_func) > 0:; time_type = 2; else:; raise Exception(""Error determining time-dependence.""). # list style Hamiltonian; elif len(h_str) > 0:; if len(c_func) == len(c_str) == 0:; time_type = 10; elif len(c_str) > 0:; time_type = 11; else:; raise Exception(""Error determining time-dependence.""). # Python function style Hamiltonian; elif len(h_func) > 0:; if len(c_func) == len(c_str) == 0:; time_type = 20; elif len(c_func) > 0:; time_type = 22; else:; raise Exception(""Error determining time-dependence.""). return time_type, [h_const, h_func, h_str], [c_const, c_func, c_str]. def _td_wrap_array_str(H, c_ops, args, times):; """"""; Wrap numpy-array based time-dependence in the string-based time dependence; format; """"""; n = 0; H_new = []; c_ops_new = []; args_new = {}. if not isinstance(H, list):; H_new = H; else:; for Hk in H:; if isinstance(Hk, list) and isinstance(Hk[1], np.ndarray):; H_op, H_td = Hk; td_array_name = ""_td_array_%d"" % n; H_td_str = '(0 if (t > %f) else %s[int(round(%d * (t/%f)))])' %\; (times[-1], td_array_name, len(times) - 1, times[-1]); args_new[td_array_name] = H_td; H_new.append([H_op, H_td_str]); n += 1; else:; H_new.append(Hk). if not isinstance(c_ops, list):; c_ops_new = c_ops; else:; for ck in c_ops:; if isinstance(ck, list) and isinstance(ck[1], np.ndarray):; c_op, c_td = ck; td_array_name = ""_td_array_%d"" % n; c_td_str = '(0 if (t > %f) else %s[int(round(%d * (t/%f)))])' %\; (times[-1], td_array_name, len(times) - 1, times[-1]); args_new[td_array_name] = c_td; c_ops_new.append([c_op, c_td_str]); n += 1; else:; c_ops_new.append(ck). if not args_new:; args_new = args; elif isinstance(args, dict):; args_new.update(args); else:; raise ValueError(""Time-dependent array format requires args to "" +; ""be a dictionary""). return H_new, c_ops_new, args_new.  Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, and A.L. Grimsmo.; Last updated on Jan 17, 2018. . Built with Sphinx using a theme provided by Read the Docs. . ",MatchSource.WIKI,docs/4.2/modules/qutip/rhs_generate.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/rhs_generate.html
https://qutip.org/docs/4.2/modules/qutip/rhs_generate.html:2480,Integrability,depend,dependent,2480," THE COPYRIGHT; # HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,; # SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT; # LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,; # DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY; # THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT; # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE; # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.; ###############################################################################. __all__ = ['rhs_generate', 'rhs_clear']. import os; import numpy as np; from types import FunctionType, BuiltinFunctionType; from functools import partial. from qutip.cy.codegen import Codegen; from qutip.solver import Options, config; from qutip.qobj import Qobj; from qutip.superoperator import spre, spost; from qutip.interpolate import Cubic_Spline. [docs]def rhs_clear():; """"""; Resets the string-format time-dependent Hamiltonian parameters. Parameters; ----------. Returns; -------; Nothing, just clears data from internal config module. """"""; # time-dependent (TD) function stuff; config.tdfunc = None # Placeholder for TD RHS function.; config.colspmv = None # Placeholder for TD col-spmv function.; config.colexpect = None # Placeholder for TD col_expect function.; config.string = None # Holds string of variables to be passed to solver; config.tdname = None # Name of td .pyx file (used in parallel mc code). [docs]def rhs_generate(H, c_ops, args={}, options=Options(), name=None,; cleanup=True):; """"""; Generates the Cython functions needed for solving the dynamics of a; given system using the mesolve function inside a parfor loop. Parameters; ----------; H : qobj; System Hamiltonian. c_ops : list; ``list`` of collapse operators. args : dict; Arguments for time-dependent Hamiltonian and collapse operator terms. options : Options; Instance of ODE solver options. name: str; Name of gen",MatchSource.WIKI,docs/4.2/modules/qutip/rhs_generate.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/rhs_generate.html
https://qutip.org/docs/4.2/modules/qutip/rhs_generate.html:2623,Integrability,depend,dependent,2623,"O, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,; # DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY; # THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT; # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE; # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.; ###############################################################################. __all__ = ['rhs_generate', 'rhs_clear']. import os; import numpy as np; from types import FunctionType, BuiltinFunctionType; from functools import partial. from qutip.cy.codegen import Codegen; from qutip.solver import Options, config; from qutip.qobj import Qobj; from qutip.superoperator import spre, spost; from qutip.interpolate import Cubic_Spline. [docs]def rhs_clear():; """"""; Resets the string-format time-dependent Hamiltonian parameters. Parameters; ----------. Returns; -------; Nothing, just clears data from internal config module. """"""; # time-dependent (TD) function stuff; config.tdfunc = None # Placeholder for TD RHS function.; config.colspmv = None # Placeholder for TD col-spmv function.; config.colexpect = None # Placeholder for TD col_expect function.; config.string = None # Holds string of variables to be passed to solver; config.tdname = None # Name of td .pyx file (used in parallel mc code). [docs]def rhs_generate(H, c_ops, args={}, options=Options(), name=None,; cleanup=True):; """"""; Generates the Cython functions needed for solving the dynamics of a; given system using the mesolve function inside a parfor loop. Parameters; ----------; H : qobj; System Hamiltonian. c_ops : list; ``list`` of collapse operators. args : dict; Arguments for time-dependent Hamiltonian and collapse operator terms. options : Options; Instance of ODE solver options. name: str; Name of generated RHS. cleanup: bool; Whether the generated cython file should be automatically removed or; not. Notes; -----; Using this function with any solver other than the me",MatchSource.WIKI,docs/4.2/modules/qutip/rhs_generate.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/rhs_generate.html
https://qutip.org/docs/4.2/modules/qutip/rhs_generate.html:3343,Integrability,depend,dependent,3343,"rator import spre, spost; from qutip.interpolate import Cubic_Spline. [docs]def rhs_clear():; """"""; Resets the string-format time-dependent Hamiltonian parameters. Parameters; ----------. Returns; -------; Nothing, just clears data from internal config module. """"""; # time-dependent (TD) function stuff; config.tdfunc = None # Placeholder for TD RHS function.; config.colspmv = None # Placeholder for TD col-spmv function.; config.colexpect = None # Placeholder for TD col_expect function.; config.string = None # Holds string of variables to be passed to solver; config.tdname = None # Name of td .pyx file (used in parallel mc code). [docs]def rhs_generate(H, c_ops, args={}, options=Options(), name=None,; cleanup=True):; """"""; Generates the Cython functions needed for solving the dynamics of a; given system using the mesolve function inside a parfor loop. Parameters; ----------; H : qobj; System Hamiltonian. c_ops : list; ``list`` of collapse operators. args : dict; Arguments for time-dependent Hamiltonian and collapse operator terms. options : Options; Instance of ODE solver options. name: str; Name of generated RHS. cleanup: bool; Whether the generated cython file should be automatically removed or; not. Notes; -----; Using this function with any solver other than the mesolve function; will result in an error. """"""; config.reset(); config.options = options. if name:; config.tdname = name; else:; config.tdname = ""rhs"" + str(os.getpid()) + str(config.cgen_num). Lconst = 0. Ldata = []; Linds = []; Lptrs = []; Lcoeff = []; Lobj = []. # loop over all hamiltonian terms, convert to superoperator form and; # add the data of sparse matrix represenation to. msg = ""Incorrect specification of time-dependence: "". for h_spec in H:; if isinstance(h_spec, Qobj):; h = h_spec. if not isinstance(h, Qobj):; raise TypeError(msg + ""expected Qobj""). if h.isoper:; Lconst += -1j * (spre(h) - spost(h)); elif h.issuper:; Lconst += h; else:; raise TypeError(msg + ""expected operator or superoperator"").",MatchSource.WIKI,docs/4.2/modules/qutip/rhs_generate.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/rhs_generate.html
https://qutip.org/docs/4.2/modules/qutip/rhs_generate.html:4059,Integrability,depend,dependence,4059," name=None,; cleanup=True):; """"""; Generates the Cython functions needed for solving the dynamics of a; given system using the mesolve function inside a parfor loop. Parameters; ----------; H : qobj; System Hamiltonian. c_ops : list; ``list`` of collapse operators. args : dict; Arguments for time-dependent Hamiltonian and collapse operator terms. options : Options; Instance of ODE solver options. name: str; Name of generated RHS. cleanup: bool; Whether the generated cython file should be automatically removed or; not. Notes; -----; Using this function with any solver other than the mesolve function; will result in an error. """"""; config.reset(); config.options = options. if name:; config.tdname = name; else:; config.tdname = ""rhs"" + str(os.getpid()) + str(config.cgen_num). Lconst = 0. Ldata = []; Linds = []; Lptrs = []; Lcoeff = []; Lobj = []. # loop over all hamiltonian terms, convert to superoperator form and; # add the data of sparse matrix represenation to. msg = ""Incorrect specification of time-dependence: "". for h_spec in H:; if isinstance(h_spec, Qobj):; h = h_spec. if not isinstance(h, Qobj):; raise TypeError(msg + ""expected Qobj""). if h.isoper:; Lconst += -1j * (spre(h) - spost(h)); elif h.issuper:; Lconst += h; else:; raise TypeError(msg + ""expected operator or superoperator""). elif isinstance(h_spec, list):; h = h_spec[0]; h_coeff = h_spec[1]. if not isinstance(h, Qobj):; raise TypeError(msg + ""expected Qobj""). if h.isoper:; L = -1j * (spre(h) - spost(h)); elif h.issuper:; L = h; else:; raise TypeError(msg + ""expected operator or superoperator""). Ldata.append(L.data.data); Linds.append(L.data.indices); Lptrs.append(L.data.indptr); if isinstance(h_coeff, Cubic_Spline):; Lobj.append(h_coeff.coeffs); Lcoeff.append(h_coeff). else:; raise TypeError(msg + ""expected string format""). # loop over all collapse operators; for c_spec in c_ops:; if isinstance(c_spec, Qobj):; c = c_spec. if not isinstance(c, Qobj):; raise TypeError(msg + ""expected Qobj""). if c.isoper:; c",MatchSource.WIKI,docs/4.2/modules/qutip/rhs_generate.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/rhs_generate.html
https://qutip.org/docs/4.2/modules/qutip/rhs_generate.html:6458,Integrability,depend,dependent,6458,"()) - 0.5 * spre(cdc) \; - 0.5 * spost(cdc); c_coeff = ""("" + c_coeff + "")**2""; elif c.issuper:; L = c; else:; raise TypeError(msg + ""expected operator or superoperator""). Ldata.append(L.data.data); Linds.append(L.data.indices); Lptrs.append(L.data.indptr); Lcoeff.append(c_coeff). else:; raise TypeError(msg + ""expected string format""). # add the constant part of the lagrangian; if Lconst != 0:; Ldata.append(Lconst.data.data); Linds.append(Lconst.data.indices); Lptrs.append(Lconst.data.indptr); Lcoeff.append(""1.0""). # the total number of liouvillian terms (hamiltonian terms + collapse; # operators); n_L_terms = len(Ldata). cgen = Codegen(h_terms=n_L_terms, h_tdterms=Lcoeff, args=args,; config=config); cgen.generate(config.tdname + "".pyx""). code = compile('from ' + config.tdname +; ' import cy_td_ode_rhs', '<string>', 'exec'); exec(code, globals()). config.tdfunc = cy_td_ode_rhs. if cleanup:; try:; os.remove(config.tdname + "".pyx""); except:; pass. def _td_format_check(H, c_ops, solver='me'):; """"""; Checks on time-dependent format.; """"""; h_const = []; h_func = []; h_str = []; h_obj = []; # check H for incorrect format; if isinstance(H, Qobj):; pass; elif isinstance(H, (FunctionType, BuiltinFunctionType, partial)):; pass # n_func += 1; elif isinstance(H, list):; for k, H_k in enumerate(H):; if isinstance(H_k, Qobj):; h_const.append(k); elif isinstance(H_k, list):; if len(H_k) != 2 or not isinstance(H_k[0], Qobj):; raise TypeError(""Incorrect hamiltonian specification""); else:; if isinstance(H_k[1], (FunctionType,; BuiltinFunctionType, partial)):; h_func.append(k); elif isinstance(H_k[1], str):; h_str.append(k); elif isinstance(H_k[1], Cubic_Spline):; h_obj.append(k); elif isinstance(H_k[1], np.ndarray):; h_str.append(k); else:; raise TypeError(""Incorrect hamiltonian specification""); else:; raise TypeError(""Incorrect hamiltonian specification""). # the the whole thing again for c_ops; c_const = []; c_func = []; c_str = []; c_obj = []; if isinstance(c_ops, list):; for k in ra",MatchSource.WIKI,docs/4.2/modules/qutip/rhs_generate.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/rhs_generate.html
https://qutip.org/docs/4.2/modules/qutip/rhs_generate.html:8145,Integrability,depend,dependence,8145,"iltonian specification""); else:; raise TypeError(""Incorrect hamiltonian specification""). # the the whole thing again for c_ops; c_const = []; c_func = []; c_str = []; c_obj = []; if isinstance(c_ops, list):; for k in range(len(c_ops)):; if isinstance(c_ops[k], Qobj):; c_const.append(k); elif isinstance(c_ops[k], list):; if len(c_ops[k]) != 2:; raise TypeError(; ""Incorrect collapse operator specification.""); else:; if isinstance(c_ops[k][1], (FunctionType,; BuiltinFunctionType, partial)):; c_func.append(k); elif isinstance(c_ops[k][1], str):; c_str.append(k); elif isinstance(c_ops[k][1], Cubic_Spline):; c_obj.append(k); elif isinstance(c_ops[k][1], np.ndarray):; c_str.append(k); elif isinstance(c_ops[k][1], tuple):; c_str.append(k); else:; raise TypeError(; ""Incorrect collapse operator specification""); else:; raise TypeError(""Incorrect collapse operator specification""). #; # if n_str == 0 and n_func == 0:; # # no time-dependence at all; #; if ((len(h_str) > 0 and len(h_func) > 0) or; (len(c_str) > 0 and len(c_func) > 0)):; raise TypeError(; ""Cannot mix string and function type time-dependence formats""). # check to see if Cython is installed and version is high enough.; if len(h_str) > 0 or len(c_str) > 0:; try:; import Cython; except:; raise Exception(; ""Unable to load Cython. Use Python function format.""); else:; if Cython.__version__ < '0.21':; raise Exception(""Cython version (%s) is too old. Upgrade to "" +; ""version 0.21+"" % Cython.__version__); ; # If only time-dependence is in Objects, then prefer string based format; if (len(h_func) + len(c_func) + len(h_str) + len(c_str)) == 0:; h_str += h_obj #Does nothing if not objects; c_str += c_obj; else:; # Combine Hamiltonian objects; if len(h_func) > 0:; h_func += h_obj; elif len(h_str) > 0:; h_str += h_obj; ; #Combine collapse objects; if len(c_func) > 0:; c_func += c_obj; elif len(c_str) > 0:; c_str += c_obj. if solver == 'me':; return (len(h_const + c_const),; len(h_func) + len(c_func),; len(h_str) + len(c_str)); ;",MatchSource.WIKI,docs/4.2/modules/qutip/rhs_generate.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/rhs_generate.html
https://qutip.org/docs/4.2/modules/qutip/rhs_generate.html:8312,Integrability,depend,dependence,8312,"iltonian specification""); else:; raise TypeError(""Incorrect hamiltonian specification""). # the the whole thing again for c_ops; c_const = []; c_func = []; c_str = []; c_obj = []; if isinstance(c_ops, list):; for k in range(len(c_ops)):; if isinstance(c_ops[k], Qobj):; c_const.append(k); elif isinstance(c_ops[k], list):; if len(c_ops[k]) != 2:; raise TypeError(; ""Incorrect collapse operator specification.""); else:; if isinstance(c_ops[k][1], (FunctionType,; BuiltinFunctionType, partial)):; c_func.append(k); elif isinstance(c_ops[k][1], str):; c_str.append(k); elif isinstance(c_ops[k][1], Cubic_Spline):; c_obj.append(k); elif isinstance(c_ops[k][1], np.ndarray):; c_str.append(k); elif isinstance(c_ops[k][1], tuple):; c_str.append(k); else:; raise TypeError(; ""Incorrect collapse operator specification""); else:; raise TypeError(""Incorrect collapse operator specification""). #; # if n_str == 0 and n_func == 0:; # # no time-dependence at all; #; if ((len(h_str) > 0 and len(h_func) > 0) or; (len(c_str) > 0 and len(c_func) > 0)):; raise TypeError(; ""Cannot mix string and function type time-dependence formats""). # check to see if Cython is installed and version is high enough.; if len(h_str) > 0 or len(c_str) > 0:; try:; import Cython; except:; raise Exception(; ""Unable to load Cython. Use Python function format.""); else:; if Cython.__version__ < '0.21':; raise Exception(""Cython version (%s) is too old. Upgrade to "" +; ""version 0.21+"" % Cython.__version__); ; # If only time-dependence is in Objects, then prefer string based format; if (len(h_func) + len(c_func) + len(h_str) + len(c_str)) == 0:; h_str += h_obj #Does nothing if not objects; c_str += c_obj; else:; # Combine Hamiltonian objects; if len(h_func) > 0:; h_func += h_obj; elif len(h_str) > 0:; h_str += h_obj; ; #Combine collapse objects; if len(c_func) > 0:; c_func += c_obj; elif len(c_str) > 0:; c_str += c_obj. if solver == 'me':; return (len(h_const + c_const),; len(h_func) + len(c_func),; len(h_str) + len(c_str)); ;",MatchSource.WIKI,docs/4.2/modules/qutip/rhs_generate.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/rhs_generate.html
https://qutip.org/docs/4.2/modules/qutip/rhs_generate.html:8703,Integrability,depend,dependence,8703,"r.append(k); elif isinstance(c_ops[k][1], tuple):; c_str.append(k); else:; raise TypeError(; ""Incorrect collapse operator specification""); else:; raise TypeError(""Incorrect collapse operator specification""). #; # if n_str == 0 and n_func == 0:; # # no time-dependence at all; #; if ((len(h_str) > 0 and len(h_func) > 0) or; (len(c_str) > 0 and len(c_func) > 0)):; raise TypeError(; ""Cannot mix string and function type time-dependence formats""). # check to see if Cython is installed and version is high enough.; if len(h_str) > 0 or len(c_str) > 0:; try:; import Cython; except:; raise Exception(; ""Unable to load Cython. Use Python function format.""); else:; if Cython.__version__ < '0.21':; raise Exception(""Cython version (%s) is too old. Upgrade to "" +; ""version 0.21+"" % Cython.__version__); ; # If only time-dependence is in Objects, then prefer string based format; if (len(h_func) + len(c_func) + len(h_str) + len(c_str)) == 0:; h_str += h_obj #Does nothing if not objects; c_str += c_obj; else:; # Combine Hamiltonian objects; if len(h_func) > 0:; h_func += h_obj; elif len(h_str) > 0:; h_str += h_obj; ; #Combine collapse objects; if len(c_func) > 0:; c_func += c_obj; elif len(c_str) > 0:; c_str += c_obj. if solver == 'me':; return (len(h_const + c_const),; len(h_func) + len(c_func),; len(h_str) + len(c_str)); ; elif solver == 'mc':. # H C_ops #; # -- ----- --; # NO NO 00; # NO STR 01; # NO FUNC 02; #; # STR NO 10; # STR STR 11; #; # FUNC NO 20; #; # FUNC FUNC 22. if isinstance(H, FunctionType):; time_type = 3; # Time-indepdent problems; elif ((len(h_func) == len(h_str) == 0) and; (len(c_func) == len(c_str) == 0)):; time_type = 0. # constant Hamiltonian, time-dependent collapse operators; elif len(h_func) == len(h_str) == 0:; if len(c_str) > 0:; time_type = 1; elif len(c_func) > 0:; time_type = 2; else:; raise Exception(""Error determining time-dependence.""). # list style Hamiltonian; elif len(h_str) > 0:; if len(c_func) == len(c_str) == 0:; time_type = 10; elif len(c_str) >",MatchSource.WIKI,docs/4.2/modules/qutip/rhs_generate.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/rhs_generate.html
https://qutip.org/docs/4.2/modules/qutip/rhs_generate.html:9569,Integrability,depend,dependent,9569,"on 0.21+"" % Cython.__version__); ; # If only time-dependence is in Objects, then prefer string based format; if (len(h_func) + len(c_func) + len(h_str) + len(c_str)) == 0:; h_str += h_obj #Does nothing if not objects; c_str += c_obj; else:; # Combine Hamiltonian objects; if len(h_func) > 0:; h_func += h_obj; elif len(h_str) > 0:; h_str += h_obj; ; #Combine collapse objects; if len(c_func) > 0:; c_func += c_obj; elif len(c_str) > 0:; c_str += c_obj. if solver == 'me':; return (len(h_const + c_const),; len(h_func) + len(c_func),; len(h_str) + len(c_str)); ; elif solver == 'mc':. # H C_ops #; # -- ----- --; # NO NO 00; # NO STR 01; # NO FUNC 02; #; # STR NO 10; # STR STR 11; #; # FUNC NO 20; #; # FUNC FUNC 22. if isinstance(H, FunctionType):; time_type = 3; # Time-indepdent problems; elif ((len(h_func) == len(h_str) == 0) and; (len(c_func) == len(c_str) == 0)):; time_type = 0. # constant Hamiltonian, time-dependent collapse operators; elif len(h_func) == len(h_str) == 0:; if len(c_str) > 0:; time_type = 1; elif len(c_func) > 0:; time_type = 2; else:; raise Exception(""Error determining time-dependence.""). # list style Hamiltonian; elif len(h_str) > 0:; if len(c_func) == len(c_str) == 0:; time_type = 10; elif len(c_str) > 0:; time_type = 11; else:; raise Exception(""Error determining time-dependence.""). # Python function style Hamiltonian; elif len(h_func) > 0:; if len(c_func) == len(c_str) == 0:; time_type = 20; elif len(c_func) > 0:; time_type = 22; else:; raise Exception(""Error determining time-dependence.""). return time_type, [h_const, h_func, h_str], [c_const, c_func, c_str]. def _td_wrap_array_str(H, c_ops, args, times):; """"""; Wrap numpy-array based time-dependence in the string-based time dependence; format; """"""; n = 0; H_new = []; c_ops_new = []; args_new = {}. if not isinstance(H, list):; H_new = H; else:; for Hk in H:; if isinstance(Hk, list) and isinstance(Hk[1], np.ndarray):; H_op, H_td = Hk; td_array_name = ""_td_array_%d"" % n; H_td_str = '(0 if (t > %f) else %",MatchSource.WIKI,docs/4.2/modules/qutip/rhs_generate.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/rhs_generate.html
https://qutip.org/docs/4.2/modules/qutip/rhs_generate.html:9757,Integrability,depend,dependence,9757,"on 0.21+"" % Cython.__version__); ; # If only time-dependence is in Objects, then prefer string based format; if (len(h_func) + len(c_func) + len(h_str) + len(c_str)) == 0:; h_str += h_obj #Does nothing if not objects; c_str += c_obj; else:; # Combine Hamiltonian objects; if len(h_func) > 0:; h_func += h_obj; elif len(h_str) > 0:; h_str += h_obj; ; #Combine collapse objects; if len(c_func) > 0:; c_func += c_obj; elif len(c_str) > 0:; c_str += c_obj. if solver == 'me':; return (len(h_const + c_const),; len(h_func) + len(c_func),; len(h_str) + len(c_str)); ; elif solver == 'mc':. # H C_ops #; # -- ----- --; # NO NO 00; # NO STR 01; # NO FUNC 02; #; # STR NO 10; # STR STR 11; #; # FUNC NO 20; #; # FUNC FUNC 22. if isinstance(H, FunctionType):; time_type = 3; # Time-indepdent problems; elif ((len(h_func) == len(h_str) == 0) and; (len(c_func) == len(c_str) == 0)):; time_type = 0. # constant Hamiltonian, time-dependent collapse operators; elif len(h_func) == len(h_str) == 0:; if len(c_str) > 0:; time_type = 1; elif len(c_func) > 0:; time_type = 2; else:; raise Exception(""Error determining time-dependence.""). # list style Hamiltonian; elif len(h_str) > 0:; if len(c_func) == len(c_str) == 0:; time_type = 10; elif len(c_str) > 0:; time_type = 11; else:; raise Exception(""Error determining time-dependence.""). # Python function style Hamiltonian; elif len(h_func) > 0:; if len(c_func) == len(c_str) == 0:; time_type = 20; elif len(c_func) > 0:; time_type = 22; else:; raise Exception(""Error determining time-dependence.""). return time_type, [h_const, h_func, h_str], [c_const, c_func, c_str]. def _td_wrap_array_str(H, c_ops, args, times):; """"""; Wrap numpy-array based time-dependence in the string-based time dependence; format; """"""; n = 0; H_new = []; c_ops_new = []; args_new = {}. if not isinstance(H, list):; H_new = H; else:; for Hk in H:; if isinstance(Hk, list) and isinstance(Hk[1], np.ndarray):; H_op, H_td = Hk; td_array_name = ""_td_array_%d"" % n; H_td_str = '(0 if (t > %f) else %",MatchSource.WIKI,docs/4.2/modules/qutip/rhs_generate.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/rhs_generate.html
https://qutip.org/docs/4.2/modules/qutip/rhs_generate.html:9957,Integrability,depend,dependence,9957,"; c_str += c_obj; else:; # Combine Hamiltonian objects; if len(h_func) > 0:; h_func += h_obj; elif len(h_str) > 0:; h_str += h_obj; ; #Combine collapse objects; if len(c_func) > 0:; c_func += c_obj; elif len(c_str) > 0:; c_str += c_obj. if solver == 'me':; return (len(h_const + c_const),; len(h_func) + len(c_func),; len(h_str) + len(c_str)); ; elif solver == 'mc':. # H C_ops #; # -- ----- --; # NO NO 00; # NO STR 01; # NO FUNC 02; #; # STR NO 10; # STR STR 11; #; # FUNC NO 20; #; # FUNC FUNC 22. if isinstance(H, FunctionType):; time_type = 3; # Time-indepdent problems; elif ((len(h_func) == len(h_str) == 0) and; (len(c_func) == len(c_str) == 0)):; time_type = 0. # constant Hamiltonian, time-dependent collapse operators; elif len(h_func) == len(h_str) == 0:; if len(c_str) > 0:; time_type = 1; elif len(c_func) > 0:; time_type = 2; else:; raise Exception(""Error determining time-dependence.""). # list style Hamiltonian; elif len(h_str) > 0:; if len(c_func) == len(c_str) == 0:; time_type = 10; elif len(c_str) > 0:; time_type = 11; else:; raise Exception(""Error determining time-dependence.""). # Python function style Hamiltonian; elif len(h_func) > 0:; if len(c_func) == len(c_str) == 0:; time_type = 20; elif len(c_func) > 0:; time_type = 22; else:; raise Exception(""Error determining time-dependence.""). return time_type, [h_const, h_func, h_str], [c_const, c_func, c_str]. def _td_wrap_array_str(H, c_ops, args, times):; """"""; Wrap numpy-array based time-dependence in the string-based time dependence; format; """"""; n = 0; H_new = []; c_ops_new = []; args_new = {}. if not isinstance(H, list):; H_new = H; else:; for Hk in H:; if isinstance(Hk, list) and isinstance(Hk[1], np.ndarray):; H_op, H_td = Hk; td_array_name = ""_td_array_%d"" % n; H_td_str = '(0 if (t > %f) else %s[int(round(%d * (t/%f)))])' %\; (times[-1], td_array_name, len(times) - 1, times[-1]); args_new[td_array_name] = H_td; H_new.append([H_op, H_td_str]); n += 1; else:; H_new.append(Hk). if not isinstance(c_ops, list):",MatchSource.WIKI,docs/4.2/modules/qutip/rhs_generate.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/rhs_generate.html
https://qutip.org/docs/4.2/modules/qutip/rhs_generate.html:10170,Integrability,depend,dependence,10170,"(c_str) > 0:; c_str += c_obj. if solver == 'me':; return (len(h_const + c_const),; len(h_func) + len(c_func),; len(h_str) + len(c_str)); ; elif solver == 'mc':. # H C_ops #; # -- ----- --; # NO NO 00; # NO STR 01; # NO FUNC 02; #; # STR NO 10; # STR STR 11; #; # FUNC NO 20; #; # FUNC FUNC 22. if isinstance(H, FunctionType):; time_type = 3; # Time-indepdent problems; elif ((len(h_func) == len(h_str) == 0) and; (len(c_func) == len(c_str) == 0)):; time_type = 0. # constant Hamiltonian, time-dependent collapse operators; elif len(h_func) == len(h_str) == 0:; if len(c_str) > 0:; time_type = 1; elif len(c_func) > 0:; time_type = 2; else:; raise Exception(""Error determining time-dependence.""). # list style Hamiltonian; elif len(h_str) > 0:; if len(c_func) == len(c_str) == 0:; time_type = 10; elif len(c_str) > 0:; time_type = 11; else:; raise Exception(""Error determining time-dependence.""). # Python function style Hamiltonian; elif len(h_func) > 0:; if len(c_func) == len(c_str) == 0:; time_type = 20; elif len(c_func) > 0:; time_type = 22; else:; raise Exception(""Error determining time-dependence.""). return time_type, [h_const, h_func, h_str], [c_const, c_func, c_str]. def _td_wrap_array_str(H, c_ops, args, times):; """"""; Wrap numpy-array based time-dependence in the string-based time dependence; format; """"""; n = 0; H_new = []; c_ops_new = []; args_new = {}. if not isinstance(H, list):; H_new = H; else:; for Hk in H:; if isinstance(Hk, list) and isinstance(Hk[1], np.ndarray):; H_op, H_td = Hk; td_array_name = ""_td_array_%d"" % n; H_td_str = '(0 if (t > %f) else %s[int(round(%d * (t/%f)))])' %\; (times[-1], td_array_name, len(times) - 1, times[-1]); args_new[td_array_name] = H_td; H_new.append([H_op, H_td_str]); n += 1; else:; H_new.append(Hk). if not isinstance(c_ops, list):; c_ops_new = c_ops; else:; for ck in c_ops:; if isinstance(ck, list) and isinstance(ck[1], np.ndarray):; c_op, c_td = ck; td_array_name = ""_td_array_%d"" % n; c_td_str = '(0 if (t > %f) else %s[int(round(%d",MatchSource.WIKI,docs/4.2/modules/qutip/rhs_generate.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/rhs_generate.html
https://qutip.org/docs/4.2/modules/qutip/rhs_generate.html:10336,Integrability,depend,dependence,10336," #; # FUNC FUNC 22. if isinstance(H, FunctionType):; time_type = 3; # Time-indepdent problems; elif ((len(h_func) == len(h_str) == 0) and; (len(c_func) == len(c_str) == 0)):; time_type = 0. # constant Hamiltonian, time-dependent collapse operators; elif len(h_func) == len(h_str) == 0:; if len(c_str) > 0:; time_type = 1; elif len(c_func) > 0:; time_type = 2; else:; raise Exception(""Error determining time-dependence.""). # list style Hamiltonian; elif len(h_str) > 0:; if len(c_func) == len(c_str) == 0:; time_type = 10; elif len(c_str) > 0:; time_type = 11; else:; raise Exception(""Error determining time-dependence.""). # Python function style Hamiltonian; elif len(h_func) > 0:; if len(c_func) == len(c_str) == 0:; time_type = 20; elif len(c_func) > 0:; time_type = 22; else:; raise Exception(""Error determining time-dependence.""). return time_type, [h_const, h_func, h_str], [c_const, c_func, c_str]. def _td_wrap_array_str(H, c_ops, args, times):; """"""; Wrap numpy-array based time-dependence in the string-based time dependence; format; """"""; n = 0; H_new = []; c_ops_new = []; args_new = {}. if not isinstance(H, list):; H_new = H; else:; for Hk in H:; if isinstance(Hk, list) and isinstance(Hk[1], np.ndarray):; H_op, H_td = Hk; td_array_name = ""_td_array_%d"" % n; H_td_str = '(0 if (t > %f) else %s[int(round(%d * (t/%f)))])' %\; (times[-1], td_array_name, len(times) - 1, times[-1]); args_new[td_array_name] = H_td; H_new.append([H_op, H_td_str]); n += 1; else:; H_new.append(Hk). if not isinstance(c_ops, list):; c_ops_new = c_ops; else:; for ck in c_ops:; if isinstance(ck, list) and isinstance(ck[1], np.ndarray):; c_op, c_td = ck; td_array_name = ""_td_array_%d"" % n; c_td_str = '(0 if (t > %f) else %s[int(round(%d * (t/%f)))])' %\; (times[-1], td_array_name, len(times) - 1, times[-1]); args_new[td_array_name] = c_td; c_ops_new.append([c_op, c_td_str]); n += 1; else:; c_ops_new.append(ck). if not args_new:; args_new = args; elif isinstance(args, dict):; args_new.update(args); else:; ",MatchSource.WIKI,docs/4.2/modules/qutip/rhs_generate.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/rhs_generate.html
https://qutip.org/docs/4.2/modules/qutip/rhs_generate.html:10372,Integrability,depend,dependence,10372," #; # FUNC FUNC 22. if isinstance(H, FunctionType):; time_type = 3; # Time-indepdent problems; elif ((len(h_func) == len(h_str) == 0) and; (len(c_func) == len(c_str) == 0)):; time_type = 0. # constant Hamiltonian, time-dependent collapse operators; elif len(h_func) == len(h_str) == 0:; if len(c_str) > 0:; time_type = 1; elif len(c_func) > 0:; time_type = 2; else:; raise Exception(""Error determining time-dependence.""). # list style Hamiltonian; elif len(h_str) > 0:; if len(c_func) == len(c_str) == 0:; time_type = 10; elif len(c_str) > 0:; time_type = 11; else:; raise Exception(""Error determining time-dependence.""). # Python function style Hamiltonian; elif len(h_func) > 0:; if len(c_func) == len(c_str) == 0:; time_type = 20; elif len(c_func) > 0:; time_type = 22; else:; raise Exception(""Error determining time-dependence.""). return time_type, [h_const, h_func, h_str], [c_const, c_func, c_str]. def _td_wrap_array_str(H, c_ops, args, times):; """"""; Wrap numpy-array based time-dependence in the string-based time dependence; format; """"""; n = 0; H_new = []; c_ops_new = []; args_new = {}. if not isinstance(H, list):; H_new = H; else:; for Hk in H:; if isinstance(Hk, list) and isinstance(Hk[1], np.ndarray):; H_op, H_td = Hk; td_array_name = ""_td_array_%d"" % n; H_td_str = '(0 if (t > %f) else %s[int(round(%d * (t/%f)))])' %\; (times[-1], td_array_name, len(times) - 1, times[-1]); args_new[td_array_name] = H_td; H_new.append([H_op, H_td_str]); n += 1; else:; H_new.append(Hk). if not isinstance(c_ops, list):; c_ops_new = c_ops; else:; for ck in c_ops:; if isinstance(ck, list) and isinstance(ck[1], np.ndarray):; c_op, c_td = ck; td_array_name = ""_td_array_%d"" % n; c_td_str = '(0 if (t > %f) else %s[int(round(%d * (t/%f)))])' %\; (times[-1], td_array_name, len(times) - 1, times[-1]); args_new[td_array_name] = c_td; c_ops_new.append([c_op, c_td_str]); n += 1; else:; c_ops_new.append(ck). if not args_new:; args_new = args; elif isinstance(args, dict):; args_new.update(args); else:; ",MatchSource.WIKI,docs/4.2/modules/qutip/rhs_generate.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/rhs_generate.html
https://qutip.org/docs/4.2/modules/qutip/rhs_generate.html:11373,Integrability,depend,dependent,11373,"elif len(c_func) > 0:; time_type = 2; else:; raise Exception(""Error determining time-dependence.""). # list style Hamiltonian; elif len(h_str) > 0:; if len(c_func) == len(c_str) == 0:; time_type = 10; elif len(c_str) > 0:; time_type = 11; else:; raise Exception(""Error determining time-dependence.""). # Python function style Hamiltonian; elif len(h_func) > 0:; if len(c_func) == len(c_str) == 0:; time_type = 20; elif len(c_func) > 0:; time_type = 22; else:; raise Exception(""Error determining time-dependence.""). return time_type, [h_const, h_func, h_str], [c_const, c_func, c_str]. def _td_wrap_array_str(H, c_ops, args, times):; """"""; Wrap numpy-array based time-dependence in the string-based time dependence; format; """"""; n = 0; H_new = []; c_ops_new = []; args_new = {}. if not isinstance(H, list):; H_new = H; else:; for Hk in H:; if isinstance(Hk, list) and isinstance(Hk[1], np.ndarray):; H_op, H_td = Hk; td_array_name = ""_td_array_%d"" % n; H_td_str = '(0 if (t > %f) else %s[int(round(%d * (t/%f)))])' %\; (times[-1], td_array_name, len(times) - 1, times[-1]); args_new[td_array_name] = H_td; H_new.append([H_op, H_td_str]); n += 1; else:; H_new.append(Hk). if not isinstance(c_ops, list):; c_ops_new = c_ops; else:; for ck in c_ops:; if isinstance(ck, list) and isinstance(ck[1], np.ndarray):; c_op, c_td = ck; td_array_name = ""_td_array_%d"" % n; c_td_str = '(0 if (t > %f) else %s[int(round(%d * (t/%f)))])' %\; (times[-1], td_array_name, len(times) - 1, times[-1]); args_new[td_array_name] = c_td; c_ops_new.append([c_op, c_td_str]); n += 1; else:; c_ops_new.append(ck). if not args_new:; args_new = args; elif isinstance(args, dict):; args_new.update(args); else:; raise ValueError(""Time-dependent array format requires args to "" +; ""be a dictionary""). return H_new, c_ops_new, args_new.  Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, and A.L. Grimsmo.; Last updated on Jan 17, 2018. . Built with Sphinx using a theme provided by Read the Docs. . ",MatchSource.WIKI,docs/4.2/modules/qutip/rhs_generate.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/rhs_generate.html
https://qutip.org/docs/4.2/modules/qutip/rhs_generate.html:2295,Modifiability,config,config,2295," OR IMPLIED WARRANTIES, INCLUDING, BUT NOT; # LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A; # PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT; # HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,; # SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT; # LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,; # DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY; # THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT; # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE; # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.; ###############################################################################. __all__ = ['rhs_generate', 'rhs_clear']. import os; import numpy as np; from types import FunctionType, BuiltinFunctionType; from functools import partial. from qutip.cy.codegen import Codegen; from qutip.solver import Options, config; from qutip.qobj import Qobj; from qutip.superoperator import spre, spost; from qutip.interpolate import Cubic_Spline. [docs]def rhs_clear():; """"""; Resets the string-format time-dependent Hamiltonian parameters. Parameters; ----------. Returns; -------; Nothing, just clears data from internal config module. """"""; # time-dependent (TD) function stuff; config.tdfunc = None # Placeholder for TD RHS function.; config.colspmv = None # Placeholder for TD col-spmv function.; config.colexpect = None # Placeholder for TD col_expect function.; config.string = None # Holds string of variables to be passed to solver; config.tdname = None # Name of td .pyx file (used in parallel mc code). [docs]def rhs_generate(H, c_ops, args={}, options=Options(), name=None,; cleanup=True):; """"""; Generates the Cython functions needed for solving the dynamics of a; given system using the mesolve function inside a parfor loop. Parameters; ----------; H : qobj; System Hamiltonian. c_ops : list; ``list`` of co",MatchSource.WIKI,docs/4.2/modules/qutip/rhs_generate.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/rhs_generate.html
https://qutip.org/docs/4.2/modules/qutip/rhs_generate.html:2596,Modifiability,config,config,2596,"ARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT; # LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,; # DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY; # THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT; # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE; # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.; ###############################################################################. __all__ = ['rhs_generate', 'rhs_clear']. import os; import numpy as np; from types import FunctionType, BuiltinFunctionType; from functools import partial. from qutip.cy.codegen import Codegen; from qutip.solver import Options, config; from qutip.qobj import Qobj; from qutip.superoperator import spre, spost; from qutip.interpolate import Cubic_Spline. [docs]def rhs_clear():; """"""; Resets the string-format time-dependent Hamiltonian parameters. Parameters; ----------. Returns; -------; Nothing, just clears data from internal config module. """"""; # time-dependent (TD) function stuff; config.tdfunc = None # Placeholder for TD RHS function.; config.colspmv = None # Placeholder for TD col-spmv function.; config.colexpect = None # Placeholder for TD col_expect function.; config.string = None # Holds string of variables to be passed to solver; config.tdname = None # Name of td .pyx file (used in parallel mc code). [docs]def rhs_generate(H, c_ops, args={}, options=Options(), name=None,; cleanup=True):; """"""; Generates the Cython functions needed for solving the dynamics of a; given system using the mesolve function inside a parfor loop. Parameters; ----------; H : qobj; System Hamiltonian. c_ops : list; ``list`` of collapse operators. args : dict; Arguments for time-dependent Hamiltonian and collapse operator terms. options : Options; Instance of ODE solver options. name: str; Name of generated RHS. cleanup: bool; Whether the generated cython file should be automatically removed or; not. Notes",MatchSource.WIKI,docs/4.2/modules/qutip/rhs_generate.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/rhs_generate.html
https://qutip.org/docs/4.2/modules/qutip/rhs_generate.html:2654,Modifiability,config,config,2654,"O, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,; # DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY; # THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT; # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE; # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.; ###############################################################################. __all__ = ['rhs_generate', 'rhs_clear']. import os; import numpy as np; from types import FunctionType, BuiltinFunctionType; from functools import partial. from qutip.cy.codegen import Codegen; from qutip.solver import Options, config; from qutip.qobj import Qobj; from qutip.superoperator import spre, spost; from qutip.interpolate import Cubic_Spline. [docs]def rhs_clear():; """"""; Resets the string-format time-dependent Hamiltonian parameters. Parameters; ----------. Returns; -------; Nothing, just clears data from internal config module. """"""; # time-dependent (TD) function stuff; config.tdfunc = None # Placeholder for TD RHS function.; config.colspmv = None # Placeholder for TD col-spmv function.; config.colexpect = None # Placeholder for TD col_expect function.; config.string = None # Holds string of variables to be passed to solver; config.tdname = None # Name of td .pyx file (used in parallel mc code). [docs]def rhs_generate(H, c_ops, args={}, options=Options(), name=None,; cleanup=True):; """"""; Generates the Cython functions needed for solving the dynamics of a; given system using the mesolve function inside a parfor loop. Parameters; ----------; H : qobj; System Hamiltonian. c_ops : list; ``list`` of collapse operators. args : dict; Arguments for time-dependent Hamiltonian and collapse operator terms. options : Options; Instance of ODE solver options. name: str; Name of generated RHS. cleanup: bool; Whether the generated cython file should be automatically removed or; not. Notes; -----; Using this function with any solver other than the me",MatchSource.WIKI,docs/4.2/modules/qutip/rhs_generate.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/rhs_generate.html
https://qutip.org/docs/4.2/modules/qutip/rhs_generate.html:2711,Modifiability,config,config,2711,"TS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY; # THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT; # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE; # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.; ###############################################################################. __all__ = ['rhs_generate', 'rhs_clear']. import os; import numpy as np; from types import FunctionType, BuiltinFunctionType; from functools import partial. from qutip.cy.codegen import Codegen; from qutip.solver import Options, config; from qutip.qobj import Qobj; from qutip.superoperator import spre, spost; from qutip.interpolate import Cubic_Spline. [docs]def rhs_clear():; """"""; Resets the string-format time-dependent Hamiltonian parameters. Parameters; ----------. Returns; -------; Nothing, just clears data from internal config module. """"""; # time-dependent (TD) function stuff; config.tdfunc = None # Placeholder for TD RHS function.; config.colspmv = None # Placeholder for TD col-spmv function.; config.colexpect = None # Placeholder for TD col_expect function.; config.string = None # Holds string of variables to be passed to solver; config.tdname = None # Name of td .pyx file (used in parallel mc code). [docs]def rhs_generate(H, c_ops, args={}, options=Options(), name=None,; cleanup=True):; """"""; Generates the Cython functions needed for solving the dynamics of a; given system using the mesolve function inside a parfor loop. Parameters; ----------; H : qobj; System Hamiltonian. c_ops : list; ``list`` of collapse operators. args : dict; Arguments for time-dependent Hamiltonian and collapse operator terms. options : Options; Instance of ODE solver options. name: str; Name of generated RHS. cleanup: bool; Whether the generated cython file should be automatically removed or; not. Notes; -----; Using this function with any solver other than the mesolve function; will result in an error. """"""; config.reset(); config.options =",MatchSource.WIKI,docs/4.2/modules/qutip/rhs_generate.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/rhs_generate.html
https://qutip.org/docs/4.2/modules/qutip/rhs_generate.html:2774,Modifiability,config,config,2774,"RY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT; # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE; # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.; ###############################################################################. __all__ = ['rhs_generate', 'rhs_clear']. import os; import numpy as np; from types import FunctionType, BuiltinFunctionType; from functools import partial. from qutip.cy.codegen import Codegen; from qutip.solver import Options, config; from qutip.qobj import Qobj; from qutip.superoperator import spre, spost; from qutip.interpolate import Cubic_Spline. [docs]def rhs_clear():; """"""; Resets the string-format time-dependent Hamiltonian parameters. Parameters; ----------. Returns; -------; Nothing, just clears data from internal config module. """"""; # time-dependent (TD) function stuff; config.tdfunc = None # Placeholder for TD RHS function.; config.colspmv = None # Placeholder for TD col-spmv function.; config.colexpect = None # Placeholder for TD col_expect function.; config.string = None # Holds string of variables to be passed to solver; config.tdname = None # Name of td .pyx file (used in parallel mc code). [docs]def rhs_generate(H, c_ops, args={}, options=Options(), name=None,; cleanup=True):; """"""; Generates the Cython functions needed for solving the dynamics of a; given system using the mesolve function inside a parfor loop. Parameters; ----------; H : qobj; System Hamiltonian. c_ops : list; ``list`` of collapse operators. args : dict; Arguments for time-dependent Hamiltonian and collapse operator terms. options : Options; Instance of ODE solver options. name: str; Name of generated RHS. cleanup: bool; Whether the generated cython file should be automatically removed or; not. Notes; -----; Using this function with any solver other than the mesolve function; will result in an error. """"""; config.reset(); config.options = options. if name:; config.tdname = name; else:; config.tdname ",MatchSource.WIKI,docs/4.2/modules/qutip/rhs_generate.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/rhs_generate.html
https://qutip.org/docs/4.2/modules/qutip/rhs_generate.html:2841,Modifiability,config,config,2841,"(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE; # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.; ###############################################################################. __all__ = ['rhs_generate', 'rhs_clear']. import os; import numpy as np; from types import FunctionType, BuiltinFunctionType; from functools import partial. from qutip.cy.codegen import Codegen; from qutip.solver import Options, config; from qutip.qobj import Qobj; from qutip.superoperator import spre, spost; from qutip.interpolate import Cubic_Spline. [docs]def rhs_clear():; """"""; Resets the string-format time-dependent Hamiltonian parameters. Parameters; ----------. Returns; -------; Nothing, just clears data from internal config module. """"""; # time-dependent (TD) function stuff; config.tdfunc = None # Placeholder for TD RHS function.; config.colspmv = None # Placeholder for TD col-spmv function.; config.colexpect = None # Placeholder for TD col_expect function.; config.string = None # Holds string of variables to be passed to solver; config.tdname = None # Name of td .pyx file (used in parallel mc code). [docs]def rhs_generate(H, c_ops, args={}, options=Options(), name=None,; cleanup=True):; """"""; Generates the Cython functions needed for solving the dynamics of a; given system using the mesolve function inside a parfor loop. Parameters; ----------; H : qobj; System Hamiltonian. c_ops : list; ``list`` of collapse operators. args : dict; Arguments for time-dependent Hamiltonian and collapse operator terms. options : Options; Instance of ODE solver options. name: str; Name of generated RHS. cleanup: bool; Whether the generated cython file should be automatically removed or; not. Notes; -----; Using this function with any solver other than the mesolve function; will result in an error. """"""; config.reset(); config.options = options. if name:; config.tdname = name; else:; config.tdname = ""rhs"" + str(os.getpid()) + str(config.cgen_num). Lconst = 0. Ldat",MatchSource.WIKI,docs/4.2/modules/qutip/rhs_generate.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/rhs_generate.html
https://qutip.org/docs/4.2/modules/qutip/rhs_generate.html:2880,Modifiability,variab,variables,2880,"NG IN ANY WAY OUT OF THE USE; # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.; ###############################################################################. __all__ = ['rhs_generate', 'rhs_clear']. import os; import numpy as np; from types import FunctionType, BuiltinFunctionType; from functools import partial. from qutip.cy.codegen import Codegen; from qutip.solver import Options, config; from qutip.qobj import Qobj; from qutip.superoperator import spre, spost; from qutip.interpolate import Cubic_Spline. [docs]def rhs_clear():; """"""; Resets the string-format time-dependent Hamiltonian parameters. Parameters; ----------. Returns; -------; Nothing, just clears data from internal config module. """"""; # time-dependent (TD) function stuff; config.tdfunc = None # Placeholder for TD RHS function.; config.colspmv = None # Placeholder for TD col-spmv function.; config.colexpect = None # Placeholder for TD col_expect function.; config.string = None # Holds string of variables to be passed to solver; config.tdname = None # Name of td .pyx file (used in parallel mc code). [docs]def rhs_generate(H, c_ops, args={}, options=Options(), name=None,; cleanup=True):; """"""; Generates the Cython functions needed for solving the dynamics of a; given system using the mesolve function inside a parfor loop. Parameters; ----------; H : qobj; System Hamiltonian. c_ops : list; ``list`` of collapse operators. args : dict; Arguments for time-dependent Hamiltonian and collapse operator terms. options : Options; Instance of ODE solver options. name: str; Name of generated RHS. cleanup: bool; Whether the generated cython file should be automatically removed or; not. Notes; -----; Using this function with any solver other than the mesolve function; will result in an error. """"""; config.reset(); config.options = options. if name:; config.tdname = name; else:; config.tdname = ""rhs"" + str(os.getpid()) + str(config.cgen_num). Lconst = 0. Ldata = []; Linds = []; Lptrs = []; Lcoeff = ",MatchSource.WIKI,docs/4.2/modules/qutip/rhs_generate.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/rhs_generate.html
https://qutip.org/docs/4.2/modules/qutip/rhs_generate.html:2914,Modifiability,config,config,2914,"NG IN ANY WAY OUT OF THE USE; # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.; ###############################################################################. __all__ = ['rhs_generate', 'rhs_clear']. import os; import numpy as np; from types import FunctionType, BuiltinFunctionType; from functools import partial. from qutip.cy.codegen import Codegen; from qutip.solver import Options, config; from qutip.qobj import Qobj; from qutip.superoperator import spre, spost; from qutip.interpolate import Cubic_Spline. [docs]def rhs_clear():; """"""; Resets the string-format time-dependent Hamiltonian parameters. Parameters; ----------. Returns; -------; Nothing, just clears data from internal config module. """"""; # time-dependent (TD) function stuff; config.tdfunc = None # Placeholder for TD RHS function.; config.colspmv = None # Placeholder for TD col-spmv function.; config.colexpect = None # Placeholder for TD col_expect function.; config.string = None # Holds string of variables to be passed to solver; config.tdname = None # Name of td .pyx file (used in parallel mc code). [docs]def rhs_generate(H, c_ops, args={}, options=Options(), name=None,; cleanup=True):; """"""; Generates the Cython functions needed for solving the dynamics of a; given system using the mesolve function inside a parfor loop. Parameters; ----------; H : qobj; System Hamiltonian. c_ops : list; ``list`` of collapse operators. args : dict; Arguments for time-dependent Hamiltonian and collapse operator terms. options : Options; Instance of ODE solver options. name: str; Name of generated RHS. cleanup: bool; Whether the generated cython file should be automatically removed or; not. Notes; -----; Using this function with any solver other than the mesolve function; will result in an error. """"""; config.reset(); config.options = options. if name:; config.tdname = name; else:; config.tdname = ""rhs"" + str(os.getpid()) + str(config.cgen_num). Lconst = 0. Ldata = []; Linds = []; Lptrs = []; Lcoeff = ",MatchSource.WIKI,docs/4.2/modules/qutip/rhs_generate.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/rhs_generate.html
https://qutip.org/docs/4.2/modules/qutip/rhs_generate.html:3682,Modifiability,config,config,3682,"holder for TD RHS function.; config.colspmv = None # Placeholder for TD col-spmv function.; config.colexpect = None # Placeholder for TD col_expect function.; config.string = None # Holds string of variables to be passed to solver; config.tdname = None # Name of td .pyx file (used in parallel mc code). [docs]def rhs_generate(H, c_ops, args={}, options=Options(), name=None,; cleanup=True):; """"""; Generates the Cython functions needed for solving the dynamics of a; given system using the mesolve function inside a parfor loop. Parameters; ----------; H : qobj; System Hamiltonian. c_ops : list; ``list`` of collapse operators. args : dict; Arguments for time-dependent Hamiltonian and collapse operator terms. options : Options; Instance of ODE solver options. name: str; Name of generated RHS. cleanup: bool; Whether the generated cython file should be automatically removed or; not. Notes; -----; Using this function with any solver other than the mesolve function; will result in an error. """"""; config.reset(); config.options = options. if name:; config.tdname = name; else:; config.tdname = ""rhs"" + str(os.getpid()) + str(config.cgen_num). Lconst = 0. Ldata = []; Linds = []; Lptrs = []; Lcoeff = []; Lobj = []. # loop over all hamiltonian terms, convert to superoperator form and; # add the data of sparse matrix represenation to. msg = ""Incorrect specification of time-dependence: "". for h_spec in H:; if isinstance(h_spec, Qobj):; h = h_spec. if not isinstance(h, Qobj):; raise TypeError(msg + ""expected Qobj""). if h.isoper:; Lconst += -1j * (spre(h) - spost(h)); elif h.issuper:; Lconst += h; else:; raise TypeError(msg + ""expected operator or superoperator""). elif isinstance(h_spec, list):; h = h_spec[0]; h_coeff = h_spec[1]. if not isinstance(h, Qobj):; raise TypeError(msg + ""expected Qobj""). if h.isoper:; L = -1j * (spre(h) - spost(h)); elif h.issuper:; L = h; else:; raise TypeError(msg + ""expected operator or superoperator""). Ldata.append(L.data.data); Linds.append(L.data.indices)",MatchSource.WIKI,docs/4.2/modules/qutip/rhs_generate.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/rhs_generate.html
https://qutip.org/docs/4.2/modules/qutip/rhs_generate.html:3698,Modifiability,config,config,3698,"HS function.; config.colspmv = None # Placeholder for TD col-spmv function.; config.colexpect = None # Placeholder for TD col_expect function.; config.string = None # Holds string of variables to be passed to solver; config.tdname = None # Name of td .pyx file (used in parallel mc code). [docs]def rhs_generate(H, c_ops, args={}, options=Options(), name=None,; cleanup=True):; """"""; Generates the Cython functions needed for solving the dynamics of a; given system using the mesolve function inside a parfor loop. Parameters; ----------; H : qobj; System Hamiltonian. c_ops : list; ``list`` of collapse operators. args : dict; Arguments for time-dependent Hamiltonian and collapse operator terms. options : Options; Instance of ODE solver options. name: str; Name of generated RHS. cleanup: bool; Whether the generated cython file should be automatically removed or; not. Notes; -----; Using this function with any solver other than the mesolve function; will result in an error. """"""; config.reset(); config.options = options. if name:; config.tdname = name; else:; config.tdname = ""rhs"" + str(os.getpid()) + str(config.cgen_num). Lconst = 0. Ldata = []; Linds = []; Lptrs = []; Lcoeff = []; Lobj = []. # loop over all hamiltonian terms, convert to superoperator form and; # add the data of sparse matrix represenation to. msg = ""Incorrect specification of time-dependence: "". for h_spec in H:; if isinstance(h_spec, Qobj):; h = h_spec. if not isinstance(h, Qobj):; raise TypeError(msg + ""expected Qobj""). if h.isoper:; Lconst += -1j * (spre(h) - spost(h)); elif h.issuper:; Lconst += h; else:; raise TypeError(msg + ""expected operator or superoperator""). elif isinstance(h_spec, list):; h = h_spec[0]; h_coeff = h_spec[1]. if not isinstance(h, Qobj):; raise TypeError(msg + ""expected Qobj""). if h.isoper:; L = -1j * (spre(h) - spost(h)); elif h.issuper:; L = h; else:; raise TypeError(msg + ""expected operator or superoperator""). Ldata.append(L.data.data); Linds.append(L.data.indices); Lptrs.append",MatchSource.WIKI,docs/4.2/modules/qutip/rhs_generate.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/rhs_generate.html
https://qutip.org/docs/4.2/modules/qutip/rhs_generate.html:3734,Modifiability,config,config,3734," # Placeholder for TD col-spmv function.; config.colexpect = None # Placeholder for TD col_expect function.; config.string = None # Holds string of variables to be passed to solver; config.tdname = None # Name of td .pyx file (used in parallel mc code). [docs]def rhs_generate(H, c_ops, args={}, options=Options(), name=None,; cleanup=True):; """"""; Generates the Cython functions needed for solving the dynamics of a; given system using the mesolve function inside a parfor loop. Parameters; ----------; H : qobj; System Hamiltonian. c_ops : list; ``list`` of collapse operators. args : dict; Arguments for time-dependent Hamiltonian and collapse operator terms. options : Options; Instance of ODE solver options. name: str; Name of generated RHS. cleanup: bool; Whether the generated cython file should be automatically removed or; not. Notes; -----; Using this function with any solver other than the mesolve function; will result in an error. """"""; config.reset(); config.options = options. if name:; config.tdname = name; else:; config.tdname = ""rhs"" + str(os.getpid()) + str(config.cgen_num). Lconst = 0. Ldata = []; Linds = []; Lptrs = []; Lcoeff = []; Lobj = []. # loop over all hamiltonian terms, convert to superoperator form and; # add the data of sparse matrix represenation to. msg = ""Incorrect specification of time-dependence: "". for h_spec in H:; if isinstance(h_spec, Qobj):; h = h_spec. if not isinstance(h, Qobj):; raise TypeError(msg + ""expected Qobj""). if h.isoper:; Lconst += -1j * (spre(h) - spost(h)); elif h.issuper:; Lconst += h; else:; raise TypeError(msg + ""expected operator or superoperator""). elif isinstance(h_spec, list):; h = h_spec[0]; h_coeff = h_spec[1]. if not isinstance(h, Qobj):; raise TypeError(msg + ""expected Qobj""). if h.isoper:; L = -1j * (spre(h) - spost(h)); elif h.issuper:; L = h; else:; raise TypeError(msg + ""expected operator or superoperator""). Ldata.append(L.data.data); Linds.append(L.data.indices); Lptrs.append(L.data.indptr); if isinstance(h_co",MatchSource.WIKI,docs/4.2/modules/qutip/rhs_generate.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/rhs_generate.html
https://qutip.org/docs/4.2/modules/qutip/rhs_generate.html:3763,Modifiability,config,config,3763,"ol-spmv function.; config.colexpect = None # Placeholder for TD col_expect function.; config.string = None # Holds string of variables to be passed to solver; config.tdname = None # Name of td .pyx file (used in parallel mc code). [docs]def rhs_generate(H, c_ops, args={}, options=Options(), name=None,; cleanup=True):; """"""; Generates the Cython functions needed for solving the dynamics of a; given system using the mesolve function inside a parfor loop. Parameters; ----------; H : qobj; System Hamiltonian. c_ops : list; ``list`` of collapse operators. args : dict; Arguments for time-dependent Hamiltonian and collapse operator terms. options : Options; Instance of ODE solver options. name: str; Name of generated RHS. cleanup: bool; Whether the generated cython file should be automatically removed or; not. Notes; -----; Using this function with any solver other than the mesolve function; will result in an error. """"""; config.reset(); config.options = options. if name:; config.tdname = name; else:; config.tdname = ""rhs"" + str(os.getpid()) + str(config.cgen_num). Lconst = 0. Ldata = []; Linds = []; Lptrs = []; Lcoeff = []; Lobj = []. # loop over all hamiltonian terms, convert to superoperator form and; # add the data of sparse matrix represenation to. msg = ""Incorrect specification of time-dependence: "". for h_spec in H:; if isinstance(h_spec, Qobj):; h = h_spec. if not isinstance(h, Qobj):; raise TypeError(msg + ""expected Qobj""). if h.isoper:; Lconst += -1j * (spre(h) - spost(h)); elif h.issuper:; Lconst += h; else:; raise TypeError(msg + ""expected operator or superoperator""). elif isinstance(h_spec, list):; h = h_spec[0]; h_coeff = h_spec[1]. if not isinstance(h, Qobj):; raise TypeError(msg + ""expected Qobj""). if h.isoper:; L = -1j * (spre(h) - spost(h)); elif h.issuper:; L = h; else:; raise TypeError(msg + ""expected operator or superoperator""). Ldata.append(L.data.data); Linds.append(L.data.indices); Lptrs.append(L.data.indptr); if isinstance(h_coeff, Cubic_Spline):; Lob",MatchSource.WIKI,docs/4.2/modules/qutip/rhs_generate.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/rhs_generate.html
https://qutip.org/docs/4.2/modules/qutip/rhs_generate.html:3810,Modifiability,config,config,3810,"holder for TD col_expect function.; config.string = None # Holds string of variables to be passed to solver; config.tdname = None # Name of td .pyx file (used in parallel mc code). [docs]def rhs_generate(H, c_ops, args={}, options=Options(), name=None,; cleanup=True):; """"""; Generates the Cython functions needed for solving the dynamics of a; given system using the mesolve function inside a parfor loop. Parameters; ----------; H : qobj; System Hamiltonian. c_ops : list; ``list`` of collapse operators. args : dict; Arguments for time-dependent Hamiltonian and collapse operator terms. options : Options; Instance of ODE solver options. name: str; Name of generated RHS. cleanup: bool; Whether the generated cython file should be automatically removed or; not. Notes; -----; Using this function with any solver other than the mesolve function; will result in an error. """"""; config.reset(); config.options = options. if name:; config.tdname = name; else:; config.tdname = ""rhs"" + str(os.getpid()) + str(config.cgen_num). Lconst = 0. Ldata = []; Linds = []; Lptrs = []; Lcoeff = []; Lobj = []. # loop over all hamiltonian terms, convert to superoperator form and; # add the data of sparse matrix represenation to. msg = ""Incorrect specification of time-dependence: "". for h_spec in H:; if isinstance(h_spec, Qobj):; h = h_spec. if not isinstance(h, Qobj):; raise TypeError(msg + ""expected Qobj""). if h.isoper:; Lconst += -1j * (spre(h) - spost(h)); elif h.issuper:; Lconst += h; else:; raise TypeError(msg + ""expected operator or superoperator""). elif isinstance(h_spec, list):; h = h_spec[0]; h_coeff = h_spec[1]. if not isinstance(h, Qobj):; raise TypeError(msg + ""expected Qobj""). if h.isoper:; L = -1j * (spre(h) - spost(h)); elif h.issuper:; L = h; else:; raise TypeError(msg + ""expected operator or superoperator""). Ldata.append(L.data.data); Linds.append(L.data.indices); Lptrs.append(L.data.indptr); if isinstance(h_coeff, Cubic_Spline):; Lobj.append(h_coeff.coeffs); Lcoeff.append(h_coeff). ",MatchSource.WIKI,docs/4.2/modules/qutip/rhs_generate.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/rhs_generate.html
https://qutip.org/docs/4.2/modules/qutip/rhs_generate.html:6126,Modifiability,config,config,6126," * spre(cdc) \; - 0.5 * spost(cdc); elif c.issuper:; Lconst += c; else:; raise TypeError(msg + ""expected operator or superoperator""). elif isinstance(c_spec, list):; c = c_spec[0]; c_coeff = c_spec[1]. if not isinstance(c, Qobj):; raise TypeError(msg + ""expected Qobj""). if c.isoper:; cdc = c.dag() * c; L = spre(c) * spost(c.dag()) - 0.5 * spre(cdc) \; - 0.5 * spost(cdc); c_coeff = ""("" + c_coeff + "")**2""; elif c.issuper:; L = c; else:; raise TypeError(msg + ""expected operator or superoperator""). Ldata.append(L.data.data); Linds.append(L.data.indices); Lptrs.append(L.data.indptr); Lcoeff.append(c_coeff). else:; raise TypeError(msg + ""expected string format""). # add the constant part of the lagrangian; if Lconst != 0:; Ldata.append(Lconst.data.data); Linds.append(Lconst.data.indices); Lptrs.append(Lconst.data.indptr); Lcoeff.append(""1.0""). # the total number of liouvillian terms (hamiltonian terms + collapse; # operators); n_L_terms = len(Ldata). cgen = Codegen(h_terms=n_L_terms, h_tdterms=Lcoeff, args=args,; config=config); cgen.generate(config.tdname + "".pyx""). code = compile('from ' + config.tdname +; ' import cy_td_ode_rhs', '<string>', 'exec'); exec(code, globals()). config.tdfunc = cy_td_ode_rhs. if cleanup:; try:; os.remove(config.tdname + "".pyx""); except:; pass. def _td_format_check(H, c_ops, solver='me'):; """"""; Checks on time-dependent format.; """"""; h_const = []; h_func = []; h_str = []; h_obj = []; # check H for incorrect format; if isinstance(H, Qobj):; pass; elif isinstance(H, (FunctionType, BuiltinFunctionType, partial)):; pass # n_func += 1; elif isinstance(H, list):; for k, H_k in enumerate(H):; if isinstance(H_k, Qobj):; h_const.append(k); elif isinstance(H_k, list):; if len(H_k) != 2 or not isinstance(H_k[0], Qobj):; raise TypeError(""Incorrect hamiltonian specification""); else:; if isinstance(H_k[1], (FunctionType,; BuiltinFunctionType, partial)):; h_func.append(k); elif isinstance(H_k[1], str):; h_str.append(k); elif isinstance(H_k[1], Cubic_Spline):;",MatchSource.WIKI,docs/4.2/modules/qutip/rhs_generate.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/rhs_generate.html
https://qutip.org/docs/4.2/modules/qutip/rhs_generate.html:6133,Modifiability,config,config,6133," * spre(cdc) \; - 0.5 * spost(cdc); elif c.issuper:; Lconst += c; else:; raise TypeError(msg + ""expected operator or superoperator""). elif isinstance(c_spec, list):; c = c_spec[0]; c_coeff = c_spec[1]. if not isinstance(c, Qobj):; raise TypeError(msg + ""expected Qobj""). if c.isoper:; cdc = c.dag() * c; L = spre(c) * spost(c.dag()) - 0.5 * spre(cdc) \; - 0.5 * spost(cdc); c_coeff = ""("" + c_coeff + "")**2""; elif c.issuper:; L = c; else:; raise TypeError(msg + ""expected operator or superoperator""). Ldata.append(L.data.data); Linds.append(L.data.indices); Lptrs.append(L.data.indptr); Lcoeff.append(c_coeff). else:; raise TypeError(msg + ""expected string format""). # add the constant part of the lagrangian; if Lconst != 0:; Ldata.append(Lconst.data.data); Linds.append(Lconst.data.indices); Lptrs.append(Lconst.data.indptr); Lcoeff.append(""1.0""). # the total number of liouvillian terms (hamiltonian terms + collapse; # operators); n_L_terms = len(Ldata). cgen = Codegen(h_terms=n_L_terms, h_tdterms=Lcoeff, args=args,; config=config); cgen.generate(config.tdname + "".pyx""). code = compile('from ' + config.tdname +; ' import cy_td_ode_rhs', '<string>', 'exec'); exec(code, globals()). config.tdfunc = cy_td_ode_rhs. if cleanup:; try:; os.remove(config.tdname + "".pyx""); except:; pass. def _td_format_check(H, c_ops, solver='me'):; """"""; Checks on time-dependent format.; """"""; h_const = []; h_func = []; h_str = []; h_obj = []; # check H for incorrect format; if isinstance(H, Qobj):; pass; elif isinstance(H, (FunctionType, BuiltinFunctionType, partial)):; pass # n_func += 1; elif isinstance(H, list):; for k, H_k in enumerate(H):; if isinstance(H_k, Qobj):; h_const.append(k); elif isinstance(H_k, list):; if len(H_k) != 2 or not isinstance(H_k[0], Qobj):; raise TypeError(""Incorrect hamiltonian specification""); else:; if isinstance(H_k[1], (FunctionType,; BuiltinFunctionType, partial)):; h_func.append(k); elif isinstance(H_k[1], str):; h_str.append(k); elif isinstance(H_k[1], Cubic_Spline):;",MatchSource.WIKI,docs/4.2/modules/qutip/rhs_generate.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/rhs_generate.html
https://qutip.org/docs/4.2/modules/qutip/rhs_generate.html:6156,Modifiability,config,config,6156,"; Lconst += c; else:; raise TypeError(msg + ""expected operator or superoperator""). elif isinstance(c_spec, list):; c = c_spec[0]; c_coeff = c_spec[1]. if not isinstance(c, Qobj):; raise TypeError(msg + ""expected Qobj""). if c.isoper:; cdc = c.dag() * c; L = spre(c) * spost(c.dag()) - 0.5 * spre(cdc) \; - 0.5 * spost(cdc); c_coeff = ""("" + c_coeff + "")**2""; elif c.issuper:; L = c; else:; raise TypeError(msg + ""expected operator or superoperator""). Ldata.append(L.data.data); Linds.append(L.data.indices); Lptrs.append(L.data.indptr); Lcoeff.append(c_coeff). else:; raise TypeError(msg + ""expected string format""). # add the constant part of the lagrangian; if Lconst != 0:; Ldata.append(Lconst.data.data); Linds.append(Lconst.data.indices); Lptrs.append(Lconst.data.indptr); Lcoeff.append(""1.0""). # the total number of liouvillian terms (hamiltonian terms + collapse; # operators); n_L_terms = len(Ldata). cgen = Codegen(h_terms=n_L_terms, h_tdterms=Lcoeff, args=args,; config=config); cgen.generate(config.tdname + "".pyx""). code = compile('from ' + config.tdname +; ' import cy_td_ode_rhs', '<string>', 'exec'); exec(code, globals()). config.tdfunc = cy_td_ode_rhs. if cleanup:; try:; os.remove(config.tdname + "".pyx""); except:; pass. def _td_format_check(H, c_ops, solver='me'):; """"""; Checks on time-dependent format.; """"""; h_const = []; h_func = []; h_str = []; h_obj = []; # check H for incorrect format; if isinstance(H, Qobj):; pass; elif isinstance(H, (FunctionType, BuiltinFunctionType, partial)):; pass # n_func += 1; elif isinstance(H, list):; for k, H_k in enumerate(H):; if isinstance(H_k, Qobj):; h_const.append(k); elif isinstance(H_k, list):; if len(H_k) != 2 or not isinstance(H_k[0], Qobj):; raise TypeError(""Incorrect hamiltonian specification""); else:; if isinstance(H_k[1], (FunctionType,; BuiltinFunctionType, partial)):; h_func.append(k); elif isinstance(H_k[1], str):; h_str.append(k); elif isinstance(H_k[1], Cubic_Spline):; h_obj.append(k); elif isinstance(H_k[1], np.ndarra",MatchSource.WIKI,docs/4.2/modules/qutip/rhs_generate.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/rhs_generate.html
https://qutip.org/docs/4.2/modules/qutip/rhs_generate.html:6206,Modifiability,config,config,6206," + ""expected operator or superoperator""). elif isinstance(c_spec, list):; c = c_spec[0]; c_coeff = c_spec[1]. if not isinstance(c, Qobj):; raise TypeError(msg + ""expected Qobj""). if c.isoper:; cdc = c.dag() * c; L = spre(c) * spost(c.dag()) - 0.5 * spre(cdc) \; - 0.5 * spost(cdc); c_coeff = ""("" + c_coeff + "")**2""; elif c.issuper:; L = c; else:; raise TypeError(msg + ""expected operator or superoperator""). Ldata.append(L.data.data); Linds.append(L.data.indices); Lptrs.append(L.data.indptr); Lcoeff.append(c_coeff). else:; raise TypeError(msg + ""expected string format""). # add the constant part of the lagrangian; if Lconst != 0:; Ldata.append(Lconst.data.data); Linds.append(Lconst.data.indices); Lptrs.append(Lconst.data.indptr); Lcoeff.append(""1.0""). # the total number of liouvillian terms (hamiltonian terms + collapse; # operators); n_L_terms = len(Ldata). cgen = Codegen(h_terms=n_L_terms, h_tdterms=Lcoeff, args=args,; config=config); cgen.generate(config.tdname + "".pyx""). code = compile('from ' + config.tdname +; ' import cy_td_ode_rhs', '<string>', 'exec'); exec(code, globals()). config.tdfunc = cy_td_ode_rhs. if cleanup:; try:; os.remove(config.tdname + "".pyx""); except:; pass. def _td_format_check(H, c_ops, solver='me'):; """"""; Checks on time-dependent format.; """"""; h_const = []; h_func = []; h_str = []; h_obj = []; # check H for incorrect format; if isinstance(H, Qobj):; pass; elif isinstance(H, (FunctionType, BuiltinFunctionType, partial)):; pass # n_func += 1; elif isinstance(H, list):; for k, H_k in enumerate(H):; if isinstance(H_k, Qobj):; h_const.append(k); elif isinstance(H_k, list):; if len(H_k) != 2 or not isinstance(H_k[0], Qobj):; raise TypeError(""Incorrect hamiltonian specification""); else:; if isinstance(H_k[1], (FunctionType,; BuiltinFunctionType, partial)):; h_func.append(k); elif isinstance(H_k[1], str):; h_str.append(k); elif isinstance(H_k[1], Cubic_Spline):; h_obj.append(k); elif isinstance(H_k[1], np.ndarray):; h_str.append(k); else:; raise TypeErr",MatchSource.WIKI,docs/4.2/modules/qutip/rhs_generate.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/rhs_generate.html
https://qutip.org/docs/4.2/modules/qutip/rhs_generate.html:6292,Modifiability,config,config,6292,"c_spec[1]. if not isinstance(c, Qobj):; raise TypeError(msg + ""expected Qobj""). if c.isoper:; cdc = c.dag() * c; L = spre(c) * spost(c.dag()) - 0.5 * spre(cdc) \; - 0.5 * spost(cdc); c_coeff = ""("" + c_coeff + "")**2""; elif c.issuper:; L = c; else:; raise TypeError(msg + ""expected operator or superoperator""). Ldata.append(L.data.data); Linds.append(L.data.indices); Lptrs.append(L.data.indptr); Lcoeff.append(c_coeff). else:; raise TypeError(msg + ""expected string format""). # add the constant part of the lagrangian; if Lconst != 0:; Ldata.append(Lconst.data.data); Linds.append(Lconst.data.indices); Lptrs.append(Lconst.data.indptr); Lcoeff.append(""1.0""). # the total number of liouvillian terms (hamiltonian terms + collapse; # operators); n_L_terms = len(Ldata). cgen = Codegen(h_terms=n_L_terms, h_tdterms=Lcoeff, args=args,; config=config); cgen.generate(config.tdname + "".pyx""). code = compile('from ' + config.tdname +; ' import cy_td_ode_rhs', '<string>', 'exec'); exec(code, globals()). config.tdfunc = cy_td_ode_rhs. if cleanup:; try:; os.remove(config.tdname + "".pyx""); except:; pass. def _td_format_check(H, c_ops, solver='me'):; """"""; Checks on time-dependent format.; """"""; h_const = []; h_func = []; h_str = []; h_obj = []; # check H for incorrect format; if isinstance(H, Qobj):; pass; elif isinstance(H, (FunctionType, BuiltinFunctionType, partial)):; pass # n_func += 1; elif isinstance(H, list):; for k, H_k in enumerate(H):; if isinstance(H_k, Qobj):; h_const.append(k); elif isinstance(H_k, list):; if len(H_k) != 2 or not isinstance(H_k[0], Qobj):; raise TypeError(""Incorrect hamiltonian specification""); else:; if isinstance(H_k[1], (FunctionType,; BuiltinFunctionType, partial)):; h_func.append(k); elif isinstance(H_k[1], str):; h_str.append(k); elif isinstance(H_k[1], Cubic_Spline):; h_obj.append(k); elif isinstance(H_k[1], np.ndarray):; h_str.append(k); else:; raise TypeError(""Incorrect hamiltonian specification""); else:; raise TypeError(""Incorrect hamiltonian specifica",MatchSource.WIKI,docs/4.2/modules/qutip/rhs_generate.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/rhs_generate.html
https://qutip.org/docs/4.2/modules/qutip/rhs_generate.html:6352,Modifiability,config,config,6352,"sg + ""expected Qobj""). if c.isoper:; cdc = c.dag() * c; L = spre(c) * spost(c.dag()) - 0.5 * spre(cdc) \; - 0.5 * spost(cdc); c_coeff = ""("" + c_coeff + "")**2""; elif c.issuper:; L = c; else:; raise TypeError(msg + ""expected operator or superoperator""). Ldata.append(L.data.data); Linds.append(L.data.indices); Lptrs.append(L.data.indptr); Lcoeff.append(c_coeff). else:; raise TypeError(msg + ""expected string format""). # add the constant part of the lagrangian; if Lconst != 0:; Ldata.append(Lconst.data.data); Linds.append(Lconst.data.indices); Lptrs.append(Lconst.data.indptr); Lcoeff.append(""1.0""). # the total number of liouvillian terms (hamiltonian terms + collapse; # operators); n_L_terms = len(Ldata). cgen = Codegen(h_terms=n_L_terms, h_tdterms=Lcoeff, args=args,; config=config); cgen.generate(config.tdname + "".pyx""). code = compile('from ' + config.tdname +; ' import cy_td_ode_rhs', '<string>', 'exec'); exec(code, globals()). config.tdfunc = cy_td_ode_rhs. if cleanup:; try:; os.remove(config.tdname + "".pyx""); except:; pass. def _td_format_check(H, c_ops, solver='me'):; """"""; Checks on time-dependent format.; """"""; h_const = []; h_func = []; h_str = []; h_obj = []; # check H for incorrect format; if isinstance(H, Qobj):; pass; elif isinstance(H, (FunctionType, BuiltinFunctionType, partial)):; pass # n_func += 1; elif isinstance(H, list):; for k, H_k in enumerate(H):; if isinstance(H_k, Qobj):; h_const.append(k); elif isinstance(H_k, list):; if len(H_k) != 2 or not isinstance(H_k[0], Qobj):; raise TypeError(""Incorrect hamiltonian specification""); else:; if isinstance(H_k[1], (FunctionType,; BuiltinFunctionType, partial)):; h_func.append(k); elif isinstance(H_k[1], str):; h_str.append(k); elif isinstance(H_k[1], Cubic_Spline):; h_obj.append(k); elif isinstance(H_k[1], np.ndarray):; h_str.append(k); else:; raise TypeError(""Incorrect hamiltonian specification""); else:; raise TypeError(""Incorrect hamiltonian specification""). # the the whole thing again for c_ops; c_const = ",MatchSource.WIKI,docs/4.2/modules/qutip/rhs_generate.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/rhs_generate.html
https://qutip.org/docs/4.2/modules/qutip/rhs_generate.html:8498,Performance,load,load,8498,"isinstance(c_ops[k], Qobj):; c_const.append(k); elif isinstance(c_ops[k], list):; if len(c_ops[k]) != 2:; raise TypeError(; ""Incorrect collapse operator specification.""); else:; if isinstance(c_ops[k][1], (FunctionType,; BuiltinFunctionType, partial)):; c_func.append(k); elif isinstance(c_ops[k][1], str):; c_str.append(k); elif isinstance(c_ops[k][1], Cubic_Spline):; c_obj.append(k); elif isinstance(c_ops[k][1], np.ndarray):; c_str.append(k); elif isinstance(c_ops[k][1], tuple):; c_str.append(k); else:; raise TypeError(; ""Incorrect collapse operator specification""); else:; raise TypeError(""Incorrect collapse operator specification""). #; # if n_str == 0 and n_func == 0:; # # no time-dependence at all; #; if ((len(h_str) > 0 and len(h_func) > 0) or; (len(c_str) > 0 and len(c_func) > 0)):; raise TypeError(; ""Cannot mix string and function type time-dependence formats""). # check to see if Cython is installed and version is high enough.; if len(h_str) > 0 or len(c_str) > 0:; try:; import Cython; except:; raise Exception(; ""Unable to load Cython. Use Python function format.""); else:; if Cython.__version__ < '0.21':; raise Exception(""Cython version (%s) is too old. Upgrade to "" +; ""version 0.21+"" % Cython.__version__); ; # If only time-dependence is in Objects, then prefer string based format; if (len(h_func) + len(c_func) + len(h_str) + len(c_str)) == 0:; h_str += h_obj #Does nothing if not objects; c_str += c_obj; else:; # Combine Hamiltonian objects; if len(h_func) > 0:; h_func += h_obj; elif len(h_str) > 0:; h_str += h_obj; ; #Combine collapse objects; if len(c_func) > 0:; c_func += c_obj; elif len(c_str) > 0:; c_str += c_obj. if solver == 'me':; return (len(h_const + c_const),; len(h_func) + len(c_func),; len(h_str) + len(c_str)); ; elif solver == 'mc':. # H C_ops #; # -- ----- --; # NO NO 00; # NO STR 01; # NO FUNC 02; #; # STR NO 10; # STR STR 11; #; # FUNC NO 20; #; # FUNC FUNC 22. if isinstance(H, FunctionType):; time_type = 3; # Time-indepdent problems; elif ((len",MatchSource.WIKI,docs/4.2/modules/qutip/rhs_generate.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/rhs_generate.html
https://qutip.org/docs/4.2/modules/qutip/rhs_generate.html:2570,Usability,clear,clears,2570,"ARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT; # LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,; # DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY; # THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT; # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE; # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.; ###############################################################################. __all__ = ['rhs_generate', 'rhs_clear']. import os; import numpy as np; from types import FunctionType, BuiltinFunctionType; from functools import partial. from qutip.cy.codegen import Codegen; from qutip.solver import Options, config; from qutip.qobj import Qobj; from qutip.superoperator import spre, spost; from qutip.interpolate import Cubic_Spline. [docs]def rhs_clear():; """"""; Resets the string-format time-dependent Hamiltonian parameters. Parameters; ----------. Returns; -------; Nothing, just clears data from internal config module. """"""; # time-dependent (TD) function stuff; config.tdfunc = None # Placeholder for TD RHS function.; config.colspmv = None # Placeholder for TD col-spmv function.; config.colexpect = None # Placeholder for TD col_expect function.; config.string = None # Holds string of variables to be passed to solver; config.tdname = None # Name of td .pyx file (used in parallel mc code). [docs]def rhs_generate(H, c_ops, args={}, options=Options(), name=None,; cleanup=True):; """"""; Generates the Cython functions needed for solving the dynamics of a; given system using the mesolve function inside a parfor loop. Parameters; ----------; H : qobj; System Hamiltonian. c_ops : list; ``list`` of collapse operators. args : dict; Arguments for time-dependent Hamiltonian and collapse operator terms. options : Options; Instance of ODE solver options. name: str; Name of generated RHS. cleanup: bool; Whether the generated cython file should be automatically removed or; not. Notes",MatchSource.WIKI,docs/4.2/modules/qutip/rhs_generate.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/rhs_generate.html
https://qutip.org/docs/4.2/modules/qutip/sesolve.html:19209,Availability,error,error,19209,"list, e_ops, opt, progress_bar, dims=None):; """"""; Internal function for solving ODEs.; """"""; if opt.normalize_output:; state_norm_func = norm; else:; state_norm_func = None; ; ; #; # prepare output array; #; n_tsteps = len(tlist); output = Result(); output.solver = ""sesolve""; output.times = tlist. if opt.store_states:; output.states = []. if isinstance(e_ops, types.FunctionType):; n_expt_op = 0; expt_callback = True. elif isinstance(e_ops, list):. n_expt_op = len(e_ops); expt_callback = False. if n_expt_op == 0:; # fallback on storing states; output.states = []; opt.store_states = True; else:; output.expect = []; output.num_expect = n_expt_op; for op in e_ops:; if op.isherm:; output.expect.append(np.zeros(n_tsteps)); else:; output.expect.append(np.zeros(n_tsteps, dtype=complex)); else:; raise TypeError(""Expectation parameter must be a list or a function""). #; # start evolution; #; progress_bar.start(n_tsteps). dt = np.diff(tlist); for t_idx, t in enumerate(tlist):; progress_bar.update(t_idx). if not r.successful():; raise Exception(""ODE integration error: Try to increase ""; ""the allowed number of substeps by increasing ""; ""the nsteps parameter in the Options class.""). if state_norm_func:; data = r.y / state_norm_func(r.y); r.set_initial_value(data, r.t). if opt.store_states:; output.states.append(Qobj(r.y, dims=dims)). if expt_callback:; # use callback method; e_ops(t, Qobj(r.y, dims=psi0.dims)). for m in range(n_expt_op):; output.expect[m][t_idx] = cy_expect_psi(e_ops[m].data,; r.y, e_ops[m].isherm). if t_idx < n_tsteps - 1:; r.integrate(r.t + dt[t_idx]). progress_bar.finished(). if not opt.rhs_reuse and config.tdname is not None:; try:; os.remove(config.tdname + "".pyx""); except:; pass. if opt.store_final_state:; output.final_state = Qobj(r.y, dims=dims). return output.  Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, and A.L. Grimsmo.; Last updated on Jan 17, 2018. . Built with Sphinx using a theme provided by Read the Docs. . ",MatchSource.WIKI,docs/4.2/modules/qutip/sesolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/sesolve.html
https://qutip.org/docs/4.2/modules/qutip/sesolve.html:2242,Deployability,integrat,integrate,2242,"# ""AS IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT; # LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A; # PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT; # HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,; # SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT; # LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,; # DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY; # THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT; # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE; # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.; ###############################################################################; """"""; This module provides solvers for the unitary Schrodinger equation.; """""". __all__ = ['sesolve']. import os; import types; from functools import partial; import numpy as np; import scipy.integrate; from scipy.linalg import norm; import qutip.settings as qset; from qutip.qobj import Qobj, isket; from qutip.rhs_generate import rhs_generate; from qutip.solver import Result, Options, config, _solver_safety_check; from qutip.rhs_generate import _td_format_check, _td_wrap_array_str; from qutip.interpolate import Cubic_Spline; from qutip.settings import debug; from qutip.cy.spmatfuncs import (cy_expect_psi, cy_ode_rhs,; cy_ode_psi_func_td,; cy_ode_psi_func_td_with_state,; spmvpy_csr); from qutip.cy.codegen import Codegen; from qutip.cy.utilities import _cython_build_cleanup. from qutip.ui.progressbar import BaseProgressBar; from qutip.cy.openmp.utilities import check_use_openmp, openmp_components. if qset.has_openmp:; from qutip.cy.openmp.parfuncs import cy_ode_rhs_openmp. if debug:; import inspect. [docs]def sesolve(H, rho0, tlist, e_ops=[], args={}, options=None,; progress_bar=BaseProgressBar(),; _safe_mode=True):; """"""; Schrodinger equation evolution of a state vector for a given Hami",MatchSource.WIKI,docs/4.2/modules/qutip/sesolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/sesolve.html
https://qutip.org/docs/4.2/modules/qutip/sesolve.html:3350,Deployability,integrat,integrating,3350,"sket; from qutip.rhs_generate import rhs_generate; from qutip.solver import Result, Options, config, _solver_safety_check; from qutip.rhs_generate import _td_format_check, _td_wrap_array_str; from qutip.interpolate import Cubic_Spline; from qutip.settings import debug; from qutip.cy.spmatfuncs import (cy_expect_psi, cy_ode_rhs,; cy_ode_psi_func_td,; cy_ode_psi_func_td_with_state,; spmvpy_csr); from qutip.cy.codegen import Codegen; from qutip.cy.utilities import _cython_build_cleanup. from qutip.ui.progressbar import BaseProgressBar; from qutip.cy.openmp.utilities import check_use_openmp, openmp_components. if qset.has_openmp:; from qutip.cy.openmp.parfuncs import cy_ode_rhs_openmp. if debug:; import inspect. [docs]def sesolve(H, rho0, tlist, e_ops=[], args={}, options=None,; progress_bar=BaseProgressBar(),; _safe_mode=True):; """"""; Schrodinger equation evolution of a state vector for a given Hamiltonian. Evolve the state vector or density matrix (`rho0`) using a given; Hamiltonian (`H`), by integrating the set of ordinary differential; equations that define the system. The output is either the state vector at arbitrary points in time; (`tlist`), or the expectation values of the supplied operators; (`e_ops`). If e_ops is a callback function, it is invoked for each; time in `tlist` with time and the state as arguments, and the function; does not use any return values. Parameters; ----------. H : :class:`qutip.qobj`; system Hamiltonian, or a callback function for time-dependent; Hamiltonians. rho0 : :class:`qutip.qobj`; initial density matrix or state vector (ket). tlist : *list* / *array*; list of times for :math:`t`. e_ops : list of :class:`qutip.qobj` / callback function single; single operator or list of operators for which to evaluate; expectation values. args : *dictionary*; dictionary of parameters for time-dependent Hamiltonians and; collapse operators. options : :class:`qutip.Qdeoptions`; with options for the ODE solver. Returns; -------. output: :class:`qutip.",MatchSource.WIKI,docs/4.2/modules/qutip/sesolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/sesolve.html
https://qutip.org/docs/4.2/modules/qutip/sesolve.html:7027,Deployability,integrat,integrator,7027,"me-dependent unitary wavefunction equation on the list-function format; #; def _sesolve_list_func_td(H_list, psi0, tlist, e_ops, args, opt,; progress_bar):; """"""; Internal function for solving the master equation. See mesolve for usage.; """""". if debug:; print(inspect.stack()[0][3]). #; # check initial state; #; if not isket(psi0):; raise TypeError(""The unitary solver requires a ket as initial state""). #; # construct liouvillian in list-function format; #; L_list = []; if not opt.rhs_with_state:; constant_func = lambda x, y: 1.0; else:; constant_func = lambda x, y, z: 1.0. # add all hamitonian terms to the lagrangian list; for h_spec in H_list:. if isinstance(h_spec, Qobj):; h = h_spec; h_coeff = constant_func. elif isinstance(h_spec, list):; h = h_spec[0]; h_coeff = h_spec[1]. else:; raise TypeError(""Incorrect specification of time-dependent "" +; ""Hamiltonian (expected callback function)""). L_list.append([-1j * h.data, h_coeff]). L_list_and_args = [L_list, args]. #; # setup integrator; #; initial_vector = psi0.full().ravel(); if not opt.rhs_with_state:; r = scipy.integrate.ode(psi_list_td); else:; r = scipy.integrate.ode(psi_list_td_with_state); r.set_integrator('zvode', method=opt.method, order=opt.order,; atol=opt.atol, rtol=opt.rtol, nsteps=opt.nsteps,; first_step=opt.first_step, min_step=opt.min_step,; max_step=opt.max_step); r.set_initial_value(initial_vector, tlist[0]); r.set_f_params(L_list_and_args). #; # call generic ODE code; #; return _generic_ode_solve(r, psi0, tlist, e_ops, opt, progress_bar,; dims=psi0.dims). #; # evaluate dpsi(t)/dt according to the master equation using the; # [Qobj, function] style time dependence API; #; def psi_list_td(t, psi, H_list_and_args):. H_list = H_list_and_args[0]; args = H_list_and_args[1]. H = H_list[0][0]; H_td = H_list[0][1]; out = np.zeros(psi.shape[0],dtype=complex); spmvpy_csr(H.data, H.indices, H.indptr, psi, H_td(t, args), out); for n in range(1, len(H_list)):; #; # args[n][0] = the sparse data for a Qobj in operat",MatchSource.WIKI,docs/4.2/modules/qutip/sesolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/sesolve.html
https://qutip.org/docs/4.2/modules/qutip/sesolve.html:7118,Deployability,integrat,integrate,7118,"lve_list_func_td(H_list, psi0, tlist, e_ops, args, opt,; progress_bar):; """"""; Internal function for solving the master equation. See mesolve for usage.; """""". if debug:; print(inspect.stack()[0][3]). #; # check initial state; #; if not isket(psi0):; raise TypeError(""The unitary solver requires a ket as initial state""). #; # construct liouvillian in list-function format; #; L_list = []; if not opt.rhs_with_state:; constant_func = lambda x, y: 1.0; else:; constant_func = lambda x, y, z: 1.0. # add all hamitonian terms to the lagrangian list; for h_spec in H_list:. if isinstance(h_spec, Qobj):; h = h_spec; h_coeff = constant_func. elif isinstance(h_spec, list):; h = h_spec[0]; h_coeff = h_spec[1]. else:; raise TypeError(""Incorrect specification of time-dependent "" +; ""Hamiltonian (expected callback function)""). L_list.append([-1j * h.data, h_coeff]). L_list_and_args = [L_list, args]. #; # setup integrator; #; initial_vector = psi0.full().ravel(); if not opt.rhs_with_state:; r = scipy.integrate.ode(psi_list_td); else:; r = scipy.integrate.ode(psi_list_td_with_state); r.set_integrator('zvode', method=opt.method, order=opt.order,; atol=opt.atol, rtol=opt.rtol, nsteps=opt.nsteps,; first_step=opt.first_step, min_step=opt.min_step,; max_step=opt.max_step); r.set_initial_value(initial_vector, tlist[0]); r.set_f_params(L_list_and_args). #; # call generic ODE code; #; return _generic_ode_solve(r, psi0, tlist, e_ops, opt, progress_bar,; dims=psi0.dims). #; # evaluate dpsi(t)/dt according to the master equation using the; # [Qobj, function] style time dependence API; #; def psi_list_td(t, psi, H_list_and_args):. H_list = H_list_and_args[0]; args = H_list_and_args[1]. H = H_list[0][0]; H_td = H_list[0][1]; out = np.zeros(psi.shape[0],dtype=complex); spmvpy_csr(H.data, H.indices, H.indptr, psi, H_td(t, args), out); for n in range(1, len(H_list)):; #; # args[n][0] = the sparse data for a Qobj in operator form; # args[n][1] = function callback giving the coefficient; #; H = H_list[n][",MatchSource.WIKI,docs/4.2/modules/qutip/sesolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/sesolve.html
https://qutip.org/docs/4.2/modules/qutip/sesolve.html:7163,Deployability,integrat,integrate,7163,"args, opt,; progress_bar):; """"""; Internal function for solving the master equation. See mesolve for usage.; """""". if debug:; print(inspect.stack()[0][3]). #; # check initial state; #; if not isket(psi0):; raise TypeError(""The unitary solver requires a ket as initial state""). #; # construct liouvillian in list-function format; #; L_list = []; if not opt.rhs_with_state:; constant_func = lambda x, y: 1.0; else:; constant_func = lambda x, y, z: 1.0. # add all hamitonian terms to the lagrangian list; for h_spec in H_list:. if isinstance(h_spec, Qobj):; h = h_spec; h_coeff = constant_func. elif isinstance(h_spec, list):; h = h_spec[0]; h_coeff = h_spec[1]. else:; raise TypeError(""Incorrect specification of time-dependent "" +; ""Hamiltonian (expected callback function)""). L_list.append([-1j * h.data, h_coeff]). L_list_and_args = [L_list, args]. #; # setup integrator; #; initial_vector = psi0.full().ravel(); if not opt.rhs_with_state:; r = scipy.integrate.ode(psi_list_td); else:; r = scipy.integrate.ode(psi_list_td_with_state); r.set_integrator('zvode', method=opt.method, order=opt.order,; atol=opt.atol, rtol=opt.rtol, nsteps=opt.nsteps,; first_step=opt.first_step, min_step=opt.min_step,; max_step=opt.max_step); r.set_initial_value(initial_vector, tlist[0]); r.set_f_params(L_list_and_args). #; # call generic ODE code; #; return _generic_ode_solve(r, psi0, tlist, e_ops, opt, progress_bar,; dims=psi0.dims). #; # evaluate dpsi(t)/dt according to the master equation using the; # [Qobj, function] style time dependence API; #; def psi_list_td(t, psi, H_list_and_args):. H_list = H_list_and_args[0]; args = H_list_and_args[1]. H = H_list[0][0]; H_td = H_list[0][1]; out = np.zeros(psi.shape[0],dtype=complex); spmvpy_csr(H.data, H.indices, H.indptr, psi, H_td(t, args), out); for n in range(1, len(H_list)):; #; # args[n][0] = the sparse data for a Qobj in operator form; # args[n][1] = function callback giving the coefficient; #; H = H_list[n][0]; H_td = H_list[n][1]; spmvpy_csr(H.data, H",MatchSource.WIKI,docs/4.2/modules/qutip/sesolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/sesolve.html
https://qutip.org/docs/4.2/modules/qutip/sesolve.html:9188,Deployability,integrat,integrator,9188," psi, H_td(t, args), out). return out. def psi_list_td_with_state(t, psi, H_list_and_args):. H_list = H_list_and_args[0]; args = H_list_and_args[1]. H = H_list[0][0]; H_td = H_list[0][1]; out = np.zeros(psi.shape[0],dtype=complex); spmvpy_csr(H.data, H.indices, H.indptr,; psi, H_td(t, args), out); for n in range(1, len(H_list)):; #; # args[n][0] = the sparse data for a Qobj in operator form; # args[n][1] = function callback giving the coefficient; #; H = H_list[n][0]; H_td = H_list[n][1]; spmvpy_csr(H.data, H.indices, H.indptr, psi, H_td(t, args), out). return out. # -----------------------------------------------------------------------------; # Wave function evolution using a ODE solver (unitary quantum evolution) using; # a constant Hamiltonian.; #; def _sesolve_const(H, psi0, tlist, e_ops, args, opt, progress_bar):; """"""!; Evolve the wave function using an ODE solver; """"""; if debug:; print(inspect.stack()[0][3]). if not isket(psi0):; raise TypeError(""psi0 must be a ket""). #; # setup integrator.; #; initial_vector = psi0.full().ravel(); L = -1.0j * H; ; if opt.use_openmp and L.data.nnz >= qset.openmp_thresh:; r = scipy.integrate.ode(cy_ode_rhs_openmp); r.set_f_params(L.data.data, L.data.indices, L.data.indptr, ; opt.openmp_threads); else:; r = scipy.integrate.ode(cy_ode_rhs); r.set_f_params(L.data.data, L.data.indices, L.data.indptr); r.set_integrator('zvode', method=opt.method, order=opt.order,; atol=opt.atol, rtol=opt.rtol, nsteps=opt.nsteps,; first_step=opt.first_step, min_step=opt.min_step,; max_step=opt.max_step). r.set_initial_value(initial_vector, tlist[0]). #; # call generic ODE code; #; return _generic_ode_solve(r, psi0, tlist, e_ops, opt,; progress_bar, dims=psi0.dims). #; # evaluate dpsi(t)/dt [not used. using cython function is being used instead]; #; def _ode_psi_func(t, psi, H):; return H * psi. # -----------------------------------------------------------------------------; # A time-dependent disipative master equation on the list-string format for; ",MatchSource.WIKI,docs/4.2/modules/qutip/sesolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/sesolve.html
https://qutip.org/docs/4.2/modules/qutip/sesolve.html:9326,Deployability,integrat,integrate,9326,"[1]. H = H_list[0][0]; H_td = H_list[0][1]; out = np.zeros(psi.shape[0],dtype=complex); spmvpy_csr(H.data, H.indices, H.indptr,; psi, H_td(t, args), out); for n in range(1, len(H_list)):; #; # args[n][0] = the sparse data for a Qobj in operator form; # args[n][1] = function callback giving the coefficient; #; H = H_list[n][0]; H_td = H_list[n][1]; spmvpy_csr(H.data, H.indices, H.indptr, psi, H_td(t, args), out). return out. # -----------------------------------------------------------------------------; # Wave function evolution using a ODE solver (unitary quantum evolution) using; # a constant Hamiltonian.; #; def _sesolve_const(H, psi0, tlist, e_ops, args, opt, progress_bar):; """"""!; Evolve the wave function using an ODE solver; """"""; if debug:; print(inspect.stack()[0][3]). if not isket(psi0):; raise TypeError(""psi0 must be a ket""). #; # setup integrator.; #; initial_vector = psi0.full().ravel(); L = -1.0j * H; ; if opt.use_openmp and L.data.nnz >= qset.openmp_thresh:; r = scipy.integrate.ode(cy_ode_rhs_openmp); r.set_f_params(L.data.data, L.data.indices, L.data.indptr, ; opt.openmp_threads); else:; r = scipy.integrate.ode(cy_ode_rhs); r.set_f_params(L.data.data, L.data.indices, L.data.indptr); r.set_integrator('zvode', method=opt.method, order=opt.order,; atol=opt.atol, rtol=opt.rtol, nsteps=opt.nsteps,; first_step=opt.first_step, min_step=opt.min_step,; max_step=opt.max_step). r.set_initial_value(initial_vector, tlist[0]). #; # call generic ODE code; #; return _generic_ode_solve(r, psi0, tlist, e_ops, opt,; progress_bar, dims=psi0.dims). #; # evaluate dpsi(t)/dt [not used. using cython function is being used instead]; #; def _ode_psi_func(t, psi, H):; return H * psi. # -----------------------------------------------------------------------------; # A time-dependent disipative master equation on the list-string format for; # cython compilation; #; def _sesolve_list_str_td(H_list, psi0, tlist, e_ops, args, opt,; progress_bar):; """"""; Internal function for solving th",MatchSource.WIKI,docs/4.2/modules/qutip/sesolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/sesolve.html
https://qutip.org/docs/4.2/modules/qutip/sesolve.html:9459,Deployability,integrat,integrate,9459," H_td(t, args), out); for n in range(1, len(H_list)):; #; # args[n][0] = the sparse data for a Qobj in operator form; # args[n][1] = function callback giving the coefficient; #; H = H_list[n][0]; H_td = H_list[n][1]; spmvpy_csr(H.data, H.indices, H.indptr, psi, H_td(t, args), out). return out. # -----------------------------------------------------------------------------; # Wave function evolution using a ODE solver (unitary quantum evolution) using; # a constant Hamiltonian.; #; def _sesolve_const(H, psi0, tlist, e_ops, args, opt, progress_bar):; """"""!; Evolve the wave function using an ODE solver; """"""; if debug:; print(inspect.stack()[0][3]). if not isket(psi0):; raise TypeError(""psi0 must be a ket""). #; # setup integrator.; #; initial_vector = psi0.full().ravel(); L = -1.0j * H; ; if opt.use_openmp and L.data.nnz >= qset.openmp_thresh:; r = scipy.integrate.ode(cy_ode_rhs_openmp); r.set_f_params(L.data.data, L.data.indices, L.data.indptr, ; opt.openmp_threads); else:; r = scipy.integrate.ode(cy_ode_rhs); r.set_f_params(L.data.data, L.data.indices, L.data.indptr); r.set_integrator('zvode', method=opt.method, order=opt.order,; atol=opt.atol, rtol=opt.rtol, nsteps=opt.nsteps,; first_step=opt.first_step, min_step=opt.min_step,; max_step=opt.max_step). r.set_initial_value(initial_vector, tlist[0]). #; # call generic ODE code; #; return _generic_ode_solve(r, psi0, tlist, e_ops, opt,; progress_bar, dims=psi0.dims). #; # evaluate dpsi(t)/dt [not used. using cython function is being used instead]; #; def _ode_psi_func(t, psi, H):; return H * psi. # -----------------------------------------------------------------------------; # A time-dependent disipative master equation on the list-string format for; # cython compilation; #; def _sesolve_list_str_td(H_list, psi0, tlist, e_ops, args, opt,; progress_bar):; """"""; Internal function for solving the master equation. See mesolve for usage.; """""". if debug:; print(inspect.stack()[0][3]). #; # check initial state: must be a density ",MatchSource.WIKI,docs/4.2/modules/qutip/sesolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/sesolve.html
https://qutip.org/docs/4.2/modules/qutip/sesolve.html:12624,Deployability,integrat,integrator,12624,"r k in range(n_L_terms):; string_list.append(""Ldata[%d], Linds[%d], Lptrs[%d]"" % (k, k, k)); # Add object terms to end of ode args string; for k in range(len(Lobj)):; string_list.append(""Lobj[%d]"" % k); ; for name, value in args.items():; if isinstance(value, np.ndarray):; string_list.append(name); else:; string_list.append(str(value)); parameter_string = "","".join(string_list). #; # generate and compile new cython code if necessary; #; if not opt.rhs_reuse or config.tdfunc is None:; if opt.rhs_filename is None:; config.tdname = ""rhs"" + str(os.getpid()) + str(config.cgen_num); else:; config.tdname = opt.rhs_filename; cgen = Codegen(h_terms=n_L_terms, h_tdterms=Lcoeff, args=args,; config=config, use_openmp=opt.use_openmp,; omp_components=omp_components,; omp_threads=opt.openmp_threads); cgen.generate(config.tdname + "".pyx""). code = compile('from ' + config.tdname + ' import cy_td_ode_rhs',; '<string>', 'exec'); exec(code, globals()); config.tdfunc = cy_td_ode_rhs. #; # setup integrator; #; initial_vector = psi0.full().ravel(); r = scipy.integrate.ode(config.tdfunc); r.set_integrator('zvode', method=opt.method, order=opt.order,; atol=opt.atol, rtol=opt.rtol, nsteps=opt.nsteps,; first_step=opt.first_step, min_step=opt.min_step,; max_step=opt.max_step); r.set_initial_value(initial_vector, tlist[0]); code = compile('r.set_f_params(' + parameter_string + ')',; '<string>', 'exec'). exec(code, locals(), args). ; # Remove RHS cython file if necessary; if not opt.rhs_reuse and config.tdname:; _cython_build_cleanup(config.tdname); ; #; # call generic ODE code; #; return _generic_ode_solve(r, psi0, tlist, e_ops, opt, progress_bar,; dims=psi0.dims). # -----------------------------------------------------------------------------; # Wave function evolution using a ODE solver (unitary quantum evolution), for; # time dependent hamiltonians; #; def _sesolve_list_td(H_func, psi0, tlist, e_ops, args, opt, progress_bar):; """"""!; Evolve the wave function using an ODE solver with time-depend",MatchSource.WIKI,docs/4.2/modules/qutip/sesolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/sesolve.html
https://qutip.org/docs/4.2/modules/qutip/sesolve.html:12687,Deployability,integrat,integrate,12687," Linds[%d], Lptrs[%d]"" % (k, k, k)); # Add object terms to end of ode args string; for k in range(len(Lobj)):; string_list.append(""Lobj[%d]"" % k); ; for name, value in args.items():; if isinstance(value, np.ndarray):; string_list.append(name); else:; string_list.append(str(value)); parameter_string = "","".join(string_list). #; # generate and compile new cython code if necessary; #; if not opt.rhs_reuse or config.tdfunc is None:; if opt.rhs_filename is None:; config.tdname = ""rhs"" + str(os.getpid()) + str(config.cgen_num); else:; config.tdname = opt.rhs_filename; cgen = Codegen(h_terms=n_L_terms, h_tdterms=Lcoeff, args=args,; config=config, use_openmp=opt.use_openmp,; omp_components=omp_components,; omp_threads=opt.openmp_threads); cgen.generate(config.tdname + "".pyx""). code = compile('from ' + config.tdname + ' import cy_td_ode_rhs',; '<string>', 'exec'); exec(code, globals()); config.tdfunc = cy_td_ode_rhs. #; # setup integrator; #; initial_vector = psi0.full().ravel(); r = scipy.integrate.ode(config.tdfunc); r.set_integrator('zvode', method=opt.method, order=opt.order,; atol=opt.atol, rtol=opt.rtol, nsteps=opt.nsteps,; first_step=opt.first_step, min_step=opt.min_step,; max_step=opt.max_step); r.set_initial_value(initial_vector, tlist[0]); code = compile('r.set_f_params(' + parameter_string + ')',; '<string>', 'exec'). exec(code, locals(), args). ; # Remove RHS cython file if necessary; if not opt.rhs_reuse and config.tdname:; _cython_build_cleanup(config.tdname); ; #; # call generic ODE code; #; return _generic_ode_solve(r, psi0, tlist, e_ops, opt, progress_bar,; dims=psi0.dims). # -----------------------------------------------------------------------------; # Wave function evolution using a ODE solver (unitary quantum evolution), for; # time dependent hamiltonians; #; def _sesolve_list_td(H_func, psi0, tlist, e_ops, args, opt, progress_bar):; """"""!; Evolve the wave function using an ODE solver with time-dependent; Hamiltonian.; """""". if debug:; print(inspect.stack(",MatchSource.WIKI,docs/4.2/modules/qutip/sesolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/sesolve.html
https://qutip.org/docs/4.2/modules/qutip/sesolve.html:15573,Deployability,integrat,integrator,15573," range(lenh)]; # create data arrays for time-dependent RHS function; Hdata = [-1.0j * H_func[0][k].data.data for k in range(lenh)]; Hinds = [H_func[0][k].data.indices for k in range(lenh)]; Hptrs = [H_func[0][k].data.indptr for k in range(lenh)]; # setup ode args string; string = """"; for k in range(lenh):; string += (""Hdata["" + str(k) + ""], Hinds["" + str(k) +; ""], Hptrs["" + str(k) + ""],""). if args:; td_consts = args.items(); for elem in td_consts:; string += str(elem[1]); if elem != td_consts[-1]:; string += ("",""). # run code generator; if not opt.rhs_reuse or config.tdfunc is None:; if opt.rhs_filename is None:; config.tdname = ""rhs"" + str(os.getpid()) + str(config.cgen_num); else:; config.tdname = opt.rhs_filename; cgen = Codegen(h_terms=n_L_terms, h_tdterms=Lcoeff, args=args,; config=config); cgen.generate(config.tdname + "".pyx""). code = compile('from ' + config.tdname + ' import cy_td_ode_rhs',; '<string>', 'exec'); exec(code, globals()); config.tdfunc = cy_td_ode_rhs; #; # setup integrator; #; initial_vector = psi0.full().ravel(); r = scipy.integrate.ode(config.tdfunc); r.set_integrator('zvode', method=opt.method, order=opt.order,; atol=opt.atol, rtol=opt.rtol, nsteps=opt.nsteps,; first_step=opt.first_step, min_step=opt.min_step,; max_step=opt.max_step); r.set_initial_value(initial_vector, tlist[0]); code = compile('r.set_f_params(' + string + ')', '<string>', 'exec'); exec(code). #; # call generic ODE code; #; return _generic_ode_solve(r, psi0, tlist, e_ops, opt, progress_bar; , dims=psi0.dims). # -----------------------------------------------------------------------------; # Wave function evolution using a ODE solver (unitary quantum evolution), for; # time dependent hamiltonians; #; def _sesolve_func_td(H_func, psi0, tlist, e_ops, args, opt, progress_bar):; """"""!; Evolve the wave function using an ODE solver with time-dependent; Hamiltonian.; """""". if debug:; print(inspect.stack()[0][3]). if not isket(psi0):; raise TypeError(""psi0 must be a ket""). #; # setup ",MatchSource.WIKI,docs/4.2/modules/qutip/sesolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/sesolve.html
https://qutip.org/docs/4.2/modules/qutip/sesolve.html:15636,Deployability,integrat,integrate,15636,"; Hdata = [-1.0j * H_func[0][k].data.data for k in range(lenh)]; Hinds = [H_func[0][k].data.indices for k in range(lenh)]; Hptrs = [H_func[0][k].data.indptr for k in range(lenh)]; # setup ode args string; string = """"; for k in range(lenh):; string += (""Hdata["" + str(k) + ""], Hinds["" + str(k) +; ""], Hptrs["" + str(k) + ""],""). if args:; td_consts = args.items(); for elem in td_consts:; string += str(elem[1]); if elem != td_consts[-1]:; string += ("",""). # run code generator; if not opt.rhs_reuse or config.tdfunc is None:; if opt.rhs_filename is None:; config.tdname = ""rhs"" + str(os.getpid()) + str(config.cgen_num); else:; config.tdname = opt.rhs_filename; cgen = Codegen(h_terms=n_L_terms, h_tdterms=Lcoeff, args=args,; config=config); cgen.generate(config.tdname + "".pyx""). code = compile('from ' + config.tdname + ' import cy_td_ode_rhs',; '<string>', 'exec'); exec(code, globals()); config.tdfunc = cy_td_ode_rhs; #; # setup integrator; #; initial_vector = psi0.full().ravel(); r = scipy.integrate.ode(config.tdfunc); r.set_integrator('zvode', method=opt.method, order=opt.order,; atol=opt.atol, rtol=opt.rtol, nsteps=opt.nsteps,; first_step=opt.first_step, min_step=opt.min_step,; max_step=opt.max_step); r.set_initial_value(initial_vector, tlist[0]); code = compile('r.set_f_params(' + string + ')', '<string>', 'exec'); exec(code). #; # call generic ODE code; #; return _generic_ode_solve(r, psi0, tlist, e_ops, opt, progress_bar; , dims=psi0.dims). # -----------------------------------------------------------------------------; # Wave function evolution using a ODE solver (unitary quantum evolution), for; # time dependent hamiltonians; #; def _sesolve_func_td(H_func, psi0, tlist, e_ops, args, opt, progress_bar):; """"""!; Evolve the wave function using an ODE solver with time-dependent; Hamiltonian.; """""". if debug:; print(inspect.stack()[0][3]). if not isket(psi0):; raise TypeError(""psi0 must be a ket""). #; # setup integrator; #; new_args = None. if type(args) is dict:; new_args = ",MatchSource.WIKI,docs/4.2/modules/qutip/sesolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/sesolve.html
https://qutip.org/docs/4.2/modules/qutip/sesolve.html:16574,Deployability,integrat,integrator,16574,"; #; initial_vector = psi0.full().ravel(); r = scipy.integrate.ode(config.tdfunc); r.set_integrator('zvode', method=opt.method, order=opt.order,; atol=opt.atol, rtol=opt.rtol, nsteps=opt.nsteps,; first_step=opt.first_step, min_step=opt.min_step,; max_step=opt.max_step); r.set_initial_value(initial_vector, tlist[0]); code = compile('r.set_f_params(' + string + ')', '<string>', 'exec'); exec(code). #; # call generic ODE code; #; return _generic_ode_solve(r, psi0, tlist, e_ops, opt, progress_bar; , dims=psi0.dims). # -----------------------------------------------------------------------------; # Wave function evolution using a ODE solver (unitary quantum evolution), for; # time dependent hamiltonians; #; def _sesolve_func_td(H_func, psi0, tlist, e_ops, args, opt, progress_bar):; """"""!; Evolve the wave function using an ODE solver with time-dependent; Hamiltonian.; """""". if debug:; print(inspect.stack()[0][3]). if not isket(psi0):; raise TypeError(""psi0 must be a ket""). #; # setup integrator; #; new_args = None. if type(args) is dict:; new_args = {}; for key in args:; if isinstance(args[key], Qobj):; new_args[key] = args[key].data; else:; new_args[key] = args[key]. elif type(args) is list or type(args) is tuple:; new_args = []; for arg in args:; if isinstance(arg, Qobj):; new_args.append(arg.data); else:; new_args.append(arg). if type(args) is tuple:; new_args = tuple(new_args); else:; if isinstance(args, Qobj):; new_args = args.data; else:; new_args = args. initial_vector = psi0.full().ravel(). if not opt.rhs_with_state:; r = scipy.integrate.ode(cy_ode_psi_func_td); else:; r = scipy.integrate.ode(cy_ode_psi_func_td_with_state). r.set_integrator('zvode', method=opt.method, order=opt.order,; atol=opt.atol, rtol=opt.rtol, nsteps=opt.nsteps,; first_step=opt.first_step, min_step=opt.min_step,; max_step=opt.max_step); r.set_initial_value(initial_vector, tlist[0]); r.set_f_params(H_func, new_args). #; # call generic ODE code; #; return _generic_ode_solve(r, psi0, tlist, e_ops, ",MatchSource.WIKI,docs/4.2/modules/qutip/sesolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/sesolve.html
https://qutip.org/docs/4.2/modules/qutip/sesolve.html:17137,Deployability,integrat,integrate,17137,"--------------------------------------; # Wave function evolution using a ODE solver (unitary quantum evolution), for; # time dependent hamiltonians; #; def _sesolve_func_td(H_func, psi0, tlist, e_ops, args, opt, progress_bar):; """"""!; Evolve the wave function using an ODE solver with time-dependent; Hamiltonian.; """""". if debug:; print(inspect.stack()[0][3]). if not isket(psi0):; raise TypeError(""psi0 must be a ket""). #; # setup integrator; #; new_args = None. if type(args) is dict:; new_args = {}; for key in args:; if isinstance(args[key], Qobj):; new_args[key] = args[key].data; else:; new_args[key] = args[key]. elif type(args) is list or type(args) is tuple:; new_args = []; for arg in args:; if isinstance(arg, Qobj):; new_args.append(arg.data); else:; new_args.append(arg). if type(args) is tuple:; new_args = tuple(new_args); else:; if isinstance(args, Qobj):; new_args = args.data; else:; new_args = args. initial_vector = psi0.full().ravel(). if not opt.rhs_with_state:; r = scipy.integrate.ode(cy_ode_psi_func_td); else:; r = scipy.integrate.ode(cy_ode_psi_func_td_with_state). r.set_integrator('zvode', method=opt.method, order=opt.order,; atol=opt.atol, rtol=opt.rtol, nsteps=opt.nsteps,; first_step=opt.first_step, min_step=opt.min_step,; max_step=opt.max_step); r.set_initial_value(initial_vector, tlist[0]); r.set_f_params(H_func, new_args). #; # call generic ODE code; #; return _generic_ode_solve(r, psi0, tlist, e_ops, opt, progress_bar,; dims=psi0.dims). #; # evaluate dpsi(t)/dt for time-dependent hamiltonian; #; def _ode_psi_func_td(t, psi, H_func, args):; H = H_func(t, args); return -1j * (H * psi). def _ode_psi_func_td_with_state(t, psi, H_func, args):; H = H_func(t, psi, args); return -1j * (H * psi). # -----------------------------------------------------------------------------; # Solve an ODE which solver parameters already setup (r). Calculate the; # required expectation values or invoke callback function at each time step.; #; def _generic_ode_solve(r, psi0",MatchSource.WIKI,docs/4.2/modules/qutip/sesolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/sesolve.html
https://qutip.org/docs/4.2/modules/qutip/sesolve.html:17189,Deployability,integrat,integrate,17189,"ion evolution using a ODE solver (unitary quantum evolution), for; # time dependent hamiltonians; #; def _sesolve_func_td(H_func, psi0, tlist, e_ops, args, opt, progress_bar):; """"""!; Evolve the wave function using an ODE solver with time-dependent; Hamiltonian.; """""". if debug:; print(inspect.stack()[0][3]). if not isket(psi0):; raise TypeError(""psi0 must be a ket""). #; # setup integrator; #; new_args = None. if type(args) is dict:; new_args = {}; for key in args:; if isinstance(args[key], Qobj):; new_args[key] = args[key].data; else:; new_args[key] = args[key]. elif type(args) is list or type(args) is tuple:; new_args = []; for arg in args:; if isinstance(arg, Qobj):; new_args.append(arg.data); else:; new_args.append(arg). if type(args) is tuple:; new_args = tuple(new_args); else:; if isinstance(args, Qobj):; new_args = args.data; else:; new_args = args. initial_vector = psi0.full().ravel(). if not opt.rhs_with_state:; r = scipy.integrate.ode(cy_ode_psi_func_td); else:; r = scipy.integrate.ode(cy_ode_psi_func_td_with_state). r.set_integrator('zvode', method=opt.method, order=opt.order,; atol=opt.atol, rtol=opt.rtol, nsteps=opt.nsteps,; first_step=opt.first_step, min_step=opt.min_step,; max_step=opt.max_step); r.set_initial_value(initial_vector, tlist[0]); r.set_f_params(H_func, new_args). #; # call generic ODE code; #; return _generic_ode_solve(r, psi0, tlist, e_ops, opt, progress_bar,; dims=psi0.dims). #; # evaluate dpsi(t)/dt for time-dependent hamiltonian; #; def _ode_psi_func_td(t, psi, H_func, args):; H = H_func(t, args); return -1j * (H * psi). def _ode_psi_func_td_with_state(t, psi, H_func, args):; H = H_func(t, psi, args); return -1j * (H * psi). # -----------------------------------------------------------------------------; # Solve an ODE which solver parameters already setup (r). Calculate the; # required expectation values or invoke callback function at each time step.; #; def _generic_ode_solve(r, psi0, tlist, e_ops, opt, progress_bar, dims=None):; """""";",MatchSource.WIKI,docs/4.2/modules/qutip/sesolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/sesolve.html
https://qutip.org/docs/4.2/modules/qutip/sesolve.html:19137,Deployability,update,update,19137,"tlist, e_ops, opt, progress_bar, dims=None):; """"""; Internal function for solving ODEs.; """"""; if opt.normalize_output:; state_norm_func = norm; else:; state_norm_func = None; ; ; #; # prepare output array; #; n_tsteps = len(tlist); output = Result(); output.solver = ""sesolve""; output.times = tlist. if opt.store_states:; output.states = []. if isinstance(e_ops, types.FunctionType):; n_expt_op = 0; expt_callback = True. elif isinstance(e_ops, list):. n_expt_op = len(e_ops); expt_callback = False. if n_expt_op == 0:; # fallback on storing states; output.states = []; opt.store_states = True; else:; output.expect = []; output.num_expect = n_expt_op; for op in e_ops:; if op.isherm:; output.expect.append(np.zeros(n_tsteps)); else:; output.expect.append(np.zeros(n_tsteps, dtype=complex)); else:; raise TypeError(""Expectation parameter must be a list or a function""). #; # start evolution; #; progress_bar.start(n_tsteps). dt = np.diff(tlist); for t_idx, t in enumerate(tlist):; progress_bar.update(t_idx). if not r.successful():; raise Exception(""ODE integration error: Try to increase ""; ""the allowed number of substeps by increasing ""; ""the nsteps parameter in the Options class.""). if state_norm_func:; data = r.y / state_norm_func(r.y); r.set_initial_value(data, r.t). if opt.store_states:; output.states.append(Qobj(r.y, dims=dims)). if expt_callback:; # use callback method; e_ops(t, Qobj(r.y, dims=psi0.dims)). for m in range(n_expt_op):; output.expect[m][t_idx] = cy_expect_psi(e_ops[m].data,; r.y, e_ops[m].isherm). if t_idx < n_tsteps - 1:; r.integrate(r.t + dt[t_idx]). progress_bar.finished(). if not opt.rhs_reuse and config.tdname is not None:; try:; os.remove(config.tdname + "".pyx""); except:; pass. if opt.store_final_state:; output.final_state = Qobj(r.y, dims=dims). return output.  Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, and A.L. Grimsmo.; Last updated on Jan 17, 2018. . Built with Sphinx using a theme provided by Read the Docs. .",MatchSource.WIKI,docs/4.2/modules/qutip/sesolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/sesolve.html
https://qutip.org/docs/4.2/modules/qutip/sesolve.html:19197,Deployability,integrat,integration,19197,"list, e_ops, opt, progress_bar, dims=None):; """"""; Internal function for solving ODEs.; """"""; if opt.normalize_output:; state_norm_func = norm; else:; state_norm_func = None; ; ; #; # prepare output array; #; n_tsteps = len(tlist); output = Result(); output.solver = ""sesolve""; output.times = tlist. if opt.store_states:; output.states = []. if isinstance(e_ops, types.FunctionType):; n_expt_op = 0; expt_callback = True. elif isinstance(e_ops, list):. n_expt_op = len(e_ops); expt_callback = False. if n_expt_op == 0:; # fallback on storing states; output.states = []; opt.store_states = True; else:; output.expect = []; output.num_expect = n_expt_op; for op in e_ops:; if op.isherm:; output.expect.append(np.zeros(n_tsteps)); else:; output.expect.append(np.zeros(n_tsteps, dtype=complex)); else:; raise TypeError(""Expectation parameter must be a list or a function""). #; # start evolution; #; progress_bar.start(n_tsteps). dt = np.diff(tlist); for t_idx, t in enumerate(tlist):; progress_bar.update(t_idx). if not r.successful():; raise Exception(""ODE integration error: Try to increase ""; ""the allowed number of substeps by increasing ""; ""the nsteps parameter in the Options class.""). if state_norm_func:; data = r.y / state_norm_func(r.y); r.set_initial_value(data, r.t). if opt.store_states:; output.states.append(Qobj(r.y, dims=dims)). if expt_callback:; # use callback method; e_ops(t, Qobj(r.y, dims=psi0.dims)). for m in range(n_expt_op):; output.expect[m][t_idx] = cy_expect_psi(e_ops[m].data,; r.y, e_ops[m].isherm). if t_idx < n_tsteps - 1:; r.integrate(r.t + dt[t_idx]). progress_bar.finished(). if not opt.rhs_reuse and config.tdname is not None:; try:; os.remove(config.tdname + "".pyx""); except:; pass. if opt.store_final_state:; output.final_state = Qobj(r.y, dims=dims). return output.  Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, and A.L. Grimsmo.; Last updated on Jan 17, 2018. . Built with Sphinx using a theme provided by Read the Docs. . ",MatchSource.WIKI,docs/4.2/modules/qutip/sesolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/sesolve.html
https://qutip.org/docs/4.2/modules/qutip/sesolve.html:19699,Deployability,integrat,integrate,19699,"list, e_ops, opt, progress_bar, dims=None):; """"""; Internal function for solving ODEs.; """"""; if opt.normalize_output:; state_norm_func = norm; else:; state_norm_func = None; ; ; #; # prepare output array; #; n_tsteps = len(tlist); output = Result(); output.solver = ""sesolve""; output.times = tlist. if opt.store_states:; output.states = []. if isinstance(e_ops, types.FunctionType):; n_expt_op = 0; expt_callback = True. elif isinstance(e_ops, list):. n_expt_op = len(e_ops); expt_callback = False. if n_expt_op == 0:; # fallback on storing states; output.states = []; opt.store_states = True; else:; output.expect = []; output.num_expect = n_expt_op; for op in e_ops:; if op.isherm:; output.expect.append(np.zeros(n_tsteps)); else:; output.expect.append(np.zeros(n_tsteps, dtype=complex)); else:; raise TypeError(""Expectation parameter must be a list or a function""). #; # start evolution; #; progress_bar.start(n_tsteps). dt = np.diff(tlist); for t_idx, t in enumerate(tlist):; progress_bar.update(t_idx). if not r.successful():; raise Exception(""ODE integration error: Try to increase ""; ""the allowed number of substeps by increasing ""; ""the nsteps parameter in the Options class.""). if state_norm_func:; data = r.y / state_norm_func(r.y); r.set_initial_value(data, r.t). if opt.store_states:; output.states.append(Qobj(r.y, dims=dims)). if expt_callback:; # use callback method; e_ops(t, Qobj(r.y, dims=psi0.dims)). for m in range(n_expt_op):; output.expect[m][t_idx] = cy_expect_psi(e_ops[m].data,; r.y, e_ops[m].isherm). if t_idx < n_tsteps - 1:; r.integrate(r.t + dt[t_idx]). progress_bar.finished(). if not opt.rhs_reuse and config.tdname is not None:; try:; os.remove(config.tdname + "".pyx""); except:; pass. if opt.store_final_state:; output.final_state = Qobj(r.y, dims=dims). return output.  Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, and A.L. Grimsmo.; Last updated on Jan 17, 2018. . Built with Sphinx using a theme provided by Read the Docs. . ",MatchSource.WIKI,docs/4.2/modules/qutip/sesolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/sesolve.html
https://qutip.org/docs/4.2/modules/qutip/sesolve.html:20057,Deployability,update,updated,20057,"list, e_ops, opt, progress_bar, dims=None):; """"""; Internal function for solving ODEs.; """"""; if opt.normalize_output:; state_norm_func = norm; else:; state_norm_func = None; ; ; #; # prepare output array; #; n_tsteps = len(tlist); output = Result(); output.solver = ""sesolve""; output.times = tlist. if opt.store_states:; output.states = []. if isinstance(e_ops, types.FunctionType):; n_expt_op = 0; expt_callback = True. elif isinstance(e_ops, list):. n_expt_op = len(e_ops); expt_callback = False. if n_expt_op == 0:; # fallback on storing states; output.states = []; opt.store_states = True; else:; output.expect = []; output.num_expect = n_expt_op; for op in e_ops:; if op.isherm:; output.expect.append(np.zeros(n_tsteps)); else:; output.expect.append(np.zeros(n_tsteps, dtype=complex)); else:; raise TypeError(""Expectation parameter must be a list or a function""). #; # start evolution; #; progress_bar.start(n_tsteps). dt = np.diff(tlist); for t_idx, t in enumerate(tlist):; progress_bar.update(t_idx). if not r.successful():; raise Exception(""ODE integration error: Try to increase ""; ""the allowed number of substeps by increasing ""; ""the nsteps parameter in the Options class.""). if state_norm_func:; data = r.y / state_norm_func(r.y); r.set_initial_value(data, r.t). if opt.store_states:; output.states.append(Qobj(r.y, dims=dims)). if expt_callback:; # use callback method; e_ops(t, Qobj(r.y, dims=psi0.dims)). for m in range(n_expt_op):; output.expect[m][t_idx] = cy_expect_psi(e_ops[m].data,; r.y, e_ops[m].isherm). if t_idx < n_tsteps - 1:; r.integrate(r.t + dt[t_idx]). progress_bar.finished(). if not opt.rhs_reuse and config.tdname is not None:; try:; os.remove(config.tdname + "".pyx""); except:; pass. if opt.store_final_state:; output.final_state = Qobj(r.y, dims=dims). return output.  Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, and A.L. Grimsmo.; Last updated on Jan 17, 2018. . Built with Sphinx using a theme provided by Read the Docs. . ",MatchSource.WIKI,docs/4.2/modules/qutip/sesolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/sesolve.html
https://qutip.org/docs/4.2/modules/qutip/sesolve.html:2242,Integrability,integrat,integrate,2242,"# ""AS IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT; # LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A; # PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT; # HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,; # SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT; # LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,; # DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY; # THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT; # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE; # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.; ###############################################################################; """"""; This module provides solvers for the unitary Schrodinger equation.; """""". __all__ = ['sesolve']. import os; import types; from functools import partial; import numpy as np; import scipy.integrate; from scipy.linalg import norm; import qutip.settings as qset; from qutip.qobj import Qobj, isket; from qutip.rhs_generate import rhs_generate; from qutip.solver import Result, Options, config, _solver_safety_check; from qutip.rhs_generate import _td_format_check, _td_wrap_array_str; from qutip.interpolate import Cubic_Spline; from qutip.settings import debug; from qutip.cy.spmatfuncs import (cy_expect_psi, cy_ode_rhs,; cy_ode_psi_func_td,; cy_ode_psi_func_td_with_state,; spmvpy_csr); from qutip.cy.codegen import Codegen; from qutip.cy.utilities import _cython_build_cleanup. from qutip.ui.progressbar import BaseProgressBar; from qutip.cy.openmp.utilities import check_use_openmp, openmp_components. if qset.has_openmp:; from qutip.cy.openmp.parfuncs import cy_ode_rhs_openmp. if debug:; import inspect. [docs]def sesolve(H, rho0, tlist, e_ops=[], args={}, options=None,; progress_bar=BaseProgressBar(),; _safe_mode=True):; """"""; Schrodinger equation evolution of a state vector for a given Hami",MatchSource.WIKI,docs/4.2/modules/qutip/sesolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/sesolve.html
https://qutip.org/docs/4.2/modules/qutip/sesolve.html:3350,Integrability,integrat,integrating,3350,"sket; from qutip.rhs_generate import rhs_generate; from qutip.solver import Result, Options, config, _solver_safety_check; from qutip.rhs_generate import _td_format_check, _td_wrap_array_str; from qutip.interpolate import Cubic_Spline; from qutip.settings import debug; from qutip.cy.spmatfuncs import (cy_expect_psi, cy_ode_rhs,; cy_ode_psi_func_td,; cy_ode_psi_func_td_with_state,; spmvpy_csr); from qutip.cy.codegen import Codegen; from qutip.cy.utilities import _cython_build_cleanup. from qutip.ui.progressbar import BaseProgressBar; from qutip.cy.openmp.utilities import check_use_openmp, openmp_components. if qset.has_openmp:; from qutip.cy.openmp.parfuncs import cy_ode_rhs_openmp. if debug:; import inspect. [docs]def sesolve(H, rho0, tlist, e_ops=[], args={}, options=None,; progress_bar=BaseProgressBar(),; _safe_mode=True):; """"""; Schrodinger equation evolution of a state vector for a given Hamiltonian. Evolve the state vector or density matrix (`rho0`) using a given; Hamiltonian (`H`), by integrating the set of ordinary differential; equations that define the system. The output is either the state vector at arbitrary points in time; (`tlist`), or the expectation values of the supplied operators; (`e_ops`). If e_ops is a callback function, it is invoked for each; time in `tlist` with time and the state as arguments, and the function; does not use any return values. Parameters; ----------. H : :class:`qutip.qobj`; system Hamiltonian, or a callback function for time-dependent; Hamiltonians. rho0 : :class:`qutip.qobj`; initial density matrix or state vector (ket). tlist : *list* / *array*; list of times for :math:`t`. e_ops : list of :class:`qutip.qobj` / callback function single; single operator or list of operators for which to evaluate; expectation values. args : *dictionary*; dictionary of parameters for time-dependent Hamiltonians and; collapse operators. options : :class:`qutip.Qdeoptions`; with options for the ODE solver. Returns; -------. output: :class:`qutip.",MatchSource.WIKI,docs/4.2/modules/qutip/sesolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/sesolve.html
https://qutip.org/docs/4.2/modules/qutip/sesolve.html:3834,Integrability,depend,dependent,3834,"on_build_cleanup. from qutip.ui.progressbar import BaseProgressBar; from qutip.cy.openmp.utilities import check_use_openmp, openmp_components. if qset.has_openmp:; from qutip.cy.openmp.parfuncs import cy_ode_rhs_openmp. if debug:; import inspect. [docs]def sesolve(H, rho0, tlist, e_ops=[], args={}, options=None,; progress_bar=BaseProgressBar(),; _safe_mode=True):; """"""; Schrodinger equation evolution of a state vector for a given Hamiltonian. Evolve the state vector or density matrix (`rho0`) using a given; Hamiltonian (`H`), by integrating the set of ordinary differential; equations that define the system. The output is either the state vector at arbitrary points in time; (`tlist`), or the expectation values of the supplied operators; (`e_ops`). If e_ops is a callback function, it is invoked for each; time in `tlist` with time and the state as arguments, and the function; does not use any return values. Parameters; ----------. H : :class:`qutip.qobj`; system Hamiltonian, or a callback function for time-dependent; Hamiltonians. rho0 : :class:`qutip.qobj`; initial density matrix or state vector (ket). tlist : *list* / *array*; list of times for :math:`t`. e_ops : list of :class:`qutip.qobj` / callback function single; single operator or list of operators for which to evaluate; expectation values. args : *dictionary*; dictionary of parameters for time-dependent Hamiltonians and; collapse operators. options : :class:`qutip.Qdeoptions`; with options for the ODE solver. Returns; -------. output: :class:`qutip.solver`. An instance of the class :class:`qutip.solver`, which contains either; an *array* of expectation values for the times specified by `tlist`, or; an *array* or state vectors or density matrices corresponding to the; times in `tlist` [if `e_ops` is an empty list], or; nothing if a callback function was given inplace of operators for; which to calculate the expectation values. """"""; if isinstance(e_ops, Qobj):; e_ops = [e_ops]. if isinstance(e_ops, dict):; e_ops_d",MatchSource.WIKI,docs/4.2/modules/qutip/sesolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/sesolve.html
https://qutip.org/docs/4.2/modules/qutip/sesolve.html:4187,Integrability,depend,dependent,4187," """"""; Schrodinger equation evolution of a state vector for a given Hamiltonian. Evolve the state vector or density matrix (`rho0`) using a given; Hamiltonian (`H`), by integrating the set of ordinary differential; equations that define the system. The output is either the state vector at arbitrary points in time; (`tlist`), or the expectation values of the supplied operators; (`e_ops`). If e_ops is a callback function, it is invoked for each; time in `tlist` with time and the state as arguments, and the function; does not use any return values. Parameters; ----------. H : :class:`qutip.qobj`; system Hamiltonian, or a callback function for time-dependent; Hamiltonians. rho0 : :class:`qutip.qobj`; initial density matrix or state vector (ket). tlist : *list* / *array*; list of times for :math:`t`. e_ops : list of :class:`qutip.qobj` / callback function single; single operator or list of operators for which to evaluate; expectation values. args : *dictionary*; dictionary of parameters for time-dependent Hamiltonians and; collapse operators. options : :class:`qutip.Qdeoptions`; with options for the ODE solver. Returns; -------. output: :class:`qutip.solver`. An instance of the class :class:`qutip.solver`, which contains either; an *array* of expectation values for the times specified by `tlist`, or; an *array* or state vectors or density matrices corresponding to the; times in `tlist` [if `e_ops` is an empty list], or; nothing if a callback function was given inplace of operators for; which to calculate the expectation values. """"""; if isinstance(e_ops, Qobj):; e_ops = [e_ops]. if isinstance(e_ops, dict):; e_ops_dict = e_ops; e_ops = [e for e in e_ops.values()]; else:; e_ops_dict = None; ; if _safe_mode:; _solver_safety_check(H, rho0, c_ops=[], e_ops=e_ops, args=args); ; # convert array based time-dependence to string format; H, _, args = _td_wrap_array_str(H, [], args, tlist); # check for type (if any) of time-dependent inputs; n_const, n_func, n_str = _td_format_check(H,",MatchSource.WIKI,docs/4.2/modules/qutip/sesolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/sesolve.html
https://qutip.org/docs/4.2/modules/qutip/sesolve.html:5005,Integrability,depend,dependence,5005,"` / callback function single; single operator or list of operators for which to evaluate; expectation values. args : *dictionary*; dictionary of parameters for time-dependent Hamiltonians and; collapse operators. options : :class:`qutip.Qdeoptions`; with options for the ODE solver. Returns; -------. output: :class:`qutip.solver`. An instance of the class :class:`qutip.solver`, which contains either; an *array* of expectation values for the times specified by `tlist`, or; an *array* or state vectors or density matrices corresponding to the; times in `tlist` [if `e_ops` is an empty list], or; nothing if a callback function was given inplace of operators for; which to calculate the expectation values. """"""; if isinstance(e_ops, Qobj):; e_ops = [e_ops]. if isinstance(e_ops, dict):; e_ops_dict = e_ops; e_ops = [e for e in e_ops.values()]; else:; e_ops_dict = None; ; if _safe_mode:; _solver_safety_check(H, rho0, c_ops=[], e_ops=e_ops, args=args); ; # convert array based time-dependence to string format; H, _, args = _td_wrap_array_str(H, [], args, tlist); # check for type (if any) of time-dependent inputs; n_const, n_func, n_str = _td_format_check(H, []). if options is None:; options = Options(). if (not options.rhs_reuse) or (not config.tdfunc):; # reset config time-dependence flags to default values; config.reset(); ; #check if should use OPENMP; check_use_openmp(options). if n_func > 0:; res = _sesolve_list_func_td(H, rho0, tlist, e_ops, args, options,; progress_bar). elif n_str > 0:; res = _sesolve_list_str_td(H, rho0, tlist, e_ops, args, options,; progress_bar). elif isinstance(H, (types.FunctionType,; types.BuiltinFunctionType,; partial)):; res = _sesolve_func_td(H, rho0, tlist, e_ops, args, options,; progress_bar). else:; res = _sesolve_const(H, rho0, tlist, e_ops, args, options,; progress_bar). if e_ops_dict:; res.expect = {e: res.expect[n]; for n, e in enumerate(e_ops_dict.keys())}. return res. # --------------------------------------------------------------------",MatchSource.WIKI,docs/4.2/modules/qutip/sesolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/sesolve.html
https://qutip.org/docs/4.2/modules/qutip/sesolve.html:5121,Integrability,depend,dependent,5121,"` / callback function single; single operator or list of operators for which to evaluate; expectation values. args : *dictionary*; dictionary of parameters for time-dependent Hamiltonians and; collapse operators. options : :class:`qutip.Qdeoptions`; with options for the ODE solver. Returns; -------. output: :class:`qutip.solver`. An instance of the class :class:`qutip.solver`, which contains either; an *array* of expectation values for the times specified by `tlist`, or; an *array* or state vectors or density matrices corresponding to the; times in `tlist` [if `e_ops` is an empty list], or; nothing if a callback function was given inplace of operators for; which to calculate the expectation values. """"""; if isinstance(e_ops, Qobj):; e_ops = [e_ops]. if isinstance(e_ops, dict):; e_ops_dict = e_ops; e_ops = [e for e in e_ops.values()]; else:; e_ops_dict = None; ; if _safe_mode:; _solver_safety_check(H, rho0, c_ops=[], e_ops=e_ops, args=args); ; # convert array based time-dependence to string format; H, _, args = _td_wrap_array_str(H, [], args, tlist); # check for type (if any) of time-dependent inputs; n_const, n_func, n_str = _td_format_check(H, []). if options is None:; options = Options(). if (not options.rhs_reuse) or (not config.tdfunc):; # reset config time-dependence flags to default values; config.reset(); ; #check if should use OPENMP; check_use_openmp(options). if n_func > 0:; res = _sesolve_list_func_td(H, rho0, tlist, e_ops, args, options,; progress_bar). elif n_str > 0:; res = _sesolve_list_str_td(H, rho0, tlist, e_ops, args, options,; progress_bar). elif isinstance(H, (types.FunctionType,; types.BuiltinFunctionType,; partial)):; res = _sesolve_func_td(H, rho0, tlist, e_ops, args, options,; progress_bar). else:; res = _sesolve_const(H, rho0, tlist, e_ops, args, options,; progress_bar). if e_ops_dict:; res.expect = {e: res.expect[n]; for n, e in enumerate(e_ops_dict.keys())}. return res. # --------------------------------------------------------------------",MatchSource.WIKI,docs/4.2/modules/qutip/sesolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/sesolve.html
https://qutip.org/docs/4.2/modules/qutip/sesolve.html:5303,Integrability,depend,dependence,5303,"rns; -------. output: :class:`qutip.solver`. An instance of the class :class:`qutip.solver`, which contains either; an *array* of expectation values for the times specified by `tlist`, or; an *array* or state vectors or density matrices corresponding to the; times in `tlist` [if `e_ops` is an empty list], or; nothing if a callback function was given inplace of operators for; which to calculate the expectation values. """"""; if isinstance(e_ops, Qobj):; e_ops = [e_ops]. if isinstance(e_ops, dict):; e_ops_dict = e_ops; e_ops = [e for e in e_ops.values()]; else:; e_ops_dict = None; ; if _safe_mode:; _solver_safety_check(H, rho0, c_ops=[], e_ops=e_ops, args=args); ; # convert array based time-dependence to string format; H, _, args = _td_wrap_array_str(H, [], args, tlist); # check for type (if any) of time-dependent inputs; n_const, n_func, n_str = _td_format_check(H, []). if options is None:; options = Options(). if (not options.rhs_reuse) or (not config.tdfunc):; # reset config time-dependence flags to default values; config.reset(); ; #check if should use OPENMP; check_use_openmp(options). if n_func > 0:; res = _sesolve_list_func_td(H, rho0, tlist, e_ops, args, options,; progress_bar). elif n_str > 0:; res = _sesolve_list_str_td(H, rho0, tlist, e_ops, args, options,; progress_bar). elif isinstance(H, (types.FunctionType,; types.BuiltinFunctionType,; partial)):; res = _sesolve_func_td(H, rho0, tlist, e_ops, args, options,; progress_bar). else:; res = _sesolve_const(H, rho0, tlist, e_ops, args, options,; progress_bar). if e_ops_dict:; res.expect = {e: res.expect[n]; for n, e in enumerate(e_ops_dict.keys())}. return res. # -----------------------------------------------------------------------------; # A time-dependent unitary wavefunction equation on the list-function format; #; def _sesolve_list_func_td(H_list, psi0, tlist, e_ops, args, opt,; progress_bar):; """"""; Internal function for solving the master equation. See mesolve for usage.; """""". if debug:; print(inspect.stac",MatchSource.WIKI,docs/4.2/modules/qutip/sesolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/sesolve.html
https://qutip.org/docs/4.2/modules/qutip/sesolve.html:6042,Integrability,depend,dependent,6042,"pe (if any) of time-dependent inputs; n_const, n_func, n_str = _td_format_check(H, []). if options is None:; options = Options(). if (not options.rhs_reuse) or (not config.tdfunc):; # reset config time-dependence flags to default values; config.reset(); ; #check if should use OPENMP; check_use_openmp(options). if n_func > 0:; res = _sesolve_list_func_td(H, rho0, tlist, e_ops, args, options,; progress_bar). elif n_str > 0:; res = _sesolve_list_str_td(H, rho0, tlist, e_ops, args, options,; progress_bar). elif isinstance(H, (types.FunctionType,; types.BuiltinFunctionType,; partial)):; res = _sesolve_func_td(H, rho0, tlist, e_ops, args, options,; progress_bar). else:; res = _sesolve_const(H, rho0, tlist, e_ops, args, options,; progress_bar). if e_ops_dict:; res.expect = {e: res.expect[n]; for n, e in enumerate(e_ops_dict.keys())}. return res. # -----------------------------------------------------------------------------; # A time-dependent unitary wavefunction equation on the list-function format; #; def _sesolve_list_func_td(H_list, psi0, tlist, e_ops, args, opt,; progress_bar):; """"""; Internal function for solving the master equation. See mesolve for usage.; """""". if debug:; print(inspect.stack()[0][3]). #; # check initial state; #; if not isket(psi0):; raise TypeError(""The unitary solver requires a ket as initial state""). #; # construct liouvillian in list-function format; #; L_list = []; if not opt.rhs_with_state:; constant_func = lambda x, y: 1.0; else:; constant_func = lambda x, y, z: 1.0. # add all hamitonian terms to the lagrangian list; for h_spec in H_list:. if isinstance(h_spec, Qobj):; h = h_spec; h_coeff = constant_func. elif isinstance(h_spec, list):; h = h_spec[0]; h_coeff = h_spec[1]. else:; raise TypeError(""Incorrect specification of time-dependent "" +; ""Hamiltonian (expected callback function)""). L_list.append([-1j * h.data, h_coeff]). L_list_and_args = [L_list, args]. #; # setup integrator; #; initial_vector = psi0.full().ravel(); if not opt.rhs_with_s",MatchSource.WIKI,docs/4.2/modules/qutip/sesolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/sesolve.html
https://qutip.org/docs/4.2/modules/qutip/sesolve.html:6882,Integrability,depend,dependent,6882,"es.expect[n]; for n, e in enumerate(e_ops_dict.keys())}. return res. # -----------------------------------------------------------------------------; # A time-dependent unitary wavefunction equation on the list-function format; #; def _sesolve_list_func_td(H_list, psi0, tlist, e_ops, args, opt,; progress_bar):; """"""; Internal function for solving the master equation. See mesolve for usage.; """""". if debug:; print(inspect.stack()[0][3]). #; # check initial state; #; if not isket(psi0):; raise TypeError(""The unitary solver requires a ket as initial state""). #; # construct liouvillian in list-function format; #; L_list = []; if not opt.rhs_with_state:; constant_func = lambda x, y: 1.0; else:; constant_func = lambda x, y, z: 1.0. # add all hamitonian terms to the lagrangian list; for h_spec in H_list:. if isinstance(h_spec, Qobj):; h = h_spec; h_coeff = constant_func. elif isinstance(h_spec, list):; h = h_spec[0]; h_coeff = h_spec[1]. else:; raise TypeError(""Incorrect specification of time-dependent "" +; ""Hamiltonian (expected callback function)""). L_list.append([-1j * h.data, h_coeff]). L_list_and_args = [L_list, args]. #; # setup integrator; #; initial_vector = psi0.full().ravel(); if not opt.rhs_with_state:; r = scipy.integrate.ode(psi_list_td); else:; r = scipy.integrate.ode(psi_list_td_with_state); r.set_integrator('zvode', method=opt.method, order=opt.order,; atol=opt.atol, rtol=opt.rtol, nsteps=opt.nsteps,; first_step=opt.first_step, min_step=opt.min_step,; max_step=opt.max_step); r.set_initial_value(initial_vector, tlist[0]); r.set_f_params(L_list_and_args). #; # call generic ODE code; #; return _generic_ode_solve(r, psi0, tlist, e_ops, opt, progress_bar,; dims=psi0.dims). #; # evaluate dpsi(t)/dt according to the master equation using the; # [Qobj, function] style time dependence API; #; def psi_list_td(t, psi, H_list_and_args):. H_list = H_list_and_args[0]; args = H_list_and_args[1]. H = H_list[0][0]; H_td = H_list[0][1]; out = np.zeros(psi.shape[0],dtype=comple",MatchSource.WIKI,docs/4.2/modules/qutip/sesolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/sesolve.html
https://qutip.org/docs/4.2/modules/qutip/sesolve.html:7027,Integrability,integrat,integrator,7027,"me-dependent unitary wavefunction equation on the list-function format; #; def _sesolve_list_func_td(H_list, psi0, tlist, e_ops, args, opt,; progress_bar):; """"""; Internal function for solving the master equation. See mesolve for usage.; """""". if debug:; print(inspect.stack()[0][3]). #; # check initial state; #; if not isket(psi0):; raise TypeError(""The unitary solver requires a ket as initial state""). #; # construct liouvillian in list-function format; #; L_list = []; if not opt.rhs_with_state:; constant_func = lambda x, y: 1.0; else:; constant_func = lambda x, y, z: 1.0. # add all hamitonian terms to the lagrangian list; for h_spec in H_list:. if isinstance(h_spec, Qobj):; h = h_spec; h_coeff = constant_func. elif isinstance(h_spec, list):; h = h_spec[0]; h_coeff = h_spec[1]. else:; raise TypeError(""Incorrect specification of time-dependent "" +; ""Hamiltonian (expected callback function)""). L_list.append([-1j * h.data, h_coeff]). L_list_and_args = [L_list, args]. #; # setup integrator; #; initial_vector = psi0.full().ravel(); if not opt.rhs_with_state:; r = scipy.integrate.ode(psi_list_td); else:; r = scipy.integrate.ode(psi_list_td_with_state); r.set_integrator('zvode', method=opt.method, order=opt.order,; atol=opt.atol, rtol=opt.rtol, nsteps=opt.nsteps,; first_step=opt.first_step, min_step=opt.min_step,; max_step=opt.max_step); r.set_initial_value(initial_vector, tlist[0]); r.set_f_params(L_list_and_args). #; # call generic ODE code; #; return _generic_ode_solve(r, psi0, tlist, e_ops, opt, progress_bar,; dims=psi0.dims). #; # evaluate dpsi(t)/dt according to the master equation using the; # [Qobj, function] style time dependence API; #; def psi_list_td(t, psi, H_list_and_args):. H_list = H_list_and_args[0]; args = H_list_and_args[1]. H = H_list[0][0]; H_td = H_list[0][1]; out = np.zeros(psi.shape[0],dtype=complex); spmvpy_csr(H.data, H.indices, H.indptr, psi, H_td(t, args), out); for n in range(1, len(H_list)):; #; # args[n][0] = the sparse data for a Qobj in operat",MatchSource.WIKI,docs/4.2/modules/qutip/sesolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/sesolve.html
https://qutip.org/docs/4.2/modules/qutip/sesolve.html:7118,Integrability,integrat,integrate,7118,"lve_list_func_td(H_list, psi0, tlist, e_ops, args, opt,; progress_bar):; """"""; Internal function for solving the master equation. See mesolve for usage.; """""". if debug:; print(inspect.stack()[0][3]). #; # check initial state; #; if not isket(psi0):; raise TypeError(""The unitary solver requires a ket as initial state""). #; # construct liouvillian in list-function format; #; L_list = []; if not opt.rhs_with_state:; constant_func = lambda x, y: 1.0; else:; constant_func = lambda x, y, z: 1.0. # add all hamitonian terms to the lagrangian list; for h_spec in H_list:. if isinstance(h_spec, Qobj):; h = h_spec; h_coeff = constant_func. elif isinstance(h_spec, list):; h = h_spec[0]; h_coeff = h_spec[1]. else:; raise TypeError(""Incorrect specification of time-dependent "" +; ""Hamiltonian (expected callback function)""). L_list.append([-1j * h.data, h_coeff]). L_list_and_args = [L_list, args]. #; # setup integrator; #; initial_vector = psi0.full().ravel(); if not opt.rhs_with_state:; r = scipy.integrate.ode(psi_list_td); else:; r = scipy.integrate.ode(psi_list_td_with_state); r.set_integrator('zvode', method=opt.method, order=opt.order,; atol=opt.atol, rtol=opt.rtol, nsteps=opt.nsteps,; first_step=opt.first_step, min_step=opt.min_step,; max_step=opt.max_step); r.set_initial_value(initial_vector, tlist[0]); r.set_f_params(L_list_and_args). #; # call generic ODE code; #; return _generic_ode_solve(r, psi0, tlist, e_ops, opt, progress_bar,; dims=psi0.dims). #; # evaluate dpsi(t)/dt according to the master equation using the; # [Qobj, function] style time dependence API; #; def psi_list_td(t, psi, H_list_and_args):. H_list = H_list_and_args[0]; args = H_list_and_args[1]. H = H_list[0][0]; H_td = H_list[0][1]; out = np.zeros(psi.shape[0],dtype=complex); spmvpy_csr(H.data, H.indices, H.indptr, psi, H_td(t, args), out); for n in range(1, len(H_list)):; #; # args[n][0] = the sparse data for a Qobj in operator form; # args[n][1] = function callback giving the coefficient; #; H = H_list[n][",MatchSource.WIKI,docs/4.2/modules/qutip/sesolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/sesolve.html
https://qutip.org/docs/4.2/modules/qutip/sesolve.html:7163,Integrability,integrat,integrate,7163,"args, opt,; progress_bar):; """"""; Internal function for solving the master equation. See mesolve for usage.; """""". if debug:; print(inspect.stack()[0][3]). #; # check initial state; #; if not isket(psi0):; raise TypeError(""The unitary solver requires a ket as initial state""). #; # construct liouvillian in list-function format; #; L_list = []; if not opt.rhs_with_state:; constant_func = lambda x, y: 1.0; else:; constant_func = lambda x, y, z: 1.0. # add all hamitonian terms to the lagrangian list; for h_spec in H_list:. if isinstance(h_spec, Qobj):; h = h_spec; h_coeff = constant_func. elif isinstance(h_spec, list):; h = h_spec[0]; h_coeff = h_spec[1]. else:; raise TypeError(""Incorrect specification of time-dependent "" +; ""Hamiltonian (expected callback function)""). L_list.append([-1j * h.data, h_coeff]). L_list_and_args = [L_list, args]. #; # setup integrator; #; initial_vector = psi0.full().ravel(); if not opt.rhs_with_state:; r = scipy.integrate.ode(psi_list_td); else:; r = scipy.integrate.ode(psi_list_td_with_state); r.set_integrator('zvode', method=opt.method, order=opt.order,; atol=opt.atol, rtol=opt.rtol, nsteps=opt.nsteps,; first_step=opt.first_step, min_step=opt.min_step,; max_step=opt.max_step); r.set_initial_value(initial_vector, tlist[0]); r.set_f_params(L_list_and_args). #; # call generic ODE code; #; return _generic_ode_solve(r, psi0, tlist, e_ops, opt, progress_bar,; dims=psi0.dims). #; # evaluate dpsi(t)/dt according to the master equation using the; # [Qobj, function] style time dependence API; #; def psi_list_td(t, psi, H_list_and_args):. H_list = H_list_and_args[0]; args = H_list_and_args[1]. H = H_list[0][0]; H_td = H_list[0][1]; out = np.zeros(psi.shape[0],dtype=complex); spmvpy_csr(H.data, H.indices, H.indptr, psi, H_td(t, args), out); for n in range(1, len(H_list)):; #; # args[n][0] = the sparse data for a Qobj in operator form; # args[n][1] = function callback giving the coefficient; #; H = H_list[n][0]; H_td = H_list[n][1]; spmvpy_csr(H.data, H",MatchSource.WIKI,docs/4.2/modules/qutip/sesolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/sesolve.html
https://qutip.org/docs/4.2/modules/qutip/sesolve.html:7686,Integrability,depend,dependence,7686,"; for h_spec in H_list:. if isinstance(h_spec, Qobj):; h = h_spec; h_coeff = constant_func. elif isinstance(h_spec, list):; h = h_spec[0]; h_coeff = h_spec[1]. else:; raise TypeError(""Incorrect specification of time-dependent "" +; ""Hamiltonian (expected callback function)""). L_list.append([-1j * h.data, h_coeff]). L_list_and_args = [L_list, args]. #; # setup integrator; #; initial_vector = psi0.full().ravel(); if not opt.rhs_with_state:; r = scipy.integrate.ode(psi_list_td); else:; r = scipy.integrate.ode(psi_list_td_with_state); r.set_integrator('zvode', method=opt.method, order=opt.order,; atol=opt.atol, rtol=opt.rtol, nsteps=opt.nsteps,; first_step=opt.first_step, min_step=opt.min_step,; max_step=opt.max_step); r.set_initial_value(initial_vector, tlist[0]); r.set_f_params(L_list_and_args). #; # call generic ODE code; #; return _generic_ode_solve(r, psi0, tlist, e_ops, opt, progress_bar,; dims=psi0.dims). #; # evaluate dpsi(t)/dt according to the master equation using the; # [Qobj, function] style time dependence API; #; def psi_list_td(t, psi, H_list_and_args):. H_list = H_list_and_args[0]; args = H_list_and_args[1]. H = H_list[0][0]; H_td = H_list[0][1]; out = np.zeros(psi.shape[0],dtype=complex); spmvpy_csr(H.data, H.indices, H.indptr, psi, H_td(t, args), out); for n in range(1, len(H_list)):; #; # args[n][0] = the sparse data for a Qobj in operator form; # args[n][1] = function callback giving the coefficient; #; H = H_list[n][0]; H_td = H_list[n][1]; spmvpy_csr(H.data, H.indices, H.indptr, psi, H_td(t, args), out). return out. def psi_list_td_with_state(t, psi, H_list_and_args):. H_list = H_list_and_args[0]; args = H_list_and_args[1]. H = H_list[0][0]; H_td = H_list[0][1]; out = np.zeros(psi.shape[0],dtype=complex); spmvpy_csr(H.data, H.indices, H.indptr,; psi, H_td(t, args), out); for n in range(1, len(H_list)):; #; # args[n][0] = the sparse data for a Qobj in operator form; # args[n][1] = function callback giving the coefficient; #; H = H_list[n][0]; H_td = ",MatchSource.WIKI,docs/4.2/modules/qutip/sesolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/sesolve.html
https://qutip.org/docs/4.2/modules/qutip/sesolve.html:9188,Integrability,integrat,integrator,9188," psi, H_td(t, args), out). return out. def psi_list_td_with_state(t, psi, H_list_and_args):. H_list = H_list_and_args[0]; args = H_list_and_args[1]. H = H_list[0][0]; H_td = H_list[0][1]; out = np.zeros(psi.shape[0],dtype=complex); spmvpy_csr(H.data, H.indices, H.indptr,; psi, H_td(t, args), out); for n in range(1, len(H_list)):; #; # args[n][0] = the sparse data for a Qobj in operator form; # args[n][1] = function callback giving the coefficient; #; H = H_list[n][0]; H_td = H_list[n][1]; spmvpy_csr(H.data, H.indices, H.indptr, psi, H_td(t, args), out). return out. # -----------------------------------------------------------------------------; # Wave function evolution using a ODE solver (unitary quantum evolution) using; # a constant Hamiltonian.; #; def _sesolve_const(H, psi0, tlist, e_ops, args, opt, progress_bar):; """"""!; Evolve the wave function using an ODE solver; """"""; if debug:; print(inspect.stack()[0][3]). if not isket(psi0):; raise TypeError(""psi0 must be a ket""). #; # setup integrator.; #; initial_vector = psi0.full().ravel(); L = -1.0j * H; ; if opt.use_openmp and L.data.nnz >= qset.openmp_thresh:; r = scipy.integrate.ode(cy_ode_rhs_openmp); r.set_f_params(L.data.data, L.data.indices, L.data.indptr, ; opt.openmp_threads); else:; r = scipy.integrate.ode(cy_ode_rhs); r.set_f_params(L.data.data, L.data.indices, L.data.indptr); r.set_integrator('zvode', method=opt.method, order=opt.order,; atol=opt.atol, rtol=opt.rtol, nsteps=opt.nsteps,; first_step=opt.first_step, min_step=opt.min_step,; max_step=opt.max_step). r.set_initial_value(initial_vector, tlist[0]). #; # call generic ODE code; #; return _generic_ode_solve(r, psi0, tlist, e_ops, opt,; progress_bar, dims=psi0.dims). #; # evaluate dpsi(t)/dt [not used. using cython function is being used instead]; #; def _ode_psi_func(t, psi, H):; return H * psi. # -----------------------------------------------------------------------------; # A time-dependent disipative master equation on the list-string format for; ",MatchSource.WIKI,docs/4.2/modules/qutip/sesolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/sesolve.html
https://qutip.org/docs/4.2/modules/qutip/sesolve.html:9326,Integrability,integrat,integrate,9326,"[1]. H = H_list[0][0]; H_td = H_list[0][1]; out = np.zeros(psi.shape[0],dtype=complex); spmvpy_csr(H.data, H.indices, H.indptr,; psi, H_td(t, args), out); for n in range(1, len(H_list)):; #; # args[n][0] = the sparse data for a Qobj in operator form; # args[n][1] = function callback giving the coefficient; #; H = H_list[n][0]; H_td = H_list[n][1]; spmvpy_csr(H.data, H.indices, H.indptr, psi, H_td(t, args), out). return out. # -----------------------------------------------------------------------------; # Wave function evolution using a ODE solver (unitary quantum evolution) using; # a constant Hamiltonian.; #; def _sesolve_const(H, psi0, tlist, e_ops, args, opt, progress_bar):; """"""!; Evolve the wave function using an ODE solver; """"""; if debug:; print(inspect.stack()[0][3]). if not isket(psi0):; raise TypeError(""psi0 must be a ket""). #; # setup integrator.; #; initial_vector = psi0.full().ravel(); L = -1.0j * H; ; if opt.use_openmp and L.data.nnz >= qset.openmp_thresh:; r = scipy.integrate.ode(cy_ode_rhs_openmp); r.set_f_params(L.data.data, L.data.indices, L.data.indptr, ; opt.openmp_threads); else:; r = scipy.integrate.ode(cy_ode_rhs); r.set_f_params(L.data.data, L.data.indices, L.data.indptr); r.set_integrator('zvode', method=opt.method, order=opt.order,; atol=opt.atol, rtol=opt.rtol, nsteps=opt.nsteps,; first_step=opt.first_step, min_step=opt.min_step,; max_step=opt.max_step). r.set_initial_value(initial_vector, tlist[0]). #; # call generic ODE code; #; return _generic_ode_solve(r, psi0, tlist, e_ops, opt,; progress_bar, dims=psi0.dims). #; # evaluate dpsi(t)/dt [not used. using cython function is being used instead]; #; def _ode_psi_func(t, psi, H):; return H * psi. # -----------------------------------------------------------------------------; # A time-dependent disipative master equation on the list-string format for; # cython compilation; #; def _sesolve_list_str_td(H_list, psi0, tlist, e_ops, args, opt,; progress_bar):; """"""; Internal function for solving th",MatchSource.WIKI,docs/4.2/modules/qutip/sesolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/sesolve.html
https://qutip.org/docs/4.2/modules/qutip/sesolve.html:9459,Integrability,integrat,integrate,9459," H_td(t, args), out); for n in range(1, len(H_list)):; #; # args[n][0] = the sparse data for a Qobj in operator form; # args[n][1] = function callback giving the coefficient; #; H = H_list[n][0]; H_td = H_list[n][1]; spmvpy_csr(H.data, H.indices, H.indptr, psi, H_td(t, args), out). return out. # -----------------------------------------------------------------------------; # Wave function evolution using a ODE solver (unitary quantum evolution) using; # a constant Hamiltonian.; #; def _sesolve_const(H, psi0, tlist, e_ops, args, opt, progress_bar):; """"""!; Evolve the wave function using an ODE solver; """"""; if debug:; print(inspect.stack()[0][3]). if not isket(psi0):; raise TypeError(""psi0 must be a ket""). #; # setup integrator.; #; initial_vector = psi0.full().ravel(); L = -1.0j * H; ; if opt.use_openmp and L.data.nnz >= qset.openmp_thresh:; r = scipy.integrate.ode(cy_ode_rhs_openmp); r.set_f_params(L.data.data, L.data.indices, L.data.indptr, ; opt.openmp_threads); else:; r = scipy.integrate.ode(cy_ode_rhs); r.set_f_params(L.data.data, L.data.indices, L.data.indptr); r.set_integrator('zvode', method=opt.method, order=opt.order,; atol=opt.atol, rtol=opt.rtol, nsteps=opt.nsteps,; first_step=opt.first_step, min_step=opt.min_step,; max_step=opt.max_step). r.set_initial_value(initial_vector, tlist[0]). #; # call generic ODE code; #; return _generic_ode_solve(r, psi0, tlist, e_ops, opt,; progress_bar, dims=psi0.dims). #; # evaluate dpsi(t)/dt [not used. using cython function is being used instead]; #; def _ode_psi_func(t, psi, H):; return H * psi. # -----------------------------------------------------------------------------; # A time-dependent disipative master equation on the list-string format for; # cython compilation; #; def _sesolve_list_str_td(H_list, psi0, tlist, e_ops, args, opt,; progress_bar):; """"""; Internal function for solving the master equation. See mesolve for usage.; """""". if debug:; print(inspect.stack()[0][3]). #; # check initial state: must be a density ",MatchSource.WIKI,docs/4.2/modules/qutip/sesolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/sesolve.html
https://qutip.org/docs/4.2/modules/qutip/sesolve.html:10120,Integrability,depend,dependent,10120,"ntegrator.; #; initial_vector = psi0.full().ravel(); L = -1.0j * H; ; if opt.use_openmp and L.data.nnz >= qset.openmp_thresh:; r = scipy.integrate.ode(cy_ode_rhs_openmp); r.set_f_params(L.data.data, L.data.indices, L.data.indptr, ; opt.openmp_threads); else:; r = scipy.integrate.ode(cy_ode_rhs); r.set_f_params(L.data.data, L.data.indices, L.data.indptr); r.set_integrator('zvode', method=opt.method, order=opt.order,; atol=opt.atol, rtol=opt.rtol, nsteps=opt.nsteps,; first_step=opt.first_step, min_step=opt.min_step,; max_step=opt.max_step). r.set_initial_value(initial_vector, tlist[0]). #; # call generic ODE code; #; return _generic_ode_solve(r, psi0, tlist, e_ops, opt,; progress_bar, dims=psi0.dims). #; # evaluate dpsi(t)/dt [not used. using cython function is being used instead]; #; def _ode_psi_func(t, psi, H):; return H * psi. # -----------------------------------------------------------------------------; # A time-dependent disipative master equation on the list-string format for; # cython compilation; #; def _sesolve_list_str_td(H_list, psi0, tlist, e_ops, args, opt,; progress_bar):; """"""; Internal function for solving the master equation. See mesolve for usage.; """""". if debug:; print(inspect.stack()[0][3]). #; # check initial state: must be a density matrix; #; if not isket(psi0):; raise TypeError(""The unitary solver requires a ket as initial state""). #; # construct liouvillian; #; Ldata = []; Linds = []; Lptrs = []; Lcoeff = []; Lobj = []. # loop over all hamiltonian terms, convert to superoperator form and; # add the data of sparse matrix representation to h_coeff; for h_spec in H_list:. if isinstance(h_spec, Qobj):; h = h_spec; h_coeff = ""1.0"". elif isinstance(h_spec, list):; h = h_spec[0]; h_coeff = h_spec[1]. else:; raise TypeError(""Incorrect specification of time-dependent "" +; ""Hamiltonian (expected string format)""). L = -1j * h. Ldata.append(L.data.data); Linds.append(L.data.indices); Lptrs.append(L.data.indptr); if isinstance(h_coeff, Cubic_Spline):; Lo",MatchSource.WIKI,docs/4.2/modules/qutip/sesolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/sesolve.html
https://qutip.org/docs/4.2/modules/qutip/sesolve.html:10993,Integrability,depend,dependent,10993,"psi_func(t, psi, H):; return H * psi. # -----------------------------------------------------------------------------; # A time-dependent disipative master equation on the list-string format for; # cython compilation; #; def _sesolve_list_str_td(H_list, psi0, tlist, e_ops, args, opt,; progress_bar):; """"""; Internal function for solving the master equation. See mesolve for usage.; """""". if debug:; print(inspect.stack()[0][3]). #; # check initial state: must be a density matrix; #; if not isket(psi0):; raise TypeError(""The unitary solver requires a ket as initial state""). #; # construct liouvillian; #; Ldata = []; Linds = []; Lptrs = []; Lcoeff = []; Lobj = []. # loop over all hamiltonian terms, convert to superoperator form and; # add the data of sparse matrix representation to h_coeff; for h_spec in H_list:. if isinstance(h_spec, Qobj):; h = h_spec; h_coeff = ""1.0"". elif isinstance(h_spec, list):; h = h_spec[0]; h_coeff = h_spec[1]. else:; raise TypeError(""Incorrect specification of time-dependent "" +; ""Hamiltonian (expected string format)""). L = -1j * h. Ldata.append(L.data.data); Linds.append(L.data.indices); Lptrs.append(L.data.indptr); if isinstance(h_coeff, Cubic_Spline):; Lobj.append(h_coeff.coeffs); Lcoeff.append(h_coeff). # the total number of liouvillian terms (hamiltonian terms +; # collapse operators); n_L_terms = len(Ldata); ; # Check which components should use OPENMP; omp_components = None; if qset.has_openmp:; if opt.use_openmp:; omp_components = openmp_components(Lptrs). #; # setup ode args string: we expand the list Ldata, Linds and Lptrs into; # and explicit list of parameters; #; string_list = []; for k in range(n_L_terms):; string_list.append(""Ldata[%d], Linds[%d], Lptrs[%d]"" % (k, k, k)); # Add object terms to end of ode args string; for k in range(len(Lobj)):; string_list.append(""Lobj[%d]"" % k); ; for name, value in args.items():; if isinstance(value, np.ndarray):; string_list.append(name); else:; string_list.append(str(value)); parameter_string ",MatchSource.WIKI,docs/4.2/modules/qutip/sesolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/sesolve.html
https://qutip.org/docs/4.2/modules/qutip/sesolve.html:12624,Integrability,integrat,integrator,12624,"r k in range(n_L_terms):; string_list.append(""Ldata[%d], Linds[%d], Lptrs[%d]"" % (k, k, k)); # Add object terms to end of ode args string; for k in range(len(Lobj)):; string_list.append(""Lobj[%d]"" % k); ; for name, value in args.items():; if isinstance(value, np.ndarray):; string_list.append(name); else:; string_list.append(str(value)); parameter_string = "","".join(string_list). #; # generate and compile new cython code if necessary; #; if not opt.rhs_reuse or config.tdfunc is None:; if opt.rhs_filename is None:; config.tdname = ""rhs"" + str(os.getpid()) + str(config.cgen_num); else:; config.tdname = opt.rhs_filename; cgen = Codegen(h_terms=n_L_terms, h_tdterms=Lcoeff, args=args,; config=config, use_openmp=opt.use_openmp,; omp_components=omp_components,; omp_threads=opt.openmp_threads); cgen.generate(config.tdname + "".pyx""). code = compile('from ' + config.tdname + ' import cy_td_ode_rhs',; '<string>', 'exec'); exec(code, globals()); config.tdfunc = cy_td_ode_rhs. #; # setup integrator; #; initial_vector = psi0.full().ravel(); r = scipy.integrate.ode(config.tdfunc); r.set_integrator('zvode', method=opt.method, order=opt.order,; atol=opt.atol, rtol=opt.rtol, nsteps=opt.nsteps,; first_step=opt.first_step, min_step=opt.min_step,; max_step=opt.max_step); r.set_initial_value(initial_vector, tlist[0]); code = compile('r.set_f_params(' + parameter_string + ')',; '<string>', 'exec'). exec(code, locals(), args). ; # Remove RHS cython file if necessary; if not opt.rhs_reuse and config.tdname:; _cython_build_cleanup(config.tdname); ; #; # call generic ODE code; #; return _generic_ode_solve(r, psi0, tlist, e_ops, opt, progress_bar,; dims=psi0.dims). # -----------------------------------------------------------------------------; # Wave function evolution using a ODE solver (unitary quantum evolution), for; # time dependent hamiltonians; #; def _sesolve_list_td(H_func, psi0, tlist, e_ops, args, opt, progress_bar):; """"""!; Evolve the wave function using an ODE solver with time-depend",MatchSource.WIKI,docs/4.2/modules/qutip/sesolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/sesolve.html
https://qutip.org/docs/4.2/modules/qutip/sesolve.html:12687,Integrability,integrat,integrate,12687," Linds[%d], Lptrs[%d]"" % (k, k, k)); # Add object terms to end of ode args string; for k in range(len(Lobj)):; string_list.append(""Lobj[%d]"" % k); ; for name, value in args.items():; if isinstance(value, np.ndarray):; string_list.append(name); else:; string_list.append(str(value)); parameter_string = "","".join(string_list). #; # generate and compile new cython code if necessary; #; if not opt.rhs_reuse or config.tdfunc is None:; if opt.rhs_filename is None:; config.tdname = ""rhs"" + str(os.getpid()) + str(config.cgen_num); else:; config.tdname = opt.rhs_filename; cgen = Codegen(h_terms=n_L_terms, h_tdterms=Lcoeff, args=args,; config=config, use_openmp=opt.use_openmp,; omp_components=omp_components,; omp_threads=opt.openmp_threads); cgen.generate(config.tdname + "".pyx""). code = compile('from ' + config.tdname + ' import cy_td_ode_rhs',; '<string>', 'exec'); exec(code, globals()); config.tdfunc = cy_td_ode_rhs. #; # setup integrator; #; initial_vector = psi0.full().ravel(); r = scipy.integrate.ode(config.tdfunc); r.set_integrator('zvode', method=opt.method, order=opt.order,; atol=opt.atol, rtol=opt.rtol, nsteps=opt.nsteps,; first_step=opt.first_step, min_step=opt.min_step,; max_step=opt.max_step); r.set_initial_value(initial_vector, tlist[0]); code = compile('r.set_f_params(' + parameter_string + ')',; '<string>', 'exec'). exec(code, locals(), args). ; # Remove RHS cython file if necessary; if not opt.rhs_reuse and config.tdname:; _cython_build_cleanup(config.tdname); ; #; # call generic ODE code; #; return _generic_ode_solve(r, psi0, tlist, e_ops, opt, progress_bar,; dims=psi0.dims). # -----------------------------------------------------------------------------; # Wave function evolution using a ODE solver (unitary quantum evolution), for; # time dependent hamiltonians; #; def _sesolve_list_td(H_func, psi0, tlist, e_ops, args, opt, progress_bar):; """"""!; Evolve the wave function using an ODE solver with time-dependent; Hamiltonian.; """""". if debug:; print(inspect.stack(",MatchSource.WIKI,docs/4.2/modules/qutip/sesolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/sesolve.html
https://qutip.org/docs/4.2/modules/qutip/sesolve.html:13467,Integrability,depend,dependent,13467,"= compile('from ' + config.tdname + ' import cy_td_ode_rhs',; '<string>', 'exec'); exec(code, globals()); config.tdfunc = cy_td_ode_rhs. #; # setup integrator; #; initial_vector = psi0.full().ravel(); r = scipy.integrate.ode(config.tdfunc); r.set_integrator('zvode', method=opt.method, order=opt.order,; atol=opt.atol, rtol=opt.rtol, nsteps=opt.nsteps,; first_step=opt.first_step, min_step=opt.min_step,; max_step=opt.max_step); r.set_initial_value(initial_vector, tlist[0]); code = compile('r.set_f_params(' + parameter_string + ')',; '<string>', 'exec'). exec(code, locals(), args). ; # Remove RHS cython file if necessary; if not opt.rhs_reuse and config.tdname:; _cython_build_cleanup(config.tdname); ; #; # call generic ODE code; #; return _generic_ode_solve(r, psi0, tlist, e_ops, opt, progress_bar,; dims=psi0.dims). # -----------------------------------------------------------------------------; # Wave function evolution using a ODE solver (unitary quantum evolution), for; # time dependent hamiltonians; #; def _sesolve_list_td(H_func, psi0, tlist, e_ops, args, opt, progress_bar):; """"""!; Evolve the wave function using an ODE solver with time-dependent; Hamiltonian.; """""". if debug:; print(inspect.stack()[0][3]). if not isket(psi0):; raise TypeError(""psi0 must be a ket""). #; # configure time-dependent terms and setup ODE solver; #; if len(H_func) != 2:; raise TypeError('Time-dependent Hamiltonian list must have two terms.'); if (not isinstance(H_func[0], (list, np.ndarray))) or \; (len(H_func[0]) <= 1):; raise TypeError('Time-dependent Hamiltonians must be a list with two '; + 'or more terms'); if (not isinstance(H_func[1], (list, np.ndarray))) or \; (len(H_func[1]) != (len(H_func[0]) - 1)):; raise TypeError('Time-dependent coefficients must be list with ' +; 'length N-1 where N is the number of ' +; 'Hamiltonian terms.'); tflag = 1; if opt.rhs_reuse and config.tdfunc is None:; print(""No previous time-dependent RHS found.""); print(""Generating one for you...""); rhs_generate(",MatchSource.WIKI,docs/4.2/modules/qutip/sesolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/sesolve.html
https://qutip.org/docs/4.2/modules/qutip/sesolve.html:13631,Integrability,depend,dependent,13631,"= compile('from ' + config.tdname + ' import cy_td_ode_rhs',; '<string>', 'exec'); exec(code, globals()); config.tdfunc = cy_td_ode_rhs. #; # setup integrator; #; initial_vector = psi0.full().ravel(); r = scipy.integrate.ode(config.tdfunc); r.set_integrator('zvode', method=opt.method, order=opt.order,; atol=opt.atol, rtol=opt.rtol, nsteps=opt.nsteps,; first_step=opt.first_step, min_step=opt.min_step,; max_step=opt.max_step); r.set_initial_value(initial_vector, tlist[0]); code = compile('r.set_f_params(' + parameter_string + ')',; '<string>', 'exec'). exec(code, locals(), args). ; # Remove RHS cython file if necessary; if not opt.rhs_reuse and config.tdname:; _cython_build_cleanup(config.tdname); ; #; # call generic ODE code; #; return _generic_ode_solve(r, psi0, tlist, e_ops, opt, progress_bar,; dims=psi0.dims). # -----------------------------------------------------------------------------; # Wave function evolution using a ODE solver (unitary quantum evolution), for; # time dependent hamiltonians; #; def _sesolve_list_td(H_func, psi0, tlist, e_ops, args, opt, progress_bar):; """"""!; Evolve the wave function using an ODE solver with time-dependent; Hamiltonian.; """""". if debug:; print(inspect.stack()[0][3]). if not isket(psi0):; raise TypeError(""psi0 must be a ket""). #; # configure time-dependent terms and setup ODE solver; #; if len(H_func) != 2:; raise TypeError('Time-dependent Hamiltonian list must have two terms.'); if (not isinstance(H_func[0], (list, np.ndarray))) or \; (len(H_func[0]) <= 1):; raise TypeError('Time-dependent Hamiltonians must be a list with two '; + 'or more terms'); if (not isinstance(H_func[1], (list, np.ndarray))) or \; (len(H_func[1]) != (len(H_func[0]) - 1)):; raise TypeError('Time-dependent coefficients must be list with ' +; 'length N-1 where N is the number of ' +; 'Hamiltonian terms.'); tflag = 1; if opt.rhs_reuse and config.tdfunc is None:; print(""No previous time-dependent RHS found.""); print(""Generating one for you...""); rhs_generate(",MatchSource.WIKI,docs/4.2/modules/qutip/sesolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/sesolve.html
https://qutip.org/docs/4.2/modules/qutip/sesolve.html:13782,Integrability,depend,dependent,13782,"tep=opt.first_step, min_step=opt.min_step,; max_step=opt.max_step); r.set_initial_value(initial_vector, tlist[0]); code = compile('r.set_f_params(' + parameter_string + ')',; '<string>', 'exec'). exec(code, locals(), args). ; # Remove RHS cython file if necessary; if not opt.rhs_reuse and config.tdname:; _cython_build_cleanup(config.tdname); ; #; # call generic ODE code; #; return _generic_ode_solve(r, psi0, tlist, e_ops, opt, progress_bar,; dims=psi0.dims). # -----------------------------------------------------------------------------; # Wave function evolution using a ODE solver (unitary quantum evolution), for; # time dependent hamiltonians; #; def _sesolve_list_td(H_func, psi0, tlist, e_ops, args, opt, progress_bar):; """"""!; Evolve the wave function using an ODE solver with time-dependent; Hamiltonian.; """""". if debug:; print(inspect.stack()[0][3]). if not isket(psi0):; raise TypeError(""psi0 must be a ket""). #; # configure time-dependent terms and setup ODE solver; #; if len(H_func) != 2:; raise TypeError('Time-dependent Hamiltonian list must have two terms.'); if (not isinstance(H_func[0], (list, np.ndarray))) or \; (len(H_func[0]) <= 1):; raise TypeError('Time-dependent Hamiltonians must be a list with two '; + 'or more terms'); if (not isinstance(H_func[1], (list, np.ndarray))) or \; (len(H_func[1]) != (len(H_func[0]) - 1)):; raise TypeError('Time-dependent coefficients must be list with ' +; 'length N-1 where N is the number of ' +; 'Hamiltonian terms.'); tflag = 1; if opt.rhs_reuse and config.tdfunc is None:; print(""No previous time-dependent RHS found.""); print(""Generating one for you...""); rhs_generate(H_func, args); lenh = len(H_func[0]); if opt.tidy:; H_func[0] = [(H_func[0][k]).tidyup() for k in range(lenh)]; # create data arrays for time-dependent RHS function; Hdata = [-1.0j * H_func[0][k].data.data for k in range(lenh)]; Hinds = [H_func[0][k].data.indices for k in range(lenh)]; Hptrs = [H_func[0][k].data.indptr for k in range(lenh)]; # setup ode args ",MatchSource.WIKI,docs/4.2/modules/qutip/sesolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/sesolve.html
https://qutip.org/docs/4.2/modules/qutip/sesolve.html:13867,Integrability,depend,dependent,13867,"tep=opt.first_step, min_step=opt.min_step,; max_step=opt.max_step); r.set_initial_value(initial_vector, tlist[0]); code = compile('r.set_f_params(' + parameter_string + ')',; '<string>', 'exec'). exec(code, locals(), args). ; # Remove RHS cython file if necessary; if not opt.rhs_reuse and config.tdname:; _cython_build_cleanup(config.tdname); ; #; # call generic ODE code; #; return _generic_ode_solve(r, psi0, tlist, e_ops, opt, progress_bar,; dims=psi0.dims). # -----------------------------------------------------------------------------; # Wave function evolution using a ODE solver (unitary quantum evolution), for; # time dependent hamiltonians; #; def _sesolve_list_td(H_func, psi0, tlist, e_ops, args, opt, progress_bar):; """"""!; Evolve the wave function using an ODE solver with time-dependent; Hamiltonian.; """""". if debug:; print(inspect.stack()[0][3]). if not isket(psi0):; raise TypeError(""psi0 must be a ket""). #; # configure time-dependent terms and setup ODE solver; #; if len(H_func) != 2:; raise TypeError('Time-dependent Hamiltonian list must have two terms.'); if (not isinstance(H_func[0], (list, np.ndarray))) or \; (len(H_func[0]) <= 1):; raise TypeError('Time-dependent Hamiltonians must be a list with two '; + 'or more terms'); if (not isinstance(H_func[1], (list, np.ndarray))) or \; (len(H_func[1]) != (len(H_func[0]) - 1)):; raise TypeError('Time-dependent coefficients must be list with ' +; 'length N-1 where N is the number of ' +; 'Hamiltonian terms.'); tflag = 1; if opt.rhs_reuse and config.tdfunc is None:; print(""No previous time-dependent RHS found.""); print(""Generating one for you...""); rhs_generate(H_func, args); lenh = len(H_func[0]); if opt.tidy:; H_func[0] = [(H_func[0][k]).tidyup() for k in range(lenh)]; # create data arrays for time-dependent RHS function; Hdata = [-1.0j * H_func[0][k].data.data for k in range(lenh)]; Hinds = [H_func[0][k].data.indices for k in range(lenh)]; Hptrs = [H_func[0][k].data.indptr for k in range(lenh)]; # setup ode args ",MatchSource.WIKI,docs/4.2/modules/qutip/sesolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/sesolve.html
https://qutip.org/docs/4.2/modules/qutip/sesolve.html:14021,Integrability,depend,dependent,14021,"locals(), args). ; # Remove RHS cython file if necessary; if not opt.rhs_reuse and config.tdname:; _cython_build_cleanup(config.tdname); ; #; # call generic ODE code; #; return _generic_ode_solve(r, psi0, tlist, e_ops, opt, progress_bar,; dims=psi0.dims). # -----------------------------------------------------------------------------; # Wave function evolution using a ODE solver (unitary quantum evolution), for; # time dependent hamiltonians; #; def _sesolve_list_td(H_func, psi0, tlist, e_ops, args, opt, progress_bar):; """"""!; Evolve the wave function using an ODE solver with time-dependent; Hamiltonian.; """""". if debug:; print(inspect.stack()[0][3]). if not isket(psi0):; raise TypeError(""psi0 must be a ket""). #; # configure time-dependent terms and setup ODE solver; #; if len(H_func) != 2:; raise TypeError('Time-dependent Hamiltonian list must have two terms.'); if (not isinstance(H_func[0], (list, np.ndarray))) or \; (len(H_func[0]) <= 1):; raise TypeError('Time-dependent Hamiltonians must be a list with two '; + 'or more terms'); if (not isinstance(H_func[1], (list, np.ndarray))) or \; (len(H_func[1]) != (len(H_func[0]) - 1)):; raise TypeError('Time-dependent coefficients must be list with ' +; 'length N-1 where N is the number of ' +; 'Hamiltonian terms.'); tflag = 1; if opt.rhs_reuse and config.tdfunc is None:; print(""No previous time-dependent RHS found.""); print(""Generating one for you...""); rhs_generate(H_func, args); lenh = len(H_func[0]); if opt.tidy:; H_func[0] = [(H_func[0][k]).tidyup() for k in range(lenh)]; # create data arrays for time-dependent RHS function; Hdata = [-1.0j * H_func[0][k].data.data for k in range(lenh)]; Hinds = [H_func[0][k].data.indices for k in range(lenh)]; Hptrs = [H_func[0][k].data.indptr for k in range(lenh)]; # setup ode args string; string = """"; for k in range(lenh):; string += (""Hdata["" + str(k) + ""], Hinds["" + str(k) +; ""], Hptrs["" + str(k) + ""],""). if args:; td_consts = args.items(); for elem in td_consts:; string += str(elem",MatchSource.WIKI,docs/4.2/modules/qutip/sesolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/sesolve.html
https://qutip.org/docs/4.2/modules/qutip/sesolve.html:14213,Integrability,depend,dependent,14213,"eric_ode_solve(r, psi0, tlist, e_ops, opt, progress_bar,; dims=psi0.dims). # -----------------------------------------------------------------------------; # Wave function evolution using a ODE solver (unitary quantum evolution), for; # time dependent hamiltonians; #; def _sesolve_list_td(H_func, psi0, tlist, e_ops, args, opt, progress_bar):; """"""!; Evolve the wave function using an ODE solver with time-dependent; Hamiltonian.; """""". if debug:; print(inspect.stack()[0][3]). if not isket(psi0):; raise TypeError(""psi0 must be a ket""). #; # configure time-dependent terms and setup ODE solver; #; if len(H_func) != 2:; raise TypeError('Time-dependent Hamiltonian list must have two terms.'); if (not isinstance(H_func[0], (list, np.ndarray))) or \; (len(H_func[0]) <= 1):; raise TypeError('Time-dependent Hamiltonians must be a list with two '; + 'or more terms'); if (not isinstance(H_func[1], (list, np.ndarray))) or \; (len(H_func[1]) != (len(H_func[0]) - 1)):; raise TypeError('Time-dependent coefficients must be list with ' +; 'length N-1 where N is the number of ' +; 'Hamiltonian terms.'); tflag = 1; if opt.rhs_reuse and config.tdfunc is None:; print(""No previous time-dependent RHS found.""); print(""Generating one for you...""); rhs_generate(H_func, args); lenh = len(H_func[0]); if opt.tidy:; H_func[0] = [(H_func[0][k]).tidyup() for k in range(lenh)]; # create data arrays for time-dependent RHS function; Hdata = [-1.0j * H_func[0][k].data.data for k in range(lenh)]; Hinds = [H_func[0][k].data.indices for k in range(lenh)]; Hptrs = [H_func[0][k].data.indptr for k in range(lenh)]; # setup ode args string; string = """"; for k in range(lenh):; string += (""Hdata["" + str(k) + ""], Hinds["" + str(k) +; ""], Hptrs["" + str(k) + ""],""). if args:; td_consts = args.items(); for elem in td_consts:; string += str(elem[1]); if elem != td_consts[-1]:; string += ("",""). # run code generator; if not opt.rhs_reuse or config.tdfunc is None:; if opt.rhs_filename is None:; config.tdname = ""rhs"" + str(os.",MatchSource.WIKI,docs/4.2/modules/qutip/sesolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/sesolve.html
https://qutip.org/docs/4.2/modules/qutip/sesolve.html:14404,Integrability,depend,dependent,14404,"ion evolution using a ODE solver (unitary quantum evolution), for; # time dependent hamiltonians; #; def _sesolve_list_td(H_func, psi0, tlist, e_ops, args, opt, progress_bar):; """"""!; Evolve the wave function using an ODE solver with time-dependent; Hamiltonian.; """""". if debug:; print(inspect.stack()[0][3]). if not isket(psi0):; raise TypeError(""psi0 must be a ket""). #; # configure time-dependent terms and setup ODE solver; #; if len(H_func) != 2:; raise TypeError('Time-dependent Hamiltonian list must have two terms.'); if (not isinstance(H_func[0], (list, np.ndarray))) or \; (len(H_func[0]) <= 1):; raise TypeError('Time-dependent Hamiltonians must be a list with two '; + 'or more terms'); if (not isinstance(H_func[1], (list, np.ndarray))) or \; (len(H_func[1]) != (len(H_func[0]) - 1)):; raise TypeError('Time-dependent coefficients must be list with ' +; 'length N-1 where N is the number of ' +; 'Hamiltonian terms.'); tflag = 1; if opt.rhs_reuse and config.tdfunc is None:; print(""No previous time-dependent RHS found.""); print(""Generating one for you...""); rhs_generate(H_func, args); lenh = len(H_func[0]); if opt.tidy:; H_func[0] = [(H_func[0][k]).tidyup() for k in range(lenh)]; # create data arrays for time-dependent RHS function; Hdata = [-1.0j * H_func[0][k].data.data for k in range(lenh)]; Hinds = [H_func[0][k].data.indices for k in range(lenh)]; Hptrs = [H_func[0][k].data.indptr for k in range(lenh)]; # setup ode args string; string = """"; for k in range(lenh):; string += (""Hdata["" + str(k) + ""], Hinds["" + str(k) +; ""], Hptrs["" + str(k) + ""],""). if args:; td_consts = args.items(); for elem in td_consts:; string += str(elem[1]); if elem != td_consts[-1]:; string += ("",""). # run code generator; if not opt.rhs_reuse or config.tdfunc is None:; if opt.rhs_filename is None:; config.tdname = ""rhs"" + str(os.getpid()) + str(config.cgen_num); else:; config.tdname = opt.rhs_filename; cgen = Codegen(h_terms=n_L_terms, h_tdterms=Lcoeff, args=args,; config=config); cgen.generate",MatchSource.WIKI,docs/4.2/modules/qutip/sesolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/sesolve.html
https://qutip.org/docs/4.2/modules/qutip/sesolve.html:14619,Integrability,depend,dependent,14619," an ODE solver with time-dependent; Hamiltonian.; """""". if debug:; print(inspect.stack()[0][3]). if not isket(psi0):; raise TypeError(""psi0 must be a ket""). #; # configure time-dependent terms and setup ODE solver; #; if len(H_func) != 2:; raise TypeError('Time-dependent Hamiltonian list must have two terms.'); if (not isinstance(H_func[0], (list, np.ndarray))) or \; (len(H_func[0]) <= 1):; raise TypeError('Time-dependent Hamiltonians must be a list with two '; + 'or more terms'); if (not isinstance(H_func[1], (list, np.ndarray))) or \; (len(H_func[1]) != (len(H_func[0]) - 1)):; raise TypeError('Time-dependent coefficients must be list with ' +; 'length N-1 where N is the number of ' +; 'Hamiltonian terms.'); tflag = 1; if opt.rhs_reuse and config.tdfunc is None:; print(""No previous time-dependent RHS found.""); print(""Generating one for you...""); rhs_generate(H_func, args); lenh = len(H_func[0]); if opt.tidy:; H_func[0] = [(H_func[0][k]).tidyup() for k in range(lenh)]; # create data arrays for time-dependent RHS function; Hdata = [-1.0j * H_func[0][k].data.data for k in range(lenh)]; Hinds = [H_func[0][k].data.indices for k in range(lenh)]; Hptrs = [H_func[0][k].data.indptr for k in range(lenh)]; # setup ode args string; string = """"; for k in range(lenh):; string += (""Hdata["" + str(k) + ""], Hinds["" + str(k) +; ""], Hptrs["" + str(k) + ""],""). if args:; td_consts = args.items(); for elem in td_consts:; string += str(elem[1]); if elem != td_consts[-1]:; string += ("",""). # run code generator; if not opt.rhs_reuse or config.tdfunc is None:; if opt.rhs_filename is None:; config.tdname = ""rhs"" + str(os.getpid()) + str(config.cgen_num); else:; config.tdname = opt.rhs_filename; cgen = Codegen(h_terms=n_L_terms, h_tdterms=Lcoeff, args=args,; config=config); cgen.generate(config.tdname + "".pyx""). code = compile('from ' + config.tdname + ' import cy_td_ode_rhs',; '<string>', 'exec'); exec(code, globals()); config.tdfunc = cy_td_ode_rhs; #; # setup integrator; #; initial_vector = p",MatchSource.WIKI,docs/4.2/modules/qutip/sesolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/sesolve.html
https://qutip.org/docs/4.2/modules/qutip/sesolve.html:15573,Integrability,integrat,integrator,15573," range(lenh)]; # create data arrays for time-dependent RHS function; Hdata = [-1.0j * H_func[0][k].data.data for k in range(lenh)]; Hinds = [H_func[0][k].data.indices for k in range(lenh)]; Hptrs = [H_func[0][k].data.indptr for k in range(lenh)]; # setup ode args string; string = """"; for k in range(lenh):; string += (""Hdata["" + str(k) + ""], Hinds["" + str(k) +; ""], Hptrs["" + str(k) + ""],""). if args:; td_consts = args.items(); for elem in td_consts:; string += str(elem[1]); if elem != td_consts[-1]:; string += ("",""). # run code generator; if not opt.rhs_reuse or config.tdfunc is None:; if opt.rhs_filename is None:; config.tdname = ""rhs"" + str(os.getpid()) + str(config.cgen_num); else:; config.tdname = opt.rhs_filename; cgen = Codegen(h_terms=n_L_terms, h_tdterms=Lcoeff, args=args,; config=config); cgen.generate(config.tdname + "".pyx""). code = compile('from ' + config.tdname + ' import cy_td_ode_rhs',; '<string>', 'exec'); exec(code, globals()); config.tdfunc = cy_td_ode_rhs; #; # setup integrator; #; initial_vector = psi0.full().ravel(); r = scipy.integrate.ode(config.tdfunc); r.set_integrator('zvode', method=opt.method, order=opt.order,; atol=opt.atol, rtol=opt.rtol, nsteps=opt.nsteps,; first_step=opt.first_step, min_step=opt.min_step,; max_step=opt.max_step); r.set_initial_value(initial_vector, tlist[0]); code = compile('r.set_f_params(' + string + ')', '<string>', 'exec'); exec(code). #; # call generic ODE code; #; return _generic_ode_solve(r, psi0, tlist, e_ops, opt, progress_bar; , dims=psi0.dims). # -----------------------------------------------------------------------------; # Wave function evolution using a ODE solver (unitary quantum evolution), for; # time dependent hamiltonians; #; def _sesolve_func_td(H_func, psi0, tlist, e_ops, args, opt, progress_bar):; """"""!; Evolve the wave function using an ODE solver with time-dependent; Hamiltonian.; """""". if debug:; print(inspect.stack()[0][3]). if not isket(psi0):; raise TypeError(""psi0 must be a ket""). #; # setup ",MatchSource.WIKI,docs/4.2/modules/qutip/sesolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/sesolve.html
https://qutip.org/docs/4.2/modules/qutip/sesolve.html:15636,Integrability,integrat,integrate,15636,"; Hdata = [-1.0j * H_func[0][k].data.data for k in range(lenh)]; Hinds = [H_func[0][k].data.indices for k in range(lenh)]; Hptrs = [H_func[0][k].data.indptr for k in range(lenh)]; # setup ode args string; string = """"; for k in range(lenh):; string += (""Hdata["" + str(k) + ""], Hinds["" + str(k) +; ""], Hptrs["" + str(k) + ""],""). if args:; td_consts = args.items(); for elem in td_consts:; string += str(elem[1]); if elem != td_consts[-1]:; string += ("",""). # run code generator; if not opt.rhs_reuse or config.tdfunc is None:; if opt.rhs_filename is None:; config.tdname = ""rhs"" + str(os.getpid()) + str(config.cgen_num); else:; config.tdname = opt.rhs_filename; cgen = Codegen(h_terms=n_L_terms, h_tdterms=Lcoeff, args=args,; config=config); cgen.generate(config.tdname + "".pyx""). code = compile('from ' + config.tdname + ' import cy_td_ode_rhs',; '<string>', 'exec'); exec(code, globals()); config.tdfunc = cy_td_ode_rhs; #; # setup integrator; #; initial_vector = psi0.full().ravel(); r = scipy.integrate.ode(config.tdfunc); r.set_integrator('zvode', method=opt.method, order=opt.order,; atol=opt.atol, rtol=opt.rtol, nsteps=opt.nsteps,; first_step=opt.first_step, min_step=opt.min_step,; max_step=opt.max_step); r.set_initial_value(initial_vector, tlist[0]); code = compile('r.set_f_params(' + string + ')', '<string>', 'exec'); exec(code). #; # call generic ODE code; #; return _generic_ode_solve(r, psi0, tlist, e_ops, opt, progress_bar; , dims=psi0.dims). # -----------------------------------------------------------------------------; # Wave function evolution using a ODE solver (unitary quantum evolution), for; # time dependent hamiltonians; #; def _sesolve_func_td(H_func, psi0, tlist, e_ops, args, opt, progress_bar):; """"""!; Evolve the wave function using an ODE solver with time-dependent; Hamiltonian.; """""". if debug:; print(inspect.stack()[0][3]). if not isket(psi0):; raise TypeError(""psi0 must be a ket""). #; # setup integrator; #; new_args = None. if type(args) is dict:; new_args = ",MatchSource.WIKI,docs/4.2/modules/qutip/sesolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/sesolve.html
https://qutip.org/docs/4.2/modules/qutip/sesolve.html:16268,Integrability,depend,dependent,16268,"ame = opt.rhs_filename; cgen = Codegen(h_terms=n_L_terms, h_tdterms=Lcoeff, args=args,; config=config); cgen.generate(config.tdname + "".pyx""). code = compile('from ' + config.tdname + ' import cy_td_ode_rhs',; '<string>', 'exec'); exec(code, globals()); config.tdfunc = cy_td_ode_rhs; #; # setup integrator; #; initial_vector = psi0.full().ravel(); r = scipy.integrate.ode(config.tdfunc); r.set_integrator('zvode', method=opt.method, order=opt.order,; atol=opt.atol, rtol=opt.rtol, nsteps=opt.nsteps,; first_step=opt.first_step, min_step=opt.min_step,; max_step=opt.max_step); r.set_initial_value(initial_vector, tlist[0]); code = compile('r.set_f_params(' + string + ')', '<string>', 'exec'); exec(code). #; # call generic ODE code; #; return _generic_ode_solve(r, psi0, tlist, e_ops, opt, progress_bar; , dims=psi0.dims). # -----------------------------------------------------------------------------; # Wave function evolution using a ODE solver (unitary quantum evolution), for; # time dependent hamiltonians; #; def _sesolve_func_td(H_func, psi0, tlist, e_ops, args, opt, progress_bar):; """"""!; Evolve the wave function using an ODE solver with time-dependent; Hamiltonian.; """""". if debug:; print(inspect.stack()[0][3]). if not isket(psi0):; raise TypeError(""psi0 must be a ket""). #; # setup integrator; #; new_args = None. if type(args) is dict:; new_args = {}; for key in args:; if isinstance(args[key], Qobj):; new_args[key] = args[key].data; else:; new_args[key] = args[key]. elif type(args) is list or type(args) is tuple:; new_args = []; for arg in args:; if isinstance(arg, Qobj):; new_args.append(arg.data); else:; new_args.append(arg). if type(args) is tuple:; new_args = tuple(new_args); else:; if isinstance(args, Qobj):; new_args = args.data; else:; new_args = args. initial_vector = psi0.full().ravel(). if not opt.rhs_with_state:; r = scipy.integrate.ode(cy_ode_psi_func_td); else:; r = scipy.integrate.ode(cy_ode_psi_func_td_with_state). r.set_integrator('zvode', method=opt.method",MatchSource.WIKI,docs/4.2/modules/qutip/sesolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/sesolve.html
https://qutip.org/docs/4.2/modules/qutip/sesolve.html:16432,Integrability,depend,dependent,16432,"ame = opt.rhs_filename; cgen = Codegen(h_terms=n_L_terms, h_tdterms=Lcoeff, args=args,; config=config); cgen.generate(config.tdname + "".pyx""). code = compile('from ' + config.tdname + ' import cy_td_ode_rhs',; '<string>', 'exec'); exec(code, globals()); config.tdfunc = cy_td_ode_rhs; #; # setup integrator; #; initial_vector = psi0.full().ravel(); r = scipy.integrate.ode(config.tdfunc); r.set_integrator('zvode', method=opt.method, order=opt.order,; atol=opt.atol, rtol=opt.rtol, nsteps=opt.nsteps,; first_step=opt.first_step, min_step=opt.min_step,; max_step=opt.max_step); r.set_initial_value(initial_vector, tlist[0]); code = compile('r.set_f_params(' + string + ')', '<string>', 'exec'); exec(code). #; # call generic ODE code; #; return _generic_ode_solve(r, psi0, tlist, e_ops, opt, progress_bar; , dims=psi0.dims). # -----------------------------------------------------------------------------; # Wave function evolution using a ODE solver (unitary quantum evolution), for; # time dependent hamiltonians; #; def _sesolve_func_td(H_func, psi0, tlist, e_ops, args, opt, progress_bar):; """"""!; Evolve the wave function using an ODE solver with time-dependent; Hamiltonian.; """""". if debug:; print(inspect.stack()[0][3]). if not isket(psi0):; raise TypeError(""psi0 must be a ket""). #; # setup integrator; #; new_args = None. if type(args) is dict:; new_args = {}; for key in args:; if isinstance(args[key], Qobj):; new_args[key] = args[key].data; else:; new_args[key] = args[key]. elif type(args) is list or type(args) is tuple:; new_args = []; for arg in args:; if isinstance(arg, Qobj):; new_args.append(arg.data); else:; new_args.append(arg). if type(args) is tuple:; new_args = tuple(new_args); else:; if isinstance(args, Qobj):; new_args = args.data; else:; new_args = args. initial_vector = psi0.full().ravel(). if not opt.rhs_with_state:; r = scipy.integrate.ode(cy_ode_psi_func_td); else:; r = scipy.integrate.ode(cy_ode_psi_func_td_with_state). r.set_integrator('zvode', method=opt.method",MatchSource.WIKI,docs/4.2/modules/qutip/sesolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/sesolve.html
https://qutip.org/docs/4.2/modules/qutip/sesolve.html:16574,Integrability,integrat,integrator,16574,"; #; initial_vector = psi0.full().ravel(); r = scipy.integrate.ode(config.tdfunc); r.set_integrator('zvode', method=opt.method, order=opt.order,; atol=opt.atol, rtol=opt.rtol, nsteps=opt.nsteps,; first_step=opt.first_step, min_step=opt.min_step,; max_step=opt.max_step); r.set_initial_value(initial_vector, tlist[0]); code = compile('r.set_f_params(' + string + ')', '<string>', 'exec'); exec(code). #; # call generic ODE code; #; return _generic_ode_solve(r, psi0, tlist, e_ops, opt, progress_bar; , dims=psi0.dims). # -----------------------------------------------------------------------------; # Wave function evolution using a ODE solver (unitary quantum evolution), for; # time dependent hamiltonians; #; def _sesolve_func_td(H_func, psi0, tlist, e_ops, args, opt, progress_bar):; """"""!; Evolve the wave function using an ODE solver with time-dependent; Hamiltonian.; """""". if debug:; print(inspect.stack()[0][3]). if not isket(psi0):; raise TypeError(""psi0 must be a ket""). #; # setup integrator; #; new_args = None. if type(args) is dict:; new_args = {}; for key in args:; if isinstance(args[key], Qobj):; new_args[key] = args[key].data; else:; new_args[key] = args[key]. elif type(args) is list or type(args) is tuple:; new_args = []; for arg in args:; if isinstance(arg, Qobj):; new_args.append(arg.data); else:; new_args.append(arg). if type(args) is tuple:; new_args = tuple(new_args); else:; if isinstance(args, Qobj):; new_args = args.data; else:; new_args = args. initial_vector = psi0.full().ravel(). if not opt.rhs_with_state:; r = scipy.integrate.ode(cy_ode_psi_func_td); else:; r = scipy.integrate.ode(cy_ode_psi_func_td_with_state). r.set_integrator('zvode', method=opt.method, order=opt.order,; atol=opt.atol, rtol=opt.rtol, nsteps=opt.nsteps,; first_step=opt.first_step, min_step=opt.min_step,; max_step=opt.max_step); r.set_initial_value(initial_vector, tlist[0]); r.set_f_params(H_func, new_args). #; # call generic ODE code; #; return _generic_ode_solve(r, psi0, tlist, e_ops, ",MatchSource.WIKI,docs/4.2/modules/qutip/sesolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/sesolve.html
https://qutip.org/docs/4.2/modules/qutip/sesolve.html:17137,Integrability,integrat,integrate,17137,"--------------------------------------; # Wave function evolution using a ODE solver (unitary quantum evolution), for; # time dependent hamiltonians; #; def _sesolve_func_td(H_func, psi0, tlist, e_ops, args, opt, progress_bar):; """"""!; Evolve the wave function using an ODE solver with time-dependent; Hamiltonian.; """""". if debug:; print(inspect.stack()[0][3]). if not isket(psi0):; raise TypeError(""psi0 must be a ket""). #; # setup integrator; #; new_args = None. if type(args) is dict:; new_args = {}; for key in args:; if isinstance(args[key], Qobj):; new_args[key] = args[key].data; else:; new_args[key] = args[key]. elif type(args) is list or type(args) is tuple:; new_args = []; for arg in args:; if isinstance(arg, Qobj):; new_args.append(arg.data); else:; new_args.append(arg). if type(args) is tuple:; new_args = tuple(new_args); else:; if isinstance(args, Qobj):; new_args = args.data; else:; new_args = args. initial_vector = psi0.full().ravel(). if not opt.rhs_with_state:; r = scipy.integrate.ode(cy_ode_psi_func_td); else:; r = scipy.integrate.ode(cy_ode_psi_func_td_with_state). r.set_integrator('zvode', method=opt.method, order=opt.order,; atol=opt.atol, rtol=opt.rtol, nsteps=opt.nsteps,; first_step=opt.first_step, min_step=opt.min_step,; max_step=opt.max_step); r.set_initial_value(initial_vector, tlist[0]); r.set_f_params(H_func, new_args). #; # call generic ODE code; #; return _generic_ode_solve(r, psi0, tlist, e_ops, opt, progress_bar,; dims=psi0.dims). #; # evaluate dpsi(t)/dt for time-dependent hamiltonian; #; def _ode_psi_func_td(t, psi, H_func, args):; H = H_func(t, args); return -1j * (H * psi). def _ode_psi_func_td_with_state(t, psi, H_func, args):; H = H_func(t, psi, args); return -1j * (H * psi). # -----------------------------------------------------------------------------; # Solve an ODE which solver parameters already setup (r). Calculate the; # required expectation values or invoke callback function at each time step.; #; def _generic_ode_solve(r, psi0",MatchSource.WIKI,docs/4.2/modules/qutip/sesolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/sesolve.html
https://qutip.org/docs/4.2/modules/qutip/sesolve.html:17189,Integrability,integrat,integrate,17189,"ion evolution using a ODE solver (unitary quantum evolution), for; # time dependent hamiltonians; #; def _sesolve_func_td(H_func, psi0, tlist, e_ops, args, opt, progress_bar):; """"""!; Evolve the wave function using an ODE solver with time-dependent; Hamiltonian.; """""". if debug:; print(inspect.stack()[0][3]). if not isket(psi0):; raise TypeError(""psi0 must be a ket""). #; # setup integrator; #; new_args = None. if type(args) is dict:; new_args = {}; for key in args:; if isinstance(args[key], Qobj):; new_args[key] = args[key].data; else:; new_args[key] = args[key]. elif type(args) is list or type(args) is tuple:; new_args = []; for arg in args:; if isinstance(arg, Qobj):; new_args.append(arg.data); else:; new_args.append(arg). if type(args) is tuple:; new_args = tuple(new_args); else:; if isinstance(args, Qobj):; new_args = args.data; else:; new_args = args. initial_vector = psi0.full().ravel(). if not opt.rhs_with_state:; r = scipy.integrate.ode(cy_ode_psi_func_td); else:; r = scipy.integrate.ode(cy_ode_psi_func_td_with_state). r.set_integrator('zvode', method=opt.method, order=opt.order,; atol=opt.atol, rtol=opt.rtol, nsteps=opt.nsteps,; first_step=opt.first_step, min_step=opt.min_step,; max_step=opt.max_step); r.set_initial_value(initial_vector, tlist[0]); r.set_f_params(H_func, new_args). #; # call generic ODE code; #; return _generic_ode_solve(r, psi0, tlist, e_ops, opt, progress_bar,; dims=psi0.dims). #; # evaluate dpsi(t)/dt for time-dependent hamiltonian; #; def _ode_psi_func_td(t, psi, H_func, args):; H = H_func(t, args); return -1j * (H * psi). def _ode_psi_func_td_with_state(t, psi, H_func, args):; H = H_func(t, psi, args); return -1j * (H * psi). # -----------------------------------------------------------------------------; # Solve an ODE which solver parameters already setup (r). Calculate the; # required expectation values or invoke callback function at each time step.; #; def _generic_ode_solve(r, psi0, tlist, e_ops, opt, progress_bar, dims=None):; """""";",MatchSource.WIKI,docs/4.2/modules/qutip/sesolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/sesolve.html
https://qutip.org/docs/4.2/modules/qutip/sesolve.html:17655,Integrability,depend,dependent,17655," new_args[key] = args[key].data; else:; new_args[key] = args[key]. elif type(args) is list or type(args) is tuple:; new_args = []; for arg in args:; if isinstance(arg, Qobj):; new_args.append(arg.data); else:; new_args.append(arg). if type(args) is tuple:; new_args = tuple(new_args); else:; if isinstance(args, Qobj):; new_args = args.data; else:; new_args = args. initial_vector = psi0.full().ravel(). if not opt.rhs_with_state:; r = scipy.integrate.ode(cy_ode_psi_func_td); else:; r = scipy.integrate.ode(cy_ode_psi_func_td_with_state). r.set_integrator('zvode', method=opt.method, order=opt.order,; atol=opt.atol, rtol=opt.rtol, nsteps=opt.nsteps,; first_step=opt.first_step, min_step=opt.min_step,; max_step=opt.max_step); r.set_initial_value(initial_vector, tlist[0]); r.set_f_params(H_func, new_args). #; # call generic ODE code; #; return _generic_ode_solve(r, psi0, tlist, e_ops, opt, progress_bar,; dims=psi0.dims). #; # evaluate dpsi(t)/dt for time-dependent hamiltonian; #; def _ode_psi_func_td(t, psi, H_func, args):; H = H_func(t, args); return -1j * (H * psi). def _ode_psi_func_td_with_state(t, psi, H_func, args):; H = H_func(t, psi, args); return -1j * (H * psi). # -----------------------------------------------------------------------------; # Solve an ODE which solver parameters already setup (r). Calculate the; # required expectation values or invoke callback function at each time step.; #; def _generic_ode_solve(r, psi0, tlist, e_ops, opt, progress_bar, dims=None):; """"""; Internal function for solving ODEs.; """"""; if opt.normalize_output:; state_norm_func = norm; else:; state_norm_func = None; ; ; #; # prepare output array; #; n_tsteps = len(tlist); output = Result(); output.solver = ""sesolve""; output.times = tlist. if opt.store_states:; output.states = []. if isinstance(e_ops, types.FunctionType):; n_expt_op = 0; expt_callback = True. elif isinstance(e_ops, list):. n_expt_op = len(e_ops); expt_callback = False. if n_expt_op == 0:; # fallback on storing states; ou",MatchSource.WIKI,docs/4.2/modules/qutip/sesolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/sesolve.html
https://qutip.org/docs/4.2/modules/qutip/sesolve.html:19197,Integrability,integrat,integration,19197,"list, e_ops, opt, progress_bar, dims=None):; """"""; Internal function for solving ODEs.; """"""; if opt.normalize_output:; state_norm_func = norm; else:; state_norm_func = None; ; ; #; # prepare output array; #; n_tsteps = len(tlist); output = Result(); output.solver = ""sesolve""; output.times = tlist. if opt.store_states:; output.states = []. if isinstance(e_ops, types.FunctionType):; n_expt_op = 0; expt_callback = True. elif isinstance(e_ops, list):. n_expt_op = len(e_ops); expt_callback = False. if n_expt_op == 0:; # fallback on storing states; output.states = []; opt.store_states = True; else:; output.expect = []; output.num_expect = n_expt_op; for op in e_ops:; if op.isherm:; output.expect.append(np.zeros(n_tsteps)); else:; output.expect.append(np.zeros(n_tsteps, dtype=complex)); else:; raise TypeError(""Expectation parameter must be a list or a function""). #; # start evolution; #; progress_bar.start(n_tsteps). dt = np.diff(tlist); for t_idx, t in enumerate(tlist):; progress_bar.update(t_idx). if not r.successful():; raise Exception(""ODE integration error: Try to increase ""; ""the allowed number of substeps by increasing ""; ""the nsteps parameter in the Options class.""). if state_norm_func:; data = r.y / state_norm_func(r.y); r.set_initial_value(data, r.t). if opt.store_states:; output.states.append(Qobj(r.y, dims=dims)). if expt_callback:; # use callback method; e_ops(t, Qobj(r.y, dims=psi0.dims)). for m in range(n_expt_op):; output.expect[m][t_idx] = cy_expect_psi(e_ops[m].data,; r.y, e_ops[m].isherm). if t_idx < n_tsteps - 1:; r.integrate(r.t + dt[t_idx]). progress_bar.finished(). if not opt.rhs_reuse and config.tdname is not None:; try:; os.remove(config.tdname + "".pyx""); except:; pass. if opt.store_final_state:; output.final_state = Qobj(r.y, dims=dims). return output.  Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, and A.L. Grimsmo.; Last updated on Jan 17, 2018. . Built with Sphinx using a theme provided by Read the Docs. . ",MatchSource.WIKI,docs/4.2/modules/qutip/sesolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/sesolve.html
https://qutip.org/docs/4.2/modules/qutip/sesolve.html:19699,Integrability,integrat,integrate,19699,"list, e_ops, opt, progress_bar, dims=None):; """"""; Internal function for solving ODEs.; """"""; if opt.normalize_output:; state_norm_func = norm; else:; state_norm_func = None; ; ; #; # prepare output array; #; n_tsteps = len(tlist); output = Result(); output.solver = ""sesolve""; output.times = tlist. if opt.store_states:; output.states = []. if isinstance(e_ops, types.FunctionType):; n_expt_op = 0; expt_callback = True. elif isinstance(e_ops, list):. n_expt_op = len(e_ops); expt_callback = False. if n_expt_op == 0:; # fallback on storing states; output.states = []; opt.store_states = True; else:; output.expect = []; output.num_expect = n_expt_op; for op in e_ops:; if op.isherm:; output.expect.append(np.zeros(n_tsteps)); else:; output.expect.append(np.zeros(n_tsteps, dtype=complex)); else:; raise TypeError(""Expectation parameter must be a list or a function""). #; # start evolution; #; progress_bar.start(n_tsteps). dt = np.diff(tlist); for t_idx, t in enumerate(tlist):; progress_bar.update(t_idx). if not r.successful():; raise Exception(""ODE integration error: Try to increase ""; ""the allowed number of substeps by increasing ""; ""the nsteps parameter in the Options class.""). if state_norm_func:; data = r.y / state_norm_func(r.y); r.set_initial_value(data, r.t). if opt.store_states:; output.states.append(Qobj(r.y, dims=dims)). if expt_callback:; # use callback method; e_ops(t, Qobj(r.y, dims=psi0.dims)). for m in range(n_expt_op):; output.expect[m][t_idx] = cy_expect_psi(e_ops[m].data,; r.y, e_ops[m].isherm). if t_idx < n_tsteps - 1:; r.integrate(r.t + dt[t_idx]). progress_bar.finished(). if not opt.rhs_reuse and config.tdname is not None:; try:; os.remove(config.tdname + "".pyx""); except:; pass. if opt.store_final_state:; output.final_state = Qobj(r.y, dims=dims). return output.  Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, and A.L. Grimsmo.; Last updated on Jan 17, 2018. . Built with Sphinx using a theme provided by Read the Docs. . ",MatchSource.WIKI,docs/4.2/modules/qutip/sesolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/sesolve.html
https://qutip.org/docs/4.2/modules/qutip/sesolve.html:2438,Modifiability,config,config,2438,"NT SHALL THE COPYRIGHT; # HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,; # SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT; # LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,; # DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY; # THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT; # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE; # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.; ###############################################################################; """"""; This module provides solvers for the unitary Schrodinger equation.; """""". __all__ = ['sesolve']. import os; import types; from functools import partial; import numpy as np; import scipy.integrate; from scipy.linalg import norm; import qutip.settings as qset; from qutip.qobj import Qobj, isket; from qutip.rhs_generate import rhs_generate; from qutip.solver import Result, Options, config, _solver_safety_check; from qutip.rhs_generate import _td_format_check, _td_wrap_array_str; from qutip.interpolate import Cubic_Spline; from qutip.settings import debug; from qutip.cy.spmatfuncs import (cy_expect_psi, cy_ode_rhs,; cy_ode_psi_func_td,; cy_ode_psi_func_td_with_state,; spmvpy_csr); from qutip.cy.codegen import Codegen; from qutip.cy.utilities import _cython_build_cleanup. from qutip.ui.progressbar import BaseProgressBar; from qutip.cy.openmp.utilities import check_use_openmp, openmp_components. if qset.has_openmp:; from qutip.cy.openmp.parfuncs import cy_ode_rhs_openmp. if debug:; import inspect. [docs]def sesolve(H, rho0, tlist, e_ops=[], args={}, options=None,; progress_bar=BaseProgressBar(),; _safe_mode=True):; """"""; Schrodinger equation evolution of a state vector for a given Hamiltonian. Evolve the state vector or density matrix (`rho0`) using a given; Hamiltonian (`H`), by integrating the set of ordinary differential; equations that define the system. The output is",MatchSource.WIKI,docs/4.2/modules/qutip/sesolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/sesolve.html
https://qutip.org/docs/4.2/modules/qutip/sesolve.html:5266,Modifiability,config,config,5266,"deoptions`; with options for the ODE solver. Returns; -------. output: :class:`qutip.solver`. An instance of the class :class:`qutip.solver`, which contains either; an *array* of expectation values for the times specified by `tlist`, or; an *array* or state vectors or density matrices corresponding to the; times in `tlist` [if `e_ops` is an empty list], or; nothing if a callback function was given inplace of operators for; which to calculate the expectation values. """"""; if isinstance(e_ops, Qobj):; e_ops = [e_ops]. if isinstance(e_ops, dict):; e_ops_dict = e_ops; e_ops = [e for e in e_ops.values()]; else:; e_ops_dict = None; ; if _safe_mode:; _solver_safety_check(H, rho0, c_ops=[], e_ops=e_ops, args=args); ; # convert array based time-dependence to string format; H, _, args = _td_wrap_array_str(H, [], args, tlist); # check for type (if any) of time-dependent inputs; n_const, n_func, n_str = _td_format_check(H, []). if options is None:; options = Options(). if (not options.rhs_reuse) or (not config.tdfunc):; # reset config time-dependence flags to default values; config.reset(); ; #check if should use OPENMP; check_use_openmp(options). if n_func > 0:; res = _sesolve_list_func_td(H, rho0, tlist, e_ops, args, options,; progress_bar). elif n_str > 0:; res = _sesolve_list_str_td(H, rho0, tlist, e_ops, args, options,; progress_bar). elif isinstance(H, (types.FunctionType,; types.BuiltinFunctionType,; partial)):; res = _sesolve_func_td(H, rho0, tlist, e_ops, args, options,; progress_bar). else:; res = _sesolve_const(H, rho0, tlist, e_ops, args, options,; progress_bar). if e_ops_dict:; res.expect = {e: res.expect[n]; for n, e in enumerate(e_ops_dict.keys())}. return res. # -----------------------------------------------------------------------------; # A time-dependent unitary wavefunction equation on the list-function format; #; def _sesolve_list_func_td(H_list, psi0, tlist, e_ops, args, opt,; progress_bar):; """"""; Internal function for solving the master equation. See meso",MatchSource.WIKI,docs/4.2/modules/qutip/sesolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/sesolve.html
https://qutip.org/docs/4.2/modules/qutip/sesolve.html:5291,Modifiability,config,config,5291,"rns; -------. output: :class:`qutip.solver`. An instance of the class :class:`qutip.solver`, which contains either; an *array* of expectation values for the times specified by `tlist`, or; an *array* or state vectors or density matrices corresponding to the; times in `tlist` [if `e_ops` is an empty list], or; nothing if a callback function was given inplace of operators for; which to calculate the expectation values. """"""; if isinstance(e_ops, Qobj):; e_ops = [e_ops]. if isinstance(e_ops, dict):; e_ops_dict = e_ops; e_ops = [e for e in e_ops.values()]; else:; e_ops_dict = None; ; if _safe_mode:; _solver_safety_check(H, rho0, c_ops=[], e_ops=e_ops, args=args); ; # convert array based time-dependence to string format; H, _, args = _td_wrap_array_str(H, [], args, tlist); # check for type (if any) of time-dependent inputs; n_const, n_func, n_str = _td_format_check(H, []). if options is None:; options = Options(). if (not options.rhs_reuse) or (not config.tdfunc):; # reset config time-dependence flags to default values; config.reset(); ; #check if should use OPENMP; check_use_openmp(options). if n_func > 0:; res = _sesolve_list_func_td(H, rho0, tlist, e_ops, args, options,; progress_bar). elif n_str > 0:; res = _sesolve_list_str_td(H, rho0, tlist, e_ops, args, options,; progress_bar). elif isinstance(H, (types.FunctionType,; types.BuiltinFunctionType,; partial)):; res = _sesolve_func_td(H, rho0, tlist, e_ops, args, options,; progress_bar). else:; res = _sesolve_const(H, rho0, tlist, e_ops, args, options,; progress_bar). if e_ops_dict:; res.expect = {e: res.expect[n]; for n, e in enumerate(e_ops_dict.keys())}. return res. # -----------------------------------------------------------------------------; # A time-dependent unitary wavefunction equation on the list-function format; #; def _sesolve_list_func_td(H_list, psi0, tlist, e_ops, args, opt,; progress_bar):; """"""; Internal function for solving the master equation. See mesolve for usage.; """""". if debug:; print(inspect.stac",MatchSource.WIKI,docs/4.2/modules/qutip/sesolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/sesolve.html
https://qutip.org/docs/4.2/modules/qutip/sesolve.html:5339,Modifiability,config,config,5339,"rns; -------. output: :class:`qutip.solver`. An instance of the class :class:`qutip.solver`, which contains either; an *array* of expectation values for the times specified by `tlist`, or; an *array* or state vectors or density matrices corresponding to the; times in `tlist` [if `e_ops` is an empty list], or; nothing if a callback function was given inplace of operators for; which to calculate the expectation values. """"""; if isinstance(e_ops, Qobj):; e_ops = [e_ops]. if isinstance(e_ops, dict):; e_ops_dict = e_ops; e_ops = [e for e in e_ops.values()]; else:; e_ops_dict = None; ; if _safe_mode:; _solver_safety_check(H, rho0, c_ops=[], e_ops=e_ops, args=args); ; # convert array based time-dependence to string format; H, _, args = _td_wrap_array_str(H, [], args, tlist); # check for type (if any) of time-dependent inputs; n_const, n_func, n_str = _td_format_check(H, []). if options is None:; options = Options(). if (not options.rhs_reuse) or (not config.tdfunc):; # reset config time-dependence flags to default values; config.reset(); ; #check if should use OPENMP; check_use_openmp(options). if n_func > 0:; res = _sesolve_list_func_td(H, rho0, tlist, e_ops, args, options,; progress_bar). elif n_str > 0:; res = _sesolve_list_str_td(H, rho0, tlist, e_ops, args, options,; progress_bar). elif isinstance(H, (types.FunctionType,; types.BuiltinFunctionType,; partial)):; res = _sesolve_func_td(H, rho0, tlist, e_ops, args, options,; progress_bar). else:; res = _sesolve_const(H, rho0, tlist, e_ops, args, options,; progress_bar). if e_ops_dict:; res.expect = {e: res.expect[n]; for n, e in enumerate(e_ops_dict.keys())}. return res. # -----------------------------------------------------------------------------; # A time-dependent unitary wavefunction equation on the list-function format; #; def _sesolve_list_func_td(H_list, psi0, tlist, e_ops, args, opt,; progress_bar):; """"""; Internal function for solving the master equation. See mesolve for usage.; """""". if debug:; print(inspect.stac",MatchSource.WIKI,docs/4.2/modules/qutip/sesolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/sesolve.html
https://qutip.org/docs/4.2/modules/qutip/sesolve.html:12100,Modifiability,config,config,12100,"pend(L.data.indices); Lptrs.append(L.data.indptr); if isinstance(h_coeff, Cubic_Spline):; Lobj.append(h_coeff.coeffs); Lcoeff.append(h_coeff). # the total number of liouvillian terms (hamiltonian terms +; # collapse operators); n_L_terms = len(Ldata); ; # Check which components should use OPENMP; omp_components = None; if qset.has_openmp:; if opt.use_openmp:; omp_components = openmp_components(Lptrs). #; # setup ode args string: we expand the list Ldata, Linds and Lptrs into; # and explicit list of parameters; #; string_list = []; for k in range(n_L_terms):; string_list.append(""Ldata[%d], Linds[%d], Lptrs[%d]"" % (k, k, k)); # Add object terms to end of ode args string; for k in range(len(Lobj)):; string_list.append(""Lobj[%d]"" % k); ; for name, value in args.items():; if isinstance(value, np.ndarray):; string_list.append(name); else:; string_list.append(str(value)); parameter_string = "","".join(string_list). #; # generate and compile new cython code if necessary; #; if not opt.rhs_reuse or config.tdfunc is None:; if opt.rhs_filename is None:; config.tdname = ""rhs"" + str(os.getpid()) + str(config.cgen_num); else:; config.tdname = opt.rhs_filename; cgen = Codegen(h_terms=n_L_terms, h_tdterms=Lcoeff, args=args,; config=config, use_openmp=opt.use_openmp,; omp_components=omp_components,; omp_threads=opt.openmp_threads); cgen.generate(config.tdname + "".pyx""). code = compile('from ' + config.tdname + ' import cy_td_ode_rhs',; '<string>', 'exec'); exec(code, globals()); config.tdfunc = cy_td_ode_rhs. #; # setup integrator; #; initial_vector = psi0.full().ravel(); r = scipy.integrate.ode(config.tdfunc); r.set_integrator('zvode', method=opt.method, order=opt.order,; atol=opt.atol, rtol=opt.rtol, nsteps=opt.nsteps,; first_step=opt.first_step, min_step=opt.min_step,; max_step=opt.max_step); r.set_initial_value(initial_vector, tlist[0]); code = compile('r.set_f_params(' + parameter_string + ')',; '<string>', 'exec'). exec(code, locals(), args). ; # Remove RHS cython file if necess",MatchSource.WIKI,docs/4.2/modules/qutip/sesolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/sesolve.html
https://qutip.org/docs/4.2/modules/qutip/sesolve.html:12154,Modifiability,config,config,12154,"; if isinstance(h_coeff, Cubic_Spline):; Lobj.append(h_coeff.coeffs); Lcoeff.append(h_coeff). # the total number of liouvillian terms (hamiltonian terms +; # collapse operators); n_L_terms = len(Ldata); ; # Check which components should use OPENMP; omp_components = None; if qset.has_openmp:; if opt.use_openmp:; omp_components = openmp_components(Lptrs). #; # setup ode args string: we expand the list Ldata, Linds and Lptrs into; # and explicit list of parameters; #; string_list = []; for k in range(n_L_terms):; string_list.append(""Ldata[%d], Linds[%d], Lptrs[%d]"" % (k, k, k)); # Add object terms to end of ode args string; for k in range(len(Lobj)):; string_list.append(""Lobj[%d]"" % k); ; for name, value in args.items():; if isinstance(value, np.ndarray):; string_list.append(name); else:; string_list.append(str(value)); parameter_string = "","".join(string_list). #; # generate and compile new cython code if necessary; #; if not opt.rhs_reuse or config.tdfunc is None:; if opt.rhs_filename is None:; config.tdname = ""rhs"" + str(os.getpid()) + str(config.cgen_num); else:; config.tdname = opt.rhs_filename; cgen = Codegen(h_terms=n_L_terms, h_tdterms=Lcoeff, args=args,; config=config, use_openmp=opt.use_openmp,; omp_components=omp_components,; omp_threads=opt.openmp_threads); cgen.generate(config.tdname + "".pyx""). code = compile('from ' + config.tdname + ' import cy_td_ode_rhs',; '<string>', 'exec'); exec(code, globals()); config.tdfunc = cy_td_ode_rhs. #; # setup integrator; #; initial_vector = psi0.full().ravel(); r = scipy.integrate.ode(config.tdfunc); r.set_integrator('zvode', method=opt.method, order=opt.order,; atol=opt.atol, rtol=opt.rtol, nsteps=opt.nsteps,; first_step=opt.first_step, min_step=opt.min_step,; max_step=opt.max_step); r.set_initial_value(initial_vector, tlist[0]); code = compile('r.set_f_params(' + parameter_string + ')',; '<string>', 'exec'). exec(code, locals(), args). ; # Remove RHS cython file if necessary; if not opt.rhs_reuse and config.tdname:; _cy",MatchSource.WIKI,docs/4.2/modules/qutip/sesolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/sesolve.html
https://qutip.org/docs/4.2/modules/qutip/sesolve.html:12201,Modifiability,config,config,12201,"nd(h_coeff.coeffs); Lcoeff.append(h_coeff). # the total number of liouvillian terms (hamiltonian terms +; # collapse operators); n_L_terms = len(Ldata); ; # Check which components should use OPENMP; omp_components = None; if qset.has_openmp:; if opt.use_openmp:; omp_components = openmp_components(Lptrs). #; # setup ode args string: we expand the list Ldata, Linds and Lptrs into; # and explicit list of parameters; #; string_list = []; for k in range(n_L_terms):; string_list.append(""Ldata[%d], Linds[%d], Lptrs[%d]"" % (k, k, k)); # Add object terms to end of ode args string; for k in range(len(Lobj)):; string_list.append(""Lobj[%d]"" % k); ; for name, value in args.items():; if isinstance(value, np.ndarray):; string_list.append(name); else:; string_list.append(str(value)); parameter_string = "","".join(string_list). #; # generate and compile new cython code if necessary; #; if not opt.rhs_reuse or config.tdfunc is None:; if opt.rhs_filename is None:; config.tdname = ""rhs"" + str(os.getpid()) + str(config.cgen_num); else:; config.tdname = opt.rhs_filename; cgen = Codegen(h_terms=n_L_terms, h_tdterms=Lcoeff, args=args,; config=config, use_openmp=opt.use_openmp,; omp_components=omp_components,; omp_threads=opt.openmp_threads); cgen.generate(config.tdname + "".pyx""). code = compile('from ' + config.tdname + ' import cy_td_ode_rhs',; '<string>', 'exec'); exec(code, globals()); config.tdfunc = cy_td_ode_rhs. #; # setup integrator; #; initial_vector = psi0.full().ravel(); r = scipy.integrate.ode(config.tdfunc); r.set_integrator('zvode', method=opt.method, order=opt.order,; atol=opt.atol, rtol=opt.rtol, nsteps=opt.nsteps,; first_step=opt.first_step, min_step=opt.min_step,; max_step=opt.max_step); r.set_initial_value(initial_vector, tlist[0]); code = compile('r.set_f_params(' + parameter_string + ')',; '<string>', 'exec'). exec(code, locals(), args). ; # Remove RHS cython file if necessary; if not opt.rhs_reuse and config.tdname:; _cython_build_cleanup(config.tdname); ; #; # call gene",MatchSource.WIKI,docs/4.2/modules/qutip/sesolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/sesolve.html
https://qutip.org/docs/4.2/modules/qutip/sesolve.html:12226,Modifiability,config,config,12226,"ff.append(h_coeff). # the total number of liouvillian terms (hamiltonian terms +; # collapse operators); n_L_terms = len(Ldata); ; # Check which components should use OPENMP; omp_components = None; if qset.has_openmp:; if opt.use_openmp:; omp_components = openmp_components(Lptrs). #; # setup ode args string: we expand the list Ldata, Linds and Lptrs into; # and explicit list of parameters; #; string_list = []; for k in range(n_L_terms):; string_list.append(""Ldata[%d], Linds[%d], Lptrs[%d]"" % (k, k, k)); # Add object terms to end of ode args string; for k in range(len(Lobj)):; string_list.append(""Lobj[%d]"" % k); ; for name, value in args.items():; if isinstance(value, np.ndarray):; string_list.append(name); else:; string_list.append(str(value)); parameter_string = "","".join(string_list). #; # generate and compile new cython code if necessary; #; if not opt.rhs_reuse or config.tdfunc is None:; if opt.rhs_filename is None:; config.tdname = ""rhs"" + str(os.getpid()) + str(config.cgen_num); else:; config.tdname = opt.rhs_filename; cgen = Codegen(h_terms=n_L_terms, h_tdterms=Lcoeff, args=args,; config=config, use_openmp=opt.use_openmp,; omp_components=omp_components,; omp_threads=opt.openmp_threads); cgen.generate(config.tdname + "".pyx""). code = compile('from ' + config.tdname + ' import cy_td_ode_rhs',; '<string>', 'exec'); exec(code, globals()); config.tdfunc = cy_td_ode_rhs. #; # setup integrator; #; initial_vector = psi0.full().ravel(); r = scipy.integrate.ode(config.tdfunc); r.set_integrator('zvode', method=opt.method, order=opt.order,; atol=opt.atol, rtol=opt.rtol, nsteps=opt.nsteps,; first_step=opt.first_step, min_step=opt.min_step,; max_step=opt.max_step); r.set_initial_value(initial_vector, tlist[0]); code = compile('r.set_f_params(' + parameter_string + ')',; '<string>', 'exec'). exec(code, locals(), args). ; # Remove RHS cython file if necessary; if not opt.rhs_reuse and config.tdname:; _cython_build_cleanup(config.tdname); ; #; # call generic ODE code; #; return ",MatchSource.WIKI,docs/4.2/modules/qutip/sesolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/sesolve.html
https://qutip.org/docs/4.2/modules/qutip/sesolve.html:12324,Modifiability,config,config,12324,"; # collapse operators); n_L_terms = len(Ldata); ; # Check which components should use OPENMP; omp_components = None; if qset.has_openmp:; if opt.use_openmp:; omp_components = openmp_components(Lptrs). #; # setup ode args string: we expand the list Ldata, Linds and Lptrs into; # and explicit list of parameters; #; string_list = []; for k in range(n_L_terms):; string_list.append(""Ldata[%d], Linds[%d], Lptrs[%d]"" % (k, k, k)); # Add object terms to end of ode args string; for k in range(len(Lobj)):; string_list.append(""Lobj[%d]"" % k); ; for name, value in args.items():; if isinstance(value, np.ndarray):; string_list.append(name); else:; string_list.append(str(value)); parameter_string = "","".join(string_list). #; # generate and compile new cython code if necessary; #; if not opt.rhs_reuse or config.tdfunc is None:; if opt.rhs_filename is None:; config.tdname = ""rhs"" + str(os.getpid()) + str(config.cgen_num); else:; config.tdname = opt.rhs_filename; cgen = Codegen(h_terms=n_L_terms, h_tdterms=Lcoeff, args=args,; config=config, use_openmp=opt.use_openmp,; omp_components=omp_components,; omp_threads=opt.openmp_threads); cgen.generate(config.tdname + "".pyx""). code = compile('from ' + config.tdname + ' import cy_td_ode_rhs',; '<string>', 'exec'); exec(code, globals()); config.tdfunc = cy_td_ode_rhs. #; # setup integrator; #; initial_vector = psi0.full().ravel(); r = scipy.integrate.ode(config.tdfunc); r.set_integrator('zvode', method=opt.method, order=opt.order,; atol=opt.atol, rtol=opt.rtol, nsteps=opt.nsteps,; first_step=opt.first_step, min_step=opt.min_step,; max_step=opt.max_step); r.set_initial_value(initial_vector, tlist[0]); code = compile('r.set_f_params(' + parameter_string + ')',; '<string>', 'exec'). exec(code, locals(), args). ; # Remove RHS cython file if necessary; if not opt.rhs_reuse and config.tdname:; _cython_build_cleanup(config.tdname); ; #; # call generic ODE code; #; return _generic_ode_solve(r, psi0, tlist, e_ops, opt, progress_bar,; dims=psi0.dims). ",MatchSource.WIKI,docs/4.2/modules/qutip/sesolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/sesolve.html
https://qutip.org/docs/4.2/modules/qutip/sesolve.html:12331,Modifiability,config,config,12331,"; # collapse operators); n_L_terms = len(Ldata); ; # Check which components should use OPENMP; omp_components = None; if qset.has_openmp:; if opt.use_openmp:; omp_components = openmp_components(Lptrs). #; # setup ode args string: we expand the list Ldata, Linds and Lptrs into; # and explicit list of parameters; #; string_list = []; for k in range(n_L_terms):; string_list.append(""Ldata[%d], Linds[%d], Lptrs[%d]"" % (k, k, k)); # Add object terms to end of ode args string; for k in range(len(Lobj)):; string_list.append(""Lobj[%d]"" % k); ; for name, value in args.items():; if isinstance(value, np.ndarray):; string_list.append(name); else:; string_list.append(str(value)); parameter_string = "","".join(string_list). #; # generate and compile new cython code if necessary; #; if not opt.rhs_reuse or config.tdfunc is None:; if opt.rhs_filename is None:; config.tdname = ""rhs"" + str(os.getpid()) + str(config.cgen_num); else:; config.tdname = opt.rhs_filename; cgen = Codegen(h_terms=n_L_terms, h_tdterms=Lcoeff, args=args,; config=config, use_openmp=opt.use_openmp,; omp_components=omp_components,; omp_threads=opt.openmp_threads); cgen.generate(config.tdname + "".pyx""). code = compile('from ' + config.tdname + ' import cy_td_ode_rhs',; '<string>', 'exec'); exec(code, globals()); config.tdfunc = cy_td_ode_rhs. #; # setup integrator; #; initial_vector = psi0.full().ravel(); r = scipy.integrate.ode(config.tdfunc); r.set_integrator('zvode', method=opt.method, order=opt.order,; atol=opt.atol, rtol=opt.rtol, nsteps=opt.nsteps,; first_step=opt.first_step, min_step=opt.min_step,; max_step=opt.max_step); r.set_initial_value(initial_vector, tlist[0]); code = compile('r.set_f_params(' + parameter_string + ')',; '<string>', 'exec'). exec(code, locals(), args). ; # Remove RHS cython file if necessary; if not opt.rhs_reuse and config.tdname:; _cython_build_cleanup(config.tdname); ; #; # call generic ODE code; #; return _generic_ode_solve(r, psi0, tlist, e_ops, opt, progress_bar,; dims=psi0.dims). ",MatchSource.WIKI,docs/4.2/modules/qutip/sesolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/sesolve.html
https://qutip.org/docs/4.2/modules/qutip/sesolve.html:12446,Modifiability,config,config,12446,".use_openmp:; omp_components = openmp_components(Lptrs). #; # setup ode args string: we expand the list Ldata, Linds and Lptrs into; # and explicit list of parameters; #; string_list = []; for k in range(n_L_terms):; string_list.append(""Ldata[%d], Linds[%d], Lptrs[%d]"" % (k, k, k)); # Add object terms to end of ode args string; for k in range(len(Lobj)):; string_list.append(""Lobj[%d]"" % k); ; for name, value in args.items():; if isinstance(value, np.ndarray):; string_list.append(name); else:; string_list.append(str(value)); parameter_string = "","".join(string_list). #; # generate and compile new cython code if necessary; #; if not opt.rhs_reuse or config.tdfunc is None:; if opt.rhs_filename is None:; config.tdname = ""rhs"" + str(os.getpid()) + str(config.cgen_num); else:; config.tdname = opt.rhs_filename; cgen = Codegen(h_terms=n_L_terms, h_tdterms=Lcoeff, args=args,; config=config, use_openmp=opt.use_openmp,; omp_components=omp_components,; omp_threads=opt.openmp_threads); cgen.generate(config.tdname + "".pyx""). code = compile('from ' + config.tdname + ' import cy_td_ode_rhs',; '<string>', 'exec'); exec(code, globals()); config.tdfunc = cy_td_ode_rhs. #; # setup integrator; #; initial_vector = psi0.full().ravel(); r = scipy.integrate.ode(config.tdfunc); r.set_integrator('zvode', method=opt.method, order=opt.order,; atol=opt.atol, rtol=opt.rtol, nsteps=opt.nsteps,; first_step=opt.first_step, min_step=opt.min_step,; max_step=opt.max_step); r.set_initial_value(initial_vector, tlist[0]); code = compile('r.set_f_params(' + parameter_string + ')',; '<string>', 'exec'). exec(code, locals(), args). ; # Remove RHS cython file if necessary; if not opt.rhs_reuse and config.tdname:; _cython_build_cleanup(config.tdname); ; #; # call generic ODE code; #; return _generic_ode_solve(r, psi0, tlist, e_ops, opt, progress_bar,; dims=psi0.dims). # -----------------------------------------------------------------------------; # Wave function evolution using a ODE solver (unitary quantum ev",MatchSource.WIKI,docs/4.2/modules/qutip/sesolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/sesolve.html
https://qutip.org/docs/4.2/modules/qutip/sesolve.html:12496,Modifiability,config,config,12496,"ponents(Lptrs). #; # setup ode args string: we expand the list Ldata, Linds and Lptrs into; # and explicit list of parameters; #; string_list = []; for k in range(n_L_terms):; string_list.append(""Ldata[%d], Linds[%d], Lptrs[%d]"" % (k, k, k)); # Add object terms to end of ode args string; for k in range(len(Lobj)):; string_list.append(""Lobj[%d]"" % k); ; for name, value in args.items():; if isinstance(value, np.ndarray):; string_list.append(name); else:; string_list.append(str(value)); parameter_string = "","".join(string_list). #; # generate and compile new cython code if necessary; #; if not opt.rhs_reuse or config.tdfunc is None:; if opt.rhs_filename is None:; config.tdname = ""rhs"" + str(os.getpid()) + str(config.cgen_num); else:; config.tdname = opt.rhs_filename; cgen = Codegen(h_terms=n_L_terms, h_tdterms=Lcoeff, args=args,; config=config, use_openmp=opt.use_openmp,; omp_components=omp_components,; omp_threads=opt.openmp_threads); cgen.generate(config.tdname + "".pyx""). code = compile('from ' + config.tdname + ' import cy_td_ode_rhs',; '<string>', 'exec'); exec(code, globals()); config.tdfunc = cy_td_ode_rhs. #; # setup integrator; #; initial_vector = psi0.full().ravel(); r = scipy.integrate.ode(config.tdfunc); r.set_integrator('zvode', method=opt.method, order=opt.order,; atol=opt.atol, rtol=opt.rtol, nsteps=opt.nsteps,; first_step=opt.first_step, min_step=opt.min_step,; max_step=opt.max_step); r.set_initial_value(initial_vector, tlist[0]); code = compile('r.set_f_params(' + parameter_string + ')',; '<string>', 'exec'). exec(code, locals(), args). ; # Remove RHS cython file if necessary; if not opt.rhs_reuse and config.tdname:; _cython_build_cleanup(config.tdname); ; #; # call generic ODE code; #; return _generic_ode_solve(r, psi0, tlist, e_ops, opt, progress_bar,; dims=psi0.dims). # -----------------------------------------------------------------------------; # Wave function evolution using a ODE solver (unitary quantum evolution), for; # time dependent hamiltonia",MatchSource.WIKI,docs/4.2/modules/qutip/sesolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/sesolve.html
https://qutip.org/docs/4.2/modules/qutip/sesolve.html:12582,Modifiability,config,config,12582,"st Ldata, Linds and Lptrs into; # and explicit list of parameters; #; string_list = []; for k in range(n_L_terms):; string_list.append(""Ldata[%d], Linds[%d], Lptrs[%d]"" % (k, k, k)); # Add object terms to end of ode args string; for k in range(len(Lobj)):; string_list.append(""Lobj[%d]"" % k); ; for name, value in args.items():; if isinstance(value, np.ndarray):; string_list.append(name); else:; string_list.append(str(value)); parameter_string = "","".join(string_list). #; # generate and compile new cython code if necessary; #; if not opt.rhs_reuse or config.tdfunc is None:; if opt.rhs_filename is None:; config.tdname = ""rhs"" + str(os.getpid()) + str(config.cgen_num); else:; config.tdname = opt.rhs_filename; cgen = Codegen(h_terms=n_L_terms, h_tdterms=Lcoeff, args=args,; config=config, use_openmp=opt.use_openmp,; omp_components=omp_components,; omp_threads=opt.openmp_threads); cgen.generate(config.tdname + "".pyx""). code = compile('from ' + config.tdname + ' import cy_td_ode_rhs',; '<string>', 'exec'); exec(code, globals()); config.tdfunc = cy_td_ode_rhs. #; # setup integrator; #; initial_vector = psi0.full().ravel(); r = scipy.integrate.ode(config.tdfunc); r.set_integrator('zvode', method=opt.method, order=opt.order,; atol=opt.atol, rtol=opt.rtol, nsteps=opt.nsteps,; first_step=opt.first_step, min_step=opt.min_step,; max_step=opt.max_step); r.set_initial_value(initial_vector, tlist[0]); code = compile('r.set_f_params(' + parameter_string + ')',; '<string>', 'exec'). exec(code, locals(), args). ; # Remove RHS cython file if necessary; if not opt.rhs_reuse and config.tdname:; _cython_build_cleanup(config.tdname); ; #; # call generic ODE code; #; return _generic_ode_solve(r, psi0, tlist, e_ops, opt, progress_bar,; dims=psi0.dims). # -----------------------------------------------------------------------------; # Wave function evolution using a ODE solver (unitary quantum evolution), for; # time dependent hamiltonians; #; def _sesolve_list_td(H_func, psi0, tlist, e_ops, arg",MatchSource.WIKI,docs/4.2/modules/qutip/sesolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/sesolve.html
https://qutip.org/docs/4.2/modules/qutip/sesolve.html:12701,Modifiability,config,config,12701,", Lptrs[%d]"" % (k, k, k)); # Add object terms to end of ode args string; for k in range(len(Lobj)):; string_list.append(""Lobj[%d]"" % k); ; for name, value in args.items():; if isinstance(value, np.ndarray):; string_list.append(name); else:; string_list.append(str(value)); parameter_string = "","".join(string_list). #; # generate and compile new cython code if necessary; #; if not opt.rhs_reuse or config.tdfunc is None:; if opt.rhs_filename is None:; config.tdname = ""rhs"" + str(os.getpid()) + str(config.cgen_num); else:; config.tdname = opt.rhs_filename; cgen = Codegen(h_terms=n_L_terms, h_tdterms=Lcoeff, args=args,; config=config, use_openmp=opt.use_openmp,; omp_components=omp_components,; omp_threads=opt.openmp_threads); cgen.generate(config.tdname + "".pyx""). code = compile('from ' + config.tdname + ' import cy_td_ode_rhs',; '<string>', 'exec'); exec(code, globals()); config.tdfunc = cy_td_ode_rhs. #; # setup integrator; #; initial_vector = psi0.full().ravel(); r = scipy.integrate.ode(config.tdfunc); r.set_integrator('zvode', method=opt.method, order=opt.order,; atol=opt.atol, rtol=opt.rtol, nsteps=opt.nsteps,; first_step=opt.first_step, min_step=opt.min_step,; max_step=opt.max_step); r.set_initial_value(initial_vector, tlist[0]); code = compile('r.set_f_params(' + parameter_string + ')',; '<string>', 'exec'). exec(code, locals(), args). ; # Remove RHS cython file if necessary; if not opt.rhs_reuse and config.tdname:; _cython_build_cleanup(config.tdname); ; #; # call generic ODE code; #; return _generic_ode_solve(r, psi0, tlist, e_ops, opt, progress_bar,; dims=psi0.dims). # -----------------------------------------------------------------------------; # Wave function evolution using a ODE solver (unitary quantum evolution), for; # time dependent hamiltonians; #; def _sesolve_list_td(H_func, psi0, tlist, e_ops, args, opt, progress_bar):; """"""!; Evolve the wave function using an ODE solver with time-dependent; Hamiltonian.; """""". if debug:; print(inspect.stack()[0][3]). i",MatchSource.WIKI,docs/4.2/modules/qutip/sesolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/sesolve.html
https://qutip.org/docs/4.2/modules/qutip/sesolve.html:13127,Modifiability,config,config,13127," if opt.rhs_filename is None:; config.tdname = ""rhs"" + str(os.getpid()) + str(config.cgen_num); else:; config.tdname = opt.rhs_filename; cgen = Codegen(h_terms=n_L_terms, h_tdterms=Lcoeff, args=args,; config=config, use_openmp=opt.use_openmp,; omp_components=omp_components,; omp_threads=opt.openmp_threads); cgen.generate(config.tdname + "".pyx""). code = compile('from ' + config.tdname + ' import cy_td_ode_rhs',; '<string>', 'exec'); exec(code, globals()); config.tdfunc = cy_td_ode_rhs. #; # setup integrator; #; initial_vector = psi0.full().ravel(); r = scipy.integrate.ode(config.tdfunc); r.set_integrator('zvode', method=opt.method, order=opt.order,; atol=opt.atol, rtol=opt.rtol, nsteps=opt.nsteps,; first_step=opt.first_step, min_step=opt.min_step,; max_step=opt.max_step); r.set_initial_value(initial_vector, tlist[0]); code = compile('r.set_f_params(' + parameter_string + ')',; '<string>', 'exec'). exec(code, locals(), args). ; # Remove RHS cython file if necessary; if not opt.rhs_reuse and config.tdname:; _cython_build_cleanup(config.tdname); ; #; # call generic ODE code; #; return _generic_ode_solve(r, psi0, tlist, e_ops, opt, progress_bar,; dims=psi0.dims). # -----------------------------------------------------------------------------; # Wave function evolution using a ODE solver (unitary quantum evolution), for; # time dependent hamiltonians; #; def _sesolve_list_td(H_func, psi0, tlist, e_ops, args, opt, progress_bar):; """"""!; Evolve the wave function using an ODE solver with time-dependent; Hamiltonian.; """""". if debug:; print(inspect.stack()[0][3]). if not isket(psi0):; raise TypeError(""psi0 must be a ket""). #; # configure time-dependent terms and setup ODE solver; #; if len(H_func) != 2:; raise TypeError('Time-dependent Hamiltonian list must have two terms.'); if (not isinstance(H_func[0], (list, np.ndarray))) or \; (len(H_func[0]) <= 1):; raise TypeError('Time-dependent Hamiltonians must be a list with two '; + 'or more terms'); if (not isinstance(H_func[1], (li",MatchSource.WIKI,docs/4.2/modules/qutip/sesolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/sesolve.html
https://qutip.org/docs/4.2/modules/qutip/sesolve.html:13165,Modifiability,config,config,13165," config.tdname = ""rhs"" + str(os.getpid()) + str(config.cgen_num); else:; config.tdname = opt.rhs_filename; cgen = Codegen(h_terms=n_L_terms, h_tdterms=Lcoeff, args=args,; config=config, use_openmp=opt.use_openmp,; omp_components=omp_components,; omp_threads=opt.openmp_threads); cgen.generate(config.tdname + "".pyx""). code = compile('from ' + config.tdname + ' import cy_td_ode_rhs',; '<string>', 'exec'); exec(code, globals()); config.tdfunc = cy_td_ode_rhs. #; # setup integrator; #; initial_vector = psi0.full().ravel(); r = scipy.integrate.ode(config.tdfunc); r.set_integrator('zvode', method=opt.method, order=opt.order,; atol=opt.atol, rtol=opt.rtol, nsteps=opt.nsteps,; first_step=opt.first_step, min_step=opt.min_step,; max_step=opt.max_step); r.set_initial_value(initial_vector, tlist[0]); code = compile('r.set_f_params(' + parameter_string + ')',; '<string>', 'exec'). exec(code, locals(), args). ; # Remove RHS cython file if necessary; if not opt.rhs_reuse and config.tdname:; _cython_build_cleanup(config.tdname); ; #; # call generic ODE code; #; return _generic_ode_solve(r, psi0, tlist, e_ops, opt, progress_bar,; dims=psi0.dims). # -----------------------------------------------------------------------------; # Wave function evolution using a ODE solver (unitary quantum evolution), for; # time dependent hamiltonians; #; def _sesolve_list_td(H_func, psi0, tlist, e_ops, args, opt, progress_bar):; """"""!; Evolve the wave function using an ODE solver with time-dependent; Hamiltonian.; """""". if debug:; print(inspect.stack()[0][3]). if not isket(psi0):; raise TypeError(""psi0 must be a ket""). #; # configure time-dependent terms and setup ODE solver; #; if len(H_func) != 2:; raise TypeError('Time-dependent Hamiltonian list must have two terms.'); if (not isinstance(H_func[0], (list, np.ndarray))) or \; (len(H_func[0]) <= 1):; raise TypeError('Time-dependent Hamiltonians must be a list with two '; + 'or more terms'); if (not isinstance(H_func[1], (list, np.ndarray))) or \; (len(",MatchSource.WIKI,docs/4.2/modules/qutip/sesolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/sesolve.html
https://qutip.org/docs/4.2/modules/qutip/sesolve.html:13767,Modifiability,config,configure,13767,"tep=opt.first_step, min_step=opt.min_step,; max_step=opt.max_step); r.set_initial_value(initial_vector, tlist[0]); code = compile('r.set_f_params(' + parameter_string + ')',; '<string>', 'exec'). exec(code, locals(), args). ; # Remove RHS cython file if necessary; if not opt.rhs_reuse and config.tdname:; _cython_build_cleanup(config.tdname); ; #; # call generic ODE code; #; return _generic_ode_solve(r, psi0, tlist, e_ops, opt, progress_bar,; dims=psi0.dims). # -----------------------------------------------------------------------------; # Wave function evolution using a ODE solver (unitary quantum evolution), for; # time dependent hamiltonians; #; def _sesolve_list_td(H_func, psi0, tlist, e_ops, args, opt, progress_bar):; """"""!; Evolve the wave function using an ODE solver with time-dependent; Hamiltonian.; """""". if debug:; print(inspect.stack()[0][3]). if not isket(psi0):; raise TypeError(""psi0 must be a ket""). #; # configure time-dependent terms and setup ODE solver; #; if len(H_func) != 2:; raise TypeError('Time-dependent Hamiltonian list must have two terms.'); if (not isinstance(H_func[0], (list, np.ndarray))) or \; (len(H_func[0]) <= 1):; raise TypeError('Time-dependent Hamiltonians must be a list with two '; + 'or more terms'); if (not isinstance(H_func[1], (list, np.ndarray))) or \; (len(H_func[1]) != (len(H_func[0]) - 1)):; raise TypeError('Time-dependent coefficients must be list with ' +; 'length N-1 where N is the number of ' +; 'Hamiltonian terms.'); tflag = 1; if opt.rhs_reuse and config.tdfunc is None:; print(""No previous time-dependent RHS found.""); print(""Generating one for you...""); rhs_generate(H_func, args); lenh = len(H_func[0]); if opt.tidy:; H_func[0] = [(H_func[0][k]).tidyup() for k in range(lenh)]; # create data arrays for time-dependent RHS function; Hdata = [-1.0j * H_func[0][k].data.data for k in range(lenh)]; Hinds = [H_func[0][k].data.indices for k in range(lenh)]; Hptrs = [H_func[0][k].data.indptr for k in range(lenh)]; # setup ode args ",MatchSource.WIKI,docs/4.2/modules/qutip/sesolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/sesolve.html
https://qutip.org/docs/4.2/modules/qutip/sesolve.html:14356,Modifiability,config,config,14356,"---------------------------; # Wave function evolution using a ODE solver (unitary quantum evolution), for; # time dependent hamiltonians; #; def _sesolve_list_td(H_func, psi0, tlist, e_ops, args, opt, progress_bar):; """"""!; Evolve the wave function using an ODE solver with time-dependent; Hamiltonian.; """""". if debug:; print(inspect.stack()[0][3]). if not isket(psi0):; raise TypeError(""psi0 must be a ket""). #; # configure time-dependent terms and setup ODE solver; #; if len(H_func) != 2:; raise TypeError('Time-dependent Hamiltonian list must have two terms.'); if (not isinstance(H_func[0], (list, np.ndarray))) or \; (len(H_func[0]) <= 1):; raise TypeError('Time-dependent Hamiltonians must be a list with two '; + 'or more terms'); if (not isinstance(H_func[1], (list, np.ndarray))) or \; (len(H_func[1]) != (len(H_func[0]) - 1)):; raise TypeError('Time-dependent coefficients must be list with ' +; 'length N-1 where N is the number of ' +; 'Hamiltonian terms.'); tflag = 1; if opt.rhs_reuse and config.tdfunc is None:; print(""No previous time-dependent RHS found.""); print(""Generating one for you...""); rhs_generate(H_func, args); lenh = len(H_func[0]); if opt.tidy:; H_func[0] = [(H_func[0][k]).tidyup() for k in range(lenh)]; # create data arrays for time-dependent RHS function; Hdata = [-1.0j * H_func[0][k].data.data for k in range(lenh)]; Hinds = [H_func[0][k].data.indices for k in range(lenh)]; Hptrs = [H_func[0][k].data.indptr for k in range(lenh)]; # setup ode args string; string = """"; for k in range(lenh):; string += (""Hdata["" + str(k) + ""], Hinds["" + str(k) +; ""], Hptrs["" + str(k) + ""],""). if args:; td_consts = args.items(); for elem in td_consts:; string += str(elem[1]); if elem != td_consts[-1]:; string += ("",""). # run code generator; if not opt.rhs_reuse or config.tdfunc is None:; if opt.rhs_filename is None:; config.tdname = ""rhs"" + str(os.getpid()) + str(config.cgen_num); else:; config.tdname = opt.rhs_filename; cgen = Codegen(h_terms=n_L_terms, h_tdterms=Lcoeff, ",MatchSource.WIKI,docs/4.2/modules/qutip/sesolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/sesolve.html
https://qutip.org/docs/4.2/modules/qutip/sesolve.html:15141,Modifiability,config,config,15141,"))) or \; (len(H_func[1]) != (len(H_func[0]) - 1)):; raise TypeError('Time-dependent coefficients must be list with ' +; 'length N-1 where N is the number of ' +; 'Hamiltonian terms.'); tflag = 1; if opt.rhs_reuse and config.tdfunc is None:; print(""No previous time-dependent RHS found.""); print(""Generating one for you...""); rhs_generate(H_func, args); lenh = len(H_func[0]); if opt.tidy:; H_func[0] = [(H_func[0][k]).tidyup() for k in range(lenh)]; # create data arrays for time-dependent RHS function; Hdata = [-1.0j * H_func[0][k].data.data for k in range(lenh)]; Hinds = [H_func[0][k].data.indices for k in range(lenh)]; Hptrs = [H_func[0][k].data.indptr for k in range(lenh)]; # setup ode args string; string = """"; for k in range(lenh):; string += (""Hdata["" + str(k) + ""], Hinds["" + str(k) +; ""], Hptrs["" + str(k) + ""],""). if args:; td_consts = args.items(); for elem in td_consts:; string += str(elem[1]); if elem != td_consts[-1]:; string += ("",""). # run code generator; if not opt.rhs_reuse or config.tdfunc is None:; if opt.rhs_filename is None:; config.tdname = ""rhs"" + str(os.getpid()) + str(config.cgen_num); else:; config.tdname = opt.rhs_filename; cgen = Codegen(h_terms=n_L_terms, h_tdterms=Lcoeff, args=args,; config=config); cgen.generate(config.tdname + "".pyx""). code = compile('from ' + config.tdname + ' import cy_td_ode_rhs',; '<string>', 'exec'); exec(code, globals()); config.tdfunc = cy_td_ode_rhs; #; # setup integrator; #; initial_vector = psi0.full().ravel(); r = scipy.integrate.ode(config.tdfunc); r.set_integrator('zvode', method=opt.method, order=opt.order,; atol=opt.atol, rtol=opt.rtol, nsteps=opt.nsteps,; first_step=opt.first_step, min_step=opt.min_step,; max_step=opt.max_step); r.set_initial_value(initial_vector, tlist[0]); code = compile('r.set_f_params(' + string + ')', '<string>', 'exec'); exec(code). #; # call generic ODE code; #; return _generic_ode_solve(r, psi0, tlist, e_ops, opt, progress_bar; , dims=psi0.dims). # -----------------------------------",MatchSource.WIKI,docs/4.2/modules/qutip/sesolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/sesolve.html
https://qutip.org/docs/4.2/modules/qutip/sesolve.html:15195,Modifiability,config,config,15195,"):; raise TypeError('Time-dependent coefficients must be list with ' +; 'length N-1 where N is the number of ' +; 'Hamiltonian terms.'); tflag = 1; if opt.rhs_reuse and config.tdfunc is None:; print(""No previous time-dependent RHS found.""); print(""Generating one for you...""); rhs_generate(H_func, args); lenh = len(H_func[0]); if opt.tidy:; H_func[0] = [(H_func[0][k]).tidyup() for k in range(lenh)]; # create data arrays for time-dependent RHS function; Hdata = [-1.0j * H_func[0][k].data.data for k in range(lenh)]; Hinds = [H_func[0][k].data.indices for k in range(lenh)]; Hptrs = [H_func[0][k].data.indptr for k in range(lenh)]; # setup ode args string; string = """"; for k in range(lenh):; string += (""Hdata["" + str(k) + ""], Hinds["" + str(k) +; ""], Hptrs["" + str(k) + ""],""). if args:; td_consts = args.items(); for elem in td_consts:; string += str(elem[1]); if elem != td_consts[-1]:; string += ("",""). # run code generator; if not opt.rhs_reuse or config.tdfunc is None:; if opt.rhs_filename is None:; config.tdname = ""rhs"" + str(os.getpid()) + str(config.cgen_num); else:; config.tdname = opt.rhs_filename; cgen = Codegen(h_terms=n_L_terms, h_tdterms=Lcoeff, args=args,; config=config); cgen.generate(config.tdname + "".pyx""). code = compile('from ' + config.tdname + ' import cy_td_ode_rhs',; '<string>', 'exec'); exec(code, globals()); config.tdfunc = cy_td_ode_rhs; #; # setup integrator; #; initial_vector = psi0.full().ravel(); r = scipy.integrate.ode(config.tdfunc); r.set_integrator('zvode', method=opt.method, order=opt.order,; atol=opt.atol, rtol=opt.rtol, nsteps=opt.nsteps,; first_step=opt.first_step, min_step=opt.min_step,; max_step=opt.max_step); r.set_initial_value(initial_vector, tlist[0]); code = compile('r.set_f_params(' + string + ')', '<string>', 'exec'); exec(code). #; # call generic ODE code; #; return _generic_ode_solve(r, psi0, tlist, e_ops, opt, progress_bar; , dims=psi0.dims). # -----------------------------------------------------------------------------; # Wav",MatchSource.WIKI,docs/4.2/modules/qutip/sesolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/sesolve.html
https://qutip.org/docs/4.2/modules/qutip/sesolve.html:15242,Modifiability,config,config,15242,"ust be list with ' +; 'length N-1 where N is the number of ' +; 'Hamiltonian terms.'); tflag = 1; if opt.rhs_reuse and config.tdfunc is None:; print(""No previous time-dependent RHS found.""); print(""Generating one for you...""); rhs_generate(H_func, args); lenh = len(H_func[0]); if opt.tidy:; H_func[0] = [(H_func[0][k]).tidyup() for k in range(lenh)]; # create data arrays for time-dependent RHS function; Hdata = [-1.0j * H_func[0][k].data.data for k in range(lenh)]; Hinds = [H_func[0][k].data.indices for k in range(lenh)]; Hptrs = [H_func[0][k].data.indptr for k in range(lenh)]; # setup ode args string; string = """"; for k in range(lenh):; string += (""Hdata["" + str(k) + ""], Hinds["" + str(k) +; ""], Hptrs["" + str(k) + ""],""). if args:; td_consts = args.items(); for elem in td_consts:; string += str(elem[1]); if elem != td_consts[-1]:; string += ("",""). # run code generator; if not opt.rhs_reuse or config.tdfunc is None:; if opt.rhs_filename is None:; config.tdname = ""rhs"" + str(os.getpid()) + str(config.cgen_num); else:; config.tdname = opt.rhs_filename; cgen = Codegen(h_terms=n_L_terms, h_tdterms=Lcoeff, args=args,; config=config); cgen.generate(config.tdname + "".pyx""). code = compile('from ' + config.tdname + ' import cy_td_ode_rhs',; '<string>', 'exec'); exec(code, globals()); config.tdfunc = cy_td_ode_rhs; #; # setup integrator; #; initial_vector = psi0.full().ravel(); r = scipy.integrate.ode(config.tdfunc); r.set_integrator('zvode', method=opt.method, order=opt.order,; atol=opt.atol, rtol=opt.rtol, nsteps=opt.nsteps,; first_step=opt.first_step, min_step=opt.min_step,; max_step=opt.max_step); r.set_initial_value(initial_vector, tlist[0]); code = compile('r.set_f_params(' + string + ')', '<string>', 'exec'); exec(code). #; # call generic ODE code; #; return _generic_ode_solve(r, psi0, tlist, e_ops, opt, progress_bar; , dims=psi0.dims). # -----------------------------------------------------------------------------; # Wave function evolution using a ODE solver (unitary qu",MatchSource.WIKI,docs/4.2/modules/qutip/sesolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/sesolve.html
https://qutip.org/docs/4.2/modules/qutip/sesolve.html:15267,Modifiability,config,config,15267,"ength N-1 where N is the number of ' +; 'Hamiltonian terms.'); tflag = 1; if opt.rhs_reuse and config.tdfunc is None:; print(""No previous time-dependent RHS found.""); print(""Generating one for you...""); rhs_generate(H_func, args); lenh = len(H_func[0]); if opt.tidy:; H_func[0] = [(H_func[0][k]).tidyup() for k in range(lenh)]; # create data arrays for time-dependent RHS function; Hdata = [-1.0j * H_func[0][k].data.data for k in range(lenh)]; Hinds = [H_func[0][k].data.indices for k in range(lenh)]; Hptrs = [H_func[0][k].data.indptr for k in range(lenh)]; # setup ode args string; string = """"; for k in range(lenh):; string += (""Hdata["" + str(k) + ""], Hinds["" + str(k) +; ""], Hptrs["" + str(k) + ""],""). if args:; td_consts = args.items(); for elem in td_consts:; string += str(elem[1]); if elem != td_consts[-1]:; string += ("",""). # run code generator; if not opt.rhs_reuse or config.tdfunc is None:; if opt.rhs_filename is None:; config.tdname = ""rhs"" + str(os.getpid()) + str(config.cgen_num); else:; config.tdname = opt.rhs_filename; cgen = Codegen(h_terms=n_L_terms, h_tdterms=Lcoeff, args=args,; config=config); cgen.generate(config.tdname + "".pyx""). code = compile('from ' + config.tdname + ' import cy_td_ode_rhs',; '<string>', 'exec'); exec(code, globals()); config.tdfunc = cy_td_ode_rhs; #; # setup integrator; #; initial_vector = psi0.full().ravel(); r = scipy.integrate.ode(config.tdfunc); r.set_integrator('zvode', method=opt.method, order=opt.order,; atol=opt.atol, rtol=opt.rtol, nsteps=opt.nsteps,; first_step=opt.first_step, min_step=opt.min_step,; max_step=opt.max_step); r.set_initial_value(initial_vector, tlist[0]); code = compile('r.set_f_params(' + string + ')', '<string>', 'exec'); exec(code). #; # call generic ODE code; #; return _generic_ode_solve(r, psi0, tlist, e_ops, opt, progress_bar; , dims=psi0.dims). # -----------------------------------------------------------------------------; # Wave function evolution using a ODE solver (unitary quantum evolution), for; #",MatchSource.WIKI,docs/4.2/modules/qutip/sesolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/sesolve.html
https://qutip.org/docs/4.2/modules/qutip/sesolve.html:15365,Modifiability,config,config,15365,"f opt.rhs_reuse and config.tdfunc is None:; print(""No previous time-dependent RHS found.""); print(""Generating one for you...""); rhs_generate(H_func, args); lenh = len(H_func[0]); if opt.tidy:; H_func[0] = [(H_func[0][k]).tidyup() for k in range(lenh)]; # create data arrays for time-dependent RHS function; Hdata = [-1.0j * H_func[0][k].data.data for k in range(lenh)]; Hinds = [H_func[0][k].data.indices for k in range(lenh)]; Hptrs = [H_func[0][k].data.indptr for k in range(lenh)]; # setup ode args string; string = """"; for k in range(lenh):; string += (""Hdata["" + str(k) + ""], Hinds["" + str(k) +; ""], Hptrs["" + str(k) + ""],""). if args:; td_consts = args.items(); for elem in td_consts:; string += str(elem[1]); if elem != td_consts[-1]:; string += ("",""). # run code generator; if not opt.rhs_reuse or config.tdfunc is None:; if opt.rhs_filename is None:; config.tdname = ""rhs"" + str(os.getpid()) + str(config.cgen_num); else:; config.tdname = opt.rhs_filename; cgen = Codegen(h_terms=n_L_terms, h_tdterms=Lcoeff, args=args,; config=config); cgen.generate(config.tdname + "".pyx""). code = compile('from ' + config.tdname + ' import cy_td_ode_rhs',; '<string>', 'exec'); exec(code, globals()); config.tdfunc = cy_td_ode_rhs; #; # setup integrator; #; initial_vector = psi0.full().ravel(); r = scipy.integrate.ode(config.tdfunc); r.set_integrator('zvode', method=opt.method, order=opt.order,; atol=opt.atol, rtol=opt.rtol, nsteps=opt.nsteps,; first_step=opt.first_step, min_step=opt.min_step,; max_step=opt.max_step); r.set_initial_value(initial_vector, tlist[0]); code = compile('r.set_f_params(' + string + ')', '<string>', 'exec'); exec(code). #; # call generic ODE code; #; return _generic_ode_solve(r, psi0, tlist, e_ops, opt, progress_bar; , dims=psi0.dims). # -----------------------------------------------------------------------------; # Wave function evolution using a ODE solver (unitary quantum evolution), for; # time dependent hamiltonians; #; def _sesolve_func_td(H_func, psi0, tlist, ",MatchSource.WIKI,docs/4.2/modules/qutip/sesolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/sesolve.html
https://qutip.org/docs/4.2/modules/qutip/sesolve.html:15372,Modifiability,config,config,15372,"f opt.rhs_reuse and config.tdfunc is None:; print(""No previous time-dependent RHS found.""); print(""Generating one for you...""); rhs_generate(H_func, args); lenh = len(H_func[0]); if opt.tidy:; H_func[0] = [(H_func[0][k]).tidyup() for k in range(lenh)]; # create data arrays for time-dependent RHS function; Hdata = [-1.0j * H_func[0][k].data.data for k in range(lenh)]; Hinds = [H_func[0][k].data.indices for k in range(lenh)]; Hptrs = [H_func[0][k].data.indptr for k in range(lenh)]; # setup ode args string; string = """"; for k in range(lenh):; string += (""Hdata["" + str(k) + ""], Hinds["" + str(k) +; ""], Hptrs["" + str(k) + ""],""). if args:; td_consts = args.items(); for elem in td_consts:; string += str(elem[1]); if elem != td_consts[-1]:; string += ("",""). # run code generator; if not opt.rhs_reuse or config.tdfunc is None:; if opt.rhs_filename is None:; config.tdname = ""rhs"" + str(os.getpid()) + str(config.cgen_num); else:; config.tdname = opt.rhs_filename; cgen = Codegen(h_terms=n_L_terms, h_tdterms=Lcoeff, args=args,; config=config); cgen.generate(config.tdname + "".pyx""). code = compile('from ' + config.tdname + ' import cy_td_ode_rhs',; '<string>', 'exec'); exec(code, globals()); config.tdfunc = cy_td_ode_rhs; #; # setup integrator; #; initial_vector = psi0.full().ravel(); r = scipy.integrate.ode(config.tdfunc); r.set_integrator('zvode', method=opt.method, order=opt.order,; atol=opt.atol, rtol=opt.rtol, nsteps=opt.nsteps,; first_step=opt.first_step, min_step=opt.min_step,; max_step=opt.max_step); r.set_initial_value(initial_vector, tlist[0]); code = compile('r.set_f_params(' + string + ')', '<string>', 'exec'); exec(code). #; # call generic ODE code; #; return _generic_ode_solve(r, psi0, tlist, e_ops, opt, progress_bar; , dims=psi0.dims). # -----------------------------------------------------------------------------; # Wave function evolution using a ODE solver (unitary quantum evolution), for; # time dependent hamiltonians; #; def _sesolve_func_td(H_func, psi0, tlist, ",MatchSource.WIKI,docs/4.2/modules/qutip/sesolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/sesolve.html
https://qutip.org/docs/4.2/modules/qutip/sesolve.html:15395,Modifiability,config,config,15395,"ious time-dependent RHS found.""); print(""Generating one for you...""); rhs_generate(H_func, args); lenh = len(H_func[0]); if opt.tidy:; H_func[0] = [(H_func[0][k]).tidyup() for k in range(lenh)]; # create data arrays for time-dependent RHS function; Hdata = [-1.0j * H_func[0][k].data.data for k in range(lenh)]; Hinds = [H_func[0][k].data.indices for k in range(lenh)]; Hptrs = [H_func[0][k].data.indptr for k in range(lenh)]; # setup ode args string; string = """"; for k in range(lenh):; string += (""Hdata["" + str(k) + ""], Hinds["" + str(k) +; ""], Hptrs["" + str(k) + ""],""). if args:; td_consts = args.items(); for elem in td_consts:; string += str(elem[1]); if elem != td_consts[-1]:; string += ("",""). # run code generator; if not opt.rhs_reuse or config.tdfunc is None:; if opt.rhs_filename is None:; config.tdname = ""rhs"" + str(os.getpid()) + str(config.cgen_num); else:; config.tdname = opt.rhs_filename; cgen = Codegen(h_terms=n_L_terms, h_tdterms=Lcoeff, args=args,; config=config); cgen.generate(config.tdname + "".pyx""). code = compile('from ' + config.tdname + ' import cy_td_ode_rhs',; '<string>', 'exec'); exec(code, globals()); config.tdfunc = cy_td_ode_rhs; #; # setup integrator; #; initial_vector = psi0.full().ravel(); r = scipy.integrate.ode(config.tdfunc); r.set_integrator('zvode', method=opt.method, order=opt.order,; atol=opt.atol, rtol=opt.rtol, nsteps=opt.nsteps,; first_step=opt.first_step, min_step=opt.min_step,; max_step=opt.max_step); r.set_initial_value(initial_vector, tlist[0]); code = compile('r.set_f_params(' + string + ')', '<string>', 'exec'); exec(code). #; # call generic ODE code; #; return _generic_ode_solve(r, psi0, tlist, e_ops, opt, progress_bar; , dims=psi0.dims). # -----------------------------------------------------------------------------; # Wave function evolution using a ODE solver (unitary quantum evolution), for; # time dependent hamiltonians; #; def _sesolve_func_td(H_func, psi0, tlist, e_ops, args, opt, progress_bar):; """"""!; Evolve the wave f",MatchSource.WIKI,docs/4.2/modules/qutip/sesolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/sesolve.html
https://qutip.org/docs/4.2/modules/qutip/sesolve.html:15445,Modifiability,config,config,15445,"Generating one for you...""); rhs_generate(H_func, args); lenh = len(H_func[0]); if opt.tidy:; H_func[0] = [(H_func[0][k]).tidyup() for k in range(lenh)]; # create data arrays for time-dependent RHS function; Hdata = [-1.0j * H_func[0][k].data.data for k in range(lenh)]; Hinds = [H_func[0][k].data.indices for k in range(lenh)]; Hptrs = [H_func[0][k].data.indptr for k in range(lenh)]; # setup ode args string; string = """"; for k in range(lenh):; string += (""Hdata["" + str(k) + ""], Hinds["" + str(k) +; ""], Hptrs["" + str(k) + ""],""). if args:; td_consts = args.items(); for elem in td_consts:; string += str(elem[1]); if elem != td_consts[-1]:; string += ("",""). # run code generator; if not opt.rhs_reuse or config.tdfunc is None:; if opt.rhs_filename is None:; config.tdname = ""rhs"" + str(os.getpid()) + str(config.cgen_num); else:; config.tdname = opt.rhs_filename; cgen = Codegen(h_terms=n_L_terms, h_tdterms=Lcoeff, args=args,; config=config); cgen.generate(config.tdname + "".pyx""). code = compile('from ' + config.tdname + ' import cy_td_ode_rhs',; '<string>', 'exec'); exec(code, globals()); config.tdfunc = cy_td_ode_rhs; #; # setup integrator; #; initial_vector = psi0.full().ravel(); r = scipy.integrate.ode(config.tdfunc); r.set_integrator('zvode', method=opt.method, order=opt.order,; atol=opt.atol, rtol=opt.rtol, nsteps=opt.nsteps,; first_step=opt.first_step, min_step=opt.min_step,; max_step=opt.max_step); r.set_initial_value(initial_vector, tlist[0]); code = compile('r.set_f_params(' + string + ')', '<string>', 'exec'); exec(code). #; # call generic ODE code; #; return _generic_ode_solve(r, psi0, tlist, e_ops, opt, progress_bar; , dims=psi0.dims). # -----------------------------------------------------------------------------; # Wave function evolution using a ODE solver (unitary quantum evolution), for; # time dependent hamiltonians; #; def _sesolve_func_td(H_func, psi0, tlist, e_ops, args, opt, progress_bar):; """"""!; Evolve the wave function using an ODE solver with time-depe",MatchSource.WIKI,docs/4.2/modules/qutip/sesolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/sesolve.html
https://qutip.org/docs/4.2/modules/qutip/sesolve.html:15531,Modifiability,config,config,15531,"h = len(H_func[0]); if opt.tidy:; H_func[0] = [(H_func[0][k]).tidyup() for k in range(lenh)]; # create data arrays for time-dependent RHS function; Hdata = [-1.0j * H_func[0][k].data.data for k in range(lenh)]; Hinds = [H_func[0][k].data.indices for k in range(lenh)]; Hptrs = [H_func[0][k].data.indptr for k in range(lenh)]; # setup ode args string; string = """"; for k in range(lenh):; string += (""Hdata["" + str(k) + ""], Hinds["" + str(k) +; ""], Hptrs["" + str(k) + ""],""). if args:; td_consts = args.items(); for elem in td_consts:; string += str(elem[1]); if elem != td_consts[-1]:; string += ("",""). # run code generator; if not opt.rhs_reuse or config.tdfunc is None:; if opt.rhs_filename is None:; config.tdname = ""rhs"" + str(os.getpid()) + str(config.cgen_num); else:; config.tdname = opt.rhs_filename; cgen = Codegen(h_terms=n_L_terms, h_tdterms=Lcoeff, args=args,; config=config); cgen.generate(config.tdname + "".pyx""). code = compile('from ' + config.tdname + ' import cy_td_ode_rhs',; '<string>', 'exec'); exec(code, globals()); config.tdfunc = cy_td_ode_rhs; #; # setup integrator; #; initial_vector = psi0.full().ravel(); r = scipy.integrate.ode(config.tdfunc); r.set_integrator('zvode', method=opt.method, order=opt.order,; atol=opt.atol, rtol=opt.rtol, nsteps=opt.nsteps,; first_step=opt.first_step, min_step=opt.min_step,; max_step=opt.max_step); r.set_initial_value(initial_vector, tlist[0]); code = compile('r.set_f_params(' + string + ')', '<string>', 'exec'); exec(code). #; # call generic ODE code; #; return _generic_ode_solve(r, psi0, tlist, e_ops, opt, progress_bar; , dims=psi0.dims). # -----------------------------------------------------------------------------; # Wave function evolution using a ODE solver (unitary quantum evolution), for; # time dependent hamiltonians; #; def _sesolve_func_td(H_func, psi0, tlist, e_ops, args, opt, progress_bar):; """"""!; Evolve the wave function using an ODE solver with time-dependent; Hamiltonian.; """""". if debug:; print(inspect.stack()[",MatchSource.WIKI,docs/4.2/modules/qutip/sesolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/sesolve.html
https://qutip.org/docs/4.2/modules/qutip/sesolve.html:15650,Modifiability,config,config,15650,"[-1.0j * H_func[0][k].data.data for k in range(lenh)]; Hinds = [H_func[0][k].data.indices for k in range(lenh)]; Hptrs = [H_func[0][k].data.indptr for k in range(lenh)]; # setup ode args string; string = """"; for k in range(lenh):; string += (""Hdata["" + str(k) + ""], Hinds["" + str(k) +; ""], Hptrs["" + str(k) + ""],""). if args:; td_consts = args.items(); for elem in td_consts:; string += str(elem[1]); if elem != td_consts[-1]:; string += ("",""). # run code generator; if not opt.rhs_reuse or config.tdfunc is None:; if opt.rhs_filename is None:; config.tdname = ""rhs"" + str(os.getpid()) + str(config.cgen_num); else:; config.tdname = opt.rhs_filename; cgen = Codegen(h_terms=n_L_terms, h_tdterms=Lcoeff, args=args,; config=config); cgen.generate(config.tdname + "".pyx""). code = compile('from ' + config.tdname + ' import cy_td_ode_rhs',; '<string>', 'exec'); exec(code, globals()); config.tdfunc = cy_td_ode_rhs; #; # setup integrator; #; initial_vector = psi0.full().ravel(); r = scipy.integrate.ode(config.tdfunc); r.set_integrator('zvode', method=opt.method, order=opt.order,; atol=opt.atol, rtol=opt.rtol, nsteps=opt.nsteps,; first_step=opt.first_step, min_step=opt.min_step,; max_step=opt.max_step); r.set_initial_value(initial_vector, tlist[0]); code = compile('r.set_f_params(' + string + ')', '<string>', 'exec'); exec(code). #; # call generic ODE code; #; return _generic_ode_solve(r, psi0, tlist, e_ops, opt, progress_bar; , dims=psi0.dims). # -----------------------------------------------------------------------------; # Wave function evolution using a ODE solver (unitary quantum evolution), for; # time dependent hamiltonians; #; def _sesolve_func_td(H_func, psi0, tlist, e_ops, args, opt, progress_bar):; """"""!; Evolve the wave function using an ODE solver with time-dependent; Hamiltonian.; """""". if debug:; print(inspect.stack()[0][3]). if not isket(psi0):; raise TypeError(""psi0 must be a ket""). #; # setup integrator; #; new_args = None. if type(args) is dict:; new_args = {}; for key",MatchSource.WIKI,docs/4.2/modules/qutip/sesolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/sesolve.html
https://qutip.org/docs/4.2/modules/qutip/sesolve.html:19777,Modifiability,config,config,19777,"list, e_ops, opt, progress_bar, dims=None):; """"""; Internal function for solving ODEs.; """"""; if opt.normalize_output:; state_norm_func = norm; else:; state_norm_func = None; ; ; #; # prepare output array; #; n_tsteps = len(tlist); output = Result(); output.solver = ""sesolve""; output.times = tlist. if opt.store_states:; output.states = []. if isinstance(e_ops, types.FunctionType):; n_expt_op = 0; expt_callback = True. elif isinstance(e_ops, list):. n_expt_op = len(e_ops); expt_callback = False. if n_expt_op == 0:; # fallback on storing states; output.states = []; opt.store_states = True; else:; output.expect = []; output.num_expect = n_expt_op; for op in e_ops:; if op.isherm:; output.expect.append(np.zeros(n_tsteps)); else:; output.expect.append(np.zeros(n_tsteps, dtype=complex)); else:; raise TypeError(""Expectation parameter must be a list or a function""). #; # start evolution; #; progress_bar.start(n_tsteps). dt = np.diff(tlist); for t_idx, t in enumerate(tlist):; progress_bar.update(t_idx). if not r.successful():; raise Exception(""ODE integration error: Try to increase ""; ""the allowed number of substeps by increasing ""; ""the nsteps parameter in the Options class.""). if state_norm_func:; data = r.y / state_norm_func(r.y); r.set_initial_value(data, r.t). if opt.store_states:; output.states.append(Qobj(r.y, dims=dims)). if expt_callback:; # use callback method; e_ops(t, Qobj(r.y, dims=psi0.dims)). for m in range(n_expt_op):; output.expect[m][t_idx] = cy_expect_psi(e_ops[m].data,; r.y, e_ops[m].isherm). if t_idx < n_tsteps - 1:; r.integrate(r.t + dt[t_idx]). progress_bar.finished(). if not opt.rhs_reuse and config.tdname is not None:; try:; os.remove(config.tdname + "".pyx""); except:; pass. if opt.store_final_state:; output.final_state = Qobj(r.y, dims=dims). return output.  Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, and A.L. Grimsmo.; Last updated on Jan 17, 2018. . Built with Sphinx using a theme provided by Read the Docs. . ",MatchSource.WIKI,docs/4.2/modules/qutip/sesolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/sesolve.html
https://qutip.org/docs/4.2/modules/qutip/sesolve.html:19821,Modifiability,config,config,19821,"list, e_ops, opt, progress_bar, dims=None):; """"""; Internal function for solving ODEs.; """"""; if opt.normalize_output:; state_norm_func = norm; else:; state_norm_func = None; ; ; #; # prepare output array; #; n_tsteps = len(tlist); output = Result(); output.solver = ""sesolve""; output.times = tlist. if opt.store_states:; output.states = []. if isinstance(e_ops, types.FunctionType):; n_expt_op = 0; expt_callback = True. elif isinstance(e_ops, list):. n_expt_op = len(e_ops); expt_callback = False. if n_expt_op == 0:; # fallback on storing states; output.states = []; opt.store_states = True; else:; output.expect = []; output.num_expect = n_expt_op; for op in e_ops:; if op.isherm:; output.expect.append(np.zeros(n_tsteps)); else:; output.expect.append(np.zeros(n_tsteps, dtype=complex)); else:; raise TypeError(""Expectation parameter must be a list or a function""). #; # start evolution; #; progress_bar.start(n_tsteps). dt = np.diff(tlist); for t_idx, t in enumerate(tlist):; progress_bar.update(t_idx). if not r.successful():; raise Exception(""ODE integration error: Try to increase ""; ""the allowed number of substeps by increasing ""; ""the nsteps parameter in the Options class.""). if state_norm_func:; data = r.y / state_norm_func(r.y); r.set_initial_value(data, r.t). if opt.store_states:; output.states.append(Qobj(r.y, dims=dims)). if expt_callback:; # use callback method; e_ops(t, Qobj(r.y, dims=psi0.dims)). for m in range(n_expt_op):; output.expect[m][t_idx] = cy_expect_psi(e_ops[m].data,; r.y, e_ops[m].isherm). if t_idx < n_tsteps - 1:; r.integrate(r.t + dt[t_idx]). progress_bar.finished(). if not opt.rhs_reuse and config.tdname is not None:; try:; os.remove(config.tdname + "".pyx""); except:; pass. if opt.store_final_state:; output.final_state = Qobj(r.y, dims=dims). return output.  Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, and A.L. Grimsmo.; Last updated on Jan 17, 2018. . Built with Sphinx using a theme provided by Read the Docs. . ",MatchSource.WIKI,docs/4.2/modules/qutip/sesolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/sesolve.html
https://qutip.org/docs/4.2/modules/qutip/simdiag.html:5682,Deployability,update,updated,5682,")); inds = rng[inds]; if len(inds) > 1: # if at least 2 eigvals are degenerate; eigvecs_array[inds] = degen(; tol, eigvecs_array[inds],; np.array([ops[kk] for kk in range(1, num_ops)])); k = max(inds) + 1; eigvals_out = np.zeros((num_ops, len(ds)), dtype=float); kets_out = np.array([Qobj(eigvecs_array[j] / la.norm(eigvecs_array[j]),; dims=[ops[0].dims[0], [1]],; shape=[ops[0].shape[0], 1]); for j in range(len(ds))]); if not evals:; return kets_out; else:; for kk in range(num_ops):; for j in range(len(ds)):; eigvals_out[kk, j] = np.real(np.dot(; eigvecs_array[j].conj().T,; ops[kk].data * eigvecs_array[j])); return eigvals_out, kets_out. def degen(tol, in_vecs, ops):; """"""; Private function that finds eigen vals and vecs for degenerate matrices..; """"""; n = len(ops); if n == 0:; return in_vecs; A = ops[0]; vecs = np.column_stack(in_vecs); eigvals, eigvecs = la.eig(np.dot(vecs.conj().T, A.data.dot(vecs))); zipped = zip(-eigvals, range(len(eigvals))); zipped.sort(); ds, perm = zip(*zipped); ds = -np.real(np.array(ds)); perm = np.array(perm); vecsperm = np.zeros(eigvecs.shape, dtype=complex); for kk in range(len(perm)): # matrix with sorted eigvecs in columns; vecsperm[:, kk] = eigvecs[:, perm[kk]]; vecs_new = np.dot(vecs, vecsperm); vecs_out = np.array(; [np.zeros((A.shape[0], 1), dtype=complex) for k in range(len(ds))]); for kk in range(len(perm)): # matrix with sorted eigvecs in columns; vecs_out[kk][:, 0] = vecs_new[:, kk]; k = 0; rng = np.arange(len(ds)); while k < len(ds):; inds = np.array(abs(ds - ds[k]) < max(; tol, tol * abs(ds[k]))) # get indicies of degenerate eigvals; inds = rng[inds]; if len(inds) > 1: # if at least 2 eigvals are degenerate; vecs_out[inds] = degen(tol, vecs_out[inds],; np.array([ops[jj] for jj in range(1, n)])); k = max(inds) + 1; return vecs_out.  Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, and A.L. Grimsmo.; Last updated on Jan 17, 2018. . Built with Sphinx using a theme provided by Read the Docs. . ",MatchSource.WIKI,docs/4.2/modules/qutip/simdiag.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/simdiag.html
https://qutip.org/docs/4.2/modules/qutip/solver.html:2808,Availability,toler,tolerance,2808,"TRICT LIABILITY, OR TORT; # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE; # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.; ###############################################################################; from __future__ import print_function. __all__ = ['Options', 'Odeoptions', 'Odedata']. import sys; import datetime; from collections import OrderedDict; import os; import warnings; from qutip import __version__; from qutip.qobj import Qobj; import qutip.settings as qset; from types import FunctionType, BuiltinFunctionType. [docs]class Options():; """"""; Class of options for evolution solvers such as :func:`qutip.mesolve` and; :func:`qutip.mcsolve`. Options can be specified either as arguments to the; constructor::. opts = Options(order=10, ...). or by changing the class attributes after creation::. opts = Options(); opts.order = 10. Returns options class to be used as options in evolution solvers. Attributes; ----------. atol : float {1e-8}; Absolute tolerance.; rtol : float {1e-6}; Relative tolerance.; method : str {'adams','bdf'}; Integration method.; order : int {12}; Order of integrator (<=12 'adams', <=5 'bdf'); nsteps : int {2500}; Max. number of internal steps/call.; first_step : float {0}; Size of initial step (0 = automatic).; min_step : float {0}; Minimum step size (0 = automatic).; max_step : float {0}; Maximum step size (0 = automatic); tidy : bool {True,False}; Tidyup Hamiltonian and initial state by removing small terms.; num_cpus : int; Number of cpus used by mcsolver (default = # of cpus).; norm_tol : float; Tolerance used when finding wavefunction norm in mcsolve.; norm_steps : int; Max. number of steps used to find wavefunction norm to within norm_tol; in mcsolve.; average_states : bool {False}; Average states values over trajectories in stochastic solvers.; average_expect : bool {True}; Average expectation values over trajectories for stochastic solvers.; mc_corr_eps : float {1e-10}; Arbitrarily small v",MatchSource.WIKI,docs/4.2/modules/qutip/solver.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/solver.html
https://qutip.org/docs/4.2/modules/qutip/solver.html:2850,Availability,toler,tolerance,2850,"LIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE; # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.; ###############################################################################; from __future__ import print_function. __all__ = ['Options', 'Odeoptions', 'Odedata']. import sys; import datetime; from collections import OrderedDict; import os; import warnings; from qutip import __version__; from qutip.qobj import Qobj; import qutip.settings as qset; from types import FunctionType, BuiltinFunctionType. [docs]class Options():; """"""; Class of options for evolution solvers such as :func:`qutip.mesolve` and; :func:`qutip.mcsolve`. Options can be specified either as arguments to the; constructor::. opts = Options(order=10, ...). or by changing the class attributes after creation::. opts = Options(); opts.order = 10. Returns options class to be used as options in evolution solvers. Attributes; ----------. atol : float {1e-8}; Absolute tolerance.; rtol : float {1e-6}; Relative tolerance.; method : str {'adams','bdf'}; Integration method.; order : int {12}; Order of integrator (<=12 'adams', <=5 'bdf'); nsteps : int {2500}; Max. number of internal steps/call.; first_step : float {0}; Size of initial step (0 = automatic).; min_step : float {0}; Minimum step size (0 = automatic).; max_step : float {0}; Maximum step size (0 = automatic); tidy : bool {True,False}; Tidyup Hamiltonian and initial state by removing small terms.; num_cpus : int; Number of cpus used by mcsolver (default = # of cpus).; norm_tol : float; Tolerance used when finding wavefunction norm in mcsolve.; norm_steps : int; Max. number of steps used to find wavefunction norm to within norm_tol; in mcsolve.; average_states : bool {False}; Average states values over trajectories in stochastic solvers.; average_expect : bool {True}; Average expectation values over trajectories for stochastic solvers.; mc_corr_eps : float {1e-10}; Arbitrarily small value for eliminating any divide-by-zero e",MatchSource.WIKI,docs/4.2/modules/qutip/solver.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/solver.html
https://qutip.org/docs/4.2/modules/qutip/solver.html:3838,Availability,error,errors,3838,"rtol : float {1e-6}; Relative tolerance.; method : str {'adams','bdf'}; Integration method.; order : int {12}; Order of integrator (<=12 'adams', <=5 'bdf'); nsteps : int {2500}; Max. number of internal steps/call.; first_step : float {0}; Size of initial step (0 = automatic).; min_step : float {0}; Minimum step size (0 = automatic).; max_step : float {0}; Maximum step size (0 = automatic); tidy : bool {True,False}; Tidyup Hamiltonian and initial state by removing small terms.; num_cpus : int; Number of cpus used by mcsolver (default = # of cpus).; norm_tol : float; Tolerance used when finding wavefunction norm in mcsolve.; norm_steps : int; Max. number of steps used to find wavefunction norm to within norm_tol; in mcsolve.; average_states : bool {False}; Average states values over trajectories in stochastic solvers.; average_expect : bool {True}; Average expectation values over trajectories for stochastic solvers.; mc_corr_eps : float {1e-10}; Arbitrarily small value for eliminating any divide-by-zero errors in; correlation calculations when using mcsolve.; ntraj : int {500}; Number of trajectories in stochastic solvers.; openmp_threads : int; Number of OPENMP threads to use. Default is number of cpu cores.; rhs_reuse : bool {False,True}; Reuse Hamiltonian data.; rhs_with_state : bool {False,True}; Whether or not to include the state in the Hamiltonian function; callback signature.; rhs_filename : str; Name for compiled Cython file.; seeds : ndarray; Array containing random number seeds for mcsolver.; store_final_state : bool {False, True}; Whether or not to store the final state of the evolution in the; result class.; store_states : bool {False, True}; Whether or not to store the state vectors or density matrices in the; result class, even if expectation values operators are given. If no; expectation are provided, then states are stored by default and this; option has no effect.; use_openmp : bool {True, False}; Use OPENMP for sparse matrix vector multiplication. D",MatchSource.WIKI,docs/4.2/modules/qutip/solver.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/solver.html
https://qutip.org/docs/4.2/modules/qutip/solver.html:5316,Availability,toler,tolerance,5316,".; rhs_with_state : bool {False,True}; Whether or not to include the state in the Hamiltonian function; callback signature.; rhs_filename : str; Name for compiled Cython file.; seeds : ndarray; Array containing random number seeds for mcsolver.; store_final_state : bool {False, True}; Whether or not to store the final state of the evolution in the; result class.; store_states : bool {False, True}; Whether or not to store the state vectors or density matrices in the; result class, even if expectation values operators are given. If no; expectation are provided, then states are stored by default and this; option has no effect.; use_openmp : bool {True, False}; Use OPENMP for sparse matrix vector multiplication. Default; None means auto check. """""". def __init__(self, atol=1e-8, rtol=1e-6, method='adams', order=12,; nsteps=1000, first_step=0, max_step=0, min_step=0,; average_expect=True, average_states=False, tidy=True,; num_cpus=0, norm_tol=1e-3, norm_steps=5, rhs_reuse=False,; rhs_filename=None, ntraj=500, gui=False, rhs_with_state=False,; store_final_state=False, store_states=False, seeds=None,; steady_state_average=False, normalize_output=True,; use_openmp=None, openmp_threads=None):; # Absolute tolerance (default = 1e-8); self.atol = atol; # Relative tolerance (default = 1e-6); self.rtol = rtol; # Integration method (default = 'adams', for stiff 'bdf'); self.method = method; # Max. number of internal steps/call; self.nsteps = nsteps; # Size of initial step (0 = determined by solver); self.first_step = first_step; # Minimal step size (0 = determined by solver); self.min_step = min_step; # Max step size (0 = determined by solver); self.max_step = max_step; # Maximum order used by integrator (<=12 for 'adams', <=5 for 'bdf'); self.order = order; # Average expectation values over trajectories (default = True); self.average_states = average_states; # average expectation values; self.average_expect = average_expect; # Number of trajectories (default = 500); self.ntraj = nt",MatchSource.WIKI,docs/4.2/modules/qutip/solver.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/solver.html
https://qutip.org/docs/4.2/modules/qutip/solver.html:5373,Availability,toler,tolerance,5373,"se, True}; Whether or not to store the final state of the evolution in the; result class.; store_states : bool {False, True}; Whether or not to store the state vectors or density matrices in the; result class, even if expectation values operators are given. If no; expectation are provided, then states are stored by default and this; option has no effect.; use_openmp : bool {True, False}; Use OPENMP for sparse matrix vector multiplication. Default; None means auto check. """""". def __init__(self, atol=1e-8, rtol=1e-6, method='adams', order=12,; nsteps=1000, first_step=0, max_step=0, min_step=0,; average_expect=True, average_states=False, tidy=True,; num_cpus=0, norm_tol=1e-3, norm_steps=5, rhs_reuse=False,; rhs_filename=None, ntraj=500, gui=False, rhs_with_state=False,; store_final_state=False, store_states=False, seeds=None,; steady_state_average=False, normalize_output=True,; use_openmp=None, openmp_threads=None):; # Absolute tolerance (default = 1e-8); self.atol = atol; # Relative tolerance (default = 1e-6); self.rtol = rtol; # Integration method (default = 'adams', for stiff 'bdf'); self.method = method; # Max. number of internal steps/call; self.nsteps = nsteps; # Size of initial step (0 = determined by solver); self.first_step = first_step; # Minimal step size (0 = determined by solver); self.min_step = min_step; # Max step size (0 = determined by solver); self.max_step = max_step; # Maximum order used by integrator (<=12 for 'adams', <=5 for 'bdf'); self.order = order; # Average expectation values over trajectories (default = True); self.average_states = average_states; # average expectation values; self.average_expect = average_expect; # Number of trajectories (default = 500); self.ntraj = ntraj; # Holds seeds for rand num gen; self.seeds = seeds; # tidyup Hamiltonian before calculation (default = True); self.tidy = tidy; # include the state in the function callback signature; self.rhs_with_state = rhs_with_state; # Use preexisting RHS function for time-dependen",MatchSource.WIKI,docs/4.2/modules/qutip/solver.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/solver.html
https://qutip.org/docs/4.2/modules/qutip/solver.html:11208,Availability,toler,tolerance,11208,"ct is not None and len(self.expect) > 0:; s += ""expect = True\nnum_expect = "" + str(self.num_expect) + "", ""; else:; s += ""states = True, expect = True\n"" + \; ""num_expect = "" + str(self.num_expect) + "", ""; s += ""num_collapse = "" + str(self.num_collapse); if self.solver == 'mcsolve':; s += "", ntraj = "" + str(self.ntraj); return s. def __repr__(self):; return self.__str__(). def __getstate__(self):; # defines what happens when Qobj object gets pickled; self.__dict__.update({'qutip_version': __version__[:5]}); return self.__dict__. def __setstate__(self, state):; # defines what happens when loading a pickled Qobj; if 'qutip_version' in state.keys():; del state['qutip_version']; (self.__dict__).update(state). class SolverConfiguration():. def __init__(self):. self.cgen_num = 0. self.reset(). def reset(self):. # General stuff; self.tlist = None # evaluations times; self.ntraj = None # number / list of trajectories; self.options = None # options for solvers; self.norm_tol = None # tolerance for wavefunction norm; self.norm_steps = None # max. number of steps to take in finding; # Initial state stuff; self.psi0 = None # initial state; self.psi0_dims = None # initial state dims; self.psi0_shape = None # initial state shape. # flags for setting time-dependence, collapse ops, and number of times; # codegen has been run; self.cflag = 0 # Flag signaling collapse operators; self.tflag = 0 # Flag signaling time-dependent problem; ; self.soft_reset(). def soft_reset(self):. # Hamiltonian stuff; self.h_td_inds = [] # indicies of time-dependent Hamiltonian operators; self.h_tdterms = [] # List of td strs and funcs ; self.h_data = None # List of sparse matrix data; self.h_ind = None # List of sparse matrix indices; self.h_ptr = None # List of sparse matrix ptrs. # Expectation operator stuff; self.e_num = 0 # number of expect ops; self.e_ops_data = [] # expect op data; self.e_ops_ind = [] # expect op indices; self.e_ops_ptr = [] # expect op indptrs; self.e_ops_isherm = [] # expect op ",MatchSource.WIKI,docs/4.2/modules/qutip/solver.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/solver.html
https://qutip.org/docs/4.2/modules/qutip/solver.html:2940,Deployability,integrat,integrator,2940,"H DAMAGE.; ###############################################################################; from __future__ import print_function. __all__ = ['Options', 'Odeoptions', 'Odedata']. import sys; import datetime; from collections import OrderedDict; import os; import warnings; from qutip import __version__; from qutip.qobj import Qobj; import qutip.settings as qset; from types import FunctionType, BuiltinFunctionType. [docs]class Options():; """"""; Class of options for evolution solvers such as :func:`qutip.mesolve` and; :func:`qutip.mcsolve`. Options can be specified either as arguments to the; constructor::. opts = Options(order=10, ...). or by changing the class attributes after creation::. opts = Options(); opts.order = 10. Returns options class to be used as options in evolution solvers. Attributes; ----------. atol : float {1e-8}; Absolute tolerance.; rtol : float {1e-6}; Relative tolerance.; method : str {'adams','bdf'}; Integration method.; order : int {12}; Order of integrator (<=12 'adams', <=5 'bdf'); nsteps : int {2500}; Max. number of internal steps/call.; first_step : float {0}; Size of initial step (0 = automatic).; min_step : float {0}; Minimum step size (0 = automatic).; max_step : float {0}; Maximum step size (0 = automatic); tidy : bool {True,False}; Tidyup Hamiltonian and initial state by removing small terms.; num_cpus : int; Number of cpus used by mcsolver (default = # of cpus).; norm_tol : float; Tolerance used when finding wavefunction norm in mcsolve.; norm_steps : int; Max. number of steps used to find wavefunction norm to within norm_tol; in mcsolve.; average_states : bool {False}; Average states values over trajectories in stochastic solvers.; average_expect : bool {True}; Average expectation values over trajectories for stochastic solvers.; mc_corr_eps : float {1e-10}; Arbitrarily small value for eliminating any divide-by-zero errors in; correlation calculations when using mcsolve.; ntraj : int {500}; Number of trajectories in stochastic solver",MatchSource.WIKI,docs/4.2/modules/qutip/solver.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/solver.html
https://qutip.org/docs/4.2/modules/qutip/solver.html:5809,Deployability,integrat,integrator,5809,"cation. Default; None means auto check. """""". def __init__(self, atol=1e-8, rtol=1e-6, method='adams', order=12,; nsteps=1000, first_step=0, max_step=0, min_step=0,; average_expect=True, average_states=False, tidy=True,; num_cpus=0, norm_tol=1e-3, norm_steps=5, rhs_reuse=False,; rhs_filename=None, ntraj=500, gui=False, rhs_with_state=False,; store_final_state=False, store_states=False, seeds=None,; steady_state_average=False, normalize_output=True,; use_openmp=None, openmp_threads=None):; # Absolute tolerance (default = 1e-8); self.atol = atol; # Relative tolerance (default = 1e-6); self.rtol = rtol; # Integration method (default = 'adams', for stiff 'bdf'); self.method = method; # Max. number of internal steps/call; self.nsteps = nsteps; # Size of initial step (0 = determined by solver); self.first_step = first_step; # Minimal step size (0 = determined by solver); self.min_step = min_step; # Max step size (0 = determined by solver); self.max_step = max_step; # Maximum order used by integrator (<=12 for 'adams', <=5 for 'bdf'); self.order = order; # Average expectation values over trajectories (default = True); self.average_states = average_states; # average expectation values; self.average_expect = average_expect; # Number of trajectories (default = 500); self.ntraj = ntraj; # Holds seeds for rand num gen; self.seeds = seeds; # tidyup Hamiltonian before calculation (default = True); self.tidy = tidy; # include the state in the function callback signature; self.rhs_with_state = rhs_with_state; # Use preexisting RHS function for time-dependent solvers; self.rhs_reuse = rhs_reuse; # Use filename for preexisting RHS function (will default to last; # compiled function if None & rhs_exists=True); self.rhs_filename = rhs_filename; # small value in mc solver for computing correlations; self.mc_corr_eps = 1e-10; # Number of processors to use (mcsolve only); if num_cpus:; self.num_cpus = num_cpus; else:; self.num_cpus = 0; # Tolerance for wavefunction norm (mcsolve only); sel",MatchSource.WIKI,docs/4.2/modules/qutip/solver.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/solver.html
https://qutip.org/docs/4.2/modules/qutip/solver.html:10687,Deployability,update,update,10687,"ver. """"""; def __init__(self):; self.solver = None; self.times = None; self.states = []; self.expect = []; self.num_expect = 0; self.num_collapse = 0; self.ntraj = None; self.seeds = None; self.col_times = None; self.col_which = None. def __str__(self):; s = ""Result object ""; if self.solver:; s += ""with "" + self.solver + "" data.\n""; else:; s += ""missing solver information.\n""; s += ""-"" * (len(s) - 1) + ""\n""; if self.states is not None and len(self.states) > 0:; s += ""states = True\n""; elif self.expect is not None and len(self.expect) > 0:; s += ""expect = True\nnum_expect = "" + str(self.num_expect) + "", ""; else:; s += ""states = True, expect = True\n"" + \; ""num_expect = "" + str(self.num_expect) + "", ""; s += ""num_collapse = "" + str(self.num_collapse); if self.solver == 'mcsolve':; s += "", ntraj = "" + str(self.ntraj); return s. def __repr__(self):; return self.__str__(). def __getstate__(self):; # defines what happens when Qobj object gets pickled; self.__dict__.update({'qutip_version': __version__[:5]}); return self.__dict__. def __setstate__(self, state):; # defines what happens when loading a pickled Qobj; if 'qutip_version' in state.keys():; del state['qutip_version']; (self.__dict__).update(state). class SolverConfiguration():. def __init__(self):. self.cgen_num = 0. self.reset(). def reset(self):. # General stuff; self.tlist = None # evaluations times; self.ntraj = None # number / list of trajectories; self.options = None # options for solvers; self.norm_tol = None # tolerance for wavefunction norm; self.norm_steps = None # max. number of steps to take in finding; # Initial state stuff; self.psi0 = None # initial state; self.psi0_dims = None # initial state dims; self.psi0_shape = None # initial state shape. # flags for setting time-dependence, collapse ops, and number of times; # codegen has been run; self.cflag = 0 # Flag signaling collapse operators; self.tflag = 0 # Flag signaling time-dependent problem; ; self.soft_reset(). def soft_reset(self):. # Hamiltonian",MatchSource.WIKI,docs/4.2/modules/qutip/solver.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/solver.html
https://qutip.org/docs/4.2/modules/qutip/solver.html:10918,Deployability,update,update,10918," self.col_which = None. def __str__(self):; s = ""Result object ""; if self.solver:; s += ""with "" + self.solver + "" data.\n""; else:; s += ""missing solver information.\n""; s += ""-"" * (len(s) - 1) + ""\n""; if self.states is not None and len(self.states) > 0:; s += ""states = True\n""; elif self.expect is not None and len(self.expect) > 0:; s += ""expect = True\nnum_expect = "" + str(self.num_expect) + "", ""; else:; s += ""states = True, expect = True\n"" + \; ""num_expect = "" + str(self.num_expect) + "", ""; s += ""num_collapse = "" + str(self.num_collapse); if self.solver == 'mcsolve':; s += "", ntraj = "" + str(self.ntraj); return s. def __repr__(self):; return self.__str__(). def __getstate__(self):; # defines what happens when Qobj object gets pickled; self.__dict__.update({'qutip_version': __version__[:5]}); return self.__dict__. def __setstate__(self, state):; # defines what happens when loading a pickled Qobj; if 'qutip_version' in state.keys():; del state['qutip_version']; (self.__dict__).update(state). class SolverConfiguration():. def __init__(self):. self.cgen_num = 0. self.reset(). def reset(self):. # General stuff; self.tlist = None # evaluations times; self.ntraj = None # number / list of trajectories; self.options = None # options for solvers; self.norm_tol = None # tolerance for wavefunction norm; self.norm_steps = None # max. number of steps to take in finding; # Initial state stuff; self.psi0 = None # initial state; self.psi0_dims = None # initial state dims; self.psi0_shape = None # initial state shape. # flags for setting time-dependence, collapse ops, and number of times; # codegen has been run; self.cflag = 0 # Flag signaling collapse operators; self.tflag = 0 # Flag signaling time-dependent problem; ; self.soft_reset(). def soft_reset(self):. # Hamiltonian stuff; self.h_td_inds = [] # indicies of time-dependent Hamiltonian operators; self.h_tdterms = [] # List of td strs and funcs ; self.h_data = None # List of sparse matrix data; self.h_ind = None # List of spa",MatchSource.WIKI,docs/4.2/modules/qutip/solver.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/solver.html
https://qutip.org/docs/4.2/modules/qutip/solver.html:27443,Deployability,update,updated,27443,"[ii]; elif isinstance(c_ops[ii], list):; if isinstance(c_ops[ii][0], Qobj):; _temp_state = c_ops[ii][0]; elif isinstance(c_ops[ii][0], tuple):; do_tests = False; for kk in range(len(c_ops[ii][0])):; _temp_state = c_ops[ii][0][kk]; _structure_check(Hdims, Htype, _temp_state); else:; raise Exception('Invalid td-list element.'); if do_tests:; _structure_check(Hdims, Htype, _temp_state); ; if isinstance(e_ops, list): ; for ii in range(len(e_ops)):; if isinstance(e_ops[ii], Qobj):; _temp_state = e_ops[ii]; elif isinstance(e_ops[ii], list):; _temp_state = e_ops[ii][0]; else:; raise Exception('Invalid td-list element.'); _structure_check(Hdims,Htype,_temp_state); elif isinstance(e_ops, FunctionType):; pass; else:; raise Exception('Invalid e_ops specification.'). def _structure_check(Hdims, Htype, state):; # Input state is a ket vector; if state.type == 'ket':; # Input is Hamiltonian; if Htype == 'oper':; if Hdims[1] != state.dims[0]:; raise Exception('Input operator and ket do not share same structure.'); # Input is super and state is ket; elif Htype == 'super':; if Hdims[1][1] != state.dims[0]:; raise Exception('Input operator and ket do not share same structure.'); else:; raise Exception('Invalid input operator.'); # Input state is a density matrix; elif state.type == 'oper':; # Input is Hamiltonian and state is density matrix; if Htype == 'oper':; if Hdims[1] != state.dims[0]:; raise Exception('Input operators do not share same structure.'); # Input is super op. and state is density matrix; elif Htype == 'super':; if Hdims[1] != state.dims:; raise Exception('Input operators do not share same structure.'). ; #; # create a global instance of the SolverConfiguration class; #; config = SolverConfiguration(). # for backwards compatibility; Odeoptions = Options; Odedata = Result.  Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, and A.L. Grimsmo.; Last updated on Jan 17, 2018. . Built with Sphinx using a theme provided by Read the Docs. . ",MatchSource.WIKI,docs/4.2/modules/qutip/solver.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/solver.html
https://qutip.org/docs/4.2/modules/qutip/solver.html:2940,Integrability,integrat,integrator,2940,"H DAMAGE.; ###############################################################################; from __future__ import print_function. __all__ = ['Options', 'Odeoptions', 'Odedata']. import sys; import datetime; from collections import OrderedDict; import os; import warnings; from qutip import __version__; from qutip.qobj import Qobj; import qutip.settings as qset; from types import FunctionType, BuiltinFunctionType. [docs]class Options():; """"""; Class of options for evolution solvers such as :func:`qutip.mesolve` and; :func:`qutip.mcsolve`. Options can be specified either as arguments to the; constructor::. opts = Options(order=10, ...). or by changing the class attributes after creation::. opts = Options(); opts.order = 10. Returns options class to be used as options in evolution solvers. Attributes; ----------. atol : float {1e-8}; Absolute tolerance.; rtol : float {1e-6}; Relative tolerance.; method : str {'adams','bdf'}; Integration method.; order : int {12}; Order of integrator (<=12 'adams', <=5 'bdf'); nsteps : int {2500}; Max. number of internal steps/call.; first_step : float {0}; Size of initial step (0 = automatic).; min_step : float {0}; Minimum step size (0 = automatic).; max_step : float {0}; Maximum step size (0 = automatic); tidy : bool {True,False}; Tidyup Hamiltonian and initial state by removing small terms.; num_cpus : int; Number of cpus used by mcsolver (default = # of cpus).; norm_tol : float; Tolerance used when finding wavefunction norm in mcsolve.; norm_steps : int; Max. number of steps used to find wavefunction norm to within norm_tol; in mcsolve.; average_states : bool {False}; Average states values over trajectories in stochastic solvers.; average_expect : bool {True}; Average expectation values over trajectories for stochastic solvers.; mc_corr_eps : float {1e-10}; Arbitrarily small value for eliminating any divide-by-zero errors in; correlation calculations when using mcsolve.; ntraj : int {500}; Number of trajectories in stochastic solver",MatchSource.WIKI,docs/4.2/modules/qutip/solver.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/solver.html
https://qutip.org/docs/4.2/modules/qutip/solver.html:5809,Integrability,integrat,integrator,5809,"cation. Default; None means auto check. """""". def __init__(self, atol=1e-8, rtol=1e-6, method='adams', order=12,; nsteps=1000, first_step=0, max_step=0, min_step=0,; average_expect=True, average_states=False, tidy=True,; num_cpus=0, norm_tol=1e-3, norm_steps=5, rhs_reuse=False,; rhs_filename=None, ntraj=500, gui=False, rhs_with_state=False,; store_final_state=False, store_states=False, seeds=None,; steady_state_average=False, normalize_output=True,; use_openmp=None, openmp_threads=None):; # Absolute tolerance (default = 1e-8); self.atol = atol; # Relative tolerance (default = 1e-6); self.rtol = rtol; # Integration method (default = 'adams', for stiff 'bdf'); self.method = method; # Max. number of internal steps/call; self.nsteps = nsteps; # Size of initial step (0 = determined by solver); self.first_step = first_step; # Minimal step size (0 = determined by solver); self.min_step = min_step; # Max step size (0 = determined by solver); self.max_step = max_step; # Maximum order used by integrator (<=12 for 'adams', <=5 for 'bdf'); self.order = order; # Average expectation values over trajectories (default = True); self.average_states = average_states; # average expectation values; self.average_expect = average_expect; # Number of trajectories (default = 500); self.ntraj = ntraj; # Holds seeds for rand num gen; self.seeds = seeds; # tidyup Hamiltonian before calculation (default = True); self.tidy = tidy; # include the state in the function callback signature; self.rhs_with_state = rhs_with_state; # Use preexisting RHS function for time-dependent solvers; self.rhs_reuse = rhs_reuse; # Use filename for preexisting RHS function (will default to last; # compiled function if None & rhs_exists=True); self.rhs_filename = rhs_filename; # small value in mc solver for computing correlations; self.mc_corr_eps = 1e-10; # Number of processors to use (mcsolve only); if num_cpus:; self.num_cpus = num_cpus; else:; self.num_cpus = 0; # Tolerance for wavefunction norm (mcsolve only); sel",MatchSource.WIKI,docs/4.2/modules/qutip/solver.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/solver.html
https://qutip.org/docs/4.2/modules/qutip/solver.html:6370,Integrability,depend,dependent,6370,"elf.atol = atol; # Relative tolerance (default = 1e-6); self.rtol = rtol; # Integration method (default = 'adams', for stiff 'bdf'); self.method = method; # Max. number of internal steps/call; self.nsteps = nsteps; # Size of initial step (0 = determined by solver); self.first_step = first_step; # Minimal step size (0 = determined by solver); self.min_step = min_step; # Max step size (0 = determined by solver); self.max_step = max_step; # Maximum order used by integrator (<=12 for 'adams', <=5 for 'bdf'); self.order = order; # Average expectation values over trajectories (default = True); self.average_states = average_states; # average expectation values; self.average_expect = average_expect; # Number of trajectories (default = 500); self.ntraj = ntraj; # Holds seeds for rand num gen; self.seeds = seeds; # tidyup Hamiltonian before calculation (default = True); self.tidy = tidy; # include the state in the function callback signature; self.rhs_with_state = rhs_with_state; # Use preexisting RHS function for time-dependent solvers; self.rhs_reuse = rhs_reuse; # Use filename for preexisting RHS function (will default to last; # compiled function if None & rhs_exists=True); self.rhs_filename = rhs_filename; # small value in mc solver for computing correlations; self.mc_corr_eps = 1e-10; # Number of processors to use (mcsolve only); if num_cpus:; self.num_cpus = num_cpus; else:; self.num_cpus = 0; # Tolerance for wavefunction norm (mcsolve only); self.norm_tol = norm_tol; # Max. number of steps taken to find wavefunction norm to within; # norm_tol (mcsolve only); self.norm_steps = norm_steps; # Number of threads for openmp; if openmp_threads is None:; self.openmp_threads = qset.num_cpus; else:; self.openmp_threads = openmp_threads; # store final state?; self.store_final_state = store_final_state; # store states even if expectation operators are given?; self.store_states = store_states; # average mcsolver density matricies assuming steady state evolution; self.steady_state_a",MatchSource.WIKI,docs/4.2/modules/qutip/solver.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/solver.html
https://qutip.org/docs/4.2/modules/qutip/solver.html:11479,Integrability,depend,dependence,11479," += "", ntraj = "" + str(self.ntraj); return s. def __repr__(self):; return self.__str__(). def __getstate__(self):; # defines what happens when Qobj object gets pickled; self.__dict__.update({'qutip_version': __version__[:5]}); return self.__dict__. def __setstate__(self, state):; # defines what happens when loading a pickled Qobj; if 'qutip_version' in state.keys():; del state['qutip_version']; (self.__dict__).update(state). class SolverConfiguration():. def __init__(self):. self.cgen_num = 0. self.reset(). def reset(self):. # General stuff; self.tlist = None # evaluations times; self.ntraj = None # number / list of trajectories; self.options = None # options for solvers; self.norm_tol = None # tolerance for wavefunction norm; self.norm_steps = None # max. number of steps to take in finding; # Initial state stuff; self.psi0 = None # initial state; self.psi0_dims = None # initial state dims; self.psi0_shape = None # initial state shape. # flags for setting time-dependence, collapse ops, and number of times; # codegen has been run; self.cflag = 0 # Flag signaling collapse operators; self.tflag = 0 # Flag signaling time-dependent problem; ; self.soft_reset(). def soft_reset(self):. # Hamiltonian stuff; self.h_td_inds = [] # indicies of time-dependent Hamiltonian operators; self.h_tdterms = [] # List of td strs and funcs ; self.h_data = None # List of sparse matrix data; self.h_ind = None # List of sparse matrix indices; self.h_ptr = None # List of sparse matrix ptrs. # Expectation operator stuff; self.e_num = 0 # number of expect ops; self.e_ops_data = [] # expect op data; self.e_ops_ind = [] # expect op indices; self.e_ops_ptr = [] # expect op indptrs; self.e_ops_isherm = [] # expect op isherm. # Collapse operator stuff; self.c_num = 0 # number of collapse ops; self.c_const_inds = [] # indicies of constant collapse operators; self.c_td_inds = [] # indicies of time-dependent collapse operators; self.c_ops_data = [] # collapse op data; self.c_ops_ind = [] # collapse op ",MatchSource.WIKI,docs/4.2/modules/qutip/solver.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/solver.html
https://qutip.org/docs/4.2/modules/qutip/solver.html:11639,Integrability,depend,dependent,11639,"ppens when Qobj object gets pickled; self.__dict__.update({'qutip_version': __version__[:5]}); return self.__dict__. def __setstate__(self, state):; # defines what happens when loading a pickled Qobj; if 'qutip_version' in state.keys():; del state['qutip_version']; (self.__dict__).update(state). class SolverConfiguration():. def __init__(self):. self.cgen_num = 0. self.reset(). def reset(self):. # General stuff; self.tlist = None # evaluations times; self.ntraj = None # number / list of trajectories; self.options = None # options for solvers; self.norm_tol = None # tolerance for wavefunction norm; self.norm_steps = None # max. number of steps to take in finding; # Initial state stuff; self.psi0 = None # initial state; self.psi0_dims = None # initial state dims; self.psi0_shape = None # initial state shape. # flags for setting time-dependence, collapse ops, and number of times; # codegen has been run; self.cflag = 0 # Flag signaling collapse operators; self.tflag = 0 # Flag signaling time-dependent problem; ; self.soft_reset(). def soft_reset(self):. # Hamiltonian stuff; self.h_td_inds = [] # indicies of time-dependent Hamiltonian operators; self.h_tdterms = [] # List of td strs and funcs ; self.h_data = None # List of sparse matrix data; self.h_ind = None # List of sparse matrix indices; self.h_ptr = None # List of sparse matrix ptrs. # Expectation operator stuff; self.e_num = 0 # number of expect ops; self.e_ops_data = [] # expect op data; self.e_ops_ind = [] # expect op indices; self.e_ops_ptr = [] # expect op indptrs; self.e_ops_isherm = [] # expect op isherm. # Collapse operator stuff; self.c_num = 0 # number of collapse ops; self.c_const_inds = [] # indicies of constant collapse operators; self.c_td_inds = [] # indicies of time-dependent collapse operators; self.c_ops_data = [] # collapse op data; self.c_ops_ind = [] # collapse op indices; self.c_ops_ptr = [] # collapse op indptrs; self.c_args = [] # store args for time-dependent collapse func. # Norm collapse ",MatchSource.WIKI,docs/4.2/modules/qutip/solver.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/solver.html
https://qutip.org/docs/4.2/modules/qutip/solver.html:11762,Integrability,depend,dependent,11762,"ate__(self, state):; # defines what happens when loading a pickled Qobj; if 'qutip_version' in state.keys():; del state['qutip_version']; (self.__dict__).update(state). class SolverConfiguration():. def __init__(self):. self.cgen_num = 0. self.reset(). def reset(self):. # General stuff; self.tlist = None # evaluations times; self.ntraj = None # number / list of trajectories; self.options = None # options for solvers; self.norm_tol = None # tolerance for wavefunction norm; self.norm_steps = None # max. number of steps to take in finding; # Initial state stuff; self.psi0 = None # initial state; self.psi0_dims = None # initial state dims; self.psi0_shape = None # initial state shape. # flags for setting time-dependence, collapse ops, and number of times; # codegen has been run; self.cflag = 0 # Flag signaling collapse operators; self.tflag = 0 # Flag signaling time-dependent problem; ; self.soft_reset(). def soft_reset(self):. # Hamiltonian stuff; self.h_td_inds = [] # indicies of time-dependent Hamiltonian operators; self.h_tdterms = [] # List of td strs and funcs ; self.h_data = None # List of sparse matrix data; self.h_ind = None # List of sparse matrix indices; self.h_ptr = None # List of sparse matrix ptrs. # Expectation operator stuff; self.e_num = 0 # number of expect ops; self.e_ops_data = [] # expect op data; self.e_ops_ind = [] # expect op indices; self.e_ops_ptr = [] # expect op indptrs; self.e_ops_isherm = [] # expect op isherm. # Collapse operator stuff; self.c_num = 0 # number of collapse ops; self.c_const_inds = [] # indicies of constant collapse operators; self.c_td_inds = [] # indicies of time-dependent collapse operators; self.c_ops_data = [] # collapse op data; self.c_ops_ind = [] # collapse op indices; self.c_ops_ptr = [] # collapse op indptrs; self.c_args = [] # store args for time-dependent collapse func. # Norm collapse operator stuff; self.n_ops_data = [] # norm collapse op data; self.n_ops_ind = [] # norm collapse op indices; self.n_ops_ptr = [",MatchSource.WIKI,docs/4.2/modules/qutip/solver.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/solver.html
https://qutip.org/docs/4.2/modules/qutip/solver.html:12399,Integrability,depend,dependent,12399,"te dims; self.psi0_shape = None # initial state shape. # flags for setting time-dependence, collapse ops, and number of times; # codegen has been run; self.cflag = 0 # Flag signaling collapse operators; self.tflag = 0 # Flag signaling time-dependent problem; ; self.soft_reset(). def soft_reset(self):. # Hamiltonian stuff; self.h_td_inds = [] # indicies of time-dependent Hamiltonian operators; self.h_tdterms = [] # List of td strs and funcs ; self.h_data = None # List of sparse matrix data; self.h_ind = None # List of sparse matrix indices; self.h_ptr = None # List of sparse matrix ptrs. # Expectation operator stuff; self.e_num = 0 # number of expect ops; self.e_ops_data = [] # expect op data; self.e_ops_ind = [] # expect op indices; self.e_ops_ptr = [] # expect op indptrs; self.e_ops_isherm = [] # expect op isherm. # Collapse operator stuff; self.c_num = 0 # number of collapse ops; self.c_const_inds = [] # indicies of constant collapse operators; self.c_td_inds = [] # indicies of time-dependent collapse operators; self.c_ops_data = [] # collapse op data; self.c_ops_ind = [] # collapse op indices; self.c_ops_ptr = [] # collapse op indptrs; self.c_args = [] # store args for time-dependent collapse func. # Norm collapse operator stuff; self.n_ops_data = [] # norm collapse op data; self.n_ops_ind = [] # norm collapse op indices; self.n_ops_ptr = [] # norm collapse op indptrs. # holds executable strings for time-dependent collapse evaluation; self.col_expect_code = None; self.col_spmv_code = None. # hold stuff for function list based time dependence; self.h_td_inds = []; self.h_td_data = []; self.h_td_ind = []; self.h_td_ptr = []; self.h_funcs = None; self.h_func_args = None; self.c_funcs = None; self.c_func_args = None; ; # time-dependent (TD) function stuff; self.tdfunc = None # Placeholder for TD RHS function.; self.tdname = None # Name of td .pyx file; self.colspmv = None # Placeholder for TD col-spmv function.; self.colexpect = None # Placeholder for TD col_expect fu",MatchSource.WIKI,docs/4.2/modules/qutip/solver.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/solver.html
https://qutip.org/docs/4.2/modules/qutip/solver.html:12595,Integrability,depend,dependent,12595," operators; self.tflag = 0 # Flag signaling time-dependent problem; ; self.soft_reset(). def soft_reset(self):. # Hamiltonian stuff; self.h_td_inds = [] # indicies of time-dependent Hamiltonian operators; self.h_tdterms = [] # List of td strs and funcs ; self.h_data = None # List of sparse matrix data; self.h_ind = None # List of sparse matrix indices; self.h_ptr = None # List of sparse matrix ptrs. # Expectation operator stuff; self.e_num = 0 # number of expect ops; self.e_ops_data = [] # expect op data; self.e_ops_ind = [] # expect op indices; self.e_ops_ptr = [] # expect op indptrs; self.e_ops_isherm = [] # expect op isherm. # Collapse operator stuff; self.c_num = 0 # number of collapse ops; self.c_const_inds = [] # indicies of constant collapse operators; self.c_td_inds = [] # indicies of time-dependent collapse operators; self.c_ops_data = [] # collapse op data; self.c_ops_ind = [] # collapse op indices; self.c_ops_ptr = [] # collapse op indptrs; self.c_args = [] # store args for time-dependent collapse func. # Norm collapse operator stuff; self.n_ops_data = [] # norm collapse op data; self.n_ops_ind = [] # norm collapse op indices; self.n_ops_ptr = [] # norm collapse op indptrs. # holds executable strings for time-dependent collapse evaluation; self.col_expect_code = None; self.col_spmv_code = None. # hold stuff for function list based time dependence; self.h_td_inds = []; self.h_td_data = []; self.h_td_ind = []; self.h_td_ptr = []; self.h_funcs = None; self.h_func_args = None; self.c_funcs = None; self.c_func_args = None; ; # time-dependent (TD) function stuff; self.tdfunc = None # Placeholder for TD RHS function.; self.tdname = None # Name of td .pyx file; self.colspmv = None # Placeholder for TD col-spmv function.; self.colexpect = None # Placeholder for TD col_expect function.; self.string = None # Holds string of variables passed to td solver; . def _format_time(t, tt=None, ttt=None):; time_str = str(datetime.timedelta(seconds=t)); if tt is not None and t",MatchSource.WIKI,docs/4.2/modules/qutip/solver.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/solver.html
https://qutip.org/docs/4.2/modules/qutip/solver.html:12830,Integrability,depend,dependent,12830,"trs and funcs ; self.h_data = None # List of sparse matrix data; self.h_ind = None # List of sparse matrix indices; self.h_ptr = None # List of sparse matrix ptrs. # Expectation operator stuff; self.e_num = 0 # number of expect ops; self.e_ops_data = [] # expect op data; self.e_ops_ind = [] # expect op indices; self.e_ops_ptr = [] # expect op indptrs; self.e_ops_isherm = [] # expect op isherm. # Collapse operator stuff; self.c_num = 0 # number of collapse ops; self.c_const_inds = [] # indicies of constant collapse operators; self.c_td_inds = [] # indicies of time-dependent collapse operators; self.c_ops_data = [] # collapse op data; self.c_ops_ind = [] # collapse op indices; self.c_ops_ptr = [] # collapse op indptrs; self.c_args = [] # store args for time-dependent collapse func. # Norm collapse operator stuff; self.n_ops_data = [] # norm collapse op data; self.n_ops_ind = [] # norm collapse op indices; self.n_ops_ptr = [] # norm collapse op indptrs. # holds executable strings for time-dependent collapse evaluation; self.col_expect_code = None; self.col_spmv_code = None. # hold stuff for function list based time dependence; self.h_td_inds = []; self.h_td_data = []; self.h_td_ind = []; self.h_td_ptr = []; self.h_funcs = None; self.h_func_args = None; self.c_funcs = None; self.c_func_args = None; ; # time-dependent (TD) function stuff; self.tdfunc = None # Placeholder for TD RHS function.; self.tdname = None # Name of td .pyx file; self.colspmv = None # Placeholder for TD col-spmv function.; self.colexpect = None # Placeholder for TD col_expect function.; self.string = None # Holds string of variables passed to td solver; . def _format_time(t, tt=None, ttt=None):; time_str = str(datetime.timedelta(seconds=t)); if tt is not None and ttt is not None:; sect_percent = 100*t/tt; solve_percent = 100*t/ttt; time_str += "" ({:03.2f}% section, {:03.2f}% total)"".format(; sect_percent, solve_percent); elif tt is not None:; sect_percent = 100*t/tt; time_str += "" ({:03.2f}% section)",MatchSource.WIKI,docs/4.2/modules/qutip/solver.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/solver.html
https://qutip.org/docs/4.2/modules/qutip/solver.html:12959,Integrability,depend,dependence,12959,"elf.h_ptr = None # List of sparse matrix ptrs. # Expectation operator stuff; self.e_num = 0 # number of expect ops; self.e_ops_data = [] # expect op data; self.e_ops_ind = [] # expect op indices; self.e_ops_ptr = [] # expect op indptrs; self.e_ops_isherm = [] # expect op isherm. # Collapse operator stuff; self.c_num = 0 # number of collapse ops; self.c_const_inds = [] # indicies of constant collapse operators; self.c_td_inds = [] # indicies of time-dependent collapse operators; self.c_ops_data = [] # collapse op data; self.c_ops_ind = [] # collapse op indices; self.c_ops_ptr = [] # collapse op indptrs; self.c_args = [] # store args for time-dependent collapse func. # Norm collapse operator stuff; self.n_ops_data = [] # norm collapse op data; self.n_ops_ind = [] # norm collapse op indices; self.n_ops_ptr = [] # norm collapse op indptrs. # holds executable strings for time-dependent collapse evaluation; self.col_expect_code = None; self.col_spmv_code = None. # hold stuff for function list based time dependence; self.h_td_inds = []; self.h_td_data = []; self.h_td_ind = []; self.h_td_ptr = []; self.h_funcs = None; self.h_func_args = None; self.c_funcs = None; self.c_func_args = None; ; # time-dependent (TD) function stuff; self.tdfunc = None # Placeholder for TD RHS function.; self.tdname = None # Name of td .pyx file; self.colspmv = None # Placeholder for TD col-spmv function.; self.colexpect = None # Placeholder for TD col_expect function.; self.string = None # Holds string of variables passed to td solver; . def _format_time(t, tt=None, ttt=None):; time_str = str(datetime.timedelta(seconds=t)); if tt is not None and ttt is not None:; sect_percent = 100*t/tt; solve_percent = 100*t/ttt; time_str += "" ({:03.2f}% section, {:03.2f}% total)"".format(; sect_percent, solve_percent); elif tt is not None:; sect_percent = 100*t/tt; time_str += "" ({:03.2f}% section)"".format(sect_percent); ; elif ttt is not None:; solve_percent = 100*t/ttt; time_str += "" ({:03.2f}% total)"".format(",MatchSource.WIKI,docs/4.2/modules/qutip/solver.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/solver.html
https://qutip.org/docs/4.2/modules/qutip/solver.html:13154,Integrability,depend,dependent,13154,"= [] # expect op indptrs; self.e_ops_isherm = [] # expect op isherm. # Collapse operator stuff; self.c_num = 0 # number of collapse ops; self.c_const_inds = [] # indicies of constant collapse operators; self.c_td_inds = [] # indicies of time-dependent collapse operators; self.c_ops_data = [] # collapse op data; self.c_ops_ind = [] # collapse op indices; self.c_ops_ptr = [] # collapse op indptrs; self.c_args = [] # store args for time-dependent collapse func. # Norm collapse operator stuff; self.n_ops_data = [] # norm collapse op data; self.n_ops_ind = [] # norm collapse op indices; self.n_ops_ptr = [] # norm collapse op indptrs. # holds executable strings for time-dependent collapse evaluation; self.col_expect_code = None; self.col_spmv_code = None. # hold stuff for function list based time dependence; self.h_td_inds = []; self.h_td_data = []; self.h_td_ind = []; self.h_td_ptr = []; self.h_funcs = None; self.h_func_args = None; self.c_funcs = None; self.c_func_args = None; ; # time-dependent (TD) function stuff; self.tdfunc = None # Placeholder for TD RHS function.; self.tdname = None # Name of td .pyx file; self.colspmv = None # Placeholder for TD col-spmv function.; self.colexpect = None # Placeholder for TD col_expect function.; self.string = None # Holds string of variables passed to td solver; . def _format_time(t, tt=None, ttt=None):; time_str = str(datetime.timedelta(seconds=t)); if tt is not None and ttt is not None:; sect_percent = 100*t/tt; solve_percent = 100*t/ttt; time_str += "" ({:03.2f}% section, {:03.2f}% total)"".format(; sect_percent, solve_percent); elif tt is not None:; sect_percent = 100*t/tt; time_str += "" ({:03.2f}% section)"".format(sect_percent); ; elif ttt is not None:; solve_percent = 100*t/ttt; time_str += "" ({:03.2f}% total)"".format(solve_percent); ; return time_str. [docs]class Stats(object):; """"""; Statistical information on the solver performance; Statistics can be grouped into sections.; If no section names are given in the the contructor",MatchSource.WIKI,docs/4.2/modules/qutip/solver.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/solver.html
https://qutip.org/docs/4.2/modules/qutip/solver.html:17730,Integrability,message,message,17730," value; ; value : int; Initial value of the count, or added to an existing count; ; section: string or `class` : _StatsSection; Section which to add the count to.; If None given, the default (first) section will be used; """"""; ; self._get_section(section).add_count(key, value); ; [docs] def add_timing(self, key, value, section=None):; """"""; Add value to timing. If key does not already exist in section then; it is created with this value.; If key already exists it is increased by the give value; value is expected to be a float, and given in seconds.; ; Parameters; ----------; key : string; key for the section.timings dictionary; reusing a key will result in numerical addition of value; ; value : int; Initial value of the timing, or added to an existing timing; ; section: string or `class` : _StatsSection; Section which to add the timing to.; If None given, the default (first) section will be used; """""" ; self._get_section(section).add_timing(key, value); ; [docs] def add_message(self, key, value, section=None, sep="";""):; """"""; Add value to message. If key does not already exist in section then; it is created with this value.; If key already exists the value is added to the message; The value will be converted to a string; ; Parameters; ----------; key : string; key for the section.messages dictionary; reusing a key will result in concatenation of value; ; value : int; Initial value of the message, or added to an existing message; ; sep : string; Message will be prefixed with this string when concatenating; ; section: string or `class` : _StatsSection; Section which to add the message to.; If None given, the default (first) section will be used; """""" ; self._get_section(section).add_message(key, value, sep=sep); ; [docs] def set_total_time(self, value, section=None):; """"""; Sets the total time for the complete solve or for a specific section; value is expected to be a float, and given in seconds; ; Parameters; ----------; value : float; Time in seconds to complete the solve",MatchSource.WIKI,docs/4.2/modules/qutip/solver.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/solver.html
https://qutip.org/docs/4.2/modules/qutip/solver.html:17866,Integrability,message,message,17866,"ed; """"""; ; self._get_section(section).add_count(key, value); ; [docs] def add_timing(self, key, value, section=None):; """"""; Add value to timing. If key does not already exist in section then; it is created with this value.; If key already exists it is increased by the give value; value is expected to be a float, and given in seconds.; ; Parameters; ----------; key : string; key for the section.timings dictionary; reusing a key will result in numerical addition of value; ; value : int; Initial value of the timing, or added to an existing timing; ; section: string or `class` : _StatsSection; Section which to add the timing to.; If None given, the default (first) section will be used; """""" ; self._get_section(section).add_timing(key, value); ; [docs] def add_message(self, key, value, section=None, sep="";""):; """"""; Add value to message. If key does not already exist in section then; it is created with this value.; If key already exists the value is added to the message; The value will be converted to a string; ; Parameters; ----------; key : string; key for the section.messages dictionary; reusing a key will result in concatenation of value; ; value : int; Initial value of the message, or added to an existing message; ; sep : string; Message will be prefixed with this string when concatenating; ; section: string or `class` : _StatsSection; Section which to add the message to.; If None given, the default (first) section will be used; """""" ; self._get_section(section).add_message(key, value, sep=sep); ; [docs] def set_total_time(self, value, section=None):; """"""; Sets the total time for the complete solve or for a specific section; value is expected to be a float, and given in seconds; ; Parameters; ----------; value : float; Time in seconds to complete the solver section; ; section : string or `class` : _StatsSection; Section which to set the total_time for; If None given, the total_time for complete solve is set; """"""; if not isinstance(value, float):; try:; value = float(va",MatchSource.WIKI,docs/4.2/modules/qutip/solver.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/solver.html
https://qutip.org/docs/4.2/modules/qutip/solver.html:17976,Integrability,message,messages,17976,"dy exists it is increased by the give value; value is expected to be a float, and given in seconds.; ; Parameters; ----------; key : string; key for the section.timings dictionary; reusing a key will result in numerical addition of value; ; value : int; Initial value of the timing, or added to an existing timing; ; section: string or `class` : _StatsSection; Section which to add the timing to.; If None given, the default (first) section will be used; """""" ; self._get_section(section).add_timing(key, value); ; [docs] def add_message(self, key, value, section=None, sep="";""):; """"""; Add value to message. If key does not already exist in section then; it is created with this value.; If key already exists the value is added to the message; The value will be converted to a string; ; Parameters; ----------; key : string; key for the section.messages dictionary; reusing a key will result in concatenation of value; ; value : int; Initial value of the message, or added to an existing message; ; sep : string; Message will be prefixed with this string when concatenating; ; section: string or `class` : _StatsSection; Section which to add the message to.; If None given, the default (first) section will be used; """""" ; self._get_section(section).add_message(key, value, sep=sep); ; [docs] def set_total_time(self, value, section=None):; """"""; Sets the total time for the complete solve or for a specific section; value is expected to be a float, and given in seconds; ; Parameters; ----------; value : float; Time in seconds to complete the solver section; ; section : string or `class` : _StatsSection; Section which to set the total_time for; If None given, the total_time for complete solve is set; """"""; if not isinstance(value, float):; try:; value = float(value); except:; raise TypeError(""value is expected to be a float""); ; if section is None:; self.total_time = value; else:; sect = self._get_section(section); sect.total_time = value; ; [docs] def report(self, output=sys.stdout):; """"""; Re",MatchSource.WIKI,docs/4.2/modules/qutip/solver.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/solver.html
https://qutip.org/docs/4.2/modules/qutip/solver.html:18086,Integrability,message,message,18086,"dy exists it is increased by the give value; value is expected to be a float, and given in seconds.; ; Parameters; ----------; key : string; key for the section.timings dictionary; reusing a key will result in numerical addition of value; ; value : int; Initial value of the timing, or added to an existing timing; ; section: string or `class` : _StatsSection; Section which to add the timing to.; If None given, the default (first) section will be used; """""" ; self._get_section(section).add_timing(key, value); ; [docs] def add_message(self, key, value, section=None, sep="";""):; """"""; Add value to message. If key does not already exist in section then; it is created with this value.; If key already exists the value is added to the message; The value will be converted to a string; ; Parameters; ----------; key : string; key for the section.messages dictionary; reusing a key will result in concatenation of value; ; value : int; Initial value of the message, or added to an existing message; ; sep : string; Message will be prefixed with this string when concatenating; ; section: string or `class` : _StatsSection; Section which to add the message to.; If None given, the default (first) section will be used; """""" ; self._get_section(section).add_message(key, value, sep=sep); ; [docs] def set_total_time(self, value, section=None):; """"""; Sets the total time for the complete solve or for a specific section; value is expected to be a float, and given in seconds; ; Parameters; ----------; value : float; Time in seconds to complete the solver section; ; section : string or `class` : _StatsSection; Section which to set the total_time for; If None given, the total_time for complete solve is set; """"""; if not isinstance(value, float):; try:; value = float(value); except:; raise TypeError(""value is expected to be a float""); ; if section is None:; self.total_time = value; else:; sect = self._get_section(section); sect.total_time = value; ; [docs] def report(self, output=sys.stdout):; """"""; Re",MatchSource.WIKI,docs/4.2/modules/qutip/solver.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/solver.html
https://qutip.org/docs/4.2/modules/qutip/solver.html:18119,Integrability,message,message,18119,"dy exists it is increased by the give value; value is expected to be a float, and given in seconds.; ; Parameters; ----------; key : string; key for the section.timings dictionary; reusing a key will result in numerical addition of value; ; value : int; Initial value of the timing, or added to an existing timing; ; section: string or `class` : _StatsSection; Section which to add the timing to.; If None given, the default (first) section will be used; """""" ; self._get_section(section).add_timing(key, value); ; [docs] def add_message(self, key, value, section=None, sep="";""):; """"""; Add value to message. If key does not already exist in section then; it is created with this value.; If key already exists the value is added to the message; The value will be converted to a string; ; Parameters; ----------; key : string; key for the section.messages dictionary; reusing a key will result in concatenation of value; ; value : int; Initial value of the message, or added to an existing message; ; sep : string; Message will be prefixed with this string when concatenating; ; section: string or `class` : _StatsSection; Section which to add the message to.; If None given, the default (first) section will be used; """""" ; self._get_section(section).add_message(key, value, sep=sep); ; [docs] def set_total_time(self, value, section=None):; """"""; Sets the total time for the complete solve or for a specific section; value is expected to be a float, and given in seconds; ; Parameters; ----------; value : float; Time in seconds to complete the solver section; ; section : string or `class` : _StatsSection; Section which to set the total_time for; If None given, the total_time for complete solve is set; """"""; if not isinstance(value, float):; try:; value = float(value); except:; raise TypeError(""value is expected to be a float""); ; if section is None:; self.total_time = value; else:; sect = self._get_section(section); sect.total_time = value; ; [docs] def report(self, output=sys.stdout):; """"""; Re",MatchSource.WIKI,docs/4.2/modules/qutip/solver.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/solver.html
https://qutip.org/docs/4.2/modules/qutip/solver.html:18277,Integrability,message,message,18277,"dy exists it is increased by the give value; value is expected to be a float, and given in seconds.; ; Parameters; ----------; key : string; key for the section.timings dictionary; reusing a key will result in numerical addition of value; ; value : int; Initial value of the timing, or added to an existing timing; ; section: string or `class` : _StatsSection; Section which to add the timing to.; If None given, the default (first) section will be used; """""" ; self._get_section(section).add_timing(key, value); ; [docs] def add_message(self, key, value, section=None, sep="";""):; """"""; Add value to message. If key does not already exist in section then; it is created with this value.; If key already exists the value is added to the message; The value will be converted to a string; ; Parameters; ----------; key : string; key for the section.messages dictionary; reusing a key will result in concatenation of value; ; value : int; Initial value of the message, or added to an existing message; ; sep : string; Message will be prefixed with this string when concatenating; ; section: string or `class` : _StatsSection; Section which to add the message to.; If None given, the default (first) section will be used; """""" ; self._get_section(section).add_message(key, value, sep=sep); ; [docs] def set_total_time(self, value, section=None):; """"""; Sets the total time for the complete solve or for a specific section; value is expected to be a float, and given in seconds; ; Parameters; ----------; value : float; Time in seconds to complete the solver section; ; section : string or `class` : _StatsSection; Section which to set the total_time for; If None given, the total_time for complete solve is set; """"""; if not isinstance(value, float):; try:; value = float(value); except:; raise TypeError(""value is expected to be a float""); ; if section is None:; self.total_time = value; else:; sect = self._get_section(section); sect.total_time = value; ; [docs] def report(self, output=sys.stdout):; """"""; Re",MatchSource.WIKI,docs/4.2/modules/qutip/solver.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/solver.html
https://qutip.org/docs/4.2/modules/qutip/solver.html:19161,Integrability,message,messages,19161," will be prefixed with this string when concatenating; ; section: string or `class` : _StatsSection; Section which to add the message to.; If None given, the default (first) section will be used; """""" ; self._get_section(section).add_message(key, value, sep=sep); ; [docs] def set_total_time(self, value, section=None):; """"""; Sets the total time for the complete solve or for a specific section; value is expected to be a float, and given in seconds; ; Parameters; ----------; value : float; Time in seconds to complete the solver section; ; section : string or `class` : _StatsSection; Section which to set the total_time for; If None given, the total_time for complete solve is set; """"""; if not isinstance(value, float):; try:; value = float(value); except:; raise TypeError(""value is expected to be a float""); ; if section is None:; self.total_time = value; else:; sect = self._get_section(section); sect.total_time = value; ; [docs] def report(self, output=sys.stdout):; """"""; Report the counts, timings and messages from the sections.; Sections are reported in the order that the names were supplied; in the constructor.; The counts, timings and messages are reported in the order that they; are added to the sections; The output can be written to anything that supports a write method,; e.g. a file or the console (default); The output is intended to in markdown format; ; Parameters; ----------; output : stream; file or console stream - anything that support write - where; the output will be written; """"""; ; if not hasattr(output, 'write'):; raise TypeError(""output must have a write method""); ; if self.header:; output.write(""{}\n{}\n"".format(self.header, ; (""=""*len(self.header)))); for name, sect in self.sections.items():; sect.report(output); ; if self.total_time is not None:; output.write(""\nSummary\n-------\n""); output.write(""{}\t solver total time\n"".format(; _format_time(self.total_time))); ; [docs] def clear(self):; """"""; Clear counts, timings and messages from all sections; """"""; ",MatchSource.WIKI,docs/4.2/modules/qutip/solver.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/solver.html
https://qutip.org/docs/4.2/modules/qutip/solver.html:19300,Integrability,message,messages,19300,"get_section(section).add_message(key, value, sep=sep); ; [docs] def set_total_time(self, value, section=None):; """"""; Sets the total time for the complete solve or for a specific section; value is expected to be a float, and given in seconds; ; Parameters; ----------; value : float; Time in seconds to complete the solver section; ; section : string or `class` : _StatsSection; Section which to set the total_time for; If None given, the total_time for complete solve is set; """"""; if not isinstance(value, float):; try:; value = float(value); except:; raise TypeError(""value is expected to be a float""); ; if section is None:; self.total_time = value; else:; sect = self._get_section(section); sect.total_time = value; ; [docs] def report(self, output=sys.stdout):; """"""; Report the counts, timings and messages from the sections.; Sections are reported in the order that the names were supplied; in the constructor.; The counts, timings and messages are reported in the order that they; are added to the sections; The output can be written to anything that supports a write method,; e.g. a file or the console (default); The output is intended to in markdown format; ; Parameters; ----------; output : stream; file or console stream - anything that support write - where; the output will be written; """"""; ; if not hasattr(output, 'write'):; raise TypeError(""output must have a write method""); ; if self.header:; output.write(""{}\n{}\n"".format(self.header, ; (""=""*len(self.header)))); for name, sect in self.sections.items():; sect.report(output); ; if self.total_time is not None:; output.write(""\nSummary\n-------\n""); output.write(""{}\t solver total time\n"".format(; _format_time(self.total_time))); ; [docs] def clear(self):; """"""; Clear counts, timings and messages from all sections; """"""; for sect in self.sections.values():; sect.clear(); self.total_time = None; ; class _StatsSection(object):; """"""; Not intended to be directly instantiated; This is the type for the SolverStats.sections values;",MatchSource.WIKI,docs/4.2/modules/qutip/solver.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/solver.html
https://qutip.org/docs/4.2/modules/qutip/solver.html:20119,Integrability,message,messages,20119,"put=sys.stdout):; """"""; Report the counts, timings and messages from the sections.; Sections are reported in the order that the names were supplied; in the constructor.; The counts, timings and messages are reported in the order that they; are added to the sections; The output can be written to anything that supports a write method,; e.g. a file or the console (default); The output is intended to in markdown format; ; Parameters; ----------; output : stream; file or console stream - anything that support write - where; the output will be written; """"""; ; if not hasattr(output, 'write'):; raise TypeError(""output must have a write method""); ; if self.header:; output.write(""{}\n{}\n"".format(self.header, ; (""=""*len(self.header)))); for name, sect in self.sections.items():; sect.report(output); ; if self.total_time is not None:; output.write(""\nSummary\n-------\n""); output.write(""{}\t solver total time\n"".format(; _format_time(self.total_time))); ; [docs] def clear(self):; """"""; Clear counts, timings and messages from all sections; """"""; for sect in self.sections.values():; sect.clear(); self.total_time = None; ; class _StatsSection(object):; """"""; Not intended to be directly instantiated; This is the type for the SolverStats.sections values; ; The method parameter descriptions are the same as for those the parent ; with the same method name; ; Parameters; ----------; name : string; key for the parent sections dictionary; will also be used as the header; ; parent : `class` : SolverStats; The container for all the sections; ; Attributes; ----------; name : string; key for the parent sections dictionary; will also be used as the header; ; parent : `class` : SolverStats; The container for all the sections; ; header : string; Used as heading for section in report; ; counts : OrderedDict; The integer type statistics for the stats section; ; timings : OrderedDict; The timing type statistics for the stats section; Expected to contain float values representing values in seconds; ; mes",MatchSource.WIKI,docs/4.2/modules/qutip/solver.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/solver.html
https://qutip.org/docs/4.2/modules/qutip/solver.html:21105,Integrability,message,messages,21105," for name, sect in self.sections.items():; sect.report(output); ; if self.total_time is not None:; output.write(""\nSummary\n-------\n""); output.write(""{}\t solver total time\n"".format(; _format_time(self.total_time))); ; [docs] def clear(self):; """"""; Clear counts, timings and messages from all sections; """"""; for sect in self.sections.values():; sect.clear(); self.total_time = None; ; class _StatsSection(object):; """"""; Not intended to be directly instantiated; This is the type for the SolverStats.sections values; ; The method parameter descriptions are the same as for those the parent ; with the same method name; ; Parameters; ----------; name : string; key for the parent sections dictionary; will also be used as the header; ; parent : `class` : SolverStats; The container for all the sections; ; Attributes; ----------; name : string; key for the parent sections dictionary; will also be used as the header; ; parent : `class` : SolverStats; The container for all the sections; ; header : string; Used as heading for section in report; ; counts : OrderedDict; The integer type statistics for the stats section; ; timings : OrderedDict; The timing type statistics for the stats section; Expected to contain float values representing values in seconds; ; messages : OrderedDict; Text type output to be reported; ; total_time : float; Total time for processing in the section; Can be None, meaning that section timing percentages will be reported; """"""; def __init__(self, name, parent):; self.parent = parent; self.header = str(name); self.name = name; self.counts = OrderedDict(); self.timings = OrderedDict(); self.messages = OrderedDict(); self.total_time = None. def add_count(self, key, value):; """"""; Add value to count. If key does not already exist in section then; it is created with this value.; If key already exists it is increased by the given value; value is expected to be an integer; """"""; if not isinstance(value, int):; try:; value = int(value); except:; raise TypeError(""value ",MatchSource.WIKI,docs/4.2/modules/qutip/solver.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/solver.html
https://qutip.org/docs/4.2/modules/qutip/solver.html:21466,Integrability,message,messages,21466,"-----; name : string; key for the parent sections dictionary; will also be used as the header; ; parent : `class` : SolverStats; The container for all the sections; ; Attributes; ----------; name : string; key for the parent sections dictionary; will also be used as the header; ; parent : `class` : SolverStats; The container for all the sections; ; header : string; Used as heading for section in report; ; counts : OrderedDict; The integer type statistics for the stats section; ; timings : OrderedDict; The timing type statistics for the stats section; Expected to contain float values representing values in seconds; ; messages : OrderedDict; Text type output to be reported; ; total_time : float; Total time for processing in the section; Can be None, meaning that section timing percentages will be reported; """"""; def __init__(self, name, parent):; self.parent = parent; self.header = str(name); self.name = name; self.counts = OrderedDict(); self.timings = OrderedDict(); self.messages = OrderedDict(); self.total_time = None. def add_count(self, key, value):; """"""; Add value to count. If key does not already exist in section then; it is created with this value.; If key already exists it is increased by the given value; value is expected to be an integer; """"""; if not isinstance(value, int):; try:; value = int(value); except:; raise TypeError(""value is expected to be an integer""); ; if key in self.counts:; self.counts[key] += value; else:; self.counts[key] = value; ; def add_timing(self, key, value):; """"""; Add value to timing. If key does not already exist in section then; it is created with this value.; If key already exists it is increased by the give value; value is expected to be a float, and given in seconds.; """"""; if not isinstance(value, float):; try:; value = float(value); except:; raise TypeError(""value is expected to be a float""); ; if key in self.timings:; self.timings[key] += value; else:; self.timings[key] = value; ; def add_message(self, key, value, sep="";""):; """"",MatchSource.WIKI,docs/4.2/modules/qutip/solver.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/solver.html
https://qutip.org/docs/4.2/modules/qutip/solver.html:22498,Integrability,message,message,22498,"); self.messages = OrderedDict(); self.total_time = None. def add_count(self, key, value):; """"""; Add value to count. If key does not already exist in section then; it is created with this value.; If key already exists it is increased by the given value; value is expected to be an integer; """"""; if not isinstance(value, int):; try:; value = int(value); except:; raise TypeError(""value is expected to be an integer""); ; if key in self.counts:; self.counts[key] += value; else:; self.counts[key] = value; ; def add_timing(self, key, value):; """"""; Add value to timing. If key does not already exist in section then; it is created with this value.; If key already exists it is increased by the give value; value is expected to be a float, and given in seconds.; """"""; if not isinstance(value, float):; try:; value = float(value); except:; raise TypeError(""value is expected to be a float""); ; if key in self.timings:; self.timings[key] += value; else:; self.timings[key] = value; ; def add_message(self, key, value, sep="";""):; """"""; Add value to message. If key does not already exist in section then; it is created with this value.; If key already exists the value is added to the message; The value will be converted to a string; """"""; value = str(value). if key in self.messages:; if sep is not None:; try:; value = sep + value; except:; TypeError(""It is not possible to concatenate the value with ""; ""the given seperator""); self.messages[key] += value; else:; self.messages[key] = value; ; def report(self, output=sys.stdout):; """"""; Report the counts, timings and messages for this section.; Note the percentage of the section and solver total times will be; given if the parent and or section total_time is set; """"""; if self.header:; output.write(""\n{}\n{}\n"".format(self.header, ; (""-""*len(self.header)))); ; # TODO: Make the timings and counts ouput in a table format; # Generally make more pretty; ; # Report timings; try:; ttt = self.parent.total_time; except:; ttt = None; ; tt = self.total_time; ;",MatchSource.WIKI,docs/4.2/modules/qutip/solver.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/solver.html
https://qutip.org/docs/4.2/modules/qutip/solver.html:22634,Integrability,message,message,22634,"value.; If key already exists it is increased by the given value; value is expected to be an integer; """"""; if not isinstance(value, int):; try:; value = int(value); except:; raise TypeError(""value is expected to be an integer""); ; if key in self.counts:; self.counts[key] += value; else:; self.counts[key] = value; ; def add_timing(self, key, value):; """"""; Add value to timing. If key does not already exist in section then; it is created with this value.; If key already exists it is increased by the give value; value is expected to be a float, and given in seconds.; """"""; if not isinstance(value, float):; try:; value = float(value); except:; raise TypeError(""value is expected to be a float""); ; if key in self.timings:; self.timings[key] += value; else:; self.timings[key] = value; ; def add_message(self, key, value, sep="";""):; """"""; Add value to message. If key does not already exist in section then; it is created with this value.; If key already exists the value is added to the message; The value will be converted to a string; """"""; value = str(value). if key in self.messages:; if sep is not None:; try:; value = sep + value; except:; TypeError(""It is not possible to concatenate the value with ""; ""the given seperator""); self.messages[key] += value; else:; self.messages[key] = value; ; def report(self, output=sys.stdout):; """"""; Report the counts, timings and messages for this section.; Note the percentage of the section and solver total times will be; given if the parent and or section total_time is set; """"""; if self.header:; output.write(""\n{}\n{}\n"".format(self.header, ; (""-""*len(self.header)))); ; # TODO: Make the timings and counts ouput in a table format; # Generally make more pretty; ; # Report timings; try:; ttt = self.parent.total_time; except:; ttt = None; ; tt = self.total_time; ; output.write(""### Timings:\n""); for key, value in self.timings.items():; l = "" - {}\t{}\n"".format(_format_time(value, tt, ttt), key); output.write(l); if tt is not None:; output.write("" ",MatchSource.WIKI,docs/4.2/modules/qutip/solver.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/solver.html
https://qutip.org/docs/4.2/modules/qutip/solver.html:22724,Integrability,message,messages,22724,"alue); except:; raise TypeError(""value is expected to be an integer""); ; if key in self.counts:; self.counts[key] += value; else:; self.counts[key] = value; ; def add_timing(self, key, value):; """"""; Add value to timing. If key does not already exist in section then; it is created with this value.; If key already exists it is increased by the give value; value is expected to be a float, and given in seconds.; """"""; if not isinstance(value, float):; try:; value = float(value); except:; raise TypeError(""value is expected to be a float""); ; if key in self.timings:; self.timings[key] += value; else:; self.timings[key] = value; ; def add_message(self, key, value, sep="";""):; """"""; Add value to message. If key does not already exist in section then; it is created with this value.; If key already exists the value is added to the message; The value will be converted to a string; """"""; value = str(value). if key in self.messages:; if sep is not None:; try:; value = sep + value; except:; TypeError(""It is not possible to concatenate the value with ""; ""the given seperator""); self.messages[key] += value; else:; self.messages[key] = value; ; def report(self, output=sys.stdout):; """"""; Report the counts, timings and messages for this section.; Note the percentage of the section and solver total times will be; given if the parent and or section total_time is set; """"""; if self.header:; output.write(""\n{}\n{}\n"".format(self.header, ; (""-""*len(self.header)))); ; # TODO: Make the timings and counts ouput in a table format; # Generally make more pretty; ; # Report timings; try:; ttt = self.parent.total_time; except:; ttt = None; ; tt = self.total_time; ; output.write(""### Timings:\n""); for key, value in self.timings.items():; l = "" - {}\t{}\n"".format(_format_time(value, tt, ttt), key); output.write(l); if tt is not None:; output.write("" - {}\t{} total time\n"".format(_format_time(tt), ; self.name)); ; # Report counts; output.write(""### Counts:\n""); for key, value in self.counts.items():; l = """,MatchSource.WIKI,docs/4.2/modules/qutip/solver.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/solver.html
https://qutip.org/docs/4.2/modules/qutip/solver.html:22884,Integrability,message,messages,22884,"elf.counts[key] += value; else:; self.counts[key] = value; ; def add_timing(self, key, value):; """"""; Add value to timing. If key does not already exist in section then; it is created with this value.; If key already exists it is increased by the give value; value is expected to be a float, and given in seconds.; """"""; if not isinstance(value, float):; try:; value = float(value); except:; raise TypeError(""value is expected to be a float""); ; if key in self.timings:; self.timings[key] += value; else:; self.timings[key] = value; ; def add_message(self, key, value, sep="";""):; """"""; Add value to message. If key does not already exist in section then; it is created with this value.; If key already exists the value is added to the message; The value will be converted to a string; """"""; value = str(value). if key in self.messages:; if sep is not None:; try:; value = sep + value; except:; TypeError(""It is not possible to concatenate the value with ""; ""the given seperator""); self.messages[key] += value; else:; self.messages[key] = value; ; def report(self, output=sys.stdout):; """"""; Report the counts, timings and messages for this section.; Note the percentage of the section and solver total times will be; given if the parent and or section total_time is set; """"""; if self.header:; output.write(""\n{}\n{}\n"".format(self.header, ; (""-""*len(self.header)))); ; # TODO: Make the timings and counts ouput in a table format; # Generally make more pretty; ; # Report timings; try:; ttt = self.parent.total_time; except:; ttt = None; ; tt = self.total_time; ; output.write(""### Timings:\n""); for key, value in self.timings.items():; l = "" - {}\t{}\n"".format(_format_time(value, tt, ttt), key); output.write(l); if tt is not None:; output.write("" - {}\t{} total time\n"".format(_format_time(tt), ; self.name)); ; # Report counts; output.write(""### Counts:\n""); for key, value in self.counts.items():; l = "" - {}\t{}\n"".format(value, key); output.write(l); ; # Report messages; output.write(""### Messages:",MatchSource.WIKI,docs/4.2/modules/qutip/solver.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/solver.html
https://qutip.org/docs/4.2/modules/qutip/solver.html:22920,Integrability,message,messages,22920,"[key] = value; ; def add_timing(self, key, value):; """"""; Add value to timing. If key does not already exist in section then; it is created with this value.; If key already exists it is increased by the give value; value is expected to be a float, and given in seconds.; """"""; if not isinstance(value, float):; try:; value = float(value); except:; raise TypeError(""value is expected to be a float""); ; if key in self.timings:; self.timings[key] += value; else:; self.timings[key] = value; ; def add_message(self, key, value, sep="";""):; """"""; Add value to message. If key does not already exist in section then; it is created with this value.; If key already exists the value is added to the message; The value will be converted to a string; """"""; value = str(value). if key in self.messages:; if sep is not None:; try:; value = sep + value; except:; TypeError(""It is not possible to concatenate the value with ""; ""the given seperator""); self.messages[key] += value; else:; self.messages[key] = value; ; def report(self, output=sys.stdout):; """"""; Report the counts, timings and messages for this section.; Note the percentage of the section and solver total times will be; given if the parent and or section total_time is set; """"""; if self.header:; output.write(""\n{}\n{}\n"".format(self.header, ; (""-""*len(self.header)))); ; # TODO: Make the timings and counts ouput in a table format; # Generally make more pretty; ; # Report timings; try:; ttt = self.parent.total_time; except:; ttt = None; ; tt = self.total_time; ; output.write(""### Timings:\n""); for key, value in self.timings.items():; l = "" - {}\t{}\n"".format(_format_time(value, tt, ttt), key); output.write(l); if tt is not None:; output.write("" - {}\t{} total time\n"".format(_format_time(tt), ; self.name)); ; # Report counts; output.write(""### Counts:\n""); for key, value in self.counts.items():; l = "" - {}\t{}\n"".format(value, key); output.write(l); ; # Report messages; output.write(""### Messages:\n""); for key, value in self.messages.items()",MatchSource.WIKI,docs/4.2/modules/qutip/solver.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/solver.html
https://qutip.org/docs/4.2/modules/qutip/solver.html:23019,Integrability,message,messages,23019,"lue to timing. If key does not already exist in section then; it is created with this value.; If key already exists it is increased by the give value; value is expected to be a float, and given in seconds.; """"""; if not isinstance(value, float):; try:; value = float(value); except:; raise TypeError(""value is expected to be a float""); ; if key in self.timings:; self.timings[key] += value; else:; self.timings[key] = value; ; def add_message(self, key, value, sep="";""):; """"""; Add value to message. If key does not already exist in section then; it is created with this value.; If key already exists the value is added to the message; The value will be converted to a string; """"""; value = str(value). if key in self.messages:; if sep is not None:; try:; value = sep + value; except:; TypeError(""It is not possible to concatenate the value with ""; ""the given seperator""); self.messages[key] += value; else:; self.messages[key] = value; ; def report(self, output=sys.stdout):; """"""; Report the counts, timings and messages for this section.; Note the percentage of the section and solver total times will be; given if the parent and or section total_time is set; """"""; if self.header:; output.write(""\n{}\n{}\n"".format(self.header, ; (""-""*len(self.header)))); ; # TODO: Make the timings and counts ouput in a table format; # Generally make more pretty; ; # Report timings; try:; ttt = self.parent.total_time; except:; ttt = None; ; tt = self.total_time; ; output.write(""### Timings:\n""); for key, value in self.timings.items():; l = "" - {}\t{}\n"".format(_format_time(value, tt, ttt), key); output.write(l); if tt is not None:; output.write("" - {}\t{} total time\n"".format(_format_time(tt), ; self.name)); ; # Report counts; output.write(""### Counts:\n""); for key, value in self.counts.items():; l = "" - {}\t{}\n"".format(value, key); output.write(l); ; # Report messages; output.write(""### Messages:\n""); for key, value in self.messages.items():; l = "" - {}:\t{}\n"".format(key, value); output.write(l); . d",MatchSource.WIKI,docs/4.2/modules/qutip/solver.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/solver.html
https://qutip.org/docs/4.2/modules/qutip/solver.html:23865,Integrability,message,messages,23865,"en seperator""); self.messages[key] += value; else:; self.messages[key] = value; ; def report(self, output=sys.stdout):; """"""; Report the counts, timings and messages for this section.; Note the percentage of the section and solver total times will be; given if the parent and or section total_time is set; """"""; if self.header:; output.write(""\n{}\n{}\n"".format(self.header, ; (""-""*len(self.header)))); ; # TODO: Make the timings and counts ouput in a table format; # Generally make more pretty; ; # Report timings; try:; ttt = self.parent.total_time; except:; ttt = None; ; tt = self.total_time; ; output.write(""### Timings:\n""); for key, value in self.timings.items():; l = "" - {}\t{}\n"".format(_format_time(value, tt, ttt), key); output.write(l); if tt is not None:; output.write("" - {}\t{} total time\n"".format(_format_time(tt), ; self.name)); ; # Report counts; output.write(""### Counts:\n""); for key, value in self.counts.items():; l = "" - {}\t{}\n"".format(value, key); output.write(l); ; # Report messages; output.write(""### Messages:\n""); for key, value in self.messages.items():; l = "" - {}:\t{}\n"".format(key, value); output.write(l); . def clear(self):; """"""; Clear counts, timings and messages from this section; """"""; self.counts.clear(); self.timings.clear(); self.messages.clear(); self.total_time = None; . def _solver_safety_check(H, state, c_ops=[], e_ops=[], args={}):; # Input is std Qobj (Hamiltonian or Liouvillian); if isinstance(H, Qobj):; Hdims = H.dims; Htype = H.type; _structure_check(Hdims, Htype, state); # Input H is function; elif isinstance(H, (FunctionType, BuiltinFunctionType)):; Hdims = H(0,args).dims; Htype = H(0,args).type; _structure_check(Hdims, Htype, state); # Input is td-list; elif isinstance(H, list):; if isinstance(H[0], Qobj):; Hdims = H[0].dims; Htype = H[0].type; elif isinstance(H[0], list):; Hdims = H[0][0].dims; Htype = H[0][0].type; elif isinstance(H[0], (FunctionType, BuiltinFunctionType)):; Hdims = H[0](0,args).dims; Htype = H[0](0,args).type ",MatchSource.WIKI,docs/4.2/modules/qutip/solver.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/solver.html
https://qutip.org/docs/4.2/modules/qutip/solver.html:23931,Integrability,message,messages,23931," value; ; def report(self, output=sys.stdout):; """"""; Report the counts, timings and messages for this section.; Note the percentage of the section and solver total times will be; given if the parent and or section total_time is set; """"""; if self.header:; output.write(""\n{}\n{}\n"".format(self.header, ; (""-""*len(self.header)))); ; # TODO: Make the timings and counts ouput in a table format; # Generally make more pretty; ; # Report timings; try:; ttt = self.parent.total_time; except:; ttt = None; ; tt = self.total_time; ; output.write(""### Timings:\n""); for key, value in self.timings.items():; l = "" - {}\t{}\n"".format(_format_time(value, tt, ttt), key); output.write(l); if tt is not None:; output.write("" - {}\t{} total time\n"".format(_format_time(tt), ; self.name)); ; # Report counts; output.write(""### Counts:\n""); for key, value in self.counts.items():; l = "" - {}\t{}\n"".format(value, key); output.write(l); ; # Report messages; output.write(""### Messages:\n""); for key, value in self.messages.items():; l = "" - {}:\t{}\n"".format(key, value); output.write(l); . def clear(self):; """"""; Clear counts, timings and messages from this section; """"""; self.counts.clear(); self.timings.clear(); self.messages.clear(); self.total_time = None; . def _solver_safety_check(H, state, c_ops=[], e_ops=[], args={}):; # Input is std Qobj (Hamiltonian or Liouvillian); if isinstance(H, Qobj):; Hdims = H.dims; Htype = H.type; _structure_check(Hdims, Htype, state); # Input H is function; elif isinstance(H, (FunctionType, BuiltinFunctionType)):; Hdims = H(0,args).dims; Htype = H(0,args).type; _structure_check(Hdims, Htype, state); # Input is td-list; elif isinstance(H, list):; if isinstance(H[0], Qobj):; Hdims = H[0].dims; Htype = H[0].type; elif isinstance(H[0], list):; Hdims = H[0][0].dims; Htype = H[0][0].type; elif isinstance(H[0], (FunctionType, BuiltinFunctionType)):; Hdims = H[0](0,args).dims; Htype = H[0](0,args).type ; else:; raise Exception('Invalid td-list element.'); # Check all operato",MatchSource.WIKI,docs/4.2/modules/qutip/solver.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/solver.html
https://qutip.org/docs/4.2/modules/qutip/solver.html:24057,Integrability,message,messages,24057," the percentage of the section and solver total times will be; given if the parent and or section total_time is set; """"""; if self.header:; output.write(""\n{}\n{}\n"".format(self.header, ; (""-""*len(self.header)))); ; # TODO: Make the timings and counts ouput in a table format; # Generally make more pretty; ; # Report timings; try:; ttt = self.parent.total_time; except:; ttt = None; ; tt = self.total_time; ; output.write(""### Timings:\n""); for key, value in self.timings.items():; l = "" - {}\t{}\n"".format(_format_time(value, tt, ttt), key); output.write(l); if tt is not None:; output.write("" - {}\t{} total time\n"".format(_format_time(tt), ; self.name)); ; # Report counts; output.write(""### Counts:\n""); for key, value in self.counts.items():; l = "" - {}\t{}\n"".format(value, key); output.write(l); ; # Report messages; output.write(""### Messages:\n""); for key, value in self.messages.items():; l = "" - {}:\t{}\n"".format(key, value); output.write(l); . def clear(self):; """"""; Clear counts, timings and messages from this section; """"""; self.counts.clear(); self.timings.clear(); self.messages.clear(); self.total_time = None; . def _solver_safety_check(H, state, c_ops=[], e_ops=[], args={}):; # Input is std Qobj (Hamiltonian or Liouvillian); if isinstance(H, Qobj):; Hdims = H.dims; Htype = H.type; _structure_check(Hdims, Htype, state); # Input H is function; elif isinstance(H, (FunctionType, BuiltinFunctionType)):; Hdims = H(0,args).dims; Htype = H(0,args).type; _structure_check(Hdims, Htype, state); # Input is td-list; elif isinstance(H, list):; if isinstance(H[0], Qobj):; Hdims = H[0].dims; Htype = H[0].type; elif isinstance(H[0], list):; Hdims = H[0][0].dims; Htype = H[0][0].type; elif isinstance(H[0], (FunctionType, BuiltinFunctionType)):; Hdims = H[0](0,args).dims; Htype = H[0](0,args).type ; else:; raise Exception('Invalid td-list element.'); # Check all operators in list; for ii in range(len(H)):; if isinstance(H[ii], Qobj):; _temp_dims = H[ii].dims; _temp_type = H[ii].type",MatchSource.WIKI,docs/4.2/modules/qutip/solver.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/solver.html
https://qutip.org/docs/4.2/modules/qutip/solver.html:24138,Integrability,message,messages,24138,"ection total_time is set; """"""; if self.header:; output.write(""\n{}\n{}\n"".format(self.header, ; (""-""*len(self.header)))); ; # TODO: Make the timings and counts ouput in a table format; # Generally make more pretty; ; # Report timings; try:; ttt = self.parent.total_time; except:; ttt = None; ; tt = self.total_time; ; output.write(""### Timings:\n""); for key, value in self.timings.items():; l = "" - {}\t{}\n"".format(_format_time(value, tt, ttt), key); output.write(l); if tt is not None:; output.write("" - {}\t{} total time\n"".format(_format_time(tt), ; self.name)); ; # Report counts; output.write(""### Counts:\n""); for key, value in self.counts.items():; l = "" - {}\t{}\n"".format(value, key); output.write(l); ; # Report messages; output.write(""### Messages:\n""); for key, value in self.messages.items():; l = "" - {}:\t{}\n"".format(key, value); output.write(l); . def clear(self):; """"""; Clear counts, timings and messages from this section; """"""; self.counts.clear(); self.timings.clear(); self.messages.clear(); self.total_time = None; . def _solver_safety_check(H, state, c_ops=[], e_ops=[], args={}):; # Input is std Qobj (Hamiltonian or Liouvillian); if isinstance(H, Qobj):; Hdims = H.dims; Htype = H.type; _structure_check(Hdims, Htype, state); # Input H is function; elif isinstance(H, (FunctionType, BuiltinFunctionType)):; Hdims = H(0,args).dims; Htype = H(0,args).type; _structure_check(Hdims, Htype, state); # Input is td-list; elif isinstance(H, list):; if isinstance(H[0], Qobj):; Hdims = H[0].dims; Htype = H[0].type; elif isinstance(H[0], list):; Hdims = H[0][0].dims; Htype = H[0][0].type; elif isinstance(H[0], (FunctionType, BuiltinFunctionType)):; Hdims = H[0](0,args).dims; Htype = H[0](0,args).type ; else:; raise Exception('Invalid td-list element.'); # Check all operators in list; for ii in range(len(H)):; if isinstance(H[ii], Qobj):; _temp_dims = H[ii].dims; _temp_type = H[ii].type; elif isinstance(H[ii], list):; _temp_dims = H[ii][0].dims; _temp_type = H[ii][0].type; eli",MatchSource.WIKI,docs/4.2/modules/qutip/solver.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/solver.html
https://qutip.org/docs/4.2/modules/qutip/solver.html:25407,Integrability,depend,dependent,25407,"k(Hdims, Htype, state); # Input H is function; elif isinstance(H, (FunctionType, BuiltinFunctionType)):; Hdims = H(0,args).dims; Htype = H(0,args).type; _structure_check(Hdims, Htype, state); # Input is td-list; elif isinstance(H, list):; if isinstance(H[0], Qobj):; Hdims = H[0].dims; Htype = H[0].type; elif isinstance(H[0], list):; Hdims = H[0][0].dims; Htype = H[0][0].type; elif isinstance(H[0], (FunctionType, BuiltinFunctionType)):; Hdims = H[0](0,args).dims; Htype = H[0](0,args).type ; else:; raise Exception('Invalid td-list element.'); # Check all operators in list; for ii in range(len(H)):; if isinstance(H[ii], Qobj):; _temp_dims = H[ii].dims; _temp_type = H[ii].type; elif isinstance(H[ii], list):; _temp_dims = H[ii][0].dims; _temp_type = H[ii][0].type; elif isinstance(H[ii], (FunctionType, BuiltinFunctionType)):; _temp_dims = H[ii](0,args).dims; _temp_type = H[ii](0,args).type; else: ; raise Exception('Invalid td-list element.'); _structure_check(_temp_dims,_temp_type,state); ; else:; raise Exception('Invalid time-dependent format.'); ; ; for ii in range(len(c_ops)):; do_tests = True; if isinstance(c_ops[ii], Qobj):; _temp_state = c_ops[ii]; elif isinstance(c_ops[ii], list):; if isinstance(c_ops[ii][0], Qobj):; _temp_state = c_ops[ii][0]; elif isinstance(c_ops[ii][0], tuple):; do_tests = False; for kk in range(len(c_ops[ii][0])):; _temp_state = c_ops[ii][0][kk]; _structure_check(Hdims, Htype, _temp_state); else:; raise Exception('Invalid td-list element.'); if do_tests:; _structure_check(Hdims, Htype, _temp_state); ; if isinstance(e_ops, list): ; for ii in range(len(e_ops)):; if isinstance(e_ops[ii], Qobj):; _temp_state = e_ops[ii]; elif isinstance(e_ops[ii], list):; _temp_state = e_ops[ii][0]; else:; raise Exception('Invalid td-list element.'); _structure_check(Hdims,Htype,_temp_state); elif isinstance(e_ops, FunctionType):; pass; else:; raise Exception('Invalid e_ops specification.'). def _structure_check(Hdims, Htype, state):; # Input state is a ket vector;",MatchSource.WIKI,docs/4.2/modules/qutip/solver.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/solver.html
https://qutip.org/docs/4.2/modules/qutip/solver.html:13446,Modifiability,variab,variables,13446," [] # collapse op data; self.c_ops_ind = [] # collapse op indices; self.c_ops_ptr = [] # collapse op indptrs; self.c_args = [] # store args for time-dependent collapse func. # Norm collapse operator stuff; self.n_ops_data = [] # norm collapse op data; self.n_ops_ind = [] # norm collapse op indices; self.n_ops_ptr = [] # norm collapse op indptrs. # holds executable strings for time-dependent collapse evaluation; self.col_expect_code = None; self.col_spmv_code = None. # hold stuff for function list based time dependence; self.h_td_inds = []; self.h_td_data = []; self.h_td_ind = []; self.h_td_ptr = []; self.h_funcs = None; self.h_func_args = None; self.c_funcs = None; self.c_func_args = None; ; # time-dependent (TD) function stuff; self.tdfunc = None # Placeholder for TD RHS function.; self.tdname = None # Name of td .pyx file; self.colspmv = None # Placeholder for TD col-spmv function.; self.colexpect = None # Placeholder for TD col_expect function.; self.string = None # Holds string of variables passed to td solver; . def _format_time(t, tt=None, ttt=None):; time_str = str(datetime.timedelta(seconds=t)); if tt is not None and ttt is not None:; sect_percent = 100*t/tt; solve_percent = 100*t/ttt; time_str += "" ({:03.2f}% section, {:03.2f}% total)"".format(; sect_percent, solve_percent); elif tt is not None:; sect_percent = 100*t/tt; time_str += "" ({:03.2f}% section)"".format(sect_percent); ; elif ttt is not None:; solve_percent = 100*t/ttt; time_str += "" ({:03.2f}% total)"".format(solve_percent); ; return time_str. [docs]class Stats(object):; """"""; Statistical information on the solver performance; Statistics can be grouped into sections.; If no section names are given in the the contructor, then all statistics; will be added to one section 'main'; ; Parameters; ----------; section_names : list; list of keys that will be used as keys for the sections; These keys will also be used as names for the sections; The text in the output can be overidden by setting the header prope",MatchSource.WIKI,docs/4.2/modules/qutip/solver.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/solver.html
https://qutip.org/docs/4.2/modules/qutip/solver.html:27229,Modifiability,config,config,27229,"[ii]; elif isinstance(c_ops[ii], list):; if isinstance(c_ops[ii][0], Qobj):; _temp_state = c_ops[ii][0]; elif isinstance(c_ops[ii][0], tuple):; do_tests = False; for kk in range(len(c_ops[ii][0])):; _temp_state = c_ops[ii][0][kk]; _structure_check(Hdims, Htype, _temp_state); else:; raise Exception('Invalid td-list element.'); if do_tests:; _structure_check(Hdims, Htype, _temp_state); ; if isinstance(e_ops, list): ; for ii in range(len(e_ops)):; if isinstance(e_ops[ii], Qobj):; _temp_state = e_ops[ii]; elif isinstance(e_ops[ii], list):; _temp_state = e_ops[ii][0]; else:; raise Exception('Invalid td-list element.'); _structure_check(Hdims,Htype,_temp_state); elif isinstance(e_ops, FunctionType):; pass; else:; raise Exception('Invalid e_ops specification.'). def _structure_check(Hdims, Htype, state):; # Input state is a ket vector; if state.type == 'ket':; # Input is Hamiltonian; if Htype == 'oper':; if Hdims[1] != state.dims[0]:; raise Exception('Input operator and ket do not share same structure.'); # Input is super and state is ket; elif Htype == 'super':; if Hdims[1][1] != state.dims[0]:; raise Exception('Input operator and ket do not share same structure.'); else:; raise Exception('Invalid input operator.'); # Input state is a density matrix; elif state.type == 'oper':; # Input is Hamiltonian and state is density matrix; if Htype == 'oper':; if Hdims[1] != state.dims[0]:; raise Exception('Input operators do not share same structure.'); # Input is super op. and state is density matrix; elif Htype == 'super':; if Hdims[1] != state.dims:; raise Exception('Input operators do not share same structure.'). ; #; # create a global instance of the SolverConfiguration class; #; config = SolverConfiguration(). # for backwards compatibility; Odeoptions = Options; Odedata = Result.  Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, and A.L. Grimsmo.; Last updated on Jan 17, 2018. . Built with Sphinx using a theme provided by Read the Docs. . ",MatchSource.WIKI,docs/4.2/modules/qutip/solver.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/solver.html
https://qutip.org/docs/4.2/modules/qutip/solver.html:10813,Performance,load,loading,10813,"expect = []; self.num_expect = 0; self.num_collapse = 0; self.ntraj = None; self.seeds = None; self.col_times = None; self.col_which = None. def __str__(self):; s = ""Result object ""; if self.solver:; s += ""with "" + self.solver + "" data.\n""; else:; s += ""missing solver information.\n""; s += ""-"" * (len(s) - 1) + ""\n""; if self.states is not None and len(self.states) > 0:; s += ""states = True\n""; elif self.expect is not None and len(self.expect) > 0:; s += ""expect = True\nnum_expect = "" + str(self.num_expect) + "", ""; else:; s += ""states = True, expect = True\n"" + \; ""num_expect = "" + str(self.num_expect) + "", ""; s += ""num_collapse = "" + str(self.num_collapse); if self.solver == 'mcsolve':; s += "", ntraj = "" + str(self.ntraj); return s. def __repr__(self):; return self.__str__(). def __getstate__(self):; # defines what happens when Qobj object gets pickled; self.__dict__.update({'qutip_version': __version__[:5]}); return self.__dict__. def __setstate__(self, state):; # defines what happens when loading a pickled Qobj; if 'qutip_version' in state.keys():; del state['qutip_version']; (self.__dict__).update(state). class SolverConfiguration():. def __init__(self):. self.cgen_num = 0. self.reset(). def reset(self):. # General stuff; self.tlist = None # evaluations times; self.ntraj = None # number / list of trajectories; self.options = None # options for solvers; self.norm_tol = None # tolerance for wavefunction norm; self.norm_steps = None # max. number of steps to take in finding; # Initial state stuff; self.psi0 = None # initial state; self.psi0_dims = None # initial state dims; self.psi0_shape = None # initial state shape. # flags for setting time-dependence, collapse ops, and number of times; # codegen has been run; self.cflag = 0 # Flag signaling collapse operators; self.tflag = 0 # Flag signaling time-dependent problem; ; self.soft_reset(). def soft_reset(self):. # Hamiltonian stuff; self.h_td_inds = [] # indicies of time-dependent Hamiltonian operators; self.h_tdterms",MatchSource.WIKI,docs/4.2/modules/qutip/solver.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/solver.html
https://qutip.org/docs/4.2/modules/qutip/solver.html:14052,Performance,perform,performance,14052,"_ptr = []; self.h_funcs = None; self.h_func_args = None; self.c_funcs = None; self.c_func_args = None; ; # time-dependent (TD) function stuff; self.tdfunc = None # Placeholder for TD RHS function.; self.tdname = None # Name of td .pyx file; self.colspmv = None # Placeholder for TD col-spmv function.; self.colexpect = None # Placeholder for TD col_expect function.; self.string = None # Holds string of variables passed to td solver; . def _format_time(t, tt=None, ttt=None):; time_str = str(datetime.timedelta(seconds=t)); if tt is not None and ttt is not None:; sect_percent = 100*t/tt; solve_percent = 100*t/ttt; time_str += "" ({:03.2f}% section, {:03.2f}% total)"".format(; sect_percent, solve_percent); elif tt is not None:; sect_percent = 100*t/tt; time_str += "" ({:03.2f}% section)"".format(sect_percent); ; elif ttt is not None:; solve_percent = 100*t/ttt; time_str += "" ({:03.2f}% total)"".format(solve_percent); ; return time_str. [docs]class Stats(object):; """"""; Statistical information on the solver performance; Statistics can be grouped into sections.; If no section names are given in the the contructor, then all statistics; will be added to one section 'main'; ; Parameters; ----------; section_names : list; list of keys that will be used as keys for the sections; These keys will also be used as names for the sections; The text in the output can be overidden by setting the header property; of the section; If no names are given then one section called 'main' is created; ; Attributes; ----------; sections : OrderedDict of _StatsSection; These are the sections that are created automatically on instantiation; or added using add_section; ; header : string; Some text that will be used as the heading in the report; By default there is None; ; total_time : float; Time in seconds for the solver to complete processing; Can be None, meaning that total timing percentages will be reported; ; Methods; -------; add_section; Add another section; ; add_count; Add some stat that is an int",MatchSource.WIKI,docs/4.2/modules/qutip/solver.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/solver.html
https://qutip.org/docs/4.2/modules/qutip/solver.html:20074,Usability,clear,clear,20074,"put=sys.stdout):; """"""; Report the counts, timings and messages from the sections.; Sections are reported in the order that the names were supplied; in the constructor.; The counts, timings and messages are reported in the order that they; are added to the sections; The output can be written to anything that supports a write method,; e.g. a file or the console (default); The output is intended to in markdown format; ; Parameters; ----------; output : stream; file or console stream - anything that support write - where; the output will be written; """"""; ; if not hasattr(output, 'write'):; raise TypeError(""output must have a write method""); ; if self.header:; output.write(""{}\n{}\n"".format(self.header, ; (""=""*len(self.header)))); for name, sect in self.sections.items():; sect.report(output); ; if self.total_time is not None:; output.write(""\nSummary\n-------\n""); output.write(""{}\t solver total time\n"".format(; _format_time(self.total_time))); ; [docs] def clear(self):; """"""; Clear counts, timings and messages from all sections; """"""; for sect in self.sections.values():; sect.clear(); self.total_time = None; ; class _StatsSection(object):; """"""; Not intended to be directly instantiated; This is the type for the SolverStats.sections values; ; The method parameter descriptions are the same as for those the parent ; with the same method name; ; Parameters; ----------; name : string; key for the parent sections dictionary; will also be used as the header; ; parent : `class` : SolverStats; The container for all the sections; ; Attributes; ----------; name : string; key for the parent sections dictionary; will also be used as the header; ; parent : `class` : SolverStats; The container for all the sections; ; header : string; Used as heading for section in report; ; counts : OrderedDict; The integer type statistics for the stats section; ; timings : OrderedDict; The timing type statistics for the stats section; Expected to contain float values representing values in seconds; ; mes",MatchSource.WIKI,docs/4.2/modules/qutip/solver.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/solver.html
https://qutip.org/docs/4.2/modules/qutip/solver.html:20194,Usability,clear,clear,20194,"e reported in the order that the names were supplied; in the constructor.; The counts, timings and messages are reported in the order that they; are added to the sections; The output can be written to anything that supports a write method,; e.g. a file or the console (default); The output is intended to in markdown format; ; Parameters; ----------; output : stream; file or console stream - anything that support write - where; the output will be written; """"""; ; if not hasattr(output, 'write'):; raise TypeError(""output must have a write method""); ; if self.header:; output.write(""{}\n{}\n"".format(self.header, ; (""=""*len(self.header)))); for name, sect in self.sections.items():; sect.report(output); ; if self.total_time is not None:; output.write(""\nSummary\n-------\n""); output.write(""{}\t solver total time\n"".format(; _format_time(self.total_time))); ; [docs] def clear(self):; """"""; Clear counts, timings and messages from all sections; """"""; for sect in self.sections.values():; sect.clear(); self.total_time = None; ; class _StatsSection(object):; """"""; Not intended to be directly instantiated; This is the type for the SolverStats.sections values; ; The method parameter descriptions are the same as for those the parent ; with the same method name; ; Parameters; ----------; name : string; key for the parent sections dictionary; will also be used as the header; ; parent : `class` : SolverStats; The container for all the sections; ; Attributes; ----------; name : string; key for the parent sections dictionary; will also be used as the header; ; parent : `class` : SolverStats; The container for all the sections; ; header : string; Used as heading for section in report; ; counts : OrderedDict; The integer type statistics for the stats section; ; timings : OrderedDict; The timing type statistics for the stats section; Expected to contain float values representing values in seconds; ; messages : OrderedDict; Text type output to be reported; ; total_time : float; Total time for pr",MatchSource.WIKI,docs/4.2/modules/qutip/solver.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/solver.html
https://qutip.org/docs/4.2/modules/qutip/solver.html:24012,Usability,clear,clear,24012," the percentage of the section and solver total times will be; given if the parent and or section total_time is set; """"""; if self.header:; output.write(""\n{}\n{}\n"".format(self.header, ; (""-""*len(self.header)))); ; # TODO: Make the timings and counts ouput in a table format; # Generally make more pretty; ; # Report timings; try:; ttt = self.parent.total_time; except:; ttt = None; ; tt = self.total_time; ; output.write(""### Timings:\n""); for key, value in self.timings.items():; l = "" - {}\t{}\n"".format(_format_time(value, tt, ttt), key); output.write(l); if tt is not None:; output.write("" - {}\t{} total time\n"".format(_format_time(tt), ; self.name)); ; # Report counts; output.write(""### Counts:\n""); for key, value in self.counts.items():; l = "" - {}\t{}\n"".format(value, key); output.write(l); ; # Report messages; output.write(""### Messages:\n""); for key, value in self.messages.items():; l = "" - {}:\t{}\n"".format(key, value); output.write(l); . def clear(self):; """"""; Clear counts, timings and messages from this section; """"""; self.counts.clear(); self.timings.clear(); self.messages.clear(); self.total_time = None; . def _solver_safety_check(H, state, c_ops=[], e_ops=[], args={}):; # Input is std Qobj (Hamiltonian or Liouvillian); if isinstance(H, Qobj):; Hdims = H.dims; Htype = H.type; _structure_check(Hdims, Htype, state); # Input H is function; elif isinstance(H, (FunctionType, BuiltinFunctionType)):; Hdims = H(0,args).dims; Htype = H(0,args).type; _structure_check(Hdims, Htype, state); # Input is td-list; elif isinstance(H, list):; if isinstance(H[0], Qobj):; Hdims = H[0].dims; Htype = H[0].type; elif isinstance(H[0], list):; Hdims = H[0][0].dims; Htype = H[0][0].type; elif isinstance(H[0], (FunctionType, BuiltinFunctionType)):; Hdims = H[0](0,args).dims; Htype = H[0](0,args).type ; else:; raise Exception('Invalid td-list element.'); # Check all operators in list; for ii in range(len(H)):; if isinstance(H[ii], Qobj):; _temp_dims = H[ii].dims; _temp_type = H[ii].type",MatchSource.WIKI,docs/4.2/modules/qutip/solver.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/solver.html
https://qutip.org/docs/4.2/modules/qutip/solver.html:24102,Usability,clear,clear,24102," be; given if the parent and or section total_time is set; """"""; if self.header:; output.write(""\n{}\n{}\n"".format(self.header, ; (""-""*len(self.header)))); ; # TODO: Make the timings and counts ouput in a table format; # Generally make more pretty; ; # Report timings; try:; ttt = self.parent.total_time; except:; ttt = None; ; tt = self.total_time; ; output.write(""### Timings:\n""); for key, value in self.timings.items():; l = "" - {}\t{}\n"".format(_format_time(value, tt, ttt), key); output.write(l); if tt is not None:; output.write("" - {}\t{} total time\n"".format(_format_time(tt), ; self.name)); ; # Report counts; output.write(""### Counts:\n""); for key, value in self.counts.items():; l = "" - {}\t{}\n"".format(value, key); output.write(l); ; # Report messages; output.write(""### Messages:\n""); for key, value in self.messages.items():; l = "" - {}:\t{}\n"".format(key, value); output.write(l); . def clear(self):; """"""; Clear counts, timings and messages from this section; """"""; self.counts.clear(); self.timings.clear(); self.messages.clear(); self.total_time = None; . def _solver_safety_check(H, state, c_ops=[], e_ops=[], args={}):; # Input is std Qobj (Hamiltonian or Liouvillian); if isinstance(H, Qobj):; Hdims = H.dims; Htype = H.type; _structure_check(Hdims, Htype, state); # Input H is function; elif isinstance(H, (FunctionType, BuiltinFunctionType)):; Hdims = H(0,args).dims; Htype = H(0,args).type; _structure_check(Hdims, Htype, state); # Input is td-list; elif isinstance(H, list):; if isinstance(H[0], Qobj):; Hdims = H[0].dims; Htype = H[0].type; elif isinstance(H[0], list):; Hdims = H[0][0].dims; Htype = H[0][0].type; elif isinstance(H[0], (FunctionType, BuiltinFunctionType)):; Hdims = H[0](0,args).dims; Htype = H[0](0,args).type ; else:; raise Exception('Invalid td-list element.'); # Check all operators in list; for ii in range(len(H)):; if isinstance(H[ii], Qobj):; _temp_dims = H[ii].dims; _temp_type = H[ii].type; elif isinstance(H[ii], list):; _temp_dims = H[ii][0].dim",MatchSource.WIKI,docs/4.2/modules/qutip/solver.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/solver.html
https://qutip.org/docs/4.2/modules/qutip/solver.html:24124,Usability,clear,clear,24124,"nt and or section total_time is set; """"""; if self.header:; output.write(""\n{}\n{}\n"".format(self.header, ; (""-""*len(self.header)))); ; # TODO: Make the timings and counts ouput in a table format; # Generally make more pretty; ; # Report timings; try:; ttt = self.parent.total_time; except:; ttt = None; ; tt = self.total_time; ; output.write(""### Timings:\n""); for key, value in self.timings.items():; l = "" - {}\t{}\n"".format(_format_time(value, tt, ttt), key); output.write(l); if tt is not None:; output.write("" - {}\t{} total time\n"".format(_format_time(tt), ; self.name)); ; # Report counts; output.write(""### Counts:\n""); for key, value in self.counts.items():; l = "" - {}\t{}\n"".format(value, key); output.write(l); ; # Report messages; output.write(""### Messages:\n""); for key, value in self.messages.items():; l = "" - {}:\t{}\n"".format(key, value); output.write(l); . def clear(self):; """"""; Clear counts, timings and messages from this section; """"""; self.counts.clear(); self.timings.clear(); self.messages.clear(); self.total_time = None; . def _solver_safety_check(H, state, c_ops=[], e_ops=[], args={}):; # Input is std Qobj (Hamiltonian or Liouvillian); if isinstance(H, Qobj):; Hdims = H.dims; Htype = H.type; _structure_check(Hdims, Htype, state); # Input H is function; elif isinstance(H, (FunctionType, BuiltinFunctionType)):; Hdims = H(0,args).dims; Htype = H(0,args).type; _structure_check(Hdims, Htype, state); # Input is td-list; elif isinstance(H, list):; if isinstance(H[0], Qobj):; Hdims = H[0].dims; Htype = H[0].type; elif isinstance(H[0], list):; Hdims = H[0][0].dims; Htype = H[0][0].type; elif isinstance(H[0], (FunctionType, BuiltinFunctionType)):; Hdims = H[0](0,args).dims; Htype = H[0](0,args).type ; else:; raise Exception('Invalid td-list element.'); # Check all operators in list; for ii in range(len(H)):; if isinstance(H[ii], Qobj):; _temp_dims = H[ii].dims; _temp_type = H[ii].type; elif isinstance(H[ii], list):; _temp_dims = H[ii][0].dims; _temp_type = H[ii][",MatchSource.WIKI,docs/4.2/modules/qutip/solver.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/solver.html
https://qutip.org/docs/4.2/modules/qutip/solver.html:24147,Usability,clear,clear,24147,"_time is set; """"""; if self.header:; output.write(""\n{}\n{}\n"".format(self.header, ; (""-""*len(self.header)))); ; # TODO: Make the timings and counts ouput in a table format; # Generally make more pretty; ; # Report timings; try:; ttt = self.parent.total_time; except:; ttt = None; ; tt = self.total_time; ; output.write(""### Timings:\n""); for key, value in self.timings.items():; l = "" - {}\t{}\n"".format(_format_time(value, tt, ttt), key); output.write(l); if tt is not None:; output.write("" - {}\t{} total time\n"".format(_format_time(tt), ; self.name)); ; # Report counts; output.write(""### Counts:\n""); for key, value in self.counts.items():; l = "" - {}\t{}\n"".format(value, key); output.write(l); ; # Report messages; output.write(""### Messages:\n""); for key, value in self.messages.items():; l = "" - {}:\t{}\n"".format(key, value); output.write(l); . def clear(self):; """"""; Clear counts, timings and messages from this section; """"""; self.counts.clear(); self.timings.clear(); self.messages.clear(); self.total_time = None; . def _solver_safety_check(H, state, c_ops=[], e_ops=[], args={}):; # Input is std Qobj (Hamiltonian or Liouvillian); if isinstance(H, Qobj):; Hdims = H.dims; Htype = H.type; _structure_check(Hdims, Htype, state); # Input H is function; elif isinstance(H, (FunctionType, BuiltinFunctionType)):; Hdims = H(0,args).dims; Htype = H(0,args).type; _structure_check(Hdims, Htype, state); # Input is td-list; elif isinstance(H, list):; if isinstance(H[0], Qobj):; Hdims = H[0].dims; Htype = H[0].type; elif isinstance(H[0], list):; Hdims = H[0][0].dims; Htype = H[0][0].type; elif isinstance(H[0], (FunctionType, BuiltinFunctionType)):; Hdims = H[0](0,args).dims; Htype = H[0](0,args).type ; else:; raise Exception('Invalid td-list element.'); # Check all operators in list; for ii in range(len(H)):; if isinstance(H[ii], Qobj):; _temp_dims = H[ii].dims; _temp_type = H[ii].type; elif isinstance(H[ii], list):; _temp_dims = H[ii][0].dims; _temp_type = H[ii][0].type; elif isinstanc",MatchSource.WIKI,docs/4.2/modules/qutip/solver.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/solver.html
https://qutip.org/docs/4.2/modules/qutip/states.html:13152,Availability,down,down,13152,">> ket2dm(x); Quantum object: dims = [[3], [3]], \; shape = [3, 3], type = oper, isHerm = True; Qobj data =; [[ 0.+0.j 0.+0.j 0.+0.j]; [ 0.+0.j 0.+0.j 0.+0.j]; [ 0.+0.j 0.+0.j 1.+0.j]]. """"""; if Q.type == 'ket':; out = Q * Q.dag(); elif Q.type == 'bra':; out = Q.dag() * Q; else:; raise TypeError(""Input is not a ket or bra vector.""); return Qobj(out). #; # projection operator; #; [docs]def projection(N, n, m, offset=0):; """"""The projection operator that projects state :math:`|m>` on state :math:`|n>`. Parameters; ----------; N : int; Number of basis states in Hilbert space. n, m : float; The number states in the projection. offset : int (default 0); The lowest number state that is included in the finite number state; representation of the projector. Returns; -------; oper : qobj; Requested projection operator. """"""; ket1 = basis(N, n, offset=offset); ket2 = basis(N, m, offset=offset). return ket1 * ket2.dag(). #; # composite qubit states; #; def qstate(string):; """"""Creates a tensor product for a set of qubits in either; the 'up' :math:`|0>` or 'down' :math:`|1>` state. Parameters; ----------; string : str; String containing 'u' or 'd' for each qubit (ex. 'ududd'). Returns; -------; qstate : qobj; Qobj for tensor product corresponding to input string. Notes; -----; Look at ket and bra for more general functions; creating multiparticle states. Examples; --------; >>> qstate('udu'); Quantum object: dims = [[2, 2, 2], [1, 1, 1]], shape = [8, 1], type = ket; Qobj data =; [[ 0.]; [ 0.]; [ 0.]; [ 0.]; [ 0.]; [ 1.]; [ 0.]; [ 0.]]. """"""; n = len(string); if n != (string.count('u') + string.count('d')):; raise TypeError('String input to QSTATE must consist ' +; 'of ""u"" and ""d"" elements only'); else:; up = basis(2, 1); dn = basis(2, 0); lst = []; for k in range(n):; if string[k] == 'u':; lst.append(up); else:; lst.append(dn); return tensor(lst). #; # different qubit notation dictionary; #; _qubit_dict = {'g': 0, # ground state; 'e': 1, # excited state; 'u': 0, # spin up; 'd': 1, # ",MatchSource.WIKI,docs/4.2/modules/qutip/states.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/states.html
https://qutip.org/docs/4.2/modules/qutip/states.html:14100,Availability,down,down,14100,"):; """"""Creates a tensor product for a set of qubits in either; the 'up' :math:`|0>` or 'down' :math:`|1>` state. Parameters; ----------; string : str; String containing 'u' or 'd' for each qubit (ex. 'ududd'). Returns; -------; qstate : qobj; Qobj for tensor product corresponding to input string. Notes; -----; Look at ket and bra for more general functions; creating multiparticle states. Examples; --------; >>> qstate('udu'); Quantum object: dims = [[2, 2, 2], [1, 1, 1]], shape = [8, 1], type = ket; Qobj data =; [[ 0.]; [ 0.]; [ 0.]; [ 0.]; [ 0.]; [ 1.]; [ 0.]; [ 0.]]. """"""; n = len(string); if n != (string.count('u') + string.count('d')):; raise TypeError('String input to QSTATE must consist ' +; 'of ""u"" and ""d"" elements only'); else:; up = basis(2, 1); dn = basis(2, 0); lst = []; for k in range(n):; if string[k] == 'u':; lst.append(up); else:; lst.append(dn); return tensor(lst). #; # different qubit notation dictionary; #; _qubit_dict = {'g': 0, # ground state; 'e': 1, # excited state; 'u': 0, # spin up; 'd': 1, # spin down; 'H': 0, # horizontal polarization; 'V': 1} # vertical polarization. def _character_to_qudit(x):; """"""; Converts a character representing a one-particle state into int.; """"""; if x in _qubit_dict:; return _qubit_dict[x]; else:; return int(x). [docs]def ket(seq, dim=2):; """"""; Produces a multiparticle ket state for a list or string,; where each element stands for state of the respective particle. Parameters; ----------; seq : str / list of ints or characters; Each element defines state of the respective particle.; (e.g. [1,1,0,1] or a string ""1101"").; For qubits it is also possible to use the following conventions:; - 'g'/'e' (ground and excited state); - 'u'/'d' (spin up and down); - 'H'/'V' (horizontal and vertical polarization); Note: for dimension > 9 you need to use a list. dim : int (default: 2) / list of ints; Space dimension for each particle:; int if there are the same, list if they are different. Returns; -------; ket : qobj. Examples; ----",MatchSource.WIKI,docs/4.2/modules/qutip/states.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/states.html
https://qutip.org/docs/4.2/modules/qutip/states.html:14786,Availability,down,down,14786," ""u"" and ""d"" elements only'); else:; up = basis(2, 1); dn = basis(2, 0); lst = []; for k in range(n):; if string[k] == 'u':; lst.append(up); else:; lst.append(dn); return tensor(lst). #; # different qubit notation dictionary; #; _qubit_dict = {'g': 0, # ground state; 'e': 1, # excited state; 'u': 0, # spin up; 'd': 1, # spin down; 'H': 0, # horizontal polarization; 'V': 1} # vertical polarization. def _character_to_qudit(x):; """"""; Converts a character representing a one-particle state into int.; """"""; if x in _qubit_dict:; return _qubit_dict[x]; else:; return int(x). [docs]def ket(seq, dim=2):; """"""; Produces a multiparticle ket state for a list or string,; where each element stands for state of the respective particle. Parameters; ----------; seq : str / list of ints or characters; Each element defines state of the respective particle.; (e.g. [1,1,0,1] or a string ""1101"").; For qubits it is also possible to use the following conventions:; - 'g'/'e' (ground and excited state); - 'u'/'d' (spin up and down); - 'H'/'V' (horizontal and vertical polarization); Note: for dimension > 9 you need to use a list. dim : int (default: 2) / list of ints; Space dimension for each particle:; int if there are the same, list if they are different. Returns; -------; ket : qobj. Examples; --------; >>> ket(""10""); Quantum object: dims = [[2, 2], [1, 1]], shape = [4, 1], type = ket; Qobj data =; [[ 0.]; [ 0.]; [ 1.]; [ 0.]]. >>> ket(""Hue""); Quantum object: dims = [[2, 2, 2], [1, 1, 1]], shape = [8, 1], type = ket; Qobj data =; [[ 0.]; [ 1.]; [ 0.]; [ 0.]; [ 0.]; [ 0.]; [ 0.]; [ 0.]]. >>> ket(""12"", 3); Quantum object: dims = [[3, 3], [1, 1]], shape = [9, 1], type = ket; Qobj data =; [[ 0.]; [ 0.]; [ 0.]; [ 0.]; [ 0.]; [ 1.]; [ 0.]; [ 0.]; [ 0.]]. >>> ket(""31"", [5, 2]); Quantum object: dims = [[5, 2], [1, 1]], shape = [10, 1], type = ket; Qobj data =; [[ 0.]; [ 0.]; [ 0.]; [ 0.]; [ 0.]; [ 0.]; [ 0.]; [ 1.]; [ 0.]; [ 0.]]; """"""; if isinstance(dim, int):; dim = [dim] * len(seq); return tensor([b",MatchSource.WIKI,docs/4.2/modules/qutip/states.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/states.html
https://qutip.org/docs/4.2/modules/qutip/states.html:16282,Availability,down,down,16282,"[8, 1], type = ket; Qobj data =; [[ 0.]; [ 1.]; [ 0.]; [ 0.]; [ 0.]; [ 0.]; [ 0.]; [ 0.]]. >>> ket(""12"", 3); Quantum object: dims = [[3, 3], [1, 1]], shape = [9, 1], type = ket; Qobj data =; [[ 0.]; [ 0.]; [ 0.]; [ 0.]; [ 0.]; [ 1.]; [ 0.]; [ 0.]; [ 0.]]. >>> ket(""31"", [5, 2]); Quantum object: dims = [[5, 2], [1, 1]], shape = [10, 1], type = ket; Qobj data =; [[ 0.]; [ 0.]; [ 0.]; [ 0.]; [ 0.]; [ 0.]; [ 0.]; [ 1.]; [ 0.]; [ 0.]]; """"""; if isinstance(dim, int):; dim = [dim] * len(seq); return tensor([basis(dim[i], _character_to_qudit(x)); for i, x in enumerate(seq)]). [docs]def bra(seq, dim=2):; """"""; Produces a multiparticle bra state for a list or string,; where each element stands for state of the respective particle. Parameters; ----------; seq : str / list of ints or characters; Each element defines state of the respective particle.; (e.g. [1,1,0,1] or a string ""1101"").; For qubits it is also possible to use the following conventions:; - 'g'/'e' (ground and excited state); - 'u'/'d' (spin up and down); - 'H'/'V' (horizontal and vertical polarization); Note: for dimension > 9 you need to use a list. dim : int (default: 2) / list of ints; Space dimension for each particle:; int if there are the same, list if they are different. Returns; -------; bra : qobj. Examples; --------; >>> bra(""10""); Quantum object: dims = [[1, 1], [2, 2]], shape = [1, 4], type = bra; Qobj data =; [[ 0. 0. 1. 0.]]. >>> bra(""Hue""); Quantum object: dims = [[1, 1, 1], [2, 2, 2]], shape = [1, 8], type = bra; Qobj data =; [[ 0. 1. 0. 0. 0. 0. 0. 0.]]. >>> bra(""12"", 3); Quantum object: dims = [[1, 1], [3, 3]], shape = [1, 9], type = bra; Qobj data =; [[ 0. 0. 0. 0. 0. 1. 0. 0. 0.]]. >>> bra(""31"", [5, 2]); Quantum object: dims = [[1, 1], [5, 2]], shape = [1, 10], type = bra; Qobj data =; [[ 0. 0. 0. 0. 0. 0. 0. 1. 0. 0.]]; """"""; return ket(seq, dim=dim).dag(). #; # quantum state number helper functions; #; [docs]def state_number_enumerate(dims, excitations=None, state=None, idx=0):; """"""; An iterator ",MatchSource.WIKI,docs/4.2/modules/qutip/states.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/states.html
https://qutip.org/docs/4.2/modules/qutip/states.html:28500,Deployability,update,updated,28500,"00':; Bell_state = tensor(; basis(2), basis(2))+tensor(basis(2, 1), basis(2, 1)); elif state == '01':; Bell_state = tensor(; basis(2), basis(2))-tensor(basis(2, 1), basis(2, 1)); elif state == '10':; Bell_state = tensor(; basis(2), basis(2, 1))+tensor(basis(2, 1), basis(2)); elif state == '11':; Bell_state = tensor(; basis(2), basis(2, 1))-tensor(basis(2, 1), basis(2)). return Bell_state.unit(). [docs]def singlet_state():; """"""; Returns the two particle singlet-state:. |S>=1/sqrt(2)*[|0>|1>-|1>|0>]. that is identical to the fourth bell state. Returns; -------; Bell_state : qobj; |B11> Bell state. """"""; return bell_state('11'). def triplet_states():; """"""; Returns the two particle triplet-states:. |T>= |1>|1>; = 1 / sqrt(2)*[|0>|1>-|1>|0>]; = |0>|0>; that is identical to the fourth bell state. Returns; -------; trip_states : list; 2 particle triplet states. """"""; trip_states = []; trip_states.append(tensor(basis(2, 1), basis(2, 1))); trip_states.append(; (tensor(basis(2), basis(2, 1)) + tensor(basis(2, 1), basis(2))).unit(); ); trip_states.append(tensor(basis(2), basis(2))); return trip_states. def w_state(N=3):; """"""; Returns the N-qubit W-state. Parameters; ----------; N : int (default=3); Number of qubits in state. Returns; -------; W : qobj; N-qubit W-state. """"""; inds = np.zeros(N, dtype=int); inds[0] = 1; state = tensor([basis(2, x) for x in inds]); for kk in range(1, N):; perm_inds = np.roll(inds, kk); state += tensor([basis(2, x) for x in perm_inds]); return state.unit(). [docs]def ghz_state(N=3):; """"""; Returns the N-qubit GHZ-state. Parameters; ----------; N : int (default=3); Number of qubits in state. Returns; -------; G : qobj; N-qubit GHZ-state. """"""; state = (tensor([basis(2) for k in range(N)]) +; tensor([basis(2, 1) for k in range(N)])); return state/np.sqrt(2).  Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, and A.L. Grimsmo.; Last updated on Jan 17, 2018. . Built with Sphinx using a theme provided by Read the Docs. . ",MatchSource.WIKI,docs/4.2/modules/qutip/states.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/states.html
https://qutip.org/docs/4.2/modules/qutip/states.html:10885,Testability,log,log,10885," state density matrix. Examples; --------; >>> thermal_dm(5, 1); Quantum object: dims = [[5], [5]], \; shape = [5, 5], type = oper, isHerm = True; Qobj data =; [[ 0.51612903 0. 0. 0. 0. ]; [ 0. 0.25806452 0. 0. 0. ]; [ 0. 0. 0.12903226 0. 0. ]; [ 0. 0. 0. 0.06451613 0. ]; [ 0. 0. 0. 0. 0.03225806]]. >>> thermal_dm(5, 1, 'analytic'); Quantum object: dims = [[5], [5]], \; shape = [5, 5], type = oper, isHerm = True; Qobj data =; [[ 0.5 0. 0. 0. 0. ]; [ 0. 0.25 0. 0. 0. ]; [ 0. 0. 0.125 0. 0. ]; [ 0. 0. 0. 0.0625 0. ]; [ 0. 0. 0. 0. 0.03125]]. Notes; -----; The 'operator' method (default) generates; the thermal state using the truncated number operator ``num(N)``. This; is the method that should be used in computations. The; 'analytic' method uses the analytic coefficients derived in; an infinite Hilbert space. The analytic form is not necessarily normalized,; if truncated too aggressively. """"""; if n == 0:; return fock_dm(N, 0); else:; i = arange(N); if method == 'operator':; beta = np.log(1.0 / n + 1.0); diags = np.exp(-beta * i); diags = diags / np.sum(diags); # populates diagonal terms using truncated operator expression; rm = sp.spdiags(diags, 0, N, N, format='csr'); elif method == 'analytic':; # populates diagonal terms using analytic values; rm = sp.spdiags((1.0 + n) ** (-1.0) * (n / (1.0 + n)) ** (i),; 0, N, N, format='csr'); else:; raise ValueError(; ""'method' keyword argument must be 'operator' or 'analytic'""); return Qobj(rm). [docs]def maximally_mixed_dm(N):; """"""; Returns the maximally mixed density matrix for a Hilbert space of; dimension N. Parameters; ----------; N : int; Number of basis states in Hilbert space. Returns; -------; dm : qobj; Thermal state density matrix.; """"""; if (not isinstance(N, (int, np.int64))) or N <= 0:; raise ValueError(""N must be integer N > 0""). dm = sp.spdiags(np.ones(N, dtype=complex)/float(N), 0, N, N, format='csr'). return Qobj(dm, isherm=True). [docs]def ket2dm(Q):; """"""Takes input ket or bra vector and returns density matrix;",MatchSource.WIKI,docs/4.2/modules/qutip/states.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/states.html
https://qutip.org/docs/4.2/modules/qutip/steadystate.html:20784,Availability,error,error,20784,"mres(L, b, tol=ss_args['tol'], M=ss_args['M'],; x0=ss_args['x0'], maxiter=ss_args['maxiter'],; callback=_iter_count). elif ss_args['method'] == 'iterative-bicgstab':; v, check = bicgstab(L, b, tol=ss_args['tol'], M=ss_args['M'],; x0=ss_args['x0'],; maxiter=ss_args['maxiter'], callback=_iter_count); else:; raise Exception(""Invalid iterative solver method.""); _iter_end = time.time(). ss_args['info']['iter_time'] = _iter_end - _iter_start; if ss_args['info']['precond_time'] is not None:; ss_args['info']['solution_time'] = (ss_args['info']['iter_time'] +; ss_args['info']['precond_time']); else:; ss_args['info']['solution_time'] = ss_args['info']['iter_time']; ss_args['info']['iterations'] = ss_iters['iter']; if ss_args['return_info']:; ss_args['info']['residual_norm'] = la.norm(b - L*v). if settings.debug:; logger.debug('Number of Iterations: %i' % ss_iters['iter']); logger.debug('Iteration. time: %f' % (_iter_end - _iter_start)). if check > 0:; raise Exception(""Steadystate error: Did not reach tolerance after "" +; str(ss_args['maxiter']) + "" steps."" +; ""\nResidual norm: "" +; str(ss_args['info']['residual_norm'])). elif check < 0:; raise Exception(; ""Steadystate error: Failed with fatal error: "" + str(check) + "".""). if ss_args['use_rcm']:; v = v[np.ix_(rev_perm,)]. data = vec2mat(v); data = 0.5 * (data + data.conj().T); if ss_args['return_info']:; return Qobj(data, dims=dims, isherm=True), ss_args['info']; else:; return Qobj(data, dims=dims, isherm=True). def _steadystate_svd_dense(L, ss_args):; """"""; Find the steady state(s) of an open quantum system by solving for the; nullspace of the Liouvillian.; """"""; ss_args['info'].pop('weight', None); atol = 1e-12; rtol = 1e-12; if settings.debug:; logger.debug('Starting SVD solver.'); _svd_start = time.time(); u, s, vh = svd(L.full(), full_matrices=False); tol = max(atol, rtol * s[0]); nnz = (s >= tol).sum(); ns = vh[nnz:].conj().T; _svd_end = time.time(); ss_args['info']['solution_time'] = _svd_end-_svd_start; if ss_args['all_st",MatchSource.WIKI,docs/4.2/modules/qutip/steadystate.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/steadystate.html
https://qutip.org/docs/4.2/modules/qutip/steadystate.html:20805,Availability,toler,tolerance,20805,"mres(L, b, tol=ss_args['tol'], M=ss_args['M'],; x0=ss_args['x0'], maxiter=ss_args['maxiter'],; callback=_iter_count). elif ss_args['method'] == 'iterative-bicgstab':; v, check = bicgstab(L, b, tol=ss_args['tol'], M=ss_args['M'],; x0=ss_args['x0'],; maxiter=ss_args['maxiter'], callback=_iter_count); else:; raise Exception(""Invalid iterative solver method.""); _iter_end = time.time(). ss_args['info']['iter_time'] = _iter_end - _iter_start; if ss_args['info']['precond_time'] is not None:; ss_args['info']['solution_time'] = (ss_args['info']['iter_time'] +; ss_args['info']['precond_time']); else:; ss_args['info']['solution_time'] = ss_args['info']['iter_time']; ss_args['info']['iterations'] = ss_iters['iter']; if ss_args['return_info']:; ss_args['info']['residual_norm'] = la.norm(b - L*v). if settings.debug:; logger.debug('Number of Iterations: %i' % ss_iters['iter']); logger.debug('Iteration. time: %f' % (_iter_end - _iter_start)). if check > 0:; raise Exception(""Steadystate error: Did not reach tolerance after "" +; str(ss_args['maxiter']) + "" steps."" +; ""\nResidual norm: "" +; str(ss_args['info']['residual_norm'])). elif check < 0:; raise Exception(; ""Steadystate error: Failed with fatal error: "" + str(check) + "".""). if ss_args['use_rcm']:; v = v[np.ix_(rev_perm,)]. data = vec2mat(v); data = 0.5 * (data + data.conj().T); if ss_args['return_info']:; return Qobj(data, dims=dims, isherm=True), ss_args['info']; else:; return Qobj(data, dims=dims, isherm=True). def _steadystate_svd_dense(L, ss_args):; """"""; Find the steady state(s) of an open quantum system by solving for the; nullspace of the Liouvillian.; """"""; ss_args['info'].pop('weight', None); atol = 1e-12; rtol = 1e-12; if settings.debug:; logger.debug('Starting SVD solver.'); _svd_start = time.time(); u, s, vh = svd(L.full(), full_matrices=False); tol = max(atol, rtol * s[0]); nnz = (s >= tol).sum(); ns = vh[nnz:].conj().T; _svd_end = time.time(); ss_args['info']['solution_time'] = _svd_end-_svd_start; if ss_args['all_st",MatchSource.WIKI,docs/4.2/modules/qutip/steadystate.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/steadystate.html
https://qutip.org/docs/4.2/modules/qutip/steadystate.html:20976,Availability,error,error,20976,"bicgstab(L, b, tol=ss_args['tol'], M=ss_args['M'],; x0=ss_args['x0'],; maxiter=ss_args['maxiter'], callback=_iter_count); else:; raise Exception(""Invalid iterative solver method.""); _iter_end = time.time(). ss_args['info']['iter_time'] = _iter_end - _iter_start; if ss_args['info']['precond_time'] is not None:; ss_args['info']['solution_time'] = (ss_args['info']['iter_time'] +; ss_args['info']['precond_time']); else:; ss_args['info']['solution_time'] = ss_args['info']['iter_time']; ss_args['info']['iterations'] = ss_iters['iter']; if ss_args['return_info']:; ss_args['info']['residual_norm'] = la.norm(b - L*v). if settings.debug:; logger.debug('Number of Iterations: %i' % ss_iters['iter']); logger.debug('Iteration. time: %f' % (_iter_end - _iter_start)). if check > 0:; raise Exception(""Steadystate error: Did not reach tolerance after "" +; str(ss_args['maxiter']) + "" steps."" +; ""\nResidual norm: "" +; str(ss_args['info']['residual_norm'])). elif check < 0:; raise Exception(; ""Steadystate error: Failed with fatal error: "" + str(check) + "".""). if ss_args['use_rcm']:; v = v[np.ix_(rev_perm,)]. data = vec2mat(v); data = 0.5 * (data + data.conj().T); if ss_args['return_info']:; return Qobj(data, dims=dims, isherm=True), ss_args['info']; else:; return Qobj(data, dims=dims, isherm=True). def _steadystate_svd_dense(L, ss_args):; """"""; Find the steady state(s) of an open quantum system by solving for the; nullspace of the Liouvillian.; """"""; ss_args['info'].pop('weight', None); atol = 1e-12; rtol = 1e-12; if settings.debug:; logger.debug('Starting SVD solver.'); _svd_start = time.time(); u, s, vh = svd(L.full(), full_matrices=False); tol = max(atol, rtol * s[0]); nnz = (s >= tol).sum(); ns = vh[nnz:].conj().T; _svd_end = time.time(); ss_args['info']['solution_time'] = _svd_end-_svd_start; if ss_args['all_states']:; rhoss_list = []; for n in range(ns.shape[1]):; rhoss = Qobj(vec2mat(ns[:, n]), dims=L.dims[0]); rhoss_list.append(rhoss / rhoss.tr()); if ss_args['return_info']:; retur",MatchSource.WIKI,docs/4.2/modules/qutip/steadystate.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/steadystate.html
https://qutip.org/docs/4.2/modules/qutip/steadystate.html:21001,Availability,error,error,21001,"bicgstab(L, b, tol=ss_args['tol'], M=ss_args['M'],; x0=ss_args['x0'],; maxiter=ss_args['maxiter'], callback=_iter_count); else:; raise Exception(""Invalid iterative solver method.""); _iter_end = time.time(). ss_args['info']['iter_time'] = _iter_end - _iter_start; if ss_args['info']['precond_time'] is not None:; ss_args['info']['solution_time'] = (ss_args['info']['iter_time'] +; ss_args['info']['precond_time']); else:; ss_args['info']['solution_time'] = ss_args['info']['iter_time']; ss_args['info']['iterations'] = ss_iters['iter']; if ss_args['return_info']:; ss_args['info']['residual_norm'] = la.norm(b - L*v). if settings.debug:; logger.debug('Number of Iterations: %i' % ss_iters['iter']); logger.debug('Iteration. time: %f' % (_iter_end - _iter_start)). if check > 0:; raise Exception(""Steadystate error: Did not reach tolerance after "" +; str(ss_args['maxiter']) + "" steps."" +; ""\nResidual norm: "" +; str(ss_args['info']['residual_norm'])). elif check < 0:; raise Exception(; ""Steadystate error: Failed with fatal error: "" + str(check) + "".""). if ss_args['use_rcm']:; v = v[np.ix_(rev_perm,)]. data = vec2mat(v); data = 0.5 * (data + data.conj().T); if ss_args['return_info']:; return Qobj(data, dims=dims, isherm=True), ss_args['info']; else:; return Qobj(data, dims=dims, isherm=True). def _steadystate_svd_dense(L, ss_args):; """"""; Find the steady state(s) of an open quantum system by solving for the; nullspace of the Liouvillian.; """"""; ss_args['info'].pop('weight', None); atol = 1e-12; rtol = 1e-12; if settings.debug:; logger.debug('Starting SVD solver.'); _svd_start = time.time(); u, s, vh = svd(L.full(), full_matrices=False); tol = max(atol, rtol * s[0]); nnz = (s >= tol).sum(); ns = vh[nnz:].conj().T; _svd_end = time.time(); ss_args['info']['solution_time'] = _svd_end-_svd_start; if ss_args['all_states']:; rhoss_list = []; for n in range(ns.shape[1]):; rhoss = Qobj(vec2mat(ns[:, n]), dims=L.dims[0]); rhoss_list.append(rhoss / rhoss.tr()); if ss_args['return_info']:; retur",MatchSource.WIKI,docs/4.2/modules/qutip/steadystate.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/steadystate.html
https://qutip.org/docs/4.2/modules/qutip/steadystate.html:35151,Availability,avail,available,35151,"r the Liouvillian; superoperator L.; ; w : double; frequency at which to evaluate pseudo-inverse. Can be zero for dense systems; and large sparse systems. Small sparse systems can fail for zero frequencies. sparse : bool; Flag that indicate whether to use sparse or dense matrix methods when; computing the pseudo inverse. method : string; Name of method to use. For sparse=True, allowed values are 'spsolve',; 'splu' and 'spilu'. For sparse=False, allowed values are 'direct' and; 'numpy'. kwargs : dictionary; Additional keyword arguments for setting parameters for solver methods. Returns; -------; R : Qobj; Returns a Qobj instance representing the pseudo inverse of L.; ; Note; ----; In general the inverse of a sparse matrix will be dense. If you; are applying the inverse to a density matrix then it is better to; cast the problem as an Ax=b type problem where the explicit calculation; of the inverse is not required. See page 67 of ""Electrons in nanostructures""; C. Flindt, PhD Thesis available online:; http://orbit.dtu.dk/fedora/objects/orbit:82314/datastreams/file_4732600/content; ; Note also that the definition of the pseudo-inverse herein is different; from numpys pinv() alone, as it includes pre and post projection onto ; the subspace defined by the projector Q.; ; """"""; pseudo_args = _default_steadystate_args(); for key in kwargs.keys():; if key in pseudo_args.keys():; pseudo_args[key] = kwargs[key]; else:; raise Exception(; ""Invalid keyword argument '""+key+""' passed to pseudo_inverse.""); if 'method' not in kwargs.keys():; pseudo_args['method']='splu'; ; # Set column perm to NATURAL if using RCM and not specified by user; if pseudo_args['use_rcm'] and ('permc_spec' not in kwargs.keys()):; pseudo_args['permc_spec'] = 'NATURAL'; ; if rhoss is None:; rhoss = steadystate(L, **pseudo_args). if sparse:; return _pseudo_inverse_sparse(L,rhoss, w=w, **pseudo_args); else:; pseudo_args['method'] = pseudo_args['method'] if pseudo_args['method'] != 'splu' else 'direct'; return _p",MatchSource.WIKI,docs/4.2/modules/qutip/steadystate.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/steadystate.html
https://qutip.org/docs/4.2/modules/qutip/steadystate.html:36319,Deployability,update,updated,36319,"o use sparse or dense matrix methods when; computing the pseudo inverse. method : string; Name of method to use. For sparse=True, allowed values are 'spsolve',; 'splu' and 'spilu'. For sparse=False, allowed values are 'direct' and; 'numpy'. kwargs : dictionary; Additional keyword arguments for setting parameters for solver methods. Returns; -------; R : Qobj; Returns a Qobj instance representing the pseudo inverse of L.; ; Note; ----; In general the inverse of a sparse matrix will be dense. If you; are applying the inverse to a density matrix then it is better to; cast the problem as an Ax=b type problem where the explicit calculation; of the inverse is not required. See page 67 of ""Electrons in nanostructures""; C. Flindt, PhD Thesis available online:; http://orbit.dtu.dk/fedora/objects/orbit:82314/datastreams/file_4732600/content; ; Note also that the definition of the pseudo-inverse herein is different; from numpys pinv() alone, as it includes pre and post projection onto ; the subspace defined by the projector Q.; ; """"""; pseudo_args = _default_steadystate_args(); for key in kwargs.keys():; if key in pseudo_args.keys():; pseudo_args[key] = kwargs[key]; else:; raise Exception(; ""Invalid keyword argument '""+key+""' passed to pseudo_inverse.""); if 'method' not in kwargs.keys():; pseudo_args['method']='splu'; ; # Set column perm to NATURAL if using RCM and not specified by user; if pseudo_args['use_rcm'] and ('permc_spec' not in kwargs.keys()):; pseudo_args['permc_spec'] = 'NATURAL'; ; if rhoss is None:; rhoss = steadystate(L, **pseudo_args). if sparse:; return _pseudo_inverse_sparse(L,rhoss, w=w, **pseudo_args); else:; pseudo_args['method'] = pseudo_args['method'] if pseudo_args['method'] != 'splu' else 'direct'; return _pseudo_inverse_dense(L, rhoss, w=w, **pseudo_args).  Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, and A.L. Grimsmo.; Last updated on Jan 17, 2018. . Built with Sphinx using a theme provided by Read the Docs. . ",MatchSource.WIKI,docs/4.2/modules/qutip/steadystate.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/steadystate.html
https://qutip.org/docs/4.2/modules/qutip/steadystate.html:4988,Energy Efficiency,power,power,4988,"'direct', 'sparse': True, 'use_rcm': False,; 'use_wbm': False, 'weight': None, 'use_precond': False, ; 'all_states': False, 'M': None, 'x0': None, 'drop_tol': 1e-4, ; 'fill_factor': 100, 'diag_pivot_thresh': None, 'maxiter': 1000, ; 'tol': 1e-12, 'permc_spec': 'COLAMD', 'ILU_MILU': 'smilu_2', ; 'restart': 20, 'return_info': False, 'info': _empty_info_dict(), ; 'verbose': False}. return def_args. [docs]def steadystate(A, c_op_list=[], **kwargs):; """"""Calculates the steady state for quantum evolution subject to the; supplied Hamiltonian or Liouvillian operator and (if given a Hamiltonian) a; list of collapse operators. If the user passes a Hamiltonian then it, along with the list of collapse; operators, will be converted into a Liouvillian operator in Lindblad form. Parameters; ----------; A : qobj; A Hamiltonian or Liouvillian operator. c_op_list : list; A list of collapse operators. method : str {'direct', 'eigen', 'iterative-gmres',; 'iterative-lgmres', 'iterative-bicgstab', 'svd', 'power',; 'power-gmres', 'power-lgmres', 'power-bicgstab'}; Method for solving the underlying linear equation. Direct LU solver; 'direct' (default), sparse eigenvalue problem 'eigen',; iterative GMRES method 'iterative-gmres', iterative LGMRES method; 'iterative-lgmres', iterative BICGSTAB method 'iterative-bicgstab',; SVD 'svd' (dense), or inverse-power method 'power'. The iterative; power methods 'power-gmres', 'power-lgmres', 'power-bicgstab' use; the same solvers as their direct counterparts. return_info : bool, optional, default = False; Return a dictionary of solver-specific infomation about the; solution and how it was obtained. sparse : bool, optional, default = True; Solve for the steady state using sparse algorithms. If set to False,; the underlying Liouvillian operator will be converted into a dense; matrix. Use only for 'smaller' systems. use_rcm : bool, optional, default = False; Use reverse Cuthill-Mckee reordering to minimize fill-in in the; LU factorization of the Liouvilli",MatchSource.WIKI,docs/4.2/modules/qutip/steadystate.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/steadystate.html
https://qutip.org/docs/4.2/modules/qutip/steadystate.html:4998,Energy Efficiency,power,power-gmres,4998,"'direct', 'sparse': True, 'use_rcm': False,; 'use_wbm': False, 'weight': None, 'use_precond': False, ; 'all_states': False, 'M': None, 'x0': None, 'drop_tol': 1e-4, ; 'fill_factor': 100, 'diag_pivot_thresh': None, 'maxiter': 1000, ; 'tol': 1e-12, 'permc_spec': 'COLAMD', 'ILU_MILU': 'smilu_2', ; 'restart': 20, 'return_info': False, 'info': _empty_info_dict(), ; 'verbose': False}. return def_args. [docs]def steadystate(A, c_op_list=[], **kwargs):; """"""Calculates the steady state for quantum evolution subject to the; supplied Hamiltonian or Liouvillian operator and (if given a Hamiltonian) a; list of collapse operators. If the user passes a Hamiltonian then it, along with the list of collapse; operators, will be converted into a Liouvillian operator in Lindblad form. Parameters; ----------; A : qobj; A Hamiltonian or Liouvillian operator. c_op_list : list; A list of collapse operators. method : str {'direct', 'eigen', 'iterative-gmres',; 'iterative-lgmres', 'iterative-bicgstab', 'svd', 'power',; 'power-gmres', 'power-lgmres', 'power-bicgstab'}; Method for solving the underlying linear equation. Direct LU solver; 'direct' (default), sparse eigenvalue problem 'eigen',; iterative GMRES method 'iterative-gmres', iterative LGMRES method; 'iterative-lgmres', iterative BICGSTAB method 'iterative-bicgstab',; SVD 'svd' (dense), or inverse-power method 'power'. The iterative; power methods 'power-gmres', 'power-lgmres', 'power-bicgstab' use; the same solvers as their direct counterparts. return_info : bool, optional, default = False; Return a dictionary of solver-specific infomation about the; solution and how it was obtained. sparse : bool, optional, default = True; Solve for the steady state using sparse algorithms. If set to False,; the underlying Liouvillian operator will be converted into a dense; matrix. Use only for 'smaller' systems. use_rcm : bool, optional, default = False; Use reverse Cuthill-Mckee reordering to minimize fill-in in the; LU factorization of the Liouvilli",MatchSource.WIKI,docs/4.2/modules/qutip/steadystate.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/steadystate.html
https://qutip.org/docs/4.2/modules/qutip/steadystate.html:5013,Energy Efficiency,power,power-lgmres,5013,"'direct', 'sparse': True, 'use_rcm': False,; 'use_wbm': False, 'weight': None, 'use_precond': False, ; 'all_states': False, 'M': None, 'x0': None, 'drop_tol': 1e-4, ; 'fill_factor': 100, 'diag_pivot_thresh': None, 'maxiter': 1000, ; 'tol': 1e-12, 'permc_spec': 'COLAMD', 'ILU_MILU': 'smilu_2', ; 'restart': 20, 'return_info': False, 'info': _empty_info_dict(), ; 'verbose': False}. return def_args. [docs]def steadystate(A, c_op_list=[], **kwargs):; """"""Calculates the steady state for quantum evolution subject to the; supplied Hamiltonian or Liouvillian operator and (if given a Hamiltonian) a; list of collapse operators. If the user passes a Hamiltonian then it, along with the list of collapse; operators, will be converted into a Liouvillian operator in Lindblad form. Parameters; ----------; A : qobj; A Hamiltonian or Liouvillian operator. c_op_list : list; A list of collapse operators. method : str {'direct', 'eigen', 'iterative-gmres',; 'iterative-lgmres', 'iterative-bicgstab', 'svd', 'power',; 'power-gmres', 'power-lgmres', 'power-bicgstab'}; Method for solving the underlying linear equation. Direct LU solver; 'direct' (default), sparse eigenvalue problem 'eigen',; iterative GMRES method 'iterative-gmres', iterative LGMRES method; 'iterative-lgmres', iterative BICGSTAB method 'iterative-bicgstab',; SVD 'svd' (dense), or inverse-power method 'power'. The iterative; power methods 'power-gmres', 'power-lgmres', 'power-bicgstab' use; the same solvers as their direct counterparts. return_info : bool, optional, default = False; Return a dictionary of solver-specific infomation about the; solution and how it was obtained. sparse : bool, optional, default = True; Solve for the steady state using sparse algorithms. If set to False,; the underlying Liouvillian operator will be converted into a dense; matrix. Use only for 'smaller' systems. use_rcm : bool, optional, default = False; Use reverse Cuthill-Mckee reordering to minimize fill-in in the; LU factorization of the Liouvilli",MatchSource.WIKI,docs/4.2/modules/qutip/steadystate.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/steadystate.html
https://qutip.org/docs/4.2/modules/qutip/steadystate.html:5029,Energy Efficiency,power,power-bicgstab,5029,"'direct', 'sparse': True, 'use_rcm': False,; 'use_wbm': False, 'weight': None, 'use_precond': False, ; 'all_states': False, 'M': None, 'x0': None, 'drop_tol': 1e-4, ; 'fill_factor': 100, 'diag_pivot_thresh': None, 'maxiter': 1000, ; 'tol': 1e-12, 'permc_spec': 'COLAMD', 'ILU_MILU': 'smilu_2', ; 'restart': 20, 'return_info': False, 'info': _empty_info_dict(), ; 'verbose': False}. return def_args. [docs]def steadystate(A, c_op_list=[], **kwargs):; """"""Calculates the steady state for quantum evolution subject to the; supplied Hamiltonian or Liouvillian operator and (if given a Hamiltonian) a; list of collapse operators. If the user passes a Hamiltonian then it, along with the list of collapse; operators, will be converted into a Liouvillian operator in Lindblad form. Parameters; ----------; A : qobj; A Hamiltonian or Liouvillian operator. c_op_list : list; A list of collapse operators. method : str {'direct', 'eigen', 'iterative-gmres',; 'iterative-lgmres', 'iterative-bicgstab', 'svd', 'power',; 'power-gmres', 'power-lgmres', 'power-bicgstab'}; Method for solving the underlying linear equation. Direct LU solver; 'direct' (default), sparse eigenvalue problem 'eigen',; iterative GMRES method 'iterative-gmres', iterative LGMRES method; 'iterative-lgmres', iterative BICGSTAB method 'iterative-bicgstab',; SVD 'svd' (dense), or inverse-power method 'power'. The iterative; power methods 'power-gmres', 'power-lgmres', 'power-bicgstab' use; the same solvers as their direct counterparts. return_info : bool, optional, default = False; Return a dictionary of solver-specific infomation about the; solution and how it was obtained. sparse : bool, optional, default = True; Solve for the steady state using sparse algorithms. If set to False,; the underlying Liouvillian operator will be converted into a dense; matrix. Use only for 'smaller' systems. use_rcm : bool, optional, default = False; Use reverse Cuthill-Mckee reordering to minimize fill-in in the; LU factorization of the Liouvilli",MatchSource.WIKI,docs/4.2/modules/qutip/steadystate.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/steadystate.html
https://qutip.org/docs/4.2/modules/qutip/steadystate.html:5338,Energy Efficiency,power,power,5338,": 1e-12, 'permc_spec': 'COLAMD', 'ILU_MILU': 'smilu_2', ; 'restart': 20, 'return_info': False, 'info': _empty_info_dict(), ; 'verbose': False}. return def_args. [docs]def steadystate(A, c_op_list=[], **kwargs):; """"""Calculates the steady state for quantum evolution subject to the; supplied Hamiltonian or Liouvillian operator and (if given a Hamiltonian) a; list of collapse operators. If the user passes a Hamiltonian then it, along with the list of collapse; operators, will be converted into a Liouvillian operator in Lindblad form. Parameters; ----------; A : qobj; A Hamiltonian or Liouvillian operator. c_op_list : list; A list of collapse operators. method : str {'direct', 'eigen', 'iterative-gmres',; 'iterative-lgmres', 'iterative-bicgstab', 'svd', 'power',; 'power-gmres', 'power-lgmres', 'power-bicgstab'}; Method for solving the underlying linear equation. Direct LU solver; 'direct' (default), sparse eigenvalue problem 'eigen',; iterative GMRES method 'iterative-gmres', iterative LGMRES method; 'iterative-lgmres', iterative BICGSTAB method 'iterative-bicgstab',; SVD 'svd' (dense), or inverse-power method 'power'. The iterative; power methods 'power-gmres', 'power-lgmres', 'power-bicgstab' use; the same solvers as their direct counterparts. return_info : bool, optional, default = False; Return a dictionary of solver-specific infomation about the; solution and how it was obtained. sparse : bool, optional, default = True; Solve for the steady state using sparse algorithms. If set to False,; the underlying Liouvillian operator will be converted into a dense; matrix. Use only for 'smaller' systems. use_rcm : bool, optional, default = False; Use reverse Cuthill-Mckee reordering to minimize fill-in in the; LU factorization of the Liouvillian. use_wbm : bool, optional, default = False; Use Weighted Bipartite Matching reordering to make the Liouvillian; diagonally dominant. This is useful for iterative preconditioners; only, and is set to ``True`` by default when finding a ",MatchSource.WIKI,docs/4.2/modules/qutip/steadystate.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/steadystate.html
https://qutip.org/docs/4.2/modules/qutip/steadystate.html:5352,Energy Efficiency,power,power,5352,": 1e-12, 'permc_spec': 'COLAMD', 'ILU_MILU': 'smilu_2', ; 'restart': 20, 'return_info': False, 'info': _empty_info_dict(), ; 'verbose': False}. return def_args. [docs]def steadystate(A, c_op_list=[], **kwargs):; """"""Calculates the steady state for quantum evolution subject to the; supplied Hamiltonian or Liouvillian operator and (if given a Hamiltonian) a; list of collapse operators. If the user passes a Hamiltonian then it, along with the list of collapse; operators, will be converted into a Liouvillian operator in Lindblad form. Parameters; ----------; A : qobj; A Hamiltonian or Liouvillian operator. c_op_list : list; A list of collapse operators. method : str {'direct', 'eigen', 'iterative-gmres',; 'iterative-lgmres', 'iterative-bicgstab', 'svd', 'power',; 'power-gmres', 'power-lgmres', 'power-bicgstab'}; Method for solving the underlying linear equation. Direct LU solver; 'direct' (default), sparse eigenvalue problem 'eigen',; iterative GMRES method 'iterative-gmres', iterative LGMRES method; 'iterative-lgmres', iterative BICGSTAB method 'iterative-bicgstab',; SVD 'svd' (dense), or inverse-power method 'power'. The iterative; power methods 'power-gmres', 'power-lgmres', 'power-bicgstab' use; the same solvers as their direct counterparts. return_info : bool, optional, default = False; Return a dictionary of solver-specific infomation about the; solution and how it was obtained. sparse : bool, optional, default = True; Solve for the steady state using sparse algorithms. If set to False,; the underlying Liouvillian operator will be converted into a dense; matrix. Use only for 'smaller' systems. use_rcm : bool, optional, default = False; Use reverse Cuthill-Mckee reordering to minimize fill-in in the; LU factorization of the Liouvillian. use_wbm : bool, optional, default = False; Use Weighted Bipartite Matching reordering to make the Liouvillian; diagonally dominant. This is useful for iterative preconditioners; only, and is set to ``True`` by default when finding a ",MatchSource.WIKI,docs/4.2/modules/qutip/steadystate.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/steadystate.html
https://qutip.org/docs/4.2/modules/qutip/steadystate.html:5375,Energy Efficiency,power,power,5375,"=[], **kwargs):; """"""Calculates the steady state for quantum evolution subject to the; supplied Hamiltonian or Liouvillian operator and (if given a Hamiltonian) a; list of collapse operators. If the user passes a Hamiltonian then it, along with the list of collapse; operators, will be converted into a Liouvillian operator in Lindblad form. Parameters; ----------; A : qobj; A Hamiltonian or Liouvillian operator. c_op_list : list; A list of collapse operators. method : str {'direct', 'eigen', 'iterative-gmres',; 'iterative-lgmres', 'iterative-bicgstab', 'svd', 'power',; 'power-gmres', 'power-lgmres', 'power-bicgstab'}; Method for solving the underlying linear equation. Direct LU solver; 'direct' (default), sparse eigenvalue problem 'eigen',; iterative GMRES method 'iterative-gmres', iterative LGMRES method; 'iterative-lgmres', iterative BICGSTAB method 'iterative-bicgstab',; SVD 'svd' (dense), or inverse-power method 'power'. The iterative; power methods 'power-gmres', 'power-lgmres', 'power-bicgstab' use; the same solvers as their direct counterparts. return_info : bool, optional, default = False; Return a dictionary of solver-specific infomation about the; solution and how it was obtained. sparse : bool, optional, default = True; Solve for the steady state using sparse algorithms. If set to False,; the underlying Liouvillian operator will be converted into a dense; matrix. Use only for 'smaller' systems. use_rcm : bool, optional, default = False; Use reverse Cuthill-Mckee reordering to minimize fill-in in the; LU factorization of the Liouvillian. use_wbm : bool, optional, default = False; Use Weighted Bipartite Matching reordering to make the Liouvillian; diagonally dominant. This is useful for iterative preconditioners; only, and is set to ``True`` by default when finding a preconditioner. weight : float, optional; Sets the size of the elements used for adding the unity trace condition; to the linear solvers. This is set to the average abs value of the; Liouvillian e",MatchSource.WIKI,docs/4.2/modules/qutip/steadystate.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/steadystate.html
https://qutip.org/docs/4.2/modules/qutip/steadystate.html:5390,Energy Efficiency,power,power-gmres,5390,"=[], **kwargs):; """"""Calculates the steady state for quantum evolution subject to the; supplied Hamiltonian or Liouvillian operator and (if given a Hamiltonian) a; list of collapse operators. If the user passes a Hamiltonian then it, along with the list of collapse; operators, will be converted into a Liouvillian operator in Lindblad form. Parameters; ----------; A : qobj; A Hamiltonian or Liouvillian operator. c_op_list : list; A list of collapse operators. method : str {'direct', 'eigen', 'iterative-gmres',; 'iterative-lgmres', 'iterative-bicgstab', 'svd', 'power',; 'power-gmres', 'power-lgmres', 'power-bicgstab'}; Method for solving the underlying linear equation. Direct LU solver; 'direct' (default), sparse eigenvalue problem 'eigen',; iterative GMRES method 'iterative-gmres', iterative LGMRES method; 'iterative-lgmres', iterative BICGSTAB method 'iterative-bicgstab',; SVD 'svd' (dense), or inverse-power method 'power'. The iterative; power methods 'power-gmres', 'power-lgmres', 'power-bicgstab' use; the same solvers as their direct counterparts. return_info : bool, optional, default = False; Return a dictionary of solver-specific infomation about the; solution and how it was obtained. sparse : bool, optional, default = True; Solve for the steady state using sparse algorithms. If set to False,; the underlying Liouvillian operator will be converted into a dense; matrix. Use only for 'smaller' systems. use_rcm : bool, optional, default = False; Use reverse Cuthill-Mckee reordering to minimize fill-in in the; LU factorization of the Liouvillian. use_wbm : bool, optional, default = False; Use Weighted Bipartite Matching reordering to make the Liouvillian; diagonally dominant. This is useful for iterative preconditioners; only, and is set to ``True`` by default when finding a preconditioner. weight : float, optional; Sets the size of the elements used for adding the unity trace condition; to the linear solvers. This is set to the average abs value of the; Liouvillian e",MatchSource.WIKI,docs/4.2/modules/qutip/steadystate.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/steadystate.html
https://qutip.org/docs/4.2/modules/qutip/steadystate.html:5405,Energy Efficiency,power,power-lgmres,5405,"=[], **kwargs):; """"""Calculates the steady state for quantum evolution subject to the; supplied Hamiltonian or Liouvillian operator and (if given a Hamiltonian) a; list of collapse operators. If the user passes a Hamiltonian then it, along with the list of collapse; operators, will be converted into a Liouvillian operator in Lindblad form. Parameters; ----------; A : qobj; A Hamiltonian or Liouvillian operator. c_op_list : list; A list of collapse operators. method : str {'direct', 'eigen', 'iterative-gmres',; 'iterative-lgmres', 'iterative-bicgstab', 'svd', 'power',; 'power-gmres', 'power-lgmres', 'power-bicgstab'}; Method for solving the underlying linear equation. Direct LU solver; 'direct' (default), sparse eigenvalue problem 'eigen',; iterative GMRES method 'iterative-gmres', iterative LGMRES method; 'iterative-lgmres', iterative BICGSTAB method 'iterative-bicgstab',; SVD 'svd' (dense), or inverse-power method 'power'. The iterative; power methods 'power-gmres', 'power-lgmres', 'power-bicgstab' use; the same solvers as their direct counterparts. return_info : bool, optional, default = False; Return a dictionary of solver-specific infomation about the; solution and how it was obtained. sparse : bool, optional, default = True; Solve for the steady state using sparse algorithms. If set to False,; the underlying Liouvillian operator will be converted into a dense; matrix. Use only for 'smaller' systems. use_rcm : bool, optional, default = False; Use reverse Cuthill-Mckee reordering to minimize fill-in in the; LU factorization of the Liouvillian. use_wbm : bool, optional, default = False; Use Weighted Bipartite Matching reordering to make the Liouvillian; diagonally dominant. This is useful for iterative preconditioners; only, and is set to ``True`` by default when finding a preconditioner. weight : float, optional; Sets the size of the elements used for adding the unity trace condition; to the linear solvers. This is set to the average abs value of the; Liouvillian e",MatchSource.WIKI,docs/4.2/modules/qutip/steadystate.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/steadystate.html
https://qutip.org/docs/4.2/modules/qutip/steadystate.html:5421,Energy Efficiency,power,power-bicgstab,5421,"=[], **kwargs):; """"""Calculates the steady state for quantum evolution subject to the; supplied Hamiltonian or Liouvillian operator and (if given a Hamiltonian) a; list of collapse operators. If the user passes a Hamiltonian then it, along with the list of collapse; operators, will be converted into a Liouvillian operator in Lindblad form. Parameters; ----------; A : qobj; A Hamiltonian or Liouvillian operator. c_op_list : list; A list of collapse operators. method : str {'direct', 'eigen', 'iterative-gmres',; 'iterative-lgmres', 'iterative-bicgstab', 'svd', 'power',; 'power-gmres', 'power-lgmres', 'power-bicgstab'}; Method for solving the underlying linear equation. Direct LU solver; 'direct' (default), sparse eigenvalue problem 'eigen',; iterative GMRES method 'iterative-gmres', iterative LGMRES method; 'iterative-lgmres', iterative BICGSTAB method 'iterative-bicgstab',; SVD 'svd' (dense), or inverse-power method 'power'. The iterative; power methods 'power-gmres', 'power-lgmres', 'power-bicgstab' use; the same solvers as their direct counterparts. return_info : bool, optional, default = False; Return a dictionary of solver-specific infomation about the; solution and how it was obtained. sparse : bool, optional, default = True; Solve for the steady state using sparse algorithms. If set to False,; the underlying Liouvillian operator will be converted into a dense; matrix. Use only for 'smaller' systems. use_rcm : bool, optional, default = False; Use reverse Cuthill-Mckee reordering to minimize fill-in in the; LU factorization of the Liouvillian. use_wbm : bool, optional, default = False; Use Weighted Bipartite Matching reordering to make the Liouvillian; diagonally dominant. This is useful for iterative preconditioners; only, and is set to ``True`` by default when finding a preconditioner. weight : float, optional; Sets the size of the elements used for adding the unity trace condition; to the linear solvers. This is set to the average abs value of the; Liouvillian e",MatchSource.WIKI,docs/4.2/modules/qutip/steadystate.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/steadystate.html
https://qutip.org/docs/4.2/modules/qutip/steadystate.html:7981,Energy Efficiency,reduce,reduced,7981," False; ITERATIVE ONLY. Use an incomplete sparse LU decomposition as a; preconditioner for the 'iterative' GMRES and BICG solvers.; Speeds up convergence time by orders of magnitude in many cases. M : {sparse matrix, dense matrix, LinearOperator}, optional; ITERATIVE ONLY. Preconditioner for A. The preconditioner should; approximate the inverse of A. Effective preconditioning can; dramatically improve the rate of convergence for iterative methods.; If no preconditioner is given and ``use_precond = True``, then one; is generated automatically. fill_factor : float, optional, default = 100; ITERATIVE ONLY. Specifies the fill ratio upper bound (>=1) of the iLU; preconditioner. Lower values save memory at the cost of longer; execution times and a possible singular factorization. drop_tol : float, optional, default = 1e-4; ITERATIVE ONLY. Sets the threshold for the magnitude of preconditioner; elements that should be dropped. Can be reduced for a courser; factorization at the cost of an increased number of iterations, and a; possible singular factorization. diag_pivot_thresh : float, optional, default = None; ITERATIVE ONLY. Sets the threshold between [0,1] for which diagonal; elements are considered acceptable pivot points when using a; preconditioner. A value of zero forces the pivot to be the diagonal; element. ILU_MILU : str, optional, default = 'smilu_2'; ITERATIVE ONLY. Selects the incomplete LU decomposition method; algoithm used in creating the preconditoner. Should only be used by; advanced users. Returns; -------; dm : qobj; Steady state density matrix.; info : dict, optional; Dictionary containing solver-specific information about the solution. Notes; -----; The SVD method works only for dense operators (i.e. small systems).; ; """"""; ss_args = _default_steadystate_args(); for key in kwargs.keys():; if key in ss_args.keys():; ss_args[key] = kwargs[key]; else:; raise Exception(; ""Invalid keyword argument '""+key+""' passed to steadystate.""). # Set column perm to NAT",MatchSource.WIKI,docs/4.2/modules/qutip/steadystate.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/steadystate.html
https://qutip.org/docs/4.2/modules/qutip/steadystate.html:9955,Energy Efficiency,power,power,9955," passed to steadystate.""). # Set column perm to NATURAL if using RCM and not specified by user; if ss_args['use_rcm'] and ('permc_spec' not in kwargs.keys()):; ss_args['permc_spec'] = 'NATURAL'. # Create & check Liouvillian; A = _steadystate_setup(A, c_op_list). # Set weight parameter to avg abs val in L if not set explicitly; if 'weight' not in kwargs.keys():; ss_args['info']['weight']; ss_args['weight'] = np.mean(np.abs(A.data.data.max())); ss_args['info']['weight'] = ss_args['weight']. if ss_args['method'] == 'direct':; if ss_args['sparse']:; return _steadystate_direct_sparse(A, ss_args); else:; return _steadystate_direct_dense(A, ss_args). elif ss_args['method'] == 'eigen':; return _steadystate_eigen(A, ss_args). elif ss_args['method'] in ['iterative-gmres',; 'iterative-lgmres', 'iterative-bicgstab']:; return _steadystate_iterative(A, ss_args). elif ss_args['method'] == 'svd':; return _steadystate_svd_dense(A, ss_args). elif ss_args['method'] in ['power', 'power-gmres',; 'power-lgmres', 'power-bicgstab']:; return _steadystate_power(A, ss_args). else:; raise ValueError('Invalid method argument for steadystate.'). def _steadystate_setup(A, c_op_list):; """"""Build Liouvillian (if necessary) and check input.; """"""; if isoper(A):; if len(c_op_list) > 0:; return liouvillian(A, c_op_list). raise TypeError('Cannot calculate the steady state for a ' +; 'non-dissipative system ' +; '(no collapse operators given)'); elif issuper(A):; return A; else:; raise TypeError('Solving for steady states requires ' +; 'Liouvillian (super) operators'). def _steadystate_LU_liouvillian(L, ss_args, has_mkl=0):; """"""Creates modified Liouvillian for LU based SS methods.; """"""; perm = None; perm2 = None; rev_perm = None; n = int(np.sqrt(L.shape[0])); form = 'csr'; if has_mkl:; L = L.data + sp.csr_matrix(; (ss_args['weight']*np.ones(n), (np.zeros(n), [nn * (n + 1); for nn in range(n)])),; shape=(n ** 2, n ** 2)); else:; form = 'csc'; L = L.data.tocsc() + sp.csc_matrix(; (ss_args['weight']*np.ones(n",MatchSource.WIKI,docs/4.2/modules/qutip/steadystate.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/steadystate.html
https://qutip.org/docs/4.2/modules/qutip/steadystate.html:9964,Energy Efficiency,power,power-gmres,9964," passed to steadystate.""). # Set column perm to NATURAL if using RCM and not specified by user; if ss_args['use_rcm'] and ('permc_spec' not in kwargs.keys()):; ss_args['permc_spec'] = 'NATURAL'. # Create & check Liouvillian; A = _steadystate_setup(A, c_op_list). # Set weight parameter to avg abs val in L if not set explicitly; if 'weight' not in kwargs.keys():; ss_args['info']['weight']; ss_args['weight'] = np.mean(np.abs(A.data.data.max())); ss_args['info']['weight'] = ss_args['weight']. if ss_args['method'] == 'direct':; if ss_args['sparse']:; return _steadystate_direct_sparse(A, ss_args); else:; return _steadystate_direct_dense(A, ss_args). elif ss_args['method'] == 'eigen':; return _steadystate_eigen(A, ss_args). elif ss_args['method'] in ['iterative-gmres',; 'iterative-lgmres', 'iterative-bicgstab']:; return _steadystate_iterative(A, ss_args). elif ss_args['method'] == 'svd':; return _steadystate_svd_dense(A, ss_args). elif ss_args['method'] in ['power', 'power-gmres',; 'power-lgmres', 'power-bicgstab']:; return _steadystate_power(A, ss_args). else:; raise ValueError('Invalid method argument for steadystate.'). def _steadystate_setup(A, c_op_list):; """"""Build Liouvillian (if necessary) and check input.; """"""; if isoper(A):; if len(c_op_list) > 0:; return liouvillian(A, c_op_list). raise TypeError('Cannot calculate the steady state for a ' +; 'non-dissipative system ' +; '(no collapse operators given)'); elif issuper(A):; return A; else:; raise TypeError('Solving for steady states requires ' +; 'Liouvillian (super) operators'). def _steadystate_LU_liouvillian(L, ss_args, has_mkl=0):; """"""Creates modified Liouvillian for LU based SS methods.; """"""; perm = None; perm2 = None; rev_perm = None; n = int(np.sqrt(L.shape[0])); form = 'csr'; if has_mkl:; L = L.data + sp.csr_matrix(; (ss_args['weight']*np.ones(n), (np.zeros(n), [nn * (n + 1); for nn in range(n)])),; shape=(n ** 2, n ** 2)); else:; form = 'csc'; L = L.data.tocsc() + sp.csc_matrix(; (ss_args['weight']*np.ones(n",MatchSource.WIKI,docs/4.2/modules/qutip/steadystate.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/steadystate.html
https://qutip.org/docs/4.2/modules/qutip/steadystate.html:9980,Energy Efficiency,power,power-lgmres,9980," passed to steadystate.""). # Set column perm to NATURAL if using RCM and not specified by user; if ss_args['use_rcm'] and ('permc_spec' not in kwargs.keys()):; ss_args['permc_spec'] = 'NATURAL'. # Create & check Liouvillian; A = _steadystate_setup(A, c_op_list). # Set weight parameter to avg abs val in L if not set explicitly; if 'weight' not in kwargs.keys():; ss_args['info']['weight']; ss_args['weight'] = np.mean(np.abs(A.data.data.max())); ss_args['info']['weight'] = ss_args['weight']. if ss_args['method'] == 'direct':; if ss_args['sparse']:; return _steadystate_direct_sparse(A, ss_args); else:; return _steadystate_direct_dense(A, ss_args). elif ss_args['method'] == 'eigen':; return _steadystate_eigen(A, ss_args). elif ss_args['method'] in ['iterative-gmres',; 'iterative-lgmres', 'iterative-bicgstab']:; return _steadystate_iterative(A, ss_args). elif ss_args['method'] == 'svd':; return _steadystate_svd_dense(A, ss_args). elif ss_args['method'] in ['power', 'power-gmres',; 'power-lgmres', 'power-bicgstab']:; return _steadystate_power(A, ss_args). else:; raise ValueError('Invalid method argument for steadystate.'). def _steadystate_setup(A, c_op_list):; """"""Build Liouvillian (if necessary) and check input.; """"""; if isoper(A):; if len(c_op_list) > 0:; return liouvillian(A, c_op_list). raise TypeError('Cannot calculate the steady state for a ' +; 'non-dissipative system ' +; '(no collapse operators given)'); elif issuper(A):; return A; else:; raise TypeError('Solving for steady states requires ' +; 'Liouvillian (super) operators'). def _steadystate_LU_liouvillian(L, ss_args, has_mkl=0):; """"""Creates modified Liouvillian for LU based SS methods.; """"""; perm = None; perm2 = None; rev_perm = None; n = int(np.sqrt(L.shape[0])); form = 'csr'; if has_mkl:; L = L.data + sp.csr_matrix(; (ss_args['weight']*np.ones(n), (np.zeros(n), [nn * (n + 1); for nn in range(n)])),; shape=(n ** 2, n ** 2)); else:; form = 'csc'; L = L.data.tocsc() + sp.csc_matrix(; (ss_args['weight']*np.ones(n",MatchSource.WIKI,docs/4.2/modules/qutip/steadystate.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/steadystate.html
https://qutip.org/docs/4.2/modules/qutip/steadystate.html:9996,Energy Efficiency,power,power-bicgstab,9996," passed to steadystate.""). # Set column perm to NATURAL if using RCM and not specified by user; if ss_args['use_rcm'] and ('permc_spec' not in kwargs.keys()):; ss_args['permc_spec'] = 'NATURAL'. # Create & check Liouvillian; A = _steadystate_setup(A, c_op_list). # Set weight parameter to avg abs val in L if not set explicitly; if 'weight' not in kwargs.keys():; ss_args['info']['weight']; ss_args['weight'] = np.mean(np.abs(A.data.data.max())); ss_args['info']['weight'] = ss_args['weight']. if ss_args['method'] == 'direct':; if ss_args['sparse']:; return _steadystate_direct_sparse(A, ss_args); else:; return _steadystate_direct_dense(A, ss_args). elif ss_args['method'] == 'eigen':; return _steadystate_eigen(A, ss_args). elif ss_args['method'] in ['iterative-gmres',; 'iterative-lgmres', 'iterative-bicgstab']:; return _steadystate_iterative(A, ss_args). elif ss_args['method'] == 'svd':; return _steadystate_svd_dense(A, ss_args). elif ss_args['method'] in ['power', 'power-gmres',; 'power-lgmres', 'power-bicgstab']:; return _steadystate_power(A, ss_args). else:; raise ValueError('Invalid method argument for steadystate.'). def _steadystate_setup(A, c_op_list):; """"""Build Liouvillian (if necessary) and check input.; """"""; if isoper(A):; if len(c_op_list) > 0:; return liouvillian(A, c_op_list). raise TypeError('Cannot calculate the steady state for a ' +; 'non-dissipative system ' +; '(no collapse operators given)'); elif issuper(A):; return A; else:; raise TypeError('Solving for steady states requires ' +; 'Liouvillian (super) operators'). def _steadystate_LU_liouvillian(L, ss_args, has_mkl=0):; """"""Creates modified Liouvillian for LU based SS methods.; """"""; perm = None; perm2 = None; rev_perm = None; n = int(np.sqrt(L.shape[0])); form = 'csr'; if has_mkl:; L = L.data + sp.csr_matrix(; (ss_args['weight']*np.ones(n), (np.zeros(n), [nn * (n + 1); for nn in range(n)])),; shape=(n ** 2, n ** 2)); else:; form = 'csc'; L = L.data.tocsc() + sp.csc_matrix(; (ss_args['weight']*np.ones(n",MatchSource.WIKI,docs/4.2/modules/qutip/steadystate.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/steadystate.html
https://qutip.org/docs/4.2/modules/qutip/steadystate.html:22284,Energy Efficiency,power,power,22284,"a, dims=dims, isherm=True). def _steadystate_svd_dense(L, ss_args):; """"""; Find the steady state(s) of an open quantum system by solving for the; nullspace of the Liouvillian.; """"""; ss_args['info'].pop('weight', None); atol = 1e-12; rtol = 1e-12; if settings.debug:; logger.debug('Starting SVD solver.'); _svd_start = time.time(); u, s, vh = svd(L.full(), full_matrices=False); tol = max(atol, rtol * s[0]); nnz = (s >= tol).sum(); ns = vh[nnz:].conj().T; _svd_end = time.time(); ss_args['info']['solution_time'] = _svd_end-_svd_start; if ss_args['all_states']:; rhoss_list = []; for n in range(ns.shape[1]):; rhoss = Qobj(vec2mat(ns[:, n]), dims=L.dims[0]); rhoss_list.append(rhoss / rhoss.tr()); if ss_args['return_info']:; return rhoss_list, ss_args['info']; else:; if ss_args['return_info']:; return rhoss_list, ss_args['info']; else:; return rhoss_list; else:; rhoss = Qobj(vec2mat(ns[:, 0]), dims=L.dims[0]); return rhoss / rhoss.tr(). def _steadystate_power_liouvillian(L, ss_args, has_mkl=0):; """"""Creates modified Liouvillian for power based SS methods.; """"""; perm = None; perm2 = None; rev_perm = None; n = L.shape[0]; if has_mkl:; L = L.data - (1e-15) * sp.eye(n, n, format='csr'); kind = 'csr'; else:; L = L.data.tocsc() - (1e-15) * sp.eye(n, n, format='csc'); kind = 'csc'; orig_nnz = L.nnz; if settings.debug:; old_band = sp_bandwidth(L)[0]; old_pro = sp_profile(L)[0]; logger.debug('Original bandwidth: %i' % old_band); logger.debug('Original profile: %i' % old_pro); ; if ss_args['use_wbm']:; if settings.debug:; logger.debug('Calculating Weighted Bipartite Matching ordering...'); _wbm_start = time.time(); perm = weighted_bipartite_matching(L); _wbm_end = time.time(); L = sp_permute(L, perm, [], kind); ss_args['info']['perm'].append('wbm'); ss_args['info']['wbm_time'] = _wbm_end-_wbm_start; if settings.debug:; wbm_band = sp_bandwidth(L)[0]; wbm_pro = sp_profile(L)[0]; logger.debug('WBM bandwidth: %i' % wbm_band); logger.debug('WBM profile: %i' % wbm_pro); ; if ss_args['use_rcm'",MatchSource.WIKI,docs/4.2/modules/qutip/steadystate.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/steadystate.html
https://qutip.org/docs/4.2/modules/qutip/steadystate.html:23993,Energy Efficiency,power,power,23993,"rm'].append('wbm'); ss_args['info']['wbm_time'] = _wbm_end-_wbm_start; if settings.debug:; wbm_band = sp_bandwidth(L)[0]; wbm_pro = sp_profile(L)[0]; logger.debug('WBM bandwidth: %i' % wbm_band); logger.debug('WBM profile: %i' % wbm_pro); ; if ss_args['use_rcm']:; if settings.debug:; logger.debug('Calculating Reverse Cuthill-Mckee ordering...'); ss_args['info']['perm'].append('rcm'); _rcm_start = time.time(); perm2 = reverse_cuthill_mckee(L); _rcm_end = time.time(); ss_args['info']['rcm_time'] = _rcm_end-_rcm_start; rev_perm = np.argsort(perm2); L = sp_permute(L, perm2, perm2, kind); if settings.debug:; new_band = sp_bandwidth(L)[0]; new_pro = sp_profile(L)[0]; logger.debug('RCM bandwidth: %i' % new_band); logger.debug('Bandwidth reduction factor: %f' % (old_band/new_band)); logger.debug('RCM profile: %i' % new_pro); logger.debug('Profile reduction factor: %f' % (old_pro/new_pro)); L.sort_indices(); return L, perm, perm2, rev_perm, ss_args; . def _steadystate_power(L, ss_args):; """"""; Inverse power method for steady state solving.; """"""; ss_args['info'].pop('weight', None); if settings.debug:; logger.debug('Starting iterative inverse-power method solver.'); tol = ss_args['tol']; maxiter = ss_args['maxiter']. use_solver(assumeSortedIndices=True); rhoss = Qobj(); sflag = issuper(L); if sflag:; rhoss.dims = L.dims[0]; else:; rhoss.dims = [L.dims[0], 1]; n = L.shape[0]; # Build Liouvillian; if settings.has_mkl and ss_args['method'] == 'power':; has_mkl = 1; else:; has_mkl = 0; L, perm, perm2, rev_perm, ss_args = _steadystate_power_liouvillian(L, ; ss_args, has_mkl); orig_nnz = L.nnz; # start with all ones as RHS; v = np.ones(n, dtype=complex); if ss_args['use_rcm']:; v = v[np.ix_(perm2,)]; ; # Do preconditioning; if ss_args['M'] is None and ss_args['use_precond'] and \; ss_args['method'] in ['power-gmres', ; 'power-lgmres', 'power-bicgstab']:; ss_args['M'], ss_args = _iterative_precondition(L, int(np.sqrt(n)), ss_args); if ss_args['M'] is None:; warnings.warn(""Precondition",MatchSource.WIKI,docs/4.2/modules/qutip/steadystate.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/steadystate.html
https://qutip.org/docs/4.2/modules/qutip/steadystate.html:24136,Energy Efficiency,power,power,24136,"L)[0]; logger.debug('WBM bandwidth: %i' % wbm_band); logger.debug('WBM profile: %i' % wbm_pro); ; if ss_args['use_rcm']:; if settings.debug:; logger.debug('Calculating Reverse Cuthill-Mckee ordering...'); ss_args['info']['perm'].append('rcm'); _rcm_start = time.time(); perm2 = reverse_cuthill_mckee(L); _rcm_end = time.time(); ss_args['info']['rcm_time'] = _rcm_end-_rcm_start; rev_perm = np.argsort(perm2); L = sp_permute(L, perm2, perm2, kind); if settings.debug:; new_band = sp_bandwidth(L)[0]; new_pro = sp_profile(L)[0]; logger.debug('RCM bandwidth: %i' % new_band); logger.debug('Bandwidth reduction factor: %f' % (old_band/new_band)); logger.debug('RCM profile: %i' % new_pro); logger.debug('Profile reduction factor: %f' % (old_pro/new_pro)); L.sort_indices(); return L, perm, perm2, rev_perm, ss_args; . def _steadystate_power(L, ss_args):; """"""; Inverse power method for steady state solving.; """"""; ss_args['info'].pop('weight', None); if settings.debug:; logger.debug('Starting iterative inverse-power method solver.'); tol = ss_args['tol']; maxiter = ss_args['maxiter']. use_solver(assumeSortedIndices=True); rhoss = Qobj(); sflag = issuper(L); if sflag:; rhoss.dims = L.dims[0]; else:; rhoss.dims = [L.dims[0], 1]; n = L.shape[0]; # Build Liouvillian; if settings.has_mkl and ss_args['method'] == 'power':; has_mkl = 1; else:; has_mkl = 0; L, perm, perm2, rev_perm, ss_args = _steadystate_power_liouvillian(L, ; ss_args, has_mkl); orig_nnz = L.nnz; # start with all ones as RHS; v = np.ones(n, dtype=complex); if ss_args['use_rcm']:; v = v[np.ix_(perm2,)]; ; # Do preconditioning; if ss_args['M'] is None and ss_args['use_precond'] and \; ss_args['method'] in ['power-gmres', ; 'power-lgmres', 'power-bicgstab']:; ss_args['M'], ss_args = _iterative_precondition(L, int(np.sqrt(n)), ss_args); if ss_args['M'] is None:; warnings.warn(""Preconditioning failed. Continuing without."",; UserWarning); ; ss_iters = {'iter': 0}. def _iter_count(r):; ss_iters['iter'] += 1; return; ; _power_start ",MatchSource.WIKI,docs/4.2/modules/qutip/steadystate.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/steadystate.html
https://qutip.org/docs/4.2/modules/qutip/steadystate.html:24440,Energy Efficiency,power,power,24440,"_rcm_start; rev_perm = np.argsort(perm2); L = sp_permute(L, perm2, perm2, kind); if settings.debug:; new_band = sp_bandwidth(L)[0]; new_pro = sp_profile(L)[0]; logger.debug('RCM bandwidth: %i' % new_band); logger.debug('Bandwidth reduction factor: %f' % (old_band/new_band)); logger.debug('RCM profile: %i' % new_pro); logger.debug('Profile reduction factor: %f' % (old_pro/new_pro)); L.sort_indices(); return L, perm, perm2, rev_perm, ss_args; . def _steadystate_power(L, ss_args):; """"""; Inverse power method for steady state solving.; """"""; ss_args['info'].pop('weight', None); if settings.debug:; logger.debug('Starting iterative inverse-power method solver.'); tol = ss_args['tol']; maxiter = ss_args['maxiter']. use_solver(assumeSortedIndices=True); rhoss = Qobj(); sflag = issuper(L); if sflag:; rhoss.dims = L.dims[0]; else:; rhoss.dims = [L.dims[0], 1]; n = L.shape[0]; # Build Liouvillian; if settings.has_mkl and ss_args['method'] == 'power':; has_mkl = 1; else:; has_mkl = 0; L, perm, perm2, rev_perm, ss_args = _steadystate_power_liouvillian(L, ; ss_args, has_mkl); orig_nnz = L.nnz; # start with all ones as RHS; v = np.ones(n, dtype=complex); if ss_args['use_rcm']:; v = v[np.ix_(perm2,)]; ; # Do preconditioning; if ss_args['M'] is None and ss_args['use_precond'] and \; ss_args['method'] in ['power-gmres', ; 'power-lgmres', 'power-bicgstab']:; ss_args['M'], ss_args = _iterative_precondition(L, int(np.sqrt(n)), ss_args); if ss_args['M'] is None:; warnings.warn(""Preconditioning failed. Continuing without."",; UserWarning); ; ss_iters = {'iter': 0}. def _iter_count(r):; ss_iters['iter'] += 1; return; ; _power_start = time.time(); # Get LU factors; if ss_args['method'] == 'power':; if settings.has_mkl:; lu = mkl_splu(L); else: ; lu = splu(L, permc_spec=ss_args['permc_spec'],; diag_pivot_thresh=ss_args['diag_pivot_thresh'],; options=dict(ILU_MILU=ss_args['ILU_MILU'])). if settings.debug and _scipy_check:; L_nnz = lu.L.nnz; U_nnz = lu.U.nnz; logger.debug('L NNZ: %i ; U NNZ: %i' ",MatchSource.WIKI,docs/4.2/modules/qutip/steadystate.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/steadystate.html
https://qutip.org/docs/4.2/modules/qutip/steadystate.html:24804,Energy Efficiency,power,power-gmres,24804,"%i' % new_pro); logger.debug('Profile reduction factor: %f' % (old_pro/new_pro)); L.sort_indices(); return L, perm, perm2, rev_perm, ss_args; . def _steadystate_power(L, ss_args):; """"""; Inverse power method for steady state solving.; """"""; ss_args['info'].pop('weight', None); if settings.debug:; logger.debug('Starting iterative inverse-power method solver.'); tol = ss_args['tol']; maxiter = ss_args['maxiter']. use_solver(assumeSortedIndices=True); rhoss = Qobj(); sflag = issuper(L); if sflag:; rhoss.dims = L.dims[0]; else:; rhoss.dims = [L.dims[0], 1]; n = L.shape[0]; # Build Liouvillian; if settings.has_mkl and ss_args['method'] == 'power':; has_mkl = 1; else:; has_mkl = 0; L, perm, perm2, rev_perm, ss_args = _steadystate_power_liouvillian(L, ; ss_args, has_mkl); orig_nnz = L.nnz; # start with all ones as RHS; v = np.ones(n, dtype=complex); if ss_args['use_rcm']:; v = v[np.ix_(perm2,)]; ; # Do preconditioning; if ss_args['M'] is None and ss_args['use_precond'] and \; ss_args['method'] in ['power-gmres', ; 'power-lgmres', 'power-bicgstab']:; ss_args['M'], ss_args = _iterative_precondition(L, int(np.sqrt(n)), ss_args); if ss_args['M'] is None:; warnings.warn(""Preconditioning failed. Continuing without."",; UserWarning); ; ss_iters = {'iter': 0}. def _iter_count(r):; ss_iters['iter'] += 1; return; ; _power_start = time.time(); # Get LU factors; if ss_args['method'] == 'power':; if settings.has_mkl:; lu = mkl_splu(L); else: ; lu = splu(L, permc_spec=ss_args['permc_spec'],; diag_pivot_thresh=ss_args['diag_pivot_thresh'],; options=dict(ILU_MILU=ss_args['ILU_MILU'])). if settings.debug and _scipy_check:; L_nnz = lu.L.nnz; U_nnz = lu.U.nnz; logger.debug('L NNZ: %i ; U NNZ: %i' % (L_nnz, U_nnz)); logger.debug('Fill factor: %f' % ((L_nnz+U_nnz)/orig_nnz)). it = 0; _tol = max(ss_args['tol']/10, 1e-15) # Should make this user accessible; while (la.norm(L * v, np.inf) > tol) and (it < maxiter):; ; if ss_args['method'] == 'power':; v = lu.solve(v); elif ss_args['method'] == 'power-",MatchSource.WIKI,docs/4.2/modules/qutip/steadystate.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/steadystate.html
https://qutip.org/docs/4.2/modules/qutip/steadystate.html:24821,Energy Efficiency,power,power-lgmres,24821,"%i' % new_pro); logger.debug('Profile reduction factor: %f' % (old_pro/new_pro)); L.sort_indices(); return L, perm, perm2, rev_perm, ss_args; . def _steadystate_power(L, ss_args):; """"""; Inverse power method for steady state solving.; """"""; ss_args['info'].pop('weight', None); if settings.debug:; logger.debug('Starting iterative inverse-power method solver.'); tol = ss_args['tol']; maxiter = ss_args['maxiter']. use_solver(assumeSortedIndices=True); rhoss = Qobj(); sflag = issuper(L); if sflag:; rhoss.dims = L.dims[0]; else:; rhoss.dims = [L.dims[0], 1]; n = L.shape[0]; # Build Liouvillian; if settings.has_mkl and ss_args['method'] == 'power':; has_mkl = 1; else:; has_mkl = 0; L, perm, perm2, rev_perm, ss_args = _steadystate_power_liouvillian(L, ; ss_args, has_mkl); orig_nnz = L.nnz; # start with all ones as RHS; v = np.ones(n, dtype=complex); if ss_args['use_rcm']:; v = v[np.ix_(perm2,)]; ; # Do preconditioning; if ss_args['M'] is None and ss_args['use_precond'] and \; ss_args['method'] in ['power-gmres', ; 'power-lgmres', 'power-bicgstab']:; ss_args['M'], ss_args = _iterative_precondition(L, int(np.sqrt(n)), ss_args); if ss_args['M'] is None:; warnings.warn(""Preconditioning failed. Continuing without."",; UserWarning); ; ss_iters = {'iter': 0}. def _iter_count(r):; ss_iters['iter'] += 1; return; ; _power_start = time.time(); # Get LU factors; if ss_args['method'] == 'power':; if settings.has_mkl:; lu = mkl_splu(L); else: ; lu = splu(L, permc_spec=ss_args['permc_spec'],; diag_pivot_thresh=ss_args['diag_pivot_thresh'],; options=dict(ILU_MILU=ss_args['ILU_MILU'])). if settings.debug and _scipy_check:; L_nnz = lu.L.nnz; U_nnz = lu.U.nnz; logger.debug('L NNZ: %i ; U NNZ: %i' % (L_nnz, U_nnz)); logger.debug('Fill factor: %f' % ((L_nnz+U_nnz)/orig_nnz)). it = 0; _tol = max(ss_args['tol']/10, 1e-15) # Should make this user accessible; while (la.norm(L * v, np.inf) > tol) and (it < maxiter):; ; if ss_args['method'] == 'power':; v = lu.solve(v); elif ss_args['method'] == 'power-",MatchSource.WIKI,docs/4.2/modules/qutip/steadystate.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/steadystate.html
https://qutip.org/docs/4.2/modules/qutip/steadystate.html:24837,Energy Efficiency,power,power-bicgstab,24837,"%i' % new_pro); logger.debug('Profile reduction factor: %f' % (old_pro/new_pro)); L.sort_indices(); return L, perm, perm2, rev_perm, ss_args; . def _steadystate_power(L, ss_args):; """"""; Inverse power method for steady state solving.; """"""; ss_args['info'].pop('weight', None); if settings.debug:; logger.debug('Starting iterative inverse-power method solver.'); tol = ss_args['tol']; maxiter = ss_args['maxiter']. use_solver(assumeSortedIndices=True); rhoss = Qobj(); sflag = issuper(L); if sflag:; rhoss.dims = L.dims[0]; else:; rhoss.dims = [L.dims[0], 1]; n = L.shape[0]; # Build Liouvillian; if settings.has_mkl and ss_args['method'] == 'power':; has_mkl = 1; else:; has_mkl = 0; L, perm, perm2, rev_perm, ss_args = _steadystate_power_liouvillian(L, ; ss_args, has_mkl); orig_nnz = L.nnz; # start with all ones as RHS; v = np.ones(n, dtype=complex); if ss_args['use_rcm']:; v = v[np.ix_(perm2,)]; ; # Do preconditioning; if ss_args['M'] is None and ss_args['use_precond'] and \; ss_args['method'] in ['power-gmres', ; 'power-lgmres', 'power-bicgstab']:; ss_args['M'], ss_args = _iterative_precondition(L, int(np.sqrt(n)), ss_args); if ss_args['M'] is None:; warnings.warn(""Preconditioning failed. Continuing without."",; UserWarning); ; ss_iters = {'iter': 0}. def _iter_count(r):; ss_iters['iter'] += 1; return; ; _power_start = time.time(); # Get LU factors; if ss_args['method'] == 'power':; if settings.has_mkl:; lu = mkl_splu(L); else: ; lu = splu(L, permc_spec=ss_args['permc_spec'],; diag_pivot_thresh=ss_args['diag_pivot_thresh'],; options=dict(ILU_MILU=ss_args['ILU_MILU'])). if settings.debug and _scipy_check:; L_nnz = lu.L.nnz; U_nnz = lu.U.nnz; logger.debug('L NNZ: %i ; U NNZ: %i' % (L_nnz, U_nnz)); logger.debug('Fill factor: %f' % ((L_nnz+U_nnz)/orig_nnz)). it = 0; _tol = max(ss_args['tol']/10, 1e-15) # Should make this user accessible; while (la.norm(L * v, np.inf) > tol) and (it < maxiter):; ; if ss_args['method'] == 'power':; v = lu.solve(v); elif ss_args['method'] == 'power-",MatchSource.WIKI,docs/4.2/modules/qutip/steadystate.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/steadystate.html
https://qutip.org/docs/4.2/modules/qutip/steadystate.html:25187,Energy Efficiency,power,power,25187,"s['tol']; maxiter = ss_args['maxiter']. use_solver(assumeSortedIndices=True); rhoss = Qobj(); sflag = issuper(L); if sflag:; rhoss.dims = L.dims[0]; else:; rhoss.dims = [L.dims[0], 1]; n = L.shape[0]; # Build Liouvillian; if settings.has_mkl and ss_args['method'] == 'power':; has_mkl = 1; else:; has_mkl = 0; L, perm, perm2, rev_perm, ss_args = _steadystate_power_liouvillian(L, ; ss_args, has_mkl); orig_nnz = L.nnz; # start with all ones as RHS; v = np.ones(n, dtype=complex); if ss_args['use_rcm']:; v = v[np.ix_(perm2,)]; ; # Do preconditioning; if ss_args['M'] is None and ss_args['use_precond'] and \; ss_args['method'] in ['power-gmres', ; 'power-lgmres', 'power-bicgstab']:; ss_args['M'], ss_args = _iterative_precondition(L, int(np.sqrt(n)), ss_args); if ss_args['M'] is None:; warnings.warn(""Preconditioning failed. Continuing without."",; UserWarning); ; ss_iters = {'iter': 0}. def _iter_count(r):; ss_iters['iter'] += 1; return; ; _power_start = time.time(); # Get LU factors; if ss_args['method'] == 'power':; if settings.has_mkl:; lu = mkl_splu(L); else: ; lu = splu(L, permc_spec=ss_args['permc_spec'],; diag_pivot_thresh=ss_args['diag_pivot_thresh'],; options=dict(ILU_MILU=ss_args['ILU_MILU'])). if settings.debug and _scipy_check:; L_nnz = lu.L.nnz; U_nnz = lu.U.nnz; logger.debug('L NNZ: %i ; U NNZ: %i' % (L_nnz, U_nnz)); logger.debug('Fill factor: %f' % ((L_nnz+U_nnz)/orig_nnz)). it = 0; _tol = max(ss_args['tol']/10, 1e-15) # Should make this user accessible; while (la.norm(L * v, np.inf) > tol) and (it < maxiter):; ; if ss_args['method'] == 'power':; v = lu.solve(v); elif ss_args['method'] == 'power-gmres':; v, check = gmres(L, v, tol=_tol, M=ss_args['M'],; x0=ss_args['x0'], restart=ss_args['restart'],; maxiter=ss_args['maxiter'], callback=_iter_count); elif ss_args['method'] == 'power-lgmres':; v, check = lgmres(L, v, tol=_tol, M=ss_args['M'],; x0=ss_args['x0'], maxiter=ss_args['maxiter'],; callback=_iter_count); elif ss_args['method'] == 'power-bicgstab':; v, che",MatchSource.WIKI,docs/4.2/modules/qutip/steadystate.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/steadystate.html
https://qutip.org/docs/4.2/modules/qutip/steadystate.html:25741,Energy Efficiency,power,power,25741,"ng; if ss_args['M'] is None and ss_args['use_precond'] and \; ss_args['method'] in ['power-gmres', ; 'power-lgmres', 'power-bicgstab']:; ss_args['M'], ss_args = _iterative_precondition(L, int(np.sqrt(n)), ss_args); if ss_args['M'] is None:; warnings.warn(""Preconditioning failed. Continuing without."",; UserWarning); ; ss_iters = {'iter': 0}. def _iter_count(r):; ss_iters['iter'] += 1; return; ; _power_start = time.time(); # Get LU factors; if ss_args['method'] == 'power':; if settings.has_mkl:; lu = mkl_splu(L); else: ; lu = splu(L, permc_spec=ss_args['permc_spec'],; diag_pivot_thresh=ss_args['diag_pivot_thresh'],; options=dict(ILU_MILU=ss_args['ILU_MILU'])). if settings.debug and _scipy_check:; L_nnz = lu.L.nnz; U_nnz = lu.U.nnz; logger.debug('L NNZ: %i ; U NNZ: %i' % (L_nnz, U_nnz)); logger.debug('Fill factor: %f' % ((L_nnz+U_nnz)/orig_nnz)). it = 0; _tol = max(ss_args['tol']/10, 1e-15) # Should make this user accessible; while (la.norm(L * v, np.inf) > tol) and (it < maxiter):; ; if ss_args['method'] == 'power':; v = lu.solve(v); elif ss_args['method'] == 'power-gmres':; v, check = gmres(L, v, tol=_tol, M=ss_args['M'],; x0=ss_args['x0'], restart=ss_args['restart'],; maxiter=ss_args['maxiter'], callback=_iter_count); elif ss_args['method'] == 'power-lgmres':; v, check = lgmres(L, v, tol=_tol, M=ss_args['M'],; x0=ss_args['x0'], maxiter=ss_args['maxiter'],; callback=_iter_count); elif ss_args['method'] == 'power-bicgstab':; v, check = bicgstab(L, v, tol=_tol, M=ss_args['M'],; x0=ss_args['x0'],; maxiter=ss_args['maxiter'], callback=_iter_count); else:; raise Exception(""Invalid iterative solver method.""); ; v = v / la.norm(v, np.inf); it += 1; if ss_args['method'] == 'power' and settings.has_mkl:; lu.delete(); if it >= maxiter:; raise Exception('Failed to find steady state after ' +; str(maxiter) + ' iterations'); _power_end = time.time(); ss_args['info']['solution_time'] = _power_end-_power_start; ss_args['info']['iterations'] = it; if ss_args['return_info']:; ss_args",MatchSource.WIKI,docs/4.2/modules/qutip/steadystate.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/steadystate.html
https://qutip.org/docs/4.2/modules/qutip/steadystate.html:25794,Energy Efficiency,power,power-gmres,25794,"iter': 0}. def _iter_count(r):; ss_iters['iter'] += 1; return; ; _power_start = time.time(); # Get LU factors; if ss_args['method'] == 'power':; if settings.has_mkl:; lu = mkl_splu(L); else: ; lu = splu(L, permc_spec=ss_args['permc_spec'],; diag_pivot_thresh=ss_args['diag_pivot_thresh'],; options=dict(ILU_MILU=ss_args['ILU_MILU'])). if settings.debug and _scipy_check:; L_nnz = lu.L.nnz; U_nnz = lu.U.nnz; logger.debug('L NNZ: %i ; U NNZ: %i' % (L_nnz, U_nnz)); logger.debug('Fill factor: %f' % ((L_nnz+U_nnz)/orig_nnz)). it = 0; _tol = max(ss_args['tol']/10, 1e-15) # Should make this user accessible; while (la.norm(L * v, np.inf) > tol) and (it < maxiter):; ; if ss_args['method'] == 'power':; v = lu.solve(v); elif ss_args['method'] == 'power-gmres':; v, check = gmres(L, v, tol=_tol, M=ss_args['M'],; x0=ss_args['x0'], restart=ss_args['restart'],; maxiter=ss_args['maxiter'], callback=_iter_count); elif ss_args['method'] == 'power-lgmres':; v, check = lgmres(L, v, tol=_tol, M=ss_args['M'],; x0=ss_args['x0'], maxiter=ss_args['maxiter'],; callback=_iter_count); elif ss_args['method'] == 'power-bicgstab':; v, check = bicgstab(L, v, tol=_tol, M=ss_args['M'],; x0=ss_args['x0'],; maxiter=ss_args['maxiter'], callback=_iter_count); else:; raise Exception(""Invalid iterative solver method.""); ; v = v / la.norm(v, np.inf); it += 1; if ss_args['method'] == 'power' and settings.has_mkl:; lu.delete(); if it >= maxiter:; raise Exception('Failed to find steady state after ' +; str(maxiter) + ' iterations'); _power_end = time.time(); ss_args['info']['solution_time'] = _power_end-_power_start; ss_args['info']['iterations'] = it; if ss_args['return_info']:; ss_args['info']['residual_norm'] = la.norm(L*v); if settings.debug:; logger.debug('Number of iterations: %i' % it). if ss_args['use_rcm']:; v = v[np.ix_(rev_perm,)]. # normalise according to type of problem; if sflag:; trow = v[::rhoss.shape[0]+1]; data = v / np.sum(trow); else:; data = data / la.norm(v). data = dense2D_to_fastcsr_fmode(",MatchSource.WIKI,docs/4.2/modules/qutip/steadystate.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/steadystate.html
https://qutip.org/docs/4.2/modules/qutip/steadystate.html:25984,Energy Efficiency,power,power-lgmres,25984,"iter': 0}. def _iter_count(r):; ss_iters['iter'] += 1; return; ; _power_start = time.time(); # Get LU factors; if ss_args['method'] == 'power':; if settings.has_mkl:; lu = mkl_splu(L); else: ; lu = splu(L, permc_spec=ss_args['permc_spec'],; diag_pivot_thresh=ss_args['diag_pivot_thresh'],; options=dict(ILU_MILU=ss_args['ILU_MILU'])). if settings.debug and _scipy_check:; L_nnz = lu.L.nnz; U_nnz = lu.U.nnz; logger.debug('L NNZ: %i ; U NNZ: %i' % (L_nnz, U_nnz)); logger.debug('Fill factor: %f' % ((L_nnz+U_nnz)/orig_nnz)). it = 0; _tol = max(ss_args['tol']/10, 1e-15) # Should make this user accessible; while (la.norm(L * v, np.inf) > tol) and (it < maxiter):; ; if ss_args['method'] == 'power':; v = lu.solve(v); elif ss_args['method'] == 'power-gmres':; v, check = gmres(L, v, tol=_tol, M=ss_args['M'],; x0=ss_args['x0'], restart=ss_args['restart'],; maxiter=ss_args['maxiter'], callback=_iter_count); elif ss_args['method'] == 'power-lgmres':; v, check = lgmres(L, v, tol=_tol, M=ss_args['M'],; x0=ss_args['x0'], maxiter=ss_args['maxiter'],; callback=_iter_count); elif ss_args['method'] == 'power-bicgstab':; v, check = bicgstab(L, v, tol=_tol, M=ss_args['M'],; x0=ss_args['x0'],; maxiter=ss_args['maxiter'], callback=_iter_count); else:; raise Exception(""Invalid iterative solver method.""); ; v = v / la.norm(v, np.inf); it += 1; if ss_args['method'] == 'power' and settings.has_mkl:; lu.delete(); if it >= maxiter:; raise Exception('Failed to find steady state after ' +; str(maxiter) + ' iterations'); _power_end = time.time(); ss_args['info']['solution_time'] = _power_end-_power_start; ss_args['info']['iterations'] = it; if ss_args['return_info']:; ss_args['info']['residual_norm'] = la.norm(L*v); if settings.debug:; logger.debug('Number of iterations: %i' % it). if ss_args['use_rcm']:; v = v[np.ix_(rev_perm,)]. # normalise according to type of problem; if sflag:; trow = v[::rhoss.shape[0]+1]; data = v / np.sum(trow); else:; data = data / la.norm(v). data = dense2D_to_fastcsr_fmode(",MatchSource.WIKI,docs/4.2/modules/qutip/steadystate.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/steadystate.html
https://qutip.org/docs/4.2/modules/qutip/steadystate.html:26148,Energy Efficiency,power,power-bicgstab,26148,"iter': 0}. def _iter_count(r):; ss_iters['iter'] += 1; return; ; _power_start = time.time(); # Get LU factors; if ss_args['method'] == 'power':; if settings.has_mkl:; lu = mkl_splu(L); else: ; lu = splu(L, permc_spec=ss_args['permc_spec'],; diag_pivot_thresh=ss_args['diag_pivot_thresh'],; options=dict(ILU_MILU=ss_args['ILU_MILU'])). if settings.debug and _scipy_check:; L_nnz = lu.L.nnz; U_nnz = lu.U.nnz; logger.debug('L NNZ: %i ; U NNZ: %i' % (L_nnz, U_nnz)); logger.debug('Fill factor: %f' % ((L_nnz+U_nnz)/orig_nnz)). it = 0; _tol = max(ss_args['tol']/10, 1e-15) # Should make this user accessible; while (la.norm(L * v, np.inf) > tol) and (it < maxiter):; ; if ss_args['method'] == 'power':; v = lu.solve(v); elif ss_args['method'] == 'power-gmres':; v, check = gmres(L, v, tol=_tol, M=ss_args['M'],; x0=ss_args['x0'], restart=ss_args['restart'],; maxiter=ss_args['maxiter'], callback=_iter_count); elif ss_args['method'] == 'power-lgmres':; v, check = lgmres(L, v, tol=_tol, M=ss_args['M'],; x0=ss_args['x0'], maxiter=ss_args['maxiter'],; callback=_iter_count); elif ss_args['method'] == 'power-bicgstab':; v, check = bicgstab(L, v, tol=_tol, M=ss_args['M'],; x0=ss_args['x0'],; maxiter=ss_args['maxiter'], callback=_iter_count); else:; raise Exception(""Invalid iterative solver method.""); ; v = v / la.norm(v, np.inf); it += 1; if ss_args['method'] == 'power' and settings.has_mkl:; lu.delete(); if it >= maxiter:; raise Exception('Failed to find steady state after ' +; str(maxiter) + ' iterations'); _power_end = time.time(); ss_args['info']['solution_time'] = _power_end-_power_start; ss_args['info']['iterations'] = it; if ss_args['return_info']:; ss_args['info']['residual_norm'] = la.norm(L*v); if settings.debug:; logger.debug('Number of iterations: %i' % it). if ss_args['use_rcm']:; v = v[np.ix_(rev_perm,)]. # normalise according to type of problem; if sflag:; trow = v[::rhoss.shape[0]+1]; data = v / np.sum(trow); else:; data = data / la.norm(v). data = dense2D_to_fastcsr_fmode(",MatchSource.WIKI,docs/4.2/modules/qutip/steadystate.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/steadystate.html
https://qutip.org/docs/4.2/modules/qutip/steadystate.html:26413,Energy Efficiency,power,power,26413," and _scipy_check:; L_nnz = lu.L.nnz; U_nnz = lu.U.nnz; logger.debug('L NNZ: %i ; U NNZ: %i' % (L_nnz, U_nnz)); logger.debug('Fill factor: %f' % ((L_nnz+U_nnz)/orig_nnz)). it = 0; _tol = max(ss_args['tol']/10, 1e-15) # Should make this user accessible; while (la.norm(L * v, np.inf) > tol) and (it < maxiter):; ; if ss_args['method'] == 'power':; v = lu.solve(v); elif ss_args['method'] == 'power-gmres':; v, check = gmres(L, v, tol=_tol, M=ss_args['M'],; x0=ss_args['x0'], restart=ss_args['restart'],; maxiter=ss_args['maxiter'], callback=_iter_count); elif ss_args['method'] == 'power-lgmres':; v, check = lgmres(L, v, tol=_tol, M=ss_args['M'],; x0=ss_args['x0'], maxiter=ss_args['maxiter'],; callback=_iter_count); elif ss_args['method'] == 'power-bicgstab':; v, check = bicgstab(L, v, tol=_tol, M=ss_args['M'],; x0=ss_args['x0'],; maxiter=ss_args['maxiter'], callback=_iter_count); else:; raise Exception(""Invalid iterative solver method.""); ; v = v / la.norm(v, np.inf); it += 1; if ss_args['method'] == 'power' and settings.has_mkl:; lu.delete(); if it >= maxiter:; raise Exception('Failed to find steady state after ' +; str(maxiter) + ' iterations'); _power_end = time.time(); ss_args['info']['solution_time'] = _power_end-_power_start; ss_args['info']['iterations'] = it; if ss_args['return_info']:; ss_args['info']['residual_norm'] = la.norm(L*v); if settings.debug:; logger.debug('Number of iterations: %i' % it). if ss_args['use_rcm']:; v = v[np.ix_(rev_perm,)]. # normalise according to type of problem; if sflag:; trow = v[::rhoss.shape[0]+1]; data = v / np.sum(trow); else:; data = data / la.norm(v). data = dense2D_to_fastcsr_fmode(vec2mat(data), rhoss.shape[0], rhoss.shape[0]); rhoss.data = 0.5 * (data + data.H); rhoss.isherm = True; if ss_args['return_info']:; return rhoss, ss_args['info']; else:; return rhoss. [docs]def build_preconditioner(A, c_op_list=[], **kwargs):; """"""Constructs a iLU preconditioner necessary for solving for; the steady state density matrix using the ite",MatchSource.WIKI,docs/4.2/modules/qutip/steadystate.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/steadystate.html
https://qutip.org/docs/4.2/modules/qutip/steadystate.html:28503,Energy Efficiency,power,power,28503,"n operator. c_op_list : list; A list of collapse operators. return_info : bool, optional, default = False; Return a dictionary of solver-specific infomation about the; solution and how it was obtained. use_rcm : bool, optional, default = False; Use reverse Cuthill-Mckee reordering to minimize fill-in in the; LU factorization of the Liouvillian. use_wbm : bool, optional, default = False; Use Weighted Bipartite Matching reordering to make the Liouvillian; diagonally dominant. This is useful for iterative preconditioners; only, and is set to ``True`` by default when finding a preconditioner. weight : float, optional; Sets the size of the elements used for adding the unity trace condition; to the linear solvers. This is set to the average abs value of the; Liouvillian elements if not specified by the user. method : str, default = 'iterative'; Tells the preconditioner what type of Liouvillian to build for; iLU factorization. For direct iterative methods use 'iterative'.; For power iterative methods use 'power'.; ; permc_spec : str, optional, default='COLAMD'; Column ordering used internally by superLU for the; 'direct' LU decomposition method. Options include 'COLAMD' and; 'NATURAL'. If using RCM then this is set to 'NATURAL' automatically; unless explicitly specified. fill_factor : float, optional, default = 100; Specifies the fill ratio upper bound (>=1) of the iLU; preconditioner. Lower values save memory at the cost of longer; execution times and a possible singular factorization. drop_tol : float, optional, default = 1e-4; Sets the threshold for the magnitude of preconditioner; elements that should be dropped. Can be reduced for a courser; factorization at the cost of an increased number of iterations, and a; possible singular factorization. diag_pivot_thresh : float, optional, default = None; Sets the threshold between [0,1] for which diagonal; elements are considered acceptable pivot points when using a; preconditioner. A value of zero forces the pivot to be the d",MatchSource.WIKI,docs/4.2/modules/qutip/steadystate.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/steadystate.html
https://qutip.org/docs/4.2/modules/qutip/steadystate.html:28532,Energy Efficiency,power,power,28532,"n operator. c_op_list : list; A list of collapse operators. return_info : bool, optional, default = False; Return a dictionary of solver-specific infomation about the; solution and how it was obtained. use_rcm : bool, optional, default = False; Use reverse Cuthill-Mckee reordering to minimize fill-in in the; LU factorization of the Liouvillian. use_wbm : bool, optional, default = False; Use Weighted Bipartite Matching reordering to make the Liouvillian; diagonally dominant. This is useful for iterative preconditioners; only, and is set to ``True`` by default when finding a preconditioner. weight : float, optional; Sets the size of the elements used for adding the unity trace condition; to the linear solvers. This is set to the average abs value of the; Liouvillian elements if not specified by the user. method : str, default = 'iterative'; Tells the preconditioner what type of Liouvillian to build for; iLU factorization. For direct iterative methods use 'iterative'.; For power iterative methods use 'power'.; ; permc_spec : str, optional, default='COLAMD'; Column ordering used internally by superLU for the; 'direct' LU decomposition method. Options include 'COLAMD' and; 'NATURAL'. If using RCM then this is set to 'NATURAL' automatically; unless explicitly specified. fill_factor : float, optional, default = 100; Specifies the fill ratio upper bound (>=1) of the iLU; preconditioner. Lower values save memory at the cost of longer; execution times and a possible singular factorization. drop_tol : float, optional, default = 1e-4; Sets the threshold for the magnitude of preconditioner; elements that should be dropped. Can be reduced for a courser; factorization at the cost of an increased number of iterations, and a; possible singular factorization. diag_pivot_thresh : float, optional, default = None; Sets the threshold between [0,1] for which diagonal; elements are considered acceptable pivot points when using a; preconditioner. A value of zero forces the pivot to be the d",MatchSource.WIKI,docs/4.2/modules/qutip/steadystate.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/steadystate.html
https://qutip.org/docs/4.2/modules/qutip/steadystate.html:29163,Energy Efficiency,reduce,reduced,29163,"near solvers. This is set to the average abs value of the; Liouvillian elements if not specified by the user. method : str, default = 'iterative'; Tells the preconditioner what type of Liouvillian to build for; iLU factorization. For direct iterative methods use 'iterative'.; For power iterative methods use 'power'.; ; permc_spec : str, optional, default='COLAMD'; Column ordering used internally by superLU for the; 'direct' LU decomposition method. Options include 'COLAMD' and; 'NATURAL'. If using RCM then this is set to 'NATURAL' automatically; unless explicitly specified. fill_factor : float, optional, default = 100; Specifies the fill ratio upper bound (>=1) of the iLU; preconditioner. Lower values save memory at the cost of longer; execution times and a possible singular factorization. drop_tol : float, optional, default = 1e-4; Sets the threshold for the magnitude of preconditioner; elements that should be dropped. Can be reduced for a courser; factorization at the cost of an increased number of iterations, and a; possible singular factorization. diag_pivot_thresh : float, optional, default = None; Sets the threshold between [0,1] for which diagonal; elements are considered acceptable pivot points when using a; preconditioner. A value of zero forces the pivot to be the diagonal; element. ILU_MILU : str, optional, default = 'smilu_2'; Selects the incomplete LU decomposition method algoithm used in; creating the preconditoner. Should only be used by advanced users. Returns; -------; lu : object; Returns a SuperLU object representing iLU preconditioner. info : dict, optional; Dictionary containing solver-specific information.; """"""; ss_args = _default_steadystate_args(); ss_args['method'] = 'iterative'; for key in kwargs.keys():; if key in ss_args.keys():; ss_args[key] = kwargs[key]; else:; raise Exception(""Invalid keyword argument '"" + key +; ""' passed to steadystate.""). # Set column perm to NATURAL if using RCM and not specified by user; if ss_args['use_rcm'] and",MatchSource.WIKI,docs/4.2/modules/qutip/steadystate.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/steadystate.html
https://qutip.org/docs/4.2/modules/qutip/steadystate.html:30710,Energy Efficiency,power,power,30710,"ed users. Returns; -------; lu : object; Returns a SuperLU object representing iLU preconditioner. info : dict, optional; Dictionary containing solver-specific information.; """"""; ss_args = _default_steadystate_args(); ss_args['method'] = 'iterative'; for key in kwargs.keys():; if key in ss_args.keys():; ss_args[key] = kwargs[key]; else:; raise Exception(""Invalid keyword argument '"" + key +; ""' passed to steadystate.""). # Set column perm to NATURAL if using RCM and not specified by user; if ss_args['use_rcm'] and ('permc_spec' not in kwargs.keys()):; ss_args['permc_spec'] = 'NATURAL'. L = _steadystate_setup(A, c_op_list); # Set weight parameter to avg abs val in L if not set explicitly; if 'weight' not in kwargs.keys():; ss_args['weight'] = np.mean(np.abs(L.data.data.max())); ss_args['info']['weight'] = ss_args['weight']. n = int(np.sqrt(L.shape[0])); if ss_args['method'] == 'iterative':; L, perm, perm2, rev_perm, ss_args = _steadystate_LU_liouvillian(L, ss_args); elif ss_args['method'] == 'power':; L, perm, perm2, rev_perm, ss_args = _steadystate_power_liouvillian(L, ss_args); else:; raise Exception(""Invalid preconditioning method.""); ; M, ss_args = _iterative_precondition(L, n, ss_args). if ss_args['return_info']:; return M, ss_args['info']; else:; return M. def _pseudo_inverse_dense(L, rhoss, w=None, **pseudo_args):; """"""; Internal function for computing the pseudo inverse of an Liouvillian using; dense matrix methods. See pseudo_inverse for details.; """"""; rho_vec = np.transpose(mat2vec(rhoss.full())). tr_mat = tensor([identity(n) for n in L.dims[0][0]]); tr_vec = np.transpose(mat2vec(tr_mat.full())); N = np.prod(L.dims[0][0]); I = np.identity(N * N); P = np.kron(np.transpose(rho_vec), tr_vec); Q = I - P; ; if w is None:; L = L; else:; L = 1.0j*w*spre(tr_mat)+L; ; if pseudo_args['method'] == 'direct':; try:; LIQ = np.linalg.solve(L.full(), Q); except:; LIQ = np.linalg.lstsq(L.full(), Q)[0]; ; R = np.dot(Q, LIQ); ; return Qobj(R, dims=L.dims). elif pseudo_args['meth",MatchSource.WIKI,docs/4.2/modules/qutip/steadystate.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/steadystate.html
https://qutip.org/docs/4.2/modules/qutip/steadystate.html:12502,Integrability,message,message,12502,"m'); ss_args['info']['wbm_time'] = _wbm_end-_wbm_start; if settings.debug:; wbm_band = sp_bandwidth(L)[0]; logger.debug('WBM bandwidth: %i' % wbm_band). if ss_args['use_rcm']:; if settings.debug:; logger.debug('Calculating Reverse Cuthill-Mckee ordering...'); _rcm_start = time.time(); perm2 = reverse_cuthill_mckee(L); _rcm_end = time.time(); rev_perm = np.argsort(perm2); L = sp_permute(L, perm2, perm2, form); ss_args['info']['perm'].append('rcm'); ss_args['info']['rcm_time'] = _rcm_end-_rcm_start; if settings.debug:; rcm_band = sp_bandwidth(L)[0]; rcm_pro = sp_profile(L)[0]; logger.debug('RCM bandwidth: %i' % rcm_band); logger.debug('Bandwidth reduction factor: %f' % ; (old_band/rcm_band)); logger.debug('Profile reduction factor: %f' % ; (old_pro/rcm_pro)); L.sort_indices(); return L, perm, perm2, rev_perm, ss_args. def steady(L, maxiter=10, tol=1e-12, itertol=1e-15, method='solve', ; use_precond=False):; """"""; Deprecated. See steadystate instead.; """"""; message = ""steady has been deprecated, use steadystate instead""; warnings.warn(message, DeprecationWarning); return steadystate(L, [], maxiter=maxiter, tol=tol, use_precond=use_precond). def _steadystate_direct_sparse(L, ss_args):; """"""; Direct solver that uses scipy sparse matrices; """"""; if settings.debug:; logger.debug('Starting direct LU solver.'). dims = L.dims[0]; n = int(np.sqrt(L.shape[0])); b = np.zeros(n ** 2, dtype=complex); b[0] = ss_args['weight']. if settings.has_mkl:; has_mkl = 1; else:; has_mkl = 0; ; L, perm, perm2, rev_perm, ss_args = _steadystate_LU_liouvillian(L, ss_args, has_mkl); if np.any(perm):; b = b[np.ix_(perm,)]; if np.any(perm2):; b = b[np.ix_(perm2,)]. ss_args['info']['permc_spec'] = ss_args['permc_spec']; ss_args['info']['drop_tol'] = ss_args['drop_tol']; ss_args['info']['diag_pivot_thresh'] = ss_args['diag_pivot_thresh']; ss_args['info']['fill_factor'] = ss_args['fill_factor']; ss_args['info']['ILU_MILU'] = ss_args['ILU_MILU']. if not has_mkl:; # Use superLU solver; orig_nnz = L.nnz; _dire",MatchSource.WIKI,docs/4.2/modules/qutip/steadystate.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/steadystate.html
https://qutip.org/docs/4.2/modules/qutip/steadystate.html:12581,Integrability,message,message,12581,"th(L)[0]; logger.debug('WBM bandwidth: %i' % wbm_band). if ss_args['use_rcm']:; if settings.debug:; logger.debug('Calculating Reverse Cuthill-Mckee ordering...'); _rcm_start = time.time(); perm2 = reverse_cuthill_mckee(L); _rcm_end = time.time(); rev_perm = np.argsort(perm2); L = sp_permute(L, perm2, perm2, form); ss_args['info']['perm'].append('rcm'); ss_args['info']['rcm_time'] = _rcm_end-_rcm_start; if settings.debug:; rcm_band = sp_bandwidth(L)[0]; rcm_pro = sp_profile(L)[0]; logger.debug('RCM bandwidth: %i' % rcm_band); logger.debug('Bandwidth reduction factor: %f' % ; (old_band/rcm_band)); logger.debug('Profile reduction factor: %f' % ; (old_pro/rcm_pro)); L.sort_indices(); return L, perm, perm2, rev_perm, ss_args. def steady(L, maxiter=10, tol=1e-12, itertol=1e-15, method='solve', ; use_precond=False):; """"""; Deprecated. See steadystate instead.; """"""; message = ""steady has been deprecated, use steadystate instead""; warnings.warn(message, DeprecationWarning); return steadystate(L, [], maxiter=maxiter, tol=tol, use_precond=use_precond). def _steadystate_direct_sparse(L, ss_args):; """"""; Direct solver that uses scipy sparse matrices; """"""; if settings.debug:; logger.debug('Starting direct LU solver.'). dims = L.dims[0]; n = int(np.sqrt(L.shape[0])); b = np.zeros(n ** 2, dtype=complex); b[0] = ss_args['weight']. if settings.has_mkl:; has_mkl = 1; else:; has_mkl = 0; ; L, perm, perm2, rev_perm, ss_args = _steadystate_LU_liouvillian(L, ss_args, has_mkl); if np.any(perm):; b = b[np.ix_(perm,)]; if np.any(perm2):; b = b[np.ix_(perm2,)]. ss_args['info']['permc_spec'] = ss_args['permc_spec']; ss_args['info']['drop_tol'] = ss_args['drop_tol']; ss_args['info']['diag_pivot_thresh'] = ss_args['diag_pivot_thresh']; ss_args['info']['fill_factor'] = ss_args['fill_factor']; ss_args['info']['ILU_MILU'] = ss_args['ILU_MILU']. if not has_mkl:; # Use superLU solver; orig_nnz = L.nnz; _direct_start = time.time(); lu = splu(L, permc_spec=ss_args['permc_spec'],; diag_pivot_thresh=ss_arg",MatchSource.WIKI,docs/4.2/modules/qutip/steadystate.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/steadystate.html
https://qutip.org/docs/4.2/modules/qutip/steadystate.html:6624,Performance,perform,perform,6624,"ow it was obtained. sparse : bool, optional, default = True; Solve for the steady state using sparse algorithms. If set to False,; the underlying Liouvillian operator will be converted into a dense; matrix. Use only for 'smaller' systems. use_rcm : bool, optional, default = False; Use reverse Cuthill-Mckee reordering to minimize fill-in in the; LU factorization of the Liouvillian. use_wbm : bool, optional, default = False; Use Weighted Bipartite Matching reordering to make the Liouvillian; diagonally dominant. This is useful for iterative preconditioners; only, and is set to ``True`` by default when finding a preconditioner. weight : float, optional; Sets the size of the elements used for adding the unity trace condition; to the linear solvers. This is set to the average abs value of the; Liouvillian elements if not specified by the user. x0 : ndarray, optional; ITERATIVE ONLY. Initial guess for solution vector. maxiter : int, optional, default=1000; ITERATIVE ONLY. Maximum number of iterations to perform. tol : float, optional, default=1e-12; ITERATIVE ONLY. Tolerance used for terminating solver. permc_spec : str, optional, default='COLAMD'; ITERATIVE ONLY. Column ordering used internally by superLU for the; 'direct' LU decomposition method. Options include 'COLAMD' and; 'NATURAL'. If using RCM then this is set to 'NATURAL' automatically; unless explicitly specified. use_precond : bool optional, default = False; ITERATIVE ONLY. Use an incomplete sparse LU decomposition as a; preconditioner for the 'iterative' GMRES and BICG solvers.; Speeds up convergence time by orders of magnitude in many cases. M : {sparse matrix, dense matrix, LinearOperator}, optional; ITERATIVE ONLY. Preconditioner for A. The preconditioner should; approximate the inverse of A. Effective preconditioning can; dramatically improve the rate of convergence for iterative methods.; If no preconditioner is given and ``use_precond = True``, then one; is generated automatically. fill_factor : float, op",MatchSource.WIKI,docs/4.2/modules/qutip/steadystate.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/steadystate.html
https://qutip.org/docs/4.2/modules/qutip/steadystate.html:25644,Security,access,accessible,25644," v = np.ones(n, dtype=complex); if ss_args['use_rcm']:; v = v[np.ix_(perm2,)]; ; # Do preconditioning; if ss_args['M'] is None and ss_args['use_precond'] and \; ss_args['method'] in ['power-gmres', ; 'power-lgmres', 'power-bicgstab']:; ss_args['M'], ss_args = _iterative_precondition(L, int(np.sqrt(n)), ss_args); if ss_args['M'] is None:; warnings.warn(""Preconditioning failed. Continuing without."",; UserWarning); ; ss_iters = {'iter': 0}. def _iter_count(r):; ss_iters['iter'] += 1; return; ; _power_start = time.time(); # Get LU factors; if ss_args['method'] == 'power':; if settings.has_mkl:; lu = mkl_splu(L); else: ; lu = splu(L, permc_spec=ss_args['permc_spec'],; diag_pivot_thresh=ss_args['diag_pivot_thresh'],; options=dict(ILU_MILU=ss_args['ILU_MILU'])). if settings.debug and _scipy_check:; L_nnz = lu.L.nnz; U_nnz = lu.U.nnz; logger.debug('L NNZ: %i ; U NNZ: %i' % (L_nnz, U_nnz)); logger.debug('Fill factor: %f' % ((L_nnz+U_nnz)/orig_nnz)). it = 0; _tol = max(ss_args['tol']/10, 1e-15) # Should make this user accessible; while (la.norm(L * v, np.inf) > tol) and (it < maxiter):; ; if ss_args['method'] == 'power':; v = lu.solve(v); elif ss_args['method'] == 'power-gmres':; v, check = gmres(L, v, tol=_tol, M=ss_args['M'],; x0=ss_args['x0'], restart=ss_args['restart'],; maxiter=ss_args['maxiter'], callback=_iter_count); elif ss_args['method'] == 'power-lgmres':; v, check = lgmres(L, v, tol=_tol, M=ss_args['M'],; x0=ss_args['x0'], maxiter=ss_args['maxiter'],; callback=_iter_count); elif ss_args['method'] == 'power-bicgstab':; v, check = bicgstab(L, v, tol=_tol, M=ss_args['M'],; x0=ss_args['x0'],; maxiter=ss_args['maxiter'], callback=_iter_count); else:; raise Exception(""Invalid iterative solver method.""); ; v = v / la.norm(v, np.inf); it += 1; if ss_args['method'] == 'power' and settings.has_mkl:; lu.delete(); if it >= maxiter:; raise Exception('Failed to find steady state after ' +; str(maxiter) + ' iterations'); _power_end = time.time(); ss_args['info']['solution_time']",MatchSource.WIKI,docs/4.2/modules/qutip/steadystate.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/steadystate.html
https://qutip.org/docs/4.2/modules/qutip/steadystate.html:3275,Testability,log,logger,3275,"'steady', 'build_preconditioner',; 'pseudo_inverse']. import warnings; import time; import scipy; import numpy as np; from numpy.linalg import svd; from scipy import prod; import scipy.sparse as sp; import scipy.linalg as la; from scipy.sparse.linalg import (use_solver, splu, spilu, spsolve, eigs,; LinearOperator, gmres, lgmres, bicgstab); from qutip.qobj import Qobj, issuper, isoper. from qutip.superoperator import liouvillian, vec2mat, spre; from qutip.sparse import sp_permute, sp_bandwidth, sp_reshape, sp_profile. from qutip.superoperator import liouvillian, vec2mat; from qutip.sparse import (sp_permute, sp_bandwidth, sp_reshape, ; sp_profile); from qutip.cy.spmath import zcsr_kron; from qutip.graph import reverse_cuthill_mckee, weighted_bipartite_matching; from qutip import (mat2vec, tensor, identity, operator_to_vector); import qutip.settings as settings; from qutip.utilities import _version2int; from qutip.cy.spconvert import dense2D_to_fastcsr_fmode. import qutip.logging_utils; logger = qutip.logging_utils.get_logger(); logger.setLevel('DEBUG'). # Load MKL spsolve if avaiable; if settings.has_mkl:; from qutip._mkl.spsolve import (mkl_splu, mkl_spsolve). # test if scipy is recent enought to get L & U factors from superLU; _scipy_check = _version2int(scipy.__version__) >= _version2int('0.14.0'). def _empty_info_dict():; def_info = {'perm': [], 'solution_time': None, 'iterations': None,; 'residual_norm': None, 'rcm_time': None, 'wbm_time': None,; 'iter_time': None, 'precond_time': None, 'ILU_MILU': None,; 'fill_factor': None, 'diag_pivot_thresh': None, ; 'drop_tol': None, 'permc_spec': None, 'weight': None}; ; return def_info. def _default_steadystate_args():; def_args = {'method': 'direct', 'sparse': True, 'use_rcm': False,; 'use_wbm': False, 'weight': None, 'use_precond': False, ; 'all_states': False, 'M': None, 'x0': None, 'drop_tol': 1e-4, ; 'fill_factor': 100, 'diag_pivot_thresh': None, 'maxiter': 1000, ; 'tol': 1e-12, 'permc_spec': 'COLAMD', 'ILU_MILU': 's",MatchSource.WIKI,docs/4.2/modules/qutip/steadystate.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/steadystate.html
https://qutip.org/docs/4.2/modules/qutip/steadystate.html:3318,Testability,log,logger,3318,"udo_inverse']. import warnings; import time; import scipy; import numpy as np; from numpy.linalg import svd; from scipy import prod; import scipy.sparse as sp; import scipy.linalg as la; from scipy.sparse.linalg import (use_solver, splu, spilu, spsolve, eigs,; LinearOperator, gmres, lgmres, bicgstab); from qutip.qobj import Qobj, issuper, isoper. from qutip.superoperator import liouvillian, vec2mat, spre; from qutip.sparse import sp_permute, sp_bandwidth, sp_reshape, sp_profile. from qutip.superoperator import liouvillian, vec2mat; from qutip.sparse import (sp_permute, sp_bandwidth, sp_reshape, ; sp_profile); from qutip.cy.spmath import zcsr_kron; from qutip.graph import reverse_cuthill_mckee, weighted_bipartite_matching; from qutip import (mat2vec, tensor, identity, operator_to_vector); import qutip.settings as settings; from qutip.utilities import _version2int; from qutip.cy.spconvert import dense2D_to_fastcsr_fmode. import qutip.logging_utils; logger = qutip.logging_utils.get_logger(); logger.setLevel('DEBUG'). # Load MKL spsolve if avaiable; if settings.has_mkl:; from qutip._mkl.spsolve import (mkl_splu, mkl_spsolve). # test if scipy is recent enought to get L & U factors from superLU; _scipy_check = _version2int(scipy.__version__) >= _version2int('0.14.0'). def _empty_info_dict():; def_info = {'perm': [], 'solution_time': None, 'iterations': None,; 'residual_norm': None, 'rcm_time': None, 'wbm_time': None,; 'iter_time': None, 'precond_time': None, 'ILU_MILU': None,; 'fill_factor': None, 'diag_pivot_thresh': None, ; 'drop_tol': None, 'permc_spec': None, 'weight': None}; ; return def_info. def _default_steadystate_args():; def_args = {'method': 'direct', 'sparse': True, 'use_rcm': False,; 'use_wbm': False, 'weight': None, 'use_precond': False, ; 'all_states': False, 'M': None, 'x0': None, 'drop_tol': 1e-4, ; 'fill_factor': 100, 'diag_pivot_thresh': None, 'maxiter': 1000, ; 'tol': 1e-12, 'permc_spec': 'COLAMD', 'ILU_MILU': 'smilu_2', ; 'restart': 20, 'return_info':",MatchSource.WIKI,docs/4.2/modules/qutip/steadystate.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/steadystate.html
https://qutip.org/docs/4.2/modules/qutip/steadystate.html:3456,Testability,test,test,3456," scipy.sparse.linalg import (use_solver, splu, spilu, spsolve, eigs,; LinearOperator, gmres, lgmres, bicgstab); from qutip.qobj import Qobj, issuper, isoper. from qutip.superoperator import liouvillian, vec2mat, spre; from qutip.sparse import sp_permute, sp_bandwidth, sp_reshape, sp_profile. from qutip.superoperator import liouvillian, vec2mat; from qutip.sparse import (sp_permute, sp_bandwidth, sp_reshape, ; sp_profile); from qutip.cy.spmath import zcsr_kron; from qutip.graph import reverse_cuthill_mckee, weighted_bipartite_matching; from qutip import (mat2vec, tensor, identity, operator_to_vector); import qutip.settings as settings; from qutip.utilities import _version2int; from qutip.cy.spconvert import dense2D_to_fastcsr_fmode. import qutip.logging_utils; logger = qutip.logging_utils.get_logger(); logger.setLevel('DEBUG'). # Load MKL spsolve if avaiable; if settings.has_mkl:; from qutip._mkl.spsolve import (mkl_splu, mkl_spsolve). # test if scipy is recent enought to get L & U factors from superLU; _scipy_check = _version2int(scipy.__version__) >= _version2int('0.14.0'). def _empty_info_dict():; def_info = {'perm': [], 'solution_time': None, 'iterations': None,; 'residual_norm': None, 'rcm_time': None, 'wbm_time': None,; 'iter_time': None, 'precond_time': None, 'ILU_MILU': None,; 'fill_factor': None, 'diag_pivot_thresh': None, ; 'drop_tol': None, 'permc_spec': None, 'weight': None}; ; return def_info. def _default_steadystate_args():; def_args = {'method': 'direct', 'sparse': True, 'use_rcm': False,; 'use_wbm': False, 'weight': None, 'use_precond': False, ; 'all_states': False, 'M': None, 'x0': None, 'drop_tol': 1e-4, ; 'fill_factor': 100, 'diag_pivot_thresh': None, 'maxiter': 1000, ; 'tol': 1e-12, 'permc_spec': 'COLAMD', 'ILU_MILU': 'smilu_2', ; 'restart': 20, 'return_info': False, 'info': _empty_info_dict(), ; 'verbose': False}. return def_args. [docs]def steadystate(A, c_op_list=[], **kwargs):; """"""Calculates the steady state for quantum evolution subject to t",MatchSource.WIKI,docs/4.2/modules/qutip/steadystate.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/steadystate.html
https://qutip.org/docs/4.2/modules/qutip/steadystate.html:11150,Testability,log,logger,11150,"). def _steadystate_setup(A, c_op_list):; """"""Build Liouvillian (if necessary) and check input.; """"""; if isoper(A):; if len(c_op_list) > 0:; return liouvillian(A, c_op_list). raise TypeError('Cannot calculate the steady state for a ' +; 'non-dissipative system ' +; '(no collapse operators given)'); elif issuper(A):; return A; else:; raise TypeError('Solving for steady states requires ' +; 'Liouvillian (super) operators'). def _steadystate_LU_liouvillian(L, ss_args, has_mkl=0):; """"""Creates modified Liouvillian for LU based SS methods.; """"""; perm = None; perm2 = None; rev_perm = None; n = int(np.sqrt(L.shape[0])); form = 'csr'; if has_mkl:; L = L.data + sp.csr_matrix(; (ss_args['weight']*np.ones(n), (np.zeros(n), [nn * (n + 1); for nn in range(n)])),; shape=(n ** 2, n ** 2)); else:; form = 'csc'; L = L.data.tocsc() + sp.csc_matrix(; (ss_args['weight']*np.ones(n), (np.zeros(n), [nn * (n + 1); for nn in range(n)])),; shape=(n ** 2, n ** 2)). if settings.debug:; old_band = sp_bandwidth(L)[0]; old_pro = sp_profile(L)[0]; logger.debug('Orig. NNZ: %i' % L.nnz); if ss_args['use_rcm']:; logger.debug('Original bandwidth: %i' % old_band). if ss_args['use_wbm']:; if settings.debug:; logger.debug('Calculating Weighted Bipartite Matching ordering...'); _wbm_start = time.time(); perm = weighted_bipartite_matching(L); _wbm_end = time.time(); L = sp_permute(L, perm, [], form); ss_args['info']['perm'].append('wbm'); ss_args['info']['wbm_time'] = _wbm_end-_wbm_start; if settings.debug:; wbm_band = sp_bandwidth(L)[0]; logger.debug('WBM bandwidth: %i' % wbm_band). if ss_args['use_rcm']:; if settings.debug:; logger.debug('Calculating Reverse Cuthill-Mckee ordering...'); _rcm_start = time.time(); perm2 = reverse_cuthill_mckee(L); _rcm_end = time.time(); rev_perm = np.argsort(perm2); L = sp_permute(L, perm2, perm2, form); ss_args['info']['perm'].append('rcm'); ss_args['info']['rcm_time'] = _rcm_end-_rcm_start; if settings.debug:; rcm_band = sp_bandwidth(L)[0]; rcm_pro = sp_profile(L)[0]; log",MatchSource.WIKI,docs/4.2/modules/qutip/steadystate.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/steadystate.html
https://qutip.org/docs/4.2/modules/qutip/steadystate.html:11213,Testability,log,logger,11213," check input.; """"""; if isoper(A):; if len(c_op_list) > 0:; return liouvillian(A, c_op_list). raise TypeError('Cannot calculate the steady state for a ' +; 'non-dissipative system ' +; '(no collapse operators given)'); elif issuper(A):; return A; else:; raise TypeError('Solving for steady states requires ' +; 'Liouvillian (super) operators'). def _steadystate_LU_liouvillian(L, ss_args, has_mkl=0):; """"""Creates modified Liouvillian for LU based SS methods.; """"""; perm = None; perm2 = None; rev_perm = None; n = int(np.sqrt(L.shape[0])); form = 'csr'; if has_mkl:; L = L.data + sp.csr_matrix(; (ss_args['weight']*np.ones(n), (np.zeros(n), [nn * (n + 1); for nn in range(n)])),; shape=(n ** 2, n ** 2)); else:; form = 'csc'; L = L.data.tocsc() + sp.csc_matrix(; (ss_args['weight']*np.ones(n), (np.zeros(n), [nn * (n + 1); for nn in range(n)])),; shape=(n ** 2, n ** 2)). if settings.debug:; old_band = sp_bandwidth(L)[0]; old_pro = sp_profile(L)[0]; logger.debug('Orig. NNZ: %i' % L.nnz); if ss_args['use_rcm']:; logger.debug('Original bandwidth: %i' % old_band). if ss_args['use_wbm']:; if settings.debug:; logger.debug('Calculating Weighted Bipartite Matching ordering...'); _wbm_start = time.time(); perm = weighted_bipartite_matching(L); _wbm_end = time.time(); L = sp_permute(L, perm, [], form); ss_args['info']['perm'].append('wbm'); ss_args['info']['wbm_time'] = _wbm_end-_wbm_start; if settings.debug:; wbm_band = sp_bandwidth(L)[0]; logger.debug('WBM bandwidth: %i' % wbm_band). if ss_args['use_rcm']:; if settings.debug:; logger.debug('Calculating Reverse Cuthill-Mckee ordering...'); _rcm_start = time.time(); perm2 = reverse_cuthill_mckee(L); _rcm_end = time.time(); rev_perm = np.argsort(perm2); L = sp_permute(L, perm2, perm2, form); ss_args['info']['perm'].append('rcm'); ss_args['info']['rcm_time'] = _rcm_end-_rcm_start; if settings.debug:; rcm_band = sp_bandwidth(L)[0]; rcm_pro = sp_profile(L)[0]; logger.debug('RCM bandwidth: %i' % rcm_band); logger.debug('Bandwidth reduction facto",MatchSource.WIKI,docs/4.2/modules/qutip/steadystate.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/steadystate.html
https://qutip.org/docs/4.2/modules/qutip/steadystate.html:11308,Testability,log,logger,11308,"or('Cannot calculate the steady state for a ' +; 'non-dissipative system ' +; '(no collapse operators given)'); elif issuper(A):; return A; else:; raise TypeError('Solving for steady states requires ' +; 'Liouvillian (super) operators'). def _steadystate_LU_liouvillian(L, ss_args, has_mkl=0):; """"""Creates modified Liouvillian for LU based SS methods.; """"""; perm = None; perm2 = None; rev_perm = None; n = int(np.sqrt(L.shape[0])); form = 'csr'; if has_mkl:; L = L.data + sp.csr_matrix(; (ss_args['weight']*np.ones(n), (np.zeros(n), [nn * (n + 1); for nn in range(n)])),; shape=(n ** 2, n ** 2)); else:; form = 'csc'; L = L.data.tocsc() + sp.csc_matrix(; (ss_args['weight']*np.ones(n), (np.zeros(n), [nn * (n + 1); for nn in range(n)])),; shape=(n ** 2, n ** 2)). if settings.debug:; old_band = sp_bandwidth(L)[0]; old_pro = sp_profile(L)[0]; logger.debug('Orig. NNZ: %i' % L.nnz); if ss_args['use_rcm']:; logger.debug('Original bandwidth: %i' % old_band). if ss_args['use_wbm']:; if settings.debug:; logger.debug('Calculating Weighted Bipartite Matching ordering...'); _wbm_start = time.time(); perm = weighted_bipartite_matching(L); _wbm_end = time.time(); L = sp_permute(L, perm, [], form); ss_args['info']['perm'].append('wbm'); ss_args['info']['wbm_time'] = _wbm_end-_wbm_start; if settings.debug:; wbm_band = sp_bandwidth(L)[0]; logger.debug('WBM bandwidth: %i' % wbm_band). if ss_args['use_rcm']:; if settings.debug:; logger.debug('Calculating Reverse Cuthill-Mckee ordering...'); _rcm_start = time.time(); perm2 = reverse_cuthill_mckee(L); _rcm_end = time.time(); rev_perm = np.argsort(perm2); L = sp_permute(L, perm2, perm2, form); ss_args['info']['perm'].append('rcm'); ss_args['info']['rcm_time'] = _rcm_end-_rcm_start; if settings.debug:; rcm_band = sp_bandwidth(L)[0]; rcm_pro = sp_profile(L)[0]; logger.debug('RCM bandwidth: %i' % rcm_band); logger.debug('Bandwidth reduction factor: %f' % ; (old_band/rcm_band)); logger.debug('Profile reduction factor: %f' % ; (old_pro/rcm_pro)); L.sor",MatchSource.WIKI,docs/4.2/modules/qutip/steadystate.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/steadystate.html
https://qutip.org/docs/4.2/modules/qutip/steadystate.html:11642,Testability,log,logger,11642,"villian for LU based SS methods.; """"""; perm = None; perm2 = None; rev_perm = None; n = int(np.sqrt(L.shape[0])); form = 'csr'; if has_mkl:; L = L.data + sp.csr_matrix(; (ss_args['weight']*np.ones(n), (np.zeros(n), [nn * (n + 1); for nn in range(n)])),; shape=(n ** 2, n ** 2)); else:; form = 'csc'; L = L.data.tocsc() + sp.csc_matrix(; (ss_args['weight']*np.ones(n), (np.zeros(n), [nn * (n + 1); for nn in range(n)])),; shape=(n ** 2, n ** 2)). if settings.debug:; old_band = sp_bandwidth(L)[0]; old_pro = sp_profile(L)[0]; logger.debug('Orig. NNZ: %i' % L.nnz); if ss_args['use_rcm']:; logger.debug('Original bandwidth: %i' % old_band). if ss_args['use_wbm']:; if settings.debug:; logger.debug('Calculating Weighted Bipartite Matching ordering...'); _wbm_start = time.time(); perm = weighted_bipartite_matching(L); _wbm_end = time.time(); L = sp_permute(L, perm, [], form); ss_args['info']['perm'].append('wbm'); ss_args['info']['wbm_time'] = _wbm_end-_wbm_start; if settings.debug:; wbm_band = sp_bandwidth(L)[0]; logger.debug('WBM bandwidth: %i' % wbm_band). if ss_args['use_rcm']:; if settings.debug:; logger.debug('Calculating Reverse Cuthill-Mckee ordering...'); _rcm_start = time.time(); perm2 = reverse_cuthill_mckee(L); _rcm_end = time.time(); rev_perm = np.argsort(perm2); L = sp_permute(L, perm2, perm2, form); ss_args['info']['perm'].append('rcm'); ss_args['info']['rcm_time'] = _rcm_end-_rcm_start; if settings.debug:; rcm_band = sp_bandwidth(L)[0]; rcm_pro = sp_profile(L)[0]; logger.debug('RCM bandwidth: %i' % rcm_band); logger.debug('Bandwidth reduction factor: %f' % ; (old_band/rcm_band)); logger.debug('Profile reduction factor: %f' % ; (old_pro/rcm_pro)); L.sort_indices(); return L, perm, perm2, rev_perm, ss_args. def steady(L, maxiter=10, tol=1e-12, itertol=1e-15, method='solve', ; use_precond=False):; """"""; Deprecated. See steadystate instead.; """"""; message = ""steady has been deprecated, use steadystate instead""; warnings.warn(message, DeprecationWarning); return steadyst",MatchSource.WIKI,docs/4.2/modules/qutip/steadystate.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/steadystate.html
https://qutip.org/docs/4.2/modules/qutip/steadystate.html:11732,Testability,log,logger,11732,"e[0])); form = 'csr'; if has_mkl:; L = L.data + sp.csr_matrix(; (ss_args['weight']*np.ones(n), (np.zeros(n), [nn * (n + 1); for nn in range(n)])),; shape=(n ** 2, n ** 2)); else:; form = 'csc'; L = L.data.tocsc() + sp.csc_matrix(; (ss_args['weight']*np.ones(n), (np.zeros(n), [nn * (n + 1); for nn in range(n)])),; shape=(n ** 2, n ** 2)). if settings.debug:; old_band = sp_bandwidth(L)[0]; old_pro = sp_profile(L)[0]; logger.debug('Orig. NNZ: %i' % L.nnz); if ss_args['use_rcm']:; logger.debug('Original bandwidth: %i' % old_band). if ss_args['use_wbm']:; if settings.debug:; logger.debug('Calculating Weighted Bipartite Matching ordering...'); _wbm_start = time.time(); perm = weighted_bipartite_matching(L); _wbm_end = time.time(); L = sp_permute(L, perm, [], form); ss_args['info']['perm'].append('wbm'); ss_args['info']['wbm_time'] = _wbm_end-_wbm_start; if settings.debug:; wbm_band = sp_bandwidth(L)[0]; logger.debug('WBM bandwidth: %i' % wbm_band). if ss_args['use_rcm']:; if settings.debug:; logger.debug('Calculating Reverse Cuthill-Mckee ordering...'); _rcm_start = time.time(); perm2 = reverse_cuthill_mckee(L); _rcm_end = time.time(); rev_perm = np.argsort(perm2); L = sp_permute(L, perm2, perm2, form); ss_args['info']['perm'].append('rcm'); ss_args['info']['rcm_time'] = _rcm_end-_rcm_start; if settings.debug:; rcm_band = sp_bandwidth(L)[0]; rcm_pro = sp_profile(L)[0]; logger.debug('RCM bandwidth: %i' % rcm_band); logger.debug('Bandwidth reduction factor: %f' % ; (old_band/rcm_band)); logger.debug('Profile reduction factor: %f' % ; (old_pro/rcm_pro)); L.sort_indices(); return L, perm, perm2, rev_perm, ss_args. def steady(L, maxiter=10, tol=1e-12, itertol=1e-15, method='solve', ; use_precond=False):; """"""; Deprecated. See steadystate instead.; """"""; message = ""steady has been deprecated, use steadystate instead""; warnings.warn(message, DeprecationWarning); return steadystate(L, [], maxiter=maxiter, tol=tol, use_precond=use_precond). def _steadystate_direct_sparse(L, ss_args):",MatchSource.WIKI,docs/4.2/modules/qutip/steadystate.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/steadystate.html
https://qutip.org/docs/4.2/modules/qutip/steadystate.html:12117,Testability,log,logger,12117,"g:; old_band = sp_bandwidth(L)[0]; old_pro = sp_profile(L)[0]; logger.debug('Orig. NNZ: %i' % L.nnz); if ss_args['use_rcm']:; logger.debug('Original bandwidth: %i' % old_band). if ss_args['use_wbm']:; if settings.debug:; logger.debug('Calculating Weighted Bipartite Matching ordering...'); _wbm_start = time.time(); perm = weighted_bipartite_matching(L); _wbm_end = time.time(); L = sp_permute(L, perm, [], form); ss_args['info']['perm'].append('wbm'); ss_args['info']['wbm_time'] = _wbm_end-_wbm_start; if settings.debug:; wbm_band = sp_bandwidth(L)[0]; logger.debug('WBM bandwidth: %i' % wbm_band). if ss_args['use_rcm']:; if settings.debug:; logger.debug('Calculating Reverse Cuthill-Mckee ordering...'); _rcm_start = time.time(); perm2 = reverse_cuthill_mckee(L); _rcm_end = time.time(); rev_perm = np.argsort(perm2); L = sp_permute(L, perm2, perm2, form); ss_args['info']['perm'].append('rcm'); ss_args['info']['rcm_time'] = _rcm_end-_rcm_start; if settings.debug:; rcm_band = sp_bandwidth(L)[0]; rcm_pro = sp_profile(L)[0]; logger.debug('RCM bandwidth: %i' % rcm_band); logger.debug('Bandwidth reduction factor: %f' % ; (old_band/rcm_band)); logger.debug('Profile reduction factor: %f' % ; (old_pro/rcm_pro)); L.sort_indices(); return L, perm, perm2, rev_perm, ss_args. def steady(L, maxiter=10, tol=1e-12, itertol=1e-15, method='solve', ; use_precond=False):; """"""; Deprecated. See steadystate instead.; """"""; message = ""steady has been deprecated, use steadystate instead""; warnings.warn(message, DeprecationWarning); return steadystate(L, [], maxiter=maxiter, tol=tol, use_precond=use_precond). def _steadystate_direct_sparse(L, ss_args):; """"""; Direct solver that uses scipy sparse matrices; """"""; if settings.debug:; logger.debug('Starting direct LU solver.'). dims = L.dims[0]; n = int(np.sqrt(L.shape[0])); b = np.zeros(n ** 2, dtype=complex); b[0] = ss_args['weight']. if settings.has_mkl:; has_mkl = 1; else:; has_mkl = 0; ; L, perm, perm2, rev_perm, ss_args = _steadystate_LU_liouvillian(",MatchSource.WIKI,docs/4.2/modules/qutip/steadystate.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/steadystate.html
https://qutip.org/docs/4.2/modules/qutip/steadystate.html:12163,Testability,log,logger,12163,"]; logger.debug('Orig. NNZ: %i' % L.nnz); if ss_args['use_rcm']:; logger.debug('Original bandwidth: %i' % old_band). if ss_args['use_wbm']:; if settings.debug:; logger.debug('Calculating Weighted Bipartite Matching ordering...'); _wbm_start = time.time(); perm = weighted_bipartite_matching(L); _wbm_end = time.time(); L = sp_permute(L, perm, [], form); ss_args['info']['perm'].append('wbm'); ss_args['info']['wbm_time'] = _wbm_end-_wbm_start; if settings.debug:; wbm_band = sp_bandwidth(L)[0]; logger.debug('WBM bandwidth: %i' % wbm_band). if ss_args['use_rcm']:; if settings.debug:; logger.debug('Calculating Reverse Cuthill-Mckee ordering...'); _rcm_start = time.time(); perm2 = reverse_cuthill_mckee(L); _rcm_end = time.time(); rev_perm = np.argsort(perm2); L = sp_permute(L, perm2, perm2, form); ss_args['info']['perm'].append('rcm'); ss_args['info']['rcm_time'] = _rcm_end-_rcm_start; if settings.debug:; rcm_band = sp_bandwidth(L)[0]; rcm_pro = sp_profile(L)[0]; logger.debug('RCM bandwidth: %i' % rcm_band); logger.debug('Bandwidth reduction factor: %f' % ; (old_band/rcm_band)); logger.debug('Profile reduction factor: %f' % ; (old_pro/rcm_pro)); L.sort_indices(); return L, perm, perm2, rev_perm, ss_args. def steady(L, maxiter=10, tol=1e-12, itertol=1e-15, method='solve', ; use_precond=False):; """"""; Deprecated. See steadystate instead.; """"""; message = ""steady has been deprecated, use steadystate instead""; warnings.warn(message, DeprecationWarning); return steadystate(L, [], maxiter=maxiter, tol=tol, use_precond=use_precond). def _steadystate_direct_sparse(L, ss_args):; """"""; Direct solver that uses scipy sparse matrices; """"""; if settings.debug:; logger.debug('Starting direct LU solver.'). dims = L.dims[0]; n = int(np.sqrt(L.shape[0])); b = np.zeros(n ** 2, dtype=complex); b[0] = ss_args['weight']. if settings.has_mkl:; has_mkl = 1; else:; has_mkl = 0; ; L, perm, perm2, rev_perm, ss_args = _steadystate_LU_liouvillian(L, ss_args, has_mkl); if np.any(perm):; b = b[np.ix_(perm,)]",MatchSource.WIKI,docs/4.2/modules/qutip/steadystate.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/steadystate.html
https://qutip.org/docs/4.2/modules/qutip/steadystate.html:12235,Testability,log,logger,12235,"cm']:; logger.debug('Original bandwidth: %i' % old_band). if ss_args['use_wbm']:; if settings.debug:; logger.debug('Calculating Weighted Bipartite Matching ordering...'); _wbm_start = time.time(); perm = weighted_bipartite_matching(L); _wbm_end = time.time(); L = sp_permute(L, perm, [], form); ss_args['info']['perm'].append('wbm'); ss_args['info']['wbm_time'] = _wbm_end-_wbm_start; if settings.debug:; wbm_band = sp_bandwidth(L)[0]; logger.debug('WBM bandwidth: %i' % wbm_band). if ss_args['use_rcm']:; if settings.debug:; logger.debug('Calculating Reverse Cuthill-Mckee ordering...'); _rcm_start = time.time(); perm2 = reverse_cuthill_mckee(L); _rcm_end = time.time(); rev_perm = np.argsort(perm2); L = sp_permute(L, perm2, perm2, form); ss_args['info']['perm'].append('rcm'); ss_args['info']['rcm_time'] = _rcm_end-_rcm_start; if settings.debug:; rcm_band = sp_bandwidth(L)[0]; rcm_pro = sp_profile(L)[0]; logger.debug('RCM bandwidth: %i' % rcm_band); logger.debug('Bandwidth reduction factor: %f' % ; (old_band/rcm_band)); logger.debug('Profile reduction factor: %f' % ; (old_pro/rcm_pro)); L.sort_indices(); return L, perm, perm2, rev_perm, ss_args. def steady(L, maxiter=10, tol=1e-12, itertol=1e-15, method='solve', ; use_precond=False):; """"""; Deprecated. See steadystate instead.; """"""; message = ""steady has been deprecated, use steadystate instead""; warnings.warn(message, DeprecationWarning); return steadystate(L, [], maxiter=maxiter, tol=tol, use_precond=use_precond). def _steadystate_direct_sparse(L, ss_args):; """"""; Direct solver that uses scipy sparse matrices; """"""; if settings.debug:; logger.debug('Starting direct LU solver.'). dims = L.dims[0]; n = int(np.sqrt(L.shape[0])); b = np.zeros(n ** 2, dtype=complex); b[0] = ss_args['weight']. if settings.has_mkl:; has_mkl = 1; else:; has_mkl = 0; ; L, perm, perm2, rev_perm, ss_args = _steadystate_LU_liouvillian(L, ss_args, has_mkl); if np.any(perm):; b = b[np.ix_(perm,)]; if np.any(perm2):; b = b[np.ix_(perm2,)]. ss_args['info']",MatchSource.WIKI,docs/4.2/modules/qutip/steadystate.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/steadystate.html
https://qutip.org/docs/4.2/modules/qutip/steadystate.html:12811,Testability,log,logger,12811,"me.time(); perm2 = reverse_cuthill_mckee(L); _rcm_end = time.time(); rev_perm = np.argsort(perm2); L = sp_permute(L, perm2, perm2, form); ss_args['info']['perm'].append('rcm'); ss_args['info']['rcm_time'] = _rcm_end-_rcm_start; if settings.debug:; rcm_band = sp_bandwidth(L)[0]; rcm_pro = sp_profile(L)[0]; logger.debug('RCM bandwidth: %i' % rcm_band); logger.debug('Bandwidth reduction factor: %f' % ; (old_band/rcm_band)); logger.debug('Profile reduction factor: %f' % ; (old_pro/rcm_pro)); L.sort_indices(); return L, perm, perm2, rev_perm, ss_args. def steady(L, maxiter=10, tol=1e-12, itertol=1e-15, method='solve', ; use_precond=False):; """"""; Deprecated. See steadystate instead.; """"""; message = ""steady has been deprecated, use steadystate instead""; warnings.warn(message, DeprecationWarning); return steadystate(L, [], maxiter=maxiter, tol=tol, use_precond=use_precond). def _steadystate_direct_sparse(L, ss_args):; """"""; Direct solver that uses scipy sparse matrices; """"""; if settings.debug:; logger.debug('Starting direct LU solver.'). dims = L.dims[0]; n = int(np.sqrt(L.shape[0])); b = np.zeros(n ** 2, dtype=complex); b[0] = ss_args['weight']. if settings.has_mkl:; has_mkl = 1; else:; has_mkl = 0; ; L, perm, perm2, rev_perm, ss_args = _steadystate_LU_liouvillian(L, ss_args, has_mkl); if np.any(perm):; b = b[np.ix_(perm,)]; if np.any(perm2):; b = b[np.ix_(perm2,)]. ss_args['info']['permc_spec'] = ss_args['permc_spec']; ss_args['info']['drop_tol'] = ss_args['drop_tol']; ss_args['info']['diag_pivot_thresh'] = ss_args['diag_pivot_thresh']; ss_args['info']['fill_factor'] = ss_args['fill_factor']; ss_args['info']['ILU_MILU'] = ss_args['ILU_MILU']. if not has_mkl:; # Use superLU solver; orig_nnz = L.nnz; _direct_start = time.time(); lu = splu(L, permc_spec=ss_args['permc_spec'],; diag_pivot_thresh=ss_args['diag_pivot_thresh'],; options=dict(ILU_MILU=ss_args['ILU_MILU'])); v = lu.solve(b); _direct_end = time.time(); ss_args['info']['solution_time'] = _direct_end - _direct_start; i",MatchSource.WIKI,docs/4.2/modules/qutip/steadystate.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/steadystate.html
https://qutip.org/docs/4.2/modules/qutip/steadystate.html:14058,Testability,log,logger,14058,"= _steadystate_LU_liouvillian(L, ss_args, has_mkl); if np.any(perm):; b = b[np.ix_(perm,)]; if np.any(perm2):; b = b[np.ix_(perm2,)]. ss_args['info']['permc_spec'] = ss_args['permc_spec']; ss_args['info']['drop_tol'] = ss_args['drop_tol']; ss_args['info']['diag_pivot_thresh'] = ss_args['diag_pivot_thresh']; ss_args['info']['fill_factor'] = ss_args['fill_factor']; ss_args['info']['ILU_MILU'] = ss_args['ILU_MILU']. if not has_mkl:; # Use superLU solver; orig_nnz = L.nnz; _direct_start = time.time(); lu = splu(L, permc_spec=ss_args['permc_spec'],; diag_pivot_thresh=ss_args['diag_pivot_thresh'],; options=dict(ILU_MILU=ss_args['ILU_MILU'])); v = lu.solve(b); _direct_end = time.time(); ss_args['info']['solution_time'] = _direct_end - _direct_start; if (settings.debug or ss_args['return_info']) and _scipy_check:; L_nnz = lu.L.nnz; U_nnz = lu.U.nnz; ss_args['info']['l_nnz'] = L_nnz; ss_args['info']['u_nnz'] = U_nnz; ss_args['info']['lu_fill_factor'] = (L_nnz + U_nnz)/L.nnz; if settings.debug:; logger.debug('L NNZ: %i ; U NNZ: %i' % (L_nnz, U_nnz)); logger.debug('Fill factor: %f' % ((L_nnz + U_nnz)/orig_nnz)). else: # Use MKL solver; if len(ss_args['info']['perm']) !=0:; in_perm = np.arange(n**2, dtype=np.int32); else:; in_perm = None; _direct_start = time.time(); v = mkl_spsolve(L, b, perm = in_perm, verbose = ss_args['verbose']); _direct_end = time.time(); ss_args['info']['solution_time'] = _direct_end-_direct_start. if ss_args['return_info']:; ss_args['info']['residual_norm'] = la.norm(b - L*v). if ss_args['use_rcm']:; v = v[np.ix_(rev_perm,)]. data = dense2D_to_fastcsr_fmode(vec2mat(v), n, n); data = 0.5 * (data + data.H); if ss_args['return_info']:; return Qobj(data, dims=dims, isherm=True), ss_args['info']; else:; return Qobj(data, dims=dims, isherm=True). def _steadystate_direct_dense(L, ss_args):; """"""; Direct solver that use numpy dense matrices. Suitable for; small system, with a few states.; """"""; if settings.debug:; logger.debug('Starting direct dense solver.'). dim",MatchSource.WIKI,docs/4.2/modules/qutip/steadystate.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/steadystate.html
https://qutip.org/docs/4.2/modules/qutip/steadystate.html:14114,Testability,log,logger,14114,"args, has_mkl); if np.any(perm):; b = b[np.ix_(perm,)]; if np.any(perm2):; b = b[np.ix_(perm2,)]. ss_args['info']['permc_spec'] = ss_args['permc_spec']; ss_args['info']['drop_tol'] = ss_args['drop_tol']; ss_args['info']['diag_pivot_thresh'] = ss_args['diag_pivot_thresh']; ss_args['info']['fill_factor'] = ss_args['fill_factor']; ss_args['info']['ILU_MILU'] = ss_args['ILU_MILU']. if not has_mkl:; # Use superLU solver; orig_nnz = L.nnz; _direct_start = time.time(); lu = splu(L, permc_spec=ss_args['permc_spec'],; diag_pivot_thresh=ss_args['diag_pivot_thresh'],; options=dict(ILU_MILU=ss_args['ILU_MILU'])); v = lu.solve(b); _direct_end = time.time(); ss_args['info']['solution_time'] = _direct_end - _direct_start; if (settings.debug or ss_args['return_info']) and _scipy_check:; L_nnz = lu.L.nnz; U_nnz = lu.U.nnz; ss_args['info']['l_nnz'] = L_nnz; ss_args['info']['u_nnz'] = U_nnz; ss_args['info']['lu_fill_factor'] = (L_nnz + U_nnz)/L.nnz; if settings.debug:; logger.debug('L NNZ: %i ; U NNZ: %i' % (L_nnz, U_nnz)); logger.debug('Fill factor: %f' % ((L_nnz + U_nnz)/orig_nnz)). else: # Use MKL solver; if len(ss_args['info']['perm']) !=0:; in_perm = np.arange(n**2, dtype=np.int32); else:; in_perm = None; _direct_start = time.time(); v = mkl_spsolve(L, b, perm = in_perm, verbose = ss_args['verbose']); _direct_end = time.time(); ss_args['info']['solution_time'] = _direct_end-_direct_start. if ss_args['return_info']:; ss_args['info']['residual_norm'] = la.norm(b - L*v). if ss_args['use_rcm']:; v = v[np.ix_(rev_perm,)]. data = dense2D_to_fastcsr_fmode(vec2mat(v), n, n); data = 0.5 * (data + data.H); if ss_args['return_info']:; return Qobj(data, dims=dims, isherm=True), ss_args['info']; else:; return Qobj(data, dims=dims, isherm=True). def _steadystate_direct_dense(L, ss_args):; """"""; Direct solver that use numpy dense matrices. Suitable for; small system, with a few states.; """"""; if settings.debug:; logger.debug('Starting direct dense solver.'). dims = L.dims[0]; n = int(np.sqrt(L.sh",MatchSource.WIKI,docs/4.2/modules/qutip/steadystate.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/steadystate.html
https://qutip.org/docs/4.2/modules/qutip/steadystate.html:15008,Testability,log,logger,15008,"tor'] = (L_nnz + U_nnz)/L.nnz; if settings.debug:; logger.debug('L NNZ: %i ; U NNZ: %i' % (L_nnz, U_nnz)); logger.debug('Fill factor: %f' % ((L_nnz + U_nnz)/orig_nnz)). else: # Use MKL solver; if len(ss_args['info']['perm']) !=0:; in_perm = np.arange(n**2, dtype=np.int32); else:; in_perm = None; _direct_start = time.time(); v = mkl_spsolve(L, b, perm = in_perm, verbose = ss_args['verbose']); _direct_end = time.time(); ss_args['info']['solution_time'] = _direct_end-_direct_start. if ss_args['return_info']:; ss_args['info']['residual_norm'] = la.norm(b - L*v). if ss_args['use_rcm']:; v = v[np.ix_(rev_perm,)]. data = dense2D_to_fastcsr_fmode(vec2mat(v), n, n); data = 0.5 * (data + data.H); if ss_args['return_info']:; return Qobj(data, dims=dims, isherm=True), ss_args['info']; else:; return Qobj(data, dims=dims, isherm=True). def _steadystate_direct_dense(L, ss_args):; """"""; Direct solver that use numpy dense matrices. Suitable for; small system, with a few states.; """"""; if settings.debug:; logger.debug('Starting direct dense solver.'). dims = L.dims[0]; n = int(np.sqrt(L.shape[0])); b = np.zeros(n ** 2); b[0] = ss_args['weight']. L = L.data.todense(); L[0, :] = np.diag(ss_args['weight']*np.ones(n)).reshape((1, n ** 2)); _dense_start = time.time(); v = np.linalg.solve(L, b); _dense_end = time.time(); ss_args['info']['solution_time'] = _dense_end-_dense_start; if ss_args['return_info']:; ss_args['info']['residual_norm'] = la.norm(b - L*v); data = vec2mat(v); data = 0.5 * (data + data.conj().T). return Qobj(data, dims=dims, isherm=True). def _steadystate_eigen(L, ss_args):; """"""; Internal function for solving the steady state problem by; finding the eigenvector corresponding to the zero eigenvalue; of the Liouvillian using ARPACK.; """"""; ss_args['info'].pop('weight', None); if settings.debug:; logger.debug('Starting Eigen solver.'). dims = L.dims[0]; L = L.data.tocsc(). if ss_args['use_rcm']:; ss_args['info']['perm'].append('rcm'); if settings.debug:; old_band = sp_bandwidth(",MatchSource.WIKI,docs/4.2/modules/qutip/steadystate.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/steadystate.html
https://qutip.org/docs/4.2/modules/qutip/steadystate.html:15823,Testability,log,logger,15823,"ims, isherm=True). def _steadystate_direct_dense(L, ss_args):; """"""; Direct solver that use numpy dense matrices. Suitable for; small system, with a few states.; """"""; if settings.debug:; logger.debug('Starting direct dense solver.'). dims = L.dims[0]; n = int(np.sqrt(L.shape[0])); b = np.zeros(n ** 2); b[0] = ss_args['weight']. L = L.data.todense(); L[0, :] = np.diag(ss_args['weight']*np.ones(n)).reshape((1, n ** 2)); _dense_start = time.time(); v = np.linalg.solve(L, b); _dense_end = time.time(); ss_args['info']['solution_time'] = _dense_end-_dense_start; if ss_args['return_info']:; ss_args['info']['residual_norm'] = la.norm(b - L*v); data = vec2mat(v); data = 0.5 * (data + data.conj().T). return Qobj(data, dims=dims, isherm=True). def _steadystate_eigen(L, ss_args):; """"""; Internal function for solving the steady state problem by; finding the eigenvector corresponding to the zero eigenvalue; of the Liouvillian using ARPACK.; """"""; ss_args['info'].pop('weight', None); if settings.debug:; logger.debug('Starting Eigen solver.'). dims = L.dims[0]; L = L.data.tocsc(). if ss_args['use_rcm']:; ss_args['info']['perm'].append('rcm'); if settings.debug:; old_band = sp_bandwidth(L)[0]; logger.debug('Original bandwidth: %i' % old_band); perm = reverse_cuthill_mckee(L); rev_perm = np.argsort(perm); L = sp_permute(L, perm, perm, 'csc'); if settings.debug:; rcm_band = sp_bandwidth(L)[0]; logger.debug('RCM bandwidth: %i' % rcm_band); logger.debug('Bandwidth reduction factor: %f' %; (old_band/rcm_band)). _eigen_start = time.time(); eigval, eigvec = eigs(L, k=1, sigma=1e-15, tol=ss_args['tol'],; which='LM', maxiter=ss_args['maxiter']); _eigen_end = time.time(); ss_args['info']['solution_time'] = _eigen_end - _eigen_start; if ss_args['return_info']:; ss_args['info']['residual_norm'] = la.norm(L*eigvec); if ss_args['use_rcm']:; eigvec = eigvec[np.ix_(rev_perm,)]; _temp = vec2mat(eigvec); data = dense2D_to_fastcsr_fmode(_temp,_temp.shape[0], _temp.shape[1]); data = 0.5 * (data + data.H); ",MatchSource.WIKI,docs/4.2/modules/qutip/steadystate.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/steadystate.html
https://qutip.org/docs/4.2/modules/qutip/steadystate.html:16015,Testability,log,logger,16015,".debug:; logger.debug('Starting direct dense solver.'). dims = L.dims[0]; n = int(np.sqrt(L.shape[0])); b = np.zeros(n ** 2); b[0] = ss_args['weight']. L = L.data.todense(); L[0, :] = np.diag(ss_args['weight']*np.ones(n)).reshape((1, n ** 2)); _dense_start = time.time(); v = np.linalg.solve(L, b); _dense_end = time.time(); ss_args['info']['solution_time'] = _dense_end-_dense_start; if ss_args['return_info']:; ss_args['info']['residual_norm'] = la.norm(b - L*v); data = vec2mat(v); data = 0.5 * (data + data.conj().T). return Qobj(data, dims=dims, isherm=True). def _steadystate_eigen(L, ss_args):; """"""; Internal function for solving the steady state problem by; finding the eigenvector corresponding to the zero eigenvalue; of the Liouvillian using ARPACK.; """"""; ss_args['info'].pop('weight', None); if settings.debug:; logger.debug('Starting Eigen solver.'). dims = L.dims[0]; L = L.data.tocsc(). if ss_args['use_rcm']:; ss_args['info']['perm'].append('rcm'); if settings.debug:; old_band = sp_bandwidth(L)[0]; logger.debug('Original bandwidth: %i' % old_band); perm = reverse_cuthill_mckee(L); rev_perm = np.argsort(perm); L = sp_permute(L, perm, perm, 'csc'); if settings.debug:; rcm_band = sp_bandwidth(L)[0]; logger.debug('RCM bandwidth: %i' % rcm_band); logger.debug('Bandwidth reduction factor: %f' %; (old_band/rcm_band)). _eigen_start = time.time(); eigval, eigvec = eigs(L, k=1, sigma=1e-15, tol=ss_args['tol'],; which='LM', maxiter=ss_args['maxiter']); _eigen_end = time.time(); ss_args['info']['solution_time'] = _eigen_end - _eigen_start; if ss_args['return_info']:; ss_args['info']['residual_norm'] = la.norm(L*eigvec); if ss_args['use_rcm']:; eigvec = eigvec[np.ix_(rev_perm,)]; _temp = vec2mat(eigvec); data = dense2D_to_fastcsr_fmode(_temp,_temp.shape[0], _temp.shape[1]); data = 0.5 * (data + data.H); out = Qobj(data, dims=dims, isherm=True); if ss_args['return_info']:; return out/out.tr(), ss_args['info']; else:; return out/out.tr(). def _iterative_precondition(A, n, ss_arg",MatchSource.WIKI,docs/4.2/modules/qutip/steadystate.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/steadystate.html
https://qutip.org/docs/4.2/modules/qutip/steadystate.html:16217,Testability,log,logger,16217,"eight']*np.ones(n)).reshape((1, n ** 2)); _dense_start = time.time(); v = np.linalg.solve(L, b); _dense_end = time.time(); ss_args['info']['solution_time'] = _dense_end-_dense_start; if ss_args['return_info']:; ss_args['info']['residual_norm'] = la.norm(b - L*v); data = vec2mat(v); data = 0.5 * (data + data.conj().T). return Qobj(data, dims=dims, isherm=True). def _steadystate_eigen(L, ss_args):; """"""; Internal function for solving the steady state problem by; finding the eigenvector corresponding to the zero eigenvalue; of the Liouvillian using ARPACK.; """"""; ss_args['info'].pop('weight', None); if settings.debug:; logger.debug('Starting Eigen solver.'). dims = L.dims[0]; L = L.data.tocsc(). if ss_args['use_rcm']:; ss_args['info']['perm'].append('rcm'); if settings.debug:; old_band = sp_bandwidth(L)[0]; logger.debug('Original bandwidth: %i' % old_band); perm = reverse_cuthill_mckee(L); rev_perm = np.argsort(perm); L = sp_permute(L, perm, perm, 'csc'); if settings.debug:; rcm_band = sp_bandwidth(L)[0]; logger.debug('RCM bandwidth: %i' % rcm_band); logger.debug('Bandwidth reduction factor: %f' %; (old_band/rcm_band)). _eigen_start = time.time(); eigval, eigvec = eigs(L, k=1, sigma=1e-15, tol=ss_args['tol'],; which='LM', maxiter=ss_args['maxiter']); _eigen_end = time.time(); ss_args['info']['solution_time'] = _eigen_end - _eigen_start; if ss_args['return_info']:; ss_args['info']['residual_norm'] = la.norm(L*eigvec); if ss_args['use_rcm']:; eigvec = eigvec[np.ix_(rev_perm,)]; _temp = vec2mat(eigvec); data = dense2D_to_fastcsr_fmode(_temp,_temp.shape[0], _temp.shape[1]); data = 0.5 * (data + data.H); out = Qobj(data, dims=dims, isherm=True); if ss_args['return_info']:; return out/out.tr(), ss_args['info']; else:; return out/out.tr(). def _iterative_precondition(A, n, ss_args):; """"""; Internal function for preconditioning the steadystate problem for use; with iterative solvers.; """"""; if settings.debug:; logger.debug('Starting preconditioner.'); _precond_start = time.time();",MatchSource.WIKI,docs/4.2/modules/qutip/steadystate.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/steadystate.html
https://qutip.org/docs/4.2/modules/qutip/steadystate.html:16263,Testability,log,logger,16263,"se_start = time.time(); v = np.linalg.solve(L, b); _dense_end = time.time(); ss_args['info']['solution_time'] = _dense_end-_dense_start; if ss_args['return_info']:; ss_args['info']['residual_norm'] = la.norm(b - L*v); data = vec2mat(v); data = 0.5 * (data + data.conj().T). return Qobj(data, dims=dims, isherm=True). def _steadystate_eigen(L, ss_args):; """"""; Internal function for solving the steady state problem by; finding the eigenvector corresponding to the zero eigenvalue; of the Liouvillian using ARPACK.; """"""; ss_args['info'].pop('weight', None); if settings.debug:; logger.debug('Starting Eigen solver.'). dims = L.dims[0]; L = L.data.tocsc(). if ss_args['use_rcm']:; ss_args['info']['perm'].append('rcm'); if settings.debug:; old_band = sp_bandwidth(L)[0]; logger.debug('Original bandwidth: %i' % old_band); perm = reverse_cuthill_mckee(L); rev_perm = np.argsort(perm); L = sp_permute(L, perm, perm, 'csc'); if settings.debug:; rcm_band = sp_bandwidth(L)[0]; logger.debug('RCM bandwidth: %i' % rcm_band); logger.debug('Bandwidth reduction factor: %f' %; (old_band/rcm_band)). _eigen_start = time.time(); eigval, eigvec = eigs(L, k=1, sigma=1e-15, tol=ss_args['tol'],; which='LM', maxiter=ss_args['maxiter']); _eigen_end = time.time(); ss_args['info']['solution_time'] = _eigen_end - _eigen_start; if ss_args['return_info']:; ss_args['info']['residual_norm'] = la.norm(L*eigvec); if ss_args['use_rcm']:; eigvec = eigvec[np.ix_(rev_perm,)]; _temp = vec2mat(eigvec); data = dense2D_to_fastcsr_fmode(_temp,_temp.shape[0], _temp.shape[1]); data = 0.5 * (data + data.H); out = Qobj(data, dims=dims, isherm=True); if ss_args['return_info']:; return out/out.tr(), ss_args['info']; else:; return out/out.tr(). def _iterative_precondition(A, n, ss_args):; """"""; Internal function for preconditioning the steadystate problem for use; with iterative solvers.; """"""; if settings.debug:; logger.debug('Starting preconditioner.'); _precond_start = time.time(); try:; P = spilu(A, permc_spec=ss_args['permc_",MatchSource.WIKI,docs/4.2/modules/qutip/steadystate.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/steadystate.html
https://qutip.org/docs/4.2/modules/qutip/steadystate.html:17130,Testability,log,logger,17130," = sp_permute(L, perm, perm, 'csc'); if settings.debug:; rcm_band = sp_bandwidth(L)[0]; logger.debug('RCM bandwidth: %i' % rcm_band); logger.debug('Bandwidth reduction factor: %f' %; (old_band/rcm_band)). _eigen_start = time.time(); eigval, eigvec = eigs(L, k=1, sigma=1e-15, tol=ss_args['tol'],; which='LM', maxiter=ss_args['maxiter']); _eigen_end = time.time(); ss_args['info']['solution_time'] = _eigen_end - _eigen_start; if ss_args['return_info']:; ss_args['info']['residual_norm'] = la.norm(L*eigvec); if ss_args['use_rcm']:; eigvec = eigvec[np.ix_(rev_perm,)]; _temp = vec2mat(eigvec); data = dense2D_to_fastcsr_fmode(_temp,_temp.shape[0], _temp.shape[1]); data = 0.5 * (data + data.H); out = Qobj(data, dims=dims, isherm=True); if ss_args['return_info']:; return out/out.tr(), ss_args['info']; else:; return out/out.tr(). def _iterative_precondition(A, n, ss_args):; """"""; Internal function for preconditioning the steadystate problem for use; with iterative solvers.; """"""; if settings.debug:; logger.debug('Starting preconditioner.'); _precond_start = time.time(); try:; P = spilu(A, permc_spec=ss_args['permc_spec'],; drop_tol=ss_args['drop_tol'],; diag_pivot_thresh=ss_args['diag_pivot_thresh'],; fill_factor=ss_args['fill_factor'],; options=dict(ILU_MILU=ss_args['ILU_MILU'])). P_x = lambda x: P.solve(x); M = LinearOperator((n ** 2, n ** 2), matvec=P_x); _precond_end = time.time(); ss_args['info']['permc_spec'] = ss_args['permc_spec']; ss_args['info']['drop_tol'] = ss_args['drop_tol']; ss_args['info']['diag_pivot_thresh'] = ss_args['diag_pivot_thresh']; ss_args['info']['fill_factor'] = ss_args['fill_factor']; ss_args['info']['ILU_MILU'] = ss_args['ILU_MILU']; ss_args['info']['precond_time'] = _precond_end-_precond_start. if settings.debug or ss_args['return_info']:; if settings.debug:; logger.debug('Preconditioning succeeded.'); logger.debug('Precond. time: %f' %; (_precond_end - _precond_start)). if _scipy_check:; L_nnz = P.L.nnz; U_nnz = P.U.nnz; ss_args['info']['l_nnz'] = L",MatchSource.WIKI,docs/4.2/modules/qutip/steadystate.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/steadystate.html
https://qutip.org/docs/4.2/modules/qutip/steadystate.html:17936,Testability,log,logger,17936,":; return out/out.tr(). def _iterative_precondition(A, n, ss_args):; """"""; Internal function for preconditioning the steadystate problem for use; with iterative solvers.; """"""; if settings.debug:; logger.debug('Starting preconditioner.'); _precond_start = time.time(); try:; P = spilu(A, permc_spec=ss_args['permc_spec'],; drop_tol=ss_args['drop_tol'],; diag_pivot_thresh=ss_args['diag_pivot_thresh'],; fill_factor=ss_args['fill_factor'],; options=dict(ILU_MILU=ss_args['ILU_MILU'])). P_x = lambda x: P.solve(x); M = LinearOperator((n ** 2, n ** 2), matvec=P_x); _precond_end = time.time(); ss_args['info']['permc_spec'] = ss_args['permc_spec']; ss_args['info']['drop_tol'] = ss_args['drop_tol']; ss_args['info']['diag_pivot_thresh'] = ss_args['diag_pivot_thresh']; ss_args['info']['fill_factor'] = ss_args['fill_factor']; ss_args['info']['ILU_MILU'] = ss_args['ILU_MILU']; ss_args['info']['precond_time'] = _precond_end-_precond_start. if settings.debug or ss_args['return_info']:; if settings.debug:; logger.debug('Preconditioning succeeded.'); logger.debug('Precond. time: %f' %; (_precond_end - _precond_start)). if _scipy_check:; L_nnz = P.L.nnz; U_nnz = P.U.nnz; ss_args['info']['l_nnz'] = L_nnz; ss_args['info']['u_nnz'] = U_nnz; ss_args['info']['ilu_fill_factor'] = (L_nnz+U_nnz)/A.nnz; e = np.ones(n ** 2, dtype=int); condest = la.norm(M*e, np.inf); ss_args['info']['ilu_condest'] = condest; if settings.debug:; logger.debug('L NNZ: %i ; U NNZ: %i' % (L_nnz, U_nnz)); logger.debug('Fill factor: %f' % ((L_nnz+U_nnz)/A.nnz)); logger.debug('iLU condest: %f' % condest). except:; raise Exception(""Failed to build preconditioner. Try increasing "" +; ""fill_factor and/or drop_tol.""). return M, ss_args. def _steadystate_iterative(L, ss_args):; """"""; Iterative steady state solver using the GMRES, LGMRES, or BICGSTAB; algorithm and a sparse incomplete LU preconditioner.; """"""; ss_iters = {'iter': 0}. def _iter_count(r):; ss_iters['iter'] += 1; return. if settings.debug:; logger.debug('Starting %s s",MatchSource.WIKI,docs/4.2/modules/qutip/steadystate.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/steadystate.html
https://qutip.org/docs/4.2/modules/qutip/steadystate.html:17980,Testability,log,logger,17980,"ition(A, n, ss_args):; """"""; Internal function for preconditioning the steadystate problem for use; with iterative solvers.; """"""; if settings.debug:; logger.debug('Starting preconditioner.'); _precond_start = time.time(); try:; P = spilu(A, permc_spec=ss_args['permc_spec'],; drop_tol=ss_args['drop_tol'],; diag_pivot_thresh=ss_args['diag_pivot_thresh'],; fill_factor=ss_args['fill_factor'],; options=dict(ILU_MILU=ss_args['ILU_MILU'])). P_x = lambda x: P.solve(x); M = LinearOperator((n ** 2, n ** 2), matvec=P_x); _precond_end = time.time(); ss_args['info']['permc_spec'] = ss_args['permc_spec']; ss_args['info']['drop_tol'] = ss_args['drop_tol']; ss_args['info']['diag_pivot_thresh'] = ss_args['diag_pivot_thresh']; ss_args['info']['fill_factor'] = ss_args['fill_factor']; ss_args['info']['ILU_MILU'] = ss_args['ILU_MILU']; ss_args['info']['precond_time'] = _precond_end-_precond_start. if settings.debug or ss_args['return_info']:; if settings.debug:; logger.debug('Preconditioning succeeded.'); logger.debug('Precond. time: %f' %; (_precond_end - _precond_start)). if _scipy_check:; L_nnz = P.L.nnz; U_nnz = P.U.nnz; ss_args['info']['l_nnz'] = L_nnz; ss_args['info']['u_nnz'] = U_nnz; ss_args['info']['ilu_fill_factor'] = (L_nnz+U_nnz)/A.nnz; e = np.ones(n ** 2, dtype=int); condest = la.norm(M*e, np.inf); ss_args['info']['ilu_condest'] = condest; if settings.debug:; logger.debug('L NNZ: %i ; U NNZ: %i' % (L_nnz, U_nnz)); logger.debug('Fill factor: %f' % ((L_nnz+U_nnz)/A.nnz)); logger.debug('iLU condest: %f' % condest). except:; raise Exception(""Failed to build preconditioner. Try increasing "" +; ""fill_factor and/or drop_tol.""). return M, ss_args. def _steadystate_iterative(L, ss_args):; """"""; Iterative steady state solver using the GMRES, LGMRES, or BICGSTAB; algorithm and a sparse incomplete LU preconditioner.; """"""; ss_iters = {'iter': 0}. def _iter_count(r):; ss_iters['iter'] += 1; return. if settings.debug:; logger.debug('Starting %s solver.' % ss_args['method']). dims = L.dims[0]",MatchSource.WIKI,docs/4.2/modules/qutip/steadystate.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/steadystate.html
https://qutip.org/docs/4.2/modules/qutip/steadystate.html:18354,Testability,log,logger,18354,"gs['fill_factor'],; options=dict(ILU_MILU=ss_args['ILU_MILU'])). P_x = lambda x: P.solve(x); M = LinearOperator((n ** 2, n ** 2), matvec=P_x); _precond_end = time.time(); ss_args['info']['permc_spec'] = ss_args['permc_spec']; ss_args['info']['drop_tol'] = ss_args['drop_tol']; ss_args['info']['diag_pivot_thresh'] = ss_args['diag_pivot_thresh']; ss_args['info']['fill_factor'] = ss_args['fill_factor']; ss_args['info']['ILU_MILU'] = ss_args['ILU_MILU']; ss_args['info']['precond_time'] = _precond_end-_precond_start. if settings.debug or ss_args['return_info']:; if settings.debug:; logger.debug('Preconditioning succeeded.'); logger.debug('Precond. time: %f' %; (_precond_end - _precond_start)). if _scipy_check:; L_nnz = P.L.nnz; U_nnz = P.U.nnz; ss_args['info']['l_nnz'] = L_nnz; ss_args['info']['u_nnz'] = U_nnz; ss_args['info']['ilu_fill_factor'] = (L_nnz+U_nnz)/A.nnz; e = np.ones(n ** 2, dtype=int); condest = la.norm(M*e, np.inf); ss_args['info']['ilu_condest'] = condest; if settings.debug:; logger.debug('L NNZ: %i ; U NNZ: %i' % (L_nnz, U_nnz)); logger.debug('Fill factor: %f' % ((L_nnz+U_nnz)/A.nnz)); logger.debug('iLU condest: %f' % condest). except:; raise Exception(""Failed to build preconditioner. Try increasing "" +; ""fill_factor and/or drop_tol.""). return M, ss_args. def _steadystate_iterative(L, ss_args):; """"""; Iterative steady state solver using the GMRES, LGMRES, or BICGSTAB; algorithm and a sparse incomplete LU preconditioner.; """"""; ss_iters = {'iter': 0}. def _iter_count(r):; ss_iters['iter'] += 1; return. if settings.debug:; logger.debug('Starting %s solver.' % ss_args['method']). dims = L.dims[0]; n = int(np.sqrt(L.shape[0])); b = np.zeros(n ** 2); b[0] = ss_args['weight']. L, perm, perm2, rev_perm, ss_args = _steadystate_LU_liouvillian(L, ss_args); if np.any(perm):; b = b[np.ix_(perm,)]; if np.any(perm2):; b = b[np.ix_(perm2,)]. use_solver(assumeSortedIndices=True). if ss_args['M'] is None and ss_args['use_precond']:; ss_args['M'], ss_args = _iterative_precond",MatchSource.WIKI,docs/4.2/modules/qutip/steadystate.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/steadystate.html
https://qutip.org/docs/4.2/modules/qutip/steadystate.html:18410,Testability,log,logger,18410,"_MILU=ss_args['ILU_MILU'])). P_x = lambda x: P.solve(x); M = LinearOperator((n ** 2, n ** 2), matvec=P_x); _precond_end = time.time(); ss_args['info']['permc_spec'] = ss_args['permc_spec']; ss_args['info']['drop_tol'] = ss_args['drop_tol']; ss_args['info']['diag_pivot_thresh'] = ss_args['diag_pivot_thresh']; ss_args['info']['fill_factor'] = ss_args['fill_factor']; ss_args['info']['ILU_MILU'] = ss_args['ILU_MILU']; ss_args['info']['precond_time'] = _precond_end-_precond_start. if settings.debug or ss_args['return_info']:; if settings.debug:; logger.debug('Preconditioning succeeded.'); logger.debug('Precond. time: %f' %; (_precond_end - _precond_start)). if _scipy_check:; L_nnz = P.L.nnz; U_nnz = P.U.nnz; ss_args['info']['l_nnz'] = L_nnz; ss_args['info']['u_nnz'] = U_nnz; ss_args['info']['ilu_fill_factor'] = (L_nnz+U_nnz)/A.nnz; e = np.ones(n ** 2, dtype=int); condest = la.norm(M*e, np.inf); ss_args['info']['ilu_condest'] = condest; if settings.debug:; logger.debug('L NNZ: %i ; U NNZ: %i' % (L_nnz, U_nnz)); logger.debug('Fill factor: %f' % ((L_nnz+U_nnz)/A.nnz)); logger.debug('iLU condest: %f' % condest). except:; raise Exception(""Failed to build preconditioner. Try increasing "" +; ""fill_factor and/or drop_tol.""). return M, ss_args. def _steadystate_iterative(L, ss_args):; """"""; Iterative steady state solver using the GMRES, LGMRES, or BICGSTAB; algorithm and a sparse incomplete LU preconditioner.; """"""; ss_iters = {'iter': 0}. def _iter_count(r):; ss_iters['iter'] += 1; return. if settings.debug:; logger.debug('Starting %s solver.' % ss_args['method']). dims = L.dims[0]; n = int(np.sqrt(L.shape[0])); b = np.zeros(n ** 2); b[0] = ss_args['weight']. L, perm, perm2, rev_perm, ss_args = _steadystate_LU_liouvillian(L, ss_args); if np.any(perm):; b = b[np.ix_(perm,)]; if np.any(perm2):; b = b[np.ix_(perm2,)]. use_solver(assumeSortedIndices=True). if ss_args['M'] is None and ss_args['use_precond']:; ss_args['M'], ss_args = _iterative_precondition(L, n, ss_args); if ss_args['M",MatchSource.WIKI,docs/4.2/modules/qutip/steadystate.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/steadystate.html
https://qutip.org/docs/4.2/modules/qutip/steadystate.html:18467,Testability,log,logger,18467," ** 2, n ** 2), matvec=P_x); _precond_end = time.time(); ss_args['info']['permc_spec'] = ss_args['permc_spec']; ss_args['info']['drop_tol'] = ss_args['drop_tol']; ss_args['info']['diag_pivot_thresh'] = ss_args['diag_pivot_thresh']; ss_args['info']['fill_factor'] = ss_args['fill_factor']; ss_args['info']['ILU_MILU'] = ss_args['ILU_MILU']; ss_args['info']['precond_time'] = _precond_end-_precond_start. if settings.debug or ss_args['return_info']:; if settings.debug:; logger.debug('Preconditioning succeeded.'); logger.debug('Precond. time: %f' %; (_precond_end - _precond_start)). if _scipy_check:; L_nnz = P.L.nnz; U_nnz = P.U.nnz; ss_args['info']['l_nnz'] = L_nnz; ss_args['info']['u_nnz'] = U_nnz; ss_args['info']['ilu_fill_factor'] = (L_nnz+U_nnz)/A.nnz; e = np.ones(n ** 2, dtype=int); condest = la.norm(M*e, np.inf); ss_args['info']['ilu_condest'] = condest; if settings.debug:; logger.debug('L NNZ: %i ; U NNZ: %i' % (L_nnz, U_nnz)); logger.debug('Fill factor: %f' % ((L_nnz+U_nnz)/A.nnz)); logger.debug('iLU condest: %f' % condest). except:; raise Exception(""Failed to build preconditioner. Try increasing "" +; ""fill_factor and/or drop_tol.""). return M, ss_args. def _steadystate_iterative(L, ss_args):; """"""; Iterative steady state solver using the GMRES, LGMRES, or BICGSTAB; algorithm and a sparse incomplete LU preconditioner.; """"""; ss_iters = {'iter': 0}. def _iter_count(r):; ss_iters['iter'] += 1; return. if settings.debug:; logger.debug('Starting %s solver.' % ss_args['method']). dims = L.dims[0]; n = int(np.sqrt(L.shape[0])); b = np.zeros(n ** 2); b[0] = ss_args['weight']. L, perm, perm2, rev_perm, ss_args = _steadystate_LU_liouvillian(L, ss_args); if np.any(perm):; b = b[np.ix_(perm,)]; if np.any(perm2):; b = b[np.ix_(perm2,)]. use_solver(assumeSortedIndices=True). if ss_args['M'] is None and ss_args['use_precond']:; ss_args['M'], ss_args = _iterative_precondition(L, n, ss_args); if ss_args['M'] is None:; warnings.warn(""Preconditioning failed. Continuing without."",; Use",MatchSource.WIKI,docs/4.2/modules/qutip/steadystate.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/steadystate.html
https://qutip.org/docs/4.2/modules/qutip/steadystate.html:18909,Testability,log,logger,18909,"nfo']:; if settings.debug:; logger.debug('Preconditioning succeeded.'); logger.debug('Precond. time: %f' %; (_precond_end - _precond_start)). if _scipy_check:; L_nnz = P.L.nnz; U_nnz = P.U.nnz; ss_args['info']['l_nnz'] = L_nnz; ss_args['info']['u_nnz'] = U_nnz; ss_args['info']['ilu_fill_factor'] = (L_nnz+U_nnz)/A.nnz; e = np.ones(n ** 2, dtype=int); condest = la.norm(M*e, np.inf); ss_args['info']['ilu_condest'] = condest; if settings.debug:; logger.debug('L NNZ: %i ; U NNZ: %i' % (L_nnz, U_nnz)); logger.debug('Fill factor: %f' % ((L_nnz+U_nnz)/A.nnz)); logger.debug('iLU condest: %f' % condest). except:; raise Exception(""Failed to build preconditioner. Try increasing "" +; ""fill_factor and/or drop_tol.""). return M, ss_args. def _steadystate_iterative(L, ss_args):; """"""; Iterative steady state solver using the GMRES, LGMRES, or BICGSTAB; algorithm and a sparse incomplete LU preconditioner.; """"""; ss_iters = {'iter': 0}. def _iter_count(r):; ss_iters['iter'] += 1; return. if settings.debug:; logger.debug('Starting %s solver.' % ss_args['method']). dims = L.dims[0]; n = int(np.sqrt(L.shape[0])); b = np.zeros(n ** 2); b[0] = ss_args['weight']. L, perm, perm2, rev_perm, ss_args = _steadystate_LU_liouvillian(L, ss_args); if np.any(perm):; b = b[np.ix_(perm,)]; if np.any(perm2):; b = b[np.ix_(perm2,)]. use_solver(assumeSortedIndices=True). if ss_args['M'] is None and ss_args['use_precond']:; ss_args['M'], ss_args = _iterative_precondition(L, n, ss_args); if ss_args['M'] is None:; warnings.warn(""Preconditioning failed. Continuing without."",; UserWarning). # Select iterative solver type; _iter_start = time.time(); if ss_args['method'] == 'iterative-gmres':; v, check = gmres(L, b, tol=ss_args['tol'], M=ss_args['M'],; x0=ss_args['x0'], restart=ss_args['restart'],; maxiter=ss_args['maxiter'], callback=_iter_count). elif ss_args['method'] == 'iterative-lgmres':; v, check = lgmres(L, b, tol=ss_args['tol'], M=ss_args['M'],; x0=ss_args['x0'], maxiter=ss_args['maxiter'],; callback=_iter_",MatchSource.WIKI,docs/4.2/modules/qutip/steadystate.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/steadystate.html
https://qutip.org/docs/4.2/modules/qutip/steadystate.html:20614,Testability,log,logger,20614,"gs['tol'], M=ss_args['M'],; x0=ss_args['x0'], restart=ss_args['restart'],; maxiter=ss_args['maxiter'], callback=_iter_count). elif ss_args['method'] == 'iterative-lgmres':; v, check = lgmres(L, b, tol=ss_args['tol'], M=ss_args['M'],; x0=ss_args['x0'], maxiter=ss_args['maxiter'],; callback=_iter_count). elif ss_args['method'] == 'iterative-bicgstab':; v, check = bicgstab(L, b, tol=ss_args['tol'], M=ss_args['M'],; x0=ss_args['x0'],; maxiter=ss_args['maxiter'], callback=_iter_count); else:; raise Exception(""Invalid iterative solver method.""); _iter_end = time.time(). ss_args['info']['iter_time'] = _iter_end - _iter_start; if ss_args['info']['precond_time'] is not None:; ss_args['info']['solution_time'] = (ss_args['info']['iter_time'] +; ss_args['info']['precond_time']); else:; ss_args['info']['solution_time'] = ss_args['info']['iter_time']; ss_args['info']['iterations'] = ss_iters['iter']; if ss_args['return_info']:; ss_args['info']['residual_norm'] = la.norm(b - L*v). if settings.debug:; logger.debug('Number of Iterations: %i' % ss_iters['iter']); logger.debug('Iteration. time: %f' % (_iter_end - _iter_start)). if check > 0:; raise Exception(""Steadystate error: Did not reach tolerance after "" +; str(ss_args['maxiter']) + "" steps."" +; ""\nResidual norm: "" +; str(ss_args['info']['residual_norm'])). elif check < 0:; raise Exception(; ""Steadystate error: Failed with fatal error: "" + str(check) + "".""). if ss_args['use_rcm']:; v = v[np.ix_(rev_perm,)]. data = vec2mat(v); data = 0.5 * (data + data.conj().T); if ss_args['return_info']:; return Qobj(data, dims=dims, isherm=True), ss_args['info']; else:; return Qobj(data, dims=dims, isherm=True). def _steadystate_svd_dense(L, ss_args):; """"""; Find the steady state(s) of an open quantum system by solving for the; nullspace of the Liouvillian.; """"""; ss_args['info'].pop('weight', None); atol = 1e-12; rtol = 1e-12; if settings.debug:; logger.debug('Starting SVD solver.'); _svd_start = time.time(); u, s, vh = svd(L.full(), full_matrice",MatchSource.WIKI,docs/4.2/modules/qutip/steadystate.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/steadystate.html
https://qutip.org/docs/4.2/modules/qutip/steadystate.html:20675,Testability,log,logger,20675,"['x0'], restart=ss_args['restart'],; maxiter=ss_args['maxiter'], callback=_iter_count). elif ss_args['method'] == 'iterative-lgmres':; v, check = lgmres(L, b, tol=ss_args['tol'], M=ss_args['M'],; x0=ss_args['x0'], maxiter=ss_args['maxiter'],; callback=_iter_count). elif ss_args['method'] == 'iterative-bicgstab':; v, check = bicgstab(L, b, tol=ss_args['tol'], M=ss_args['M'],; x0=ss_args['x0'],; maxiter=ss_args['maxiter'], callback=_iter_count); else:; raise Exception(""Invalid iterative solver method.""); _iter_end = time.time(). ss_args['info']['iter_time'] = _iter_end - _iter_start; if ss_args['info']['precond_time'] is not None:; ss_args['info']['solution_time'] = (ss_args['info']['iter_time'] +; ss_args['info']['precond_time']); else:; ss_args['info']['solution_time'] = ss_args['info']['iter_time']; ss_args['info']['iterations'] = ss_iters['iter']; if ss_args['return_info']:; ss_args['info']['residual_norm'] = la.norm(b - L*v). if settings.debug:; logger.debug('Number of Iterations: %i' % ss_iters['iter']); logger.debug('Iteration. time: %f' % (_iter_end - _iter_start)). if check > 0:; raise Exception(""Steadystate error: Did not reach tolerance after "" +; str(ss_args['maxiter']) + "" steps."" +; ""\nResidual norm: "" +; str(ss_args['info']['residual_norm'])). elif check < 0:; raise Exception(; ""Steadystate error: Failed with fatal error: "" + str(check) + "".""). if ss_args['use_rcm']:; v = v[np.ix_(rev_perm,)]. data = vec2mat(v); data = 0.5 * (data + data.conj().T); if ss_args['return_info']:; return Qobj(data, dims=dims, isherm=True), ss_args['info']; else:; return Qobj(data, dims=dims, isherm=True). def _steadystate_svd_dense(L, ss_args):; """"""; Find the steady state(s) of an open quantum system by solving for the; nullspace of the Liouvillian.; """"""; ss_args['info'].pop('weight', None); atol = 1e-12; rtol = 1e-12; if settings.debug:; logger.debug('Starting SVD solver.'); _svd_start = time.time(); u, s, vh = svd(L.full(), full_matrices=False); tol = max(atol, rtol * s[0])",MatchSource.WIKI,docs/4.2/modules/qutip/steadystate.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/steadystate.html
https://qutip.org/docs/4.2/modules/qutip/steadystate.html:21513,Testability,log,logger,21513," if ss_args['return_info']:; ss_args['info']['residual_norm'] = la.norm(b - L*v). if settings.debug:; logger.debug('Number of Iterations: %i' % ss_iters['iter']); logger.debug('Iteration. time: %f' % (_iter_end - _iter_start)). if check > 0:; raise Exception(""Steadystate error: Did not reach tolerance after "" +; str(ss_args['maxiter']) + "" steps."" +; ""\nResidual norm: "" +; str(ss_args['info']['residual_norm'])). elif check < 0:; raise Exception(; ""Steadystate error: Failed with fatal error: "" + str(check) + "".""). if ss_args['use_rcm']:; v = v[np.ix_(rev_perm,)]. data = vec2mat(v); data = 0.5 * (data + data.conj().T); if ss_args['return_info']:; return Qobj(data, dims=dims, isherm=True), ss_args['info']; else:; return Qobj(data, dims=dims, isherm=True). def _steadystate_svd_dense(L, ss_args):; """"""; Find the steady state(s) of an open quantum system by solving for the; nullspace of the Liouvillian.; """"""; ss_args['info'].pop('weight', None); atol = 1e-12; rtol = 1e-12; if settings.debug:; logger.debug('Starting SVD solver.'); _svd_start = time.time(); u, s, vh = svd(L.full(), full_matrices=False); tol = max(atol, rtol * s[0]); nnz = (s >= tol).sum(); ns = vh[nnz:].conj().T; _svd_end = time.time(); ss_args['info']['solution_time'] = _svd_end-_svd_start; if ss_args['all_states']:; rhoss_list = []; for n in range(ns.shape[1]):; rhoss = Qobj(vec2mat(ns[:, n]), dims=L.dims[0]); rhoss_list.append(rhoss / rhoss.tr()); if ss_args['return_info']:; return rhoss_list, ss_args['info']; else:; if ss_args['return_info']:; return rhoss_list, ss_args['info']; else:; return rhoss_list; else:; rhoss = Qobj(vec2mat(ns[:, 0]), dims=L.dims[0]); return rhoss / rhoss.tr(). def _steadystate_power_liouvillian(L, ss_args, has_mkl=0):; """"""Creates modified Liouvillian for power based SS methods.; """"""; perm = None; perm2 = None; rev_perm = None; n = L.shape[0]; if has_mkl:; L = L.data - (1e-15) * sp.eye(n, n, format='csr'); kind = 'csr'; else:; L = L.data.tocsc() - (1e-15) * sp.eye(n, n, format='cs",MatchSource.WIKI,docs/4.2/modules/qutip/steadystate.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/steadystate.html
https://qutip.org/docs/4.2/modules/qutip/steadystate.html:22629,Testability,log,logger,22629,"), full_matrices=False); tol = max(atol, rtol * s[0]); nnz = (s >= tol).sum(); ns = vh[nnz:].conj().T; _svd_end = time.time(); ss_args['info']['solution_time'] = _svd_end-_svd_start; if ss_args['all_states']:; rhoss_list = []; for n in range(ns.shape[1]):; rhoss = Qobj(vec2mat(ns[:, n]), dims=L.dims[0]); rhoss_list.append(rhoss / rhoss.tr()); if ss_args['return_info']:; return rhoss_list, ss_args['info']; else:; if ss_args['return_info']:; return rhoss_list, ss_args['info']; else:; return rhoss_list; else:; rhoss = Qobj(vec2mat(ns[:, 0]), dims=L.dims[0]); return rhoss / rhoss.tr(). def _steadystate_power_liouvillian(L, ss_args, has_mkl=0):; """"""Creates modified Liouvillian for power based SS methods.; """"""; perm = None; perm2 = None; rev_perm = None; n = L.shape[0]; if has_mkl:; L = L.data - (1e-15) * sp.eye(n, n, format='csr'); kind = 'csr'; else:; L = L.data.tocsc() - (1e-15) * sp.eye(n, n, format='csc'); kind = 'csc'; orig_nnz = L.nnz; if settings.debug:; old_band = sp_bandwidth(L)[0]; old_pro = sp_profile(L)[0]; logger.debug('Original bandwidth: %i' % old_band); logger.debug('Original profile: %i' % old_pro); ; if ss_args['use_wbm']:; if settings.debug:; logger.debug('Calculating Weighted Bipartite Matching ordering...'); _wbm_start = time.time(); perm = weighted_bipartite_matching(L); _wbm_end = time.time(); L = sp_permute(L, perm, [], kind); ss_args['info']['perm'].append('wbm'); ss_args['info']['wbm_time'] = _wbm_end-_wbm_start; if settings.debug:; wbm_band = sp_bandwidth(L)[0]; wbm_pro = sp_profile(L)[0]; logger.debug('WBM bandwidth: %i' % wbm_band); logger.debug('WBM profile: %i' % wbm_pro); ; if ss_args['use_rcm']:; if settings.debug:; logger.debug('Calculating Reverse Cuthill-Mckee ordering...'); ss_args['info']['perm'].append('rcm'); _rcm_start = time.time(); perm2 = reverse_cuthill_mckee(L); _rcm_end = time.time(); ss_args['info']['rcm_time'] = _rcm_end-_rcm_start; rev_perm = np.argsort(perm2); L = sp_permute(L, perm2, perm2, kind); if settings.debug:; ne",MatchSource.WIKI,docs/4.2/modules/qutip/steadystate.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/steadystate.html
https://qutip.org/docs/4.2/modules/qutip/steadystate.html:22680,Testability,log,logger,22680,"s >= tol).sum(); ns = vh[nnz:].conj().T; _svd_end = time.time(); ss_args['info']['solution_time'] = _svd_end-_svd_start; if ss_args['all_states']:; rhoss_list = []; for n in range(ns.shape[1]):; rhoss = Qobj(vec2mat(ns[:, n]), dims=L.dims[0]); rhoss_list.append(rhoss / rhoss.tr()); if ss_args['return_info']:; return rhoss_list, ss_args['info']; else:; if ss_args['return_info']:; return rhoss_list, ss_args['info']; else:; return rhoss_list; else:; rhoss = Qobj(vec2mat(ns[:, 0]), dims=L.dims[0]); return rhoss / rhoss.tr(). def _steadystate_power_liouvillian(L, ss_args, has_mkl=0):; """"""Creates modified Liouvillian for power based SS methods.; """"""; perm = None; perm2 = None; rev_perm = None; n = L.shape[0]; if has_mkl:; L = L.data - (1e-15) * sp.eye(n, n, format='csr'); kind = 'csr'; else:; L = L.data.tocsc() - (1e-15) * sp.eye(n, n, format='csc'); kind = 'csc'; orig_nnz = L.nnz; if settings.debug:; old_band = sp_bandwidth(L)[0]; old_pro = sp_profile(L)[0]; logger.debug('Original bandwidth: %i' % old_band); logger.debug('Original profile: %i' % old_pro); ; if ss_args['use_wbm']:; if settings.debug:; logger.debug('Calculating Weighted Bipartite Matching ordering...'); _wbm_start = time.time(); perm = weighted_bipartite_matching(L); _wbm_end = time.time(); L = sp_permute(L, perm, [], kind); ss_args['info']['perm'].append('wbm'); ss_args['info']['wbm_time'] = _wbm_end-_wbm_start; if settings.debug:; wbm_band = sp_bandwidth(L)[0]; wbm_pro = sp_profile(L)[0]; logger.debug('WBM bandwidth: %i' % wbm_band); logger.debug('WBM profile: %i' % wbm_pro); ; if ss_args['use_rcm']:; if settings.debug:; logger.debug('Calculating Reverse Cuthill-Mckee ordering...'); ss_args['info']['perm'].append('rcm'); _rcm_start = time.time(); perm2 = reverse_cuthill_mckee(L); _rcm_end = time.time(); ss_args['info']['rcm_time'] = _rcm_end-_rcm_start; rev_perm = np.argsort(perm2); L = sp_permute(L, perm2, perm2, kind); if settings.debug:; new_band = sp_bandwidth(L)[0]; new_pro = sp_profile(L)[0]; logger",MatchSource.WIKI,docs/4.2/modules/qutip/steadystate.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/steadystate.html
https://qutip.org/docs/4.2/modules/qutip/steadystate.html:22774,Testability,log,logger,22774,"d_start; if ss_args['all_states']:; rhoss_list = []; for n in range(ns.shape[1]):; rhoss = Qobj(vec2mat(ns[:, n]), dims=L.dims[0]); rhoss_list.append(rhoss / rhoss.tr()); if ss_args['return_info']:; return rhoss_list, ss_args['info']; else:; if ss_args['return_info']:; return rhoss_list, ss_args['info']; else:; return rhoss_list; else:; rhoss = Qobj(vec2mat(ns[:, 0]), dims=L.dims[0]); return rhoss / rhoss.tr(). def _steadystate_power_liouvillian(L, ss_args, has_mkl=0):; """"""Creates modified Liouvillian for power based SS methods.; """"""; perm = None; perm2 = None; rev_perm = None; n = L.shape[0]; if has_mkl:; L = L.data - (1e-15) * sp.eye(n, n, format='csr'); kind = 'csr'; else:; L = L.data.tocsc() - (1e-15) * sp.eye(n, n, format='csc'); kind = 'csc'; orig_nnz = L.nnz; if settings.debug:; old_band = sp_bandwidth(L)[0]; old_pro = sp_profile(L)[0]; logger.debug('Original bandwidth: %i' % old_band); logger.debug('Original profile: %i' % old_pro); ; if ss_args['use_wbm']:; if settings.debug:; logger.debug('Calculating Weighted Bipartite Matching ordering...'); _wbm_start = time.time(); perm = weighted_bipartite_matching(L); _wbm_end = time.time(); L = sp_permute(L, perm, [], kind); ss_args['info']['perm'].append('wbm'); ss_args['info']['wbm_time'] = _wbm_end-_wbm_start; if settings.debug:; wbm_band = sp_bandwidth(L)[0]; wbm_pro = sp_profile(L)[0]; logger.debug('WBM bandwidth: %i' % wbm_band); logger.debug('WBM profile: %i' % wbm_pro); ; if ss_args['use_rcm']:; if settings.debug:; logger.debug('Calculating Reverse Cuthill-Mckee ordering...'); ss_args['info']['perm'].append('rcm'); _rcm_start = time.time(); perm2 = reverse_cuthill_mckee(L); _rcm_end = time.time(); ss_args['info']['rcm_time'] = _rcm_end-_rcm_start; rev_perm = np.argsort(perm2); L = sp_permute(L, perm2, perm2, kind); if settings.debug:; new_band = sp_bandwidth(L)[0]; new_pro = sp_profile(L)[0]; logger.debug('RCM bandwidth: %i' % new_band); logger.debug('Bandwidth reduction factor: %f' % (old_band/new_band)); lo",MatchSource.WIKI,docs/4.2/modules/qutip/steadystate.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/steadystate.html
https://qutip.org/docs/4.2/modules/qutip/steadystate.html:23136,Testability,log,logger,23136,"lse:; rhoss = Qobj(vec2mat(ns[:, 0]), dims=L.dims[0]); return rhoss / rhoss.tr(). def _steadystate_power_liouvillian(L, ss_args, has_mkl=0):; """"""Creates modified Liouvillian for power based SS methods.; """"""; perm = None; perm2 = None; rev_perm = None; n = L.shape[0]; if has_mkl:; L = L.data - (1e-15) * sp.eye(n, n, format='csr'); kind = 'csr'; else:; L = L.data.tocsc() - (1e-15) * sp.eye(n, n, format='csc'); kind = 'csc'; orig_nnz = L.nnz; if settings.debug:; old_band = sp_bandwidth(L)[0]; old_pro = sp_profile(L)[0]; logger.debug('Original bandwidth: %i' % old_band); logger.debug('Original profile: %i' % old_pro); ; if ss_args['use_wbm']:; if settings.debug:; logger.debug('Calculating Weighted Bipartite Matching ordering...'); _wbm_start = time.time(); perm = weighted_bipartite_matching(L); _wbm_end = time.time(); L = sp_permute(L, perm, [], kind); ss_args['info']['perm'].append('wbm'); ss_args['info']['wbm_time'] = _wbm_end-_wbm_start; if settings.debug:; wbm_band = sp_bandwidth(L)[0]; wbm_pro = sp_profile(L)[0]; logger.debug('WBM bandwidth: %i' % wbm_band); logger.debug('WBM profile: %i' % wbm_pro); ; if ss_args['use_rcm']:; if settings.debug:; logger.debug('Calculating Reverse Cuthill-Mckee ordering...'); ss_args['info']['perm'].append('rcm'); _rcm_start = time.time(); perm2 = reverse_cuthill_mckee(L); _rcm_end = time.time(); ss_args['info']['rcm_time'] = _rcm_end-_rcm_start; rev_perm = np.argsort(perm2); L = sp_permute(L, perm2, perm2, kind); if settings.debug:; new_band = sp_bandwidth(L)[0]; new_pro = sp_profile(L)[0]; logger.debug('RCM bandwidth: %i' % new_band); logger.debug('Bandwidth reduction factor: %f' % (old_band/new_band)); logger.debug('RCM profile: %i' % new_pro); logger.debug('Profile reduction factor: %f' % (old_pro/new_pro)); L.sort_indices(); return L, perm, perm2, rev_perm, ss_args; . def _steadystate_power(L, ss_args):; """"""; Inverse power method for steady state solving.; """"""; ss_args['info'].pop('weight', None); if settings.debug:; logger.debu",MatchSource.WIKI,docs/4.2/modules/qutip/steadystate.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/steadystate.html
https://qutip.org/docs/4.2/modules/qutip/steadystate.html:23182,Testability,log,logger,23182,"n rhoss / rhoss.tr(). def _steadystate_power_liouvillian(L, ss_args, has_mkl=0):; """"""Creates modified Liouvillian for power based SS methods.; """"""; perm = None; perm2 = None; rev_perm = None; n = L.shape[0]; if has_mkl:; L = L.data - (1e-15) * sp.eye(n, n, format='csr'); kind = 'csr'; else:; L = L.data.tocsc() - (1e-15) * sp.eye(n, n, format='csc'); kind = 'csc'; orig_nnz = L.nnz; if settings.debug:; old_band = sp_bandwidth(L)[0]; old_pro = sp_profile(L)[0]; logger.debug('Original bandwidth: %i' % old_band); logger.debug('Original profile: %i' % old_pro); ; if ss_args['use_wbm']:; if settings.debug:; logger.debug('Calculating Weighted Bipartite Matching ordering...'); _wbm_start = time.time(); perm = weighted_bipartite_matching(L); _wbm_end = time.time(); L = sp_permute(L, perm, [], kind); ss_args['info']['perm'].append('wbm'); ss_args['info']['wbm_time'] = _wbm_end-_wbm_start; if settings.debug:; wbm_band = sp_bandwidth(L)[0]; wbm_pro = sp_profile(L)[0]; logger.debug('WBM bandwidth: %i' % wbm_band); logger.debug('WBM profile: %i' % wbm_pro); ; if ss_args['use_rcm']:; if settings.debug:; logger.debug('Calculating Reverse Cuthill-Mckee ordering...'); ss_args['info']['perm'].append('rcm'); _rcm_start = time.time(); perm2 = reverse_cuthill_mckee(L); _rcm_end = time.time(); ss_args['info']['rcm_time'] = _rcm_end-_rcm_start; rev_perm = np.argsort(perm2); L = sp_permute(L, perm2, perm2, kind); if settings.debug:; new_band = sp_bandwidth(L)[0]; new_pro = sp_profile(L)[0]; logger.debug('RCM bandwidth: %i' % new_band); logger.debug('Bandwidth reduction factor: %f' % (old_band/new_band)); logger.debug('RCM profile: %i' % new_pro); logger.debug('Profile reduction factor: %f' % (old_pro/new_pro)); L.sort_indices(); return L, perm, perm2, rev_perm, ss_args; . def _steadystate_power(L, ss_args):; """"""; Inverse power method for steady state solving.; """"""; ss_args['info'].pop('weight', None); if settings.debug:; logger.debug('Starting iterative inverse-power method solver.'); tol = ",MatchSource.WIKI,docs/4.2/modules/qutip/steadystate.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/steadystate.html
https://qutip.org/docs/4.2/modules/qutip/steadystate.html:23271,Testability,log,logger,23271,"ouvillian for power based SS methods.; """"""; perm = None; perm2 = None; rev_perm = None; n = L.shape[0]; if has_mkl:; L = L.data - (1e-15) * sp.eye(n, n, format='csr'); kind = 'csr'; else:; L = L.data.tocsc() - (1e-15) * sp.eye(n, n, format='csc'); kind = 'csc'; orig_nnz = L.nnz; if settings.debug:; old_band = sp_bandwidth(L)[0]; old_pro = sp_profile(L)[0]; logger.debug('Original bandwidth: %i' % old_band); logger.debug('Original profile: %i' % old_pro); ; if ss_args['use_wbm']:; if settings.debug:; logger.debug('Calculating Weighted Bipartite Matching ordering...'); _wbm_start = time.time(); perm = weighted_bipartite_matching(L); _wbm_end = time.time(); L = sp_permute(L, perm, [], kind); ss_args['info']['perm'].append('wbm'); ss_args['info']['wbm_time'] = _wbm_end-_wbm_start; if settings.debug:; wbm_band = sp_bandwidth(L)[0]; wbm_pro = sp_profile(L)[0]; logger.debug('WBM bandwidth: %i' % wbm_band); logger.debug('WBM profile: %i' % wbm_pro); ; if ss_args['use_rcm']:; if settings.debug:; logger.debug('Calculating Reverse Cuthill-Mckee ordering...'); ss_args['info']['perm'].append('rcm'); _rcm_start = time.time(); perm2 = reverse_cuthill_mckee(L); _rcm_end = time.time(); ss_args['info']['rcm_time'] = _rcm_end-_rcm_start; rev_perm = np.argsort(perm2); L = sp_permute(L, perm2, perm2, kind); if settings.debug:; new_band = sp_bandwidth(L)[0]; new_pro = sp_profile(L)[0]; logger.debug('RCM bandwidth: %i' % new_band); logger.debug('Bandwidth reduction factor: %f' % (old_band/new_band)); logger.debug('RCM profile: %i' % new_pro); logger.debug('Profile reduction factor: %f' % (old_pro/new_pro)); L.sort_indices(); return L, perm, perm2, rev_perm, ss_args; . def _steadystate_power(L, ss_args):; """"""; Inverse power method for steady state solving.; """"""; ss_args['info'].pop('weight', None); if settings.debug:; logger.debug('Starting iterative inverse-power method solver.'); tol = ss_args['tol']; maxiter = ss_args['maxiter']. use_solver(assumeSortedIndices=True); rhoss = Qobj(); sflag",MatchSource.WIKI,docs/4.2/modules/qutip/steadystate.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/steadystate.html
https://qutip.org/docs/4.2/modules/qutip/steadystate.html:23656,Testability,log,logger,23656,"]; logger.debug('Original bandwidth: %i' % old_band); logger.debug('Original profile: %i' % old_pro); ; if ss_args['use_wbm']:; if settings.debug:; logger.debug('Calculating Weighted Bipartite Matching ordering...'); _wbm_start = time.time(); perm = weighted_bipartite_matching(L); _wbm_end = time.time(); L = sp_permute(L, perm, [], kind); ss_args['info']['perm'].append('wbm'); ss_args['info']['wbm_time'] = _wbm_end-_wbm_start; if settings.debug:; wbm_band = sp_bandwidth(L)[0]; wbm_pro = sp_profile(L)[0]; logger.debug('WBM bandwidth: %i' % wbm_band); logger.debug('WBM profile: %i' % wbm_pro); ; if ss_args['use_rcm']:; if settings.debug:; logger.debug('Calculating Reverse Cuthill-Mckee ordering...'); ss_args['info']['perm'].append('rcm'); _rcm_start = time.time(); perm2 = reverse_cuthill_mckee(L); _rcm_end = time.time(); ss_args['info']['rcm_time'] = _rcm_end-_rcm_start; rev_perm = np.argsort(perm2); L = sp_permute(L, perm2, perm2, kind); if settings.debug:; new_band = sp_bandwidth(L)[0]; new_pro = sp_profile(L)[0]; logger.debug('RCM bandwidth: %i' % new_band); logger.debug('Bandwidth reduction factor: %f' % (old_band/new_band)); logger.debug('RCM profile: %i' % new_pro); logger.debug('Profile reduction factor: %f' % (old_pro/new_pro)); L.sort_indices(); return L, perm, perm2, rev_perm, ss_args; . def _steadystate_power(L, ss_args):; """"""; Inverse power method for steady state solving.; """"""; ss_args['info'].pop('weight', None); if settings.debug:; logger.debug('Starting iterative inverse-power method solver.'); tol = ss_args['tol']; maxiter = ss_args['maxiter']. use_solver(assumeSortedIndices=True); rhoss = Qobj(); sflag = issuper(L); if sflag:; rhoss.dims = L.dims[0]; else:; rhoss.dims = [L.dims[0], 1]; n = L.shape[0]; # Build Liouvillian; if settings.has_mkl and ss_args['method'] == 'power':; has_mkl = 1; else:; has_mkl = 0; L, perm, perm2, rev_perm, ss_args = _steadystate_power_liouvillian(L, ; ss_args, has_mkl); orig_nnz = L.nnz; # start with all ones as RHS; v = n",MatchSource.WIKI,docs/4.2/modules/qutip/steadystate.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/steadystate.html
https://qutip.org/docs/4.2/modules/qutip/steadystate.html:23702,Testability,log,logger,23702,".debug('Original profile: %i' % old_pro); ; if ss_args['use_wbm']:; if settings.debug:; logger.debug('Calculating Weighted Bipartite Matching ordering...'); _wbm_start = time.time(); perm = weighted_bipartite_matching(L); _wbm_end = time.time(); L = sp_permute(L, perm, [], kind); ss_args['info']['perm'].append('wbm'); ss_args['info']['wbm_time'] = _wbm_end-_wbm_start; if settings.debug:; wbm_band = sp_bandwidth(L)[0]; wbm_pro = sp_profile(L)[0]; logger.debug('WBM bandwidth: %i' % wbm_band); logger.debug('WBM profile: %i' % wbm_pro); ; if ss_args['use_rcm']:; if settings.debug:; logger.debug('Calculating Reverse Cuthill-Mckee ordering...'); ss_args['info']['perm'].append('rcm'); _rcm_start = time.time(); perm2 = reverse_cuthill_mckee(L); _rcm_end = time.time(); ss_args['info']['rcm_time'] = _rcm_end-_rcm_start; rev_perm = np.argsort(perm2); L = sp_permute(L, perm2, perm2, kind); if settings.debug:; new_band = sp_bandwidth(L)[0]; new_pro = sp_profile(L)[0]; logger.debug('RCM bandwidth: %i' % new_band); logger.debug('Bandwidth reduction factor: %f' % (old_band/new_band)); logger.debug('RCM profile: %i' % new_pro); logger.debug('Profile reduction factor: %f' % (old_pro/new_pro)); L.sort_indices(); return L, perm, perm2, rev_perm, ss_args; . def _steadystate_power(L, ss_args):; """"""; Inverse power method for steady state solving.; """"""; ss_args['info'].pop('weight', None); if settings.debug:; logger.debug('Starting iterative inverse-power method solver.'); tol = ss_args['tol']; maxiter = ss_args['maxiter']. use_solver(assumeSortedIndices=True); rhoss = Qobj(); sflag = issuper(L); if sflag:; rhoss.dims = L.dims[0]; else:; rhoss.dims = [L.dims[0], 1]; n = L.shape[0]; # Build Liouvillian; if settings.has_mkl and ss_args['method'] == 'power':; has_mkl = 1; else:; has_mkl = 0; L, perm, perm2, rev_perm, ss_args = _steadystate_power_liouvillian(L, ; ss_args, has_mkl); orig_nnz = L.nnz; # start with all ones as RHS; v = np.ones(n, dtype=complex); if ss_args['use_rcm']:; v = v[np.i",MatchSource.WIKI,docs/4.2/modules/qutip/steadystate.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/steadystate.html
https://qutip.org/docs/4.2/modules/qutip/steadystate.html:23772,Testability,log,logger,23772,"e_wbm']:; if settings.debug:; logger.debug('Calculating Weighted Bipartite Matching ordering...'); _wbm_start = time.time(); perm = weighted_bipartite_matching(L); _wbm_end = time.time(); L = sp_permute(L, perm, [], kind); ss_args['info']['perm'].append('wbm'); ss_args['info']['wbm_time'] = _wbm_end-_wbm_start; if settings.debug:; wbm_band = sp_bandwidth(L)[0]; wbm_pro = sp_profile(L)[0]; logger.debug('WBM bandwidth: %i' % wbm_band); logger.debug('WBM profile: %i' % wbm_pro); ; if ss_args['use_rcm']:; if settings.debug:; logger.debug('Calculating Reverse Cuthill-Mckee ordering...'); ss_args['info']['perm'].append('rcm'); _rcm_start = time.time(); perm2 = reverse_cuthill_mckee(L); _rcm_end = time.time(); ss_args['info']['rcm_time'] = _rcm_end-_rcm_start; rev_perm = np.argsort(perm2); L = sp_permute(L, perm2, perm2, kind); if settings.debug:; new_band = sp_bandwidth(L)[0]; new_pro = sp_profile(L)[0]; logger.debug('RCM bandwidth: %i' % new_band); logger.debug('Bandwidth reduction factor: %f' % (old_band/new_band)); logger.debug('RCM profile: %i' % new_pro); logger.debug('Profile reduction factor: %f' % (old_pro/new_pro)); L.sort_indices(); return L, perm, perm2, rev_perm, ss_args; . def _steadystate_power(L, ss_args):; """"""; Inverse power method for steady state solving.; """"""; ss_args['info'].pop('weight', None); if settings.debug:; logger.debug('Starting iterative inverse-power method solver.'); tol = ss_args['tol']; maxiter = ss_args['maxiter']. use_solver(assumeSortedIndices=True); rhoss = Qobj(); sflag = issuper(L); if sflag:; rhoss.dims = L.dims[0]; else:; rhoss.dims = [L.dims[0], 1]; n = L.shape[0]; # Build Liouvillian; if settings.has_mkl and ss_args['method'] == 'power':; has_mkl = 1; else:; has_mkl = 0; L, perm, perm2, rev_perm, ss_args = _steadystate_power_liouvillian(L, ; ss_args, has_mkl); orig_nnz = L.nnz; # start with all ones as RHS; v = np.ones(n, dtype=complex); if ss_args['use_rcm']:; v = v[np.ix_(perm2,)]; ; # Do preconditioning; if ss_args['M'] is No",MatchSource.WIKI,docs/4.2/modules/qutip/steadystate.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/steadystate.html
https://qutip.org/docs/4.2/modules/qutip/steadystate.html:23815,Testability,log,logger,23815,"Weighted Bipartite Matching ordering...'); _wbm_start = time.time(); perm = weighted_bipartite_matching(L); _wbm_end = time.time(); L = sp_permute(L, perm, [], kind); ss_args['info']['perm'].append('wbm'); ss_args['info']['wbm_time'] = _wbm_end-_wbm_start; if settings.debug:; wbm_band = sp_bandwidth(L)[0]; wbm_pro = sp_profile(L)[0]; logger.debug('WBM bandwidth: %i' % wbm_band); logger.debug('WBM profile: %i' % wbm_pro); ; if ss_args['use_rcm']:; if settings.debug:; logger.debug('Calculating Reverse Cuthill-Mckee ordering...'); ss_args['info']['perm'].append('rcm'); _rcm_start = time.time(); perm2 = reverse_cuthill_mckee(L); _rcm_end = time.time(); ss_args['info']['rcm_time'] = _rcm_end-_rcm_start; rev_perm = np.argsort(perm2); L = sp_permute(L, perm2, perm2, kind); if settings.debug:; new_band = sp_bandwidth(L)[0]; new_pro = sp_profile(L)[0]; logger.debug('RCM bandwidth: %i' % new_band); logger.debug('Bandwidth reduction factor: %f' % (old_band/new_band)); logger.debug('RCM profile: %i' % new_pro); logger.debug('Profile reduction factor: %f' % (old_pro/new_pro)); L.sort_indices(); return L, perm, perm2, rev_perm, ss_args; . def _steadystate_power(L, ss_args):; """"""; Inverse power method for steady state solving.; """"""; ss_args['info'].pop('weight', None); if settings.debug:; logger.debug('Starting iterative inverse-power method solver.'); tol = ss_args['tol']; maxiter = ss_args['maxiter']. use_solver(assumeSortedIndices=True); rhoss = Qobj(); sflag = issuper(L); if sflag:; rhoss.dims = L.dims[0]; else:; rhoss.dims = [L.dims[0], 1]; n = L.shape[0]; # Build Liouvillian; if settings.has_mkl and ss_args['method'] == 'power':; has_mkl = 1; else:; has_mkl = 0; L, perm, perm2, rev_perm, ss_args = _steadystate_power_liouvillian(L, ; ss_args, has_mkl); orig_nnz = L.nnz; # start with all ones as RHS; v = np.ones(n, dtype=complex); if ss_args['use_rcm']:; v = v[np.ix_(perm2,)]; ; # Do preconditioning; if ss_args['M'] is None and ss_args['use_precond'] and \; ss_args['method'] in",MatchSource.WIKI,docs/4.2/modules/qutip/steadystate.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/steadystate.html
https://qutip.org/docs/4.2/modules/qutip/steadystate.html:24095,Testability,log,logger,24095,"dwidth(L)[0]; wbm_pro = sp_profile(L)[0]; logger.debug('WBM bandwidth: %i' % wbm_band); logger.debug('WBM profile: %i' % wbm_pro); ; if ss_args['use_rcm']:; if settings.debug:; logger.debug('Calculating Reverse Cuthill-Mckee ordering...'); ss_args['info']['perm'].append('rcm'); _rcm_start = time.time(); perm2 = reverse_cuthill_mckee(L); _rcm_end = time.time(); ss_args['info']['rcm_time'] = _rcm_end-_rcm_start; rev_perm = np.argsort(perm2); L = sp_permute(L, perm2, perm2, kind); if settings.debug:; new_band = sp_bandwidth(L)[0]; new_pro = sp_profile(L)[0]; logger.debug('RCM bandwidth: %i' % new_band); logger.debug('Bandwidth reduction factor: %f' % (old_band/new_band)); logger.debug('RCM profile: %i' % new_pro); logger.debug('Profile reduction factor: %f' % (old_pro/new_pro)); L.sort_indices(); return L, perm, perm2, rev_perm, ss_args; . def _steadystate_power(L, ss_args):; """"""; Inverse power method for steady state solving.; """"""; ss_args['info'].pop('weight', None); if settings.debug:; logger.debug('Starting iterative inverse-power method solver.'); tol = ss_args['tol']; maxiter = ss_args['maxiter']. use_solver(assumeSortedIndices=True); rhoss = Qobj(); sflag = issuper(L); if sflag:; rhoss.dims = L.dims[0]; else:; rhoss.dims = [L.dims[0], 1]; n = L.shape[0]; # Build Liouvillian; if settings.has_mkl and ss_args['method'] == 'power':; has_mkl = 1; else:; has_mkl = 0; L, perm, perm2, rev_perm, ss_args = _steadystate_power_liouvillian(L, ; ss_args, has_mkl); orig_nnz = L.nnz; # start with all ones as RHS; v = np.ones(n, dtype=complex); if ss_args['use_rcm']:; v = v[np.ix_(perm2,)]; ; # Do preconditioning; if ss_args['M'] is None and ss_args['use_precond'] and \; ss_args['method'] in ['power-gmres', ; 'power-lgmres', 'power-bicgstab']:; ss_args['M'], ss_args = _iterative_precondition(L, int(np.sqrt(n)), ss_args); if ss_args['M'] is None:; warnings.warn(""Preconditioning failed. Continuing without."",; UserWarning); ; ss_iters = {'iter': 0}. def _iter_count(r):; ss_iters['it",MatchSource.WIKI,docs/4.2/modules/qutip/steadystate.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/steadystate.html
https://qutip.org/docs/4.2/modules/qutip/steadystate.html:25459,Testability,log,logger,25459,"; else:; has_mkl = 0; L, perm, perm2, rev_perm, ss_args = _steadystate_power_liouvillian(L, ; ss_args, has_mkl); orig_nnz = L.nnz; # start with all ones as RHS; v = np.ones(n, dtype=complex); if ss_args['use_rcm']:; v = v[np.ix_(perm2,)]; ; # Do preconditioning; if ss_args['M'] is None and ss_args['use_precond'] and \; ss_args['method'] in ['power-gmres', ; 'power-lgmres', 'power-bicgstab']:; ss_args['M'], ss_args = _iterative_precondition(L, int(np.sqrt(n)), ss_args); if ss_args['M'] is None:; warnings.warn(""Preconditioning failed. Continuing without."",; UserWarning); ; ss_iters = {'iter': 0}. def _iter_count(r):; ss_iters['iter'] += 1; return; ; _power_start = time.time(); # Get LU factors; if ss_args['method'] == 'power':; if settings.has_mkl:; lu = mkl_splu(L); else: ; lu = splu(L, permc_spec=ss_args['permc_spec'],; diag_pivot_thresh=ss_args['diag_pivot_thresh'],; options=dict(ILU_MILU=ss_args['ILU_MILU'])). if settings.debug and _scipy_check:; L_nnz = lu.L.nnz; U_nnz = lu.U.nnz; logger.debug('L NNZ: %i ; U NNZ: %i' % (L_nnz, U_nnz)); logger.debug('Fill factor: %f' % ((L_nnz+U_nnz)/orig_nnz)). it = 0; _tol = max(ss_args['tol']/10, 1e-15) # Should make this user accessible; while (la.norm(L * v, np.inf) > tol) and (it < maxiter):; ; if ss_args['method'] == 'power':; v = lu.solve(v); elif ss_args['method'] == 'power-gmres':; v, check = gmres(L, v, tol=_tol, M=ss_args['M'],; x0=ss_args['x0'], restart=ss_args['restart'],; maxiter=ss_args['maxiter'], callback=_iter_count); elif ss_args['method'] == 'power-lgmres':; v, check = lgmres(L, v, tol=_tol, M=ss_args['M'],; x0=ss_args['x0'], maxiter=ss_args['maxiter'],; callback=_iter_count); elif ss_args['method'] == 'power-bicgstab':; v, check = bicgstab(L, v, tol=_tol, M=ss_args['M'],; x0=ss_args['x0'],; maxiter=ss_args['maxiter'], callback=_iter_count); else:; raise Exception(""Invalid iterative solver method.""); ; v = v / la.norm(v, np.inf); it += 1; if ss_args['method'] == 'power' and settings.has_mkl:; lu.delete(); if i",MatchSource.WIKI,docs/4.2/modules/qutip/steadystate.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/steadystate.html
https://qutip.org/docs/4.2/modules/qutip/steadystate.html:25515,Testability,log,logger,25515,"m2, rev_perm, ss_args = _steadystate_power_liouvillian(L, ; ss_args, has_mkl); orig_nnz = L.nnz; # start with all ones as RHS; v = np.ones(n, dtype=complex); if ss_args['use_rcm']:; v = v[np.ix_(perm2,)]; ; # Do preconditioning; if ss_args['M'] is None and ss_args['use_precond'] and \; ss_args['method'] in ['power-gmres', ; 'power-lgmres', 'power-bicgstab']:; ss_args['M'], ss_args = _iterative_precondition(L, int(np.sqrt(n)), ss_args); if ss_args['M'] is None:; warnings.warn(""Preconditioning failed. Continuing without."",; UserWarning); ; ss_iters = {'iter': 0}. def _iter_count(r):; ss_iters['iter'] += 1; return; ; _power_start = time.time(); # Get LU factors; if ss_args['method'] == 'power':; if settings.has_mkl:; lu = mkl_splu(L); else: ; lu = splu(L, permc_spec=ss_args['permc_spec'],; diag_pivot_thresh=ss_args['diag_pivot_thresh'],; options=dict(ILU_MILU=ss_args['ILU_MILU'])). if settings.debug and _scipy_check:; L_nnz = lu.L.nnz; U_nnz = lu.U.nnz; logger.debug('L NNZ: %i ; U NNZ: %i' % (L_nnz, U_nnz)); logger.debug('Fill factor: %f' % ((L_nnz+U_nnz)/orig_nnz)). it = 0; _tol = max(ss_args['tol']/10, 1e-15) # Should make this user accessible; while (la.norm(L * v, np.inf) > tol) and (it < maxiter):; ; if ss_args['method'] == 'power':; v = lu.solve(v); elif ss_args['method'] == 'power-gmres':; v, check = gmres(L, v, tol=_tol, M=ss_args['M'],; x0=ss_args['x0'], restart=ss_args['restart'],; maxiter=ss_args['maxiter'], callback=_iter_count); elif ss_args['method'] == 'power-lgmres':; v, check = lgmres(L, v, tol=_tol, M=ss_args['M'],; x0=ss_args['x0'], maxiter=ss_args['maxiter'],; callback=_iter_count); elif ss_args['method'] == 'power-bicgstab':; v, check = bicgstab(L, v, tol=_tol, M=ss_args['M'],; x0=ss_args['x0'],; maxiter=ss_args['maxiter'], callback=_iter_count); else:; raise Exception(""Invalid iterative solver method.""); ; v = v / la.norm(v, np.inf); it += 1; if ss_args['method'] == 'power' and settings.has_mkl:; lu.delete(); if it >= maxiter:; raise Exception('Fa",MatchSource.WIKI,docs/4.2/modules/qutip/steadystate.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/steadystate.html
https://qutip.org/docs/4.2/modules/qutip/steadystate.html:26781,Testability,log,logger,26781,"'method'] == 'power-gmres':; v, check = gmres(L, v, tol=_tol, M=ss_args['M'],; x0=ss_args['x0'], restart=ss_args['restart'],; maxiter=ss_args['maxiter'], callback=_iter_count); elif ss_args['method'] == 'power-lgmres':; v, check = lgmres(L, v, tol=_tol, M=ss_args['M'],; x0=ss_args['x0'], maxiter=ss_args['maxiter'],; callback=_iter_count); elif ss_args['method'] == 'power-bicgstab':; v, check = bicgstab(L, v, tol=_tol, M=ss_args['M'],; x0=ss_args['x0'],; maxiter=ss_args['maxiter'], callback=_iter_count); else:; raise Exception(""Invalid iterative solver method.""); ; v = v / la.norm(v, np.inf); it += 1; if ss_args['method'] == 'power' and settings.has_mkl:; lu.delete(); if it >= maxiter:; raise Exception('Failed to find steady state after ' +; str(maxiter) + ' iterations'); _power_end = time.time(); ss_args['info']['solution_time'] = _power_end-_power_start; ss_args['info']['iterations'] = it; if ss_args['return_info']:; ss_args['info']['residual_norm'] = la.norm(L*v); if settings.debug:; logger.debug('Number of iterations: %i' % it). if ss_args['use_rcm']:; v = v[np.ix_(rev_perm,)]. # normalise according to type of problem; if sflag:; trow = v[::rhoss.shape[0]+1]; data = v / np.sum(trow); else:; data = data / la.norm(v). data = dense2D_to_fastcsr_fmode(vec2mat(data), rhoss.shape[0], rhoss.shape[0]); rhoss.data = 0.5 * (data + data.H); rhoss.isherm = True; if ss_args['return_info']:; return rhoss, ss_args['info']; else:; return rhoss. [docs]def build_preconditioner(A, c_op_list=[], **kwargs):; """"""Constructs a iLU preconditioner necessary for solving for; the steady state density matrix using the iterative linear solvers; in the 'steadystate' function. Parameters; ----------; A : qobj; A Hamiltonian or Liouvillian operator. c_op_list : list; A list of collapse operators. return_info : bool, optional, default = False; Return a dictionary of solver-specific infomation about the; solution and how it was obtained. use_rcm : bool, optional, default = False; Use reverse Cuthil",MatchSource.WIKI,docs/4.2/modules/qutip/steadystate.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/steadystate.html
https://qutip.org/docs/4.2/modules/qutip/stochastic.html:5193,Availability,toler,tolerance,5193,"----. H : :class:`qutip.Qobj`; System Hamiltonian. state0 : :class:`qutip.Qobj`; Initial state vector (ket) or density matrix. times : *list* / *array*; List of times for :math:`t`. Must be uniformly spaced. c_ops : list of :class:`qutip.Qobj`; List of deterministic collapse operators. sc_ops : list of :class:`qutip.Qobj`; List of stochastic collapse operators. Each stochastic collapse; operator will give a deterministic and stochastic contribution; to the equation of motion according to how the d1 and d2 functions; are defined. e_ops : list of :class:`qutip.Qobj`; Single operator or list of operators for which to evaluate; expectation values. m_ops : list of :class:`qutip.Qobj`; List of operators representing the measurement operators. The expected; format is a nested list with one measurement operator for each; stochastic increament, for each stochastic collapse operator. args : dict / list; List of dictionary of additional problem-specific parameters.; Implicit methods can adjust tolerance via args = {'tol':value}. ntraj : int; Number of trajectors. nsubsteps : int; Number of sub steps between each time-spep given in `times`. d1 : function; Function for calculating the operator-valued coefficient to the; deterministic increment dt. d2 : function; Function for calculating the operator-valued coefficient to the; stochastic increment(s) dW_n, where n is in [0, d2_len[. d2_len : int (default 1); The number of stochastic increments in the process. dW_factors : array; Array of length d2_len, containing scaling factors for each; measurement operator in m_ops. rhs : function; Function for calculating the deterministic and stochastic contributions; to the right-hand side of the stochastic differential equation. This; only needs to be specified when implementing a custom SDE solver. generate_A_ops : function; Function that generates a list of pre-computed operators or super-; operators. These precomputed operators are used in some d1 and d2; functions. generate_noise : func",MatchSource.WIKI,docs/4.2/modules/qutip/stochastic.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/stochastic.html
https://qutip.org/docs/4.2/modules/qutip/stochastic.html:6901,Availability,toler,tolerance,6901,"ial equation. This; only needs to be specified when implementing a custom SDE solver. generate_A_ops : function; Function that generates a list of pre-computed operators or super-; operators. These precomputed operators are used in some d1 and d2; functions. generate_noise : function; Function for generate an array of pre-computed noise signal. homogeneous : bool (True); Wheter or not the stochastic process is homogenous. Inhomogenous; processes are only supported for poisson distributions. solver : string; Name of the solver method to use for solving the stochastic; equations. Valid values are: ; 1/2 order algorithms: 'euler-maruyama', 'fast-euler-maruyama',; 'pc-euler' is a predictor-corrector method which is more ; stable than explicit methods,; 1 order algorithms: 'milstein', 'fast-milstein', 'platen',; 'milstein-imp' is semi-implicit Milstein method,; 3/2 order algorithms: 'taylor15', ; 'taylor15-imp' is semi-implicit Taylor 1.5 method.; Implicit methods can adjust tolerance via args = {'tol':value},; default is {'tol':1e-6}. method : string ('homodyne', 'heterodyne', 'photocurrent'); The name of the type of measurement process that give rise to the; stochastic equation to solve. Specifying a method with this keyword; argument is a short-hand notation for using pre-defined d1 and d2; functions for the corresponding stochastic processes. distribution : string ('normal', 'poission'); The name of the distribution used for the stochastic increments. store_measurements : bool (default False); Whether or not to store the measurement results in the; :class:`qutip.solver.SolverResult` instance returned by the solver. noise : array; Vector specifying the noise. normalize : bool (default True); Whether or not to normalize the wave function during the evolution. options : :class:`qutip.solver.Options`; Generic solver options. map_func: function; A map function or managing the calls to single-trajactory solvers. map_kwargs: dictionary; Optional keyword arguments to the map_",MatchSource.WIKI,docs/4.2/modules/qutip/stochastic.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/stochastic.html
https://qutip.org/docs/4.2/modules/qutip/stochastic.html:17024,Availability,avail,available,17024,"A_ops_Euler. elif sso.solver == 'fast-milstein':; sso.generate_A_ops = _generate_A_ops_Milstein; sso.generate_noise = _generate_noise_Milstein; if sso.method == 'homodyne' or sso.method is None:; if len(sc_ops) == 1:; sso.rhs = _rhs_rho_milstein_homodyne_single_fast; elif len(sc_ops) == 2:; sso.rhs = _rhs_rho_milstein_homodyne_two_fast; else:; sso.rhs = _rhs_rho_milstein_homodyne_fast. elif sso.method == 'heterodyne':; sso.d2_len = 1; sso.sc_ops = []; for sc in iter(sc_ops):; sso.sc_ops += [sc / np.sqrt(2), -1.0j * sc / np.sqrt(2)]; if len(sc_ops) == 1:; sso.rhs = _rhs_rho_milstein_homodyne_two_fast; else:; sso.rhs = _rhs_rho_milstein_homodyne_fast; ; elif sso.solver == 'taylor15':; sso.generate_A_ops = _generate_A_ops_simple; sso.generate_noise = _generate_noise_Taylor_15; if sso.method == 'homodyne' or sso.method is None:; if len(sc_ops) == 1:; sso.rhs = _rhs_rho_taylor_15_one; #elif len(sc_ops) == 2:; # sso.rhs = _rhs_rho_taylor_15_two; else:; raise Exception(""Only one stochastic operator is supported""); else:; raise Exception(""Only homodyne is available""). elif sso.solver == 'milstein-imp':; sso.generate_A_ops = _generate_A_ops_implicit; sso.generate_noise = _generate_noise_Milstein; if sso.args == None:; sso.args = {'tol':1e-6}; if sso.method == 'homodyne' or sso.method is None:; if len(sc_ops) == 1:; sso.rhs = _rhs_rho_milstein_implicit; else:; raise Exception(""Only one stochastic operator is supported""); else:; raise Exception(""Only homodyne is available"") . elif sso.solver == 'taylor15-imp': ; sso.generate_A_ops = _generate_A_ops_implicit; sso.generate_noise = _generate_noise_Taylor_15; if sso.args == None:; sso.args = {'tol':1e-6}; if sso.method == 'homodyne' or sso.method is None:; if len(sc_ops) == 1:; sso.rhs = _rhs_rho_taylor_15_implicit; else:; raise Exception(""Only one stochastic operator is supported""); else:; raise Exception(""Only homodyne is available""). elif sso.solver == 'pc-euler':; sso.generate_A_ops = _generate_A_ops_Milstein; sso.generate_noi",MatchSource.WIKI,docs/4.2/modules/qutip/stochastic.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/stochastic.html
https://qutip.org/docs/4.2/modules/qutip/stochastic.html:17436,Availability,avail,available,17436,"eterodyne':; sso.d2_len = 1; sso.sc_ops = []; for sc in iter(sc_ops):; sso.sc_ops += [sc / np.sqrt(2), -1.0j * sc / np.sqrt(2)]; if len(sc_ops) == 1:; sso.rhs = _rhs_rho_milstein_homodyne_two_fast; else:; sso.rhs = _rhs_rho_milstein_homodyne_fast; ; elif sso.solver == 'taylor15':; sso.generate_A_ops = _generate_A_ops_simple; sso.generate_noise = _generate_noise_Taylor_15; if sso.method == 'homodyne' or sso.method is None:; if len(sc_ops) == 1:; sso.rhs = _rhs_rho_taylor_15_one; #elif len(sc_ops) == 2:; # sso.rhs = _rhs_rho_taylor_15_two; else:; raise Exception(""Only one stochastic operator is supported""); else:; raise Exception(""Only homodyne is available""). elif sso.solver == 'milstein-imp':; sso.generate_A_ops = _generate_A_ops_implicit; sso.generate_noise = _generate_noise_Milstein; if sso.args == None:; sso.args = {'tol':1e-6}; if sso.method == 'homodyne' or sso.method is None:; if len(sc_ops) == 1:; sso.rhs = _rhs_rho_milstein_implicit; else:; raise Exception(""Only one stochastic operator is supported""); else:; raise Exception(""Only homodyne is available"") . elif sso.solver == 'taylor15-imp': ; sso.generate_A_ops = _generate_A_ops_implicit; sso.generate_noise = _generate_noise_Taylor_15; if sso.args == None:; sso.args = {'tol':1e-6}; if sso.method == 'homodyne' or sso.method is None:; if len(sc_ops) == 1:; sso.rhs = _rhs_rho_taylor_15_implicit; else:; raise Exception(""Only one stochastic operator is supported""); else:; raise Exception(""Only homodyne is available""). elif sso.solver == 'pc-euler':; sso.generate_A_ops = _generate_A_ops_Milstein; sso.generate_noise = _generate_noise_Milstein # could also work without this; if sso.method == 'homodyne' or sso.method is None:; if len(sc_ops) == 1:; sso.rhs = _rhs_rho_pred_corr_homodyne_single; else:; raise Exception(""Only one stochastic operator is supported""); else:; raise Exception(""Only homodyne is available""). else:; raise Exception(""Unrecognized solver '%s'."" % sso.solver). res = _smesolve_generic(sso, sso.options",MatchSource.WIKI,docs/4.2/modules/qutip/stochastic.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/stochastic.html
https://qutip.org/docs/4.2/modules/qutip/stochastic.html:17852,Availability,avail,available,17852,"d is None:; if len(sc_ops) == 1:; sso.rhs = _rhs_rho_taylor_15_one; #elif len(sc_ops) == 2:; # sso.rhs = _rhs_rho_taylor_15_two; else:; raise Exception(""Only one stochastic operator is supported""); else:; raise Exception(""Only homodyne is available""). elif sso.solver == 'milstein-imp':; sso.generate_A_ops = _generate_A_ops_implicit; sso.generate_noise = _generate_noise_Milstein; if sso.args == None:; sso.args = {'tol':1e-6}; if sso.method == 'homodyne' or sso.method is None:; if len(sc_ops) == 1:; sso.rhs = _rhs_rho_milstein_implicit; else:; raise Exception(""Only one stochastic operator is supported""); else:; raise Exception(""Only homodyne is available"") . elif sso.solver == 'taylor15-imp': ; sso.generate_A_ops = _generate_A_ops_implicit; sso.generate_noise = _generate_noise_Taylor_15; if sso.args == None:; sso.args = {'tol':1e-6}; if sso.method == 'homodyne' or sso.method is None:; if len(sc_ops) == 1:; sso.rhs = _rhs_rho_taylor_15_implicit; else:; raise Exception(""Only one stochastic operator is supported""); else:; raise Exception(""Only homodyne is available""). elif sso.solver == 'pc-euler':; sso.generate_A_ops = _generate_A_ops_Milstein; sso.generate_noise = _generate_noise_Milstein # could also work without this; if sso.method == 'homodyne' or sso.method is None:; if len(sc_ops) == 1:; sso.rhs = _rhs_rho_pred_corr_homodyne_single; else:; raise Exception(""Only one stochastic operator is supported""); else:; raise Exception(""Only homodyne is available""). else:; raise Exception(""Unrecognized solver '%s'."" % sso.solver). res = _smesolve_generic(sso, sso.options, sso.progress_bar). if e_ops_dict:; res.expect = {e: res.expect[n]; for n, e in enumerate(e_ops_dict.keys())}. return res. [docs]def ssepdpsolve(H, psi0, times, c_ops, e_ops, **kwargs):; """"""; A stochastic (piecewse deterministic process) PDP solver for wavefunction; evolution. For most purposes, use :func:`qutip.mcsolve` instead for quantum; trajectory simulations. Parameters; ----------. H : :class:`qutip.Qobj",MatchSource.WIKI,docs/4.2/modules/qutip/stochastic.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/stochastic.html
https://qutip.org/docs/4.2/modules/qutip/stochastic.html:18252,Availability,avail,available,18252,"None:; sso.args = {'tol':1e-6}; if sso.method == 'homodyne' or sso.method is None:; if len(sc_ops) == 1:; sso.rhs = _rhs_rho_milstein_implicit; else:; raise Exception(""Only one stochastic operator is supported""); else:; raise Exception(""Only homodyne is available"") . elif sso.solver == 'taylor15-imp': ; sso.generate_A_ops = _generate_A_ops_implicit; sso.generate_noise = _generate_noise_Taylor_15; if sso.args == None:; sso.args = {'tol':1e-6}; if sso.method == 'homodyne' or sso.method is None:; if len(sc_ops) == 1:; sso.rhs = _rhs_rho_taylor_15_implicit; else:; raise Exception(""Only one stochastic operator is supported""); else:; raise Exception(""Only homodyne is available""). elif sso.solver == 'pc-euler':; sso.generate_A_ops = _generate_A_ops_Milstein; sso.generate_noise = _generate_noise_Milstein # could also work without this; if sso.method == 'homodyne' or sso.method is None:; if len(sc_ops) == 1:; sso.rhs = _rhs_rho_pred_corr_homodyne_single; else:; raise Exception(""Only one stochastic operator is supported""); else:; raise Exception(""Only homodyne is available""). else:; raise Exception(""Unrecognized solver '%s'."" % sso.solver). res = _smesolve_generic(sso, sso.options, sso.progress_bar). if e_ops_dict:; res.expect = {e: res.expect[n]; for n, e in enumerate(e_ops_dict.keys())}. return res. [docs]def ssepdpsolve(H, psi0, times, c_ops, e_ops, **kwargs):; """"""; A stochastic (piecewse deterministic process) PDP solver for wavefunction; evolution. For most purposes, use :func:`qutip.mcsolve` instead for quantum; trajectory simulations. Parameters; ----------. H : :class:`qutip.Qobj`; System Hamiltonian. psi0 : :class:`qutip.Qobj`; Initial state vector (ket). times : *list* / *array*; List of times for :math:`t`. Must be uniformly spaced. c_ops : list of :class:`qutip.Qobj`; Deterministic collapse operator which will contribute with a standard; Lindblad type of dissipation. e_ops : list of :class:`qutip.Qobj` / callback function single; single operator or list of operato",MatchSource.WIKI,docs/4.2/modules/qutip/stochastic.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/stochastic.html
https://qutip.org/docs/4.2/modules/qutip/stochastic.html:23013,Availability,error,error,23013,"tore), dtype=complex); data.ss = np.zeros((len(sso.e_ops), sso.N_store), dtype=complex); data.noise = []; data.measurement = []. # pre-compute collapse operator combinations that are commonly needed; # when evaluating the RHS of stochastic Schrodinger equations; sso.A_ops = sso.generate_A_ops(sso.sc_ops, sso.H). map_kwargs = {'progress_bar': progress_bar}; map_kwargs.update(sso.map_kwargs). task = _ssesolve_single_trajectory; task_args = (sso,); task_kwargs = {}. results = sso.map_func(task, list(range(sso.ntraj)),; task_args, task_kwargs, **map_kwargs). for result in results:; states_list, dW, m, expect, ss = result; data.states.append(states_list); data.noise.append(dW); data.measurement.append(m); data.expect += expect; data.ss += ss. # average density matrices; if options.average_states and np.any(data.states):; data.states = [sum([ket2dm(data.states[mm][n]); for mm in range(nt)]).unit(); for n in range(len(data.times))]. # average; data.expect = data.expect / nt. # standard error; if nt > 1:; data.se = (data.ss - nt * (data.expect ** 2)) / (nt * (nt - 1)); else:; data.se = None. # convert complex data to real if hermitian; data.expect = [np.real(data.expect[n, :]); if e.isherm else data.expect[n, :]; for n, e in enumerate(sso.e_ops)]. return data. def _ssesolve_single_trajectory(n, sso):; """"""; Internal function. See ssesolve.; """"""; dt = sso.dt; times = sso.times; d1, d2 = sso.d1, sso.d2; d2_len = sso.d2_len; e_ops = sso.e_ops; H_data = sso.H.data; A_ops = sso.A_ops. expect = np.zeros((len(sso.e_ops), sso.N_store), dtype=complex); ss = np.zeros((len(sso.e_ops), sso.N_store), dtype=complex). psi_t = sso.state0.full().ravel(); dims = sso.state0.dims. # reseed the random number generator so that forked; # processes do not get the same sequence of random numbers; np.random.seed((n+1) * np.random.randint(0, 4294967295 // (sso.ntraj+1))). if sso.noise is None:; if sso.homogeneous:; if sso.distribution == 'normal':; dW = np.sqrt(dt) * \; np.random.randn(len(A_ops), sso",MatchSource.WIKI,docs/4.2/modules/qutip/stochastic.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/stochastic.html
https://qutip.org/docs/4.2/modules/qutip/stochastic.html:27639,Availability,error,error,27639,"ations; sso.A_ops = sso.generate_A_ops(sso.sc_ops, sso.L.data, sso.dt). # use .data instead of Qobj ?; sso.s_e_ops = [spre(e) for e in sso.e_ops]. if sso.m_ops:; sso.s_m_ops = [[spre(m) if m else None for m in m_op]; for m_op in sso.m_ops]; else:; sso.s_m_ops = [[spre(c) for _ in range(sso.d2_len)]; for c in sso.sc_ops]. map_kwargs = {'progress_bar': progress_bar}; map_kwargs.update(sso.map_kwargs). task = _smesolve_single_trajectory; task_args = (sso,); task_kwargs = {}. results = sso.map_func(task, list(range(sso.ntraj)),; task_args, task_kwargs, **map_kwargs). for result in results:; states_list, dW, m, expect, ss = result; data.states.append(states_list); data.noise.append(dW); data.measurement.append(m); data.expect += expect; data.ss += ss. # average density matrices; if options.average_states and np.any(data.states):; data.states = [sum([data.states[mm][n] for mm in range(nt)]).unit(); for n in range(len(data.times))]. # average; data.expect = data.expect / nt. # standard error; if nt > 1:; data.se = (data.ss - nt * (data.expect ** 2)) / (nt * (nt - 1)); else:; data.se = None. # convert complex data to real if hermitian; data.expect = [np.real(data.expect[n, :]); if e.isherm else data.expect[n, :]; for n, e in enumerate(sso.e_ops)]. return data. def _smesolve_single_trajectory(n, sso):; """"""; Internal function. See smesolve.; """"""; dt = sso.dt; times = sso.times; d1, d2 = sso.d1, sso.d2; d2_len = sso.d2_len; L_data = sso.L.data; N_substeps = sso.N_substeps; N_store = sso.N_store; A_ops = sso.A_ops. rho_t = mat2vec(sso.state0.full()).ravel(); dims = sso.state0.dims. expect = np.zeros((len(sso.e_ops), sso.N_store), dtype=complex); ss = np.zeros((len(sso.e_ops), sso.N_store), dtype=complex). # reseed the random number generator so that forked; # processes do not get the same sequence of random numbers; np.random.seed((n+1) * np.random.randint(0, 4294967295 // (sso.ntraj+1))). if sso.noise is None:; if sso.generate_noise:; dW = sso.generate_noise(len(A_ops), N_stor",MatchSource.WIKI,docs/4.2/modules/qutip/stochastic.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/stochastic.html
https://qutip.org/docs/4.2/modules/qutip/stochastic.html:31773,Availability,error,error,31773," data.solver = ""sepdpsolve""; data.times = sso.tlist; data.expect = np.zeros((len(sso.e_ops), N_store), dtype=complex); data.ss = np.zeros((len(sso.e_ops), N_store), dtype=complex); data.jump_times = []; data.jump_op_idx = []. # effective hamiltonian for deterministic part; Heff = sso.H; for c in sso.c_ops:; Heff += -0.5j * c.dag() * c. progress_bar.start(sso.ntraj); for n in range(sso.ntraj):; progress_bar.update(n); psi_t = sso.state0.full().ravel(). states_list, jump_times, jump_op_idx = \; _ssepdpsolve_single_trajectory(data, Heff, dt, sso.times,; N_store, N_substeps,; psi_t, sso.state0.dims,; sso.c_ops, sso.e_ops). data.states.append(states_list); data.jump_times.append(jump_times); data.jump_op_idx.append(jump_op_idx). progress_bar.finished(). # average density matrices; if options.average_states and np.any(data.states):; data.states = [sum([data.states[m][n] for m in range(nt)]).unit(); for n in range(len(data.times))]. # average; data.expect = data.expect / nt. # standard error; if nt > 1:; data.se = (data.ss - nt * (data.expect ** 2)) / (nt * (nt - 1)); else:; data.se = None. # convert complex data to real if hermitian; data.expect = [np.real(data.expect[n, :]); if e.isherm else data.expect[n, :]; for n, e in enumerate(sso.e_ops)]. return data. def _ssepdpsolve_single_trajectory(data, Heff, dt, times, N_store, N_substeps,; psi_t, dims, c_ops, e_ops):; """"""; Internal function. See ssepdpsolve.; """"""; states_list = []. phi_t = np.copy(psi_t). prng = RandomState() # todo: seed it; r_jump, r_op = prng.rand(2). jump_times = []; jump_op_idx = []. for t_idx, t in enumerate(times):. if e_ops:; for e_idx, e in enumerate(e_ops):; s = cy_expect_psi_csr(; e.data.data, e.data.indices, e.data.indptr, psi_t, 0); data.expect[e_idx, t_idx] += s; data.ss[e_idx, t_idx] += s ** 2; else:; states_list.append(Qobj(psi_t, dims=dims)). for j in range(N_substeps):. if norm(phi_t) ** 2 < r_jump:; # jump occurs; p = np.array([norm(c.data * psi_t) ** 2 for c in c_ops]); p = np.cumsum(p / ",MatchSource.WIKI,docs/4.2/modules/qutip/stochastic.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/stochastic.html
https://qutip.org/docs/4.2/modules/qutip/stochastic.html:34985,Availability,error,error,34985," / N_substeps; nt = sso.ntraj. data = Result(); data.solver = ""smepdpsolve""; data.times = sso.times; data.expect = np.zeros((len(sso.e_ops), N_store), dtype=complex); data.jump_times = []; data.jump_op_idx = []. # Liouvillian for the deterministic part.; # needs to be modified for TD systems; L = liouvillian(sso.H, sso.c_ops). progress_bar.start(sso.ntraj). for n in range(sso.ntraj):; progress_bar.update(n); rho_t = mat2vec(sso.rho0.full()).ravel(). states_list, jump_times, jump_op_idx = \; _smepdpsolve_single_trajectory(data, L, dt, sso.times,; N_store, N_substeps,; rho_t, sso.rho0.dims,; sso.c_ops, sso.e_ops). data.states.append(states_list); data.jump_times.append(jump_times); data.jump_op_idx.append(jump_op_idx). progress_bar.finished(). # average density matrices; if options.average_states and np.any(data.states):; data.states = [sum([data.states[m][n] for m in range(nt)]).unit(); for n in range(len(data.times))]. # average; data.expect = data.expect / sso.ntraj. # standard error; if nt > 1:; data.se = (data.ss - nt * (data.expect ** 2)) / (nt * (nt - 1)); else:; data.se = None. return data. def _smepdpsolve_single_trajectory(data, L, dt, times, N_store, N_substeps,; rho_t, dims, c_ops, e_ops):; """"""; Internal function. See smepdpsolve.; """"""; states_list = []. rho_t = np.copy(rho_t); sigma_t = np.copy(rho_t). prng = RandomState() # todo: seed it; r_jump, r_op = prng.rand(2). jump_times = []; jump_op_idx = []. for t_idx, t in enumerate(times):. if e_ops:; for e_idx, e in enumerate(e_ops):; data.expect[e_idx, t_idx] += expect_rho_vec(e, rho_t); else:; states_list.append(Qobj(vec2mat(rho_t), dims=dims)). for j in range(N_substeps):. if sigma_t.norm() < r_jump:; # jump occurs; p = np.array([expect(c.dag() * c, rho_t) for c in c_ops]); p = np.cumsum(p / np.sum(p)); n = np.where(p >= r_op)[0][0]. # apply jump; rho_t = c_ops[n] * rho_t * c_ops[n].dag(); rho_t /= expect(c_ops[n].dag() * c_ops[n], rho_t); sigma_t = np.copy(rho_t). # store info about jump; jump_times.appe",MatchSource.WIKI,docs/4.2/modules/qutip/stochastic.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/stochastic.html
https://qutip.org/docs/4.2/modules/qutip/stochastic.html:21685,Deployability,integrat,integration,21685,"n of motion according to how the d1 and d2 functions; are defined. e_ops : list of :class:`qutip.Qobj` / callback function single; single operator or list of operators for which to evaluate; expectation values. kwargs : *dictionary*; Optional keyword arguments. See; :class:`qutip.stochastic.StochasticSolverOptions`. Returns; -------. output: :class:`qutip.solver.SolverResult`. An instance of the class :class:`qutip.solver.SolverResult`. """"""; if debug:; logger.debug(inspect.stack()[0][3]). if isinstance(e_ops, dict):; e_ops_dict = e_ops; e_ops = [e for e in e_ops.values()]; else:; e_ops_dict = None. sso = StochasticSolverOptions(H=H, state0=rho0, times=times, c_ops=c_ops,; e_ops=e_ops, **kwargs). res = _smepdpsolve_generic(sso, sso.options, sso.progress_bar). if e_ops_dict:; res.expect = {e: res.expect[n]; for n, e in enumerate(e_ops_dict.keys())}; return res. # -----------------------------------------------------------------------------; # Generic parameterized stochastic Schrodinger equation solver; #; def _ssesolve_generic(sso, options, progress_bar):; """"""; Internal function for carrying out a sse integration. Used by ssesolve.; """"""; if debug:; logger.debug(inspect.stack()[0][3]). sso.N_store = len(sso.times); sso.N_substeps = sso.nsubsteps; sso.dt = (sso.times[1] - sso.times[0]) / sso.N_substeps; nt = sso.ntraj. data = Result(); data.solver = ""ssesolve""; data.times = sso.times; data.expect = np.zeros((len(sso.e_ops), sso.N_store), dtype=complex); data.ss = np.zeros((len(sso.e_ops), sso.N_store), dtype=complex); data.noise = []; data.measurement = []. # pre-compute collapse operator combinations that are commonly needed; # when evaluating the RHS of stochastic Schrodinger equations; sso.A_ops = sso.generate_A_ops(sso.sc_ops, sso.H). map_kwargs = {'progress_bar': progress_bar}; map_kwargs.update(sso.map_kwargs). task = _ssesolve_single_trajectory; task_args = (sso,); task_kwargs = {}. results = sso.map_func(task, list(range(sso.ntraj)),; task_args, task_kwargs, **m",MatchSource.WIKI,docs/4.2/modules/qutip/stochastic.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/stochastic.html
https://qutip.org/docs/4.2/modules/qutip/stochastic.html:22389,Deployability,update,update,22389,"n enumerate(e_ops_dict.keys())}; return res. # -----------------------------------------------------------------------------; # Generic parameterized stochastic Schrodinger equation solver; #; def _ssesolve_generic(sso, options, progress_bar):; """"""; Internal function for carrying out a sse integration. Used by ssesolve.; """"""; if debug:; logger.debug(inspect.stack()[0][3]). sso.N_store = len(sso.times); sso.N_substeps = sso.nsubsteps; sso.dt = (sso.times[1] - sso.times[0]) / sso.N_substeps; nt = sso.ntraj. data = Result(); data.solver = ""ssesolve""; data.times = sso.times; data.expect = np.zeros((len(sso.e_ops), sso.N_store), dtype=complex); data.ss = np.zeros((len(sso.e_ops), sso.N_store), dtype=complex); data.noise = []; data.measurement = []. # pre-compute collapse operator combinations that are commonly needed; # when evaluating the RHS of stochastic Schrodinger equations; sso.A_ops = sso.generate_A_ops(sso.sc_ops, sso.H). map_kwargs = {'progress_bar': progress_bar}; map_kwargs.update(sso.map_kwargs). task = _ssesolve_single_trajectory; task_args = (sso,); task_kwargs = {}. results = sso.map_func(task, list(range(sso.ntraj)),; task_args, task_kwargs, **map_kwargs). for result in results:; states_list, dW, m, expect, ss = result; data.states.append(states_list); data.noise.append(dW); data.measurement.append(m); data.expect += expect; data.ss += ss. # average density matrices; if options.average_states and np.any(data.states):; data.states = [sum([ket2dm(data.states[mm][n]); for mm in range(nt)]).unit(); for n in range(len(data.times))]. # average; data.expect = data.expect / nt. # standard error; if nt > 1:; data.se = (data.ss - nt * (data.expect ** 2)) / (nt * (nt - 1)); else:; data.se = None. # convert complex data to real if hermitian; data.expect = [np.real(data.expect[n, :]); if e.isherm else data.expect[n, :]; for n, e in enumerate(sso.e_ops)]. return data. def _ssesolve_single_trajectory(n, sso):; """"""; Internal function. See ssesolve.; """"""; dt = sso.dt; time",MatchSource.WIKI,docs/4.2/modules/qutip/stochastic.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/stochastic.html
https://qutip.org/docs/4.2/modules/qutip/stochastic.html:27024,Deployability,update,update,27024,"re = len(sso.times); sso.N_substeps = sso.nsubsteps; sso.dt = (sso.times[1] - sso.times[0]) / sso.N_substeps; nt = sso.ntraj. data = Result(); data.solver = ""smesolve""; data.times = sso.times; data.expect = np.zeros((len(sso.e_ops), sso.N_store), dtype=complex); data.ss = np.zeros((len(sso.e_ops), sso.N_store), dtype=complex); data.noise = []; data.measurement = []. # Liouvillian for the deterministic part.; # needs to be modified for TD systems; sso.L = liouvillian(sso.H, sso.c_ops). # pre-compute suporoperator operator combinations that are commonly needed; # when evaluating the RHS of stochastic master equations; sso.A_ops = sso.generate_A_ops(sso.sc_ops, sso.L.data, sso.dt). # use .data instead of Qobj ?; sso.s_e_ops = [spre(e) for e in sso.e_ops]. if sso.m_ops:; sso.s_m_ops = [[spre(m) if m else None for m in m_op]; for m_op in sso.m_ops]; else:; sso.s_m_ops = [[spre(c) for _ in range(sso.d2_len)]; for c in sso.sc_ops]. map_kwargs = {'progress_bar': progress_bar}; map_kwargs.update(sso.map_kwargs). task = _smesolve_single_trajectory; task_args = (sso,); task_kwargs = {}. results = sso.map_func(task, list(range(sso.ntraj)),; task_args, task_kwargs, **map_kwargs). for result in results:; states_list, dW, m, expect, ss = result; data.states.append(states_list); data.noise.append(dW); data.measurement.append(m); data.expect += expect; data.ss += ss. # average density matrices; if options.average_states and np.any(data.states):; data.states = [sum([data.states[mm][n] for mm in range(nt)]).unit(); for n in range(len(data.times))]. # average; data.expect = data.expect / nt. # standard error; if nt > 1:; data.se = (data.ss - nt * (data.expect ** 2)) / (nt * (nt - 1)); else:; data.se = None. # convert complex data to real if hermitian; data.expect = [np.real(data.expect[n, :]); if e.isherm else data.expect[n, :]; for n, e in enumerate(sso.e_ops)]. return data. def _smesolve_single_trajectory(n, sso):; """"""; Internal function. See smesolve.; """"""; dt = sso.dt; times = sso.t",MatchSource.WIKI,docs/4.2/modules/qutip/stochastic.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/stochastic.html
https://qutip.org/docs/4.2/modules/qutip/stochastic.html:31189,Deployability,update,update,31189,", t_idx, :, dW_idx].sum() / (dt * N_substeps). if d2_len == 1:; measurements = measurements.squeeze(axis=(2)). return states_list, dW, measurements, expect, ss. # -----------------------------------------------------------------------------; # Generic parameterized stochastic SE PDP solver; #; def _ssepdpsolve_generic(sso, options, progress_bar):; """"""; For internal use. See ssepdpsolve.; """"""; if debug:; logger.debug(inspect.stack()[0][3]). N_store = len(sso.times); N_substeps = sso.nsubsteps; dt = (sso.times[1] - sso.times[0]) / N_substeps; nt = sso.ntraj. data = Result(); data.solver = ""sepdpsolve""; data.times = sso.tlist; data.expect = np.zeros((len(sso.e_ops), N_store), dtype=complex); data.ss = np.zeros((len(sso.e_ops), N_store), dtype=complex); data.jump_times = []; data.jump_op_idx = []. # effective hamiltonian for deterministic part; Heff = sso.H; for c in sso.c_ops:; Heff += -0.5j * c.dag() * c. progress_bar.start(sso.ntraj); for n in range(sso.ntraj):; progress_bar.update(n); psi_t = sso.state0.full().ravel(). states_list, jump_times, jump_op_idx = \; _ssepdpsolve_single_trajectory(data, Heff, dt, sso.times,; N_store, N_substeps,; psi_t, sso.state0.dims,; sso.c_ops, sso.e_ops). data.states.append(states_list); data.jump_times.append(jump_times); data.jump_op_idx.append(jump_op_idx). progress_bar.finished(). # average density matrices; if options.average_states and np.any(data.states):; data.states = [sum([data.states[m][n] for m in range(nt)]).unit(); for n in range(len(data.times))]. # average; data.expect = data.expect / nt. # standard error; if nt > 1:; data.se = (data.ss - nt * (data.expect ** 2)) / (nt * (nt - 1)); else:; data.se = None. # convert complex data to real if hermitian; data.expect = [np.real(data.expect[n, :]); if e.isherm else data.expect[n, :]; for n, e in enumerate(sso.e_ops)]. return data. def _ssepdpsolve_single_trajectory(data, Heff, dt, times, N_store, N_substeps,; psi_t, dims, c_ops, e_ops):; """"""; Internal function. See ssepdpsolve.",MatchSource.WIKI,docs/4.2/modules/qutip/stochastic.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/stochastic.html
https://qutip.org/docs/4.2/modules/qutip/stochastic.html:34392,Deployability,update,update,34392,"hi_t; psi_t += dpsi_t. # ensure that normalized wavefunction remains normalized; # this allows larger time step than otherwise would be possible; psi_t /= norm(psi_t). return states_list, jump_times, jump_op_idx. # -----------------------------------------------------------------------------; # Generic parameterized stochastic ME PDP solver; #; def _smepdpsolve_generic(sso, options, progress_bar):; """"""; For internal use. See smepdpsolve.; """"""; if debug:; logger.debug(inspect.stack()[0][3]). N_store = len(sso.times); N_substeps = sso.nsubsteps; dt = (sso.times[1] - sso.times[0]) / N_substeps; nt = sso.ntraj. data = Result(); data.solver = ""smepdpsolve""; data.times = sso.times; data.expect = np.zeros((len(sso.e_ops), N_store), dtype=complex); data.jump_times = []; data.jump_op_idx = []. # Liouvillian for the deterministic part.; # needs to be modified for TD systems; L = liouvillian(sso.H, sso.c_ops). progress_bar.start(sso.ntraj). for n in range(sso.ntraj):; progress_bar.update(n); rho_t = mat2vec(sso.rho0.full()).ravel(). states_list, jump_times, jump_op_idx = \; _smepdpsolve_single_trajectory(data, L, dt, sso.times,; N_store, N_substeps,; rho_t, sso.rho0.dims,; sso.c_ops, sso.e_ops). data.states.append(states_list); data.jump_times.append(jump_times); data.jump_op_idx.append(jump_op_idx). progress_bar.finished(). # average density matrices; if options.average_states and np.any(data.states):; data.states = [sum([data.states[m][n] for m in range(nt)]).unit(); for n in range(len(data.times))]. # average; data.expect = data.expect / sso.ntraj. # standard error; if nt > 1:; data.se = (data.ss - nt * (data.expect ** 2)) / (nt * (nt - 1)); else:; data.se = None. return data. def _smepdpsolve_single_trajectory(data, L, dt, times, N_store, N_substeps,; rho_t, dims, c_ops, e_ops):; """"""; Internal function. See smepdpsolve.; """"""; states_list = []. rho_t = np.copy(rho_t); sigma_t = np.copy(rho_t). prng = RandomState() # todo: seed it; r_jump, r_op = prng.rand(2). jump_times = []",MatchSource.WIKI,docs/4.2/modules/qutip/stochastic.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/stochastic.html
https://qutip.org/docs/4.2/modules/qutip/stochastic.html:47151,Deployability,update,update,47151,"1_rho_heterodyne(t, rho_vec, A, args):; """"""; Need to cythonize, docstrings; """"""; return spmv(A[7], rho_vec). def d2_rho_heterodyne(t, rho_vec, A, args):; """"""; Need to cythonize, docstrings; """"""; M = A[0] + A[3]; e1 = cy_expect_rho_vec(M, rho_vec, 0); d1 = spmv(M, rho_vec) - e1 * rho_vec; M = A[0] - A[3]; e1 = cy_expect_rho_vec(M, rho_vec, 0); d2 = spmv(M, rho_vec) - e1 * rho_vec; return [1.0 / np.sqrt(2) * d1, -1.0j / np.sqrt(2) * d2]. def d1_rho_photocurrent(t, rho_vec, A, args):; """"""; Need to cythonize, add (AdA)_L + AdA_R to precomputed operators; """"""; n_sum = A[4] + A[5]; e1 = cy_expect_rho_vec(n_sum, rho_vec, 0); return 0.5 * (e1 * rho_vec - spmv(n_sum, rho_vec)). def d2_rho_photocurrent(t, rho_vec, A, args):; """"""; Need to cythonize, add (AdA)_L + AdA_R to precomputed operators; """"""; e1 = cy_expect_rho_vec(A[6], rho_vec, 0); if e1.real > 1e-15:; return [spmv(A[6], rho_vec) / e1 - rho_vec]; else:; return [-rho_vec]. # -----------------------------------------------------------------------------; # Deterministic part of the rho/psi update functions. TODO: Make these; # compatible with qutip's time-dependent hamiltonian and collapse operators; #; def _rhs_psi_deterministic(H, psi_t, t, dt, args):; """"""; Deterministic contribution to the density matrix change; """"""; dpsi_t = (-1.0j * dt) * (H * psi_t). return dpsi_t. def _rhs_rho_deterministic(L, rho_t, t, dt, args):; """"""; Deterministic contribution to the density matrix change; """"""; drho_t = spmv(L, rho_t) * dt. return drho_t. # -----------------------------------------------------------------------------; # Euler-Maruyama rhs functions for the stochastic Schrodinger and master; # equations; #. def _rhs_psi_euler_maruyama(H, psi_t, t, A_ops, dt, dW, d1, d2, args):; """"""; Euler-Maruyama rhs function for wave function solver.; """"""; dW_len = len(dW[0, :]); dpsi_t = _rhs_psi_deterministic(H, psi_t, t, dt, args). for a_idx, A in enumerate(A_ops):; d2_vec = d2(t, psi_t, A, args); dpsi_t += d1(t, psi_t, A, args) * dt + \; np",MatchSource.WIKI,docs/4.2/modules/qutip/stochastic.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/stochastic.html
https://qutip.org/docs/4.2/modules/qutip/stochastic.html:49530,Deployability,update,updated,49530,"([d2_vec[n] * dW[a_idx, n]; for n in range(dW_len) if dW[a_idx, n] != 0], axis=0). return rho_t + drho_t. def _rhs_rho_euler_homodyne_fast(L, rho_t, t, A, dt, ddW, d1, d2, args):; """"""; Fast Euler-Maruyama for homodyne detection.; """""". dW = ddW[:, 0]. d_vec = spmv(A[0][0], rho_t).reshape(-1, len(rho_t)); e = d_vec[:-1].reshape(-1, A[0][1], A[0][1]).trace(axis1=1, axis2=2). drho_t = d_vec[-1]; drho_t += np.dot(dW, d_vec[:-1]); drho_t += (1.0 - np.inner(np.real(e), dW)) * rho_t; return drho_t. # -----------------------------------------------------------------------------; # Platen method; #; def _rhs_psi_platen(H, psi_t, t, A_ops, dt, dW, d1, d2, args):; """"""; TODO: support multiple stochastic increments. .. note::. Experimental. """""". sqrt_dt = np.sqrt(dt). dpsi_t = _rhs_psi_deterministic(H, psi_t, t, dt, args). for a_idx, A in enumerate(A_ops):; # XXX: This needs to be revised now that; # dpsi_t is the change for all stochastic collapse operators. # TODO: needs to be updated to support mutiple Weiner increments; dpsi_t_H = (-1.0j * dt) * spmv(H, psi_t). psi_t_1 = (psi_t + dpsi_t_H +; d1(A, psi_t) * dt +; d2(A, psi_t)[0] * dW[a_idx, 0]); psi_t_p = (psi_t + dpsi_t_H +; d1(A, psi_t) * dt +; d2(A, psi_t)[0] * sqrt_dt); psi_t_m = (psi_t + dpsi_t_H +; d1(A, psi_t) * dt -; d2(A, psi_t)[0] * sqrt_dt). dpsi_t += (; 0.50 * (d1(A, psi_t_1) + d1(A, psi_t)) * dt +; 0.25 * (d2(A, psi_t_p)[0] + d2(A, psi_t_m)[0] +; 2 * d2(A, psi_t)[0]) * dW[a_idx, 0] +; 0.25 * (d2(A, psi_t_p)[0] - d2(A, psi_t_m)[0]) *; (dW[a_idx, 0] ** 2 - dt) / sqrt_dt; ). return dpsi_t. # -----------------------------------------------------------------------------; # Milstein rhs functions for the stochastic master equation; #; def _rhs_rho_milstein_homodyne_single(L, rho_t, t, A_ops, dt, dW, d1, d2,; args):; """"""; .. note::. Experimental.; Milstein scheme for homodyne detection with single jump operator. """"""; A = A_ops[0]; M = A[0] + A[3]; e1 = cy_expect_rho_vec(M, rho_t, 0). d2_vec = spmv(M, rho_t); d2_vec2 = sp",MatchSource.WIKI,docs/4.2/modules/qutip/stochastic.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/stochastic.html
https://qutip.org/docs/4.2/modules/qutip/stochastic.html:58021,Deployability,update,updated,58021,"[:, 0]; A = A[0]. #reusable operators and traces; a = A[-1] * rho_t; e0 = cy_expect_rho_vec(A[0], rho_t, 1); b = A[0] * rho_t - e0 * rho_t; TrAb = cy_expect_rho_vec(A[0], b, 1); Lb = A[0] * b - TrAb * rho_t - e0 * b; TrALb = cy_expect_rho_vec(A[0], Lb, 1); TrAa = cy_expect_rho_vec(A[0], a, 1). drho_t = b * dW[0] ; drho_t += Lb * dW[1] # Milstein term; xx0 = (drho_t + a * dt) + rho_t #starting vector for the linear solver (Milstein prediction); drho_t += (0.5 * dt) * a. # new terms: ; drho_t += A[-1] * b * (dW[2] - 0.5*dW[0]*dt); drho_t += (A[0] * a - TrAa * rho_t - e0 * a - TrAb * b) * dW[3]. drho_t += (A[0] * Lb - TrALb * rho_t - (2 * TrAb) * b - e0 * Lb) * dW[4]; drho_t += rho_t. v, check = sp.linalg.bicgstab(A[-2], drho_t, x0 = xx0, tol=args['tol']). return v; ; def _rhs_rho_pred_corr_homodyne_single(L, rho_t, t, A, dt, ddW, d1, d2,; args):; """"""; 1/2 predictor-corrector scheme for homodyne detection with 1 stochastic operator; """"""; dW = ddW[:, 0]; ; #predictor. d_vec = (A[0][0] * rho_t).reshape(-1, len(rho_t)); e = np.real(; d_vec[:-1].reshape(-1, A[0][1], A[0][1]).trace(axis1=1, axis2=2)). a_pred = np.copy(d_vec[-1]); b_pred = - e[0] * rho_t; b_pred += d_vec[0]. pred_rho_t = np.copy(a_pred); pred_rho_t += b_pred * dW[0]; pred_rho_t += rho_t. a_pred -= ((d_vec[1] - e[1] * rho_t) - (2.0 * e[0]) * b_pred) * (0.5 * dt); ; #corrector. d_vec = (A[0][0] * pred_rho_t).reshape(-1, len(rho_t)); e = np.real(; d_vec[:-1].reshape(-1, A[0][1], A[0][1]).trace(axis1=1, axis2=2)). a_corr = d_vec[-1]; b_corr = - e[0] * pred_rho_t; b_corr += d_vec[0]. a_corr -= ((d_vec[1] - e[1] * pred_rho_t) - (2.0 * e[0]) * b_corr) * (0.5 * dt); a_corr += a_pred; a_corr *= 0.5. b_corr += b_pred; b_corr *= 0.5 * dW[0]. corr_rho_t = a_corr; corr_rho_t += b_corr; corr_rho_t += rho_t. return corr_rho_t.  Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, and A.L. Grimsmo.; Last updated on Jan 17, 2018. . Built with Sphinx using a theme provided by Read the Docs. . ",MatchSource.WIKI,docs/4.2/modules/qutip/stochastic.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/stochastic.html
https://qutip.org/docs/4.2/modules/qutip/stochastic.html:9672,Integrability,depend,depending,9672,"lf.state0 = state0; self.times = times; self.c_ops = c_ops; self.sc_ops = sc_ops; self.e_ops = e_ops. if m_ops is None:; self.m_ops = [[c for _ in range(d2_len)] for c in sc_ops]; else:; self.m_ops = m_ops. self.ntraj = ntraj; self.nsubsteps = nsubsteps; self.solver = solver; self.method = method; self.distribution = distribution; self.homogeneous = homogeneous; self.rhs = rhs; self.options = options; self.progress_bar = progress_bar; self.store_measurement = store_measurement; self.store_states = options.store_states; self.noise = noise; self.args = args; self.normalize = normalize. self.generate_noise = generate_noise; self.generate_A_ops = generate_A_ops. if self.ntraj > 1 and map_func:; self.map_func = map_func; else:; self.map_func = serial_map. self.map_kwargs = map_kwargs if map_kwargs is not None else {}. [docs]def ssesolve(H, psi0, times, sc_ops=[], e_ops=[], _safe_mode=True, **kwargs):; """"""; Solve the stochastic Schrdinger equation. Dispatch to specific solvers; depending on the value of the `solver` keyword argument. Parameters; ----------. H : :class:`qutip.Qobj`; System Hamiltonian. psi0 : :class:`qutip.Qobj`; Initial state vector (ket). times : *list* / *array*; List of times for :math:`t`. Must be uniformly spaced. sc_ops : list of :class:`qutip.Qobj`; List of stochastic collapse operators. Each stochastic collapse; operator will give a deterministic and stochastic contribution; to the equation of motion according to how the d1 and d2 functions; are defined. e_ops : list of :class:`qutip.Qobj`; Single operator or list of operators for which to evaluate; expectation values. kwargs : *dictionary*; Optional keyword arguments. See; :class:`qutip.stochastic.StochasticSolverOptions`. Returns; -------. output: :class:`qutip.solver.SolverResult`; An instance of the class :class:`qutip.solver.SolverResult`.; """"""; if debug:; logger.debug(inspect.stack()[0][3]). if isinstance(e_ops, dict):; e_ops_dict = e_ops; e_ops = [e for e in e_ops.values()]; else:; e_ops_di",MatchSource.WIKI,docs/4.2/modules/qutip/stochastic.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/stochastic.html
https://qutip.org/docs/4.2/modules/qutip/stochastic.html:12604,Integrability,depend,depending,12604,"e(sso.sc_ops)]. elif sso.method == 'photocurrent':; sso.d1 = d1_psi_photocurrent; sso.d2 = d2_psi_photocurrent; sso.d2_len = 1; sso.homogeneous = False; sso.distribution = 'poisson'. if ""dW_factors"" not in kwargs:; sso.dW_factors = np.array([1]); if ""m_ops"" not in kwargs:; sso.m_ops = [[None] for c in sso.sc_ops]. else:; raise Exception(""Unrecognized method '%s'."" % sso.method). if sso.distribution == 'poisson':; sso.homogeneous = False. if sso.solver == 'euler-maruyama' or sso.solver is None:; sso.rhs = _rhs_psi_euler_maruyama. elif sso.solver == 'platen':; sso.rhs = _rhs_psi_platen. else:; raise Exception(""Unrecognized solver '%s'."" % sso.solver). res = _ssesolve_generic(sso, sso.options, sso.progress_bar). if e_ops_dict:; res.expect = {e: res.expect[n]; for n, e in enumerate(e_ops_dict.keys())}. return res. [docs]def smesolve(H, rho0, times, c_ops=[], sc_ops=[], e_ops=[], ; _safe_mode=True ,**kwargs):; """"""; Solve stochastic master equation. Dispatch to specific solvers; depending on the value of the `solver` keyword argument. Parameters; ----------. H : :class:`qutip.Qobj`; System Hamiltonian. rho0 : :class:`qutip.Qobj`; Initial density matrix or state vector (ket). times : *list* / *array*; List of times for :math:`t`. Must be uniformly spaced. c_ops : list of :class:`qutip.Qobj`; Deterministic collapse operator which will contribute with a standard; Lindblad type of dissipation. sc_ops : list of :class:`qutip.Qobj`; List of stochastic collapse operators. Each stochastic collapse; operator will give a deterministic and stochastic contribution; to the eqaution of motion according to how the d1 and d2 functions; are defined. e_ops : list of :class:`qutip.Qobj` / callback function single; single operator or list of operators for which to evaluate; expectation values. kwargs : *dictionary*; Optional keyword arguments. See; :class:`qutip.stochastic.StochasticSolverOptions`. Returns; -------. output: :class:`qutip.solver.SolverResult`. An instance of the class :class:`",MatchSource.WIKI,docs/4.2/modules/qutip/stochastic.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/stochastic.html
https://qutip.org/docs/4.2/modules/qutip/stochastic.html:21685,Integrability,integrat,integration,21685,"n of motion according to how the d1 and d2 functions; are defined. e_ops : list of :class:`qutip.Qobj` / callback function single; single operator or list of operators for which to evaluate; expectation values. kwargs : *dictionary*; Optional keyword arguments. See; :class:`qutip.stochastic.StochasticSolverOptions`. Returns; -------. output: :class:`qutip.solver.SolverResult`. An instance of the class :class:`qutip.solver.SolverResult`. """"""; if debug:; logger.debug(inspect.stack()[0][3]). if isinstance(e_ops, dict):; e_ops_dict = e_ops; e_ops = [e for e in e_ops.values()]; else:; e_ops_dict = None. sso = StochasticSolverOptions(H=H, state0=rho0, times=times, c_ops=c_ops,; e_ops=e_ops, **kwargs). res = _smepdpsolve_generic(sso, sso.options, sso.progress_bar). if e_ops_dict:; res.expect = {e: res.expect[n]; for n, e in enumerate(e_ops_dict.keys())}; return res. # -----------------------------------------------------------------------------; # Generic parameterized stochastic Schrodinger equation solver; #; def _ssesolve_generic(sso, options, progress_bar):; """"""; Internal function for carrying out a sse integration. Used by ssesolve.; """"""; if debug:; logger.debug(inspect.stack()[0][3]). sso.N_store = len(sso.times); sso.N_substeps = sso.nsubsteps; sso.dt = (sso.times[1] - sso.times[0]) / sso.N_substeps; nt = sso.ntraj. data = Result(); data.solver = ""ssesolve""; data.times = sso.times; data.expect = np.zeros((len(sso.e_ops), sso.N_store), dtype=complex); data.ss = np.zeros((len(sso.e_ops), sso.N_store), dtype=complex); data.noise = []; data.measurement = []. # pre-compute collapse operator combinations that are commonly needed; # when evaluating the RHS of stochastic Schrodinger equations; sso.A_ops = sso.generate_A_ops(sso.sc_ops, sso.H). map_kwargs = {'progress_bar': progress_bar}; map_kwargs.update(sso.map_kwargs). task = _ssesolve_single_trajectory; task_args = (sso,); task_kwargs = {}. results = sso.map_func(task, list(range(sso.ntraj)),; task_args, task_kwargs, **m",MatchSource.WIKI,docs/4.2/modules/qutip/stochastic.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/stochastic.html
https://qutip.org/docs/4.2/modules/qutip/stochastic.html:47218,Integrability,depend,dependent,47218,"rings; """"""; M = A[0] + A[3]; e1 = cy_expect_rho_vec(M, rho_vec, 0); d1 = spmv(M, rho_vec) - e1 * rho_vec; M = A[0] - A[3]; e1 = cy_expect_rho_vec(M, rho_vec, 0); d2 = spmv(M, rho_vec) - e1 * rho_vec; return [1.0 / np.sqrt(2) * d1, -1.0j / np.sqrt(2) * d2]. def d1_rho_photocurrent(t, rho_vec, A, args):; """"""; Need to cythonize, add (AdA)_L + AdA_R to precomputed operators; """"""; n_sum = A[4] + A[5]; e1 = cy_expect_rho_vec(n_sum, rho_vec, 0); return 0.5 * (e1 * rho_vec - spmv(n_sum, rho_vec)). def d2_rho_photocurrent(t, rho_vec, A, args):; """"""; Need to cythonize, add (AdA)_L + AdA_R to precomputed operators; """"""; e1 = cy_expect_rho_vec(A[6], rho_vec, 0); if e1.real > 1e-15:; return [spmv(A[6], rho_vec) / e1 - rho_vec]; else:; return [-rho_vec]. # -----------------------------------------------------------------------------; # Deterministic part of the rho/psi update functions. TODO: Make these; # compatible with qutip's time-dependent hamiltonian and collapse operators; #; def _rhs_psi_deterministic(H, psi_t, t, dt, args):; """"""; Deterministic contribution to the density matrix change; """"""; dpsi_t = (-1.0j * dt) * (H * psi_t). return dpsi_t. def _rhs_rho_deterministic(L, rho_t, t, dt, args):; """"""; Deterministic contribution to the density matrix change; """"""; drho_t = spmv(L, rho_t) * dt. return drho_t. # -----------------------------------------------------------------------------; # Euler-Maruyama rhs functions for the stochastic Schrodinger and master; # equations; #. def _rhs_psi_euler_maruyama(H, psi_t, t, A_ops, dt, dW, d1, d2, args):; """"""; Euler-Maruyama rhs function for wave function solver.; """"""; dW_len = len(dW[0, :]); dpsi_t = _rhs_psi_deterministic(H, psi_t, t, dt, args). for a_idx, A in enumerate(A_ops):; d2_vec = d2(t, psi_t, A, args); dpsi_t += d1(t, psi_t, A, args) * dt + \; np.sum([d2_vec[n] * dW[a_idx, n]; for n in range(dW_len) if dW[a_idx, n] != 0], axis=0). return psi_t + dpsi_t. def _rhs_rho_euler_maruyama(L, rho_t, t, A_ops, dt, dW, d1, d2, args):; """,MatchSource.WIKI,docs/4.2/modules/qutip/stochastic.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/stochastic.html
https://qutip.org/docs/4.2/modules/qutip/stochastic.html:21530,Modifiability,parameteriz,parameterized,21530,"n of motion according to how the d1 and d2 functions; are defined. e_ops : list of :class:`qutip.Qobj` / callback function single; single operator or list of operators for which to evaluate; expectation values. kwargs : *dictionary*; Optional keyword arguments. See; :class:`qutip.stochastic.StochasticSolverOptions`. Returns; -------. output: :class:`qutip.solver.SolverResult`. An instance of the class :class:`qutip.solver.SolverResult`. """"""; if debug:; logger.debug(inspect.stack()[0][3]). if isinstance(e_ops, dict):; e_ops_dict = e_ops; e_ops = [e for e in e_ops.values()]; else:; e_ops_dict = None. sso = StochasticSolverOptions(H=H, state0=rho0, times=times, c_ops=c_ops,; e_ops=e_ops, **kwargs). res = _smepdpsolve_generic(sso, sso.options, sso.progress_bar). if e_ops_dict:; res.expect = {e: res.expect[n]; for n, e in enumerate(e_ops_dict.keys())}; return res. # -----------------------------------------------------------------------------; # Generic parameterized stochastic Schrodinger equation solver; #; def _ssesolve_generic(sso, options, progress_bar):; """"""; Internal function for carrying out a sse integration. Used by ssesolve.; """"""; if debug:; logger.debug(inspect.stack()[0][3]). sso.N_store = len(sso.times); sso.N_substeps = sso.nsubsteps; sso.dt = (sso.times[1] - sso.times[0]) / sso.N_substeps; nt = sso.ntraj. data = Result(); data.solver = ""ssesolve""; data.times = sso.times; data.expect = np.zeros((len(sso.e_ops), sso.N_store), dtype=complex); data.ss = np.zeros((len(sso.e_ops), sso.N_store), dtype=complex); data.noise = []; data.measurement = []. # pre-compute collapse operator combinations that are commonly needed; # when evaluating the RHS of stochastic Schrodinger equations; sso.A_ops = sso.generate_A_ops(sso.sc_ops, sso.H). map_kwargs = {'progress_bar': progress_bar}; map_kwargs.update(sso.map_kwargs). task = _ssesolve_single_trajectory; task_args = (sso,); task_kwargs = {}. results = sso.map_func(task, list(range(sso.ntraj)),; task_args, task_kwargs, **m",MatchSource.WIKI,docs/4.2/modules/qutip/stochastic.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/stochastic.html
https://qutip.org/docs/4.2/modules/qutip/stochastic.html:25824,Modifiability,parameteriz,parameterized,25824,"ops):; # dw_expect = norm(spmv(A[0], psi_t)) ** 2 * dt; dw_expect = cy_expect_psi_csr(A[3].data,; A[3].indices,; A[3].indptr, psi_t, 1) * dt; dW[a_idx, t_idx, j, :] = np.random.poisson(dw_expect,; d2_len). psi_t = sso.rhs(H_data, psi_t, t + dt * j,; A_ops, dt, dW[:, t_idx, j, :], d1, d2, sso.args). # optionally renormalize the wave function; if sso.normalize:; psi_t /= norm(psi_t). if sso.store_measurement:; for m_idx, m in enumerate(sso.m_ops):; for dW_idx, dW_factor in enumerate(sso.dW_factors):; if m[dW_idx]:; m_data = m[dW_idx].data; m_expt = cy_expect_psi_csr(m_data.data,; m_data.indices,; m_data.indptr,; psi_t, 0); else:; m_expt = 0; mm = (m_expt + dW_factor *; dW[m_idx, t_idx, :, dW_idx].sum() /; (dt * sso.N_substeps)); measurements[t_idx, m_idx, dW_idx] = mm. if d2_len == 1:; measurements = measurements.squeeze(axis=(2)). return states_list, dW, measurements, expect, ss. # -----------------------------------------------------------------------------; # Generic parameterized stochastic master equation solver; #; def _smesolve_generic(sso, options, progress_bar):; """"""; Internal function. See smesolve.; """"""; if debug:; logger.debug(inspect.stack()[0][3]). sso.N_store = len(sso.times); sso.N_substeps = sso.nsubsteps; sso.dt = (sso.times[1] - sso.times[0]) / sso.N_substeps; nt = sso.ntraj. data = Result(); data.solver = ""smesolve""; data.times = sso.times; data.expect = np.zeros((len(sso.e_ops), sso.N_store), dtype=complex); data.ss = np.zeros((len(sso.e_ops), sso.N_store), dtype=complex); data.noise = []; data.measurement = []. # Liouvillian for the deterministic part.; # needs to be modified for TD systems; sso.L = liouvillian(sso.H, sso.c_ops). # pre-compute suporoperator operator combinations that are commonly needed; # when evaluating the RHS of stochastic master equations; sso.A_ops = sso.generate_A_ops(sso.sc_ops, sso.L.data, sso.dt). # use .data instead of Qobj ?; sso.s_e_ops = [spre(e) for e in sso.e_ops]. if sso.m_ops:; sso.s_m_ops = [[spre(m) if m else N",MatchSource.WIKI,docs/4.2/modules/qutip/stochastic.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/stochastic.html
https://qutip.org/docs/4.2/modules/qutip/stochastic.html:30452,Modifiability,parameteriz,parameterized,30452,"d(Qobj(vec2mat(rho_t), dims=dims)). rho_prev = np.copy(rho_t). for j in range(N_substeps):. if sso.noise is None and not sso.homogeneous:; for a_idx, A in enumerate(A_ops):; dw_expect = cy_expect_rho_vec(A[4], rho_t, 1) * dt; if dw_expect > 0:; dW[a_idx, t_idx, j, :] = np.random.poisson(dw_expect,; d2_len); else:; dW[a_idx, t_idx, j, :] = np.zeros(d2_len). rho_t = sso.rhs(L_data, rho_t, t + dt * j,; A_ops, dt, dW[:, t_idx, j, :], d1, d2, sso.args). if sso.store_measurement:; for m_idx, m in enumerate(sso.s_m_ops):; for dW_idx, dW_factor in enumerate(sso.dW_factors):; if m[dW_idx]:; m_expt = cy_expect_rho_vec(m[dW_idx].data, rho_prev, 0); else:; m_expt = 0; measurements[t_idx, m_idx, dW_idx] = m_expt + dW_factor * \; dW[m_idx, t_idx, :, dW_idx].sum() / (dt * N_substeps). if d2_len == 1:; measurements = measurements.squeeze(axis=(2)). return states_list, dW, measurements, expect, ss. # -----------------------------------------------------------------------------; # Generic parameterized stochastic SE PDP solver; #; def _ssepdpsolve_generic(sso, options, progress_bar):; """"""; For internal use. See ssepdpsolve.; """"""; if debug:; logger.debug(inspect.stack()[0][3]). N_store = len(sso.times); N_substeps = sso.nsubsteps; dt = (sso.times[1] - sso.times[0]) / N_substeps; nt = sso.ntraj. data = Result(); data.solver = ""sepdpsolve""; data.times = sso.tlist; data.expect = np.zeros((len(sso.e_ops), N_store), dtype=complex); data.ss = np.zeros((len(sso.e_ops), N_store), dtype=complex); data.jump_times = []; data.jump_op_idx = []. # effective hamiltonian for deterministic part; Heff = sso.H; for c in sso.c_ops:; Heff += -0.5j * c.dag() * c. progress_bar.start(sso.ntraj); for n in range(sso.ntraj):; progress_bar.update(n); psi_t = sso.state0.full().ravel(). states_list, jump_times, jump_op_idx = \; _ssepdpsolve_single_trajectory(data, Heff, dt, sso.times,; N_store, N_substeps,; psi_t, sso.state0.dims,; sso.c_ops, sso.e_ops). data.states.append(states_list); data.jump_times.append(jump",MatchSource.WIKI,docs/4.2/modules/qutip/stochastic.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/stochastic.html
https://qutip.org/docs/4.2/modules/qutip/stochastic.html:33711,Modifiability,parameteriz,parameterized,33711,"ata * psi_t) ** 2 for c in c_ops]); p = np.cumsum(p / np.sum(p)); n = np.where(p >= r_op)[0][0]. # apply jump; psi_t = c_ops[n].data * psi_t; psi_t /= norm(psi_t); phi_t = np.copy(psi_t). # store info about jump; jump_times.append(times[t_idx] + dt * j); jump_op_idx.append(n). # get new random numbers for next jump; r_jump, r_op = prng.rand(2). # deterministic evolution wihtout correction for norm decay; dphi_t = (-1.0j * dt) * (Heff.data * phi_t). # deterministic evolution with correction for norm decay; dpsi_t = (-1.0j * dt) * (Heff.data * psi_t); A = 0.5 * np.sum([norm(c.data * psi_t) ** 2 for c in c_ops]); dpsi_t += dt * A * psi_t. # increment wavefunctions; phi_t += dphi_t; psi_t += dpsi_t. # ensure that normalized wavefunction remains normalized; # this allows larger time step than otherwise would be possible; psi_t /= norm(psi_t). return states_list, jump_times, jump_op_idx. # -----------------------------------------------------------------------------; # Generic parameterized stochastic ME PDP solver; #; def _smepdpsolve_generic(sso, options, progress_bar):; """"""; For internal use. See smepdpsolve.; """"""; if debug:; logger.debug(inspect.stack()[0][3]). N_store = len(sso.times); N_substeps = sso.nsubsteps; dt = (sso.times[1] - sso.times[0]) / N_substeps; nt = sso.ntraj. data = Result(); data.solver = ""smepdpsolve""; data.times = sso.times; data.expect = np.zeros((len(sso.e_ops), N_store), dtype=complex); data.jump_times = []; data.jump_op_idx = []. # Liouvillian for the deterministic part.; # needs to be modified for TD systems; L = liouvillian(sso.H, sso.c_ops). progress_bar.start(sso.ntraj). for n in range(sso.ntraj):; progress_bar.update(n); rho_t = mat2vec(sso.rho0.full()).ravel(). states_list, jump_times, jump_op_idx = \; _smepdpsolve_single_trajectory(data, L, dt, sso.times,; N_store, N_substeps,; rho_t, sso.rho0.dims,; sso.c_ops, sso.e_ops). data.states.append(states_list); data.jump_times.append(jump_times); data.jump_op_idx.append(jump_op_idx). progres",MatchSource.WIKI,docs/4.2/modules/qutip/stochastic.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/stochastic.html
https://qutip.org/docs/4.2/modules/qutip/stochastic.html:2347,Performance,optimiz,optimizing,2347,"ARRANTIES, INCLUDING, BUT NOT; # LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A; # PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT; # HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,; # SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT; # LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,; # DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY; # THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT; # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE; # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.; #; # Significant parts of this code were contributed by Denis Vasilyev.; #; ###############################################################################; """"""; This module contains functions for solving stochastic schrodinger and master; equations. The API should not be considered stable, and is subject to change; when we work more on optimizing this module for performance and features.; """""". __all__ = ['ssesolve', 'ssepdpsolve', 'smesolve', 'smepdpsolve']. import numpy as np; import scipy.sparse as sp; from scipy.linalg.blas import get_blas_funcs; try:; norm = get_blas_funcs(""znrm2"", dtype=np.float64); except:; from scipy.linalg import norm. from numpy.random import RandomState. from qutip.qobj import Qobj, isket; from qutip.states import ket2dm; from qutip.solver import Result; from qutip.expect import expect, expect_rho_vec; from qutip.superoperator import (spre, spost, mat2vec, vec2mat,; liouvillian, lindblad_dissipator); from qutip.cy.spmatfuncs import cy_expect_psi_csr, spmv, cy_expect_rho_vec; from qutip.cy.stochastic import (cy_d1_rho_photocurrent,; cy_d2_rho_photocurrent); from qutip.parallel import serial_map; from qutip.ui.progressbar import TextProgressBar; from qutip.solver import Options, _solver_safety_check; from qutip.settings import debug. if debug:; import qutip.logging_utils; im",MatchSource.WIKI,docs/4.2/modules/qutip/stochastic.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/stochastic.html
https://qutip.org/docs/4.2/modules/qutip/stochastic.html:2374,Performance,perform,performance,2374,"ARRANTIES, INCLUDING, BUT NOT; # LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A; # PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT; # HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,; # SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT; # LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,; # DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY; # THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT; # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE; # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.; #; # Significant parts of this code were contributed by Denis Vasilyev.; #; ###############################################################################; """"""; This module contains functions for solving stochastic schrodinger and master; equations. The API should not be considered stable, and is subject to change; when we work more on optimizing this module for performance and features.; """""". __all__ = ['ssesolve', 'ssepdpsolve', 'smesolve', 'smepdpsolve']. import numpy as np; import scipy.sparse as sp; from scipy.linalg.blas import get_blas_funcs; try:; norm = get_blas_funcs(""znrm2"", dtype=np.float64); except:; from scipy.linalg import norm. from numpy.random import RandomState. from qutip.qobj import Qobj, isket; from qutip.states import ket2dm; from qutip.solver import Result; from qutip.expect import expect, expect_rho_vec; from qutip.superoperator import (spre, spost, mat2vec, vec2mat,; liouvillian, lindblad_dissipator); from qutip.cy.spmatfuncs import cy_expect_psi_csr, spmv, cy_expect_rho_vec; from qutip.cy.stochastic import (cy_d1_rho_photocurrent,; cy_d2_rho_photocurrent); from qutip.parallel import serial_map; from qutip.ui.progressbar import TextProgressBar; from qutip.solver import Options, _solver_safety_check; from qutip.settings import debug. if debug:; import qutip.logging_utils; im",MatchSource.WIKI,docs/4.2/modules/qutip/stochastic.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/stochastic.html
https://qutip.org/docs/4.2/modules/qutip/stochastic.html:51086,Performance,optimiz,optimizations,51086,"urn dpsi_t. # -----------------------------------------------------------------------------; # Milstein rhs functions for the stochastic master equation; #; def _rhs_rho_milstein_homodyne_single(L, rho_t, t, A_ops, dt, dW, d1, d2,; args):; """"""; .. note::. Experimental.; Milstein scheme for homodyne detection with single jump operator. """"""; A = A_ops[0]; M = A[0] + A[3]; e1 = cy_expect_rho_vec(M, rho_t, 0). d2_vec = spmv(M, rho_t); d2_vec2 = spmv(M, d2_vec); e2 = cy_expect_rho_vec(M, d2_vec, 0). drho_t = _rhs_rho_deterministic(L, rho_t, t, dt, args); drho_t += spmv(A[7], rho_t) * dt; drho_t += (d2_vec - e1 * rho_t) * dW[0, 0]; drho_t += 0.5 * (d2_vec2 - 2 * e1 * d2_vec + (-e2 + 2 * e1 * e1) *; rho_t) * (dW[0, 0] * dW[0, 0] - dt); return rho_t + drho_t. def _rhs_rho_milstein_homodyne(L, rho_t, t, A_ops, dt, dW, d1, d2, args):; """"""; .. note::. Experimental.; Milstein scheme for homodyne detection.; This implementation works for commuting stochastic jump operators.; TODO: optimizations: do calculation for n>m only. """"""; A_len = len(A_ops). M = np.array([A_ops[n][0] + A_ops[n][3] for n in range(A_len)]); e1 = np.array([cy_expect_rho_vec(M[n], rho_t, 0) for n in range(A_len)]). d1_vec = np.sum([spmv(A_ops[n][7], rho_t); for n in range(A_len)], axis=0). d2_vec = np.array([spmv(M[n], rho_t); for n in range(A_len)]). # This calculation is suboptimal. We need only values for m>n in case of; # commuting jump operators.; d2_vec2 = np.array([[spmv(M[n], d2_vec[m]); for m in range(A_len)] for n in range(A_len)]); e2 = np.array([[cy_expect_rho_vec(M[n], d2_vec[m], 0); for m in range(A_len)] for n in range(A_len)]). drho_t = _rhs_rho_deterministic(L, rho_t, t, dt, args); drho_t += d1_vec * dt; drho_t += np.sum([(d2_vec[n] - e1[n] * rho_t) * dW[n, 0]; for n in range(A_len)], axis=0); drho_t += 0.5 * np.sum(; [(d2_vec2[n, n] - 2.0 * e1[n] * d2_vec[n] +; (-e2[n, n] + 2.0 * e1[n] * e1[n]) * rho_t) * (dW[n, 0]*dW[n, 0] - dt); for n in range(A_len)], axis=0). # This calculation is subopti",MatchSource.WIKI,docs/4.2/modules/qutip/stochastic.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/stochastic.html
https://qutip.org/docs/4.2/modules/qutip/stochastic.html:6601,Safety,predict,predictor-corrector,6601,"ay; Array of length d2_len, containing scaling factors for each; measurement operator in m_ops. rhs : function; Function for calculating the deterministic and stochastic contributions; to the right-hand side of the stochastic differential equation. This; only needs to be specified when implementing a custom SDE solver. generate_A_ops : function; Function that generates a list of pre-computed operators or super-; operators. These precomputed operators are used in some d1 and d2; functions. generate_noise : function; Function for generate an array of pre-computed noise signal. homogeneous : bool (True); Wheter or not the stochastic process is homogenous. Inhomogenous; processes are only supported for poisson distributions. solver : string; Name of the solver method to use for solving the stochastic; equations. Valid values are: ; 1/2 order algorithms: 'euler-maruyama', 'fast-euler-maruyama',; 'pc-euler' is a predictor-corrector method which is more ; stable than explicit methods,; 1 order algorithms: 'milstein', 'fast-milstein', 'platen',; 'milstein-imp' is semi-implicit Milstein method,; 3/2 order algorithms: 'taylor15', ; 'taylor15-imp' is semi-implicit Taylor 1.5 method.; Implicit methods can adjust tolerance via args = {'tol':value},; default is {'tol':1e-6}. method : string ('homodyne', 'heterodyne', 'photocurrent'); The name of the type of measurement process that give rise to the; stochastic equation to solve. Specifying a method with this keyword; argument is a short-hand notation for using pre-defined d1 and d2; functions for the corresponding stochastic processes. distribution : string ('normal', 'poission'); The name of the distribution used for the stochastic increments. store_measurements : bool (default False); Whether or not to store the measurement results in the; :class:`qutip.solver.SolverResult` instance returned by the solver. noise : array; Vector specifying the noise. normalize : bool (default True); Whether or not to normalize the wave function ",MatchSource.WIKI,docs/4.2/modules/qutip/stochastic.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/stochastic.html
https://qutip.org/docs/4.2/modules/qutip/stochastic.html:37108,Safety,avoid,avoid,37108,"jump; r_jump, r_op = prng.rand(2). # deterministic evolution wihtout correction for norm decay; dsigma_t = spmv(L.data, sigma_t) * dt. # deterministic evolution with correction for norm decay; drho_t = spmv(L.data, rho_t) * dt. rho_t += drho_t. # increment density matrices; sigma_t += dsigma_t; rho_t += drho_t. return states_list, jump_times, jump_op_idx. # -----------------------------------------------------------------------------; # Helper-functions for stochastic DE; #; # d1 = deterministic part of the contribution to the DE RHS function, to be; # multiplied by the increament dt; #; # d1 = stochastic part of the contribution to the DE RHS function, to be; # multiplied by the increament dW; #. #; # For SSE; #. # Function sigurature:; #; # def d(A, psi):; #; # psi = wave function at the current time step; #; # A[0] = c; # A[1] = c + c.dag(); # A[2] = c - c.dag(); # A[3] = c.dag() * c; #; # where c is a collapse operator. The combinations of c's stored in A are; # precomputed before the time-evolution is started to avoid repeated; # computations. def _generate_psi_A_ops(sc_ops, H):; """"""; pre-compute superoperator operator combinations that are commonly needed; when evaluating the RHS of stochastic schrodinger equations; """""". A_ops = []; for c_idx, c in enumerate(sc_ops):; A_ops.append([c.data,; (c + c.dag()).data,; (c - c.dag()).data,; (c.dag() * c).data]). return A_ops. def d1_psi_homodyne(t, psi, A, args):; """"""; OK; Need to cythonize. .. math::. D_1(C, \psi) = \\frac{1}{2}(\\langle C + C^\\dagger\\rangle\\C psi -; C^\\dagger C\\psi - \\frac{1}{4}\\langle C + C^\\dagger\\rangle^2\\psi). """""". e1 = cy_expect_psi_csr(A[1].data, A[1].indices, A[1].indptr, psi, 0); return 0.5 * (e1 * spmv(A[0], psi) -; spmv(A[3], psi) -; 0.25 * e1 ** 2 * psi). def d2_psi_homodyne(t, psi, A, args):; """"""; OK; Need to cythonize. .. math::. D_2(\psi, t) = (C - \\frac{1}{2}\\langle C + C^\\dagger\\rangle)\\psi. """""". e1 = cy_expect_psi_csr(A[1].data, A[1].indices, A[1].indptr, psi, 0); retur",MatchSource.WIKI,docs/4.2/modules/qutip/stochastic.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/stochastic.html
https://qutip.org/docs/4.2/modules/qutip/stochastic.html:48768,Safety,detect,detection,48768,"r the stochastic Schrodinger and master; # equations; #. def _rhs_psi_euler_maruyama(H, psi_t, t, A_ops, dt, dW, d1, d2, args):; """"""; Euler-Maruyama rhs function for wave function solver.; """"""; dW_len = len(dW[0, :]); dpsi_t = _rhs_psi_deterministic(H, psi_t, t, dt, args). for a_idx, A in enumerate(A_ops):; d2_vec = d2(t, psi_t, A, args); dpsi_t += d1(t, psi_t, A, args) * dt + \; np.sum([d2_vec[n] * dW[a_idx, n]; for n in range(dW_len) if dW[a_idx, n] != 0], axis=0). return psi_t + dpsi_t. def _rhs_rho_euler_maruyama(L, rho_t, t, A_ops, dt, dW, d1, d2, args):; """"""; Euler-Maruyama rhs function for density matrix solver.; """"""; dW_len = len(dW[0, :]). drho_t = _rhs_rho_deterministic(L, rho_t, t, dt, args). for a_idx, A in enumerate(A_ops):; d2_vec = d2(t, rho_t, A, args); drho_t += d1(t, rho_t, A, args) * dt; drho_t += np.sum([d2_vec[n] * dW[a_idx, n]; for n in range(dW_len) if dW[a_idx, n] != 0], axis=0). return rho_t + drho_t. def _rhs_rho_euler_homodyne_fast(L, rho_t, t, A, dt, ddW, d1, d2, args):; """"""; Fast Euler-Maruyama for homodyne detection.; """""". dW = ddW[:, 0]. d_vec = spmv(A[0][0], rho_t).reshape(-1, len(rho_t)); e = d_vec[:-1].reshape(-1, A[0][1], A[0][1]).trace(axis1=1, axis2=2). drho_t = d_vec[-1]; drho_t += np.dot(dW, d_vec[:-1]); drho_t += (1.0 - np.inner(np.real(e), dW)) * rho_t; return drho_t. # -----------------------------------------------------------------------------; # Platen method; #; def _rhs_psi_platen(H, psi_t, t, A_ops, dt, dW, d1, d2, args):; """"""; TODO: support multiple stochastic increments. .. note::. Experimental. """""". sqrt_dt = np.sqrt(dt). dpsi_t = _rhs_psi_deterministic(H, psi_t, t, dt, args). for a_idx, A in enumerate(A_ops):; # XXX: This needs to be revised now that; # dpsi_t is the change for all stochastic collapse operators. # TODO: needs to be updated to support mutiple Weiner increments; dpsi_t_H = (-1.0j * dt) * spmv(H, psi_t). psi_t_1 = (psi_t + dpsi_t_H +; d1(A, psi_t) * dt +; d2(A, psi_t)[0] * dW[a_idx, 0]); psi_t_p = (psi",MatchSource.WIKI,docs/4.2/modules/qutip/stochastic.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/stochastic.html
https://qutip.org/docs/4.2/modules/qutip/stochastic.html:50403,Safety,detect,detection,50403," # XXX: This needs to be revised now that; # dpsi_t is the change for all stochastic collapse operators. # TODO: needs to be updated to support mutiple Weiner increments; dpsi_t_H = (-1.0j * dt) * spmv(H, psi_t). psi_t_1 = (psi_t + dpsi_t_H +; d1(A, psi_t) * dt +; d2(A, psi_t)[0] * dW[a_idx, 0]); psi_t_p = (psi_t + dpsi_t_H +; d1(A, psi_t) * dt +; d2(A, psi_t)[0] * sqrt_dt); psi_t_m = (psi_t + dpsi_t_H +; d1(A, psi_t) * dt -; d2(A, psi_t)[0] * sqrt_dt). dpsi_t += (; 0.50 * (d1(A, psi_t_1) + d1(A, psi_t)) * dt +; 0.25 * (d2(A, psi_t_p)[0] + d2(A, psi_t_m)[0] +; 2 * d2(A, psi_t)[0]) * dW[a_idx, 0] +; 0.25 * (d2(A, psi_t_p)[0] - d2(A, psi_t_m)[0]) *; (dW[a_idx, 0] ** 2 - dt) / sqrt_dt; ). return dpsi_t. # -----------------------------------------------------------------------------; # Milstein rhs functions for the stochastic master equation; #; def _rhs_rho_milstein_homodyne_single(L, rho_t, t, A_ops, dt, dW, d1, d2,; args):; """"""; .. note::. Experimental.; Milstein scheme for homodyne detection with single jump operator. """"""; A = A_ops[0]; M = A[0] + A[3]; e1 = cy_expect_rho_vec(M, rho_t, 0). d2_vec = spmv(M, rho_t); d2_vec2 = spmv(M, d2_vec); e2 = cy_expect_rho_vec(M, d2_vec, 0). drho_t = _rhs_rho_deterministic(L, rho_t, t, dt, args); drho_t += spmv(A[7], rho_t) * dt; drho_t += (d2_vec - e1 * rho_t) * dW[0, 0]; drho_t += 0.5 * (d2_vec2 - 2 * e1 * d2_vec + (-e2 + 2 * e1 * e1) *; rho_t) * (dW[0, 0] * dW[0, 0] - dt); return rho_t + drho_t. def _rhs_rho_milstein_homodyne(L, rho_t, t, A_ops, dt, dW, d1, d2, args):; """"""; .. note::. Experimental.; Milstein scheme for homodyne detection.; This implementation works for commuting stochastic jump operators.; TODO: optimizations: do calculation for n>m only. """"""; A_len = len(A_ops). M = np.array([A_ops[n][0] + A_ops[n][3] for n in range(A_len)]); e1 = np.array([cy_expect_rho_vec(M[n], rho_t, 0) for n in range(A_len)]). d1_vec = np.sum([spmv(A_ops[n][7], rho_t); for n in range(A_len)], axis=0). d2_vec = np.array([spmv(M[n], rho_t)",MatchSource.WIKI,docs/4.2/modules/qutip/stochastic.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/stochastic.html
https://qutip.org/docs/4.2/modules/qutip/stochastic.html:51000,Safety,detect,detection,51000,"0]) * dW[a_idx, 0] +; 0.25 * (d2(A, psi_t_p)[0] - d2(A, psi_t_m)[0]) *; (dW[a_idx, 0] ** 2 - dt) / sqrt_dt; ). return dpsi_t. # -----------------------------------------------------------------------------; # Milstein rhs functions for the stochastic master equation; #; def _rhs_rho_milstein_homodyne_single(L, rho_t, t, A_ops, dt, dW, d1, d2,; args):; """"""; .. note::. Experimental.; Milstein scheme for homodyne detection with single jump operator. """"""; A = A_ops[0]; M = A[0] + A[3]; e1 = cy_expect_rho_vec(M, rho_t, 0). d2_vec = spmv(M, rho_t); d2_vec2 = spmv(M, d2_vec); e2 = cy_expect_rho_vec(M, d2_vec, 0). drho_t = _rhs_rho_deterministic(L, rho_t, t, dt, args); drho_t += spmv(A[7], rho_t) * dt; drho_t += (d2_vec - e1 * rho_t) * dW[0, 0]; drho_t += 0.5 * (d2_vec2 - 2 * e1 * d2_vec + (-e2 + 2 * e1 * e1) *; rho_t) * (dW[0, 0] * dW[0, 0] - dt); return rho_t + drho_t. def _rhs_rho_milstein_homodyne(L, rho_t, t, A_ops, dt, dW, d1, d2, args):; """"""; .. note::. Experimental.; Milstein scheme for homodyne detection.; This implementation works for commuting stochastic jump operators.; TODO: optimizations: do calculation for n>m only. """"""; A_len = len(A_ops). M = np.array([A_ops[n][0] + A_ops[n][3] for n in range(A_len)]); e1 = np.array([cy_expect_rho_vec(M[n], rho_t, 0) for n in range(A_len)]). d1_vec = np.sum([spmv(A_ops[n][7], rho_t); for n in range(A_len)], axis=0). d2_vec = np.array([spmv(M[n], rho_t); for n in range(A_len)]). # This calculation is suboptimal. We need only values for m>n in case of; # commuting jump operators.; d2_vec2 = np.array([[spmv(M[n], d2_vec[m]); for m in range(A_len)] for n in range(A_len)]); e2 = np.array([[cy_expect_rho_vec(M[n], d2_vec[m], 0); for m in range(A_len)] for n in range(A_len)]). drho_t = _rhs_rho_deterministic(L, rho_t, t, dt, args); drho_t += d1_vec * dt; drho_t += np.sum([(d2_vec[n] - e1[n] * rho_t) * dW[n, 0]; for n in range(A_len)], axis=0); drho_t += 0.5 * np.sum(; [(d2_vec2[n, n] - 2.0 * e1[n] * d2_vec[n] +; (-e2[n, n] + 2.0 * ",MatchSource.WIKI,docs/4.2/modules/qutip/stochastic.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/stochastic.html
https://qutip.org/docs/4.2/modules/qutip/stochastic.html:52530,Safety,detect,detection,52530,"n case of; # commuting jump operators.; d2_vec2 = np.array([[spmv(M[n], d2_vec[m]); for m in range(A_len)] for n in range(A_len)]); e2 = np.array([[cy_expect_rho_vec(M[n], d2_vec[m], 0); for m in range(A_len)] for n in range(A_len)]). drho_t = _rhs_rho_deterministic(L, rho_t, t, dt, args); drho_t += d1_vec * dt; drho_t += np.sum([(d2_vec[n] - e1[n] * rho_t) * dW[n, 0]; for n in range(A_len)], axis=0); drho_t += 0.5 * np.sum(; [(d2_vec2[n, n] - 2.0 * e1[n] * d2_vec[n] +; (-e2[n, n] + 2.0 * e1[n] * e1[n]) * rho_t) * (dW[n, 0]*dW[n, 0] - dt); for n in range(A_len)], axis=0). # This calculation is suboptimal. We need only values for m>n in case of; # commuting jump operators.; drho_t += 0.5 * np.sum(; [(d2_vec2[n, m] - e1[m] * d2_vec[n] - e1[n] * d2_vec[m] +; (-e2[n, m] + 2.0 * e1[n] * e1[m]) * rho_t) * (dW[n, 0] * dW[m, 0]); for (n, m) in np.ndindex(A_len, A_len) if n != m], axis=0). return rho_t + drho_t. def _rhs_rho_milstein_homodyne_single_fast(L, rho_t, t, A, dt, ddW, d1, d2,; args):; """"""; fast Milstein for homodyne detection with 1 stochastic operator; """"""; dW = np.copy(ddW[:, 0]). d_vec = spmv(A[0][0], rho_t).reshape(-1, len(rho_t)); e = np.real(; d_vec[:-1].reshape(-1, A[0][1], A[0][1]).trace(axis1=1, axis2=2)). e[1] -= 2.0 * e[0] * e[0]. drho_t = - np.inner(e, dW) * rho_t; dW[0] -= 2.0 * e[0] * dW[1]. drho_t += d_vec[-1]; drho_t += np.dot(dW, d_vec[:-1]). return rho_t + drho_t. def _rhs_rho_milstein_homodyne_two_fast(L, rho_t, t, A, dt, ddW, d1, d2, args):; """"""; fast Milstein for homodyne detection with 2 stochastic operators; """"""; dW = np.copy(ddW[:, 0]). d_vec = spmv(A[0][0], rho_t).reshape(-1, len(rho_t)); e = np.real(; d_vec[:-1].reshape(-1, A[0][1], A[0][1]).trace(axis1=1, axis2=2)); d_vec[-2] -= np.dot(e[:2][::-1], d_vec[:2]). e[2:4] -= 2.0 * e[:2] * e[:2]; e[4] -= 2.0 * e[1] * e[0]. drho_t = - np.inner(e, dW) * rho_t; dW[:2] -= 2.0 * e[:2] * dW[2:4]. drho_t += d_vec[-1]; drho_t += np.dot(dW, d_vec[:-1]). return rho_t + drho_t. def _rhs_rho_milstein_homod",MatchSource.WIKI,docs/4.2/modules/qutip/stochastic.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/stochastic.html
https://qutip.org/docs/4.2/modules/qutip/stochastic.html:53016,Safety,detect,detection,53016,".0 * e1[n] * e1[n]) * rho_t) * (dW[n, 0]*dW[n, 0] - dt); for n in range(A_len)], axis=0). # This calculation is suboptimal. We need only values for m>n in case of; # commuting jump operators.; drho_t += 0.5 * np.sum(; [(d2_vec2[n, m] - e1[m] * d2_vec[n] - e1[n] * d2_vec[m] +; (-e2[n, m] + 2.0 * e1[n] * e1[m]) * rho_t) * (dW[n, 0] * dW[m, 0]); for (n, m) in np.ndindex(A_len, A_len) if n != m], axis=0). return rho_t + drho_t. def _rhs_rho_milstein_homodyne_single_fast(L, rho_t, t, A, dt, ddW, d1, d2,; args):; """"""; fast Milstein for homodyne detection with 1 stochastic operator; """"""; dW = np.copy(ddW[:, 0]). d_vec = spmv(A[0][0], rho_t).reshape(-1, len(rho_t)); e = np.real(; d_vec[:-1].reshape(-1, A[0][1], A[0][1]).trace(axis1=1, axis2=2)). e[1] -= 2.0 * e[0] * e[0]. drho_t = - np.inner(e, dW) * rho_t; dW[0] -= 2.0 * e[0] * dW[1]. drho_t += d_vec[-1]; drho_t += np.dot(dW, d_vec[:-1]). return rho_t + drho_t. def _rhs_rho_milstein_homodyne_two_fast(L, rho_t, t, A, dt, ddW, d1, d2, args):; """"""; fast Milstein for homodyne detection with 2 stochastic operators; """"""; dW = np.copy(ddW[:, 0]). d_vec = spmv(A[0][0], rho_t).reshape(-1, len(rho_t)); e = np.real(; d_vec[:-1].reshape(-1, A[0][1], A[0][1]).trace(axis1=1, axis2=2)); d_vec[-2] -= np.dot(e[:2][::-1], d_vec[:2]). e[2:4] -= 2.0 * e[:2] * e[:2]; e[4] -= 2.0 * e[1] * e[0]. drho_t = - np.inner(e, dW) * rho_t; dW[:2] -= 2.0 * e[:2] * dW[2:4]. drho_t += d_vec[-1]; drho_t += np.dot(dW, d_vec[:-1]). return rho_t + drho_t. def _rhs_rho_milstein_homodyne_fast(L, rho_t, t, A, dt, ddW, d1, d2, args):; """"""; fast Milstein for homodyne detection with >2 stochastic operators; """"""; dW = np.copy(ddW[:, 0]); sc_len = len(A); sc2_len = 2 * sc_len. d_vec = spmv(A[0][0], rho_t).reshape(-1, len(rho_t)); e = np.real(d_vec[:-1].reshape(; -1, A[0][1], A[0][1]).trace(axis1=1, axis2=2)); d_vec[sc2_len:-1] -= np.array(; [e[m] * d_vec[n] + e[n] * d_vec[m]; for (n, m) in np.ndindex(sc_len, sc_len) if n > m]). e[sc_len:sc2_len] -= 2.0 * e[:sc_len] * e",MatchSource.WIKI,docs/4.2/modules/qutip/stochastic.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/stochastic.html
https://qutip.org/docs/4.2/modules/qutip/stochastic.html:53579,Safety,detect,detection,53579,"chastic operator; """"""; dW = np.copy(ddW[:, 0]). d_vec = spmv(A[0][0], rho_t).reshape(-1, len(rho_t)); e = np.real(; d_vec[:-1].reshape(-1, A[0][1], A[0][1]).trace(axis1=1, axis2=2)). e[1] -= 2.0 * e[0] * e[0]. drho_t = - np.inner(e, dW) * rho_t; dW[0] -= 2.0 * e[0] * dW[1]. drho_t += d_vec[-1]; drho_t += np.dot(dW, d_vec[:-1]). return rho_t + drho_t. def _rhs_rho_milstein_homodyne_two_fast(L, rho_t, t, A, dt, ddW, d1, d2, args):; """"""; fast Milstein for homodyne detection with 2 stochastic operators; """"""; dW = np.copy(ddW[:, 0]). d_vec = spmv(A[0][0], rho_t).reshape(-1, len(rho_t)); e = np.real(; d_vec[:-1].reshape(-1, A[0][1], A[0][1]).trace(axis1=1, axis2=2)); d_vec[-2] -= np.dot(e[:2][::-1], d_vec[:2]). e[2:4] -= 2.0 * e[:2] * e[:2]; e[4] -= 2.0 * e[1] * e[0]. drho_t = - np.inner(e, dW) * rho_t; dW[:2] -= 2.0 * e[:2] * dW[2:4]. drho_t += d_vec[-1]; drho_t += np.dot(dW, d_vec[:-1]). return rho_t + drho_t. def _rhs_rho_milstein_homodyne_fast(L, rho_t, t, A, dt, ddW, d1, d2, args):; """"""; fast Milstein for homodyne detection with >2 stochastic operators; """"""; dW = np.copy(ddW[:, 0]); sc_len = len(A); sc2_len = 2 * sc_len. d_vec = spmv(A[0][0], rho_t).reshape(-1, len(rho_t)); e = np.real(d_vec[:-1].reshape(; -1, A[0][1], A[0][1]).trace(axis1=1, axis2=2)); d_vec[sc2_len:-1] -= np.array(; [e[m] * d_vec[n] + e[n] * d_vec[m]; for (n, m) in np.ndindex(sc_len, sc_len) if n > m]). e[sc_len:sc2_len] -= 2.0 * e[:sc_len] * e[:sc_len]; e[sc2_len:] -= 2.0 * np.array(; [e[n] * e[m] for (n, m) in np.ndindex(sc_len, sc_len) if n > m]). drho_t = - np.inner(e, dW) * rho_t; dW[:sc_len] -= 2.0 * e[:sc_len] * dW[sc_len:sc2_len]. drho_t += d_vec[-1]; drho_t += np.dot(dW, d_vec[:-1]). return rho_t + drho_t. def _rhs_rho_taylor_15_one(L, rho_t, t, A, dt, ddW, d1, d2,; args):; """"""; strong order 1.5 Tylor scheme for homodyne detection with 1 stochastic operator; """""". dW = ddW[:, 0]; A = A[0]. #reusable operators and traces; a = A[-1] * rho_t; e0 = cy_expect_rho_vec(A[0], rho_t, 1); b = A[0] * r",MatchSource.WIKI,docs/4.2/modules/qutip/stochastic.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/stochastic.html
https://qutip.org/docs/4.2/modules/qutip/stochastic.html:54379,Safety,detect,detection,54379,"2:4]. drho_t += d_vec[-1]; drho_t += np.dot(dW, d_vec[:-1]). return rho_t + drho_t. def _rhs_rho_milstein_homodyne_fast(L, rho_t, t, A, dt, ddW, d1, d2, args):; """"""; fast Milstein for homodyne detection with >2 stochastic operators; """"""; dW = np.copy(ddW[:, 0]); sc_len = len(A); sc2_len = 2 * sc_len. d_vec = spmv(A[0][0], rho_t).reshape(-1, len(rho_t)); e = np.real(d_vec[:-1].reshape(; -1, A[0][1], A[0][1]).trace(axis1=1, axis2=2)); d_vec[sc2_len:-1] -= np.array(; [e[m] * d_vec[n] + e[n] * d_vec[m]; for (n, m) in np.ndindex(sc_len, sc_len) if n > m]). e[sc_len:sc2_len] -= 2.0 * e[:sc_len] * e[:sc_len]; e[sc2_len:] -= 2.0 * np.array(; [e[n] * e[m] for (n, m) in np.ndindex(sc_len, sc_len) if n > m]). drho_t = - np.inner(e, dW) * rho_t; dW[:sc_len] -= 2.0 * e[:sc_len] * dW[sc_len:sc2_len]. drho_t += d_vec[-1]; drho_t += np.dot(dW, d_vec[:-1]). return rho_t + drho_t. def _rhs_rho_taylor_15_one(L, rho_t, t, A, dt, ddW, d1, d2,; args):; """"""; strong order 1.5 Tylor scheme for homodyne detection with 1 stochastic operator; """""". dW = ddW[:, 0]; A = A[0]. #reusable operators and traces; a = A[-1] * rho_t; e0 = cy_expect_rho_vec(A[0], rho_t, 1); b = A[0] * rho_t - e0 * rho_t; TrAb = cy_expect_rho_vec(A[0], b, 1); Lb = A[0] * b - TrAb * rho_t - e0 * b; TrALb = cy_expect_rho_vec(A[0], Lb, 1); TrAa = cy_expect_rho_vec(A[0], a, 1). drho_t = a * dt; drho_t += b * dW[0]; drho_t += Lb * dW[1] # Milstein term. # new terms: ; drho_t += A[-1] * b * dW[2]; drho_t += (A[0] * a - TrAa * rho_t - e0 * a - TrAb * b) * dW[3]; drho_t += A[-1] * a * (0.5 * dt*dt); drho_t += (A[0] * Lb - TrALb * rho_t - (2 * TrAb) * b - e0 * Lb) * dW[4] ; ; return rho_t + drho_t. #include _rhs_rho_Taylor_15_two#. def _rhs_rho_milstein_implicit(L, rho_t, t, A, dt, ddW, d1, d2, args):; """"""; Drift implicit Milstein (theta = 1/2, eta = 0); Wang, X., Gan, S., & Wang, D. (2012). ; A family of fully implicit Milstein methods for stiff stochastic differential ; equations with multiplicative noise. ; BIT Numerical Mathema",MatchSource.WIKI,docs/4.2/modules/qutip/stochastic.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/stochastic.html
https://qutip.org/docs/4.2/modules/qutip/stochastic.html:56544,Safety,predict,prediction,56544,"* rho_t * (0.5 * dt); e0 = cy_expect_rho_vec(A[0], rho_t, 1); b = A[0] * rho_t - e0 * rho_t; TrAb = cy_expect_rho_vec(A[0], b, 1). drho_t = b * dW[0] ; drho_t += a; drho_t += (A[0] * b - TrAb * rho_t - e0 * b) * dW[1] # Milstein term; drho_t += rho_t. v, check = sp.linalg.bicgstab(A[-2], drho_t, x0 = drho_t + a, tol=args['tol']). return v; ; def _rhs_rho_taylor_15_implicit(L, rho_t, t, A, dt, ddW, d1, d2, args):; """"""; Drift implicit Taylor 1.5 (alpha = 1/2, beta = doesn't matter); Chaptert 12.2 Eq. (2.18) in Numerical Solution of Stochastic Differential Equations; By Peter E. Kloeden, Eckhard Platen; """"""; ; dW = ddW[:, 0]; A = A[0]. #reusable operators and traces; a = A[-1] * rho_t; e0 = cy_expect_rho_vec(A[0], rho_t, 1); b = A[0] * rho_t - e0 * rho_t; TrAb = cy_expect_rho_vec(A[0], b, 1); Lb = A[0] * b - TrAb * rho_t - e0 * b; TrALb = cy_expect_rho_vec(A[0], Lb, 1); TrAa = cy_expect_rho_vec(A[0], a, 1). drho_t = b * dW[0] ; drho_t += Lb * dW[1] # Milstein term; xx0 = (drho_t + a * dt) + rho_t #starting vector for the linear solver (Milstein prediction); drho_t += (0.5 * dt) * a. # new terms: ; drho_t += A[-1] * b * (dW[2] - 0.5*dW[0]*dt); drho_t += (A[0] * a - TrAa * rho_t - e0 * a - TrAb * b) * dW[3]. drho_t += (A[0] * Lb - TrALb * rho_t - (2 * TrAb) * b - e0 * Lb) * dW[4]; drho_t += rho_t. v, check = sp.linalg.bicgstab(A[-2], drho_t, x0 = xx0, tol=args['tol']). return v; ; def _rhs_rho_pred_corr_homodyne_single(L, rho_t, t, A, dt, ddW, d1, d2,; args):; """"""; 1/2 predictor-corrector scheme for homodyne detection with 1 stochastic operator; """"""; dW = ddW[:, 0]; ; #predictor. d_vec = (A[0][0] * rho_t).reshape(-1, len(rho_t)); e = np.real(; d_vec[:-1].reshape(-1, A[0][1], A[0][1]).trace(axis1=1, axis2=2)). a_pred = np.copy(d_vec[-1]); b_pred = - e[0] * rho_t; b_pred += d_vec[0]. pred_rho_t = np.copy(a_pred); pred_rho_t += b_pred * dW[0]; pred_rho_t += rho_t. a_pred -= ((d_vec[1] - e[1] * rho_t) - (2.0 * e[0]) * b_pred) * (0.5 * dt); ; #corrector. d_vec = (A[0][0] * pre",MatchSource.WIKI,docs/4.2/modules/qutip/stochastic.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/stochastic.html
https://qutip.org/docs/4.2/modules/qutip/stochastic.html:56975,Safety,predict,predictor-corrector,56975,"t 12.2 Eq. (2.18) in Numerical Solution of Stochastic Differential Equations; By Peter E. Kloeden, Eckhard Platen; """"""; ; dW = ddW[:, 0]; A = A[0]. #reusable operators and traces; a = A[-1] * rho_t; e0 = cy_expect_rho_vec(A[0], rho_t, 1); b = A[0] * rho_t - e0 * rho_t; TrAb = cy_expect_rho_vec(A[0], b, 1); Lb = A[0] * b - TrAb * rho_t - e0 * b; TrALb = cy_expect_rho_vec(A[0], Lb, 1); TrAa = cy_expect_rho_vec(A[0], a, 1). drho_t = b * dW[0] ; drho_t += Lb * dW[1] # Milstein term; xx0 = (drho_t + a * dt) + rho_t #starting vector for the linear solver (Milstein prediction); drho_t += (0.5 * dt) * a. # new terms: ; drho_t += A[-1] * b * (dW[2] - 0.5*dW[0]*dt); drho_t += (A[0] * a - TrAa * rho_t - e0 * a - TrAb * b) * dW[3]. drho_t += (A[0] * Lb - TrALb * rho_t - (2 * TrAb) * b - e0 * Lb) * dW[4]; drho_t += rho_t. v, check = sp.linalg.bicgstab(A[-2], drho_t, x0 = xx0, tol=args['tol']). return v; ; def _rhs_rho_pred_corr_homodyne_single(L, rho_t, t, A, dt, ddW, d1, d2,; args):; """"""; 1/2 predictor-corrector scheme for homodyne detection with 1 stochastic operator; """"""; dW = ddW[:, 0]; ; #predictor. d_vec = (A[0][0] * rho_t).reshape(-1, len(rho_t)); e = np.real(; d_vec[:-1].reshape(-1, A[0][1], A[0][1]).trace(axis1=1, axis2=2)). a_pred = np.copy(d_vec[-1]); b_pred = - e[0] * rho_t; b_pred += d_vec[0]. pred_rho_t = np.copy(a_pred); pred_rho_t += b_pred * dW[0]; pred_rho_t += rho_t. a_pred -= ((d_vec[1] - e[1] * rho_t) - (2.0 * e[0]) * b_pred) * (0.5 * dt); ; #corrector. d_vec = (A[0][0] * pred_rho_t).reshape(-1, len(rho_t)); e = np.real(; d_vec[:-1].reshape(-1, A[0][1], A[0][1]).trace(axis1=1, axis2=2)). a_corr = d_vec[-1]; b_corr = - e[0] * pred_rho_t; b_corr += d_vec[0]. a_corr -= ((d_vec[1] - e[1] * pred_rho_t) - (2.0 * e[0]) * b_corr) * (0.5 * dt); a_corr += a_pred; a_corr *= 0.5. b_corr += b_pred; b_corr *= 0.5 * dW[0]. corr_rho_t = a_corr; corr_rho_t += b_corr; corr_rho_t += rho_t. return corr_rho_t.  Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchf",MatchSource.WIKI,docs/4.2/modules/qutip/stochastic.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/stochastic.html
https://qutip.org/docs/4.2/modules/qutip/stochastic.html:57015,Safety,detect,detection,57015,"t 12.2 Eq. (2.18) in Numerical Solution of Stochastic Differential Equations; By Peter E. Kloeden, Eckhard Platen; """"""; ; dW = ddW[:, 0]; A = A[0]. #reusable operators and traces; a = A[-1] * rho_t; e0 = cy_expect_rho_vec(A[0], rho_t, 1); b = A[0] * rho_t - e0 * rho_t; TrAb = cy_expect_rho_vec(A[0], b, 1); Lb = A[0] * b - TrAb * rho_t - e0 * b; TrALb = cy_expect_rho_vec(A[0], Lb, 1); TrAa = cy_expect_rho_vec(A[0], a, 1). drho_t = b * dW[0] ; drho_t += Lb * dW[1] # Milstein term; xx0 = (drho_t + a * dt) + rho_t #starting vector for the linear solver (Milstein prediction); drho_t += (0.5 * dt) * a. # new terms: ; drho_t += A[-1] * b * (dW[2] - 0.5*dW[0]*dt); drho_t += (A[0] * a - TrAa * rho_t - e0 * a - TrAb * b) * dW[3]. drho_t += (A[0] * Lb - TrALb * rho_t - (2 * TrAb) * b - e0 * Lb) * dW[4]; drho_t += rho_t. v, check = sp.linalg.bicgstab(A[-2], drho_t, x0 = xx0, tol=args['tol']). return v; ; def _rhs_rho_pred_corr_homodyne_single(L, rho_t, t, A, dt, ddW, d1, d2,; args):; """"""; 1/2 predictor-corrector scheme for homodyne detection with 1 stochastic operator; """"""; dW = ddW[:, 0]; ; #predictor. d_vec = (A[0][0] * rho_t).reshape(-1, len(rho_t)); e = np.real(; d_vec[:-1].reshape(-1, A[0][1], A[0][1]).trace(axis1=1, axis2=2)). a_pred = np.copy(d_vec[-1]); b_pred = - e[0] * rho_t; b_pred += d_vec[0]. pred_rho_t = np.copy(a_pred); pred_rho_t += b_pred * dW[0]; pred_rho_t += rho_t. a_pred -= ((d_vec[1] - e[1] * rho_t) - (2.0 * e[0]) * b_pred) * (0.5 * dt); ; #corrector. d_vec = (A[0][0] * pred_rho_t).reshape(-1, len(rho_t)); e = np.real(; d_vec[:-1].reshape(-1, A[0][1], A[0][1]).trace(axis1=1, axis2=2)). a_corr = d_vec[-1]; b_corr = - e[0] * pred_rho_t; b_corr += d_vec[0]. a_corr -= ((d_vec[1] - e[1] * pred_rho_t) - (2.0 * e[0]) * b_corr) * (0.5 * dt); a_corr += a_pred; a_corr *= 0.5. b_corr += b_pred; b_corr *= 0.5 * dW[0]. corr_rho_t = a_corr; corr_rho_t += b_corr; corr_rho_t += rho_t. return corr_rho_t.  Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchf",MatchSource.WIKI,docs/4.2/modules/qutip/stochastic.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/stochastic.html
https://qutip.org/docs/4.2/modules/qutip/stochastic.html:57077,Safety,predict,predictor,57077,"t 12.2 Eq. (2.18) in Numerical Solution of Stochastic Differential Equations; By Peter E. Kloeden, Eckhard Platen; """"""; ; dW = ddW[:, 0]; A = A[0]. #reusable operators and traces; a = A[-1] * rho_t; e0 = cy_expect_rho_vec(A[0], rho_t, 1); b = A[0] * rho_t - e0 * rho_t; TrAb = cy_expect_rho_vec(A[0], b, 1); Lb = A[0] * b - TrAb * rho_t - e0 * b; TrALb = cy_expect_rho_vec(A[0], Lb, 1); TrAa = cy_expect_rho_vec(A[0], a, 1). drho_t = b * dW[0] ; drho_t += Lb * dW[1] # Milstein term; xx0 = (drho_t + a * dt) + rho_t #starting vector for the linear solver (Milstein prediction); drho_t += (0.5 * dt) * a. # new terms: ; drho_t += A[-1] * b * (dW[2] - 0.5*dW[0]*dt); drho_t += (A[0] * a - TrAa * rho_t - e0 * a - TrAb * b) * dW[3]. drho_t += (A[0] * Lb - TrALb * rho_t - (2 * TrAb) * b - e0 * Lb) * dW[4]; drho_t += rho_t. v, check = sp.linalg.bicgstab(A[-2], drho_t, x0 = xx0, tol=args['tol']). return v; ; def _rhs_rho_pred_corr_homodyne_single(L, rho_t, t, A, dt, ddW, d1, d2,; args):; """"""; 1/2 predictor-corrector scheme for homodyne detection with 1 stochastic operator; """"""; dW = ddW[:, 0]; ; #predictor. d_vec = (A[0][0] * rho_t).reshape(-1, len(rho_t)); e = np.real(; d_vec[:-1].reshape(-1, A[0][1], A[0][1]).trace(axis1=1, axis2=2)). a_pred = np.copy(d_vec[-1]); b_pred = - e[0] * rho_t; b_pred += d_vec[0]. pred_rho_t = np.copy(a_pred); pred_rho_t += b_pred * dW[0]; pred_rho_t += rho_t. a_pred -= ((d_vec[1] - e[1] * rho_t) - (2.0 * e[0]) * b_pred) * (0.5 * dt); ; #corrector. d_vec = (A[0][0] * pred_rho_t).reshape(-1, len(rho_t)); e = np.real(; d_vec[:-1].reshape(-1, A[0][1], A[0][1]).trace(axis1=1, axis2=2)). a_corr = d_vec[-1]; b_corr = - e[0] * pred_rho_t; b_corr += d_vec[0]. a_corr -= ((d_vec[1] - e[1] * pred_rho_t) - (2.0 * e[0]) * b_corr) * (0.5 * dt); a_corr += a_pred; a_corr *= 0.5. b_corr += b_pred; b_corr *= 0.5 * dW[0]. corr_rho_t = a_corr; corr_rho_t += b_corr; corr_rho_t += rho_t. return corr_rho_t.  Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchf",MatchSource.WIKI,docs/4.2/modules/qutip/stochastic.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/stochastic.html
https://qutip.org/docs/4.2/modules/qutip/stochastic.html:3343,Testability,log,logger,3343,"ork more on optimizing this module for performance and features.; """""". __all__ = ['ssesolve', 'ssepdpsolve', 'smesolve', 'smepdpsolve']. import numpy as np; import scipy.sparse as sp; from scipy.linalg.blas import get_blas_funcs; try:; norm = get_blas_funcs(""znrm2"", dtype=np.float64); except:; from scipy.linalg import norm. from numpy.random import RandomState. from qutip.qobj import Qobj, isket; from qutip.states import ket2dm; from qutip.solver import Result; from qutip.expect import expect, expect_rho_vec; from qutip.superoperator import (spre, spost, mat2vec, vec2mat,; liouvillian, lindblad_dissipator); from qutip.cy.spmatfuncs import cy_expect_psi_csr, spmv, cy_expect_rho_vec; from qutip.cy.stochastic import (cy_d1_rho_photocurrent,; cy_d2_rho_photocurrent); from qutip.parallel import serial_map; from qutip.ui.progressbar import TextProgressBar; from qutip.solver import Options, _solver_safety_check; from qutip.settings import debug. if debug:; import qutip.logging_utils; import inspect; logger = qutip.logging_utils.get_logger(). [docs]class StochasticSolverOptions:; """"""Class of options for stochastic solvers such as; :func:`qutip.stochastic.ssesolve`, :func:`qutip.stochastic.smesolve`, etc.; Options can be specified either as arguments to the constructor::. sso = StochasticSolverOptions(nsubsteps=100, ...). or by changing the class attributes after creation::. sso = StochasticSolverOptions(); sso.nsubsteps = 1000. The stochastic solvers :func:`qutip.stochastic.ssesolve`,; :func:`qutip.stochastic.smesolve`, :func:`qutip.stochastic.ssepdpsolve` and; :func:`qutip.stochastic.smepdpsolve` all take the same keyword arguments as; the constructor of these class, and internally they use these arguments to; construct an instance of this class, so it is rarely needed to explicitly; create an instance of this class. Attributes; ----------. H : :class:`qutip.Qobj`; System Hamiltonian. state0 : :class:`qutip.Qobj`; Initial state vector (ket) or density matrix. times : *list",MatchSource.WIKI,docs/4.2/modules/qutip/stochastic.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/stochastic.html
https://qutip.org/docs/4.2/modules/qutip/stochastic.html:10547,Testability,log,logger,10547,"s, sc_ops=[], e_ops=[], _safe_mode=True, **kwargs):; """"""; Solve the stochastic Schrdinger equation. Dispatch to specific solvers; depending on the value of the `solver` keyword argument. Parameters; ----------. H : :class:`qutip.Qobj`; System Hamiltonian. psi0 : :class:`qutip.Qobj`; Initial state vector (ket). times : *list* / *array*; List of times for :math:`t`. Must be uniformly spaced. sc_ops : list of :class:`qutip.Qobj`; List of stochastic collapse operators. Each stochastic collapse; operator will give a deterministic and stochastic contribution; to the equation of motion according to how the d1 and d2 functions; are defined. e_ops : list of :class:`qutip.Qobj`; Single operator or list of operators for which to evaluate; expectation values. kwargs : *dictionary*; Optional keyword arguments. See; :class:`qutip.stochastic.StochasticSolverOptions`. Returns; -------. output: :class:`qutip.solver.SolverResult`; An instance of the class :class:`qutip.solver.SolverResult`.; """"""; if debug:; logger.debug(inspect.stack()[0][3]). if isinstance(e_ops, dict):; e_ops_dict = e_ops; e_ops = [e for e in e_ops.values()]; else:; e_ops_dict = None; ; if _safe_mode:; _solver_safety_check(H, psi0, sc_ops, e_ops); ; sso = StochasticSolverOptions(H=H, state0=psi0, times=times,; sc_ops=sc_ops, e_ops=e_ops, **kwargs). if sso.generate_A_ops is None:; sso.generate_A_ops = _generate_psi_A_ops. if (sso.d1 is None) or (sso.d2 is None):. if sso.method == 'homodyne':; sso.d1 = d1_psi_homodyne; sso.d2 = d2_psi_homodyne; sso.d2_len = 1; sso.homogeneous = True; sso.distribution = 'normal'; if ""dW_factors"" not in kwargs:; sso.dW_factors = np.array([1]); if ""m_ops"" not in kwargs:; sso.m_ops = [[c + c.dag()] for c in sso.sc_ops]. elif sso.method == 'heterodyne':; sso.d1 = d1_psi_heterodyne; sso.d2 = d2_psi_heterodyne; sso.d2_len = 2; sso.homogeneous = True; sso.distribution = 'normal'; if ""dW_factors"" not in kwargs:; sso.dW_factors = np.array([np.sqrt(2), np.sqrt(2)]); if ""m_ops"" not in kwargs:; s",MatchSource.WIKI,docs/4.2/modules/qutip/stochastic.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/stochastic.html
https://qutip.org/docs/4.2/modules/qutip/stochastic.html:13734,Testability,log,logger,13734,"ho0 : :class:`qutip.Qobj`; Initial density matrix or state vector (ket). times : *list* / *array*; List of times for :math:`t`. Must be uniformly spaced. c_ops : list of :class:`qutip.Qobj`; Deterministic collapse operator which will contribute with a standard; Lindblad type of dissipation. sc_ops : list of :class:`qutip.Qobj`; List of stochastic collapse operators. Each stochastic collapse; operator will give a deterministic and stochastic contribution; to the eqaution of motion according to how the d1 and d2 functions; are defined. e_ops : list of :class:`qutip.Qobj` / callback function single; single operator or list of operators for which to evaluate; expectation values. kwargs : *dictionary*; Optional keyword arguments. See; :class:`qutip.stochastic.StochasticSolverOptions`. Returns; -------. output: :class:`qutip.solver.SolverResult`. An instance of the class :class:`qutip.solver.SolverResult`. TODO; ----; Add checks for commuting jump operators in Milstein method.; """""". if debug:; logger.debug(inspect.stack()[0][3]). if isket(rho0):; rho0 = ket2dm(rho0). if isinstance(e_ops, dict):; e_ops_dict = e_ops; e_ops = [e for e in e_ops.values()]; else:; e_ops_dict = None; ; if _safe_mode:; _solver_safety_check(H, rho0, c_ops+sc_ops, e_ops). sso = StochasticSolverOptions(H=H, state0=rho0, times=times, c_ops=c_ops,; sc_ops=sc_ops, e_ops=e_ops, **kwargs). if (sso.d1 is None) or (sso.d2 is None):. if sso.method == 'homodyne' or sso.method is None:; sso.d1 = d1_rho_homodyne; sso.d2 = d2_rho_homodyne; sso.d2_len = 1; sso.homogeneous = True; sso.distribution = 'normal'; if ""dW_factors"" not in kwargs:; sso.dW_factors = np.array([np.sqrt(1)]); if ""m_ops"" not in kwargs:; sso.m_ops = [[c + c.dag()] for c in sso.sc_ops]. elif sso.method == 'heterodyne':; sso.d1 = d1_rho_heterodyne; sso.d2 = d2_rho_heterodyne; sso.d2_len = 2; sso.homogeneous = True; sso.distribution = 'normal'; if ""dW_factors"" not in kwargs:; sso.dW_factors = np.array([np.sqrt(2), np.sqrt(2)]); if ""m_ops"" not in k",MatchSource.WIKI,docs/4.2/modules/qutip/stochastic.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/stochastic.html
https://qutip.org/docs/4.2/modules/qutip/stochastic.html:19474,Testability,log,logger,19474,"ict.keys())}. return res. [docs]def ssepdpsolve(H, psi0, times, c_ops, e_ops, **kwargs):; """"""; A stochastic (piecewse deterministic process) PDP solver for wavefunction; evolution. For most purposes, use :func:`qutip.mcsolve` instead for quantum; trajectory simulations. Parameters; ----------. H : :class:`qutip.Qobj`; System Hamiltonian. psi0 : :class:`qutip.Qobj`; Initial state vector (ket). times : *list* / *array*; List of times for :math:`t`. Must be uniformly spaced. c_ops : list of :class:`qutip.Qobj`; Deterministic collapse operator which will contribute with a standard; Lindblad type of dissipation. e_ops : list of :class:`qutip.Qobj` / callback function single; single operator or list of operators for which to evaluate; expectation values. kwargs : *dictionary*; Optional keyword arguments. See; :class:`qutip.stochastic.StochasticSolverOptions`. Returns; -------. output: :class:`qutip.solver.SolverResult`. An instance of the class :class:`qutip.solver.SolverResult`. """"""; if debug:; logger.debug(inspect.stack()[0][3]). if isinstance(e_ops, dict):; e_ops_dict = e_ops; e_ops = [e for e in e_ops.values()]; else:; e_ops_dict = None. sso = StochasticSolverOptions(H=H, state0=psi0, times=times, c_ops=c_ops,; e_ops=e_ops, **kwargs). res = _ssepdpsolve_generic(sso, sso.options, sso.progress_bar). if e_ops_dict:; res.expect = {e: res.expect[n]; for n, e in enumerate(e_ops_dict.keys())}; return res. [docs]def smepdpsolve(H, rho0, times, c_ops, e_ops, **kwargs):; """"""; A stochastic (piecewse deterministic process) PDP solver for density matrix; evolution. Parameters; ----------. H : :class:`qutip.Qobj`; System Hamiltonian. rho0 : :class:`qutip.Qobj`; Initial density matrix. times : *list* / *array*; List of times for :math:`t`. Must be uniformly spaced. c_ops : list of :class:`qutip.Qobj`; Deterministic collapse operator which will contribute with a standard; Lindblad type of dissipation. sc_ops : list of :class:`qutip.Qobj`; List of stochastic collapse operators. Each s",MatchSource.WIKI,docs/4.2/modules/qutip/stochastic.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/stochastic.html
https://qutip.org/docs/4.2/modules/qutip/stochastic.html:21024,Testability,log,logger,21024,"density matrix; evolution. Parameters; ----------. H : :class:`qutip.Qobj`; System Hamiltonian. rho0 : :class:`qutip.Qobj`; Initial density matrix. times : *list* / *array*; List of times for :math:`t`. Must be uniformly spaced. c_ops : list of :class:`qutip.Qobj`; Deterministic collapse operator which will contribute with a standard; Lindblad type of dissipation. sc_ops : list of :class:`qutip.Qobj`; List of stochastic collapse operators. Each stochastic collapse; operator will give a deterministic and stochastic contribution; to the eqaution of motion according to how the d1 and d2 functions; are defined. e_ops : list of :class:`qutip.Qobj` / callback function single; single operator or list of operators for which to evaluate; expectation values. kwargs : *dictionary*; Optional keyword arguments. See; :class:`qutip.stochastic.StochasticSolverOptions`. Returns; -------. output: :class:`qutip.solver.SolverResult`. An instance of the class :class:`qutip.solver.SolverResult`. """"""; if debug:; logger.debug(inspect.stack()[0][3]). if isinstance(e_ops, dict):; e_ops_dict = e_ops; e_ops = [e for e in e_ops.values()]; else:; e_ops_dict = None. sso = StochasticSolverOptions(H=H, state0=rho0, times=times, c_ops=c_ops,; e_ops=e_ops, **kwargs). res = _smepdpsolve_generic(sso, sso.options, sso.progress_bar). if e_ops_dict:; res.expect = {e: res.expect[n]; for n, e in enumerate(e_ops_dict.keys())}; return res. # -----------------------------------------------------------------------------; # Generic parameterized stochastic Schrodinger equation solver; #; def _ssesolve_generic(sso, options, progress_bar):; """"""; Internal function for carrying out a sse integration. Used by ssesolve.; """"""; if debug:; logger.debug(inspect.stack()[0][3]). sso.N_store = len(sso.times); sso.N_substeps = sso.nsubsteps; sso.dt = (sso.times[1] - sso.times[0]) / sso.N_substeps; nt = sso.ntraj. data = Result(); data.solver = ""ssesolve""; data.times = sso.times; data.expect = np.zeros((len(sso.e_ops), sso.N_s",MatchSource.WIKI,docs/4.2/modules/qutip/stochastic.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/stochastic.html
https://qutip.org/docs/4.2/modules/qutip/stochastic.html:21733,Testability,log,logger,21733,"erators for which to evaluate; expectation values. kwargs : *dictionary*; Optional keyword arguments. See; :class:`qutip.stochastic.StochasticSolverOptions`. Returns; -------. output: :class:`qutip.solver.SolverResult`. An instance of the class :class:`qutip.solver.SolverResult`. """"""; if debug:; logger.debug(inspect.stack()[0][3]). if isinstance(e_ops, dict):; e_ops_dict = e_ops; e_ops = [e for e in e_ops.values()]; else:; e_ops_dict = None. sso = StochasticSolverOptions(H=H, state0=rho0, times=times, c_ops=c_ops,; e_ops=e_ops, **kwargs). res = _smepdpsolve_generic(sso, sso.options, sso.progress_bar). if e_ops_dict:; res.expect = {e: res.expect[n]; for n, e in enumerate(e_ops_dict.keys())}; return res. # -----------------------------------------------------------------------------; # Generic parameterized stochastic Schrodinger equation solver; #; def _ssesolve_generic(sso, options, progress_bar):; """"""; Internal function for carrying out a sse integration. Used by ssesolve.; """"""; if debug:; logger.debug(inspect.stack()[0][3]). sso.N_store = len(sso.times); sso.N_substeps = sso.nsubsteps; sso.dt = (sso.times[1] - sso.times[0]) / sso.N_substeps; nt = sso.ntraj. data = Result(); data.solver = ""ssesolve""; data.times = sso.times; data.expect = np.zeros((len(sso.e_ops), sso.N_store), dtype=complex); data.ss = np.zeros((len(sso.e_ops), sso.N_store), dtype=complex); data.noise = []; data.measurement = []. # pre-compute collapse operator combinations that are commonly needed; # when evaluating the RHS of stochastic Schrodinger equations; sso.A_ops = sso.generate_A_ops(sso.sc_ops, sso.H). map_kwargs = {'progress_bar': progress_bar}; map_kwargs.update(sso.map_kwargs). task = _ssesolve_single_trajectory; task_args = (sso,); task_kwargs = {}. results = sso.map_func(task, list(range(sso.ntraj)),; task_args, task_kwargs, **map_kwargs). for result in results:; states_list, dW, m, expect, ss = result; data.states.append(states_list); data.noise.append(dW); data.measurement.append(m);",MatchSource.WIKI,docs/4.2/modules/qutip/stochastic.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/stochastic.html
https://qutip.org/docs/4.2/modules/qutip/stochastic.html:25983,Testability,log,logger,25983,"* dt; dW[a_idx, t_idx, j, :] = np.random.poisson(dw_expect,; d2_len). psi_t = sso.rhs(H_data, psi_t, t + dt * j,; A_ops, dt, dW[:, t_idx, j, :], d1, d2, sso.args). # optionally renormalize the wave function; if sso.normalize:; psi_t /= norm(psi_t). if sso.store_measurement:; for m_idx, m in enumerate(sso.m_ops):; for dW_idx, dW_factor in enumerate(sso.dW_factors):; if m[dW_idx]:; m_data = m[dW_idx].data; m_expt = cy_expect_psi_csr(m_data.data,; m_data.indices,; m_data.indptr,; psi_t, 0); else:; m_expt = 0; mm = (m_expt + dW_factor *; dW[m_idx, t_idx, :, dW_idx].sum() /; (dt * sso.N_substeps)); measurements[t_idx, m_idx, dW_idx] = mm. if d2_len == 1:; measurements = measurements.squeeze(axis=(2)). return states_list, dW, measurements, expect, ss. # -----------------------------------------------------------------------------; # Generic parameterized stochastic master equation solver; #; def _smesolve_generic(sso, options, progress_bar):; """"""; Internal function. See smesolve.; """"""; if debug:; logger.debug(inspect.stack()[0][3]). sso.N_store = len(sso.times); sso.N_substeps = sso.nsubsteps; sso.dt = (sso.times[1] - sso.times[0]) / sso.N_substeps; nt = sso.ntraj. data = Result(); data.solver = ""smesolve""; data.times = sso.times; data.expect = np.zeros((len(sso.e_ops), sso.N_store), dtype=complex); data.ss = np.zeros((len(sso.e_ops), sso.N_store), dtype=complex); data.noise = []; data.measurement = []. # Liouvillian for the deterministic part.; # needs to be modified for TD systems; sso.L = liouvillian(sso.H, sso.c_ops). # pre-compute suporoperator operator combinations that are commonly needed; # when evaluating the RHS of stochastic master equations; sso.A_ops = sso.generate_A_ops(sso.sc_ops, sso.L.data, sso.dt). # use .data instead of Qobj ?; sso.s_e_ops = [spre(e) for e in sso.e_ops]. if sso.m_ops:; sso.s_m_ops = [[spre(m) if m else None for m in m_op]; for m_op in sso.m_ops]; else:; sso.s_m_ops = [[spre(c) for _ in range(sso.d2_len)]; for c in sso.sc_ops]. map_kwargs",MatchSource.WIKI,docs/4.2/modules/qutip/stochastic.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/stochastic.html
https://qutip.org/docs/4.2/modules/qutip/stochastic.html:30607,Testability,log,logger,30607,"s:; for a_idx, A in enumerate(A_ops):; dw_expect = cy_expect_rho_vec(A[4], rho_t, 1) * dt; if dw_expect > 0:; dW[a_idx, t_idx, j, :] = np.random.poisson(dw_expect,; d2_len); else:; dW[a_idx, t_idx, j, :] = np.zeros(d2_len). rho_t = sso.rhs(L_data, rho_t, t + dt * j,; A_ops, dt, dW[:, t_idx, j, :], d1, d2, sso.args). if sso.store_measurement:; for m_idx, m in enumerate(sso.s_m_ops):; for dW_idx, dW_factor in enumerate(sso.dW_factors):; if m[dW_idx]:; m_expt = cy_expect_rho_vec(m[dW_idx].data, rho_prev, 0); else:; m_expt = 0; measurements[t_idx, m_idx, dW_idx] = m_expt + dW_factor * \; dW[m_idx, t_idx, :, dW_idx].sum() / (dt * N_substeps). if d2_len == 1:; measurements = measurements.squeeze(axis=(2)). return states_list, dW, measurements, expect, ss. # -----------------------------------------------------------------------------; # Generic parameterized stochastic SE PDP solver; #; def _ssepdpsolve_generic(sso, options, progress_bar):; """"""; For internal use. See ssepdpsolve.; """"""; if debug:; logger.debug(inspect.stack()[0][3]). N_store = len(sso.times); N_substeps = sso.nsubsteps; dt = (sso.times[1] - sso.times[0]) / N_substeps; nt = sso.ntraj. data = Result(); data.solver = ""sepdpsolve""; data.times = sso.tlist; data.expect = np.zeros((len(sso.e_ops), N_store), dtype=complex); data.ss = np.zeros((len(sso.e_ops), N_store), dtype=complex); data.jump_times = []; data.jump_op_idx = []. # effective hamiltonian for deterministic part; Heff = sso.H; for c in sso.c_ops:; Heff += -0.5j * c.dag() * c. progress_bar.start(sso.ntraj); for n in range(sso.ntraj):; progress_bar.update(n); psi_t = sso.state0.full().ravel(). states_list, jump_times, jump_op_idx = \; _ssepdpsolve_single_trajectory(data, Heff, dt, sso.times,; N_store, N_substeps,; psi_t, sso.state0.dims,; sso.c_ops, sso.e_ops). data.states.append(states_list); data.jump_times.append(jump_times); data.jump_op_idx.append(jump_op_idx). progress_bar.finished(). # average density matrices; if options.average_states and np.any",MatchSource.WIKI,docs/4.2/modules/qutip/stochastic.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/stochastic.html
https://qutip.org/docs/4.2/modules/qutip/stochastic.html:33866,Testability,log,logger,33866,"psi_t; psi_t /= norm(psi_t); phi_t = np.copy(psi_t). # store info about jump; jump_times.append(times[t_idx] + dt * j); jump_op_idx.append(n). # get new random numbers for next jump; r_jump, r_op = prng.rand(2). # deterministic evolution wihtout correction for norm decay; dphi_t = (-1.0j * dt) * (Heff.data * phi_t). # deterministic evolution with correction for norm decay; dpsi_t = (-1.0j * dt) * (Heff.data * psi_t); A = 0.5 * np.sum([norm(c.data * psi_t) ** 2 for c in c_ops]); dpsi_t += dt * A * psi_t. # increment wavefunctions; phi_t += dphi_t; psi_t += dpsi_t. # ensure that normalized wavefunction remains normalized; # this allows larger time step than otherwise would be possible; psi_t /= norm(psi_t). return states_list, jump_times, jump_op_idx. # -----------------------------------------------------------------------------; # Generic parameterized stochastic ME PDP solver; #; def _smepdpsolve_generic(sso, options, progress_bar):; """"""; For internal use. See smepdpsolve.; """"""; if debug:; logger.debug(inspect.stack()[0][3]). N_store = len(sso.times); N_substeps = sso.nsubsteps; dt = (sso.times[1] - sso.times[0]) / N_substeps; nt = sso.ntraj. data = Result(); data.solver = ""smepdpsolve""; data.times = sso.times; data.expect = np.zeros((len(sso.e_ops), N_store), dtype=complex); data.jump_times = []; data.jump_op_idx = []. # Liouvillian for the deterministic part.; # needs to be modified for TD systems; L = liouvillian(sso.H, sso.c_ops). progress_bar.start(sso.ntraj). for n in range(sso.ntraj):; progress_bar.update(n); rho_t = mat2vec(sso.rho0.full()).ravel(). states_list, jump_times, jump_op_idx = \; _smepdpsolve_single_trajectory(data, L, dt, sso.times,; N_store, N_substeps,; rho_t, sso.rho0.dims,; sso.c_ops, sso.e_ops). data.states.append(states_list); data.jump_times.append(jump_times); data.jump_op_idx.append(jump_op_idx). progress_bar.finished(). # average density matrices; if options.average_states and np.any(data.states):; data.states = [sum([data.states[m][n] ",MatchSource.WIKI,docs/4.2/modules/qutip/stochastic.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/stochastic.html
https://qutip.org/docs/4.2/modules/qutip/stochastic.html:8000,Usability,progress bar,progress bar,8000,"yne', 'photocurrent'); The name of the type of measurement process that give rise to the; stochastic equation to solve. Specifying a method with this keyword; argument is a short-hand notation for using pre-defined d1 and d2; functions for the corresponding stochastic processes. distribution : string ('normal', 'poission'); The name of the distribution used for the stochastic increments. store_measurements : bool (default False); Whether or not to store the measurement results in the; :class:`qutip.solver.SolverResult` instance returned by the solver. noise : array; Vector specifying the noise. normalize : bool (default True); Whether or not to normalize the wave function during the evolution. options : :class:`qutip.solver.Options`; Generic solver options. map_func: function; A map function or managing the calls to single-trajactory solvers. map_kwargs: dictionary; Optional keyword arguments to the map_func function function. progress_bar : :class:`qutip.ui.BaseProgressBar`; Optional progress bar class instance. """"""; def __init__(self, H=None, state0=None, times=None, c_ops=[], sc_ops=[],; e_ops=[], m_ops=None, args=None, ntraj=1, nsubsteps=1,; d1=None, d2=None, d2_len=1, dW_factors=None, rhs=None,; generate_A_ops=None, generate_noise=None, homogeneous=True,; solver=None, method=None, distribution='normal',; store_measurement=False, noise=None, normalize=True,; options=None, progress_bar=None, map_func=None,; map_kwargs=None):. if options is None:; options = Options(). if progress_bar is None:; progress_bar = TextProgressBar(). self.H = H; self.d1 = d1; self.d2 = d2; self.d2_len = d2_len; self.dW_factors = dW_factors if dW_factors else np.ones(d2_len); self.state0 = state0; self.times = times; self.c_ops = c_ops; self.sc_ops = sc_ops; self.e_ops = e_ops. if m_ops is None:; self.m_ops = [[c for _ in range(d2_len)] for c in sc_ops]; else:; self.m_ops = m_ops. self.ntraj = ntraj; self.nsubsteps = nsubsteps; self.solver = solver; self.method = method; self.distribution ",MatchSource.WIKI,docs/4.2/modules/qutip/stochastic.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/stochastic.html
https://qutip.org/docs/4.2/modules/qutip/superoperator.html:8862,Deployability,update,updated,8862,"ameters; ----------; A : qobj; Quantum operator for post multiplication. Returns; -------; super : qobj; Superoperator formed from input qauntum object.; """"""; if not isinstance(A, Qobj):; raise TypeError('Input is not a quantum object'). if not A.isoper:; raise TypeError('Input is not a quantum operator'). S = Qobj(isherm=A.isherm, superrep='super'); S.dims = [[A.dims[0], A.dims[1]], [A.dims[0], A.dims[1]]]; S.data = zcsr_kron(A.data.T, ; fast_identity(np.prod(A.shape[0]))); return S. [docs]def spre(A):; """"""Superoperator formed from pre-multiplication by operator A. Parameters; ----------; A : qobj; Quantum operator for pre-multiplication. Returns; --------; super :qobj; Superoperator formed from input quantum object.; """"""; if not isinstance(A, Qobj):; raise TypeError('Input is not a quantum object'). if not A.isoper:; raise TypeError('Input is not a quantum operator'). S = Qobj(isherm=A.isherm, superrep='super'); S.dims = [[A.dims[0], A.dims[1]], [A.dims[0], A.dims[1]]]; S.data = zcsr_kron(fast_identity(np.prod(A.shape[1])), A.data); return S. def _drop_projected_dims(dims):; """"""; Eliminate subsystems that has been collapsed to only one state due to; a projection.; """"""; return [d for d in dims if d != 1]. [docs]def sprepost(A, B):; """"""Superoperator formed from pre-multiplication by operator A and post-; multiplication of operator B. Parameters; ----------; A : Qobj; Quantum operator for pre-multiplication. B : Qobj; Quantum operator for post-multiplication. Returns; --------; super : Qobj; Superoperator formed from input quantum objects.; """""". dims = [[_drop_projected_dims(A.dims[0]), _drop_projected_dims(B.dims[1])],; [_drop_projected_dims(A.dims[1]), _drop_projected_dims(B.dims[0])]]; data = zcsr_kron(B.data.T, A.data); return Qobj(data, dims=dims, superrep='super').  Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, and A.L. Grimsmo.; Last updated on Jan 17, 2018. . Built with Sphinx using a theme provided by Read the Docs. . ",MatchSource.WIKI,docs/4.2/modules/qutip/superoperator.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/superoperator.html
https://qutip.org/docs/4.2/modules/qutip/superoperator.html:2713,Safety,avoid,avoids,2713,"R BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY; # THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT; # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE; # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.; ###############################################################################. __all__ = ['liouvillian', 'liouvillian_ref', 'lindblad_dissipator',; 'operator_to_vector', 'vector_to_operator', 'mat2vec', 'vec2mat',; 'vec2mat_index', 'mat2vec_index', 'spost', 'spre', 'sprepost']. import scipy.sparse as sp; import numpy as np; from qutip.qobj import Qobj; from qutip.fastsparse import fast_csr_matrix, fast_identity; from qutip.sparse import sp_reshape; from qutip.cy.spmath import zcsr_kron. [docs]def liouvillian(H, c_ops=[], data_only=False, chi=None):; """"""Assembles the Liouvillian superoperator from a Hamiltonian; and a ``list`` of collapse operators. Like liouvillian, but with an; experimental implementation which avoids creating extra Qobj instances,; which can be advantageous for large systems. Parameters; ----------; H : qobj; System Hamiltonian. c_ops : array_like; A ``list`` or ``array`` of collapse operators. Returns; -------; L : qobj; Liouvillian superoperator. """""". if chi and len(chi) != len(c_ops):; raise ValueError('chi must be a list with same length as c_ops'). if H is not None:; if H.isoper:; op_dims = H.dims; op_shape = H.shape; elif H.issuper:; op_dims = H.dims[0]; op_shape = [np.prod(op_dims[0]), np.prod(op_dims[0])]; else:; raise TypeError(""Invalid type for Hamiltonian.""); else:; # no hamiltonian given, pick system size from a collapse operator; if isinstance(c_ops, list) and len(c_ops) > 0:; c = c_ops[0]; if c.isoper:; op_dims = c.dims; op_shape = c.shape; elif c.issuper:; op_dims = c.dims[0]; op_shape = [np.prod(op_dims[0]), np.prod(op_dims[0])]; else:; raise TypeError(""Invalid type for collapse operator.""); else:; raise TypeError(""Either H or c_ops must be given.""). sop_dims = [[op_d",MatchSource.WIKI,docs/4.2/modules/qutip/superoperator.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/superoperator.html
https://qutip.org/docs/4.2/modules/qutip/superop_reps.html:10581,Availability,down,down,10581,"other subsystem dimensions.; """"""; nq = _nq(q_oper.dims); B = _pauli_basis(nq); # Force the basis change to match the dimensions of; # the input.; B.dims = q_oper.dims. # We normally should not multiply objects of different; # superreps, so Qobj warns about that. Here, however, we're actively; # converting between, so the superrep of B is irrelevant.; # To suppress warnings, we pretend that B is also a chi.; B.superrep = 'chi'. # The Chi matrix has tr(chi) == d, so we need to divide out; # by that to get back to the Choi form.; return Qobj((B * q_oper * B.dag()) / q_oper.shape[0], superrep='choi'). def _svd_u_to_kraus(U, S, d, dK, indims, outdims):; """"""; Given a partial isometry U and a vector of square-roots of singular values S; obtained from an SVD, produces the Kraus operators represented by U. Returns; -------; Ks : list of Qobj; Quantum objects represnting each of the Kraus operators.; """"""; # We use U * S since S is 1-index, such that this is equivalent to; # U . diag(S), but easier to write down.; Ks = list(map(Qobj, array(U * S).reshape((d, d, dK), order='F').transpose((2, 0, 1)))); for K in Ks:; K.dims = [outdims, indims]; return Ks. def _generalized_kraus(q_oper, thresh=1e-10):; # TODO: document!; # TODO: use this to generalize to_kraus to the case where U != V.; # This is critical for non-CP maps, as appear in (for example); # diamond norm differences between two CP maps.; if q_oper.type != ""super"" or q_oper.superrep != ""choi"":; raise ValueError(""Expected a Choi matrix, got a {} (superrep {})."".format(q_oper.type, q_oper.superrep)); ; # Remember the shape of the underlying space,; # as we'll need this to make Kraus operators later.; dL, dR = map(int, map(sqrt, q_oper.shape)); # Also remember the dims breakout.; out_dims, in_dims = q_oper.dims; out_left, out_right = out_dims; in_left, in_right = in_dims. # Find the SVD.; U, S, V = svd(q_oper.data.todense()). # Truncate away the zero singular values, up to a threshold.; nonzero_idxs = S > thresh; dK = nonzer",MatchSource.WIKI,docs/4.2/modules/qutip/superop_reps.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/superop_reps.html
https://qutip.org/docs/4.2/modules/qutip/superop_reps.html:18339,Availability,error,errors,18339,"{0.type} ""; ""and superrep = {0.superrep} to supermatrix not ""; ""supported."".format(q_oper); ). [docs]def to_kraus(q_oper):; """"""; Converts a Qobj representing a quantum map to a list of quantum objects,; each representing an operator in the Kraus decomposition of the given map. Parameters; ----------; q_oper : Qobj; Superoperator to be converted to Kraus representation. If; ``q_oper`` is ``type=""oper""``, then it is taken to act by conjugation,; such that ``to_kraus(A) == to_kraus(sprepost(A, A.dag())) == [A]``. Returns; -------; kraus_ops : list of Qobj; A list of quantum objects, each representing a Kraus operator in the; decomposition of ``q_oper``. Raises; ------; TypeError: if the given quantum object is not a map, or cannot be; decomposed into Kraus operators.; """"""; if q_oper.type == 'super':; if q_oper.superrep in (""super"", ""chi""):; return to_kraus(to_choi(q_oper)); elif q_oper.superrep == 'choi':; return choi_to_kraus(q_oper); elif q_oper.type == 'oper': # Assume unitary; return [q_oper]; else:; raise TypeError(; ""Conversion of Qobj with type = {0.type} ""; ""and superrep = {0.superrep} to Kraus decomposition not ""; ""supported."".format(q_oper); ). def to_stinespring(q_oper):; r""""""; Converts a Qobj representing a quantum map $\Lambda$ to a pair of partial isometries; $A$ and $B$ such that $\Lambda(X) = \Tr_2(A X B^\dagger)$ for all inputs $X$, where; the partial trace is taken over a a new index on the output dimensions of $A$ and $B$. For completely positive inputs, $A$ will always equal $B$ up to precision errors. Parameters; ----------; q_oper : Qobj; Superoperator to be converted to a Stinespring pair. Returns; -------; A, B : Qobj; Quantum objects representing each of the Stinespring matrices for the input Qobj.; """"""; return choi_to_stinespring(to_choi(q_oper)).  Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, and A.L. Grimsmo.; Last updated on Jan 17, 2018. . Built with Sphinx using a theme provided by Read the Docs. . ",MatchSource.WIKI,docs/4.2/modules/qutip/superop_reps.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/superop_reps.html
https://qutip.org/docs/4.2/modules/qutip/superop_reps.html:18714,Deployability,update,updated,18714,"{0.type} ""; ""and superrep = {0.superrep} to supermatrix not ""; ""supported."".format(q_oper); ). [docs]def to_kraus(q_oper):; """"""; Converts a Qobj representing a quantum map to a list of quantum objects,; each representing an operator in the Kraus decomposition of the given map. Parameters; ----------; q_oper : Qobj; Superoperator to be converted to Kraus representation. If; ``q_oper`` is ``type=""oper""``, then it is taken to act by conjugation,; such that ``to_kraus(A) == to_kraus(sprepost(A, A.dag())) == [A]``. Returns; -------; kraus_ops : list of Qobj; A list of quantum objects, each representing a Kraus operator in the; decomposition of ``q_oper``. Raises; ------; TypeError: if the given quantum object is not a map, or cannot be; decomposed into Kraus operators.; """"""; if q_oper.type == 'super':; if q_oper.superrep in (""super"", ""chi""):; return to_kraus(to_choi(q_oper)); elif q_oper.superrep == 'choi':; return choi_to_kraus(q_oper); elif q_oper.type == 'oper': # Assume unitary; return [q_oper]; else:; raise TypeError(; ""Conversion of Qobj with type = {0.type} ""; ""and superrep = {0.superrep} to Kraus decomposition not ""; ""supported."".format(q_oper); ). def to_stinespring(q_oper):; r""""""; Converts a Qobj representing a quantum map $\Lambda$ to a pair of partial isometries; $A$ and $B$ such that $\Lambda(X) = \Tr_2(A X B^\dagger)$ for all inputs $X$, where; the partial trace is taken over a a new index on the output dimensions of $A$ and $B$. For completely positive inputs, $A$ will always equal $B$ up to precision errors. Parameters; ----------; q_oper : Qobj; Superoperator to be converted to a Stinespring pair. Returns; -------; A, B : Qobj; Quantum objects representing each of the Stinespring matrices for the input Qobj.; """"""; return choi_to_stinespring(to_choi(q_oper)).  Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, and A.L. Grimsmo.; Last updated on Jan 17, 2018. . Built with Sphinx using a theme provided by Read the Docs. . ",MatchSource.WIKI,docs/4.2/modules/qutip/superop_reps.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/superop_reps.html
https://qutip.org/docs/4.2/modules/qutip/superop_reps.html:5853,Energy Efficiency,power,powers,5853,".dag().data.todense(). return Qobj(B, dims=dims). # PRIVATE CONVERSION FUNCTIONS ------------------------------------------------; # These functions handle the main work of converting between representations,; # and are exposed below by other functions that add postconditions about types.; #; # TODO: handle type='kraus' as a three-index Qobj, rather than as a list?. def _super_tofrom_choi(q_oper):; """"""; We exploit that the basis transformation between Choi and supermatrix; representations squares to the identity, so that if we munge Qobj.type,; we can use the same function. Since this function doesn't respect :attr:`Qobj.type`, we mark it as; private; only those functions which wrap this in a way so as to preserve; type should be called externally.; """"""; data = q_oper.data.toarray(); sqrt_shape = int(sqrt(data.shape[0])); return Qobj(dims=q_oper.dims,; inpt=data.reshape([sqrt_shape] * 4).; transpose(3, 1, 2, 0).reshape(q_oper.data.shape)). def _isqubitdims(dims):; """"""Checks whether all entries in a dims list are integer powers of 2. Parameters; ----------; dims : nested list of ints; Dimensions to be checked. Returns; -------; isqubitdims : bool; True if and only if every member of the flattened dims; list is an integer power of 2.; """"""; return all([; 2**floor(log2(dim)) == dim; for dim in flatten(dims); ]). def _super_to_superpauli(q_oper):; """"""; Converts a superoperator in the column-stacking basis to; the Pauli basis (assuming qubit dimensions). This is an internal function, as QuTiP does not currently have; a way to mark that superoperators are represented in the Pauli; basis as opposed to the column-stacking basis; a Pauli-basis; ``type='super'`` would thus break other conversion functions.; """"""; # Ensure we start with a column-stacking-basis superoperator.; sqobj = to_super(q_oper); if not _isqubitdims(sqobj.dims):; raise ValueError(""Pauli basis is only defined for qubits.""); nq = int(log2(sqobj.shape[0]) / 2); B = _pauli_basis(nq) / sqrt(2**nq); # To do this, ",MatchSource.WIKI,docs/4.2/modules/qutip/superop_reps.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/superop_reps.html
https://qutip.org/docs/4.2/modules/qutip/superop_reps.html:6057,Energy Efficiency,power,power,6057,"een representations,; # and are exposed below by other functions that add postconditions about types.; #; # TODO: handle type='kraus' as a three-index Qobj, rather than as a list?. def _super_tofrom_choi(q_oper):; """"""; We exploit that the basis transformation between Choi and supermatrix; representations squares to the identity, so that if we munge Qobj.type,; we can use the same function. Since this function doesn't respect :attr:`Qobj.type`, we mark it as; private; only those functions which wrap this in a way so as to preserve; type should be called externally.; """"""; data = q_oper.data.toarray(); sqrt_shape = int(sqrt(data.shape[0])); return Qobj(dims=q_oper.dims,; inpt=data.reshape([sqrt_shape] * 4).; transpose(3, 1, 2, 0).reshape(q_oper.data.shape)). def _isqubitdims(dims):; """"""Checks whether all entries in a dims list are integer powers of 2. Parameters; ----------; dims : nested list of ints; Dimensions to be checked. Returns; -------; isqubitdims : bool; True if and only if every member of the flattened dims; list is an integer power of 2.; """"""; return all([; 2**floor(log2(dim)) == dim; for dim in flatten(dims); ]). def _super_to_superpauli(q_oper):; """"""; Converts a superoperator in the column-stacking basis to; the Pauli basis (assuming qubit dimensions). This is an internal function, as QuTiP does not currently have; a way to mark that superoperators are represented in the Pauli; basis as opposed to the column-stacking basis; a Pauli-basis; ``type='super'`` would thus break other conversion functions.; """"""; # Ensure we start with a column-stacking-basis superoperator.; sqobj = to_super(q_oper); if not _isqubitdims(sqobj.dims):; raise ValueError(""Pauli basis is only defined for qubits.""); nq = int(log2(sqobj.shape[0]) / 2); B = _pauli_basis(nq) / sqrt(2**nq); # To do this, we have to hack a bit and force the dims to match,; # since the _pauli_basis function makes different assumptions; # about indices than we need here.; B.dims = sqobj.dims; return (B.dag() ",MatchSource.WIKI,docs/4.2/modules/qutip/superop_reps.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/superop_reps.html
https://qutip.org/docs/4.2/modules/qutip/superop_reps.html:8930,Energy Efficiency,power,power,8930,"as a; strict sub-class of Qobj.; """"""; vals, vecs = eig(q_oper.data.todense()); vecs = [array(_) for _ in zip(*vecs)]; return [Qobj(inpt=sqrt(val)*vec2mat(vec)) for val, vec in zip(vals, vecs)]. def kraus_to_choi(kraus_list):; """"""; Takes a list of Kraus operators and returns the Choi matrix for the channel; represented by the Kraus operators in `kraus_list`; """"""; kraus_mat_list = list(map(lambda x: matrix(x.data.todense()), kraus_list)); op_len = len(kraus_mat_list[0]); op_rng = range(op_len); choi_blocks = array([[sum([op[:, c_ix] * array([op.H[r_ix, :]]); for op in kraus_mat_list]); for r_ix in op_rng]; for c_ix in op_rng]); return Qobj(inpt=hstack(hstack(choi_blocks)),; dims=[kraus_list[0].dims, kraus_list[0].dims], type='super',; superrep='choi'). def kraus_to_super(kraus_list):; """"""; Converts a list of Kraus operators and returns a super operator.; """"""; return choi_to_super(kraus_to_choi(kraus_list)). def _nq(dims):; dim = np.product(dims[0][0]); nq = int(log2(dim)); if 2 ** nq != dim:; raise ValueError(""{} is not an integer power of 2."".format(dim)); return nq. def choi_to_chi(q_oper):; """"""; Converts a Choi matrix to a Chi matrix in the Pauli basis. NOTE: this is only supported for qubits right now. Need to extend to; Heisenberg-Weyl for other subsystem dimensions.; """"""; nq = _nq(q_oper.dims); B = _pauli_basis(nq); # Force the basis change to match the dimensions of; # the input.; B.dims = q_oper.dims; B.superrep = 'choi'. return Qobj(B.dag() * q_oper * B, superrep='chi'). def chi_to_choi(q_oper):; """"""; Converts a Choi matrix to a Chi matrix in the Pauli basis. NOTE: this is only supported for qubits right now. Need to extend to; Heisenberg-Weyl for other subsystem dimensions.; """"""; nq = _nq(q_oper.dims); B = _pauli_basis(nq); # Force the basis change to match the dimensions of; # the input.; B.dims = q_oper.dims. # We normally should not multiply objects of different; # superreps, so Qobj warns about that. Here, however, we're actively; # converting between, s",MatchSource.WIKI,docs/4.2/modules/qutip/superop_reps.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/superop_reps.html
https://qutip.org/docs/4.2/modules/qutip/superop_reps.html:5504,Integrability,wrap,wrap,5504,"s can be.; # TODO: Make this sparse. CSR format was causing problems for the [idx, :]; # slicing below.; B = zeros((4 ** nq, 4 ** nq), dtype=complex); dims = [[[2] * nq] * 2] * 2. for idx, op in enumerate(starmap(tensor,; product(_SINGLE_QUBIT_PAULI_BASIS,; repeat=nq))):; B[:, idx] = operator_to_vector(op).dag().data.todense(). return Qobj(B, dims=dims). # PRIVATE CONVERSION FUNCTIONS ------------------------------------------------; # These functions handle the main work of converting between representations,; # and are exposed below by other functions that add postconditions about types.; #; # TODO: handle type='kraus' as a three-index Qobj, rather than as a list?. def _super_tofrom_choi(q_oper):; """"""; We exploit that the basis transformation between Choi and supermatrix; representations squares to the identity, so that if we munge Qobj.type,; we can use the same function. Since this function doesn't respect :attr:`Qobj.type`, we mark it as; private; only those functions which wrap this in a way so as to preserve; type should be called externally.; """"""; data = q_oper.data.toarray(); sqrt_shape = int(sqrt(data.shape[0])); return Qobj(dims=q_oper.dims,; inpt=data.reshape([sqrt_shape] * 4).; transpose(3, 1, 2, 0).reshape(q_oper.data.shape)). def _isqubitdims(dims):; """"""Checks whether all entries in a dims list are integer powers of 2. Parameters; ----------; dims : nested list of ints; Dimensions to be checked. Returns; -------; isqubitdims : bool; True if and only if every member of the flattened dims; list is an integer power of 2.; """"""; return all([; 2**floor(log2(dim)) == dim; for dim in flatten(dims); ]). def _super_to_superpauli(q_oper):; """"""; Converts a superoperator in the column-stacking basis to; the Pauli basis (assuming qubit dimensions). This is an internal function, as QuTiP does not currently have; a way to mark that superoperators are represented in the Pauli; basis as opposed to the column-stacking basis; a Pauli-basis; ``type='super'`` would thus bre",MatchSource.WIKI,docs/4.2/modules/qutip/superop_reps.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/superop_reps.html
https://qutip.org/docs/4.2/modules/qutip/superop_reps.html:9117,Modifiability,extend,extend,9117,"rators and returns the Choi matrix for the channel; represented by the Kraus operators in `kraus_list`; """"""; kraus_mat_list = list(map(lambda x: matrix(x.data.todense()), kraus_list)); op_len = len(kraus_mat_list[0]); op_rng = range(op_len); choi_blocks = array([[sum([op[:, c_ix] * array([op.H[r_ix, :]]); for op in kraus_mat_list]); for r_ix in op_rng]; for c_ix in op_rng]); return Qobj(inpt=hstack(hstack(choi_blocks)),; dims=[kraus_list[0].dims, kraus_list[0].dims], type='super',; superrep='choi'). def kraus_to_super(kraus_list):; """"""; Converts a list of Kraus operators and returns a super operator.; """"""; return choi_to_super(kraus_to_choi(kraus_list)). def _nq(dims):; dim = np.product(dims[0][0]); nq = int(log2(dim)); if 2 ** nq != dim:; raise ValueError(""{} is not an integer power of 2."".format(dim)); return nq. def choi_to_chi(q_oper):; """"""; Converts a Choi matrix to a Chi matrix in the Pauli basis. NOTE: this is only supported for qubits right now. Need to extend to; Heisenberg-Weyl for other subsystem dimensions.; """"""; nq = _nq(q_oper.dims); B = _pauli_basis(nq); # Force the basis change to match the dimensions of; # the input.; B.dims = q_oper.dims; B.superrep = 'choi'. return Qobj(B.dag() * q_oper * B, superrep='chi'). def chi_to_choi(q_oper):; """"""; Converts a Choi matrix to a Chi matrix in the Pauli basis. NOTE: this is only supported for qubits right now. Need to extend to; Heisenberg-Weyl for other subsystem dimensions.; """"""; nq = _nq(q_oper.dims); B = _pauli_basis(nq); # Force the basis change to match the dimensions of; # the input.; B.dims = q_oper.dims. # We normally should not multiply objects of different; # superreps, so Qobj warns about that. Here, however, we're actively; # converting between, so the superrep of B is irrelevant.; # To suppress warnings, we pretend that B is also a chi.; B.superrep = 'chi'. # The Chi matrix has tr(chi) == d, so we need to divide out; # by that to get back to the Choi form.; return Qobj((B * q_oper * B.dag()) / q_o",MatchSource.WIKI,docs/4.2/modules/qutip/superop_reps.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/superop_reps.html
https://qutip.org/docs/4.2/modules/qutip/superop_reps.html:9537,Modifiability,extend,extend,9537,")),; dims=[kraus_list[0].dims, kraus_list[0].dims], type='super',; superrep='choi'). def kraus_to_super(kraus_list):; """"""; Converts a list of Kraus operators and returns a super operator.; """"""; return choi_to_super(kraus_to_choi(kraus_list)). def _nq(dims):; dim = np.product(dims[0][0]); nq = int(log2(dim)); if 2 ** nq != dim:; raise ValueError(""{} is not an integer power of 2."".format(dim)); return nq. def choi_to_chi(q_oper):; """"""; Converts a Choi matrix to a Chi matrix in the Pauli basis. NOTE: this is only supported for qubits right now. Need to extend to; Heisenberg-Weyl for other subsystem dimensions.; """"""; nq = _nq(q_oper.dims); B = _pauli_basis(nq); # Force the basis change to match the dimensions of; # the input.; B.dims = q_oper.dims; B.superrep = 'choi'. return Qobj(B.dag() * q_oper * B, superrep='chi'). def chi_to_choi(q_oper):; """"""; Converts a Choi matrix to a Chi matrix in the Pauli basis. NOTE: this is only supported for qubits right now. Need to extend to; Heisenberg-Weyl for other subsystem dimensions.; """"""; nq = _nq(q_oper.dims); B = _pauli_basis(nq); # Force the basis change to match the dimensions of; # the input.; B.dims = q_oper.dims. # We normally should not multiply objects of different; # superreps, so Qobj warns about that. Here, however, we're actively; # converting between, so the superrep of B is irrelevant.; # To suppress warnings, we pretend that B is also a chi.; B.superrep = 'chi'. # The Chi matrix has tr(chi) == d, so we need to divide out; # by that to get back to the Choi form.; return Qobj((B * q_oper * B.dag()) / q_oper.shape[0], superrep='choi'). def _svd_u_to_kraus(U, S, d, dK, indims, outdims):; """"""; Given a partial isometry U and a vector of square-roots of singular values S; obtained from an SVD, produces the Kraus operators represented by U. Returns; -------; Ks : list of Qobj; Quantum objects represnting each of the Kraus operators.; """"""; # We use U * S since S is 1-index, such that this is equivalent to; # U . diag(S), b",MatchSource.WIKI,docs/4.2/modules/qutip/superop_reps.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/superop_reps.html
https://qutip.org/docs/4.2/modules/qutip/superop_reps.html:2836,Safety,avoid,avoid,2836,"RACT, STRICT LIABILITY, OR TORT; # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE; # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.; ###############################################################################; #; # This module was initially contributed by Ben Criger.; #; """"""; This module implements transformations between superoperator representations,; including supermatrix, Kraus, Choi and Chi (process) matrix formalisms.; """""". __all__ = ['super_to_choi', 'choi_to_super', 'choi_to_kraus', 'kraus_to_choi',; 'kraus_to_super', 'choi_to_chi', 'chi_to_choi', 'to_choi',; 'to_chi', 'to_super', 'to_kraus', 'to_stinespring'; ]. # Python Standard Library; from itertools import starmap, product. # NumPy/SciPy; from numpy.core.multiarray import array, zeros; from numpy.core.shape_base import hstack; from numpy.matrixlib.defmatrix import matrix; from numpy import sqrt, floor, log2; from numpy import dot; from scipy.linalg import eig, svd; # Needed to avoid conflict with itertools.product.; import numpy as np. # Other QuTiP functions and classes; from qutip.superoperator import vec2mat, spre, spost, operator_to_vector; from qutip.operators import identity, sigmax, sigmay, sigmaz; from qutip.tensor import tensor, flatten; from qutip.qobj import Qobj; from qutip.states import basis. # SPECIFIC SUPEROPERATORS -----------------------------------------------------. def _dep_super(pe):; """"""; Returns the superoperator corresponding to qubit depolarization for a; given parameter pe. TODO: if this is going into production (hopefully it isn't) then check; CPTP, expand to arbitrary dimensional systems, etc.; """"""; return Qobj(dims=[[[2], [2]], [[2], [2]]],; inpt=array([[1. - pe / 2., 0., 0., pe / 2.],; [0., 1. - pe, 0., 0.],; [0., 0., 1. - pe, 0.],; [pe / 2., 0., 0., 1. - pe / 2.]])). def _dep_choi(pe):; """"""; Returns the choi matrix corresponding to qubit depolarization for a; given parameter pe. TODO: if this is going into production (hopef",MatchSource.WIKI,docs/4.2/modules/qutip/superop_reps.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/superop_reps.html
https://qutip.org/docs/4.2/modules/qutip/superop_reps.html:5037,Security,expose,exposed,5037,"., 0., 0., 1. - pe],; [0., pe / 2., 0., 0.],; [0., 0., pe / 2., 0.],; [1. - pe, 0., 0., 1. - pe / 2.]]),; superrep='choi'). # CHANGE OF BASIS FUNCTIONS ---------------------------------------------------; # These functions find change of basis matrices, and are useful in converting; # between (for instance) Choi and chi matrices. At some point, these should; # probably be moved out to another module. _SINGLE_QUBIT_PAULI_BASIS = (identity(2), sigmax(), sigmay(), sigmaz()). def _pauli_basis(nq=1):; # NOTE: This is slow as can be.; # TODO: Make this sparse. CSR format was causing problems for the [idx, :]; # slicing below.; B = zeros((4 ** nq, 4 ** nq), dtype=complex); dims = [[[2] * nq] * 2] * 2. for idx, op in enumerate(starmap(tensor,; product(_SINGLE_QUBIT_PAULI_BASIS,; repeat=nq))):; B[:, idx] = operator_to_vector(op).dag().data.todense(). return Qobj(B, dims=dims). # PRIVATE CONVERSION FUNCTIONS ------------------------------------------------; # These functions handle the main work of converting between representations,; # and are exposed below by other functions that add postconditions about types.; #; # TODO: handle type='kraus' as a three-index Qobj, rather than as a list?. def _super_tofrom_choi(q_oper):; """"""; We exploit that the basis transformation between Choi and supermatrix; representations squares to the identity, so that if we munge Qobj.type,; we can use the same function. Since this function doesn't respect :attr:`Qobj.type`, we mark it as; private; only those functions which wrap this in a way so as to preserve; type should be called externally.; """"""; data = q_oper.data.toarray(); sqrt_shape = int(sqrt(data.shape[0])); return Qobj(dims=q_oper.dims,; inpt=data.reshape([sqrt_shape] * 4).; transpose(3, 1, 2, 0).reshape(q_oper.data.shape)). def _isqubitdims(dims):; """"""Checks whether all entries in a dims list are integer powers of 2. Parameters; ----------; dims : nested list of ints; Dimensions to be checked. Returns; -------; isqubitdims : bool; True",MatchSource.WIKI,docs/4.2/modules/qutip/superop_reps.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/superop_reps.html
https://qutip.org/docs/4.2/modules/qutip/superop_reps.html:12381,Testability,assert,assert,12381,"_dims. # Find the SVD.; U, S, V = svd(q_oper.data.todense()). # Truncate away the zero singular values, up to a threshold.; nonzero_idxs = S > thresh; dK = nonzero_idxs.sum(); U = array(U)[:, nonzero_idxs]; # We also want S to be a single index array, which np.matrix; # doesn't allow for. This is stripped by calling array() on it.; S = sqrt(array(S)[nonzero_idxs]); # Since NumPy returns V and not V+, we need to take the dagger; # to get back to quantum info notation for Stinespring pairs.; V = array(V.conj().T)[:, nonzero_idxs]. # Next, we convert each of U and V into Kraus operators.; # Finally, we want the Kraus index to be left-most so that we; # can map over it when making Qobjs.; # FIXME: does not preserve dims!; kU = _svd_u_to_kraus(U, S, dL, dK, out_right, out_left); kV = _svd_u_to_kraus(V, S, dL, dK, in_right, in_left). return kU, kV. def choi_to_stinespring(q_oper, thresh=1e-10):; # TODO: document!; kU, kV = _generalized_kraus(q_oper, thresh=thresh). assert(len(kU) == len(kV)); dK = len(kU); dL = kU[0].shape[0]; dR = kV[0].shape[1]; # Also remember the dims breakout.; out_dims, in_dims = q_oper.dims; out_left, out_right = out_dims; in_left, in_right = in_dims. A = Qobj(zeros((dK * dL, dL)), dims=[out_left + [dK], out_right + [1]]); B = Qobj(zeros((dK * dR, dR)), dims=[in_left + [dK], in_right + [1]]). for idx_kraus, (KL, KR) in enumerate(zip(kU, kV)):; A += tensor(KL, basis(dK, idx_kraus)); B += tensor(KR, basis(dK, idx_kraus)); ; # There is no input (right) Kraus index, so strip that off.; del A.dims[1][-1]; del B.dims[1][-1]. return A, B. # PUBLIC CONVERSION FUNCTIONS -------------------------------------------------; # These functions handle superoperator conversions in a way that preserves the; # correctness of Qobj.type, and in a way that automatically branches based on; # the input Qobj.type. [docs]def to_choi(q_oper):; """"""; Converts a Qobj representing a quantum map to the Choi representation,; such that the trace of the returned operator is equal to",MatchSource.WIKI,docs/4.2/modules/qutip/superop_reps.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/superop_reps.html
https://qutip.org/docs/4.2/modules/qutip/tensor.html:3709,Availability,error,error,3709,"rs; ----------; args : array_like; ``list`` or ``array`` of quantum objects for tensor product. Returns; -------; obj : qobj; A composite quantum object. Examples; --------; >>> tensor([sigmax(), sigmax()]); Quantum object: dims = [[2, 2], [2, 2]], \; shape = [4, 4], type = oper, isHerm = True; Qobj data =; [[ 0.+0.j 0.+0.j 0.+0.j 1.+0.j]; [ 0.+0.j 0.+0.j 1.+0.j 0.+0.j]; [ 0.+0.j 1.+0.j 0.+0.j 0.+0.j]; [ 1.+0.j 0.+0.j 0.+0.j 0.+0.j]]; """""". if not args:; raise TypeError(""Requires at least one input argument""). if len(args) == 1 and isinstance(args[0], (list, np.ndarray)):; # this is the case when tensor is called on the form:; # tensor([q1, q2, q3, ...]); qlist = args[0]. elif len(args) == 1 and isinstance(args[0], Qobj):; # tensor is called with a single Qobj as an argument, do nothing; return args[0]. else:; # this is the case when tensor is called on the form:; # tensor(q1, q2, q3, ...); qlist = args. if not all([isinstance(q, Qobj) for q in qlist]):; # raise error if one of the inputs is not a quantum object; raise TypeError(""One of inputs is not a quantum object""). out = Qobj(). if qlist[0].issuper:; out.superrep = qlist[0].superrep; if not all([q.superrep == out.superrep for q in qlist]):; raise TypeError(""In tensor products of superroperators, all must"" +; ""have the same representation""). out.isherm = True; for n, q in enumerate(qlist):; if n == 0:; out.data = q.data; out.dims = q.dims; else:; out.data = zcsr_kron(out.data, q.data); ; out.dims = [out.dims[0] + q.dims[0], out.dims[1] + q.dims[1]]. out.isherm = out.isherm and q.isherm. if not out.isherm:; out._isherm = None. return out.tidyup() if qutip.settings.auto_tidyup else out. [docs]def super_tensor(*args):; """"""Calculates the tensor product of input superoperators, by tensoring; together the underlying Hilbert spaces on which each vectorized operator; acts. Parameters; ----------; args : array_like; ``list`` or ``array`` of quantum objects with ``type=""super""``. Returns; -------; obj : qobj; A composite qu",MatchSource.WIKI,docs/4.2/modules/qutip/tensor.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/tensor.html
https://qutip.org/docs/4.2/modules/qutip/tensor.html:11921,Deployability,update,updated,11921,"ng one or more index pairs.; Note that this uses dense representations and thus; should *not* be used for very large Qobjs. Parameters; ----------. pairs : tuple; One or more tuples ``(i, j)`` indicating that the; ``i`` and ``j`` dimensions of the original qobj; should be contracted. Returns; -------. cqobj : Qobj; The original Qobj with all named index pairs contracted; away. """"""; # Record and label the original dims.; dims = qobj.dims; dims_idxs = enumerate_flat(dims); tensor_dims = dims_to_tensor_shape(dims). # Convert to dense first, since sparse won't support the reshaping we need.; qtens = qobj.data.toarray(). # Reshape by the flattened dims.; qtens = qtens.reshape(tensor_dims). # Contract out the indices from the flattened object.; # Note that we need to feed pairs through dims_idxs_to_tensor_idxs; # to ensure that we are contracting the right indices.; qtens = _tensor_contract_dense(qtens, *dims_idxs_to_tensor_idxs(dims, pairs)). # Remove the contracted indexes from dims so we know how to; # reshape back.; # This concerns dims, and not the tensor indices, so we need; # to make sure to use the original dims indices and not the ones; # generated by dims_to_* functions.; contracted_idxs = deep_remove(dims_idxs, *flatten(list(map(list, pairs)))); contracted_dims = unflatten(flatten(dims), contracted_idxs). # We don't need to check for tensor idxs versus dims idxs here,; # as column- versus row-stacking will never move an index for the; # vectorized operator spaces all the way from the left to the right.; l_mtx_dims, r_mtx_dims = map(np.product, map(flatten, contracted_dims)). # Reshape back into a 2D matrix.; qmtx = qtens.reshape((l_mtx_dims, r_mtx_dims)). # Return back as a qobj.; return Qobj(qmtx, dims=contracted_dims, superrep=qobj.superrep). import qutip.states.  Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, and A.L. Grimsmo.; Last updated on Jan 17, 2018. . Built with Sphinx using a theme provided by Read the Docs. . ",MatchSource.WIKI,docs/4.2/modules/qutip/tensor.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/tensor.html
https://qutip.org/docs/4.2/modules/qutip/tensor.html:2629,Integrability,depend,dependency,2629,"OCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,; # DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY; # THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT; # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE; # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.; ###############################################################################; """"""; Module for the creation of composite quantum objects via the tensor product.; """""". __all__ = [; 'tensor', 'super_tensor', 'composite', 'tensor_swap', 'tensor_contract'; ]. import numpy as np; import scipy.sparse as sp; from qutip.cy.spmath import zcsr_kron; from qutip.qobj import Qobj; from qutip.permute import reshuffle; from qutip.superoperator import operator_to_vector; from qutip.dimensions import (; flatten, enumerate_flat, unflatten, deep_remove,; dims_to_tensor_shape, dims_idxs_to_tensor_idxs; ). import qutip.settings; import qutip.superop_reps # Avoid circular dependency here. [docs]def tensor(*args):; """"""Calculates the tensor product of input operators. Parameters; ----------; args : array_like; ``list`` or ``array`` of quantum objects for tensor product. Returns; -------; obj : qobj; A composite quantum object. Examples; --------; >>> tensor([sigmax(), sigmax()]); Quantum object: dims = [[2, 2], [2, 2]], \; shape = [4, 4], type = oper, isHerm = True; Qobj data =; [[ 0.+0.j 0.+0.j 0.+0.j 1.+0.j]; [ 0.+0.j 0.+0.j 1.+0.j 0.+0.j]; [ 0.+0.j 1.+0.j 0.+0.j 0.+0.j]; [ 1.+0.j 0.+0.j 0.+0.j 0.+0.j]]; """""". if not args:; raise TypeError(""Requires at least one input argument""). if len(args) == 1 and isinstance(args[0], (list, np.ndarray)):; # this is the case when tensor is called on the form:; # tensor([q1, q2, q3, ...]); qlist = args[0]. elif len(args) == 1 and isinstance(args[0], Qobj):; # tensor is called with a single Qobj as an argument, do nothing; return args[0]. else:; # this is the case when tensor is called on the form:; # tensor(q1, ",MatchSource.WIKI,docs/4.2/modules/qutip/tensor.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/tensor.html
https://qutip.org/docs/4.2/modules/qutip/tensor.html:8026,Integrability,contract,contract,8026,"e already type=super, while it will; # promote unitaries to superunitaries.; return super_tensor(*map(qutip.superop_reps.to_super, args)). else:; # Everything's just an oper, so ordinary tensor products work.; return tensor(*args). elif all(map(_isketlike, args)):; # Ket-likes.; if any(arg.isoperket for arg in args):; # We have a vectorized operator, we we may need to promote; # something.; return super_tensor(*(; arg if arg.isoperket; else operator_to_vector(qutip.states.ket2dm(arg)); for arg in args; )). else:; # Everything's ordinary, so we can use the tensor product here.; return tensor(*args). elif all(map(_isbralike, args)):; # Turn into ket-likes and recurse.; return composite(*(arg.dag() for arg in args)).dag(). else:; raise TypeError(""Unsupported Qobj types [{}]."".format(; "", "".join(arg.type for arg in args); )). def _tensor_contract_single(arr, i, j):; """"""; Contracts a dense tensor along a single index pair.; """"""; if arr.shape[i] != arr.shape[j]:; raise ValueError(""Cannot contract over indices of different length.""); idxs = np.arange(arr.shape[i]); sl = tuple(slice(None, None, None); if idx not in (i, j) else idxs for idx in range(arr.ndim)); contract_at = i if j == i + 1 else 0; return np.sum(arr[sl], axis=contract_at). def _tensor_contract_dense(arr, *pairs):; """"""; Contracts a dense tensor along one or more index pairs,; keeping track of how the indices are relabeled by the removal; of other indices.; """"""; axis_idxs = list(range(arr.ndim)); for pair in pairs:; # axis_idxs.index effectively evaluates the mapping from; # original index labels to the labels after contraction.; arr = _tensor_contract_single(arr, *map(axis_idxs.index, pair)); list(map(axis_idxs.remove, pair)); return arr. def tensor_swap(q_oper, *pairs):; """"""Transposes one or more pairs of indices of a Qobj.; Note that this uses dense representations and thus; should *not* be used for very large Qobjs. Parameters; ----------. pairs : tuple; One or more tuples ``(i, j)`` indicating that the; `",MatchSource.WIKI,docs/4.2/modules/qutip/tensor.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/tensor.html
https://qutip.org/docs/4.2/modules/qutip/tensor.html:8628,Integrability,contract,contraction,8628,"e tensor product here.; return tensor(*args). elif all(map(_isbralike, args)):; # Turn into ket-likes and recurse.; return composite(*(arg.dag() for arg in args)).dag(). else:; raise TypeError(""Unsupported Qobj types [{}]."".format(; "", "".join(arg.type for arg in args); )). def _tensor_contract_single(arr, i, j):; """"""; Contracts a dense tensor along a single index pair.; """"""; if arr.shape[i] != arr.shape[j]:; raise ValueError(""Cannot contract over indices of different length.""); idxs = np.arange(arr.shape[i]); sl = tuple(slice(None, None, None); if idx not in (i, j) else idxs for idx in range(arr.ndim)); contract_at = i if j == i + 1 else 0; return np.sum(arr[sl], axis=contract_at). def _tensor_contract_dense(arr, *pairs):; """"""; Contracts a dense tensor along one or more index pairs,; keeping track of how the indices are relabeled by the removal; of other indices.; """"""; axis_idxs = list(range(arr.ndim)); for pair in pairs:; # axis_idxs.index effectively evaluates the mapping from; # original index labels to the labels after contraction.; arr = _tensor_contract_single(arr, *map(axis_idxs.index, pair)); list(map(axis_idxs.remove, pair)); return arr. def tensor_swap(q_oper, *pairs):; """"""Transposes one or more pairs of indices of a Qobj.; Note that this uses dense representations and thus; should *not* be used for very large Qobjs. Parameters; ----------. pairs : tuple; One or more tuples ``(i, j)`` indicating that the; ``i`` and ``j`` dimensions of the original qobj; should be swapped. Returns; -------. sqobj : Qobj; The original Qobj with all named index pairs swapped with each other; """"""; dims = q_oper.dims; tensor_pairs = dims_idxs_to_tensor_idxs(dims, pairs). data = q_oper.data.toarray(). # Reshape into tensor indices; data = data.reshape(dims_to_tensor_shape(dims)). # Now permute the dims list so we know how to get back.; flat_dims = flatten(dims); perm = list(range(len(flat_dims))); for i, j in pairs:; flat_dims[i], flat_dims[j] = flat_dims[j], flat_dims[i]; for i",MatchSource.WIKI,docs/4.2/modules/qutip/tensor.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/tensor.html
https://qutip.org/docs/4.2/modules/qutip/tensor.html:10282,Integrability,contract,contracted,10282,"ensor_pairs = dims_idxs_to_tensor_idxs(dims, pairs). data = q_oper.data.toarray(). # Reshape into tensor indices; data = data.reshape(dims_to_tensor_shape(dims)). # Now permute the dims list so we know how to get back.; flat_dims = flatten(dims); perm = list(range(len(flat_dims))); for i, j in pairs:; flat_dims[i], flat_dims[j] = flat_dims[j], flat_dims[i]; for i, j in tensor_pairs:; perm[i], perm[j] = perm[j], perm[i]; dims = unflatten(flat_dims, enumerate_flat(dims)). # Next, permute the actual indices of the dense tensor.; data = data.transpose(perm). # Reshape back, using the left and right of dims.; data = data.reshape(list(map(np.prod, dims))). return Qobj(inpt=data, dims=dims, superrep=q_oper.superrep). [docs]def tensor_contract(qobj, *pairs):; """"""Contracts a qobj along one or more index pairs.; Note that this uses dense representations and thus; should *not* be used for very large Qobjs. Parameters; ----------. pairs : tuple; One or more tuples ``(i, j)`` indicating that the; ``i`` and ``j`` dimensions of the original qobj; should be contracted. Returns; -------. cqobj : Qobj; The original Qobj with all named index pairs contracted; away. """"""; # Record and label the original dims.; dims = qobj.dims; dims_idxs = enumerate_flat(dims); tensor_dims = dims_to_tensor_shape(dims). # Convert to dense first, since sparse won't support the reshaping we need.; qtens = qobj.data.toarray(). # Reshape by the flattened dims.; qtens = qtens.reshape(tensor_dims). # Contract out the indices from the flattened object.; # Note that we need to feed pairs through dims_idxs_to_tensor_idxs; # to ensure that we are contracting the right indices.; qtens = _tensor_contract_dense(qtens, *dims_idxs_to_tensor_idxs(dims, pairs)). # Remove the contracted indexes from dims so we know how to; # reshape back.; # This concerns dims, and not the tensor indices, so we need; # to make sure to use the original dims indices and not the ones; # generated by dims_to_* functions.; contracted_idxs = dee",MatchSource.WIKI,docs/4.2/modules/qutip/tensor.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/tensor.html
https://qutip.org/docs/4.2/modules/qutip/tensor.html:10371,Integrability,contract,contracted,10371,".reshape(dims_to_tensor_shape(dims)). # Now permute the dims list so we know how to get back.; flat_dims = flatten(dims); perm = list(range(len(flat_dims))); for i, j in pairs:; flat_dims[i], flat_dims[j] = flat_dims[j], flat_dims[i]; for i, j in tensor_pairs:; perm[i], perm[j] = perm[j], perm[i]; dims = unflatten(flat_dims, enumerate_flat(dims)). # Next, permute the actual indices of the dense tensor.; data = data.transpose(perm). # Reshape back, using the left and right of dims.; data = data.reshape(list(map(np.prod, dims))). return Qobj(inpt=data, dims=dims, superrep=q_oper.superrep). [docs]def tensor_contract(qobj, *pairs):; """"""Contracts a qobj along one or more index pairs.; Note that this uses dense representations and thus; should *not* be used for very large Qobjs. Parameters; ----------. pairs : tuple; One or more tuples ``(i, j)`` indicating that the; ``i`` and ``j`` dimensions of the original qobj; should be contracted. Returns; -------. cqobj : Qobj; The original Qobj with all named index pairs contracted; away. """"""; # Record and label the original dims.; dims = qobj.dims; dims_idxs = enumerate_flat(dims); tensor_dims = dims_to_tensor_shape(dims). # Convert to dense first, since sparse won't support the reshaping we need.; qtens = qobj.data.toarray(). # Reshape by the flattened dims.; qtens = qtens.reshape(tensor_dims). # Contract out the indices from the flattened object.; # Note that we need to feed pairs through dims_idxs_to_tensor_idxs; # to ensure that we are contracting the right indices.; qtens = _tensor_contract_dense(qtens, *dims_idxs_to_tensor_idxs(dims, pairs)). # Remove the contracted indexes from dims so we know how to; # reshape back.; # This concerns dims, and not the tensor indices, so we need; # to make sure to use the original dims indices and not the ones; # generated by dims_to_* functions.; contracted_idxs = deep_remove(dims_idxs, *flatten(list(map(list, pairs)))); contracted_dims = unflatten(flatten(dims), contracted_idxs). # We don'",MatchSource.WIKI,docs/4.2/modules/qutip/tensor.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/tensor.html
https://qutip.org/docs/4.2/modules/qutip/tensor.html:10850,Integrability,contract,contracting,10850,"d right of dims.; data = data.reshape(list(map(np.prod, dims))). return Qobj(inpt=data, dims=dims, superrep=q_oper.superrep). [docs]def tensor_contract(qobj, *pairs):; """"""Contracts a qobj along one or more index pairs.; Note that this uses dense representations and thus; should *not* be used for very large Qobjs. Parameters; ----------. pairs : tuple; One or more tuples ``(i, j)`` indicating that the; ``i`` and ``j`` dimensions of the original qobj; should be contracted. Returns; -------. cqobj : Qobj; The original Qobj with all named index pairs contracted; away. """"""; # Record and label the original dims.; dims = qobj.dims; dims_idxs = enumerate_flat(dims); tensor_dims = dims_to_tensor_shape(dims). # Convert to dense first, since sparse won't support the reshaping we need.; qtens = qobj.data.toarray(). # Reshape by the flattened dims.; qtens = qtens.reshape(tensor_dims). # Contract out the indices from the flattened object.; # Note that we need to feed pairs through dims_idxs_to_tensor_idxs; # to ensure that we are contracting the right indices.; qtens = _tensor_contract_dense(qtens, *dims_idxs_to_tensor_idxs(dims, pairs)). # Remove the contracted indexes from dims so we know how to; # reshape back.; # This concerns dims, and not the tensor indices, so we need; # to make sure to use the original dims indices and not the ones; # generated by dims_to_* functions.; contracted_idxs = deep_remove(dims_idxs, *flatten(list(map(list, pairs)))); contracted_dims = unflatten(flatten(dims), contracted_idxs). # We don't need to check for tensor idxs versus dims idxs here,; # as column- versus row-stacking will never move an index for the; # vectorized operator spaces all the way from the left to the right.; l_mtx_dims, r_mtx_dims = map(np.product, map(flatten, contracted_dims)). # Reshape back into a 2D matrix.; qmtx = qtens.reshape((l_mtx_dims, r_mtx_dims)). # Return back as a qobj.; return Qobj(qmtx, dims=contracted_dims, superrep=qobj.superrep). import qutip.states.  Copyri",MatchSource.WIKI,docs/4.2/modules/qutip/tensor.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/tensor.html
https://qutip.org/docs/4.2/modules/qutip/tensor.html:10974,Integrability,contract,contracted,10974," a qobj along one or more index pairs.; Note that this uses dense representations and thus; should *not* be used for very large Qobjs. Parameters; ----------. pairs : tuple; One or more tuples ``(i, j)`` indicating that the; ``i`` and ``j`` dimensions of the original qobj; should be contracted. Returns; -------. cqobj : Qobj; The original Qobj with all named index pairs contracted; away. """"""; # Record and label the original dims.; dims = qobj.dims; dims_idxs = enumerate_flat(dims); tensor_dims = dims_to_tensor_shape(dims). # Convert to dense first, since sparse won't support the reshaping we need.; qtens = qobj.data.toarray(). # Reshape by the flattened dims.; qtens = qtens.reshape(tensor_dims). # Contract out the indices from the flattened object.; # Note that we need to feed pairs through dims_idxs_to_tensor_idxs; # to ensure that we are contracting the right indices.; qtens = _tensor_contract_dense(qtens, *dims_idxs_to_tensor_idxs(dims, pairs)). # Remove the contracted indexes from dims so we know how to; # reshape back.; # This concerns dims, and not the tensor indices, so we need; # to make sure to use the original dims indices and not the ones; # generated by dims_to_* functions.; contracted_idxs = deep_remove(dims_idxs, *flatten(list(map(list, pairs)))); contracted_dims = unflatten(flatten(dims), contracted_idxs). # We don't need to check for tensor idxs versus dims idxs here,; # as column- versus row-stacking will never move an index for the; # vectorized operator spaces all the way from the left to the right.; l_mtx_dims, r_mtx_dims = map(np.product, map(flatten, contracted_dims)). # Reshape back into a 2D matrix.; qmtx = qtens.reshape((l_mtx_dims, r_mtx_dims)). # Return back as a qobj.; return Qobj(qmtx, dims=contracted_dims, superrep=qobj.superrep). import qutip.states.  Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, and A.L. Grimsmo.; Last updated on Jan 17, 2018. . Built with Sphinx using a theme provided by Read th",MatchSource.WIKI,docs/4.2/modules/qutip/tensor.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/tensor.html
https://qutip.org/docs/4.2/modules/qutip/three_level_atom.html:2366,Deployability,configurat,configuration,2366,"DING, BUT NOT; # LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A; # PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT; # HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,; # SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT; # LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,; # DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY; # THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT; # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE; # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.; ###############################################################################; '''; This module provides functions that are useful for simulating the; three level atom with QuTiP. A three level atom (qutrit) has three states,; which are linked by dipole transitions so that 1 <-> 2 <-> 3.; Depending on there relative energies they are in the ladder, lambda or; vee configuration. The structure of the relevant operators is the same; for any of the three configurations::. Ladder: Lambda: Vee:; |two> |three>; -------|three> ------- -------; | / \ |one> /; | / \ ------- /; | / \ \ /; -------|two> / \ \ /; | / \ \ /; | / \ \ /; | / -------- \ /; -------|one> ------- |three> -------; |one> |two>. References; ----------; The naming of qutip operators follows the convention in [1]_ . .. [1] Shore, B. W., ""The Theory of Coherent Atomic Excitation"",; Wiley, 1990. Notes; -----; Contributed by Markus Baden, Oct. 07, 2011. '''. __all__ = ['three_level_basis', 'three_level_ops']. from qutip.states import qutrit_basis; from numpy import array. [docs]def three_level_basis():; ''' Basis states for a three level atom. Returns; -------; states : array; `array` of three level atom basis vectors. '''; # A three level atom has the same representation as a qutrit, i.e.; # three states; return qutrit_basis(). [docs]def three_level_ops():;",MatchSource.WIKI,docs/4.2/modules/qutip/three_level_atom.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/three_level_atom.html
https://qutip.org/docs/4.2/modules/qutip/three_level_atom.html:2455,Deployability,configurat,configurations,2455,"PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT; # HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,; # SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT; # LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,; # DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY; # THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT; # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE; # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.; ###############################################################################; '''; This module provides functions that are useful for simulating the; three level atom with QuTiP. A three level atom (qutrit) has three states,; which are linked by dipole transitions so that 1 <-> 2 <-> 3.; Depending on there relative energies they are in the ladder, lambda or; vee configuration. The structure of the relevant operators is the same; for any of the three configurations::. Ladder: Lambda: Vee:; |two> |three>; -------|three> ------- -------; | / \ |one> /; | / \ ------- /; | / \ \ /; -------|two> / \ \ /; | / \ \ /; | / \ \ /; | / -------- \ /; -------|one> ------- |three> -------; |one> |two>. References; ----------; The naming of qutip operators follows the convention in [1]_ . .. [1] Shore, B. W., ""The Theory of Coherent Atomic Excitation"",; Wiley, 1990. Notes; -----; Contributed by Markus Baden, Oct. 07, 2011. '''. __all__ = ['three_level_basis', 'three_level_ops']. from qutip.states import qutrit_basis; from numpy import array. [docs]def three_level_basis():; ''' Basis states for a three level atom. Returns; -------; states : array; `array` of three level atom basis vectors. '''; # A three level atom has the same representation as a qutrit, i.e.; # three states; return qutrit_basis(). [docs]def three_level_ops():; ''' Operators for a three level system (qutrit). Returns; --------; ops : array; `array` of",MatchSource.WIKI,docs/4.2/modules/qutip/three_level_atom.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/three_level_atom.html
https://qutip.org/docs/4.2/modules/qutip/three_level_atom.html:3999,Deployability,update,updated,3999,"s module provides functions that are useful for simulating the; three level atom with QuTiP. A three level atom (qutrit) has three states,; which are linked by dipole transitions so that 1 <-> 2 <-> 3.; Depending on there relative energies they are in the ladder, lambda or; vee configuration. The structure of the relevant operators is the same; for any of the three configurations::. Ladder: Lambda: Vee:; |two> |three>; -------|three> ------- -------; | / \ |one> /; | / \ ------- /; | / \ \ /; -------|two> / \ \ /; | / \ \ /; | / \ \ /; | / -------- \ /; -------|one> ------- |three> -------; |one> |two>. References; ----------; The naming of qutip operators follows the convention in [1]_ . .. [1] Shore, B. W., ""The Theory of Coherent Atomic Excitation"",; Wiley, 1990. Notes; -----; Contributed by Markus Baden, Oct. 07, 2011. '''. __all__ = ['three_level_basis', 'three_level_ops']. from qutip.states import qutrit_basis; from numpy import array. [docs]def three_level_basis():; ''' Basis states for a three level atom. Returns; -------; states : array; `array` of three level atom basis vectors. '''; # A three level atom has the same representation as a qutrit, i.e.; # three states; return qutrit_basis(). [docs]def three_level_ops():; ''' Operators for a three level system (qutrit). Returns; --------; ops : array; `array` of three level operators. '''; one, two, three = qutrit_basis(); # Note that the three level operators are different; # from the qutrit operators. A three level atom only; # has transitions 1 <-> 2 <-> 3, so we define the; # operators seperately from the qutrit code; sig11 = one * one.dag(); sig22 = two * two.dag(); sig33 = three * three.dag(); sig12 = one * two.dag(); sig32 = three * two.dag(); return array([sig11, sig22, sig33, sig12, sig32], dtype=object).  Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, and A.L. Grimsmo.; Last updated on Jan 17, 2018. . Built with Sphinx using a theme provided by Read the Docs. . ",MatchSource.WIKI,docs/4.2/modules/qutip/three_level_atom.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/three_level_atom.html
https://qutip.org/docs/4.2/modules/qutip/three_level_atom.html:2366,Modifiability,config,configuration,2366,"DING, BUT NOT; # LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A; # PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT; # HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,; # SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT; # LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,; # DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY; # THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT; # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE; # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.; ###############################################################################; '''; This module provides functions that are useful for simulating the; three level atom with QuTiP. A three level atom (qutrit) has three states,; which are linked by dipole transitions so that 1 <-> 2 <-> 3.; Depending on there relative energies they are in the ladder, lambda or; vee configuration. The structure of the relevant operators is the same; for any of the three configurations::. Ladder: Lambda: Vee:; |two> |three>; -------|three> ------- -------; | / \ |one> /; | / \ ------- /; | / \ \ /; -------|two> / \ \ /; | / \ \ /; | / \ \ /; | / -------- \ /; -------|one> ------- |three> -------; |one> |two>. References; ----------; The naming of qutip operators follows the convention in [1]_ . .. [1] Shore, B. W., ""The Theory of Coherent Atomic Excitation"",; Wiley, 1990. Notes; -----; Contributed by Markus Baden, Oct. 07, 2011. '''. __all__ = ['three_level_basis', 'three_level_ops']. from qutip.states import qutrit_basis; from numpy import array. [docs]def three_level_basis():; ''' Basis states for a three level atom. Returns; -------; states : array; `array` of three level atom basis vectors. '''; # A three level atom has the same representation as a qutrit, i.e.; # three states; return qutrit_basis(). [docs]def three_level_ops():;",MatchSource.WIKI,docs/4.2/modules/qutip/three_level_atom.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/three_level_atom.html
https://qutip.org/docs/4.2/modules/qutip/three_level_atom.html:2455,Modifiability,config,configurations,2455,"PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT; # HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,; # SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT; # LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,; # DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY; # THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT; # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE; # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.; ###############################################################################; '''; This module provides functions that are useful for simulating the; three level atom with QuTiP. A three level atom (qutrit) has three states,; which are linked by dipole transitions so that 1 <-> 2 <-> 3.; Depending on there relative energies they are in the ladder, lambda or; vee configuration. The structure of the relevant operators is the same; for any of the three configurations::. Ladder: Lambda: Vee:; |two> |three>; -------|three> ------- -------; | / \ |one> /; | / \ ------- /; | / \ \ /; -------|two> / \ \ /; | / \ \ /; | / \ \ /; | / -------- \ /; -------|one> ------- |three> -------; |one> |two>. References; ----------; The naming of qutip operators follows the convention in [1]_ . .. [1] Shore, B. W., ""The Theory of Coherent Atomic Excitation"",; Wiley, 1990. Notes; -----; Contributed by Markus Baden, Oct. 07, 2011. '''. __all__ = ['three_level_basis', 'three_level_ops']. from qutip.states import qutrit_basis; from numpy import array. [docs]def three_level_basis():; ''' Basis states for a three level atom. Returns; -------; states : array; `array` of three level atom basis vectors. '''; # A three level atom has the same representation as a qutrit, i.e.; # three states; return qutrit_basis(). [docs]def three_level_ops():; ''' Operators for a three level system (qutrit). Returns; --------; ops : array; `array` of",MatchSource.WIKI,docs/4.2/modules/qutip/three_level_atom.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/three_level_atom.html
https://qutip.org/docs/4.2/modules/qutip/tomography.html:6679,Deployability,update,updated,6679," fig argument). threshold: float (None); Threshold for when bars of smaller height should be transparent. If; not set, all bars are colored according to the color map. Returns; -------; fig, ax : tuple; A tuple of the matplotlib figure and axes instances used to produce; the figure.; """""". if ax is None:; if fig is None:; fig = plt.figure(figsize=figsize); ax = fig.add_subplot(1, 1, 1, projection='3d', position=[0, 0, 1, 1]). xlabels = []; for inds in _index_permutations([len(lbls) for lbls in lbls_list]):; xlabels.append("""".join(; [lbls_list[k][inds[k]] for k in range(len(lbls_list))])). if not title:; title = r""$\chi$"". matrix_histogram_complex(chi, xlabels, xlabels, title=title, ax=ax,; threshold=threshold). return fig, ax. [docs]def qpt(U, op_basis_list):; """"""; Calculate the quantum process tomography chi matrix for a given (possibly; nonunitary) transformation matrix U, which transforms a density matrix in; vector form according to:. vec(rho) = U * vec(rho0). or. rho = vec2mat(U * mat2vec(rho0)). U can be calculated for an open quantum system using the QuTiP propagator; function. Parameters; ----------; U : Qobj; Transformation operator. Can be calculated using QuTiP propagator; function. op_basis_list : list; A list of Qobj's representing the basis states. Returns; -------; chi : array; QPT chi matrix. """""". E_ops = []; # loop over all index permutations; for inds in _index_permutations([len(ops) for ops in op_basis_list]):; # loop over all composite systems; E_op_list = [op_basis_list[k][inds[k]] for k in range(len(; op_basis_list))]; E_ops.append(tensor(E_op_list)). EE_ops = [spre(E1) * spost(E2.dag()) for E1 in E_ops for E2 in E_ops]. M = hstack([mat2vec(EE.full()) for EE in EE_ops]). Uvec = mat2vec(U.full()). chi_vec = la.solve(M, Uvec). return vec2mat(chi_vec).  Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, and A.L. Grimsmo.; Last updated on Jan 17, 2018. . Built with Sphinx using a theme provided by Read the Docs. . ",MatchSource.WIKI,docs/4.2/modules/qutip/tomography.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/tomography.html
https://qutip.org/docs/4.2/modules/qutip/utilities.html:9988,Deployability,update,updated,9988,"K = w * 1.0e12 * (_h / _kB); return w_mK. def convert_mK_to_GHz(w):; """"""; Convert an energy from unit mK to unit GHz. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit. """"""; w_GHz = w * 1.0e-12 * (_kB / _h); return w_GHz. def view_methods(Q):; """"""; View the methods and corresponding doc strings; for a Qobj class. Parameters; ----------; Q : Qobj; Input Quantum object. """"""; meth = dir(Q); qobj_props = ['data', 'dims', 'isherm', 'shape', 'type']; pub_meth = [x for x in meth if x.find('_') and x not in qobj_props]; ml = max([len(x) for x in pub_meth]); nl = len(Q.__class__.__name__ + 'Class Methods:'); print(Q.__class__.__name__ + ' Class Methods:'); print('-' * nl); for ii in range(len(pub_meth)):; m = getattr(Q, pub_meth[ii]); meth_str = m.__doc__; ind = meth_str.find('\n'); pub_len = len(pub_meth[ii] + ': '); print(pub_meth[ii] + ':' + ' ' * (ml+3-pub_len) + meth_str[:ind]). def _version2int(version_string):; str_list = version_string.split(; ""-dev"")[0].split(""rc"")[0].split(""a"")[0].split(""b"")[0].split(; ""post"")[0].split('.'); return sum([int(d if len(d) > 0 else 0) * (100 ** (3 - n)); for n, d in enumerate(str_list[:3])]). def _blas_info():; config = np.__config__; blas_info = config.blas_opt_info; _has_lib_key = 'libraries' in blas_info.keys(); blas = None; if hasattr(config,'mkl_info') or \; (_has_lib_key and any('mkl' in lib for lib in blas_info['libraries'])):; blas = 'INTEL MKL'; elif hasattr(config,'openblas_info') or \; (_has_lib_key and any('openblas' in lib for lib in blas_info['libraries'])):; blas = 'OPENBLAS'; elif 'extra_link_args' in blas_info.keys() and ('-Wl,Accelerate' in blas_info['extra_link_args']):; blas = 'Accelerate'; else:; blas = 'Generic'; return blas.  Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, and A.L. Grimsmo.; Last updated on Jan 17, 2018. . Built with Sphinx using a theme provided by Read the Docs. . ",MatchSource.WIKI,docs/4.2/modules/qutip/utilities.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/utilities.html
https://qutip.org/docs/4.2/modules/qutip/utilities.html:5431,Energy Efficiency,energy,energy,5431,".min([j2 + j3 + m1, j3 - j1 + j2, j3 + m3])). C = np.sqrt((2.0 * j3 + 1.0) * factorial(j3 + j1 - j2) *; factorial(j3 - j1 + j2) * factorial(j1 + j2 - j3) *; factorial(j3 + m3) * factorial(j3 - m3) /; (factorial(j1 + j2 + j3 + 1) *; factorial(j1 - m1) * factorial(j1 + m1) *; factorial(j2 - m2) * factorial(j2 + m2))); S = 0; for v in range(vmin, vmax + 1):; S += (-1.0) ** (v + j2 + m2) / factorial(v) * \; factorial(j2 + j3 + m1 - v) * factorial(j1 - m1 + v) / \; factorial(j3 - j1 + j2 - v) / factorial(j3 + m3 - v) / \; factorial(v + j1 - j2 - m3); C = C * S; return C. # -----------------------------------------------------------------------------; # Functions for unit conversions; #; _e = 1.602176565e-19 # C; _kB = 1.3806488e-23 # J/K; _h = 6.62606957e-34 # Js. _unit_factor_tbl = {; # ""unit"": ""factor that convert argument from unit 'unit' to Joule""; ""J"": 1.0,; ""eV"": _e,; ""meV"": 1.0e-3 * _e,; ""GHz"": 1.0e9 * _h,; ""mK"": 1.0e-3 * _kB,; }. [docs]def convert_unit(value, orig=""meV"", to=""GHz""):; """"""; Convert an energy from unit `orig` to unit `to`. Parameters; ----------; value : float / array; The energy in the old unit. orig : string; The name of the original unit (""J"", ""eV"", ""meV"", ""GHz"", ""mK""). to : string; The name of the new unit (""J"", ""eV"", ""meV"", ""GHz"", ""mK""). Returns; -------; value_new_unit : float / array; The energy in the new unit.; """"""; if orig not in _unit_factor_tbl:; raise TypeError(""Unsupported unit %s"" % orig). if to not in _unit_factor_tbl:; raise TypeError(""Unsupported unit %s"" % to). return value * (_unit_factor_tbl[orig] / _unit_factor_tbl[to]). def convert_GHz_to_meV(w):; """"""; Convert an energy from unit GHz to unit meV. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # 1 GHz = 4.1357e-6 eV = 4.1357e-3 meV; w_meV = w * 4.1357e-3; return w_meV. def convert_meV_to_GHz(w):; """"""; Convert an energy from unit meV to unit GHz. Parameters; ----------; w : flo",MatchSource.WIKI,docs/4.2/modules/qutip/utilities.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/utilities.html
https://qutip.org/docs/4.2/modules/qutip/utilities.html:5520,Energy Efficiency,energy,energy,5520," j1 - j2) *; factorial(j3 - j1 + j2) * factorial(j1 + j2 - j3) *; factorial(j3 + m3) * factorial(j3 - m3) /; (factorial(j1 + j2 + j3 + 1) *; factorial(j1 - m1) * factorial(j1 + m1) *; factorial(j2 - m2) * factorial(j2 + m2))); S = 0; for v in range(vmin, vmax + 1):; S += (-1.0) ** (v + j2 + m2) / factorial(v) * \; factorial(j2 + j3 + m1 - v) * factorial(j1 - m1 + v) / \; factorial(j3 - j1 + j2 - v) / factorial(j3 + m3 - v) / \; factorial(v + j1 - j2 - m3); C = C * S; return C. # -----------------------------------------------------------------------------; # Functions for unit conversions; #; _e = 1.602176565e-19 # C; _kB = 1.3806488e-23 # J/K; _h = 6.62606957e-34 # Js. _unit_factor_tbl = {; # ""unit"": ""factor that convert argument from unit 'unit' to Joule""; ""J"": 1.0,; ""eV"": _e,; ""meV"": 1.0e-3 * _e,; ""GHz"": 1.0e9 * _h,; ""mK"": 1.0e-3 * _kB,; }. [docs]def convert_unit(value, orig=""meV"", to=""GHz""):; """"""; Convert an energy from unit `orig` to unit `to`. Parameters; ----------; value : float / array; The energy in the old unit. orig : string; The name of the original unit (""J"", ""eV"", ""meV"", ""GHz"", ""mK""). to : string; The name of the new unit (""J"", ""eV"", ""meV"", ""GHz"", ""mK""). Returns; -------; value_new_unit : float / array; The energy in the new unit.; """"""; if orig not in _unit_factor_tbl:; raise TypeError(""Unsupported unit %s"" % orig). if to not in _unit_factor_tbl:; raise TypeError(""Unsupported unit %s"" % to). return value * (_unit_factor_tbl[orig] / _unit_factor_tbl[to]). def convert_GHz_to_meV(w):; """"""; Convert an energy from unit GHz to unit meV. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # 1 GHz = 4.1357e-6 eV = 4.1357e-3 meV; w_meV = w * 4.1357e-3; return w_meV. def convert_meV_to_GHz(w):; """"""; Convert an energy from unit meV to unit GHz. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The en",MatchSource.WIKI,docs/4.2/modules/qutip/utilities.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/utilities.html
https://qutip.org/docs/4.2/modules/qutip/utilities.html:5747,Energy Efficiency,energy,energy,5747," S = 0; for v in range(vmin, vmax + 1):; S += (-1.0) ** (v + j2 + m2) / factorial(v) * \; factorial(j2 + j3 + m1 - v) * factorial(j1 - m1 + v) / \; factorial(j3 - j1 + j2 - v) / factorial(j3 + m3 - v) / \; factorial(v + j1 - j2 - m3); C = C * S; return C. # -----------------------------------------------------------------------------; # Functions for unit conversions; #; _e = 1.602176565e-19 # C; _kB = 1.3806488e-23 # J/K; _h = 6.62606957e-34 # Js. _unit_factor_tbl = {; # ""unit"": ""factor that convert argument from unit 'unit' to Joule""; ""J"": 1.0,; ""eV"": _e,; ""meV"": 1.0e-3 * _e,; ""GHz"": 1.0e9 * _h,; ""mK"": 1.0e-3 * _kB,; }. [docs]def convert_unit(value, orig=""meV"", to=""GHz""):; """"""; Convert an energy from unit `orig` to unit `to`. Parameters; ----------; value : float / array; The energy in the old unit. orig : string; The name of the original unit (""J"", ""eV"", ""meV"", ""GHz"", ""mK""). to : string; The name of the new unit (""J"", ""eV"", ""meV"", ""GHz"", ""mK""). Returns; -------; value_new_unit : float / array; The energy in the new unit.; """"""; if orig not in _unit_factor_tbl:; raise TypeError(""Unsupported unit %s"" % orig). if to not in _unit_factor_tbl:; raise TypeError(""Unsupported unit %s"" % to). return value * (_unit_factor_tbl[orig] / _unit_factor_tbl[to]). def convert_GHz_to_meV(w):; """"""; Convert an energy from unit GHz to unit meV. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # 1 GHz = 4.1357e-6 eV = 4.1357e-3 meV; w_meV = w * 4.1357e-3; return w_meV. def convert_meV_to_GHz(w):; """"""; Convert an energy from unit meV to unit GHz. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # 1 meV = 1.0/4.1357e-3 GHz; w_GHz = w / 4.1357e-3; return w_GHz. def convert_J_to_meV(w):; """"""; Convert an energy from unit J to unit meV. Parameters; ----------; w : float / array; The energy in ",MatchSource.WIKI,docs/4.2/modules/qutip/utilities.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/utilities.html
https://qutip.org/docs/4.2/modules/qutip/utilities.html:6043,Energy Efficiency,energy,energy,6043,"-----------------------------; # Functions for unit conversions; #; _e = 1.602176565e-19 # C; _kB = 1.3806488e-23 # J/K; _h = 6.62606957e-34 # Js. _unit_factor_tbl = {; # ""unit"": ""factor that convert argument from unit 'unit' to Joule""; ""J"": 1.0,; ""eV"": _e,; ""meV"": 1.0e-3 * _e,; ""GHz"": 1.0e9 * _h,; ""mK"": 1.0e-3 * _kB,; }. [docs]def convert_unit(value, orig=""meV"", to=""GHz""):; """"""; Convert an energy from unit `orig` to unit `to`. Parameters; ----------; value : float / array; The energy in the old unit. orig : string; The name of the original unit (""J"", ""eV"", ""meV"", ""GHz"", ""mK""). to : string; The name of the new unit (""J"", ""eV"", ""meV"", ""GHz"", ""mK""). Returns; -------; value_new_unit : float / array; The energy in the new unit.; """"""; if orig not in _unit_factor_tbl:; raise TypeError(""Unsupported unit %s"" % orig). if to not in _unit_factor_tbl:; raise TypeError(""Unsupported unit %s"" % to). return value * (_unit_factor_tbl[orig] / _unit_factor_tbl[to]). def convert_GHz_to_meV(w):; """"""; Convert an energy from unit GHz to unit meV. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # 1 GHz = 4.1357e-6 eV = 4.1357e-3 meV; w_meV = w * 4.1357e-3; return w_meV. def convert_meV_to_GHz(w):; """"""; Convert an energy from unit meV to unit GHz. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # 1 meV = 1.0/4.1357e-3 GHz; w_GHz = w / 4.1357e-3; return w_GHz. def convert_J_to_meV(w):; """"""; Convert an energy from unit J to unit meV. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # 1 eV = 1.602e-19 J; w_meV = 1000.0 * w / _e; return w_meV. def convert_meV_to_J(w):; """"""; Convert an energy from unit meV to unit J. Parameters; ----------; w : float / array; The energy in the old unit. Return",MatchSource.WIKI,docs/4.2/modules/qutip/utilities.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/utilities.html
https://qutip.org/docs/4.2/modules/qutip/utilities.html:6124,Energy Efficiency,energy,energy,6124,".602176565e-19 # C; _kB = 1.3806488e-23 # J/K; _h = 6.62606957e-34 # Js. _unit_factor_tbl = {; # ""unit"": ""factor that convert argument from unit 'unit' to Joule""; ""J"": 1.0,; ""eV"": _e,; ""meV"": 1.0e-3 * _e,; ""GHz"": 1.0e9 * _h,; ""mK"": 1.0e-3 * _kB,; }. [docs]def convert_unit(value, orig=""meV"", to=""GHz""):; """"""; Convert an energy from unit `orig` to unit `to`. Parameters; ----------; value : float / array; The energy in the old unit. orig : string; The name of the original unit (""J"", ""eV"", ""meV"", ""GHz"", ""mK""). to : string; The name of the new unit (""J"", ""eV"", ""meV"", ""GHz"", ""mK""). Returns; -------; value_new_unit : float / array; The energy in the new unit.; """"""; if orig not in _unit_factor_tbl:; raise TypeError(""Unsupported unit %s"" % orig). if to not in _unit_factor_tbl:; raise TypeError(""Unsupported unit %s"" % to). return value * (_unit_factor_tbl[orig] / _unit_factor_tbl[to]). def convert_GHz_to_meV(w):; """"""; Convert an energy from unit GHz to unit meV. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # 1 GHz = 4.1357e-6 eV = 4.1357e-3 meV; w_meV = w * 4.1357e-3; return w_meV. def convert_meV_to_GHz(w):; """"""; Convert an energy from unit meV to unit GHz. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # 1 meV = 1.0/4.1357e-3 GHz; w_GHz = w / 4.1357e-3; return w_GHz. def convert_J_to_meV(w):; """"""; Convert an energy from unit J to unit meV. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # 1 eV = 1.602e-19 J; w_meV = 1000.0 * w / _e; return w_meV. def convert_meV_to_J(w):; """"""; Convert an energy from unit meV to unit J. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; #",MatchSource.WIKI,docs/4.2/modules/qutip/utilities.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/utilities.html
https://qutip.org/docs/4.2/modules/qutip/utilities.html:6198,Energy Efficiency,energy,energy,6198,"_unit_factor_tbl = {; # ""unit"": ""factor that convert argument from unit 'unit' to Joule""; ""J"": 1.0,; ""eV"": _e,; ""meV"": 1.0e-3 * _e,; ""GHz"": 1.0e9 * _h,; ""mK"": 1.0e-3 * _kB,; }. [docs]def convert_unit(value, orig=""meV"", to=""GHz""):; """"""; Convert an energy from unit `orig` to unit `to`. Parameters; ----------; value : float / array; The energy in the old unit. orig : string; The name of the original unit (""J"", ""eV"", ""meV"", ""GHz"", ""mK""). to : string; The name of the new unit (""J"", ""eV"", ""meV"", ""GHz"", ""mK""). Returns; -------; value_new_unit : float / array; The energy in the new unit.; """"""; if orig not in _unit_factor_tbl:; raise TypeError(""Unsupported unit %s"" % orig). if to not in _unit_factor_tbl:; raise TypeError(""Unsupported unit %s"" % to). return value * (_unit_factor_tbl[orig] / _unit_factor_tbl[to]). def convert_GHz_to_meV(w):; """"""; Convert an energy from unit GHz to unit meV. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # 1 GHz = 4.1357e-6 eV = 4.1357e-3 meV; w_meV = w * 4.1357e-3; return w_meV. def convert_meV_to_GHz(w):; """"""; Convert an energy from unit meV to unit GHz. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # 1 meV = 1.0/4.1357e-3 GHz; w_GHz = w / 4.1357e-3; return w_GHz. def convert_J_to_meV(w):; """"""; Convert an energy from unit J to unit meV. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # 1 eV = 1.602e-19 J; w_meV = 1000.0 * w / _e; return w_meV. def convert_meV_to_J(w):; """"""; Convert an energy from unit meV to unit J. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # 1 eV = 1.602e-19 J; w_J = 0.001 * w * _e; return w_J. def convert_meV_t",MatchSource.WIKI,docs/4.2/modules/qutip/utilities.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/utilities.html
https://qutip.org/docs/4.2/modules/qutip/utilities.html:6349,Energy Efficiency,energy,energy,6349,"1.0e-3 * _kB,; }. [docs]def convert_unit(value, orig=""meV"", to=""GHz""):; """"""; Convert an energy from unit `orig` to unit `to`. Parameters; ----------; value : float / array; The energy in the old unit. orig : string; The name of the original unit (""J"", ""eV"", ""meV"", ""GHz"", ""mK""). to : string; The name of the new unit (""J"", ""eV"", ""meV"", ""GHz"", ""mK""). Returns; -------; value_new_unit : float / array; The energy in the new unit.; """"""; if orig not in _unit_factor_tbl:; raise TypeError(""Unsupported unit %s"" % orig). if to not in _unit_factor_tbl:; raise TypeError(""Unsupported unit %s"" % to). return value * (_unit_factor_tbl[orig] / _unit_factor_tbl[to]). def convert_GHz_to_meV(w):; """"""; Convert an energy from unit GHz to unit meV. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # 1 GHz = 4.1357e-6 eV = 4.1357e-3 meV; w_meV = w * 4.1357e-3; return w_meV. def convert_meV_to_GHz(w):; """"""; Convert an energy from unit meV to unit GHz. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # 1 meV = 1.0/4.1357e-3 GHz; w_GHz = w / 4.1357e-3; return w_GHz. def convert_J_to_meV(w):; """"""; Convert an energy from unit J to unit meV. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # 1 eV = 1.602e-19 J; w_meV = 1000.0 * w / _e; return w_meV. def convert_meV_to_J(w):; """"""; Convert an energy from unit meV to unit J. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # 1 eV = 1.602e-19 J; w_J = 0.001 * w * _e; return w_J. def convert_meV_to_mK(w):; """"""; Convert an energy from unit meV to unit mK. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit ",MatchSource.WIKI,docs/4.2/modules/qutip/utilities.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/utilities.html
https://qutip.org/docs/4.2/modules/qutip/utilities.html:6430,Energy Efficiency,energy,energy,6430,"""; Convert an energy from unit `orig` to unit `to`. Parameters; ----------; value : float / array; The energy in the old unit. orig : string; The name of the original unit (""J"", ""eV"", ""meV"", ""GHz"", ""mK""). to : string; The name of the new unit (""J"", ""eV"", ""meV"", ""GHz"", ""mK""). Returns; -------; value_new_unit : float / array; The energy in the new unit.; """"""; if orig not in _unit_factor_tbl:; raise TypeError(""Unsupported unit %s"" % orig). if to not in _unit_factor_tbl:; raise TypeError(""Unsupported unit %s"" % to). return value * (_unit_factor_tbl[orig] / _unit_factor_tbl[to]). def convert_GHz_to_meV(w):; """"""; Convert an energy from unit GHz to unit meV. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # 1 GHz = 4.1357e-6 eV = 4.1357e-3 meV; w_meV = w * 4.1357e-3; return w_meV. def convert_meV_to_GHz(w):; """"""; Convert an energy from unit meV to unit GHz. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # 1 meV = 1.0/4.1357e-3 GHz; w_GHz = w / 4.1357e-3; return w_GHz. def convert_J_to_meV(w):; """"""; Convert an energy from unit J to unit meV. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # 1 eV = 1.602e-19 J; w_meV = 1000.0 * w / _e; return w_meV. def convert_meV_to_J(w):; """"""; Convert an energy from unit meV to unit J. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # 1 eV = 1.602e-19 J; w_J = 0.001 * w * _e; return w_J. def convert_meV_to_mK(w):; """"""; Convert an energy from unit meV to unit mK. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # 1 mK = 0.0000861740 me",MatchSource.WIKI,docs/4.2/modules/qutip/utilities.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/utilities.html
https://qutip.org/docs/4.2/modules/qutip/utilities.html:6504,Energy Efficiency,energy,energy,6504,"-; value : float / array; The energy in the old unit. orig : string; The name of the original unit (""J"", ""eV"", ""meV"", ""GHz"", ""mK""). to : string; The name of the new unit (""J"", ""eV"", ""meV"", ""GHz"", ""mK""). Returns; -------; value_new_unit : float / array; The energy in the new unit.; """"""; if orig not in _unit_factor_tbl:; raise TypeError(""Unsupported unit %s"" % orig). if to not in _unit_factor_tbl:; raise TypeError(""Unsupported unit %s"" % to). return value * (_unit_factor_tbl[orig] / _unit_factor_tbl[to]). def convert_GHz_to_meV(w):; """"""; Convert an energy from unit GHz to unit meV. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # 1 GHz = 4.1357e-6 eV = 4.1357e-3 meV; w_meV = w * 4.1357e-3; return w_meV. def convert_meV_to_GHz(w):; """"""; Convert an energy from unit meV to unit GHz. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # 1 meV = 1.0/4.1357e-3 GHz; w_GHz = w / 4.1357e-3; return w_GHz. def convert_J_to_meV(w):; """"""; Convert an energy from unit J to unit meV. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # 1 eV = 1.602e-19 J; w_meV = 1000.0 * w / _e; return w_meV. def convert_meV_to_J(w):; """"""; Convert an energy from unit meV to unit J. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # 1 eV = 1.602e-19 J; w_J = 0.001 * w * _e; return w_J. def convert_meV_to_mK(w):; """"""; Convert an energy from unit meV to unit mK. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # 1 mK = 0.0000861740 meV; w_mK = w / 0.0000861740; return w_mK. def convert_mK_to_meV(w):; """""";",MatchSource.WIKI,docs/4.2/modules/qutip/utilities.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/utilities.html
https://qutip.org/docs/4.2/modules/qutip/utilities.html:6642,Energy Efficiency,energy,energy,6642,"he name of the new unit (""J"", ""eV"", ""meV"", ""GHz"", ""mK""). Returns; -------; value_new_unit : float / array; The energy in the new unit.; """"""; if orig not in _unit_factor_tbl:; raise TypeError(""Unsupported unit %s"" % orig). if to not in _unit_factor_tbl:; raise TypeError(""Unsupported unit %s"" % to). return value * (_unit_factor_tbl[orig] / _unit_factor_tbl[to]). def convert_GHz_to_meV(w):; """"""; Convert an energy from unit GHz to unit meV. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # 1 GHz = 4.1357e-6 eV = 4.1357e-3 meV; w_meV = w * 4.1357e-3; return w_meV. def convert_meV_to_GHz(w):; """"""; Convert an energy from unit meV to unit GHz. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # 1 meV = 1.0/4.1357e-3 GHz; w_GHz = w / 4.1357e-3; return w_GHz. def convert_J_to_meV(w):; """"""; Convert an energy from unit J to unit meV. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # 1 eV = 1.602e-19 J; w_meV = 1000.0 * w / _e; return w_meV. def convert_meV_to_J(w):; """"""; Convert an energy from unit meV to unit J. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # 1 eV = 1.602e-19 J; w_J = 0.001 * w * _e; return w_J. def convert_meV_to_mK(w):; """"""; Convert an energy from unit meV to unit mK. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # 1 mK = 0.0000861740 meV; w_mK = w / 0.0000861740; return w_mK. def convert_mK_to_meV(w):; """"""; Convert an energy from unit mK to unit meV. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit :",MatchSource.WIKI,docs/4.2/modules/qutip/utilities.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/utilities.html
https://qutip.org/docs/4.2/modules/qutip/utilities.html:6721,Energy Efficiency,energy,energy,6721,"-; value_new_unit : float / array; The energy in the new unit.; """"""; if orig not in _unit_factor_tbl:; raise TypeError(""Unsupported unit %s"" % orig). if to not in _unit_factor_tbl:; raise TypeError(""Unsupported unit %s"" % to). return value * (_unit_factor_tbl[orig] / _unit_factor_tbl[to]). def convert_GHz_to_meV(w):; """"""; Convert an energy from unit GHz to unit meV. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # 1 GHz = 4.1357e-6 eV = 4.1357e-3 meV; w_meV = w * 4.1357e-3; return w_meV. def convert_meV_to_GHz(w):; """"""; Convert an energy from unit meV to unit GHz. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # 1 meV = 1.0/4.1357e-3 GHz; w_GHz = w / 4.1357e-3; return w_GHz. def convert_J_to_meV(w):; """"""; Convert an energy from unit J to unit meV. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # 1 eV = 1.602e-19 J; w_meV = 1000.0 * w / _e; return w_meV. def convert_meV_to_J(w):; """"""; Convert an energy from unit meV to unit J. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # 1 eV = 1.602e-19 J; w_J = 0.001 * w * _e; return w_J. def convert_meV_to_mK(w):; """"""; Convert an energy from unit meV to unit mK. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # 1 mK = 0.0000861740 meV; w_mK = w / 0.0000861740; return w_mK. def convert_mK_to_meV(w):; """"""; Convert an energy from unit mK to unit meV. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # 1 mK = 0.0000861740 m",MatchSource.WIKI,docs/4.2/modules/qutip/utilities.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/utilities.html
https://qutip.org/docs/4.2/modules/qutip/utilities.html:6795,Energy Efficiency,energy,energy,6795,"rig not in _unit_factor_tbl:; raise TypeError(""Unsupported unit %s"" % orig). if to not in _unit_factor_tbl:; raise TypeError(""Unsupported unit %s"" % to). return value * (_unit_factor_tbl[orig] / _unit_factor_tbl[to]). def convert_GHz_to_meV(w):; """"""; Convert an energy from unit GHz to unit meV. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # 1 GHz = 4.1357e-6 eV = 4.1357e-3 meV; w_meV = w * 4.1357e-3; return w_meV. def convert_meV_to_GHz(w):; """"""; Convert an energy from unit meV to unit GHz. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # 1 meV = 1.0/4.1357e-3 GHz; w_GHz = w / 4.1357e-3; return w_GHz. def convert_J_to_meV(w):; """"""; Convert an energy from unit J to unit meV. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # 1 eV = 1.602e-19 J; w_meV = 1000.0 * w / _e; return w_meV. def convert_meV_to_J(w):; """"""; Convert an energy from unit meV to unit J. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # 1 eV = 1.602e-19 J; w_J = 0.001 * w * _e; return w_J. def convert_meV_to_mK(w):; """"""; Convert an energy from unit meV to unit mK. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # 1 mK = 0.0000861740 meV; w_mK = w / 0.0000861740; return w_mK. def convert_mK_to_meV(w):; """"""; Convert an energy from unit mK to unit meV. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # 1 mK = 0.0000861740 meV; w_meV = w * 0.0000861740; return w_meV. def convert_GHz_to_mK(w):; """,MatchSource.WIKI,docs/4.2/modules/qutip/utilities.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/utilities.html
https://qutip.org/docs/4.2/modules/qutip/utilities.html:6928,Energy Efficiency,energy,energy,6928,"t %s"" % to). return value * (_unit_factor_tbl[orig] / _unit_factor_tbl[to]). def convert_GHz_to_meV(w):; """"""; Convert an energy from unit GHz to unit meV. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # 1 GHz = 4.1357e-6 eV = 4.1357e-3 meV; w_meV = w * 4.1357e-3; return w_meV. def convert_meV_to_GHz(w):; """"""; Convert an energy from unit meV to unit GHz. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # 1 meV = 1.0/4.1357e-3 GHz; w_GHz = w / 4.1357e-3; return w_GHz. def convert_J_to_meV(w):; """"""; Convert an energy from unit J to unit meV. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # 1 eV = 1.602e-19 J; w_meV = 1000.0 * w / _e; return w_meV. def convert_meV_to_J(w):; """"""; Convert an energy from unit meV to unit J. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # 1 eV = 1.602e-19 J; w_J = 0.001 * w * _e; return w_J. def convert_meV_to_mK(w):; """"""; Convert an energy from unit meV to unit mK. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # 1 mK = 0.0000861740 meV; w_mK = w / 0.0000861740; return w_mK. def convert_mK_to_meV(w):; """"""; Convert an energy from unit mK to unit meV. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # 1 mK = 0.0000861740 meV; w_meV = w * 0.0000861740; return w_meV. def convert_GHz_to_mK(w):; """"""; Convert an energy from unit GHz to unit mK. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_ne",MatchSource.WIKI,docs/4.2/modules/qutip/utilities.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/utilities.html
https://qutip.org/docs/4.2/modules/qutip/utilities.html:7007,Energy Efficiency,energy,energy,7007,"o]). def convert_GHz_to_meV(w):; """"""; Convert an energy from unit GHz to unit meV. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # 1 GHz = 4.1357e-6 eV = 4.1357e-3 meV; w_meV = w * 4.1357e-3; return w_meV. def convert_meV_to_GHz(w):; """"""; Convert an energy from unit meV to unit GHz. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # 1 meV = 1.0/4.1357e-3 GHz; w_GHz = w / 4.1357e-3; return w_GHz. def convert_J_to_meV(w):; """"""; Convert an energy from unit J to unit meV. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # 1 eV = 1.602e-19 J; w_meV = 1000.0 * w / _e; return w_meV. def convert_meV_to_J(w):; """"""; Convert an energy from unit meV to unit J. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # 1 eV = 1.602e-19 J; w_J = 0.001 * w * _e; return w_J. def convert_meV_to_mK(w):; """"""; Convert an energy from unit meV to unit mK. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # 1 mK = 0.0000861740 meV; w_mK = w / 0.0000861740; return w_mK. def convert_mK_to_meV(w):; """"""; Convert an energy from unit mK to unit meV. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # 1 mK = 0.0000861740 meV; w_meV = w * 0.0000861740; return w_meV. def convert_GHz_to_mK(w):; """"""; Convert an energy from unit GHz to unit mK. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # h v [Hz] = kB",MatchSource.WIKI,docs/4.2/modules/qutip/utilities.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/utilities.html
https://qutip.org/docs/4.2/modules/qutip/utilities.html:7081,Energy Efficiency,energy,energy,7081,"unit meV. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # 1 GHz = 4.1357e-6 eV = 4.1357e-3 meV; w_meV = w * 4.1357e-3; return w_meV. def convert_meV_to_GHz(w):; """"""; Convert an energy from unit meV to unit GHz. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # 1 meV = 1.0/4.1357e-3 GHz; w_GHz = w / 4.1357e-3; return w_GHz. def convert_J_to_meV(w):; """"""; Convert an energy from unit J to unit meV. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # 1 eV = 1.602e-19 J; w_meV = 1000.0 * w / _e; return w_meV. def convert_meV_to_J(w):; """"""; Convert an energy from unit meV to unit J. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # 1 eV = 1.602e-19 J; w_J = 0.001 * w * _e; return w_J. def convert_meV_to_mK(w):; """"""; Convert an energy from unit meV to unit mK. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # 1 mK = 0.0000861740 meV; w_mK = w / 0.0000861740; return w_mK. def convert_mK_to_meV(w):; """"""; Convert an energy from unit mK to unit meV. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # 1 mK = 0.0000861740 meV; w_meV = w * 0.0000861740; return w_meV. def convert_GHz_to_mK(w):; """"""; Convert an energy from unit GHz to unit mK. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # h v [Hz] = kB T [K]; # h 1e9 v [GHz] = kB 1e-3 T [mK]; # T [mK] = 1e12 * (h/kB) * v [",MatchSource.WIKI,docs/4.2/modules/qutip/utilities.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/utilities.html
https://qutip.org/docs/4.2/modules/qutip/utilities.html:7210,Energy Efficiency,energy,energy,7210," in the new unit.; """"""; # 1 GHz = 4.1357e-6 eV = 4.1357e-3 meV; w_meV = w * 4.1357e-3; return w_meV. def convert_meV_to_GHz(w):; """"""; Convert an energy from unit meV to unit GHz. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # 1 meV = 1.0/4.1357e-3 GHz; w_GHz = w / 4.1357e-3; return w_GHz. def convert_J_to_meV(w):; """"""; Convert an energy from unit J to unit meV. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # 1 eV = 1.602e-19 J; w_meV = 1000.0 * w / _e; return w_meV. def convert_meV_to_J(w):; """"""; Convert an energy from unit meV to unit J. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # 1 eV = 1.602e-19 J; w_J = 0.001 * w * _e; return w_J. def convert_meV_to_mK(w):; """"""; Convert an energy from unit meV to unit mK. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # 1 mK = 0.0000861740 meV; w_mK = w / 0.0000861740; return w_mK. def convert_mK_to_meV(w):; """"""; Convert an energy from unit mK to unit meV. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # 1 mK = 0.0000861740 meV; w_meV = w * 0.0000861740; return w_meV. def convert_GHz_to_mK(w):; """"""; Convert an energy from unit GHz to unit mK. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # h v [Hz] = kB T [K]; # h 1e9 v [GHz] = kB 1e-3 T [mK]; # T [mK] = 1e12 * (h/kB) * v [GHz]; w_mK = w * 1.0e12 * (_h / _kB); return w_mK. def convert_mK_to_GHz(w):; """"""; Convert an energy from unit mK to unit GHz. Parameters",MatchSource.WIKI,docs/4.2/modules/qutip/utilities.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/utilities.html
https://qutip.org/docs/4.2/modules/qutip/utilities.html:7290,Energy Efficiency,energy,energy,7290," * 4.1357e-3; return w_meV. def convert_meV_to_GHz(w):; """"""; Convert an energy from unit meV to unit GHz. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # 1 meV = 1.0/4.1357e-3 GHz; w_GHz = w / 4.1357e-3; return w_GHz. def convert_J_to_meV(w):; """"""; Convert an energy from unit J to unit meV. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # 1 eV = 1.602e-19 J; w_meV = 1000.0 * w / _e; return w_meV. def convert_meV_to_J(w):; """"""; Convert an energy from unit meV to unit J. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # 1 eV = 1.602e-19 J; w_J = 0.001 * w * _e; return w_J. def convert_meV_to_mK(w):; """"""; Convert an energy from unit meV to unit mK. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # 1 mK = 0.0000861740 meV; w_mK = w / 0.0000861740; return w_mK. def convert_mK_to_meV(w):; """"""; Convert an energy from unit mK to unit meV. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # 1 mK = 0.0000861740 meV; w_meV = w * 0.0000861740; return w_meV. def convert_GHz_to_mK(w):; """"""; Convert an energy from unit GHz to unit mK. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # h v [Hz] = kB T [K]; # h 1e9 v [GHz] = kB 1e-3 T [mK]; # T [mK] = 1e12 * (h/kB) * v [GHz]; w_mK = w * 1.0e12 * (_h / _kB); return w_mK. def convert_mK_to_GHz(w):; """"""; Convert an energy from unit mK to unit GHz. Parameters; ----------; w : float / array; The energy in the old unit. Returns; ----",MatchSource.WIKI,docs/4.2/modules/qutip/utilities.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/utilities.html
https://qutip.org/docs/4.2/modules/qutip/utilities.html:7364,Energy Efficiency,energy,energy,7364,"nergy from unit meV to unit GHz. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # 1 meV = 1.0/4.1357e-3 GHz; w_GHz = w / 4.1357e-3; return w_GHz. def convert_J_to_meV(w):; """"""; Convert an energy from unit J to unit meV. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # 1 eV = 1.602e-19 J; w_meV = 1000.0 * w / _e; return w_meV. def convert_meV_to_J(w):; """"""; Convert an energy from unit meV to unit J. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # 1 eV = 1.602e-19 J; w_J = 0.001 * w * _e; return w_J. def convert_meV_to_mK(w):; """"""; Convert an energy from unit meV to unit mK. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # 1 mK = 0.0000861740 meV; w_mK = w / 0.0000861740; return w_mK. def convert_mK_to_meV(w):; """"""; Convert an energy from unit mK to unit meV. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # 1 mK = 0.0000861740 meV; w_meV = w * 0.0000861740; return w_meV. def convert_GHz_to_mK(w):; """"""; Convert an energy from unit GHz to unit mK. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # h v [Hz] = kB T [K]; # h 1e9 v [GHz] = kB 1e-3 T [mK]; # T [mK] = 1e12 * (h/kB) * v [GHz]; w_mK = w * 1.0e12 * (_h / _kB); return w_mK. def convert_mK_to_GHz(w):; """"""; Convert an energy from unit mK to unit GHz. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit. """"""; w_GHz ",MatchSource.WIKI,docs/4.2/modules/qutip/utilities.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/utilities.html
https://qutip.org/docs/4.2/modules/qutip/utilities.html:7502,Energy Efficiency,energy,energy,7502,"ay; The energy in the new unit.; """"""; # 1 meV = 1.0/4.1357e-3 GHz; w_GHz = w / 4.1357e-3; return w_GHz. def convert_J_to_meV(w):; """"""; Convert an energy from unit J to unit meV. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # 1 eV = 1.602e-19 J; w_meV = 1000.0 * w / _e; return w_meV. def convert_meV_to_J(w):; """"""; Convert an energy from unit meV to unit J. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # 1 eV = 1.602e-19 J; w_J = 0.001 * w * _e; return w_J. def convert_meV_to_mK(w):; """"""; Convert an energy from unit meV to unit mK. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # 1 mK = 0.0000861740 meV; w_mK = w / 0.0000861740; return w_mK. def convert_mK_to_meV(w):; """"""; Convert an energy from unit mK to unit meV. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # 1 mK = 0.0000861740 meV; w_meV = w * 0.0000861740; return w_meV. def convert_GHz_to_mK(w):; """"""; Convert an energy from unit GHz to unit mK. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # h v [Hz] = kB T [K]; # h 1e9 v [GHz] = kB 1e-3 T [mK]; # T [mK] = 1e12 * (h/kB) * v [GHz]; w_mK = w * 1.0e12 * (_h / _kB); return w_mK. def convert_mK_to_GHz(w):; """"""; Convert an energy from unit mK to unit GHz. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit. """"""; w_GHz = w * 1.0e-12 * (_kB / _h); return w_GHz. def view_methods(Q):; """"""; View the methods and corresponding doc strings; for a Qobj class. Parameters;",MatchSource.WIKI,docs/4.2/modules/qutip/utilities.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/utilities.html
https://qutip.org/docs/4.2/modules/qutip/utilities.html:7582,Energy Efficiency,energy,energy,7582,"= w / 4.1357e-3; return w_GHz. def convert_J_to_meV(w):; """"""; Convert an energy from unit J to unit meV. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # 1 eV = 1.602e-19 J; w_meV = 1000.0 * w / _e; return w_meV. def convert_meV_to_J(w):; """"""; Convert an energy from unit meV to unit J. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # 1 eV = 1.602e-19 J; w_J = 0.001 * w * _e; return w_J. def convert_meV_to_mK(w):; """"""; Convert an energy from unit meV to unit mK. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # 1 mK = 0.0000861740 meV; w_mK = w / 0.0000861740; return w_mK. def convert_mK_to_meV(w):; """"""; Convert an energy from unit mK to unit meV. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # 1 mK = 0.0000861740 meV; w_meV = w * 0.0000861740; return w_meV. def convert_GHz_to_mK(w):; """"""; Convert an energy from unit GHz to unit mK. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # h v [Hz] = kB T [K]; # h 1e9 v [GHz] = kB 1e-3 T [mK]; # T [mK] = 1e12 * (h/kB) * v [GHz]; w_mK = w * 1.0e12 * (_h / _kB); return w_mK. def convert_mK_to_GHz(w):; """"""; Convert an energy from unit mK to unit GHz. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit. """"""; w_GHz = w * 1.0e-12 * (_kB / _h); return w_GHz. def view_methods(Q):; """"""; View the methods and corresponding doc strings; for a Qobj class. Parameters; ----------; Q : Qobj; Input Quantum object. """"""; meth = dir(Q); qobj_prop",MatchSource.WIKI,docs/4.2/modules/qutip/utilities.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/utilities.html
https://qutip.org/docs/4.2/modules/qutip/utilities.html:7656,Energy Efficiency,energy,energy,7656,"energy from unit J to unit meV. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # 1 eV = 1.602e-19 J; w_meV = 1000.0 * w / _e; return w_meV. def convert_meV_to_J(w):; """"""; Convert an energy from unit meV to unit J. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # 1 eV = 1.602e-19 J; w_J = 0.001 * w * _e; return w_J. def convert_meV_to_mK(w):; """"""; Convert an energy from unit meV to unit mK. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # 1 mK = 0.0000861740 meV; w_mK = w / 0.0000861740; return w_mK. def convert_mK_to_meV(w):; """"""; Convert an energy from unit mK to unit meV. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # 1 mK = 0.0000861740 meV; w_meV = w * 0.0000861740; return w_meV. def convert_GHz_to_mK(w):; """"""; Convert an energy from unit GHz to unit mK. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # h v [Hz] = kB T [K]; # h 1e9 v [GHz] = kB 1e-3 T [mK]; # T [mK] = 1e12 * (h/kB) * v [GHz]; w_mK = w * 1.0e12 * (_h / _kB); return w_mK. def convert_mK_to_GHz(w):; """"""; Convert an energy from unit mK to unit GHz. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit. """"""; w_GHz = w * 1.0e-12 * (_kB / _h); return w_GHz. def view_methods(Q):; """"""; View the methods and corresponding doc strings; for a Qobj class. Parameters; ----------; Q : Qobj; Input Quantum object. """"""; meth = dir(Q); qobj_props = ['data', 'dims', 'isherm', 'shape', 'type']; pub_meth = [x for x in ",MatchSource.WIKI,docs/4.2/modules/qutip/utilities.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/utilities.html
https://qutip.org/docs/4.2/modules/qutip/utilities.html:7796,Energy Efficiency,energy,energy,7796," The energy in the new unit.; """"""; # 1 eV = 1.602e-19 J; w_meV = 1000.0 * w / _e; return w_meV. def convert_meV_to_J(w):; """"""; Convert an energy from unit meV to unit J. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # 1 eV = 1.602e-19 J; w_J = 0.001 * w * _e; return w_J. def convert_meV_to_mK(w):; """"""; Convert an energy from unit meV to unit mK. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # 1 mK = 0.0000861740 meV; w_mK = w / 0.0000861740; return w_mK. def convert_mK_to_meV(w):; """"""; Convert an energy from unit mK to unit meV. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # 1 mK = 0.0000861740 meV; w_meV = w * 0.0000861740; return w_meV. def convert_GHz_to_mK(w):; """"""; Convert an energy from unit GHz to unit mK. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # h v [Hz] = kB T [K]; # h 1e9 v [GHz] = kB 1e-3 T [mK]; # T [mK] = 1e12 * (h/kB) * v [GHz]; w_mK = w * 1.0e12 * (_h / _kB); return w_mK. def convert_mK_to_GHz(w):; """"""; Convert an energy from unit mK to unit GHz. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit. """"""; w_GHz = w * 1.0e-12 * (_kB / _h); return w_GHz. def view_methods(Q):; """"""; View the methods and corresponding doc strings; for a Qobj class. Parameters; ----------; Q : Qobj; Input Quantum object. """"""; meth = dir(Q); qobj_props = ['data', 'dims', 'isherm', 'shape', 'type']; pub_meth = [x for x in meth if x.find('_') and x not in qobj_props]; ml = max([len(x) for x in pub_meth]); nl = len(Q.__class__.__name__ + 'Class Methods:'); print(Q.__cla",MatchSource.WIKI,docs/4.2/modules/qutip/utilities.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/utilities.html
https://qutip.org/docs/4.2/modules/qutip/utilities.html:7876,Energy Efficiency,energy,energy,7876," w / _e; return w_meV. def convert_meV_to_J(w):; """"""; Convert an energy from unit meV to unit J. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # 1 eV = 1.602e-19 J; w_J = 0.001 * w * _e; return w_J. def convert_meV_to_mK(w):; """"""; Convert an energy from unit meV to unit mK. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # 1 mK = 0.0000861740 meV; w_mK = w / 0.0000861740; return w_mK. def convert_mK_to_meV(w):; """"""; Convert an energy from unit mK to unit meV. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # 1 mK = 0.0000861740 meV; w_meV = w * 0.0000861740; return w_meV. def convert_GHz_to_mK(w):; """"""; Convert an energy from unit GHz to unit mK. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # h v [Hz] = kB T [K]; # h 1e9 v [GHz] = kB 1e-3 T [mK]; # T [mK] = 1e12 * (h/kB) * v [GHz]; w_mK = w * 1.0e12 * (_h / _kB); return w_mK. def convert_mK_to_GHz(w):; """"""; Convert an energy from unit mK to unit GHz. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit. """"""; w_GHz = w * 1.0e-12 * (_kB / _h); return w_GHz. def view_methods(Q):; """"""; View the methods and corresponding doc strings; for a Qobj class. Parameters; ----------; Q : Qobj; Input Quantum object. """"""; meth = dir(Q); qobj_props = ['data', 'dims', 'isherm', 'shape', 'type']; pub_meth = [x for x in meth if x.find('_') and x not in qobj_props]; ml = max([len(x) for x in pub_meth]); nl = len(Q.__class__.__name__ + 'Class Methods:'); print(Q.__class__.__name__ + ' Class Methods:'); print('-' * nl); for ii in range(len(p",MatchSource.WIKI,docs/4.2/modules/qutip/utilities.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/utilities.html
https://qutip.org/docs/4.2/modules/qutip/utilities.html:7950,Energy Efficiency,energy,energy,7950,"rom unit meV to unit J. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # 1 eV = 1.602e-19 J; w_J = 0.001 * w * _e; return w_J. def convert_meV_to_mK(w):; """"""; Convert an energy from unit meV to unit mK. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # 1 mK = 0.0000861740 meV; w_mK = w / 0.0000861740; return w_mK. def convert_mK_to_meV(w):; """"""; Convert an energy from unit mK to unit meV. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # 1 mK = 0.0000861740 meV; w_meV = w * 0.0000861740; return w_meV. def convert_GHz_to_mK(w):; """"""; Convert an energy from unit GHz to unit mK. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # h v [Hz] = kB T [K]; # h 1e9 v [GHz] = kB 1e-3 T [mK]; # T [mK] = 1e12 * (h/kB) * v [GHz]; w_mK = w * 1.0e12 * (_h / _kB); return w_mK. def convert_mK_to_GHz(w):; """"""; Convert an energy from unit mK to unit GHz. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit. """"""; w_GHz = w * 1.0e-12 * (_kB / _h); return w_GHz. def view_methods(Q):; """"""; View the methods and corresponding doc strings; for a Qobj class. Parameters; ----------; Q : Qobj; Input Quantum object. """"""; meth = dir(Q); qobj_props = ['data', 'dims', 'isherm', 'shape', 'type']; pub_meth = [x for x in meth if x.find('_') and x not in qobj_props]; ml = max([len(x) for x in pub_meth]); nl = len(Q.__class__.__name__ + 'Class Methods:'); print(Q.__class__.__name__ + ' Class Methods:'); print('-' * nl); for ii in range(len(pub_meth)):; m = getattr(Q, pub_meth[ii]); meth_str = m.__doc__; ind = me",MatchSource.WIKI,docs/4.2/modules/qutip/utilities.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/utilities.html
https://qutip.org/docs/4.2/modules/qutip/utilities.html:8161,Energy Efficiency,energy,energy,8161,"return w_J. def convert_meV_to_mK(w):; """"""; Convert an energy from unit meV to unit mK. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # 1 mK = 0.0000861740 meV; w_mK = w / 0.0000861740; return w_mK. def convert_mK_to_meV(w):; """"""; Convert an energy from unit mK to unit meV. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # 1 mK = 0.0000861740 meV; w_meV = w * 0.0000861740; return w_meV. def convert_GHz_to_mK(w):; """"""; Convert an energy from unit GHz to unit mK. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # h v [Hz] = kB T [K]; # h 1e9 v [GHz] = kB 1e-3 T [mK]; # T [mK] = 1e12 * (h/kB) * v [GHz]; w_mK = w * 1.0e12 * (_h / _kB); return w_mK. def convert_mK_to_GHz(w):; """"""; Convert an energy from unit mK to unit GHz. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit. """"""; w_GHz = w * 1.0e-12 * (_kB / _h); return w_GHz. def view_methods(Q):; """"""; View the methods and corresponding doc strings; for a Qobj class. Parameters; ----------; Q : Qobj; Input Quantum object. """"""; meth = dir(Q); qobj_props = ['data', 'dims', 'isherm', 'shape', 'type']; pub_meth = [x for x in meth if x.find('_') and x not in qobj_props]; ml = max([len(x) for x in pub_meth]); nl = len(Q.__class__.__name__ + 'Class Methods:'); print(Q.__class__.__name__ + ' Class Methods:'); print('-' * nl); for ii in range(len(pub_meth)):; m = getattr(Q, pub_meth[ii]); meth_str = m.__doc__; ind = meth_str.find('\n'); pub_len = len(pub_meth[ii] + ': '); print(pub_meth[ii] + ':' + ' ' * (ml+3-pub_len) + meth_str[:ind]). def _version2int(version_string):; str_list = version_string.split(; ""-dev"")[0].split(""rc"")[0].sp",MatchSource.WIKI,docs/4.2/modules/qutip/utilities.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/utilities.html
https://qutip.org/docs/4.2/modules/qutip/utilities.html:8241,Energy Efficiency,energy,energy,8241,"eV to unit mK. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # 1 mK = 0.0000861740 meV; w_mK = w / 0.0000861740; return w_mK. def convert_mK_to_meV(w):; """"""; Convert an energy from unit mK to unit meV. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # 1 mK = 0.0000861740 meV; w_meV = w * 0.0000861740; return w_meV. def convert_GHz_to_mK(w):; """"""; Convert an energy from unit GHz to unit mK. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # h v [Hz] = kB T [K]; # h 1e9 v [GHz] = kB 1e-3 T [mK]; # T [mK] = 1e12 * (h/kB) * v [GHz]; w_mK = w * 1.0e12 * (_h / _kB); return w_mK. def convert_mK_to_GHz(w):; """"""; Convert an energy from unit mK to unit GHz. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit. """"""; w_GHz = w * 1.0e-12 * (_kB / _h); return w_GHz. def view_methods(Q):; """"""; View the methods and corresponding doc strings; for a Qobj class. Parameters; ----------; Q : Qobj; Input Quantum object. """"""; meth = dir(Q); qobj_props = ['data', 'dims', 'isherm', 'shape', 'type']; pub_meth = [x for x in meth if x.find('_') and x not in qobj_props]; ml = max([len(x) for x in pub_meth]); nl = len(Q.__class__.__name__ + 'Class Methods:'); print(Q.__class__.__name__ + ' Class Methods:'); print('-' * nl); for ii in range(len(pub_meth)):; m = getattr(Q, pub_meth[ii]); meth_str = m.__doc__; ind = meth_str.find('\n'); pub_len = len(pub_meth[ii] + ': '); print(pub_meth[ii] + ':' + ' ' * (ml+3-pub_len) + meth_str[:ind]). def _version2int(version_string):; str_list = version_string.split(; ""-dev"")[0].split(""rc"")[0].split(""a"")[0].split(""b"")[0].split(; ""post"")[0].split('.'); return sum([int(d",MatchSource.WIKI,docs/4.2/modules/qutip/utilities.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/utilities.html
https://qutip.org/docs/4.2/modules/qutip/utilities.html:8315,Energy Efficiency,energy,energy,8315,"he old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # 1 mK = 0.0000861740 meV; w_mK = w / 0.0000861740; return w_mK. def convert_mK_to_meV(w):; """"""; Convert an energy from unit mK to unit meV. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # 1 mK = 0.0000861740 meV; w_meV = w * 0.0000861740; return w_meV. def convert_GHz_to_mK(w):; """"""; Convert an energy from unit GHz to unit mK. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # h v [Hz] = kB T [K]; # h 1e9 v [GHz] = kB 1e-3 T [mK]; # T [mK] = 1e12 * (h/kB) * v [GHz]; w_mK = w * 1.0e12 * (_h / _kB); return w_mK. def convert_mK_to_GHz(w):; """"""; Convert an energy from unit mK to unit GHz. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit. """"""; w_GHz = w * 1.0e-12 * (_kB / _h); return w_GHz. def view_methods(Q):; """"""; View the methods and corresponding doc strings; for a Qobj class. Parameters; ----------; Q : Qobj; Input Quantum object. """"""; meth = dir(Q); qobj_props = ['data', 'dims', 'isherm', 'shape', 'type']; pub_meth = [x for x in meth if x.find('_') and x not in qobj_props]; ml = max([len(x) for x in pub_meth]); nl = len(Q.__class__.__name__ + 'Class Methods:'); print(Q.__class__.__name__ + ' Class Methods:'); print('-' * nl); for ii in range(len(pub_meth)):; m = getattr(Q, pub_meth[ii]); meth_str = m.__doc__; ind = meth_str.find('\n'); pub_len = len(pub_meth[ii] + ': '); print(pub_meth[ii] + ':' + ' ' * (ml+3-pub_len) + meth_str[:ind]). def _version2int(version_string):; str_list = version_string.split(; ""-dev"")[0].split(""rc"")[0].split(""a"")[0].split(""b"")[0].split(; ""post"")[0].split('.'); return sum([int(d if len(d) > 0 else 0) * (100 ** (3 - n)); for n, d in enumerate(str_lis",MatchSource.WIKI,docs/4.2/modules/qutip/utilities.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/utilities.html
https://qutip.org/docs/4.2/modules/qutip/utilities.html:3882,Modifiability,coupling,coupling,3882,"n 1.0 / (np.exp(w / w_th) - 1.0). else:; if (w_th > 0) and np.exp(w / w_th) != 1.0:; return 1.0 / (np.exp(w / w_th) - 1.0); else:; return 0.0. [docs]def linspace_with(start, stop, num=50, elems=[]):; """"""; Return an array of numbers sampled over specified interval; with additional elements added. Returns `num` spaced array with elements from `elems` inserted; if not already included in set. Returned sample array is not evenly spaced if addtional elements; are added. Parameters; ----------; start : int; The starting value of the sequence.; stop : int; The stoping values of the sequence.; num : int, optional; Number of samples to generate.; elems : list/ndarray, optional; Requested elements to include in array. Returns; -------; samples : ndadrray; Original equally spaced sample array with additional; elements added.; """"""; elems = np.array(elems); lspace = np.linspace(start, stop, num); return np.union1d(lspace, elems). [docs]def clebsch(j1, j2, j3, m1, m2, m3):; """"""Calculates the Clebsch-Gordon coefficient; for coupling (j1,m1) and (j2,m2) to give (j3,m3). Parameters; ----------; j1 : float; Total angular momentum 1. j2 : float; Total angular momentum 2. j3 : float; Total angular momentum 3. m1 : float; z-component of angular momentum 1. m2 : float; z-component of angular momentum 2. m3 : float; z-component of angular momentum 3. Returns; -------; cg_coeff : float; Requested Clebsch-Gordan coefficient. """"""; from scipy.misc import factorial; ; if m3 != m1 + m2:; return 0; vmin = int(np.max([-j1 + j2 + m3, -j1 + m1, 0])); vmax = int(np.min([j2 + j3 + m1, j3 - j1 + j2, j3 + m3])). C = np.sqrt((2.0 * j3 + 1.0) * factorial(j3 + j1 - j2) *; factorial(j3 - j1 + j2) * factorial(j1 + j2 - j3) *; factorial(j3 + m3) * factorial(j3 - m3) /; (factorial(j1 + j2 + j3 + 1) *; factorial(j1 - m1) * factorial(j1 + m1) *; factorial(j2 - m2) * factorial(j2 + m2))); S = 0; for v in range(vmin, vmax + 1):; S += (-1.0) ** (v + j2 + m2) / factorial(v) * \; factorial(j2 + j3 + m1 - v) * factor",MatchSource.WIKI,docs/4.2/modules/qutip/utilities.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/utilities.html
https://qutip.org/docs/4.2/modules/qutip/utilities.html:9330,Modifiability,config,config,9330,"K = w * 1.0e12 * (_h / _kB); return w_mK. def convert_mK_to_GHz(w):; """"""; Convert an energy from unit mK to unit GHz. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit. """"""; w_GHz = w * 1.0e-12 * (_kB / _h); return w_GHz. def view_methods(Q):; """"""; View the methods and corresponding doc strings; for a Qobj class. Parameters; ----------; Q : Qobj; Input Quantum object. """"""; meth = dir(Q); qobj_props = ['data', 'dims', 'isherm', 'shape', 'type']; pub_meth = [x for x in meth if x.find('_') and x not in qobj_props]; ml = max([len(x) for x in pub_meth]); nl = len(Q.__class__.__name__ + 'Class Methods:'); print(Q.__class__.__name__ + ' Class Methods:'); print('-' * nl); for ii in range(len(pub_meth)):; m = getattr(Q, pub_meth[ii]); meth_str = m.__doc__; ind = meth_str.find('\n'); pub_len = len(pub_meth[ii] + ': '); print(pub_meth[ii] + ':' + ' ' * (ml+3-pub_len) + meth_str[:ind]). def _version2int(version_string):; str_list = version_string.split(; ""-dev"")[0].split(""rc"")[0].split(""a"")[0].split(""b"")[0].split(; ""post"")[0].split('.'); return sum([int(d if len(d) > 0 else 0) * (100 ** (3 - n)); for n, d in enumerate(str_list[:3])]). def _blas_info():; config = np.__config__; blas_info = config.blas_opt_info; _has_lib_key = 'libraries' in blas_info.keys(); blas = None; if hasattr(config,'mkl_info') or \; (_has_lib_key and any('mkl' in lib for lib in blas_info['libraries'])):; blas = 'INTEL MKL'; elif hasattr(config,'openblas_info') or \; (_has_lib_key and any('openblas' in lib for lib in blas_info['libraries'])):; blas = 'OPENBLAS'; elif 'extra_link_args' in blas_info.keys() and ('-Wl,Accelerate' in blas_info['extra_link_args']):; blas = 'Accelerate'; else:; blas = 'Generic'; return blas.  Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, and A.L. Grimsmo.; Last updated on Jan 17, 2018. . Built with Sphinx using a theme provided by Read the Docs. . ",MatchSource.WIKI,docs/4.2/modules/qutip/utilities.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/utilities.html
https://qutip.org/docs/4.2/modules/qutip/utilities.html:9366,Modifiability,config,config,9366,"K = w * 1.0e12 * (_h / _kB); return w_mK. def convert_mK_to_GHz(w):; """"""; Convert an energy from unit mK to unit GHz. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit. """"""; w_GHz = w * 1.0e-12 * (_kB / _h); return w_GHz. def view_methods(Q):; """"""; View the methods and corresponding doc strings; for a Qobj class. Parameters; ----------; Q : Qobj; Input Quantum object. """"""; meth = dir(Q); qobj_props = ['data', 'dims', 'isherm', 'shape', 'type']; pub_meth = [x for x in meth if x.find('_') and x not in qobj_props]; ml = max([len(x) for x in pub_meth]); nl = len(Q.__class__.__name__ + 'Class Methods:'); print(Q.__class__.__name__ + ' Class Methods:'); print('-' * nl); for ii in range(len(pub_meth)):; m = getattr(Q, pub_meth[ii]); meth_str = m.__doc__; ind = meth_str.find('\n'); pub_len = len(pub_meth[ii] + ': '); print(pub_meth[ii] + ':' + ' ' * (ml+3-pub_len) + meth_str[:ind]). def _version2int(version_string):; str_list = version_string.split(; ""-dev"")[0].split(""rc"")[0].split(""a"")[0].split(""b"")[0].split(; ""post"")[0].split('.'); return sum([int(d if len(d) > 0 else 0) * (100 ** (3 - n)); for n, d in enumerate(str_list[:3])]). def _blas_info():; config = np.__config__; blas_info = config.blas_opt_info; _has_lib_key = 'libraries' in blas_info.keys(); blas = None; if hasattr(config,'mkl_info') or \; (_has_lib_key and any('mkl' in lib for lib in blas_info['libraries'])):; blas = 'INTEL MKL'; elif hasattr(config,'openblas_info') or \; (_has_lib_key and any('openblas' in lib for lib in blas_info['libraries'])):; blas = 'OPENBLAS'; elif 'extra_link_args' in blas_info.keys() and ('-Wl,Accelerate' in blas_info['extra_link_args']):; blas = 'Accelerate'; else:; blas = 'Generic'; return blas.  Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, and A.L. Grimsmo.; Last updated on Jan 17, 2018. . Built with Sphinx using a theme provided by Read the Docs. . ",MatchSource.WIKI,docs/4.2/modules/qutip/utilities.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/utilities.html
https://qutip.org/docs/4.2/modules/qutip/utilities.html:9460,Modifiability,config,config,9460,"K = w * 1.0e12 * (_h / _kB); return w_mK. def convert_mK_to_GHz(w):; """"""; Convert an energy from unit mK to unit GHz. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit. """"""; w_GHz = w * 1.0e-12 * (_kB / _h); return w_GHz. def view_methods(Q):; """"""; View the methods and corresponding doc strings; for a Qobj class. Parameters; ----------; Q : Qobj; Input Quantum object. """"""; meth = dir(Q); qobj_props = ['data', 'dims', 'isherm', 'shape', 'type']; pub_meth = [x for x in meth if x.find('_') and x not in qobj_props]; ml = max([len(x) for x in pub_meth]); nl = len(Q.__class__.__name__ + 'Class Methods:'); print(Q.__class__.__name__ + ' Class Methods:'); print('-' * nl); for ii in range(len(pub_meth)):; m = getattr(Q, pub_meth[ii]); meth_str = m.__doc__; ind = meth_str.find('\n'); pub_len = len(pub_meth[ii] + ': '); print(pub_meth[ii] + ':' + ' ' * (ml+3-pub_len) + meth_str[:ind]). def _version2int(version_string):; str_list = version_string.split(; ""-dev"")[0].split(""rc"")[0].split(""a"")[0].split(""b"")[0].split(; ""post"")[0].split('.'); return sum([int(d if len(d) > 0 else 0) * (100 ** (3 - n)); for n, d in enumerate(str_list[:3])]). def _blas_info():; config = np.__config__; blas_info = config.blas_opt_info; _has_lib_key = 'libraries' in blas_info.keys(); blas = None; if hasattr(config,'mkl_info') or \; (_has_lib_key and any('mkl' in lib for lib in blas_info['libraries'])):; blas = 'INTEL MKL'; elif hasattr(config,'openblas_info') or \; (_has_lib_key and any('openblas' in lib for lib in blas_info['libraries'])):; blas = 'OPENBLAS'; elif 'extra_link_args' in blas_info.keys() and ('-Wl,Accelerate' in blas_info['extra_link_args']):; blas = 'Accelerate'; else:; blas = 'Generic'; return blas.  Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, and A.L. Grimsmo.; Last updated on Jan 17, 2018. . Built with Sphinx using a theme provided by Read the Docs. . ",MatchSource.WIKI,docs/4.2/modules/qutip/utilities.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/utilities.html
https://qutip.org/docs/4.2/modules/qutip/utilities.html:9591,Modifiability,config,config,9591,"K = w * 1.0e12 * (_h / _kB); return w_mK. def convert_mK_to_GHz(w):; """"""; Convert an energy from unit mK to unit GHz. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit. """"""; w_GHz = w * 1.0e-12 * (_kB / _h); return w_GHz. def view_methods(Q):; """"""; View the methods and corresponding doc strings; for a Qobj class. Parameters; ----------; Q : Qobj; Input Quantum object. """"""; meth = dir(Q); qobj_props = ['data', 'dims', 'isherm', 'shape', 'type']; pub_meth = [x for x in meth if x.find('_') and x not in qobj_props]; ml = max([len(x) for x in pub_meth]); nl = len(Q.__class__.__name__ + 'Class Methods:'); print(Q.__class__.__name__ + ' Class Methods:'); print('-' * nl); for ii in range(len(pub_meth)):; m = getattr(Q, pub_meth[ii]); meth_str = m.__doc__; ind = meth_str.find('\n'); pub_len = len(pub_meth[ii] + ': '); print(pub_meth[ii] + ':' + ' ' * (ml+3-pub_len) + meth_str[:ind]). def _version2int(version_string):; str_list = version_string.split(; ""-dev"")[0].split(""rc"")[0].split(""a"")[0].split(""b"")[0].split(; ""post"")[0].split('.'); return sum([int(d if len(d) > 0 else 0) * (100 ** (3 - n)); for n, d in enumerate(str_list[:3])]). def _blas_info():; config = np.__config__; blas_info = config.blas_opt_info; _has_lib_key = 'libraries' in blas_info.keys(); blas = None; if hasattr(config,'mkl_info') or \; (_has_lib_key and any('mkl' in lib for lib in blas_info['libraries'])):; blas = 'INTEL MKL'; elif hasattr(config,'openblas_info') or \; (_has_lib_key and any('openblas' in lib for lib in blas_info['libraries'])):; blas = 'OPENBLAS'; elif 'extra_link_args' in blas_info.keys() and ('-Wl,Accelerate' in blas_info['extra_link_args']):; blas = 'Accelerate'; else:; blas = 'Generic'; return blas.  Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, and A.L. Grimsmo.; Last updated on Jan 17, 2018. . Built with Sphinx using a theme provided by Read the Docs. . ",MatchSource.WIKI,docs/4.2/modules/qutip/utilities.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/utilities.html
https://qutip.org/docs/4.2/modules/qutip/visualization.html:39048,Deployability,update,updated,39048," a matplotlib axis instance; The axis context in which the plot will be drawn. figsize : (width, height); The size of the matplotlib figure (in inches) if it is to be created; (that is, if no 'fig' and 'ax' arguments are passed). Returns; -------; fig, ax : tuple; A tuple of the matplotlib figure and axes instances used to produce; the figure. """"""; if not isket(ket):; raise Exception(""Schmidt plot works only for pure states, i.e. kets.""). if not fig and not ax:; fig, ax = plt.subplots(1, 1, figsize=figsize). dim_list = ket.dims[0]. if splitting is None:; splitting = (len(dim_list) + 1) // 2. if isinstance(labels_iteration, int):; labels_iteration = labels_iteration, labels_iteration. ketdata = ket.full(). dim_list_y = dim_list[:splitting]; dim_list_x = dim_list[splitting:]. size_x = np.prod(dim_list_x); size_y = np.prod(dim_list_y). ketdata = ketdata.reshape((size_y, size_x)). dim_list_small_x = dim_list_x[:labels_iteration[1]]; dim_list_small_y = dim_list_y[:labels_iteration[0]]. quadrants_x = np.prod(dim_list_small_x); quadrants_y = np.prod(dim_list_small_y). ticks_x = [size_x / quadrants_x * (i + 0.5); for i in range(quadrants_x)]; ticks_y = [size_y / quadrants_y * (quadrants_y - i - 0.5); for i in range(quadrants_y)]. labels_x = [_sequence_to_latex(_index_to_sequence(i*size_x // quadrants_x,; dim_list=dim_list_x)); for i in range(quadrants_x)]; labels_y = [_sequence_to_latex(_index_to_sequence(i*size_y // quadrants_y,; dim_list=dim_list_y)); for i in range(quadrants_y)]. ax.set_xticks(ticks_x); ax.set_xticklabels(labels_x); ax.set_yticks(ticks_y); ax.set_yticklabels(labels_y); ax.set_xlabel(""last particles""); ax.set_ylabel(""first particles""). ax.imshow(complex_array_to_rgb(ketdata, theme=theme),; interpolation=""none"",; extent=(0, size_x, 0, size_y)). return fig, ax.  Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, and A.L. Grimsmo.; Last updated on Jan 17, 2018. . Built with Sphinx using a theme provided by Read the Docs. . ",MatchSource.WIKI,docs/4.2/modules/qutip/visualization.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/visualization.html
https://qutip.org/docs/4.2/modules/qutip/visualization.html:14341,Energy Efficiency,energy,energy,14341,"None:; fig = plt.figure(); ax = Axes3D(fig, azim=-35, elev=35). ax.bar3d(xpos, ypos, zpos, dx, dy, dz, color=colors). if title and fig:; ax.set_title(title). # x axis; ax.axes.w_xaxis.set_major_locator(plt.IndexLocator(1, -0.5)); if xlabels:; ax.set_xticklabels(xlabels); ax.tick_params(axis='x', labelsize=12). # y axis; ax.axes.w_yaxis.set_major_locator(plt.IndexLocator(1, -0.5)); if ylabels:; ax.set_yticklabels(ylabels); ax.tick_params(axis='y', labelsize=12). # z axis; if limits and isinstance(limits, list):; ax.set_zlim3d(limits); else:; ax.set_zlim3d([0, 1]) # use min/max; # ax.set_zlabel('abs'). # color axis; if colorbar:; cax, kw = mpl.colorbar.make_axes(ax, shrink=.75, pad=.0); cb = mpl.colorbar.ColorbarBase(cax, cmap=cmap, norm=norm); cb.set_ticks([-pi, -pi / 2, 0, pi / 2, pi]); cb.set_ticklabels(; (r'$-\pi$', r'$-\pi/2$', r'$0$', r'$\pi/2$', r'$\pi$')); cb.set_label('arg'). return fig, ax. [docs]def plot_energy_levels(H_list, N=0, labels=None, show_ylabels=False,; figsize=(8, 12), fig=None, ax=None):; """"""; Plot the energy level diagrams for a list of Hamiltonians. Include; up to N energy levels. For each element in H_list, the energy; levels diagram for the cummulative Hamiltonian sum(H_list[0:n]) is plotted,; where n is the index of an element in H_list. Parameters; ----------. H_list : List of Qobj; A list of Hamiltonians. labels : List of string; A list of labels for each Hamiltonian. show_ylabels : Bool (default False); Show y labels to the left of energy levels of the initial; Hamiltonian. N : int; The number of energy levels to plot. figsize : tuple (int,int); The size of the figure (width, height). fig : a matplotlib Figure instance; The Figure canvas in which the plot will be drawn. ax : a matplotlib axes instance; The axes context in which the plot will be drawn. Returns; -------; fig, ax : tuple; A tuple of the matplotlib figure and axes instances used to produce; the figure. Raises; ------. ValueError; Input argument is not valid. """""". if not isi",MatchSource.WIKI,docs/4.2/modules/qutip/visualization.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/visualization.html
https://qutip.org/docs/4.2/modules/qutip/visualization.html:14408,Energy Efficiency,energy,energy,14408,"lor=colors). if title and fig:; ax.set_title(title). # x axis; ax.axes.w_xaxis.set_major_locator(plt.IndexLocator(1, -0.5)); if xlabels:; ax.set_xticklabels(xlabels); ax.tick_params(axis='x', labelsize=12). # y axis; ax.axes.w_yaxis.set_major_locator(plt.IndexLocator(1, -0.5)); if ylabels:; ax.set_yticklabels(ylabels); ax.tick_params(axis='y', labelsize=12). # z axis; if limits and isinstance(limits, list):; ax.set_zlim3d(limits); else:; ax.set_zlim3d([0, 1]) # use min/max; # ax.set_zlabel('abs'). # color axis; if colorbar:; cax, kw = mpl.colorbar.make_axes(ax, shrink=.75, pad=.0); cb = mpl.colorbar.ColorbarBase(cax, cmap=cmap, norm=norm); cb.set_ticks([-pi, -pi / 2, 0, pi / 2, pi]); cb.set_ticklabels(; (r'$-\pi$', r'$-\pi/2$', r'$0$', r'$\pi/2$', r'$\pi$')); cb.set_label('arg'). return fig, ax. [docs]def plot_energy_levels(H_list, N=0, labels=None, show_ylabels=False,; figsize=(8, 12), fig=None, ax=None):; """"""; Plot the energy level diagrams for a list of Hamiltonians. Include; up to N energy levels. For each element in H_list, the energy; levels diagram for the cummulative Hamiltonian sum(H_list[0:n]) is plotted,; where n is the index of an element in H_list. Parameters; ----------. H_list : List of Qobj; A list of Hamiltonians. labels : List of string; A list of labels for each Hamiltonian. show_ylabels : Bool (default False); Show y labels to the left of energy levels of the initial; Hamiltonian. N : int; The number of energy levels to plot. figsize : tuple (int,int); The size of the figure (width, height). fig : a matplotlib Figure instance; The Figure canvas in which the plot will be drawn. ax : a matplotlib axes instance; The axes context in which the plot will be drawn. Returns; -------; fig, ax : tuple; A tuple of the matplotlib figure and axes instances used to produce; the figure. Raises; ------. ValueError; Input argument is not valid. """""". if not isinstance(H_list, list):; raise ValueError(""H_list must be a list of Qobj instances""). if not fig and not a",MatchSource.WIKI,docs/4.2/modules/qutip/visualization.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/visualization.html
https://qutip.org/docs/4.2/modules/qutip/visualization.html:14455,Energy Efficiency,energy,energy,14455,"plt.IndexLocator(1, -0.5)); if xlabels:; ax.set_xticklabels(xlabels); ax.tick_params(axis='x', labelsize=12). # y axis; ax.axes.w_yaxis.set_major_locator(plt.IndexLocator(1, -0.5)); if ylabels:; ax.set_yticklabels(ylabels); ax.tick_params(axis='y', labelsize=12). # z axis; if limits and isinstance(limits, list):; ax.set_zlim3d(limits); else:; ax.set_zlim3d([0, 1]) # use min/max; # ax.set_zlabel('abs'). # color axis; if colorbar:; cax, kw = mpl.colorbar.make_axes(ax, shrink=.75, pad=.0); cb = mpl.colorbar.ColorbarBase(cax, cmap=cmap, norm=norm); cb.set_ticks([-pi, -pi / 2, 0, pi / 2, pi]); cb.set_ticklabels(; (r'$-\pi$', r'$-\pi/2$', r'$0$', r'$\pi/2$', r'$\pi$')); cb.set_label('arg'). return fig, ax. [docs]def plot_energy_levels(H_list, N=0, labels=None, show_ylabels=False,; figsize=(8, 12), fig=None, ax=None):; """"""; Plot the energy level diagrams for a list of Hamiltonians. Include; up to N energy levels. For each element in H_list, the energy; levels diagram for the cummulative Hamiltonian sum(H_list[0:n]) is plotted,; where n is the index of an element in H_list. Parameters; ----------. H_list : List of Qobj; A list of Hamiltonians. labels : List of string; A list of labels for each Hamiltonian. show_ylabels : Bool (default False); Show y labels to the left of energy levels of the initial; Hamiltonian. N : int; The number of energy levels to plot. figsize : tuple (int,int); The size of the figure (width, height). fig : a matplotlib Figure instance; The Figure canvas in which the plot will be drawn. ax : a matplotlib axes instance; The axes context in which the plot will be drawn. Returns; -------; fig, ax : tuple; A tuple of the matplotlib figure and axes instances used to produce; the figure. Raises; ------. ValueError; Input argument is not valid. """""". if not isinstance(H_list, list):; raise ValueError(""H_list must be a list of Qobj instances""). if not fig and not ax:; fig, ax = plt.subplots(1, 1, figsize=figsize). H = H_list[0]; N = H.shape[0] if N == 0 else mi",MatchSource.WIKI,docs/4.2/modules/qutip/visualization.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/visualization.html
https://qutip.org/docs/4.2/modules/qutip/visualization.html:14787,Energy Efficiency,energy,energy,14787,"s; if limits and isinstance(limits, list):; ax.set_zlim3d(limits); else:; ax.set_zlim3d([0, 1]) # use min/max; # ax.set_zlabel('abs'). # color axis; if colorbar:; cax, kw = mpl.colorbar.make_axes(ax, shrink=.75, pad=.0); cb = mpl.colorbar.ColorbarBase(cax, cmap=cmap, norm=norm); cb.set_ticks([-pi, -pi / 2, 0, pi / 2, pi]); cb.set_ticklabels(; (r'$-\pi$', r'$-\pi/2$', r'$0$', r'$\pi/2$', r'$\pi$')); cb.set_label('arg'). return fig, ax. [docs]def plot_energy_levels(H_list, N=0, labels=None, show_ylabels=False,; figsize=(8, 12), fig=None, ax=None):; """"""; Plot the energy level diagrams for a list of Hamiltonians. Include; up to N energy levels. For each element in H_list, the energy; levels diagram for the cummulative Hamiltonian sum(H_list[0:n]) is plotted,; where n is the index of an element in H_list. Parameters; ----------. H_list : List of Qobj; A list of Hamiltonians. labels : List of string; A list of labels for each Hamiltonian. show_ylabels : Bool (default False); Show y labels to the left of energy levels of the initial; Hamiltonian. N : int; The number of energy levels to plot. figsize : tuple (int,int); The size of the figure (width, height). fig : a matplotlib Figure instance; The Figure canvas in which the plot will be drawn. ax : a matplotlib axes instance; The axes context in which the plot will be drawn. Returns; -------; fig, ax : tuple; A tuple of the matplotlib figure and axes instances used to produce; the figure. Raises; ------. ValueError; Input argument is not valid. """""". if not isinstance(H_list, list):; raise ValueError(""H_list must be a list of Qobj instances""). if not fig and not ax:; fig, ax = plt.subplots(1, 1, figsize=figsize). H = H_list[0]; N = H.shape[0] if N == 0 else min(H.shape[0], N). xticks = []; yticks = []. x = 0; evals0 = H.eigenenergies(eigvals=N) / (2 * np.pi); for e_idx, e in enumerate(evals0[:N]):; ax.plot([x, x + 2], np.array([1, 1]) * e, 'b', linewidth=2); yticks.append(e); xticks.append(x + 1); x += 2. for H1 in H_list[1:]",MatchSource.WIKI,docs/4.2/modules/qutip/visualization.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/visualization.html
https://qutip.org/docs/4.2/modules/qutip/visualization.html:14853,Energy Efficiency,energy,energy,14853,"et_zlim3d([0, 1]) # use min/max; # ax.set_zlabel('abs'). # color axis; if colorbar:; cax, kw = mpl.colorbar.make_axes(ax, shrink=.75, pad=.0); cb = mpl.colorbar.ColorbarBase(cax, cmap=cmap, norm=norm); cb.set_ticks([-pi, -pi / 2, 0, pi / 2, pi]); cb.set_ticklabels(; (r'$-\pi$', r'$-\pi/2$', r'$0$', r'$\pi/2$', r'$\pi$')); cb.set_label('arg'). return fig, ax. [docs]def plot_energy_levels(H_list, N=0, labels=None, show_ylabels=False,; figsize=(8, 12), fig=None, ax=None):; """"""; Plot the energy level diagrams for a list of Hamiltonians. Include; up to N energy levels. For each element in H_list, the energy; levels diagram for the cummulative Hamiltonian sum(H_list[0:n]) is plotted,; where n is the index of an element in H_list. Parameters; ----------. H_list : List of Qobj; A list of Hamiltonians. labels : List of string; A list of labels for each Hamiltonian. show_ylabels : Bool (default False); Show y labels to the left of energy levels of the initial; Hamiltonian. N : int; The number of energy levels to plot. figsize : tuple (int,int); The size of the figure (width, height). fig : a matplotlib Figure instance; The Figure canvas in which the plot will be drawn. ax : a matplotlib axes instance; The axes context in which the plot will be drawn. Returns; -------; fig, ax : tuple; A tuple of the matplotlib figure and axes instances used to produce; the figure. Raises; ------. ValueError; Input argument is not valid. """""". if not isinstance(H_list, list):; raise ValueError(""H_list must be a list of Qobj instances""). if not fig and not ax:; fig, ax = plt.subplots(1, 1, figsize=figsize). H = H_list[0]; N = H.shape[0] if N == 0 else min(H.shape[0], N). xticks = []; yticks = []. x = 0; evals0 = H.eigenenergies(eigvals=N) / (2 * np.pi); for e_idx, e in enumerate(evals0[:N]):; ax.plot([x, x + 2], np.array([1, 1]) * e, 'b', linewidth=2); yticks.append(e); xticks.append(x + 1); x += 2. for H1 in H_list[1:]:. H = H + H1; evals1 = H.eigenenergies() / (2 * np.pi). for e_idx, e in enum",MatchSource.WIKI,docs/4.2/modules/qutip/visualization.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/visualization.html
https://qutip.org/docs/4.2/modules/qutip/visualization.html:17703,Energy Efficiency,green,green,17703,"_fock_distribution(rho, offset=0, fig=None, ax=None,; figsize=(8, 6), title=None, unit_y_range=True):; """"""; Plot the Fock distribution for a density matrix (or ket) that describes; an oscillator mode. Parameters; ----------; rho : :class:`qutip.qobj.Qobj`; The density matrix (or ket) of the state to visualize. fig : a matplotlib Figure instance; The Figure canvas in which the plot will be drawn. ax : a matplotlib axes instance; The axes context in which the plot will be drawn. title : string; An optional title for the figure. figsize : (width, height); The size of the matplotlib figure (in inches) if it is to be created; (that is, if no 'fig' and 'ax' arguments are passed). Returns; -------; fig, ax : tuple; A tuple of the matplotlib figure and axes instances used to produce; the figure.; """""". if not fig and not ax:; fig, ax = plt.subplots(1, 1, figsize=figsize). if isket(rho):; rho = ket2dm(rho). N = rho.shape[0]. ax.bar(np.arange(offset, offset + N) - .4, np.real(rho.diag()),; color=""green"", alpha=0.6, width=0.8); if unit_y_range:; ax.set_ylim(0, 1). ax.set_xlim(-.5 + offset, N + offset); ax.set_xlabel('Fock number', fontsize=12); ax.set_ylabel('Occupation probability', fontsize=12). if title:; ax.set_title(title). return fig, ax. def fock_distribution(rho, offset=0, fig=None, ax=None,; figsize=(8, 6), title=None, unit_y_range=True):; warnings.warn(""Deprecated: Use plot_fock_distribution""); return plot_fock_distribution(rho, offset=offset, fig=fig, ax=ax,; figsize=figsize, title=title,; unit_y_range=unit_y_range). [docs]def plot_wigner(rho, fig=None, ax=None, figsize=(8, 4),; cmap=None, alpha_max=7.5, colorbar=False,; method='iterative', projection='2d'):; """"""; Plot the the Wigner function for a density matrix (or ket) that describes; an oscillator mode. Parameters; ----------; rho : :class:`qutip.qobj.Qobj`; The density matrix (or ket) of the state to visualize. fig : a matplotlib Figure instance; The Figure canvas in which the plot will be drawn. ax : a matplotli",MatchSource.WIKI,docs/4.2/modules/qutip/visualization.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/visualization.html
https://qutip.org/docs/4.2/modules/qutip/visualization.html:12878,Safety,avoid,avoid,12878,"gs; list of y labels. title : string; title of the plot (optional). limits : list/array with two float numbers; The z-axis limits [min, max] (optional). phase_limits : list/array with two float numbers; The phase-axis (colorbar) limits [min, max] (optional). ax : a matplotlib axes instance; The axes context in which the plot will be drawn. threshold: float (None); Threshold for when bars of smaller height should be transparent. If; not set, all bars are colored according to the color map. Returns; -------; fig, ax : tuple; A tuple of the matplotlib figure and axes instances used to produce; the figure. Raises; ------; ValueError; Input argument is not valid. """""". if isinstance(M, Qobj):; # extract matrix data from Qobj; M = M.full(). n = np.size(M); xpos, ypos = np.meshgrid(range(M.shape[0]), range(M.shape[1])); xpos = xpos.T.flatten() - 0.5; ypos = ypos.T.flatten() - 0.5; zpos = np.zeros(n); dx = dy = 0.8 * np.ones(n); Mvec = M.flatten(); dz = abs(Mvec). # make small numbers real, to avoid random colors; idx, = np.where(abs(Mvec) < 0.001); Mvec[idx] = abs(Mvec[idx]). if phase_limits: # check that limits is a list type; phase_min = phase_limits[0]; phase_max = phase_limits[1]; else:; phase_min = -pi; phase_max = pi. norm = mpl.colors.Normalize(phase_min, phase_max); cmap = complex_phase_cmap(). colors = cmap(norm(angle(Mvec))); if threshold is not None:; colors[:, 3] = 1 * (dz > threshold). if ax is None:; fig = plt.figure(); ax = Axes3D(fig, azim=-35, elev=35). ax.bar3d(xpos, ypos, zpos, dx, dy, dz, color=colors). if title and fig:; ax.set_title(title). # x axis; ax.axes.w_xaxis.set_major_locator(plt.IndexLocator(1, -0.5)); if xlabels:; ax.set_xticklabels(xlabels); ax.tick_params(axis='x', labelsize=12). # y axis; ax.axes.w_yaxis.set_major_locator(plt.IndexLocator(1, -0.5)); if ylabels:; ax.set_yticklabels(ylabels); ax.tick_params(axis='y', labelsize=12). # z axis; if limits and isinstance(limits, list):; ax.set_zlim3d(limits); else:; ax.set_zlim3d([0, 1]) # use mi",MatchSource.WIKI,docs/4.2/modules/qutip/visualization.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/visualization.html
https://qutip.org/docs/4.2/modules/qutip/visualization.html:31932,Security,access,access,31932,"e. style : 'ket' (default), 'bra' or 'bare'; Style of LaTeX (i.e. |01> or <01| or 01, respectively). Returns; -------; latex : str; LaTeX output. """"""; if style == 'ket':; latex = ""$\\left|{0}\\right\\rangle$""; elif style == 'bra':; latex = ""$\\left\\langle{0}\\right|$""; elif style == 'bare':; latex = ""${0}$""; else:; raise Exception(""No such style.""); return latex.format("""".join(map(str, seq))). [docs]def plot_qubism(ket, theme='light', how='pairs',; grid_iteration=1, legend_iteration=0,; fig=None, ax=None, figsize=(6, 6)):; """"""; Qubism plot for pure states of many qudits.; Works best for spin chains, especially with even number of particles; of the same dimension.; Allows to see entanglement between first 2*k particles and the rest. More information:; ; J. Rodriguez-Laguna, P. Migdal,; M. Ibanez Berganza, M. Lewenstein, G. Sierra,; ""Qubism: self-similar visualization of many-body wavefunctions"",; New J. Phys. 14 053028 (2012), arXiv:1112.3560,; http://dx.doi.org/10.1088/1367-2630/14/5/053028 (open access). Parameters; ----------; ket : Qobj; Pure state for plotting. theme : 'light' (default) or 'dark'; Set coloring theme for mapping complex values into colors.; See: complex_array_to_rgb. how : 'pairs' (default), 'pairs_skewed' or 'before_after'; Type of Qubism plotting.; Options:; ; 'pairs' - typical coordinates,; 'pairs_skewed' - for ferromagnetic/antriferromagnetic plots,; 'before_after' - related to Schmidt plot (see also: plot_schmidt). grid_iteration : int (default 1); Helper lines to be drawn on plot.; Show tiles for 2*grid_iteration particles vs all others. legend_iteration : int (default 0) or 'grid_iteration' or 'all'; Show labels for first 2*legend_iteration particles.; Option 'grid_iteration' sets the same number of particles; as for grid_iteration.; Option 'all' makes label for all particles.; Typically it should be 0, 1, 2 or perhaps 3. fig : a matplotlib figure instance; The figure canvas on which the plot will be drawn. ax : a matplotlib axis instance;",MatchSource.WIKI,docs/4.2/modules/qutip/visualization.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/visualization.html
https://qutip.org/docs/4.2/modules/qutip/wigner.html:16492,Deployability,update,updated,16492,"tion. Returns; -------; Q, THETA, PHI : 2d-array; Values representing the spin Q function at the values specified; by THETA and PHI. """""". if rho.type == 'bra':; rho = rho.dag(). if rho.type == 'ket':; rho = ket2dm(rho). J = rho.shape[0]; j = int((J - 1) / 2). THETA, PHI = meshgrid(theta, phi). Q = np.zeros_like(THETA, dtype=complex). for m1 in range(-j, j+1):. Q += binom(2*j, j+m1) * cos(THETA/2) ** (2*(j-m1)) * sin(THETA/2) ** (2*(j+m1)) * \; rho.data[int(j-m1), int(j-m1)]. for m2 in range(m1+1, j+1):. Q += (sqrt(binom(2*j, j+m1)) * sqrt(binom(2*j, j+m2)) *; cos(THETA/2) ** (2*j-m1-m2) * sin(THETA/2) ** (2*j+m1+m2)) * \; (exp(1j * (m2-m1) * PHI) * rho.data[int(j-m1), int(j-m2)] +; exp(1j * (m1-m2) * PHI) * rho.data[int(j-m2), int(j-m1)]). return Q.real, THETA, PHI. def _rho_kq(rho, j, k, q):; v = 0j. for m1 in range(-j, j+1):; for m2 in range(-j, j+1):; v += (-1)**(j - m1 - q) * clebsch(j, j, k, m1, -m2,; q) * rho.data[m1 + j, m2 + j]. return v. [docs]def spin_wigner(rho, theta, phi):; """"""Wigner function for spins on the Bloch sphere. Parameters; ----------; state : qobj; A state vector or density matrix for a spin-j quantum system.; theta : array_like; theta-coordinates at which to calculate the Q function.; phi : array_like; phi-coordinates at which to calculate the Q function. Returns; -------; W, THETA, PHI : 2d-array; Values representing the spin Wigner function at the values specified; by THETA and PHI. Notes; -----; Experimental. """""". if rho.type == 'bra':; rho = rho.dag(). if rho.type == 'ket':; rho = ket2dm(rho). J = rho.shape[0]; j = int((J - 1) / 2). THETA, PHI = meshgrid(theta, phi). W = np.zeros_like(THETA, dtype=complex). for k in range(int(2 * j)+1):; for q in range(-k, k+1):; W += _rho_kq(rho, j, k, q) * sph_harm(q, k, PHI, THETA). return W, THETA, PHI.  Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, and A.L. Grimsmo.; Last updated on Jan 17, 2018. . Built with Sphinx using a theme provided by Read the Docs. . ",MatchSource.WIKI,docs/4.2/modules/qutip/wigner.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/wigner.html
https://qutip.org/docs/4.2/modules/qutip/wigner.html:3708,Energy Efficiency,efficient,efficient,3708,"iag. [docs]def wigner(psi, xvec, yvec, method='clenshaw', g=sqrt(2), ; sparse=False, parfor=False):; """"""Wigner function for a state vector or density matrix at points; `xvec + i * yvec`. Parameters; ----------. state : qobj; A state vector or density matrix. xvec : array_like; x-coordinates at which to calculate the Wigner function. yvec : array_like; y-coordinates at which to calculate the Wigner function. Does not; apply to the 'fft' method. g : float; Scaling factor for `a = 0.5 * g * (x + iy)`, default `g = sqrt(2)`. method : string {'clenshaw', 'iterative', 'laguerre', 'fft'}; Select method 'clenshaw' 'iterative', 'laguerre', or 'fft', where 'clenshaw' ; and 'iterative' use an iterative method to evaluate the Wigner functions for density; matrices :math:`|m><n|`, while 'laguerre' uses the Laguerre polynomials; in scipy for the same task. The 'fft' method evaluates the Fourier; transform of the density matrix. The 'iterative' method is default, and; in general recommended, but the 'laguerre' method is more efficient for; very sparse density matrices (e.g., superpositions of Fock states in a; large Hilbert space). The 'clenshaw' method is the preferred method for; dealing with density matrices that have a large number of excitations; (>~50). 'clenshaw' is a fast and numerically stable method. sparse : bool {False, True}; Tells the default solver whether or not to keep the input density; matrix in sparse format. As the dimensions of the density matrix; grow, setthing this flag can result in increased performance.; ; parfor : bool {False, True}; Flag for calculating the Laguerre polynomial based Wigner function; method='laguerre' in parallel using the parfor function. Returns; -------. W : array; Values representing the Wigner function calculated over the specified; range [xvec,yvec]. yvex : array; FFT ONLY. Returns the y-coordinate values calculated via the Fourier; transform. Notes; -----; The 'fft' method accepts only an xvec input for the x-coordinate.; The y-c",MatchSource.WIKI,docs/4.2/modules/qutip/wigner.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/wigner.html
https://qutip.org/docs/4.2/modules/qutip/wigner.html:10813,Energy Efficiency,efficient,efficient,10813,"0]]),; np.fliplr(psi.conj()),; np.zeros((1, n//2 - 1))), axis=1); r2 = np.concatenate((np.array([[0]]), psi,; np.zeros((1, n//2 - 1))), axis=1); w = la.toeplitz(np.zeros((n//2, 1)), r1) * \; np.flipud(la.toeplitz(np.zeros((n//2, 1)), r2)); w = np.concatenate((w[:, n//2:n], w[:, 0:n//2]), axis=1); w = ft.fft(w); w = np.real(np.concatenate((w[:, 3*n//4:n+1], w[:, 0:n//4]), axis=1)); p = np.arange(-n/4, n/4)*np.pi / (n*(xvec[1] - xvec[0])); w = w / (p[1] - p[0]) / n; return w, p. def _osc_eigen(N, pnts):; """"""; Vector of and N-dim oscillator eigenfunctions evaluated; at the points in pnts.; """"""; pnts = np.asarray(pnts); lpnts = len(pnts); A = np.zeros((N, lpnts)); A[0, :] = np.exp(-pnts ** 2 / 2.0) / pi ** 0.25; if N == 1:; return A; else:; A[1, :] = np.sqrt(2) * pnts * A[0, :]; for k in range(2, N):; A[k, :] = np.sqrt(2.0 / k) * pnts * A[k - 1, :] - \; np.sqrt((k - 1.0) / k) * A[k - 2, :]; return A. def _wigner_clenshaw(rho, xvec, yvec, g=sqrt(2), sparse=False):; """"""; Using Clenshaw summation - numerically stable and efficient; iterative algorithm to evaluate polynomial series.; ; The Wigner function is calculated as; :math:`W = e^(-0.5*x^2)/pi * \sum_{L} c_L (2x)^L / sqrt(L!)` where ; :math:`c_L = \sum_n \\rho_{n,L+n} LL_n^L` where; :math:`LL_n^L = (-1)^n sqrt(L!n!/(L+n)!) LaguerreL[n,L,x]`; ; """""". M = np.prod(rho.shape[0]); X,Y = np.meshgrid(xvec, yvec); #A = 0.5 * g * (X + 1.0j * Y); A2 = g * (X + 1.0j * Y) #this is A2 = 2*A; ; B = np.abs(A2); B *= B; w0 = (2*rho.data[0,-1])*np.ones_like(A2); L = M-1; #calculation of \sum_{L} c_L (2x)^L / sqrt(L!); #using Horner's method; if not sparse:; rho = rho.full() * (2*np.ones((M,M)) - np.diag(np.ones(M))); while L > 0:; L -= 1; #here c_L = _wig_laguerre_val(L, B, np.diag(rho, L)); w0 = _wig_laguerre_val(L, B, np.diag(rho, L)) + w0 * A2 * (L+1)**-0.5; else:; while L > 0:; L -= 1; diag = _csr_get_diag(rho.data.data,rho.data.indices,; rho.data.indptr,L); if L != 0:; diag *= 2; #here c_L = _wig_laguerre_val(L, B, np.diag(rho, L)",MatchSource.WIKI,docs/4.2/modules/qutip/wigner.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/wigner.html
https://qutip.org/docs/4.2/modules/qutip/wigner.html:4210,Performance,perform,performance,4210," g * (x + iy)`, default `g = sqrt(2)`. method : string {'clenshaw', 'iterative', 'laguerre', 'fft'}; Select method 'clenshaw' 'iterative', 'laguerre', or 'fft', where 'clenshaw' ; and 'iterative' use an iterative method to evaluate the Wigner functions for density; matrices :math:`|m><n|`, while 'laguerre' uses the Laguerre polynomials; in scipy for the same task. The 'fft' method evaluates the Fourier; transform of the density matrix. The 'iterative' method is default, and; in general recommended, but the 'laguerre' method is more efficient for; very sparse density matrices (e.g., superpositions of Fock states in a; large Hilbert space). The 'clenshaw' method is the preferred method for; dealing with density matrices that have a large number of excitations; (>~50). 'clenshaw' is a fast and numerically stable method. sparse : bool {False, True}; Tells the default solver whether or not to keep the input density; matrix in sparse format. As the dimensions of the density matrix; grow, setthing this flag can result in increased performance.; ; parfor : bool {False, True}; Flag for calculating the Laguerre polynomial based Wigner function; method='laguerre' in parallel using the parfor function. Returns; -------. W : array; Values representing the Wigner function calculated over the specified; range [xvec,yvec]. yvex : array; FFT ONLY. Returns the y-coordinate values calculated via the Fourier; transform. Notes; -----; The 'fft' method accepts only an xvec input for the x-coordinate.; The y-coordinates are calculated internally. References; ----------. Ulf Leonhardt,; Measuring the Quantum State of Light, (Cambridge University Press, 1997). """""". if not (psi.type == 'ket' or psi.type == 'oper' or psi.type == 'bra'):; raise TypeError('Input state is not a valid operator.'). if method == 'fft':; return _wigner_fourier(psi, xvec, g). if psi.type == 'ket' or psi.type == 'bra':; rho = ket2dm(psi); else:; rho = psi. if method == 'iterative':; return _wigner_iterative(rho, xvec, ",MatchSource.WIKI,docs/4.2/modules/qutip/wigner.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/wigner.html
https://qutip.org/docs/4.2/modules/qutip/control/dump.html:6330,Availability,error,error,6330,"ummary and self.dump_all):; lvl = 'FULL'. return lvl. @level.setter; def level(self, value):; self._level = value; self._apply_level(). @property; def dump_any(self):; raise NotImplemented(""This is an abstract class, ""; ""use subclass such as DynamicsDump or OptimDump""). @property; def dump_all(self):; raise NotImplemented(""This is an abstract class, ""; ""use subclass such as DynamicsDump or OptimDump""). @property; def dump_dir(self):; if self._dump_dir is None:; self.create_dump_dir(); return self._dump_dir. @dump_dir.setter; def dump_dir(self, value):; self._dump_dir = value; if not self.create_dump_dir():; self._dump_dir = None. [docs] def create_dump_dir(self):; """"""; Checks dump directory exists, creates it if not; """"""; if self._dump_dir is None or len(self._dump_dir) == 0:; self._dump_dir = DUMP_DIR. dir_ok, self._dump_dir, msg = qtrlio.create_dir(; self._dump_dir, desc='dump'). if not dir_ok:; self.write_to_file = False; msg += ""\ndump file output will be suppressed.""; logger.error(msg). return dir_ok. @property; def fname_base(self):; return self._fname_base. @fname_base.setter; def fname_base(self, value):; if not _is_string(value):; raise ValueError(""File name base must be a string""); self._fname_base = value; self._summary_file_path = None. @property; def summary_file(self):; if self._summary_file_path is None:; fname = ""{}-summary.{}"".format(self._fname_base, self.dump_file_ext); self._summary_file_path = os.path.join(self.dump_dir, fname); return self._summary_file_path. @summary_file.setter; def summary_file(self, value):; if not _is_string(value):; raise ValueError(""File path must be a string""); self._summary_file_specified = True; if os.path.abspath(value):; self._summary_file_path = value; elif '~' in value:; self._summary_file_path = os.path.expanduser(value); else:; self._summary_file_path = os.path.join(self.dump_dir, value). [docs]class OptimDump(Dump):; """"""; A container for dumps of optimisation data generated during the pulse; optimisation. Attrib",MatchSource.WIKI,docs/4.2/modules/qutip/control/dump.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/dump.html
https://qutip.org/docs/4.2/modules/qutip/control/dump.html:7629,Availability,error,error,7629,"le(self):; if self._summary_file_path is None:; fname = ""{}-summary.{}"".format(self._fname_base, self.dump_file_ext); self._summary_file_path = os.path.join(self.dump_dir, fname); return self._summary_file_path. @summary_file.setter; def summary_file(self, value):; if not _is_string(value):; raise ValueError(""File path must be a string""); self._summary_file_specified = True; if os.path.abspath(value):; self._summary_file_path = value; elif '~' in value:; self._summary_file_path = os.path.expanduser(value); else:; self._summary_file_path = os.path.join(self.dump_dir, value). [docs]class OptimDump(Dump):; """"""; A container for dumps of optimisation data generated during the pulse; optimisation. Attributes; ----------; dump_summary : bool; When True summary items are appended to the iter_summary. iter_summary : list of :class:`optimizer.OptimIterSummary`; Summary at each iteration. dump_fid_err : bool; When True values are appended to the fid_err_log. fid_err_log : list of float; Fidelity error at each call of the fid_err_func. dump_grad_norm : bool; When True values are appended to the fid_err_log. grad_norm_log : list of float; Gradient norm at each call of the grad_norm_log. dump_grad : bool; When True values are appended to the grad_log. grad_log : list of ndarray; Gradients at each call of the fid_grad_func. """"""; def __init__(self, optim, level='SUMMARY'):; from qutip.control.optimizer import Optimizer; if not isinstance(optim, Optimizer):; raise TypeError(""Must instantiate with {} type"".format(; Optimizer)); self.parent = optim; self._level = level; self.reset(). def reset(self):; Dump.reset(self); self._apply_level(); self.iter_summary = []; self.fid_err_log = []; self.grad_norm_log = []; self.grad_log = []; self._fname_base = 'optimdump'; self._fid_err_file = None; self._grad_norm_file = None. def clear(self):; del self.iter_summary[:]; self.fid_err_log[:]; self.grad_norm_log[:]; self.grad_log[:]. @property; def dump_any(self):; """"""True if anything other than th",MatchSource.WIKI,docs/4.2/modules/qutip/control/dump.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/dump.html
