id,quality_attribute,keyword,matched_word,match_idx,sentence,source,filename,author,repo,version,wiki,url
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Testing/TestAST.h:151,Availability,failure,failures,151,"/// Constructing a TestAST parses the virtual file.; ///; /// To keep tests terse, critical errors (e.g. invalid flags) are reported as; /// unit test failures with ADD_FAILURE() and produce an empty ASTContext,; /// Sema etc. This frees the test code from handling these explicitly.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang/Testing/TestAST.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Testing/TestAST.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Testing/TestAST.h:19,Testability,Test,TestAST,19,"/// Constructing a TestAST parses the virtual file.; ///; /// To keep tests terse, critical errors (e.g. invalid flags) are reported as; /// unit test failures with ADD_FAILURE() and produce an empty ASTContext,; /// Sema etc. This frees the test code from handling these explicitly.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang/Testing/TestAST.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Testing/TestAST.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Testing/TestAST.h:70,Testability,test,tests,70,"/// Constructing a TestAST parses the virtual file.; ///; /// To keep tests terse, critical errors (e.g. invalid flags) are reported as; /// unit test failures with ADD_FAILURE() and produce an empty ASTContext,; /// Sema etc. This frees the test code from handling these explicitly.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang/Testing/TestAST.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Testing/TestAST.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Testing/TestAST.h:146,Testability,test,test,146,"/// Constructing a TestAST parses the virtual file.; ///; /// To keep tests terse, critical errors (e.g. invalid flags) are reported as; /// unit test failures with ADD_FAILURE() and produce an empty ASTContext,; /// Sema etc. This frees the test code from handling these explicitly.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang/Testing/TestAST.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Testing/TestAST.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Testing/TestAST.h:242,Testability,test,test,242,"/// Constructing a TestAST parses the virtual file.; ///; /// To keep tests terse, critical errors (e.g. invalid flags) are reported as; /// unit test failures with ADD_FAILURE() and produce an empty ASTContext,; /// Sema etc. This frees the test code from handling these explicitly.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang/Testing/TestAST.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Testing/TestAST.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Testing/TestAST.h:13,Security,access,access,13,/// Provides access to the AST context and other parts of Clang.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang/Testing/TestAST.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Testing/TestAST.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Testing/TestAST.h:66,Availability,error,errors,66,"/// Returns diagnostics emitted during parsing.; /// (By default, errors cause test failures, see TestInputs::ErrorOK).",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang/Testing/TestAST.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Testing/TestAST.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Testing/TestAST.h:84,Availability,failure,failures,84,"/// Returns diagnostics emitted during parsing.; /// (By default, errors cause test failures, see TestInputs::ErrorOK).",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang/Testing/TestAST.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Testing/TestAST.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Testing/TestAST.h:110,Availability,Error,ErrorOK,110,"/// Returns diagnostics emitted during parsing.; /// (By default, errors cause test failures, see TestInputs::ErrorOK).",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang/Testing/TestAST.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Testing/TestAST.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Testing/TestAST.h:79,Testability,test,test,79,"/// Returns diagnostics emitted during parsing.; /// (By default, errors cause test failures, see TestInputs::ErrorOK).",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang/Testing/TestAST.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Testing/TestAST.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Testing/TestAST.h:98,Testability,Test,TestInputs,98,"/// Returns diagnostics emitted during parsing.; /// (By default, errors cause test failures, see TestInputs::ErrorOK).",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang/Testing/TestAST.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Testing/TestAST.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Testing/TestClangConfig.h:9,Testability,Test,TestClangConfig,9,"//===--- TestClangConfig.h ------------------------------------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang/Testing/TestClangConfig.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Testing/TestClangConfig.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Testing/TestClangConfig.h:12,Deployability,configurat,configuration,12,"/// A Clang configuration for end-to-end tests that can be converted to; /// command line arguments for the driver.; ///; /// The configuration is represented as typed, named values, making it easier; /// and safer to work with compared to an array of string command line flags.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang/Testing/TestClangConfig.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Testing/TestClangConfig.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Testing/TestClangConfig.h:130,Deployability,configurat,configuration,130,"/// A Clang configuration for end-to-end tests that can be converted to; /// command line arguments for the driver.; ///; /// The configuration is represented as typed, named values, making it easier; /// and safer to work with compared to an array of string command line flags.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang/Testing/TestClangConfig.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Testing/TestClangConfig.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Testing/TestClangConfig.h:12,Modifiability,config,configuration,12,"/// A Clang configuration for end-to-end tests that can be converted to; /// command line arguments for the driver.; ///; /// The configuration is represented as typed, named values, making it easier; /// and safer to work with compared to an array of string command line flags.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang/Testing/TestClangConfig.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Testing/TestClangConfig.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Testing/TestClangConfig.h:130,Modifiability,config,configuration,130,"/// A Clang configuration for end-to-end tests that can be converted to; /// command line arguments for the driver.; ///; /// The configuration is represented as typed, named values, making it easier; /// and safer to work with compared to an array of string command line flags.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang/Testing/TestClangConfig.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Testing/TestClangConfig.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Testing/TestClangConfig.h:209,Safety,safe,safer,209,"/// A Clang configuration for end-to-end tests that can be converted to; /// command line arguments for the driver.; ///; /// The configuration is represented as typed, named values, making it easier; /// and safer to work with compared to an array of string command line flags.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang/Testing/TestClangConfig.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Testing/TestClangConfig.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Testing/TestClangConfig.h:41,Testability,test,tests,41,"/// A Clang configuration for end-to-end tests that can be converted to; /// command line arguments for the driver.; ///; /// The configuration is represented as typed, named values, making it easier; /// and safer to work with compared to an array of string command line flags.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang/Testing/TestClangConfig.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Testing/TestClangConfig.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/ArgumentsAdjusters.h:44,Integrability,depend,dependency-file,44,/// Gets an argument adjuster which removes dependency-file; /// related command line arguments.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang/Tooling/ArgumentsAdjusters.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/ArgumentsAdjusters.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/ArgumentsAdjusters.h:43,Modifiability,plugin,plugin,43,/// Gets an argument adjuster which strips plugin related command line; /// arguments.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang/Tooling/ArgumentsAdjusters.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/ArgumentsAdjusters.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/CommonOptionsParser.h:588,Integrability,interface,interface,588,"//===- CommonOptionsParser.h - common options for clang tools -*- C++ -*-=====//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements the CommonOptionsParser class used to parse common; // command-line options for clang tools, so that they can be run as separate; // command-line applications with a consistent common interface for handling; // compilation database and input files.; //; // It provides a common subset of command-line options, common algorithm; // for locating a compilation database and source files, and help messages; // for the basic command-line interface.; //; // It creates a CompilationDatabase and reads common command-line options.; //; // This class uses the Clang Tooling infrastructure, see; // http://clang.llvm.org/docs/HowToSetupToolingForLLVM.html; // for details on setting it up with LLVM source tree.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang/Tooling/CommonOptionsParser.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/CommonOptionsParser.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/CommonOptionsParser.h:798,Integrability,message,messages,798,"//===- CommonOptionsParser.h - common options for clang tools -*- C++ -*-=====//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements the CommonOptionsParser class used to parse common; // command-line options for clang tools, so that they can be run as separate; // command-line applications with a consistent common interface for handling; // compilation database and input files.; //; // It provides a common subset of command-line options, common algorithm; // for locating a compilation database and source files, and help messages; // for the basic command-line interface.; //; // It creates a CompilationDatabase and reads common command-line options.; //; // This class uses the Clang Tooling infrastructure, see; // http://clang.llvm.org/docs/HowToSetupToolingForLLVM.html; // for details on setting it up with LLVM source tree.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang/Tooling/CommonOptionsParser.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/CommonOptionsParser.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/CommonOptionsParser.h:838,Integrability,interface,interface,838,"//===- CommonOptionsParser.h - common options for clang tools -*- C++ -*-=====//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements the CommonOptionsParser class used to parse common; // command-line options for clang tools, so that they can be run as separate; // command-line applications with a consistent common interface for handling; // compilation database and input files.; //; // It provides a common subset of command-line options, common algorithm; // for locating a compilation database and source files, and help messages; // for the basic command-line interface.; //; // It creates a CompilationDatabase and reads common command-line options.; //; // This class uses the Clang Tooling infrastructure, see; // http://clang.llvm.org/docs/HowToSetupToolingForLLVM.html; // for details on setting it up with LLVM source tree.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang/Tooling/CommonOptionsParser.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/CommonOptionsParser.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/CommonOptionsParser.h:253,Integrability,message,message,253,"/// A parser for options common to all command-line Clang tools.; ///; /// Parses a common subset of command-line arguments, locates and loads a; /// compilation commands database and runs a tool with user-specified action. It; /// also contains a help message for the common command-line options.; ///; /// An example of usage:; /// \code; /// #include ""clang/Frontend/FrontendActions.h""; /// #include ""clang/Tooling/CommonOptionsParser.h""; /// #include ""clang/Tooling/Tooling.h""; /// #include ""llvm/Support/CommandLine.h""; ///; /// using namespace clang::tooling;; /// using namespace llvm;; ///; /// static cl::OptionCategory MyToolCategory(""My tool options"");; /// static cl::extrahelp CommonHelp(CommonOptionsParser::HelpMessage);; /// static cl::extrahelp MoreHelp(""\nMore help text...\n"");; /// static cl::opt<bool> YourOwnOption(...);; /// ...; ///; /// int main(int argc, const char **argv) {; /// CommonOptionsParser OptionsParser(argc, argv, MyToolCategory);; /// ClangTool Tool(OptionsParser.getCompilations(),; /// OptionsParser.getSourcePathList());; /// return Tool.run(newFrontendActionFactory<SyntaxOnlyAction>().get());; /// }; /// \endcode",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang/Tooling/CommonOptionsParser.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/CommonOptionsParser.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/CommonOptionsParser.h:137,Performance,load,loads,137,"/// A parser for options common to all command-line Clang tools.; ///; /// Parses a common subset of command-line arguments, locates and loads a; /// compilation commands database and runs a tool with user-specified action. It; /// also contains a help message for the common command-line options.; ///; /// An example of usage:; /// \code; /// #include ""clang/Frontend/FrontendActions.h""; /// #include ""clang/Tooling/CommonOptionsParser.h""; /// #include ""clang/Tooling/Tooling.h""; /// #include ""llvm/Support/CommandLine.h""; ///; /// using namespace clang::tooling;; /// using namespace llvm;; ///; /// static cl::OptionCategory MyToolCategory(""My tool options"");; /// static cl::extrahelp CommonHelp(CommonOptionsParser::HelpMessage);; /// static cl::extrahelp MoreHelp(""\nMore help text...\n"");; /// static cl::opt<bool> YourOwnOption(...);; /// ...; ///; /// int main(int argc, const char **argv) {; /// CommonOptionsParser OptionsParser(argc, argv, MyToolCategory);; /// ClangTool Tool(OptionsParser.getCompilations(),; /// OptionsParser.getSourcePathList());; /// return Tool.run(newFrontendActionFactory<SyntaxOnlyAction>().get());; /// }; /// \endcode",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang/Tooling/CommonOptionsParser.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/CommonOptionsParser.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/CommonOptionsParser.h:91,Availability,error,error,91,"/// A factory method that is similar to the above constructor, except; /// this returns an error instead exiting the program on error.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang/Tooling/CommonOptionsParser.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/CommonOptionsParser.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/CommonOptionsParser.h:128,Availability,error,error,128,"/// A factory method that is similar to the above constructor, except; /// this returns an error instead exiting the program on error.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang/Tooling/CommonOptionsParser.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/CommonOptionsParser.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/CommonOptionsParser.h:31,Performance,load,loaded,31,/// Returns a reference to the loaded compilations database.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang/Tooling/CommonOptionsParser.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/CommonOptionsParser.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/CompilationDatabase.h:405,Integrability,interface,interface,405,"//===- CompilationDatabase.h ------------------------------------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file provides an interface and multiple implementations for; // CompilationDatabases.; //; // While C++ refactoring and analysis tools are not compilers, and thus; // don't run as part of the build system, they need the exact information; // of a build in order to be able to correctly understand the C++ code of; // the project. This information is provided via the CompilationDatabase; // interface.; //; // To create a CompilationDatabase from a build directory one can call; // CompilationDatabase::loadFromDirectory(), which deduces the correct; // compilation database from the root of the build tree.; //; // See the concrete subclasses of CompilationDatabase for currently supported; // formats.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang/Tooling/CompilationDatabase.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/CompilationDatabase.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/CompilationDatabase.h:779,Integrability,interface,interface,779,"//===- CompilationDatabase.h ------------------------------------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file provides an interface and multiple implementations for; // CompilationDatabases.; //; // While C++ refactoring and analysis tools are not compilers, and thus; // don't run as part of the build system, they need the exact information; // of a build in order to be able to correctly understand the C++ code of; // the project. This information is provided via the CompilationDatabase; // interface.; //; // To create a CompilationDatabase from a build directory one can call; // CompilationDatabase::loadFromDirectory(), which deduces the correct; // compilation database from the root of the build tree.; //; // See the concrete subclasses of CompilationDatabase for currently supported; // formats.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang/Tooling/CompilationDatabase.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/CompilationDatabase.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/CompilationDatabase.h:492,Modifiability,refactor,refactoring,492,"//===- CompilationDatabase.h ------------------------------------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file provides an interface and multiple implementations for; // CompilationDatabases.; //; // While C++ refactoring and analysis tools are not compilers, and thus; // don't run as part of the build system, they need the exact information; // of a build in order to be able to correctly understand the C++ code of; // the project. This information is provided via the CompilationDatabase; // interface.; //; // To create a CompilationDatabase from a build directory one can call; // CompilationDatabase::loadFromDirectory(), which deduces the correct; // compilation database from the root of the build tree.; //; // See the concrete subclasses of CompilationDatabase for currently supported; // formats.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang/Tooling/CompilationDatabase.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/CompilationDatabase.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/CompilationDatabase.h:891,Performance,load,loadFromDirectory,891,"//===- CompilationDatabase.h ------------------------------------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file provides an interface and multiple implementations for; // CompilationDatabases.; //; // While C++ refactoring and analysis tools are not compilers, and thus; // don't run as part of the build system, they need the exact information; // of a build in order to be able to correctly understand the C++ code of; // the project. This information is provided via the CompilationDatabase; // interface.; //; // To create a CompilationDatabase from a build directory one can call; // CompilationDatabase::loadFromDirectory(), which deduces the correct; // compilation database from the root of the build tree.; //; // See the concrete subclasses of CompilationDatabase for currently supported; // formats.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang/Tooling/CompilationDatabase.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/CompilationDatabase.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/CompilationDatabase.h:4,Integrability,Interface,Interface,4,"/// Interface for compilation databases.; ///; /// A compilation database allows the user to retrieve compile command lines; /// for the files in a project.; ///; /// Many implementations are enumerable, allowing all command lines to be; /// retrieved. These can be used to run clang tools over a subset of the files; /// in a project.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang/Tooling/CompilationDatabase.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/CompilationDatabase.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/CompilationDatabase.h:273,Availability,Error,ErrorMessage,273,"/// Loads a compilation database from a build directory.; ///; /// Looks at the specified 'BuildDirectory' and creates a compilation database; /// that allows to query compile commands for source files in the; /// corresponding source tree.; ///; /// Returns NULL and sets ErrorMessage if we were not able to build up a; /// compilation database for the build directory.; ///; /// FIXME: Currently only supports JSON compilation databases, which; /// are named 'compile_commands.json' in the given directory. Extend this; /// for other build types (like ninja build files).",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang/Tooling/CompilationDatabase.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/CompilationDatabase.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/CompilationDatabase.h:509,Modifiability,Extend,Extend,509,"/// Loads a compilation database from a build directory.; ///; /// Looks at the specified 'BuildDirectory' and creates a compilation database; /// that allows to query compile commands for source files in the; /// corresponding source tree.; ///; /// Returns NULL and sets ErrorMessage if we were not able to build up a; /// compilation database for the build directory.; ///; /// FIXME: Currently only supports JSON compilation databases, which; /// are named 'compile_commands.json' in the given directory. Extend this; /// for other build types (like ninja build files).",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang/Tooling/CompilationDatabase.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/CompilationDatabase.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/CompilationDatabase.h:4,Performance,Load,Loads,4,"/// Loads a compilation database from a build directory.; ///; /// Looks at the specified 'BuildDirectory' and creates a compilation database; /// that allows to query compile commands for source files in the; /// corresponding source tree.; ///; /// Returns NULL and sets ErrorMessage if we were not able to build up a; /// compilation database for the build directory.; ///; /// FIXME: Currently only supports JSON compilation databases, which; /// are named 'compile_commands.json' in the given directory. Extend this; /// for other build types (like ninja build files).",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang/Tooling/CompilationDatabase.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/CompilationDatabase.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/CompilationDatabase.h:56,Performance,load,load,56,/// Tries to detect a compilation database location and load it.; ///; /// Looks for a compilation database in all parent paths of file 'SourceFile'; /// by calling loadFromDirectory.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang/Tooling/CompilationDatabase.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/CompilationDatabase.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/CompilationDatabase.h:165,Performance,load,loadFromDirectory,165,/// Tries to detect a compilation database location and load it.; ///; /// Looks for a compilation database in all parent paths of file 'SourceFile'; /// by calling loadFromDirectory.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang/Tooling/CompilationDatabase.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/CompilationDatabase.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/CompilationDatabase.h:13,Safety,detect,detect,13,/// Tries to detect a compilation database location and load it.; ///; /// Looks for a compilation database in all parent paths of file 'SourceFile'; /// by calling loadFromDirectory.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang/Tooling/CompilationDatabase.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/CompilationDatabase.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/CompilationDatabase.h:56,Performance,load,load,56,/// Tries to detect a compilation database location and load it.; ///; /// Looks for a compilation database in directory 'SourceDir' and all; /// its parent paths by calling loadFromDirectory.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang/Tooling/CompilationDatabase.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/CompilationDatabase.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/CompilationDatabase.h:174,Performance,load,loadFromDirectory,174,/// Tries to detect a compilation database location and load it.; ///; /// Looks for a compilation database in directory 'SourceDir' and all; /// its parent paths by calling loadFromDirectory.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang/Tooling/CompilationDatabase.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/CompilationDatabase.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/CompilationDatabase.h:13,Safety,detect,detect,13,/// Tries to detect a compilation database location and load it.; ///; /// Looks for a compilation database in directory 'SourceDir' and all; /// its parent paths by calling loadFromDirectory.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang/Tooling/CompilationDatabase.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/CompilationDatabase.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/CompilationDatabase.h:242,Testability,test,test,242,"/// Returns all compile commands in which the specified file was; /// compiled.; ///; /// This includes compile commands that span multiple source files.; /// For example, consider a project with the following compilations:; /// $ clang++ -o test a.cc b.cc t.cc; /// $ clang++ -o production a.cc b.cc -DPRODUCTION; /// A compilation database representing the project would return both command; /// lines for a.cc and b.cc and only the first command line for t.cc.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang/Tooling/CompilationDatabase.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/CompilationDatabase.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/CompilationDatabase.h:34,Availability,avail,available,34,"/// Returns the list of all files available in the compilation database.; ///; /// By default, returns nothing. Implementations should override this if they; /// can enumerate their source files.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang/Tooling/CompilationDatabase.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/CompilationDatabase.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/CompilationDatabase.h:142,Integrability,interface,interface,142,"/// Returns all compile commands for all the files in the compilation; /// database.; ///; /// FIXME: Add a layer in Tooling that provides an interface to run a tool; /// over all files in a compilation database. Not all build systems have the; /// ability to provide a feasible implementation for \c getAllCompileCommands.; ///; /// By default, this is implemented in terms of getAllFiles() and; /// getCompileCommands(). Subclasses may override this for efficiency.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang/Tooling/CompilationDatabase.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/CompilationDatabase.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/CompilationDatabase.h:1134,Availability,Error,ErrorMsg,1134,"/// Creates a FixedCompilationDatabase from the arguments after ""--"".; ///; /// Parses the given command line for ""--"". If ""--"" is found, the rest of; /// the arguments will make up the command line in the returned; /// FixedCompilationDatabase.; /// The arguments after ""--"" must not include positional parameters or the; /// argv[0] of the tool. Those will be added by the FixedCompilationDatabase; /// when a CompileCommand is requested. The argv[0] of the returned command; /// line will be ""clang-tool"".; ///; /// Returns NULL in case ""--"" is not found.; ///; /// The argument list is meant to be compatible with normal llvm command line; /// parsing in main methods.; /// int main(int argc, char **argv) {; /// std::unique_ptr<FixedCompilationDatabase> Compilations(; /// FixedCompilationDatabase::loadFromCommandLine(argc, argv));; /// cl::ParseCommandLineOptions(argc, argv);; /// ...; /// }; ///; /// \param Argc The number of command line arguments - will be changed to; /// the number of arguments before ""--"", if ""--"" was found in the argument; /// list.; /// \param Argv Points to the command line arguments.; /// \param ErrorMsg Contains error text if the function returns null pointer.; /// \param Directory The base directory used in the FixedCompilationDatabase.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang/Tooling/CompilationDatabase.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/CompilationDatabase.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/CompilationDatabase.h:1152,Availability,error,error,1152,"/// Creates a FixedCompilationDatabase from the arguments after ""--"".; ///; /// Parses the given command line for ""--"". If ""--"" is found, the rest of; /// the arguments will make up the command line in the returned; /// FixedCompilationDatabase.; /// The arguments after ""--"" must not include positional parameters or the; /// argv[0] of the tool. Those will be added by the FixedCompilationDatabase; /// when a CompileCommand is requested. The argv[0] of the returned command; /// line will be ""clang-tool"".; ///; /// Returns NULL in case ""--"" is not found.; ///; /// The argument list is meant to be compatible with normal llvm command line; /// parsing in main methods.; /// int main(int argc, char **argv) {; /// std::unique_ptr<FixedCompilationDatabase> Compilations(; /// FixedCompilationDatabase::loadFromCommandLine(argc, argv));; /// cl::ParseCommandLineOptions(argc, argv);; /// ...; /// }; ///; /// \param Argc The number of command line arguments - will be changed to; /// the number of arguments before ""--"", if ""--"" was found in the argument; /// list.; /// \param Argv Points to the command line arguments.; /// \param ErrorMsg Contains error text if the function returns null pointer.; /// \param Directory The base directory used in the FixedCompilationDatabase.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang/Tooling/CompilationDatabase.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/CompilationDatabase.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/CompilationDatabase.h:804,Performance,load,loadFromCommandLine,804,"/// Creates a FixedCompilationDatabase from the arguments after ""--"".; ///; /// Parses the given command line for ""--"". If ""--"" is found, the rest of; /// the arguments will make up the command line in the returned; /// FixedCompilationDatabase.; /// The arguments after ""--"" must not include positional parameters or the; /// argv[0] of the tool. Those will be added by the FixedCompilationDatabase; /// when a CompileCommand is requested. The argv[0] of the returned command; /// line will be ""clang-tool"".; ///; /// Returns NULL in case ""--"" is not found.; ///; /// The argument list is meant to be compatible with normal llvm command line; /// parsing in main methods.; /// int main(int argc, char **argv) {; /// std::unique_ptr<FixedCompilationDatabase> Compilations(; /// FixedCompilationDatabase::loadFromCommandLine(argc, argv));; /// cl::ParseCommandLineOptions(argc, argv);; /// ...; /// }; ///; /// \param Argc The number of command line arguments - will be changed to; /// the number of arguments before ""--"", if ""--"" was found in the argument; /// list.; /// \param Argv Points to the command line arguments.; /// \param ErrorMsg Contains error text if the function returns null pointer.; /// \param Directory The base directory used in the FixedCompilationDatabase.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang/Tooling/CompilationDatabase.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/CompilationDatabase.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/CompilationDatabase.h:81,Availability,Error,ErrorMessage,81,"/// Reads flags from the given file, one-per-line.; /// Returns nullptr and sets ErrorMessage if we can't read the file.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang/Tooling/CompilationDatabase.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/CompilationDatabase.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/CompilationDatabase.h:61,Deployability,configurat,configuration,61,"/// Transforms a compile command so that it applies the same configuration to; /// a different file. Most args are left intact, but tweaks may be needed; /// to certain flags (-x, -std etc).; ///; /// The output command will always end in {""--"", Filename}.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang/Tooling/CompilationDatabase.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/CompilationDatabase.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/CompilationDatabase.h:61,Modifiability,config,configuration,61,"/// Transforms a compile command so that it applies the same configuration to; /// a different file. Most args are left intact, but tweaks may be needed; /// to certain flags (-x, -std etc).; ///; /// The output command will always end in {""--"", Filename}.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang/Tooling/CompilationDatabase.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/CompilationDatabase.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/CompilationDatabase.h:14,Integrability,wrap,wrapped,14,"/// Returns a wrapped CompilationDatabase that defers to the provided one,; /// but getCompileCommands() will infer commands for unknown files.; /// The return value of getAllFiles() or getAllCompileCommands() is unchanged.; /// See InterpolatingCompilationDatabase.cpp for details on heuristics.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang/Tooling/CompilationDatabase.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/CompilationDatabase.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/CompilationDatabase.h:14,Integrability,wrap,wrapped,14,/// Returns a wrapped CompilationDatabase that will add -target and -mode flags; /// to commandline when they can be deduced from argv[0] of commandline returned; /// by underlying database.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang/Tooling/CompilationDatabase.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/CompilationDatabase.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/CompilationDatabase.h:14,Integrability,wrap,wrapped,14,/// Returns a wrapped CompilationDatabase that will expand all rsp(response); /// files on commandline returned by underlying database.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang/Tooling/CompilationDatabase.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/CompilationDatabase.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/CompilationDatabasePluginRegistry.h:4,Integrability,Interface,Interface,4,"/// Interface for compilation database plugins.; ///; /// A compilation database plugin allows the user to register custom compilation; /// databases that are picked up as compilation database if the corresponding; /// library is linked in. To register a plugin, declare a static variable like:; ///; /// \code; /// static CompilationDatabasePluginRegistry::Add<MyDatabasePlugin>; /// X(""my-compilation-database"", ""Reads my own compilation database"");; /// \endcode",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang/Tooling/CompilationDatabasePluginRegistry.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/CompilationDatabasePluginRegistry.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/CompilationDatabasePluginRegistry.h:39,Modifiability,plugin,plugins,39,"/// Interface for compilation database plugins.; ///; /// A compilation database plugin allows the user to register custom compilation; /// databases that are picked up as compilation database if the corresponding; /// library is linked in. To register a plugin, declare a static variable like:; ///; /// \code; /// static CompilationDatabasePluginRegistry::Add<MyDatabasePlugin>; /// X(""my-compilation-database"", ""Reads my own compilation database"");; /// \endcode",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang/Tooling/CompilationDatabasePluginRegistry.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/CompilationDatabasePluginRegistry.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/CompilationDatabasePluginRegistry.h:81,Modifiability,plugin,plugin,81,"/// Interface for compilation database plugins.; ///; /// A compilation database plugin allows the user to register custom compilation; /// databases that are picked up as compilation database if the corresponding; /// library is linked in. To register a plugin, declare a static variable like:; ///; /// \code; /// static CompilationDatabasePluginRegistry::Add<MyDatabasePlugin>; /// X(""my-compilation-database"", ""Reads my own compilation database"");; /// \endcode",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang/Tooling/CompilationDatabasePluginRegistry.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/CompilationDatabasePluginRegistry.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/CompilationDatabasePluginRegistry.h:255,Modifiability,plugin,plugin,255,"/// Interface for compilation database plugins.; ///; /// A compilation database plugin allows the user to register custom compilation; /// databases that are picked up as compilation database if the corresponding; /// library is linked in. To register a plugin, declare a static variable like:; ///; /// \code; /// static CompilationDatabasePluginRegistry::Add<MyDatabasePlugin>; /// X(""my-compilation-database"", ""Reads my own compilation database"");; /// \endcode",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang/Tooling/CompilationDatabasePluginRegistry.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/CompilationDatabasePluginRegistry.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/CompilationDatabasePluginRegistry.h:280,Modifiability,variab,variable,280,"/// Interface for compilation database plugins.; ///; /// A compilation database plugin allows the user to register custom compilation; /// databases that are picked up as compilation database if the corresponding; /// library is linked in. To register a plugin, declare a static variable like:; ///; /// \code; /// static CompilationDatabasePluginRegistry::Add<MyDatabasePlugin>; /// X(""my-compilation-database"", ""Reads my own compilation database"");; /// \endcode",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang/Tooling/CompilationDatabasePluginRegistry.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/CompilationDatabasePluginRegistry.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/CompilationDatabasePluginRegistry.h:4,Performance,Load,Loads,4,/// Loads a compilation database from a build directory.; ///; /// \see CompilationDatabase::loadFromDirectory().,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang/Tooling/CompilationDatabasePluginRegistry.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/CompilationDatabasePluginRegistry.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/CompilationDatabasePluginRegistry.h:93,Performance,load,loadFromDirectory,93,/// Loads a compilation database from a build directory.; ///; /// \see CompilationDatabase::loadFromDirectory().,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang/Tooling/CompilationDatabasePluginRegistry.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/CompilationDatabasePluginRegistry.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/DiagnosticsYaml.h:73,Security,access,access,73,/// Helper to (de)serialize a Diagnostic since we don't have direct; /// access to its data members.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang/Tooling/DiagnosticsYaml.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/DiagnosticsYaml.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Execution.h:806,Integrability,interface,interface,806,"//===--- Execution.h - Executing clang frontend actions -*- C++ ---------*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file defines framework for executing clang frontend actions.; //; // The framework can be extended to support different execution plans including; // standalone execution on the given TUs or parallel execution on all TUs in; // the codebase.; //; // In order to enable multiprocessing execution, tool actions are expected to; // output result into the ToolResults provided by the executor. The; // `ToolResults` is an interface that abstracts how results are stored e.g.; // in-memory for standalone execution or on-disk for large-scale execution.; //; // New executors can be registered as ToolExecutorPlugins via the; // `ToolExecutorPluginRegistry`. CLI tools can use; // `createExecutorFromCommandLineArgs` to create a specific registered executor; // according to the command-line arguments.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang/Tooling/Execution.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Execution.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Execution.h:478,Modifiability,extend,extended,478,"//===--- Execution.h - Executing clang frontend actions -*- C++ ---------*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file defines framework for executing clang frontend actions.; //; // The framework can be extended to support different execution plans including; // standalone execution on the given TUs or parallel execution on all TUs in; // the codebase.; //; // In order to enable multiprocessing execution, tool actions are expected to; // output result into the ToolResults provided by the executor. The; // `ToolResults` is an interface that abstracts how results are stored e.g.; // in-memory for standalone execution or on-disk for large-scale execution.; //; // New executors can be registered as ToolExecutorPlugins via the; // `ToolExecutorPluginRegistry`. CLI tools can use; // `createExecutorFromCommandLineArgs` to create a specific registered executor; // according to the command-line arguments.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang/Tooling/Execution.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Execution.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Execution.h:191,Modifiability,refactor,refactoring,191,"/// An abstraction for the result of a tool execution. For example, the; /// underlying result can be in-memory or on-disk.; ///; /// Results should be string key-value pairs. For example, a refactoring tool; /// can use source location as key and a replacement in YAML format as value.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang/Tooling/Execution.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Execution.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Execution.h:55,Availability,avail,available,55,// Returns the currently processed compilation unit if available.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang/Tooling/Execution.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Execution.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Execution.h:4,Integrability,Interface,Interface,4,"/// Interface for executing clang frontend actions.; ///; /// This can be extended to support running tool actions in different; /// execution mode, e.g. on a specific set of TUs or many TUs in parallel.; ///; /// New executors can be registered as ToolExecutorPlugins via the; /// `ToolExecutorPluginRegistry`. CLI tools can use; /// `createExecutorFromCommandLineArgs` to create a specific registered; /// executor according to the command-line arguments.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang/Tooling/Execution.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Execution.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Execution.h:74,Modifiability,extend,extended,74,"/// Interface for executing clang frontend actions.; ///; /// This can be extended to support running tool actions in different; /// execution mode, e.g. on a specific set of TUs or many TUs in parallel.; ///; /// New executors can be registered as ToolExecutorPlugins via the; /// `ToolExecutorPluginRegistry`. CLI tools can use; /// `createExecutorFromCommandLineArgs` to create a specific registered; /// executor according to the command-line arguments.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang/Tooling/Execution.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Execution.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Execution.h:4,Integrability,Interface,Interface,4,/// Interface for factories that create specific executors. This is also; /// used as a plugin to be registered into ToolExecutorPluginRegistry.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang/Tooling/Execution.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Execution.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Execution.h:88,Modifiability,plugin,plugin,88,/// Interface for factories that create specific executors. This is also; /// used as a plugin to be registered into ToolExecutorPluginRegistry.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang/Tooling/Execution.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Execution.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/FileMatchTrie.h:1410,Availability,error,error,1410,"/// A trie to efficiently match against the entries of the compilation; /// database in order of matching suffix length.; ///; /// When a clang tool is supposed to operate on a specific file, we have to; /// find the corresponding file in the compilation database. Although entries; /// in the compilation database are keyed by filename, a simple string match; /// is insufficient because of symlinks. Commonly, a project hierarchy looks; /// like this:; /// /<project-root>/src/<path>/<somefile>.cc (used as input for the tool); /// /<project-root>/build/<symlink-to-src>/<path>/<somefile>.cc (stored in DB); ///; /// Furthermore, there might be symlinks inside the source folder or inside the; /// database, so that the same source file is translated with different build; /// options.; ///; /// For a given input file, the \c FileMatchTrie finds its entries in order; /// of matching suffix length. For each suffix length, there might be one or; /// more entries in the database. For each of those entries, it calls; /// \c llvm::sys::fs::equivalent() (injected as \c PathComparator). There might; /// be zero or more entries with the same matching suffix length that are; /// equivalent to the input file. Three cases are distinguished:; /// 0 equivalent files: Continue with the next suffix length.; /// 1 equivalent file: Best match found, return it.; /// >1 equivalent files: Match is ambiguous, return error.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang/Tooling/FileMatchTrie.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/FileMatchTrie.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/FileMatchTrie.h:14,Energy Efficiency,efficient,efficiently,14,"/// A trie to efficiently match against the entries of the compilation; /// database in order of matching suffix length.; ///; /// When a clang tool is supposed to operate on a specific file, we have to; /// find the corresponding file in the compilation database. Although entries; /// in the compilation database are keyed by filename, a simple string match; /// is insufficient because of symlinks. Commonly, a project hierarchy looks; /// like this:; /// /<project-root>/src/<path>/<somefile>.cc (used as input for the tool); /// /<project-root>/build/<symlink-to-src>/<path>/<somefile>.cc (stored in DB); ///; /// Furthermore, there might be symlinks inside the source folder or inside the; /// database, so that the same source file is translated with different build; /// options.; ///; /// For a given input file, the \c FileMatchTrie finds its entries in order; /// of matching suffix length. For each suffix length, there might be one or; /// more entries in the database. For each of those entries, it calls; /// \c llvm::sys::fs::equivalent() (injected as \c PathComparator). There might; /// be zero or more entries with the same matching suffix length that are; /// equivalent to the input file. Three cases are distinguished:; /// 0 equivalent files: Continue with the next suffix length.; /// 1 equivalent file: Best match found, return it.; /// >1 equivalent files: Match is ambiguous, return error.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang/Tooling/FileMatchTrie.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/FileMatchTrie.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/FileMatchTrie.h:1056,Integrability,inject,injected,1056,"/// A trie to efficiently match against the entries of the compilation; /// database in order of matching suffix length.; ///; /// When a clang tool is supposed to operate on a specific file, we have to; /// find the corresponding file in the compilation database. Although entries; /// in the compilation database are keyed by filename, a simple string match; /// is insufficient because of symlinks. Commonly, a project hierarchy looks; /// like this:; /// /<project-root>/src/<path>/<somefile>.cc (used as input for the tool); /// /<project-root>/build/<symlink-to-src>/<path>/<somefile>.cc (stored in DB); ///; /// Furthermore, there might be symlinks inside the source folder or inside the; /// database, so that the same source file is translated with different build; /// options.; ///; /// For a given input file, the \c FileMatchTrie finds its entries in order; /// of matching suffix length. For each suffix length, there might be one or; /// more entries in the database. For each of those entries, it calls; /// \c llvm::sys::fs::equivalent() (injected as \c PathComparator). There might; /// be zero or more entries with the same matching suffix length that are; /// equivalent to the input file. Three cases are distinguished:; /// 0 equivalent files: Continue with the next suffix length.; /// 1 equivalent file: Best match found, return it.; /// >1 equivalent files: Match is ambiguous, return error.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang/Tooling/FileMatchTrie.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/FileMatchTrie.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/FileMatchTrie.h:1056,Security,inject,injected,1056,"/// A trie to efficiently match against the entries of the compilation; /// database in order of matching suffix length.; ///; /// When a clang tool is supposed to operate on a specific file, we have to; /// find the corresponding file in the compilation database. Although entries; /// in the compilation database are keyed by filename, a simple string match; /// is insufficient because of symlinks. Commonly, a project hierarchy looks; /// like this:; /// /<project-root>/src/<path>/<somefile>.cc (used as input for the tool); /// /<project-root>/build/<symlink-to-src>/<path>/<somefile>.cc (stored in DB); ///; /// Furthermore, there might be symlinks inside the source folder or inside the; /// database, so that the same source file is translated with different build; /// options.; ///; /// For a given input file, the \c FileMatchTrie finds its entries in order; /// of matching suffix length. For each suffix length, there might be one or; /// more entries in the database. For each of those entries, it calls; /// \c llvm::sys::fs::equivalent() (injected as \c PathComparator). There might; /// be zero or more entries with the same matching suffix length that are; /// equivalent to the input file. Three cases are distinguished:; /// 0 equivalent files: Continue with the next suffix length.; /// 1 equivalent file: Best match found, return it.; /// >1 equivalent files: Match is ambiguous, return error.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang/Tooling/FileMatchTrie.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/FileMatchTrie.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/FileMatchTrie.h:340,Usability,simpl,simple,340,"/// A trie to efficiently match against the entries of the compilation; /// database in order of matching suffix length.; ///; /// When a clang tool is supposed to operate on a specific file, we have to; /// find the corresponding file in the compilation database. Although entries; /// in the compilation database are keyed by filename, a simple string match; /// is insufficient because of symlinks. Commonly, a project hierarchy looks; /// like this:; /// /<project-root>/src/<path>/<somefile>.cc (used as input for the tool); /// /<project-root>/build/<symlink-to-src>/<path>/<somefile>.cc (stored in DB); ///; /// Furthermore, there might be symlinks inside the source folder or inside the; /// database, so that the same source file is translated with different build; /// options.; ///; /// For a given input file, the \c FileMatchTrie finds its entries in order; /// of matching suffix length. For each suffix length, there might be one or; /// more entries in the database. For each of those entries, it calls; /// \c llvm::sys::fs::equivalent() (injected as \c PathComparator). There might; /// be zero or more entries with the same matching suffix length that are; /// equivalent to the input file. Three cases are distinguished:; /// 0 equivalent files: Continue with the next suffix length.; /// 1 equivalent file: Best match found, return it.; /// >1 equivalent files: Match is ambiguous, return error.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang/Tooling/FileMatchTrie.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/FileMatchTrie.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/FileMatchTrie.h:144,Testability,test,testing,144,/// Construct a new \c FileMatchTrie with the given \c PathComparator.; ///; /// The \c FileMatchTrie takes ownership of 'Comparator'. Used for testing.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang/Tooling/FileMatchTrie.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/FileMatchTrie.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/FileMatchTrie.h:374,Availability,Error,Error,374,"/// Finds the corresponding file in this trie.; ///; /// Returns file name stored in this trie that is equivalent to 'FileName'; /// according to 'Comparator', if it can be uniquely identified. If there; /// are no matches an empty \c StringRef is returned. If there are ambiguous; /// matches, an empty \c StringRef is returned and a corresponding message; /// written to 'Error'.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang/Tooling/FileMatchTrie.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/FileMatchTrie.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/FileMatchTrie.h:349,Integrability,message,message,349,"/// Finds the corresponding file in this trie.; ///; /// Returns file name stored in this trie that is equivalent to 'FileName'; /// according to 'Comparator', if it can be uniquely identified. If there; /// are no matches an empty \c StringRef is returned. If there are ambiguous; /// matches, an empty \c StringRef is returned and a corresponding message; /// written to 'Error'.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang/Tooling/FileMatchTrie.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/FileMatchTrie.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/JSONCompilationDatabase.h:95,Availability,Error,ErrorMessage,95,/// Loads a JSON compilation database from the specified file.; ///; /// Returns NULL and sets ErrorMessage if the database could not be; /// loaded from the given file.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang/Tooling/JSONCompilationDatabase.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/JSONCompilationDatabase.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/JSONCompilationDatabase.h:4,Performance,Load,Loads,4,/// Loads a JSON compilation database from the specified file.; ///; /// Returns NULL and sets ErrorMessage if the database could not be; /// loaded from the given file.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang/Tooling/JSONCompilationDatabase.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/JSONCompilationDatabase.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/JSONCompilationDatabase.h:142,Performance,load,loaded,142,/// Loads a JSON compilation database from the specified file.; ///; /// Returns NULL and sets ErrorMessage if the database could not be; /// loaded from the given file.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang/Tooling/JSONCompilationDatabase.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/JSONCompilationDatabase.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/JSONCompilationDatabase.h:90,Availability,Error,ErrorMessage,90,/// Loads a JSON compilation database from a data buffer.; ///; /// Returns NULL and sets ErrorMessage if the database could not be loaded.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang/Tooling/JSONCompilationDatabase.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/JSONCompilationDatabase.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/JSONCompilationDatabase.h:4,Performance,Load,Loads,4,/// Loads a JSON compilation database from a data buffer.; ///; /// Returns NULL and sets ErrorMessage if the database could not be loaded.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang/Tooling/JSONCompilationDatabase.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/JSONCompilationDatabase.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/JSONCompilationDatabase.h:132,Performance,load,loaded,132,/// Loads a JSON compilation database from a data buffer.; ///; /// Returns NULL and sets ErrorMessage if the database could not be loaded.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang/Tooling/JSONCompilationDatabase.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/JSONCompilationDatabase.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/JSONCompilationDatabase.h:34,Availability,avail,available,34,/// Returns the list of all files available in the compilation database.; ///; /// These are the 'file' entries of the JSON objects.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang/Tooling/JSONCompilationDatabase.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/JSONCompilationDatabase.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/JSONCompilationDatabase.h:102,Availability,Error,ErrorMessage,102,/// Parses the database file and creates the index.; ///; /// Returns whether parsing succeeded. Sets ErrorMessage if parsing; /// failed.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang/Tooling/JSONCompilationDatabase.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/JSONCompilationDatabase.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/NodeIntrospection.h:301,Integrability,depend,dependent,301,"// namespace internal; // Note that this container stores unique results in a deterministic, but; // the location calls are in an unspecified order. Clients which desire; // a particular order for the location calls, such as alphabetical,; // should sort results after retrieval, because the order is dependent; // on how the LocationCalls are formatted.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang/Tooling/NodeIntrospection.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/NodeIntrospection.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Refactoring.h:383,Integrability,Interface,Interfaces,383,"//===--- Refactoring.h - Framework for clang refactoring tools --*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // Interfaces supporting refactorings that span multiple translation units.; // While single translation unit refactorings are supported via the Rewriter,; // when refactoring multiple translation units changes must be stored in a; // SourceManager independent form, duplicate changes need to be removed, and; // all changes must be applied at once at the end of the refactoring so that; // the code is always parseable.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang/Tooling/Refactoring.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Refactoring.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Refactoring.h:9,Modifiability,Refactor,Refactoring,9,"//===--- Refactoring.h - Framework for clang refactoring tools --*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // Interfaces supporting refactorings that span multiple translation units.; // While single translation unit refactorings are supported via the Rewriter,; // when refactoring multiple translation units changes must be stored in a; // SourceManager independent form, duplicate changes need to be removed, and; // all changes must be applied at once at the end of the refactoring so that; // the code is always parseable.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang/Tooling/Refactoring.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Refactoring.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Refactoring.h:45,Modifiability,refactor,refactoring,45,"//===--- Refactoring.h - Framework for clang refactoring tools --*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // Interfaces supporting refactorings that span multiple translation units.; // While single translation unit refactorings are supported via the Rewriter,; // when refactoring multiple translation units changes must be stored in a; // SourceManager independent form, duplicate changes need to be removed, and; // all changes must be applied at once at the end of the refactoring so that; // the code is always parseable.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang/Tooling/Refactoring.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Refactoring.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Refactoring.h:405,Modifiability,refactor,refactorings,405,"//===--- Refactoring.h - Framework for clang refactoring tools --*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // Interfaces supporting refactorings that span multiple translation units.; // While single translation unit refactorings are supported via the Rewriter,; // when refactoring multiple translation units changes must be stored in a; // SourceManager independent form, duplicate changes need to be removed, and; // all changes must be applied at once at the end of the refactoring so that; // the code is always parseable.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang/Tooling/Refactoring.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Refactoring.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Refactoring.h:490,Modifiability,refactor,refactorings,490,"//===--- Refactoring.h - Framework for clang refactoring tools --*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // Interfaces supporting refactorings that span multiple translation units.; // While single translation unit refactorings are supported via the Rewriter,; // when refactoring multiple translation units changes must be stored in a; // SourceManager independent form, duplicate changes need to be removed, and; // all changes must be applied at once at the end of the refactoring so that; // the code is always parseable.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang/Tooling/Refactoring.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Refactoring.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Refactoring.h:525,Modifiability,Rewrite,Rewriter,525,"//===--- Refactoring.h - Framework for clang refactoring tools --*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // Interfaces supporting refactorings that span multiple translation units.; // While single translation unit refactorings are supported via the Rewriter,; // when refactoring multiple translation units changes must be stored in a; // SourceManager independent form, duplicate changes need to be removed, and; // all changes must be applied at once at the end of the refactoring so that; // the code is always parseable.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang/Tooling/Refactoring.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Refactoring.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Refactoring.h:544,Modifiability,refactor,refactoring,544,"//===--- Refactoring.h - Framework for clang refactoring tools --*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // Interfaces supporting refactorings that span multiple translation units.; // While single translation unit refactorings are supported via the Rewriter,; // when refactoring multiple translation units changes must be stored in a; // SourceManager independent form, duplicate changes need to be removed, and; // all changes must be applied at once at the end of the refactoring so that; // the code is always parseable.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang/Tooling/Refactoring.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Refactoring.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Refactoring.h:747,Modifiability,refactor,refactoring,747,"//===--- Refactoring.h - Framework for clang refactoring tools --*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // Interfaces supporting refactorings that span multiple translation units.; // While single translation unit refactorings are supported via the Rewriter,; // when refactoring multiple translation units changes must be stored in a; // SourceManager independent form, duplicate changes need to be removed, and; // all changes must be applied at once at the end of the refactoring so that; // the code is always parseable.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang/Tooling/Refactoring.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Refactoring.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Refactoring.h:18,Modifiability,refactor,refactorings,18,/// A tool to run refactorings.; ///; /// This is a refactoring specific version of \see ClangTool. FrontendActions; /// passed to run() and runAndSave() should add replacements to; /// getReplacements().,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang/Tooling/Refactoring.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Refactoring.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Refactoring.h:52,Modifiability,refactor,refactoring,52,/// A tool to run refactorings.; ///; /// This is a refactoring specific version of \see ClangTool. FrontendActions; /// passed to run() and runAndSave() should add replacements to; /// getReplacements().,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang/Tooling/Refactoring.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Refactoring.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Refactoring.h:146,Availability,failure,failure,146,"/// Call run(), apply all generated replacements, and immediately save; /// the results to disk.; ///; /// \returns 0 upon success. Non-zero upon failure.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang/Tooling/Refactoring.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Refactoring.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Refactoring.h:47,Modifiability,Rewrite,Rewriter,47,/// Apply all stored replacements to the given Rewriter.; ///; /// FileToReplaces will be deduplicated with `groupReplacementsByFile` before; /// application.; ///; /// Replacement applications happen independently of the success of other; /// applications.; ///; /// \returns true if all replacements apply. false otherwise.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang/Tooling/Refactoring.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Refactoring.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Refactoring.h:14,Modifiability,refactor,refactored,14,/// Write all refactored files to disk.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang/Tooling/Refactoring.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Refactoring.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Refactoring.h:110,Modifiability,Rewrite,Rewriter,110,"/// Groups \p Replaces by the file path and applies each group of; /// Replacements on the related file in \p Rewriter. In addition to applying; /// given Replacements, this function also formats the changed code.; ///; /// \pre Replacements must be conflict-free.; ///; /// FileToReplaces will be deduplicated with `groupReplacementsByFile` before; /// application.; ///; /// Replacement applications happen independently of the success of other; /// applications.; ///; /// \param[in] FileToReplaces Replacements (grouped by files) to apply.; /// \param[in] Rewrite The `Rewritter` to apply replacements on.; /// \param[in] Style The style name used for reformatting. See ```getStyle``` in; /// ""include/clang/Format/Format.h"" for all possible style forms.; ///; /// \returns true if all replacements applied and formatted. false otherwise.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang/Tooling/Refactoring.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Refactoring.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Refactoring.h:560,Modifiability,Rewrite,Rewrite,560,"/// Groups \p Replaces by the file path and applies each group of; /// Replacements on the related file in \p Rewriter. In addition to applying; /// given Replacements, this function also formats the changed code.; ///; /// \pre Replacements must be conflict-free.; ///; /// FileToReplaces will be deduplicated with `groupReplacementsByFile` before; /// application.; ///; /// Replacement applications happen independently of the success of other; /// applications.; ///; /// \param[in] FileToReplaces Replacements (grouped by files) to apply.; /// \param[in] Rewrite The `Rewritter` to apply replacements on.; /// \param[in] Style The style name used for reformatting. See ```getStyle``` in; /// ""include/clang/Format/Format.h"" for all possible style forms.; ///; /// \returns true if all replacements applied and formatted. false otherwise.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang/Tooling/Refactoring.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Refactoring.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/RefactoringCallbacks.h:9,Modifiability,Refactor,RefactoringCallbacks,9,"//===--- RefactoringCallbacks.h - Structural query framework ----*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // Provides callbacks to make common kinds of refactorings easy.; //; // The general idea is to construct a matcher expression that describes a; // subtree match on the AST and then replace the corresponding source code; // either by some specific text or some other AST node.; //; // Example:; // int main(int argc, char **argv) {; // ClangTool Tool(argc, argv);; // MatchFinder Finder;; // ReplaceStmtWithText Callback(""integer"", ""42"");; // Finder.AddMatcher(id(""integer"", expression(integerLiteral())), Callback);; // return Tool.run(newFrontendActionFactory(&Finder));; // }; //; // This will replace all integer literals with ""42"".; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang/Tooling/RefactoringCallbacks.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/RefactoringCallbacks.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/RefactoringCallbacks.h:426,Modifiability,refactor,refactorings,426,"//===--- RefactoringCallbacks.h - Structural query framework ----*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // Provides callbacks to make common kinds of refactorings easy.; //; // The general idea is to construct a matcher expression that describes a; // subtree match on the AST and then replace the corresponding source code; // either by some specific text or some other AST node.; //; // Example:; // int main(int argc, char **argv) {; // ClangTool Tool(argc, argv);; // MatchFinder Finder;; // ReplaceStmtWithText Callback(""integer"", ""42"");; // Finder.AddMatcher(id(""integer"", expression(integerLiteral())), Callback);; // return Tool.run(newFrontendActionFactory(&Finder));; // }; //; // This will replace all integer literals with ""42"".; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang/Tooling/RefactoringCallbacks.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/RefactoringCallbacks.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/RefactoringCallbacks.h:19,Modifiability,Refactor,RefactoringCallbacks,19,/// Base class for RefactoringCallbacks.; ///; /// Collects \c tooling::Replacements while running.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang/Tooling/RefactoringCallbacks.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/RefactoringCallbacks.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/RefactoringCallbacks.h:4,Energy Efficiency,Adapt,Adaptor,4,/// Adaptor between \c ast_matchers::MatchFinder and \c; /// tooling::RefactoringTool.; ///; /// Runs AST matchers and stores the \c tooling::Replacements in a map.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang/Tooling/RefactoringCallbacks.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/RefactoringCallbacks.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/RefactoringCallbacks.h:4,Modifiability,Adapt,Adaptor,4,/// Adaptor between \c ast_matchers::MatchFinder and \c; /// tooling::RefactoringTool.; ///; /// Runs AST matchers and stores the \c tooling::Replacements in a map.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang/Tooling/RefactoringCallbacks.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/RefactoringCallbacks.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/RefactoringCallbacks.h:70,Modifiability,Refactor,RefactoringTool,70,/// Adaptor between \c ast_matchers::MatchFinder and \c; /// tooling::RefactoringTool.; ///; /// Runs AST matchers and stores the \c tooling::Replacements in a map.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang/Tooling/RefactoringCallbacks.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/RefactoringCallbacks.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/ReplacementsYaml.h:74,Security,access,access,74,/// Helper to (de)serialize a Replacement since we don't have direct; /// access to its data members.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang/Tooling/ReplacementsYaml.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/ReplacementsYaml.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/StandaloneExecution.h:54,Integrability,wrap,wrapper,54,// FIXME: The standalone executor is currently just a wrapper of `ClangTool`.; // Merge `ClangTool` implementation into the this.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang/Tooling/StandaloneExecution.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/StandaloneExecution.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Tooling.h:477,Modifiability,plugin,plugin,477,"//===- Tooling.h - Framework for standalone Clang tools ---------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements functions to run clang tools standalone instead; // of running them as a plugin.; //; // A ClangTool is initialized with a CompilationDatabase and a set of files; // to run over. The tool will then run a user-specified FrontendAction over; // all TUs in which the given files are compiled.; //; // It is also possible to run a FrontendAction over a snippet of code by; // calling runToolOnCode, which is useful for unit testing.; //; // Applications that need more fine grained control over how to run; // multiple FrontendActions over code can use ToolInvocation.; //; // Example tools:; // - running clang -fsyntax-only over source code from an editor to get; // fast syntax checks; // - running match/replace tools over C++ code; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang/Tooling/Tooling.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Tooling.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Tooling.h:824,Testability,test,testing,824,"//===- Tooling.h - Framework for standalone Clang tools ---------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements functions to run clang tools standalone instead; // of running them as a plugin.; //; // A ClangTool is initialized with a CompilationDatabase and a set of files; // to run over. The tool will then run a user-specified FrontendAction over; // all TUs in which the given files are compiled.; //; // It is also possible to run a FrontendAction over a snippet of code by; // calling runToolOnCode, which is useful for unit testing.; //; // Applications that need more fine grained control over how to run; // multiple FrontendActions over code can use ToolInvocation.; //; // Example tools:; // - running clang -fsyntax-only over source code from an editor to get; // fast syntax checks; // - running match/replace tools over C++ code; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang/Tooling/Tooling.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Tooling.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Tooling.h:4,Integrability,Interface,Interface,4,"/// Interface to process a clang::CompilerInvocation.; ///; /// If your tool is based on FrontendAction, you should be deriving from; /// FrontendActionFactory instead.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang/Tooling/Tooling.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Tooling.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Tooling.h:4,Performance,Perform,Perform,4,/// Perform an action for an invocation.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang/Tooling/Tooling.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Tooling.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Tooling.h:4,Integrability,Interface,Interface,4,"/// Interface to generate clang::FrontendActions.; ///; /// Having a factory interface allows, for example, a new FrontendAction to be; /// created for each translation unit processed by ClangTool. This class is; /// also a ToolAction which uses the FrontendActions created by create() to; /// process each translation unit.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang/Tooling/Tooling.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Tooling.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Tooling.h:77,Integrability,interface,interface,77,"/// Interface to generate clang::FrontendActions.; ///; /// Having a factory interface allows, for example, a new FrontendAction to be; /// created for each translation unit processed by ClangTool. This class is; /// also a ToolAction which uses the FrontendActions created by create() to; /// process each translation unit.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang/Tooling/Tooling.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Tooling.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Tooling.h:285,Performance,load,loading,285,/// Runs (and deletes) the tool on 'Code' with the -fsyntax-only flag.; ///; /// \param ToolAction The action to run over the code.; /// \param Code C++ code.; /// \param FileName The file name which 'Code' will be mapped as.; /// \param PCHContainerOps The PCHContainerOperations for loading and creating; /// clang modules.; ///; /// \return - True if 'ToolAction' was successfully executed.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang/Tooling/Tooling.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Tooling.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Tooling.h:500,Performance,load,loading,500,/// Runs (and deletes) the tool on 'Code' with the -fsyntax-only flag and; /// with additional other flags.; ///; /// \param ToolAction The action to run over the code.; /// \param Code C++ code.; /// \param Args Additional flags to pass on.; /// \param FileName The file name which 'Code' will be mapped as.; /// \param ToolName The name of the binary running the tool. Standard library; /// header paths will be resolved relative to this.; /// \param PCHContainerOps The PCHContainerOperations for loading and creating; /// clang modules.; ///; /// \return - True if 'ToolAction' was successfully executed.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang/Tooling/Tooling.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Tooling.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Tooling.h:279,Availability,error,error,279,/// Builds an AST for 'Code'.; ///; /// \param Code C++ code.; /// \param FileName The file name which 'Code' will be mapped as.; /// \param PCHContainerOps The PCHContainerOperations for loading and creating; /// clang modules.; ///; /// \return The resulting AST or null if an error occurred.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang/Tooling/Tooling.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Tooling.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Tooling.h:188,Performance,load,loading,188,/// Builds an AST for 'Code'.; ///; /// \param Code C++ code.; /// \param FileName The file name which 'Code' will be mapped as.; /// \param PCHContainerOps The PCHContainerOperations for loading and creating; /// clang modules.; ///; /// \return The resulting AST or null if an error occurred.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang/Tooling/Tooling.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Tooling.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Tooling.h:567,Availability,error,error,567,/// Builds an AST for 'Code' with additional flags.; ///; /// \param Code C++ code.; /// \param Args Additional flags to pass on.; /// \param FileName The file name which 'Code' will be mapped as.; /// \param ToolName The name of the binary running the tool. Standard library; /// header paths will be resolved relative to this.; /// \param PCHContainerOps The PCHContainerOperations for loading and creating; /// clang modules.; ///; /// \param Adjuster A function to filter the command line arguments as specified.; ///; /// \return The resulting AST or null if an error occurred.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang/Tooling/Tooling.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Tooling.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Tooling.h:388,Performance,load,loading,388,/// Builds an AST for 'Code' with additional flags.; ///; /// \param Code C++ code.; /// \param Args Additional flags to pass on.; /// \param FileName The file name which 'Code' will be mapped as.; /// \param ToolName The name of the binary running the tool. Standard library; /// header paths will be resolved relative to this.; /// \param PCHContainerOps The PCHContainerOperations for loading and creating; /// clang modules.; ///; /// \param Adjuster A function to filter the command line arguments as specified.; ///; /// \return The resulting AST or null if an error occurred.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang/Tooling/Tooling.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Tooling.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Tooling.h:228,Deployability,install,installed,228,/// Create a tool invocation.; ///; /// \param CommandLine The command line arguments to clang. Note that clang; /// uses its binary name (CommandLine[0]) to locate its builtin headers.; /// Callers have to ensure that they are installed in a compatible location; /// (see clang driver implementation) or mapped in via mapVirtualFile.; /// \param FAction The action to be executed.; /// \param Files The FileManager used for the execution. Class does not take; /// ownership.; /// \param PCHContainerOps The PCHContainerOperations for loading and creating; /// clang modules.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang/Tooling/Tooling.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Tooling.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Tooling.h:535,Performance,load,loading,535,/// Create a tool invocation.; ///; /// \param CommandLine The command line arguments to clang. Note that clang; /// uses its binary name (CommandLine[0]) to locate its builtin headers.; /// Callers have to ensure that they are installed in a compatible location; /// (see clang driver implementation) or mapped in via mapVirtualFile.; /// \param FAction The action to be executed.; /// \param Files The FileManager used for the execution. Class does not take; /// ownership.; /// \param PCHContainerOps The PCHContainerOperations for loading and creating; /// clang modules.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang/Tooling/Tooling.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Tooling.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Tooling.h:259,Performance,load,loading,259,/// Create a tool invocation.; ///; /// \param CommandLine The command line arguments to clang.; /// \param Action The action to be executed.; /// \param Files The FileManager used for the execution.; /// \param PCHContainerOps The PCHContainerOperations for loading and creating; /// clang modules.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang/Tooling/Tooling.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Tooling.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Tooling.h:71,Availability,error,errors,71,/// Run the clang invocation.; ///; /// \returns True if there were no errors during execution.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang/Tooling/Tooling.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Tooling.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Tooling.h:294,Deployability,install,install,294,/// Utility to run a FrontendAction over a set of files.; ///; /// This class is written to be usable for command line utilities.; /// By default the class uses ClangSyntaxOnlyAdjuster to modify; /// command line arguments before the arguments are used to run; /// a frontend action. One could install an additional command line; /// arguments adjuster by calling the appendArgumentsAdjuster() method.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang/Tooling/Tooling.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Tooling.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Tooling.h:95,Usability,usab,usable,95,/// Utility to run a FrontendAction over a set of files.; ///; /// This class is written to be usable for command line utilities.; /// By default the class uses ClangSyntaxOnlyAdjuster to modify; /// command line arguments before the arguments are used to run; /// a frontend action. One could install an additional command line; /// arguments adjuster by calling the appendArgumentsAdjuster() method.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang/Tooling/Tooling.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Tooling.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Tooling.h:366,Performance,load,loading,366,"/// Constructs a clang tool to run over a list of files.; ///; /// \param Compilations The CompilationDatabase which contains the compile; /// command lines for the given source paths.; /// \param SourcePaths The source files to run over. If a source files is; /// not found in Compilations, it is skipped.; /// \param PCHContainerOps The PCHContainerOperations for loading and creating; /// clang modules.; /// \param BaseFS VFS used for all underlying file accesses when running the; /// tool.; /// \param Files The file manager to use for underlying file operations when; /// running the tool.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang/Tooling/Tooling.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Tooling.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Tooling.h:459,Security,access,accesses,459,"/// Constructs a clang tool to run over a list of files.; ///; /// \param Compilations The CompilationDatabase which contains the compile; /// command lines for the given source paths.; /// \param SourcePaths The source files to run over. If a source files is; /// not found in Compilations, it is skipped.; /// \param PCHContainerOps The PCHContainerOperations for loading and creating; /// clang modules.; /// \param BaseFS VFS used for all underlying file accesses when running the; /// tool.; /// \param Files The file manager to use for underlying file operations when; /// running the tool.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang/Tooling/Tooling.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Tooling.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Tooling.h:4,Usability,Clear,Clear,4,/// Clear the command line arguments adjuster chain.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang/Tooling/Tooling.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Tooling.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Tooling.h:144,Availability,error,error,144,/// Runs an action over all files specified in the command line.; ///; /// \param Action Tool action.; ///; /// \returns 0 on success; 1 if any error occurred; 2 if there is no error but; /// some files are skipped due to missing compile commands.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang/Tooling/Tooling.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Tooling.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Tooling.h:177,Availability,error,error,177,/// Runs an action over all files specified in the command line.; ///; /// \param Action Tool action.; ///; /// \returns 0 on success; 1 if any error occurred; 2 if there is no error but; /// some files are skipped due to missing compile commands.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang/Tooling/Tooling.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Tooling.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Tooling.h:20,Availability,error,error,20,"/// Sets whether an error message should be printed out if an action fails. By; /// default, if an action fails, a message is printed out to stderr.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang/Tooling/Tooling.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Tooling.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Tooling.h:26,Integrability,message,message,26,"/// Sets whether an error message should be printed out if an action fails. By; /// default, if an action fails, a message is printed out to stderr.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang/Tooling/Tooling.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Tooling.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Tooling.h:115,Integrability,message,message,115,"/// Sets whether an error message should be printed out if an action fails. By; /// default, if an action fails, a message is printed out to stderr.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang/Tooling/Tooling.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Tooling.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/ASTDiff/ASTDiff.h:538,Availability,down,down,538,"//===- ASTDiff.h - AST differencing API -----------------------*- C++ -*- -===//; //; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file specifies an interface that can be used to compare C++ syntax; // trees.; //; // We use the gumtree algorithm which combines a heuristic top-down search that; // is able to match large subtrees that are equivalent, with an optimal; // algorithm to match small subtrees.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang/Tooling/ASTDiff/ASTDiff.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/ASTDiff/ASTDiff.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/ASTDiff/ASTDiff.h:410,Integrability,interface,interface,410,"//===- ASTDiff.h - AST differencing API -----------------------*- C++ -*- -===//; //; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file specifies an interface that can be used to compare C++ syntax; // trees.; //; // We use the gumtree algorithm which combines a heuristic top-down search that; // is able to match large subtrees that are equivalent, with an optimal; // algorithm to match small subtrees.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang/Tooling/ASTDiff/ASTDiff.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/ASTDiff/ASTDiff.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/ASTDiff/ASTDiff.h:15,Deployability,update,update,15,"// (Src, Dst): update the value of node Src to match Dst.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang/Tooling/ASTDiff/ASTDiff.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/ASTDiff/ASTDiff.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/ASTDiff/ASTDiff.h:21,Deployability,Update,Update,21,// Same as Move plus Update.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang/Tooling/ASTDiff/ASTDiff.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/ASTDiff/ASTDiff.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/ASTDiff/ASTDiff.h:15,Availability,down,down,15,"/// During top-down matching, only consider nodes of at least this height.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang/Tooling/ASTDiff/ASTDiff.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/ASTDiff/ASTDiff.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Core/Diagnostic.h:430,Modifiability,refactor,refactorings,430,"//===--- Diagnostic.h - Framework for clang diagnostics tools --*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // \file; // Structures supporting diagnostics and refactorings that span multiple; // translation units. Indicate diagnostics reports and replacements; // suggestions for the analyzed sources.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang/Tooling/Core/Diagnostic.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Core/Diagnostic.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Core/Diagnostic.h:47,Availability,error,error,47,/// Represents the diagnostic message with the error message associated; /// and the information on the location of the problem.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang/Tooling/Core/Diagnostic.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Core/Diagnostic.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Core/Diagnostic.h:30,Integrability,message,message,30,/// Represents the diagnostic message with the error message associated; /// and the information on the location of the problem.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang/Tooling/Core/Diagnostic.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Core/Diagnostic.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Core/Diagnostic.h:53,Integrability,message,message,53,/// Represents the diagnostic message with the error message associated; /// and the information on the location of the problem.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang/Tooling/Core/Diagnostic.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Core/Diagnostic.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Core/Diagnostic.h:28,Integrability,message,message,28,"/// Constructs a diagnostic message with anoffset to the diagnostic; /// within the file where the problem occurred.; ///; /// \param Loc Should be a file location, it is not meaningful for a macro; /// location.; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang/Tooling/Core/Diagnostic.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Core/Diagnostic.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Core/Diagnostic.h:90,Integrability,Message,Message,90,"/// Extra source ranges associated with the note, in addition to the location; /// of the Message itself.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang/Tooling/Core/Diagnostic.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Core/Diagnostic.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Core/Diagnostic.h:4,Integrability,Message,Message,4,/// Message associated to the diagnostic.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang/Tooling/Core/Diagnostic.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Core/Diagnostic.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Core/Diagnostic.h:45,Availability,error,error,45,/// Diagnostic level. Can indicate either an error or a warning.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang/Tooling/Core/Diagnostic.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Core/Diagnostic.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Core/Replacement.h:43,Modifiability,refactor,refactoring,43,"//===- Replacement.h - Framework for clang refactoring tools ----*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // Classes supporting refactorings that span multiple translation units.; // While single translation unit refactorings are supported via the Rewriter,; // when refactoring multiple translation units changes must be stored in a; // SourceManager independent form, duplicate changes need to be removed, and; // all changes must be applied at once at the end of the refactoring so that; // the code is always parseable.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang/Tooling/Core/Replacement.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Core/Replacement.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Core/Replacement.h:402,Modifiability,refactor,refactorings,402,"//===- Replacement.h - Framework for clang refactoring tools ----*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // Classes supporting refactorings that span multiple translation units.; // While single translation unit refactorings are supported via the Rewriter,; // when refactoring multiple translation units changes must be stored in a; // SourceManager independent form, duplicate changes need to be removed, and; // all changes must be applied at once at the end of the refactoring so that; // the code is always parseable.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang/Tooling/Core/Replacement.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Core/Replacement.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Core/Replacement.h:487,Modifiability,refactor,refactorings,487,"//===- Replacement.h - Framework for clang refactoring tools ----*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // Classes supporting refactorings that span multiple translation units.; // While single translation unit refactorings are supported via the Rewriter,; // when refactoring multiple translation units changes must be stored in a; // SourceManager independent form, duplicate changes need to be removed, and; // all changes must be applied at once at the end of the refactoring so that; // the code is always parseable.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang/Tooling/Core/Replacement.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Core/Replacement.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Core/Replacement.h:522,Modifiability,Rewrite,Rewriter,522,"//===- Replacement.h - Framework for clang refactoring tools ----*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // Classes supporting refactorings that span multiple translation units.; // While single translation unit refactorings are supported via the Rewriter,; // when refactoring multiple translation units changes must be stored in a; // SourceManager independent form, duplicate changes need to be removed, and; // all changes must be applied at once at the end of the refactoring so that; // the code is always parseable.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang/Tooling/Core/Replacement.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Core/Replacement.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Core/Replacement.h:541,Modifiability,refactor,refactoring,541,"//===- Replacement.h - Framework for clang refactoring tools ----*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // Classes supporting refactorings that span multiple translation units.; // While single translation unit refactorings are supported via the Rewriter,; // when refactoring multiple translation units changes must be stored in a; // SourceManager independent form, duplicate changes need to be removed, and; // all changes must be applied at once at the end of the refactoring so that; // the code is always parseable.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang/Tooling/Core/Replacement.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Core/Replacement.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Core/Replacement.h:744,Modifiability,refactor,refactoring,744,"//===- Replacement.h - Framework for clang refactoring tools ----*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // Classes supporting refactorings that span multiple translation units.; // While single translation unit refactorings are supported via the Rewriter,; // when refactoring multiple translation units changes must be stored in a; // SourceManager independent form, duplicate changes need to be removed, and; // all changes must be applied at once at the end of the refactoring so that; // the code is always parseable.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang/Tooling/Core/Replacement.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Core/Replacement.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Core/Replacement.h:4,Security,Access,Accessors,4,/// Accessors.; /// @{,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang/Tooling/Core/Replacement.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Core/Replacement.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Core/Replacement.h:142,Security,access,accessible,142,"/// Creates a replacement of the range [Offset, Offset+Length) in; /// FilePath with ReplacementText.; ///; /// \param FilePath A source file accessible via a SourceManager.; /// \param Offset The byte offset of the start of the range in the file.; /// \param Length The length of the range in bytes.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang/Tooling/Core/Replacement.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Core/Replacement.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Core/Replacement.h:4,Security,Access,Accessors,4,/// Accessors.; /// @{,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang/Tooling/Core/Replacement.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Core/Replacement.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Core/Replacement.h:43,Modifiability,Rewrite,Rewriter,43,/// @}; /// Applies the replacement on the Rewriter.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang/Tooling/Core/Replacement.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Core/Replacement.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Core/Replacement.h:18,Availability,error,error,18,"/// Carries extra error information in replacement-related llvm::Error,; /// e.g. fail applying replacements and replacements conflict.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang/Tooling/Core/Replacement.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Core/Replacement.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Core/Replacement.h:65,Availability,Error,Error,65,"/// Carries extra error information in replacement-related llvm::Error,; /// e.g. fail applying replacements and replacements conflict.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang/Tooling/Core/Replacement.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Core/Replacement.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Core/Replacement.h:18,Availability,error,error,18,/// Constructs an error related to an existing replacement.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang/Tooling/Core/Replacement.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Core/Replacement.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Core/Replacement.h:18,Availability,error,error,18,/// Constructs an error related to a new replacement and an existing; /// replacement in a set of replacements.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang/Tooling/Core/Replacement.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Core/Replacement.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Core/Replacement.h:164,Integrability,depend,dependent,164,/// Maintains a set of replacements that are conflict-free.; /// Two replacements are considered conflicts if they overlap or have the same; /// offset (i.e. order-dependent).,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang/Tooling/Core/Replacement.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Core/Replacement.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Core/Replacement.h:241,Availability,Error,Error,241,"/// Adds a new replacement \p R to the current set of replacements.; /// \p R must have the same file path as all existing replacements.; /// Returns `success` if the replacement is successfully inserted; otherwise,; /// it returns an llvm::Error, i.e. there is a conflict between R and the; /// existing replacements (i.e. they are order-dependent) or R's file path is; /// different from the filepath of existing replacements. Callers must; /// explicitly check the Error returned, and the returned error can be; /// converted to a string message with `llvm::toString()`. This prevents users; /// from adding order-dependent replacements. To control the order in which; /// order-dependent replacements are applied, use merge({R}) with R referring; /// to the changed code after applying all existing replacements.; /// Two replacements A and B are considered order-independent if applying them; /// in either order produces the same result. Note that the range of the; /// replacement that is applied later still refers to the original code.; /// These include (but not restricted to) replacements that:; /// - don't overlap (being directly adjacent is fine) and; /// - are overlapping deletions.; /// - are insertions at the same offset and applying them in either order; /// has the same effect, i.e. X + Y = Y + X when inserting X and Y; /// respectively.; /// - are identical replacements, i.e. applying the same replacement twice; /// is equivalent to applying it once.; /// Examples:; /// 1. Replacement A(0, 0, ""a"") and B(0, 0, ""aa"") are order-independent since; /// applying them in either order gives replacement (0, 0, ""aaa"").; /// However, A(0, 0, ""a"") and B(0, 0, ""b"") are order-dependent since; /// applying A first gives (0, 0, ""ab"") while applying B first gives (B, A,; /// ""ba"").; /// 2. Replacement A(0, 2, ""123"") and B(0, 2, ""123"") are order-independent; /// since applying them in either order gives (0, 2, ""123"").; /// 3. Replacement A(0, 3, ""123"") and B(2, 3, ""321"") are order-",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang/Tooling/Core/Replacement.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Core/Replacement.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Core/Replacement.h:468,Availability,Error,Error,468,"/// Adds a new replacement \p R to the current set of replacements.; /// \p R must have the same file path as all existing replacements.; /// Returns `success` if the replacement is successfully inserted; otherwise,; /// it returns an llvm::Error, i.e. there is a conflict between R and the; /// existing replacements (i.e. they are order-dependent) or R's file path is; /// different from the filepath of existing replacements. Callers must; /// explicitly check the Error returned, and the returned error can be; /// converted to a string message with `llvm::toString()`. This prevents users; /// from adding order-dependent replacements. To control the order in which; /// order-dependent replacements are applied, use merge({R}) with R referring; /// to the changed code after applying all existing replacements.; /// Two replacements A and B are considered order-independent if applying them; /// in either order produces the same result. Note that the range of the; /// replacement that is applied later still refers to the original code.; /// These include (but not restricted to) replacements that:; /// - don't overlap (being directly adjacent is fine) and; /// - are overlapping deletions.; /// - are insertions at the same offset and applying them in either order; /// has the same effect, i.e. X + Y = Y + X when inserting X and Y; /// respectively.; /// - are identical replacements, i.e. applying the same replacement twice; /// is equivalent to applying it once.; /// Examples:; /// 1. Replacement A(0, 0, ""a"") and B(0, 0, ""aa"") are order-independent since; /// applying them in either order gives replacement (0, 0, ""aaa"").; /// However, A(0, 0, ""a"") and B(0, 0, ""b"") are order-dependent since; /// applying A first gives (0, 0, ""ab"") while applying B first gives (B, A,; /// ""ba"").; /// 2. Replacement A(0, 2, ""123"") and B(0, 2, ""123"") are order-independent; /// since applying them in either order gives (0, 2, ""123"").; /// 3. Replacement A(0, 3, ""123"") and B(2, 3, ""321"") are order-",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang/Tooling/Core/Replacement.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Core/Replacement.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Core/Replacement.h:501,Availability,error,error,501,"/// Adds a new replacement \p R to the current set of replacements.; /// \p R must have the same file path as all existing replacements.; /// Returns `success` if the replacement is successfully inserted; otherwise,; /// it returns an llvm::Error, i.e. there is a conflict between R and the; /// existing replacements (i.e. they are order-dependent) or R's file path is; /// different from the filepath of existing replacements. Callers must; /// explicitly check the Error returned, and the returned error can be; /// converted to a string message with `llvm::toString()`. This prevents users; /// from adding order-dependent replacements. To control the order in which; /// order-dependent replacements are applied, use merge({R}) with R referring; /// to the changed code after applying all existing replacements.; /// Two replacements A and B are considered order-independent if applying them; /// in either order produces the same result. Note that the range of the; /// replacement that is applied later still refers to the original code.; /// These include (but not restricted to) replacements that:; /// - don't overlap (being directly adjacent is fine) and; /// - are overlapping deletions.; /// - are insertions at the same offset and applying them in either order; /// has the same effect, i.e. X + Y = Y + X when inserting X and Y; /// respectively.; /// - are identical replacements, i.e. applying the same replacement twice; /// is equivalent to applying it once.; /// Examples:; /// 1. Replacement A(0, 0, ""a"") and B(0, 0, ""aa"") are order-independent since; /// applying them in either order gives replacement (0, 0, ""aaa"").; /// However, A(0, 0, ""a"") and B(0, 0, ""b"") are order-dependent since; /// applying A first gives (0, 0, ""ab"") while applying B first gives (B, A,; /// ""ba"").; /// 2. Replacement A(0, 2, ""123"") and B(0, 2, ""123"") are order-independent; /// since applying them in either order gives (0, 2, ""123"").; /// 3. Replacement A(0, 3, ""123"") and B(2, 3, ""321"") are order-",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang/Tooling/Core/Replacement.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Core/Replacement.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Core/Replacement.h:339,Integrability,depend,dependent,339,"/// Adds a new replacement \p R to the current set of replacements.; /// \p R must have the same file path as all existing replacements.; /// Returns `success` if the replacement is successfully inserted; otherwise,; /// it returns an llvm::Error, i.e. there is a conflict between R and the; /// existing replacements (i.e. they are order-dependent) or R's file path is; /// different from the filepath of existing replacements. Callers must; /// explicitly check the Error returned, and the returned error can be; /// converted to a string message with `llvm::toString()`. This prevents users; /// from adding order-dependent replacements. To control the order in which; /// order-dependent replacements are applied, use merge({R}) with R referring; /// to the changed code after applying all existing replacements.; /// Two replacements A and B are considered order-independent if applying them; /// in either order produces the same result. Note that the range of the; /// replacement that is applied later still refers to the original code.; /// These include (but not restricted to) replacements that:; /// - don't overlap (being directly adjacent is fine) and; /// - are overlapping deletions.; /// - are insertions at the same offset and applying them in either order; /// has the same effect, i.e. X + Y = Y + X when inserting X and Y; /// respectively.; /// - are identical replacements, i.e. applying the same replacement twice; /// is equivalent to applying it once.; /// Examples:; /// 1. Replacement A(0, 0, ""a"") and B(0, 0, ""aa"") are order-independent since; /// applying them in either order gives replacement (0, 0, ""aaa"").; /// However, A(0, 0, ""a"") and B(0, 0, ""b"") are order-dependent since; /// applying A first gives (0, 0, ""ab"") while applying B first gives (B, A,; /// ""ba"").; /// 2. Replacement A(0, 2, ""123"") and B(0, 2, ""123"") are order-independent; /// since applying them in either order gives (0, 2, ""123"").; /// 3. Replacement A(0, 3, ""123"") and B(2, 3, ""321"") are order-",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang/Tooling/Core/Replacement.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Core/Replacement.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Core/Replacement.h:541,Integrability,message,message,541,"/// Adds a new replacement \p R to the current set of replacements.; /// \p R must have the same file path as all existing replacements.; /// Returns `success` if the replacement is successfully inserted; otherwise,; /// it returns an llvm::Error, i.e. there is a conflict between R and the; /// existing replacements (i.e. they are order-dependent) or R's file path is; /// different from the filepath of existing replacements. Callers must; /// explicitly check the Error returned, and the returned error can be; /// converted to a string message with `llvm::toString()`. This prevents users; /// from adding order-dependent replacements. To control the order in which; /// order-dependent replacements are applied, use merge({R}) with R referring; /// to the changed code after applying all existing replacements.; /// Two replacements A and B are considered order-independent if applying them; /// in either order produces the same result. Note that the range of the; /// replacement that is applied later still refers to the original code.; /// These include (but not restricted to) replacements that:; /// - don't overlap (being directly adjacent is fine) and; /// - are overlapping deletions.; /// - are insertions at the same offset and applying them in either order; /// has the same effect, i.e. X + Y = Y + X when inserting X and Y; /// respectively.; /// - are identical replacements, i.e. applying the same replacement twice; /// is equivalent to applying it once.; /// Examples:; /// 1. Replacement A(0, 0, ""a"") and B(0, 0, ""aa"") are order-independent since; /// applying them in either order gives replacement (0, 0, ""aaa"").; /// However, A(0, 0, ""a"") and B(0, 0, ""b"") are order-dependent since; /// applying A first gives (0, 0, ""ab"") while applying B first gives (B, A,; /// ""ba"").; /// 2. Replacement A(0, 2, ""123"") and B(0, 2, ""123"") are order-independent; /// since applying them in either order gives (0, 2, ""123"").; /// 3. Replacement A(0, 3, ""123"") and B(2, 3, ""321"") are order-",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang/Tooling/Core/Replacement.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Core/Replacement.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Core/Replacement.h:617,Integrability,depend,dependent,617,"/// Adds a new replacement \p R to the current set of replacements.; /// \p R must have the same file path as all existing replacements.; /// Returns `success` if the replacement is successfully inserted; otherwise,; /// it returns an llvm::Error, i.e. there is a conflict between R and the; /// existing replacements (i.e. they are order-dependent) or R's file path is; /// different from the filepath of existing replacements. Callers must; /// explicitly check the Error returned, and the returned error can be; /// converted to a string message with `llvm::toString()`. This prevents users; /// from adding order-dependent replacements. To control the order in which; /// order-dependent replacements are applied, use merge({R}) with R referring; /// to the changed code after applying all existing replacements.; /// Two replacements A and B are considered order-independent if applying them; /// in either order produces the same result. Note that the range of the; /// replacement that is applied later still refers to the original code.; /// These include (but not restricted to) replacements that:; /// - don't overlap (being directly adjacent is fine) and; /// - are overlapping deletions.; /// - are insertions at the same offset and applying them in either order; /// has the same effect, i.e. X + Y = Y + X when inserting X and Y; /// respectively.; /// - are identical replacements, i.e. applying the same replacement twice; /// is equivalent to applying it once.; /// Examples:; /// 1. Replacement A(0, 0, ""a"") and B(0, 0, ""aa"") are order-independent since; /// applying them in either order gives replacement (0, 0, ""aaa"").; /// However, A(0, 0, ""a"") and B(0, 0, ""b"") are order-dependent since; /// applying A first gives (0, 0, ""ab"") while applying B first gives (B, A,; /// ""ba"").; /// 2. Replacement A(0, 2, ""123"") and B(0, 2, ""123"") are order-independent; /// since applying them in either order gives (0, 2, ""123"").; /// 3. Replacement A(0, 3, ""123"") and B(2, 3, ""321"") are order-",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang/Tooling/Core/Replacement.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Core/Replacement.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Core/Replacement.h:682,Integrability,depend,dependent,682,"/// Adds a new replacement \p R to the current set of replacements.; /// \p R must have the same file path as all existing replacements.; /// Returns `success` if the replacement is successfully inserted; otherwise,; /// it returns an llvm::Error, i.e. there is a conflict between R and the; /// existing replacements (i.e. they are order-dependent) or R's file path is; /// different from the filepath of existing replacements. Callers must; /// explicitly check the Error returned, and the returned error can be; /// converted to a string message with `llvm::toString()`. This prevents users; /// from adding order-dependent replacements. To control the order in which; /// order-dependent replacements are applied, use merge({R}) with R referring; /// to the changed code after applying all existing replacements.; /// Two replacements A and B are considered order-independent if applying them; /// in either order produces the same result. Note that the range of the; /// replacement that is applied later still refers to the original code.; /// These include (but not restricted to) replacements that:; /// - don't overlap (being directly adjacent is fine) and; /// - are overlapping deletions.; /// - are insertions at the same offset and applying them in either order; /// has the same effect, i.e. X + Y = Y + X when inserting X and Y; /// respectively.; /// - are identical replacements, i.e. applying the same replacement twice; /// is equivalent to applying it once.; /// Examples:; /// 1. Replacement A(0, 0, ""a"") and B(0, 0, ""aa"") are order-independent since; /// applying them in either order gives replacement (0, 0, ""aaa"").; /// However, A(0, 0, ""a"") and B(0, 0, ""b"") are order-dependent since; /// applying A first gives (0, 0, ""ab"") while applying B first gives (B, A,; /// ""ba"").; /// 2. Replacement A(0, 2, ""123"") and B(0, 2, ""123"") are order-independent; /// since applying them in either order gives (0, 2, ""123"").; /// 3. Replacement A(0, 3, ""123"") and B(2, 3, ""321"") are order-",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang/Tooling/Core/Replacement.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Core/Replacement.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Core/Replacement.h:1694,Integrability,depend,dependent,1694," existing replacements. Callers must; /// explicitly check the Error returned, and the returned error can be; /// converted to a string message with `llvm::toString()`. This prevents users; /// from adding order-dependent replacements. To control the order in which; /// order-dependent replacements are applied, use merge({R}) with R referring; /// to the changed code after applying all existing replacements.; /// Two replacements A and B are considered order-independent if applying them; /// in either order produces the same result. Note that the range of the; /// replacement that is applied later still refers to the original code.; /// These include (but not restricted to) replacements that:; /// - don't overlap (being directly adjacent is fine) and; /// - are overlapping deletions.; /// - are insertions at the same offset and applying them in either order; /// has the same effect, i.e. X + Y = Y + X when inserting X and Y; /// respectively.; /// - are identical replacements, i.e. applying the same replacement twice; /// is equivalent to applying it once.; /// Examples:; /// 1. Replacement A(0, 0, ""a"") and B(0, 0, ""aa"") are order-independent since; /// applying them in either order gives replacement (0, 0, ""aaa"").; /// However, A(0, 0, ""a"") and B(0, 0, ""b"") are order-dependent since; /// applying A first gives (0, 0, ""ab"") while applying B first gives (B, A,; /// ""ba"").; /// 2. Replacement A(0, 2, ""123"") and B(0, 2, ""123"") are order-independent; /// since applying them in either order gives (0, 2, ""123"").; /// 3. Replacement A(0, 3, ""123"") and B(2, 3, ""321"") are order-independent; /// since either order gives (0, 5, ""12321"").; /// 4. Replacement A(0, 3, ""ab"") and B(0, 3, ""ab"") are order-independent since; /// applying the same replacement twice is equivalent to applying it once.; /// Replacements with offset UINT_MAX are special - we do not detect conflicts; /// for such replacements since users may add them intentionally as a special; /// category of replacements.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang/Tooling/Core/Replacement.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Core/Replacement.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Core/Replacement.h:2279,Safety,detect,detect,2279," existing replacements. Callers must; /// explicitly check the Error returned, and the returned error can be; /// converted to a string message with `llvm::toString()`. This prevents users; /// from adding order-dependent replacements. To control the order in which; /// order-dependent replacements are applied, use merge({R}) with R referring; /// to the changed code after applying all existing replacements.; /// Two replacements A and B are considered order-independent if applying them; /// in either order produces the same result. Note that the range of the; /// replacement that is applied later still refers to the original code.; /// These include (but not restricted to) replacements that:; /// - don't overlap (being directly adjacent is fine) and; /// - are overlapping deletions.; /// - are insertions at the same offset and applying them in either order; /// has the same effect, i.e. X + Y = Y + X when inserting X and Y; /// respectively.; /// - are identical replacements, i.e. applying the same replacement twice; /// is equivalent to applying it once.; /// Examples:; /// 1. Replacement A(0, 0, ""a"") and B(0, 0, ""aa"") are order-independent since; /// applying them in either order gives replacement (0, 0, ""aaa"").; /// However, A(0, 0, ""a"") and B(0, 0, ""b"") are order-dependent since; /// applying A first gives (0, 0, ""ab"") while applying B first gives (B, A,; /// ""ba"").; /// 2. Replacement A(0, 2, ""123"") and B(0, 2, ""123"") are order-independent; /// since applying them in either order gives (0, 2, ""123"").; /// 3. Replacement A(0, 3, ""123"") and B(2, 3, ""321"") are order-independent; /// since either order gives (0, 5, ""12321"").; /// 4. Replacement A(0, 3, ""ab"") and B(0, 3, ""ab"") are order-independent since; /// applying the same replacement twice is equivalent to applying it once.; /// Replacements with offset UINT_MAX are special - we do not detect conflicts; /// for such replacements since users may add them intentionally as a special; /// category of replacements.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang/Tooling/Core/Replacement.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Core/Replacement.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Core/Replacement.h:160,Availability,error,error,160,"// If `R` and all existing replacements are order-independent, then merge it; // with `Replaces` and returns the merged replacements; otherwise, returns an; // error.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang/Tooling/Core/Replacement.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Core/Replacement.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Core/Replacement.h:49,Modifiability,Rewrite,Rewriter,49,/// Apply all replacements in \p Replaces to the Rewriter \p Rewrite.; ///; /// Replacement applications happen independently of the success of; /// other applications.; ///; /// \returns true if all replacements apply. false otherwise.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang/Tooling/Core/Replacement.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Core/Replacement.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Core/Replacement.h:61,Modifiability,Rewrite,Rewrite,61,/// Apply all replacements in \p Replaces to the Rewriter \p Rewrite.; ///; /// Replacement applications happen independently of the success of; /// other applications.; ///; /// \returns true if all replacements apply. false otherwise.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang/Tooling/Core/Replacement.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Core/Replacement.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Core/Replacement.h:252,Availability,Error,Error,252,"/// Applies all replacements in \p Replaces to \p Code.; ///; /// This completely ignores the path stored in each replacement. If all; /// replacements are applied successfully, this returns the code with; /// replacements applied; otherwise, an llvm::Error carrying llvm::StringError; /// is returned (the Error message can be converted to string using; /// `llvm::toString()` and 'std::error_code` in the `Error` should be ignored).",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang/Tooling/Core/Replacement.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Core/Replacement.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Core/Replacement.h:307,Availability,Error,Error,307,"/// Applies all replacements in \p Replaces to \p Code.; ///; /// This completely ignores the path stored in each replacement. If all; /// replacements are applied successfully, this returns the code with; /// replacements applied; otherwise, an llvm::Error carrying llvm::StringError; /// is returned (the Error message can be converted to string using; /// `llvm::toString()` and 'std::error_code` in the `Error` should be ignored).",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang/Tooling/Core/Replacement.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Core/Replacement.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Core/Replacement.h:408,Availability,Error,Error,408,"/// Applies all replacements in \p Replaces to \p Code.; ///; /// This completely ignores the path stored in each replacement. If all; /// replacements are applied successfully, this returns the code with; /// replacements applied; otherwise, an llvm::Error carrying llvm::StringError; /// is returned (the Error message can be converted to string using; /// `llvm::toString()` and 'std::error_code` in the `Error` should be ignored).",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang/Tooling/Core/Replacement.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Core/Replacement.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Core/Replacement.h:313,Integrability,message,message,313,"/// Applies all replacements in \p Replaces to \p Code.; ///; /// This completely ignores the path stored in each replacement. If all; /// replacements are applied successfully, this returns the code with; /// replacements applied; otherwise, an llvm::Error carrying llvm::StringError; /// is returned (the Error message can be converted to string using; /// `llvm::toString()` and 'std::error_code` in the `Error` should be ignored).",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang/Tooling/Core/Replacement.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Core/Replacement.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/DependencyScanning/DependencyScanningFilesystem.h:7,Integrability,Depend,DependencyScanningFilesystem,7,"//===- DependencyScanningFilesystem.h - clang-scan-deps fs ===---*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang/Tooling/DependencyScanning/DependencyScanningFilesystem.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/DependencyScanning/DependencyScanningFilesystem.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/DependencyScanning/DependencyScanningFilesystem.h:39,Performance,cache,cached,39,/// Contents and directive tokens of a cached file entry. Single instance can; /// be shared between multiple entries.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang/Tooling/DependencyScanning/DependencyScanningFilesystem.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/DependencyScanning/DependencyScanningFilesystem.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/DependencyScanning/DependencyScanningFilesystem.h:80,Performance,Cache,CachedFileContents,80,/// Accessor to the directive tokens that's atomic to avoid data races.; /// \p CachedFileContents has ownership of the pointer.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang/Tooling/DependencyScanning/DependencyScanningFilesystem.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/DependencyScanning/DependencyScanningFilesystem.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/DependencyScanning/DependencyScanningFilesystem.h:54,Safety,avoid,avoid,54,/// Accessor to the directive tokens that's atomic to avoid data races.; /// \p CachedFileContents has ownership of the pointer.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang/Tooling/DependencyScanning/DependencyScanningFilesystem.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/DependencyScanning/DependencyScanningFilesystem.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/DependencyScanning/DependencyScanningFilesystem.h:4,Security,Access,Accessor,4,/// Accessor to the directive tokens that's atomic to avoid data races.; /// \p CachedFileContents has ownership of the pointer.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang/Tooling/DependencyScanning/DependencyScanningFilesystem.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/DependencyScanning/DependencyScanningFilesystem.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/DependencyScanning/DependencyScanningFilesystem.h:348,Availability,error,error,348,"/// An in-memory representation of a file system entity that is of interest to; /// the dependency scanning filesystem.; ///; /// It represents one of the following:; /// - opened file with contents and a stat value,; /// - opened file with contents, directive tokens and a stat value,; /// - directory entry with its stat value,; /// - filesystem error.; ///; /// Single instance of this class can be shared across different filenames (e.g.; /// a regular file and a symlink). For this reason the status filename is empty; /// and is only materialized by \c EntryRef that knows the requested filename.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang/Tooling/DependencyScanning/DependencyScanningFilesystem.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/DependencyScanning/DependencyScanningFilesystem.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/DependencyScanning/DependencyScanningFilesystem.h:88,Integrability,depend,dependency,88,"/// An in-memory representation of a file system entity that is of interest to; /// the dependency scanning filesystem.; ///; /// It represents one of the following:; /// - opened file with contents and a stat value,; /// - opened file with contents, directive tokens and a stat value,; /// - directory entry with its stat value,; /// - filesystem error.; ///; /// Single instance of this class can be shared across different filenames (e.g.; /// a regular file and a symlink). For this reason the status filename is empty; /// and is only materialized by \c EntryRef that knows the requested filename.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang/Tooling/DependencyScanning/DependencyScanningFilesystem.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/DependencyScanning/DependencyScanningFilesystem.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/DependencyScanning/DependencyScanningFilesystem.h:59,Availability,error,error,59,/// Creates an entry without contents: either a filesystem error or; /// a directory with stat value.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang/Tooling/DependencyScanning/DependencyScanningFilesystem.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/DependencyScanning/DependencyScanningFilesystem.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/DependencyScanning/DependencyScanningFilesystem.h:47,Availability,error,error,47,/// \returns True if the entry is a filesystem error.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang/Tooling/DependencyScanning/DependencyScanningFilesystem.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/DependencyScanning/DependencyScanningFilesystem.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/DependencyScanning/DependencyScanningFilesystem.h:116,Availability,avail,available,116,"/// \returns The scanned preprocessor directive tokens of the file that are; /// used to speed up preprocessing, if available.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang/Tooling/DependencyScanning/DependencyScanningFilesystem.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/DependencyScanning/DependencyScanningFilesystem.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/DependencyScanning/DependencyScanningFilesystem.h:17,Availability,error,error,17,/// \returns The error.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang/Tooling/DependencyScanning/DependencyScanningFilesystem.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/DependencyScanning/DependencyScanningFilesystem.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/DependencyScanning/DependencyScanningFilesystem.h:26,Availability,error,error,26,/// Either the filesystem error or status of the entry.; /// The filename is empty and only materialized by \c EntryRef.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang/Tooling/DependencyScanning/DependencyScanningFilesystem.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/DependencyScanning/DependencyScanningFilesystem.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/DependencyScanning/DependencyScanningFilesystem.h:173,Availability,error,errors,173,/// Non-owning pointer to the file contents.; ///; /// We're using pointer here to keep the size of this class small. Instances; /// representing directories and filesystem errors don't hold any contents; /// anyway.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang/Tooling/DependencyScanning/DependencyScanningFilesystem.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/DependencyScanning/DependencyScanningFilesystem.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/DependencyScanning/DependencyScanningFilesystem.h:226,Energy Efficiency,reduce,reduce,226,"/// This class is a shared cache, that caches the 'stat' and 'open' calls to the; /// underlying real file system, and the scanned preprocessor directives of; /// files.; ///; /// It is sharded based on the hash of the key to reduce the lock contention for; /// the worker threads.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang/Tooling/DependencyScanning/DependencyScanningFilesystem.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/DependencyScanning/DependencyScanningFilesystem.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/DependencyScanning/DependencyScanningFilesystem.h:27,Performance,cache,cache,27,"/// This class is a shared cache, that caches the 'stat' and 'open' calls to the; /// underlying real file system, and the scanned preprocessor directives of; /// files.; ///; /// It is sharded based on the hash of the key to reduce the lock contention for; /// the worker threads.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang/Tooling/DependencyScanning/DependencyScanningFilesystem.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/DependencyScanning/DependencyScanningFilesystem.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/DependencyScanning/DependencyScanningFilesystem.h:39,Performance,cache,caches,39,"/// This class is a shared cache, that caches the 'stat' and 'open' calls to the; /// underlying real file system, and the scanned preprocessor directives of; /// files.; ///; /// It is sharded based on the hash of the key to reduce the lock contention for; /// the worker threads.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang/Tooling/DependencyScanning/DependencyScanningFilesystem.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/DependencyScanning/DependencyScanningFilesystem.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/DependencyScanning/DependencyScanningFilesystem.h:207,Security,hash,hash,207,"/// This class is a shared cache, that caches the 'stat' and 'open' calls to the; /// underlying real file system, and the scanned preprocessor directives of; /// files.; ///; /// It is sharded based on the hash of the key to reduce the lock contention for; /// the worker threads.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang/Tooling/DependencyScanning/DependencyScanningFilesystem.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/DependencyScanning/DependencyScanningFilesystem.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/DependencyScanning/DependencyScanningFilesystem.h:26,Performance,cache,cached,26,/// Map from filenames to cached entries.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang/Tooling/DependencyScanning/DependencyScanningFilesystem.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/DependencyScanning/DependencyScanningFilesystem.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/DependencyScanning/DependencyScanningFilesystem.h:27,Performance,cache,cached,27,/// Map from unique IDs to cached entries.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang/Tooling/DependencyScanning/DependencyScanningFilesystem.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/DependencyScanning/DependencyScanningFilesystem.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/DependencyScanning/DependencyScanningFilesystem.h:28,Performance,cache,cached,28,/// The backing storage for cached entries.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang/Tooling/DependencyScanning/DependencyScanningFilesystem.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/DependencyScanning/DependencyScanningFilesystem.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/DependencyScanning/DependencyScanningFilesystem.h:28,Performance,cache,cached,28,/// The backing storage for cached contents.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang/Tooling/DependencyScanning/DependencyScanningFilesystem.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/DependencyScanning/DependencyScanningFilesystem.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/DependencyScanning/DependencyScanningFilesystem.h:26,Performance,cache,cache,26,"/// This class is a local cache, that caches the 'stat' and 'open' calls to the; /// underlying real file system.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang/Tooling/DependencyScanning/DependencyScanningFilesystem.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/DependencyScanning/DependencyScanningFilesystem.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/DependencyScanning/DependencyScanningFilesystem.h:38,Performance,cache,caches,38,"/// This class is a local cache, that caches the 'stat' and 'open' calls to the; /// underlying real file system.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang/Tooling/DependencyScanning/DependencyScanningFilesystem.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/DependencyScanning/DependencyScanningFilesystem.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/DependencyScanning/DependencyScanningFilesystem.h:95,Integrability,wrap,wrapper,95,"/// Reference to a CachedFileSystemEntry.; /// If the underlying entry is an opened file, this wrapper returns the file; /// contents and the scanned preprocessor directives.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang/Tooling/DependencyScanning/DependencyScanningFilesystem.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/DependencyScanning/DependencyScanningFilesystem.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/DependencyScanning/DependencyScanningFilesystem.h:19,Performance,Cache,CachedFileSystemEntry,19,"/// Reference to a CachedFileSystemEntry.; /// If the underlying entry is an opened file, this wrapper returns the file; /// contents and the scanned preprocessor directives.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang/Tooling/DependencyScanning/DependencyScanningFilesystem.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/DependencyScanning/DependencyScanningFilesystem.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/DependencyScanning/DependencyScanningFilesystem.h:25,Security,access,access,25,/// The filename used to access this entry.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang/Tooling/DependencyScanning/DependencyScanningFilesystem.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/DependencyScanning/DependencyScanningFilesystem.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/DependencyScanning/DependencyScanningFilesystem.h:19,Performance,cache,cached,19,/// The underlying cached entry.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang/Tooling/DependencyScanning/DependencyScanningFilesystem.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/DependencyScanning/DependencyScanningFilesystem.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/DependencyScanning/DependencyScanningFilesystem.h:38,Availability,error,error,38,"/// If the cached entry represents an error, promotes it into `ErrorOr`.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang/Tooling/DependencyScanning/DependencyScanningFilesystem.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/DependencyScanning/DependencyScanningFilesystem.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/DependencyScanning/DependencyScanningFilesystem.h:63,Availability,Error,ErrorOr,63,"/// If the cached entry represents an error, promotes it into `ErrorOr`.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang/Tooling/DependencyScanning/DependencyScanningFilesystem.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/DependencyScanning/DependencyScanningFilesystem.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/DependencyScanning/DependencyScanningFilesystem.h:11,Performance,cache,cached,11,"/// If the cached entry represents an error, promotes it into `ErrorOr`.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang/Tooling/DependencyScanning/DependencyScanningFilesystem.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/DependencyScanning/DependencyScanningFilesystem.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/DependencyScanning/DependencyScanningFilesystem.h:44,Integrability,depend,dependency,44,/// A virtual file system optimized for the dependency discovery.; ///; /// It is primarily designed to work with source files whose contents was; /// preprocessed to remove any tokens that are unlikely to affect the dependency; /// computation.; ///; /// This is not a thread safe VFS. A single instance is meant to be used only in; /// one thread. Multiple instances are allowed to service multiple threads; /// running in parallel.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang/Tooling/DependencyScanning/DependencyScanningFilesystem.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/DependencyScanning/DependencyScanningFilesystem.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/DependencyScanning/DependencyScanningFilesystem.h:217,Integrability,depend,dependency,217,/// A virtual file system optimized for the dependency discovery.; ///; /// It is primarily designed to work with source files whose contents was; /// preprocessed to remove any tokens that are unlikely to affect the dependency; /// computation.; ///; /// This is not a thread safe VFS. A single instance is meant to be used only in; /// one thread. Multiple instances are allowed to service multiple threads; /// running in parallel.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang/Tooling/DependencyScanning/DependencyScanningFilesystem.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/DependencyScanning/DependencyScanningFilesystem.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/DependencyScanning/DependencyScanningFilesystem.h:26,Performance,optimiz,optimized,26,/// A virtual file system optimized for the dependency discovery.; ///; /// It is primarily designed to work with source files whose contents was; /// preprocessed to remove any tokens that are unlikely to affect the dependency; /// computation.; ///; /// This is not a thread safe VFS. A single instance is meant to be used only in; /// one thread. Multiple instances are allowed to service multiple threads; /// running in parallel.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang/Tooling/DependencyScanning/DependencyScanningFilesystem.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/DependencyScanning/DependencyScanningFilesystem.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/DependencyScanning/DependencyScanningFilesystem.h:277,Safety,safe,safe,277,/// A virtual file system optimized for the dependency discovery.; ///; /// It is primarily designed to work with source files whose contents was; /// preprocessed to remove any tokens that are unlikely to affect the dependency; /// computation.; ///; /// This is not a thread safe VFS. A single instance is meant to be used only in; /// one thread. Multiple instances are allowed to service multiple threads; /// running in parallel.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang/Tooling/DependencyScanning/DependencyScanningFilesystem.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/DependencyScanning/DependencyScanningFilesystem.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/DependencyScanning/DependencyScanningFilesystem.h:89,Performance,cache,caches,89,"/// Returns entry for the given filename.; ///; /// Attempts to use the local and shared caches first, then falls back to; /// using the underlying filesystem.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang/Tooling/DependencyScanning/DependencyScanningFilesystem.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/DependencyScanning/DependencyScanningFilesystem.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/DependencyScanning/DependencyScanningFilesystem.h:67,Performance,cache,caches,67,"/// For a filename that's not yet associated with any entry in the caches,; /// uses the underlying filesystem to either look up the entry based in the; /// shared cache indexed by unique ID, or creates new entry from scratch.; /// \p FilenameForLookup will always be an absolute path, and different than; /// \p OriginalFilename if \p OriginalFilename is relative.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang/Tooling/DependencyScanning/DependencyScanningFilesystem.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/DependencyScanning/DependencyScanningFilesystem.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/DependencyScanning/DependencyScanningFilesystem.h:164,Performance,cache,cache,164,"/// For a filename that's not yet associated with any entry in the caches,; /// uses the underlying filesystem to either look up the entry based in the; /// shared cache indexed by unique ID, or creates new entry from scratch.; /// \p FilenameForLookup will always be an absolute path, and different than; /// \p OriginalFilename if \p OriginalFilename is relative.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang/Tooling/DependencyScanning/DependencyScanningFilesystem.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/DependencyScanning/DependencyScanningFilesystem.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/DependencyScanning/DependencyScanningFilesystem.h:89,Integrability,wrap,wrapper,89,/// Scan for preprocessor directives for the given entry if necessary and; /// returns a wrapper object with reference semantics.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang/Tooling/DependencyScanning/DependencyScanningFilesystem.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/DependencyScanning/DependencyScanningFilesystem.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/DependencyScanning/DependencyScanningFilesystem.h:125,Performance,cache,cache,125,/// Represents a filesystem entry that has been stat-ed (and potentially read); /// and that's about to be inserted into the cache as `CachedFileSystemEntry`.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang/Tooling/DependencyScanning/DependencyScanningFilesystem.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/DependencyScanning/DependencyScanningFilesystem.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/DependencyScanning/DependencyScanningFilesystem.h:135,Performance,Cache,CachedFileSystemEntry,135,/// Represents a filesystem entry that has been stat-ed (and potentially read); /// and that's about to be inserted into the cache as `CachedFileSystemEntry`.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang/Tooling/DependencyScanning/DependencyScanningFilesystem.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/DependencyScanning/DependencyScanningFilesystem.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/DependencyScanning/DependencyScanningFilesystem.h:113,Performance,cache,cache,113,"/// Returns entry associated with the unique ID of the given tentative entry; /// if there is some in the shared cache. Otherwise, constructs new one,; /// associates it with the unique ID and returns the result.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang/Tooling/DependencyScanning/DependencyScanningFilesystem.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/DependencyScanning/DependencyScanningFilesystem.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/DependencyScanning/DependencyScanningFilesystem.h:111,Performance,cache,cache,111,"/// Returns entry associated with the filename or nullptr if none is found.; ///; /// Returns entry from local cache if there is some. Otherwise, if the entry; /// is found in the shared cache, writes it through the local cache and; /// returns it. Otherwise returns nullptr.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang/Tooling/DependencyScanning/DependencyScanningFilesystem.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/DependencyScanning/DependencyScanningFilesystem.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/DependencyScanning/DependencyScanningFilesystem.h:187,Performance,cache,cache,187,"/// Returns entry associated with the filename or nullptr if none is found.; ///; /// Returns entry from local cache if there is some. Otherwise, if the entry; /// is found in the shared cache, writes it through the local cache and; /// returns it. Otherwise returns nullptr.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang/Tooling/DependencyScanning/DependencyScanningFilesystem.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/DependencyScanning/DependencyScanningFilesystem.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/DependencyScanning/DependencyScanningFilesystem.h:222,Performance,cache,cache,222,"/// Returns entry associated with the filename or nullptr if none is found.; ///; /// Returns entry from local cache if there is some. Otherwise, if the entry; /// is found in the shared cache, writes it through the local cache and; /// returns it. Otherwise returns nullptr.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang/Tooling/DependencyScanning/DependencyScanningFilesystem.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/DependencyScanning/DependencyScanningFilesystem.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/DependencyScanning/DependencyScanningFilesystem.h:62,Performance,cache,cache,62,/// Returns entry associated with the unique ID in the shared cache or nullptr; /// if none is found.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang/Tooling/DependencyScanning/DependencyScanningFilesystem.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/DependencyScanning/DependencyScanningFilesystem.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/DependencyScanning/DependencyScanningFilesystem.h:62,Performance,cache,cache,62,/// Associates the given entry with the filename in the local cache and; /// returns it.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang/Tooling/DependencyScanning/DependencyScanningFilesystem.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/DependencyScanning/DependencyScanningFilesystem.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/DependencyScanning/DependencyScanningFilesystem.h:135,Availability,error,error,135,"/// Returns entry associated with the filename in the shared cache if there is; /// some. Otherwise, constructs new one with the given error code, associates; /// it with the filename and returns the result.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang/Tooling/DependencyScanning/DependencyScanningFilesystem.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/DependencyScanning/DependencyScanningFilesystem.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/DependencyScanning/DependencyScanningFilesystem.h:61,Performance,cache,cache,61,"/// Returns entry associated with the filename in the shared cache if there is; /// some. Otherwise, constructs new one with the given error code, associates; /// it with the filename and returns the result.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang/Tooling/DependencyScanning/DependencyScanningFilesystem.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/DependencyScanning/DependencyScanningFilesystem.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/DependencyScanning/DependencyScanningFilesystem.h:61,Performance,cache,cache,61,"/// Returns entry associated with the filename in the shared cache if there is; /// some. Otherwise, associates the given entry with the filename and returns; /// it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang/Tooling/DependencyScanning/DependencyScanningFilesystem.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/DependencyScanning/DependencyScanningFilesystem.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/DependencyScanning/DependencyScanningFilesystem.h:15,Performance,cache,cache,15,/// The global cache shared between worker threads.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang/Tooling/DependencyScanning/DependencyScanningFilesystem.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/DependencyScanning/DependencyScanningFilesystem.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/DependencyScanning/DependencyScanningFilesystem.h:14,Performance,cache,cache,14,/// The local cache is used by the worker thread to cache file system queries; /// locally instead of querying the global cache every time.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang/Tooling/DependencyScanning/DependencyScanningFilesystem.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/DependencyScanning/DependencyScanningFilesystem.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/DependencyScanning/DependencyScanningFilesystem.h:52,Performance,cache,cache,52,/// The local cache is used by the worker thread to cache file system queries; /// locally instead of querying the global cache every time.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang/Tooling/DependencyScanning/DependencyScanningFilesystem.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/DependencyScanning/DependencyScanningFilesystem.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/DependencyScanning/DependencyScanningFilesystem.h:122,Performance,cache,cache,122,/// The local cache is used by the worker thread to cache file system queries; /// locally instead of querying the global cache every time.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang/Tooling/DependencyScanning/DependencyScanningFilesystem.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/DependencyScanning/DependencyScanningFilesystem.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/DependencyScanning/DependencyScanningFilesystem.h:95,Performance,cache,cache,95,/// The working directory to use for making relative paths absolute before; /// using them for cache lookups.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang/Tooling/DependencyScanning/DependencyScanningFilesystem.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/DependencyScanning/DependencyScanningFilesystem.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/DependencyScanning/DependencyScanningFilesystem.h:17,Integrability,depend,dependencies,17,// end namespace dependencies,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang/Tooling/DependencyScanning/DependencyScanningFilesystem.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/DependencyScanning/DependencyScanningFilesystem.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/DependencyScanning/DependencyScanningService.h:7,Integrability,Depend,DependencyScanningService,7,"//===- DependencyScanningService.h - clang-scan-deps service ===-*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang/Tooling/DependencyScanning/DependencyScanningService.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/DependencyScanning/DependencyScanningService.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/DependencyScanning/DependencyScanningService.h:26,Integrability,depend,dependency,26,/// The mode in which the dependency scanner will operate to find the; /// dependencies.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang/Tooling/DependencyScanning/DependencyScanningService.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/DependencyScanning/DependencyScanningService.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/DependencyScanning/DependencyScanningService.h:75,Integrability,depend,dependencies,75,/// The mode in which the dependency scanner will operate to find the; /// dependencies.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang/Tooling/DependencyScanning/DependencyScanningService.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/DependencyScanning/DependencyScanningService.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/DependencyScanning/DependencyScanningService.h:37,Integrability,depend,dependencies,37,/// This mode is used to compute the dependencies by running the preprocessor; /// over the source files.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang/Tooling/DependencyScanning/DependencyScanningService.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/DependencyScanning/DependencyScanningService.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/DependencyScanning/DependencyScanningService.h:37,Integrability,depend,dependencies,37,/// This mode is used to compute the dependencies by running the preprocessor; /// with special kind of lexing after scanning header and source files to get; /// the minimum necessary preprocessor directives for evaluating includes.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang/Tooling/DependencyScanning/DependencyScanningService.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/DependencyScanning/DependencyScanningService.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/DependencyScanning/DependencyScanningService.h:37,Integrability,depend,dependency,37,/// The format that is output by the dependency scanner.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang/Tooling/DependencyScanning/DependencyScanningService.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/DependencyScanning/DependencyScanningService.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/DependencyScanning/DependencyScanningService.h:167,Integrability,depend,dependency,167,"/// This is the Makefile compatible dep format. This will include all of the; /// deps necessary for an implicit modules build, but won't include any; /// intermodule dependency information.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang/Tooling/DependencyScanning/DependencyScanningService.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/DependencyScanning/DependencyScanningService.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/DependencyScanning/DependencyScanningService.h:39,Integrability,depend,dependency,39,/// This outputs the full clang module dependency graph suitable for use for; /// explicitly building modules.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang/Tooling/DependencyScanning/DependencyScanningService.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/DependencyScanning/DependencyScanningService.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/DependencyScanning/DependencyScanningService.h:21,Integrability,depend,dependency,21,/// This outputs the dependency graph for standard c++ modules in P1689R5; /// format.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang/Tooling/DependencyScanning/DependencyScanningService.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/DependencyScanning/DependencyScanningService.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/DependencyScanning/DependencyScanningService.h:52,Deployability,configurat,configuration,52,/// The dependency scanning service contains shared configuration and state that; /// is used by the individual dependency scanning workers.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang/Tooling/DependencyScanning/DependencyScanningService.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/DependencyScanning/DependencyScanningService.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/DependencyScanning/DependencyScanningService.h:8,Integrability,depend,dependency,8,/// The dependency scanning service contains shared configuration and state that; /// is used by the individual dependency scanning workers.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang/Tooling/DependencyScanning/DependencyScanningService.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/DependencyScanning/DependencyScanningService.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/DependencyScanning/DependencyScanningService.h:112,Integrability,depend,dependency,112,/// The dependency scanning service contains shared configuration and state that; /// is used by the individual dependency scanning workers.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang/Tooling/DependencyScanning/DependencyScanningService.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/DependencyScanning/DependencyScanningService.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/DependencyScanning/DependencyScanningService.h:52,Modifiability,config,configuration,52,/// The dependency scanning service contains shared configuration and state that; /// is used by the individual dependency scanning workers.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang/Tooling/DependencyScanning/DependencyScanningService.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/DependencyScanning/DependencyScanningService.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/DependencyScanning/DependencyScanningService.h:15,Performance,optimiz,optimize,15,/// Whether to optimize the modules' command-line arguments.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang/Tooling/DependencyScanning/DependencyScanningService.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/DependencyScanning/DependencyScanningService.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/DependencyScanning/DependencyScanningService.h:39,Performance,load,load,39,/// Whether to set up command-lines to load PCM files eagerly.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang/Tooling/DependencyScanning/DependencyScanningService.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/DependencyScanning/DependencyScanningService.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/DependencyScanning/DependencyScanningService.h:27,Performance,cache,cache,27,/// The global file system cache.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang/Tooling/DependencyScanning/DependencyScanningService.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/DependencyScanning/DependencyScanningService.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/DependencyScanning/DependencyScanningService.h:17,Integrability,depend,dependencies,17,// end namespace dependencies,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang/Tooling/DependencyScanning/DependencyScanningService.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/DependencyScanning/DependencyScanningService.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/DependencyScanning/DependencyScanningTool.h:7,Integrability,Depend,DependencyScanningTool,7,"//===- DependencyScanningTool.h - clang-scan-deps service -----------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang/Tooling/DependencyScanning/DependencyScanningTool.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/DependencyScanning/DependencyScanningTool.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/DependencyScanning/DependencyScanningTool.h:21,Integrability,depend,dependencies,21,/// Graph of modular dependencies.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang/Tooling/DependencyScanning/DependencyScanningTool.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/DependencyScanning/DependencyScanningTool.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/DependencyScanning/DependencyScanningTool.h:13,Integrability,depend,dependencies,13,/// The full dependencies and module graph for a specific input.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang/Tooling/DependencyScanning/DependencyScanningTool.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/DependencyScanning/DependencyScanningTool.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/DependencyScanning/DependencyScanningTool.h:47,Integrability,depend,dependencies,47,/// The graph of direct and transitive modular dependencies.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang/Tooling/DependencyScanning/DependencyScanningTool.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/DependencyScanning/DependencyScanningTool.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/DependencyScanning/DependencyScanningTool.h:85,Integrability,depend,depends,85,"/// A collection of absolute paths to files that this translation unit; /// directly depends on, not including transitive dependencies.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang/Tooling/DependencyScanning/DependencyScanningTool.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/DependencyScanning/DependencyScanningTool.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/DependencyScanning/DependencyScanningTool.h:122,Integrability,depend,dependencies,122,"/// A collection of absolute paths to files that this translation unit; /// directly depends on, not including transitive dependencies.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang/Tooling/DependencyScanning/DependencyScanningTool.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/DependencyScanning/DependencyScanningTool.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/DependencyScanning/DependencyScanningTool.h:68,Integrability,depend,depends,68,"/// A collection of prebuilt modules this translation unit directly depends; /// on, not including transitive dependencies.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang/Tooling/DependencyScanning/DependencyScanningTool.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/DependencyScanning/DependencyScanningTool.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/DependencyScanning/DependencyScanningTool.h:110,Integrability,depend,dependencies,110,"/// A collection of prebuilt modules this translation unit directly depends; /// on, not including transitive dependencies.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang/Tooling/DependencyScanning/DependencyScanningTool.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/DependencyScanning/DependencyScanningTool.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/DependencyScanning/DependencyScanningTool.h:53,Integrability,depend,depends,53,"/// A list of modules this translation unit directly depends on, not including; /// transitive dependencies.; ///; /// This may include modules with a different context hash when it can be; /// determined that the differences are benign for this compilation.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang/Tooling/DependencyScanning/DependencyScanningTool.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/DependencyScanning/DependencyScanningTool.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/DependencyScanning/DependencyScanningTool.h:95,Integrability,depend,dependencies,95,"/// A list of modules this translation unit directly depends on, not including; /// transitive dependencies.; ///; /// This may include modules with a different context hash when it can be; /// determined that the differences are benign for this compilation.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang/Tooling/DependencyScanning/DependencyScanningTool.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/DependencyScanning/DependencyScanningTool.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/DependencyScanning/DependencyScanningTool.h:169,Security,hash,hash,169,"/// A list of modules this translation unit directly depends on, not including; /// transitive dependencies.; ///; /// This may include modules with a different context hash when it can be; /// determined that the differences are benign for this compilation.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang/Tooling/DependencyScanning/DependencyScanningTool.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/DependencyScanning/DependencyScanningTool.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/DependencyScanning/DependencyScanningTool.h:213,Integrability,depend,dependencies,213,"/// The sequence of commands required to build the translation unit. Commands; /// should be executed in order.; ///; /// FIXME: If we add support for multi-arch builds in clang-scan-deps, we; /// should make the dependencies between commands explicit to enable parallel; /// builds of each architecture.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang/Tooling/DependencyScanning/DependencyScanningTool.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/DependencyScanning/DependencyScanningTool.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/DependencyScanning/DependencyScanningTool.h:41,Integrability,depend,dependency,41,/// The high-level implementation of the dependency discovery tool that runs on; /// an individual worker thread.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang/Tooling/DependencyScanning/DependencyScanningTool.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/DependencyScanning/DependencyScanningTool.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/DependencyScanning/DependencyScanningTool.h:16,Integrability,depend,dependency,16,/// Construct a dependency scanning tool.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang/Tooling/DependencyScanning/DependencyScanningTool.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/DependencyScanning/DependencyScanningTool.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/DependencyScanning/DependencyScanningTool.h:239,Availability,error,errors,239,"/// Print out the dependency information into a string using the dependency; /// file format that is specified in the options (-MD is the default) and; /// return it.; ///; /// \returns A \c StringError with the diagnostic output if clang errors; /// occurred, dependency file contents otherwise.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang/Tooling/DependencyScanning/DependencyScanningTool.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/DependencyScanning/DependencyScanningTool.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/DependencyScanning/DependencyScanningTool.h:18,Integrability,depend,dependency,18,"/// Print out the dependency information into a string using the dependency; /// file format that is specified in the options (-MD is the default) and; /// return it.; ///; /// \returns A \c StringError with the diagnostic output if clang errors; /// occurred, dependency file contents otherwise.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang/Tooling/DependencyScanning/DependencyScanningTool.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/DependencyScanning/DependencyScanningTool.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/DependencyScanning/DependencyScanningTool.h:65,Integrability,depend,dependency,65,"/// Print out the dependency information into a string using the dependency; /// file format that is specified in the options (-MD is the default) and; /// return it.; ///; /// \returns A \c StringError with the diagnostic output if clang errors; /// occurred, dependency file contents otherwise.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang/Tooling/DependencyScanning/DependencyScanningTool.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/DependencyScanning/DependencyScanningTool.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/DependencyScanning/DependencyScanningTool.h:261,Integrability,depend,dependency,261,"/// Print out the dependency information into a string using the dependency; /// file format that is specified in the options (-MD is the default) and; /// return it.; ///; /// \returns A \c StringError with the diagnostic output if clang errors; /// occurred, dependency file contents otherwise.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang/Tooling/DependencyScanning/DependencyScanningTool.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/DependencyScanning/DependencyScanningTool.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/DependencyScanning/DependencyScanningTool.h:460,Availability,error,errors,460,"/// Collect the module dependency in P1689 format for C++20 named modules.; ///; /// \param MakeformatOutput The output parameter for dependency information; /// in make format if the command line requires to generate make-format; /// dependency information by `-MD -MF <dep_file>`.; ///; /// \param MakeformatOutputPath The output parameter for the path to; /// \param MakeformatOutput.; ///; /// \returns A \c StringError with the diagnostic output if clang errors; /// occurred, P1689 dependency format rules otherwise.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang/Tooling/DependencyScanning/DependencyScanningTool.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/DependencyScanning/DependencyScanningTool.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/DependencyScanning/DependencyScanningTool.h:23,Integrability,depend,dependency,23,"/// Collect the module dependency in P1689 format for C++20 named modules.; ///; /// \param MakeformatOutput The output parameter for dependency information; /// in make format if the command line requires to generate make-format; /// dependency information by `-MD -MF <dep_file>`.; ///; /// \param MakeformatOutputPath The output parameter for the path to; /// \param MakeformatOutput.; ///; /// \returns A \c StringError with the diagnostic output if clang errors; /// occurred, P1689 dependency format rules otherwise.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang/Tooling/DependencyScanning/DependencyScanningTool.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/DependencyScanning/DependencyScanningTool.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/DependencyScanning/DependencyScanningTool.h:134,Integrability,depend,dependency,134,"/// Collect the module dependency in P1689 format for C++20 named modules.; ///; /// \param MakeformatOutput The output parameter for dependency information; /// in make format if the command line requires to generate make-format; /// dependency information by `-MD -MF <dep_file>`.; ///; /// \param MakeformatOutputPath The output parameter for the path to; /// \param MakeformatOutput.; ///; /// \returns A \c StringError with the diagnostic output if clang errors; /// occurred, P1689 dependency format rules otherwise.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang/Tooling/DependencyScanning/DependencyScanningTool.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/DependencyScanning/DependencyScanningTool.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/DependencyScanning/DependencyScanningTool.h:235,Integrability,depend,dependency,235,"/// Collect the module dependency in P1689 format for C++20 named modules.; ///; /// \param MakeformatOutput The output parameter for dependency information; /// in make format if the command line requires to generate make-format; /// dependency information by `-MD -MF <dep_file>`.; ///; /// \param MakeformatOutputPath The output parameter for the path to; /// \param MakeformatOutput.; ///; /// \returns A \c StringError with the diagnostic output if clang errors; /// occurred, P1689 dependency format rules otherwise.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang/Tooling/DependencyScanning/DependencyScanningTool.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/DependencyScanning/DependencyScanningTool.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/DependencyScanning/DependencyScanningTool.h:488,Integrability,depend,dependency,488,"/// Collect the module dependency in P1689 format for C++20 named modules.; ///; /// \param MakeformatOutput The output parameter for dependency information; /// in make format if the command line requires to generate make-format; /// dependency information by `-MD -MF <dep_file>`.; ///; /// \param MakeformatOutputPath The output parameter for the path to; /// \param MakeformatOutput.; ///; /// \returns A \c StringError with the diagnostic output if clang errors; /// occurred, P1689 dependency format rules otherwise.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang/Tooling/DependencyScanning/DependencyScanningTool.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/DependencyScanning/DependencyScanningTool.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/DependencyScanning/DependencyScanningTool.h:656,Availability,error,errors,656,"/// Given a Clang driver command-line for a translation unit, gather the; /// modular dependencies and return the information needed for explicit build.; ///; /// \param AlreadySeen This stores modules which have previously been; /// reported. Use the same instance for all calls to this; /// function for a single \c DependencyScanningTool in a; /// single build. Use a different one for different tools,; /// and clear it between builds.; /// \param LookupModuleOutput This function is called to fill in; /// ""-fmodule-file="", ""-o"" and other output; /// arguments for dependencies.; ///; /// \returns a \c StringError with the diagnostic output if clang errors; /// occurred, \c TranslationUnitDeps otherwise.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang/Tooling/DependencyScanning/DependencyScanningTool.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/DependencyScanning/DependencyScanningTool.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/DependencyScanning/DependencyScanningTool.h:86,Integrability,depend,dependencies,86,"/// Given a Clang driver command-line for a translation unit, gather the; /// modular dependencies and return the information needed for explicit build.; ///; /// \param AlreadySeen This stores modules which have previously been; /// reported. Use the same instance for all calls to this; /// function for a single \c DependencyScanningTool in a; /// single build. Use a different one for different tools,; /// and clear it between builds.; /// \param LookupModuleOutput This function is called to fill in; /// ""-fmodule-file="", ""-o"" and other output; /// arguments for dependencies.; ///; /// \returns a \c StringError with the diagnostic output if clang errors; /// occurred, \c TranslationUnitDeps otherwise.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang/Tooling/DependencyScanning/DependencyScanningTool.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/DependencyScanning/DependencyScanningTool.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/DependencyScanning/DependencyScanningTool.h:318,Integrability,Depend,DependencyScanningTool,318,"/// Given a Clang driver command-line for a translation unit, gather the; /// modular dependencies and return the information needed for explicit build.; ///; /// \param AlreadySeen This stores modules which have previously been; /// reported. Use the same instance for all calls to this; /// function for a single \c DependencyScanningTool in a; /// single build. Use a different one for different tools,; /// and clear it between builds.; /// \param LookupModuleOutput This function is called to fill in; /// ""-fmodule-file="", ""-o"" and other output; /// arguments for dependencies.; ///; /// \returns a \c StringError with the diagnostic output if clang errors; /// occurred, \c TranslationUnitDeps otherwise.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang/Tooling/DependencyScanning/DependencyScanningTool.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/DependencyScanning/DependencyScanningTool.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/DependencyScanning/DependencyScanningTool.h:570,Integrability,depend,dependencies,570,"/// Given a Clang driver command-line for a translation unit, gather the; /// modular dependencies and return the information needed for explicit build.; ///; /// \param AlreadySeen This stores modules which have previously been; /// reported. Use the same instance for all calls to this; /// function for a single \c DependencyScanningTool in a; /// single build. Use a different one for different tools,; /// and clear it between builds.; /// \param LookupModuleOutput This function is called to fill in; /// ""-fmodule-file="", ""-o"" and other output; /// arguments for dependencies.; ///; /// \returns a \c StringError with the diagnostic output if clang errors; /// occurred, \c TranslationUnitDeps otherwise.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang/Tooling/DependencyScanning/DependencyScanningTool.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/DependencyScanning/DependencyScanningTool.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/DependencyScanning/DependencyScanningTool.h:415,Usability,clear,clear,415,"/// Given a Clang driver command-line for a translation unit, gather the; /// modular dependencies and return the information needed for explicit build.; ///; /// \param AlreadySeen This stores modules which have previously been; /// reported. Use the same instance for all calls to this; /// function for a single \c DependencyScanningTool in a; /// single build. Use a different one for different tools,; /// and clear it between builds.; /// \param LookupModuleOutput This function is called to fill in; /// ""-fmodule-file="", ""-o"" and other output; /// arguments for dependencies.; ///; /// \returns a \c StringError with the diagnostic output if clang errors; /// occurred, \c TranslationUnitDeps otherwise.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang/Tooling/DependencyScanning/DependencyScanningTool.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/DependencyScanning/DependencyScanningTool.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/DependencyScanning/DependencyScanningTool.h:97,Integrability,depend,dependencies,97,"/// Given a compilation context specified via the Clang driver command-line,; /// gather modular dependencies of module with the given name, and return the; /// information needed for explicit build.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang/Tooling/DependencyScanning/DependencyScanningTool.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/DependencyScanning/DependencyScanningTool.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/DependencyScanning/DependencyScanningTool.h:13,Integrability,depend,dependency,13,"/// A simple dependency action controller that uses a callback. If no callback; /// is provided, it is assumed that looking up module outputs is unreachable.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang/Tooling/DependencyScanning/DependencyScanningTool.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/DependencyScanning/DependencyScanningTool.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/DependencyScanning/DependencyScanningTool.h:6,Usability,simpl,simple,6,"/// A simple dependency action controller that uses a callback. If no callback; /// is provided, it is assumed that looking up module outputs is unreachable.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang/Tooling/DependencyScanning/DependencyScanningTool.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/DependencyScanning/DependencyScanningTool.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/DependencyScanning/DependencyScanningTool.h:17,Integrability,depend,dependencies,17,// end namespace dependencies,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang/Tooling/DependencyScanning/DependencyScanningTool.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/DependencyScanning/DependencyScanningTool.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/DependencyScanning/DependencyScanningWorker.h:7,Integrability,Depend,DependencyScanningWorker,7,"//===- DependencyScanningWorker.h - clang-scan-deps worker ===---*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang/Tooling/DependencyScanning/DependencyScanningWorker.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/DependencyScanning/DependencyScanningWorker.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/DependencyScanning/DependencyScanningWorker.h:4,Integrability,Depend,Dependency,4,"/// Dependency scanner callbacks that are used during scanning to influence the; /// behaviour of the scan - for example, to customize the scanned invocations.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang/Tooling/DependencyScanning/DependencyScanningWorker.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/DependencyScanning/DependencyScanningWorker.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/DependencyScanning/DependencyScanningWorker.h:18,Integrability,depend,dependency,18,"/// An individual dependency scanning worker that is able to run on its own; /// thread.; ///; /// The worker computes the dependencies for the input files by preprocessing; /// sources either using a fast mode where the source files are minimized, or; /// using the regular processing run.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang/Tooling/DependencyScanning/DependencyScanningWorker.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/DependencyScanning/DependencyScanningWorker.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/DependencyScanning/DependencyScanningWorker.h:123,Integrability,depend,dependencies,123,"/// An individual dependency scanning worker that is able to run on its own; /// thread.; ///; /// The worker computes the dependencies for the input files by preprocessing; /// sources either using a fast mode where the source files are minimized, or; /// using the regular processing run.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang/Tooling/DependencyScanning/DependencyScanningWorker.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/DependencyScanning/DependencyScanningWorker.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/DependencyScanning/DependencyScanningWorker.h:284,Availability,error,errors,284,"/// Run the dependency scanning tool for a given clang driver command-line,; /// and report the discovered dependencies to the provided consumer. If \p; /// ModuleName isn't empty, this function reports the dependencies of module; /// \p ModuleName.; ///; /// \returns false if clang errors occurred (with diagnostics reported to; /// \c DiagConsumer), true otherwise.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang/Tooling/DependencyScanning/DependencyScanningWorker.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/DependencyScanning/DependencyScanningWorker.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/DependencyScanning/DependencyScanningWorker.h:12,Integrability,depend,dependency,12,"/// Run the dependency scanning tool for a given clang driver command-line,; /// and report the discovered dependencies to the provided consumer. If \p; /// ModuleName isn't empty, this function reports the dependencies of module; /// \p ModuleName.; ///; /// \returns false if clang errors occurred (with diagnostics reported to; /// \c DiagConsumer), true otherwise.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang/Tooling/DependencyScanning/DependencyScanningWorker.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/DependencyScanning/DependencyScanningWorker.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/DependencyScanning/DependencyScanningWorker.h:107,Integrability,depend,dependencies,107,"/// Run the dependency scanning tool for a given clang driver command-line,; /// and report the discovered dependencies to the provided consumer. If \p; /// ModuleName isn't empty, this function reports the dependencies of module; /// \p ModuleName.; ///; /// \returns false if clang errors occurred (with diagnostics reported to; /// \c DiagConsumer), true otherwise.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang/Tooling/DependencyScanning/DependencyScanningWorker.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/DependencyScanning/DependencyScanningWorker.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/DependencyScanning/DependencyScanningWorker.h:207,Integrability,depend,dependencies,207,"/// Run the dependency scanning tool for a given clang driver command-line,; /// and report the discovered dependencies to the provided consumer. If \p; /// ModuleName isn't empty, this function reports the dependencies of module; /// \p ModuleName.; ///; /// \returns false if clang errors occurred (with diagnostics reported to; /// \c DiagConsumer), true otherwise.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang/Tooling/DependencyScanning/DependencyScanningWorker.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/DependencyScanning/DependencyScanningWorker.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/DependencyScanning/DependencyScanningWorker.h:66,Availability,error,errors,66,"/// \returns A \c StringError with the diagnostic output if clang errors; /// occurred, success otherwise.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang/Tooling/DependencyScanning/DependencyScanningWorker.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/DependencyScanning/DependencyScanningWorker.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/DependencyScanning/DependencyScanningWorker.h:177,Integrability,depend,dependency,177,"/// The file system to be used during the scan.; /// This is either \c FS passed in the constructor (when performing canonical; /// preprocessing), or \c DepFS (when performing dependency directives scan).",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang/Tooling/DependencyScanning/DependencyScanningWorker.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/DependencyScanning/DependencyScanningWorker.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/DependencyScanning/DependencyScanningWorker.h:106,Performance,perform,performing,106,"/// The file system to be used during the scan.; /// This is either \c FS passed in the constructor (when performing canonical; /// preprocessing), or \c DepFS (when performing dependency directives scan).",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang/Tooling/DependencyScanning/DependencyScanningWorker.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/DependencyScanning/DependencyScanningWorker.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/DependencyScanning/DependencyScanningWorker.h:166,Performance,perform,performing,166,"/// The file system to be used during the scan.; /// This is either \c FS passed in the constructor (when performing canonical; /// preprocessing), or \c DepFS (when performing dependency directives scan).",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang/Tooling/DependencyScanning/DependencyScanningWorker.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/DependencyScanning/DependencyScanningWorker.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/DependencyScanning/DependencyScanningWorker.h:20,Integrability,depend,dependency,20,"/// When performing dependency directives scan, this is the caching (and; /// dependency-directives-extracting) filesystem overlaid on top of \c FS; /// (passed in the constructor).",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang/Tooling/DependencyScanning/DependencyScanningWorker.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/DependencyScanning/DependencyScanningWorker.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/DependencyScanning/DependencyScanningWorker.h:78,Integrability,depend,dependency-directives-extracting,78,"/// When performing dependency directives scan, this is the caching (and; /// dependency-directives-extracting) filesystem overlaid on top of \c FS; /// (passed in the constructor).",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang/Tooling/DependencyScanning/DependencyScanningWorker.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/DependencyScanning/DependencyScanningWorker.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/DependencyScanning/DependencyScanningWorker.h:9,Performance,perform,performing,9,"/// When performing dependency directives scan, this is the caching (and; /// dependency-directives-extracting) filesystem overlaid on top of \c FS; /// (passed in the constructor).",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang/Tooling/DependencyScanning/DependencyScanningWorker.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/DependencyScanning/DependencyScanningWorker.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/DependencyScanning/DependencyScanningWorker.h:15,Performance,optimiz,optimize,15,/// Whether to optimize the modules' command-line arguments.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang/Tooling/DependencyScanning/DependencyScanningWorker.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/DependencyScanning/DependencyScanningWorker.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/DependencyScanning/DependencyScanningWorker.h:39,Performance,load,load,39,/// Whether to set up command-lines to load PCM files eagerly.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang/Tooling/DependencyScanning/DependencyScanningWorker.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/DependencyScanning/DependencyScanningWorker.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/DependencyScanning/DependencyScanningWorker.h:17,Integrability,depend,dependencies,17,// end namespace dependencies,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang/Tooling/DependencyScanning/DependencyScanningWorker.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/DependencyScanning/DependencyScanningWorker.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/DependencyScanning/ModuleDepCollector.h:12,Integrability,depend,dependency,12,/// Modular dependency that has already been built prior to the dependency scan.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang/Tooling/DependencyScanning/ModuleDepCollector.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/DependencyScanning/ModuleDepCollector.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/DependencyScanning/ModuleDepCollector.h:64,Integrability,depend,dependency,64,/// Modular dependency that has already been built prior to the dependency scan.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang/Tooling/DependencyScanning/ModuleDepCollector.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/DependencyScanning/ModuleDepCollector.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/DependencyScanning/ModuleDepCollector.h:16,Security,hash,hash,16,/// The context hash of a module represents the compiler options that affect; /// the resulting command-line invocation.; ///; /// Modules with the same name and ContextHash but different invocations could; /// cause non-deterministic build results.; ///; /// Modules with the same name but a different \c ContextHash should be; /// treated as separate modules for the purpose of a build.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang/Tooling/DependencyScanning/ModuleDepCollector.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/DependencyScanning/ModuleDepCollector.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/DependencyScanning/ModuleDepCollector.h:37,Integrability,interface,interface,37,/// If this module is a standard c++ interface unit.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang/Tooling/DependencyScanning/ModuleDepCollector.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/DependencyScanning/ModuleDepCollector.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/DependencyScanning/ModuleDepCollector.h:20,Integrability,depend,dependency,20,"/// The path of the dependency file (.d), if any.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang/Tooling/DependencyScanning/ModuleDepCollector.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/DependencyScanning/ModuleDepCollector.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/DependencyScanning/ModuleDepCollector.h:66,Integrability,depend,dependency,66,"/// The null-separated list of names to use as the targets in the dependency; /// file, if any. Defaults to the value of \c ModuleFile, as in the driver.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang/Tooling/DependencyScanning/ModuleDepCollector.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/DependencyScanning/ModuleDepCollector.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/DependencyScanning/ModuleDepCollector.h:182,Integrability,depend,dependency,182,/// The path to the modulemap file which defines this module.; ///; /// This can be used to explicitly build this module. This file will; /// additionally appear in \c FileDeps as a dependency.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang/Tooling/DependencyScanning/ModuleDepCollector.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/DependencyScanning/ModuleDepCollector.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/DependencyScanning/ModuleDepCollector.h:70,Integrability,depend,depends,70,"/// A collection of absolute paths to files that this module directly depends; /// on, not including transitive dependencies.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang/Tooling/DependencyScanning/ModuleDepCollector.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/DependencyScanning/ModuleDepCollector.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/DependencyScanning/ModuleDepCollector.h:112,Integrability,depend,dependencies,112,"/// A collection of absolute paths to files that this module directly depends; /// on, not including transitive dependencies.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang/Tooling/DependencyScanning/ModuleDepCollector.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/DependencyScanning/ModuleDepCollector.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/DependencyScanning/ModuleDepCollector.h:37,Integrability,depend,dependencies,37,"/// A collection of prebuilt modular dependencies this module directly depends; /// on, not including transitive dependencies.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang/Tooling/DependencyScanning/ModuleDepCollector.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/DependencyScanning/ModuleDepCollector.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/DependencyScanning/ModuleDepCollector.h:71,Integrability,depend,depends,71,"/// A collection of prebuilt modular dependencies this module directly depends; /// on, not including transitive dependencies.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang/Tooling/DependencyScanning/ModuleDepCollector.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/DependencyScanning/ModuleDepCollector.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/DependencyScanning/ModuleDepCollector.h:113,Integrability,depend,dependencies,113,"/// A collection of prebuilt modular dependencies this module directly depends; /// on, not including transitive dependencies.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang/Tooling/DependencyScanning/ModuleDepCollector.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/DependencyScanning/ModuleDepCollector.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/DependencyScanning/ModuleDepCollector.h:54,Integrability,depend,depends,54,"/// A list of module identifiers this module directly depends on, not; /// including transitive dependencies.; ///; /// This may include modules with a different context hash when it can be; /// determined that the differences are benign for this compilation.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang/Tooling/DependencyScanning/ModuleDepCollector.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/DependencyScanning/ModuleDepCollector.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/DependencyScanning/ModuleDepCollector.h:96,Integrability,depend,dependencies,96,"/// A list of module identifiers this module directly depends on, not; /// including transitive dependencies.; ///; /// This may include modules with a different context hash when it can be; /// determined that the differences are benign for this compilation.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang/Tooling/DependencyScanning/ModuleDepCollector.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/DependencyScanning/ModuleDepCollector.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/DependencyScanning/ModuleDepCollector.h:170,Security,hash,hash,170,"/// A list of module identifiers this module directly depends on, not; /// including transitive dependencies.; ///; /// This may include modules with a different context hash when it can be; /// determined that the differences are benign for this compilation.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang/Tooling/DependencyScanning/ModuleDepCollector.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/DependencyScanning/ModuleDepCollector.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/DependencyScanning/ModuleDepCollector.h:176,Integrability,depend,dependencies,176,"/// Callback that records textual includes and direct modular includes/imports; /// during preprocessing. At the end of the main file, it also collects; /// transitive modular dependencies and passes everything to the; /// \c DependencyConsumer of the parent \c ModuleDepCollector.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang/Tooling/DependencyScanning/ModuleDepCollector.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/DependencyScanning/ModuleDepCollector.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/DependencyScanning/ModuleDepCollector.h:226,Integrability,Depend,DependencyConsumer,226,"/// Callback that records textual includes and direct modular includes/imports; /// during preprocessing. At the end of the main file, it also collects; /// transitive modular dependencies and passes everything to the; /// \c DependencyConsumer of the parent \c ModuleDepCollector.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang/Tooling/DependencyScanning/ModuleDepCollector.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/DependencyScanning/ModuleDepCollector.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/DependencyScanning/ModuleDepCollector.h:15,Integrability,depend,dependency,15,/// The parent dependency collector.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang/Tooling/DependencyScanning/ModuleDepCollector.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/DependencyScanning/ModuleDepCollector.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/DependencyScanning/ModuleDepCollector.h:24,Integrability,depend,dependencies,24,/// Adds direct modular dependencies that have already been built to the; /// ModuleDeps instance.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang/Tooling/DependencyScanning/ModuleDepCollector.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/DependencyScanning/ModuleDepCollector.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/DependencyScanning/ModuleDepCollector.h:54,Integrability,depend,dependencies,54,/// Traverses the previously collected direct modular dependencies to discover; /// transitive modular dependencies and fills the parent \c ModuleDepCollector; /// with both.; /// Returns the ID or nothing if the dependency is spurious and is ignored.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang/Tooling/DependencyScanning/ModuleDepCollector.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/DependencyScanning/ModuleDepCollector.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/DependencyScanning/ModuleDepCollector.h:103,Integrability,depend,dependencies,103,/// Traverses the previously collected direct modular dependencies to discover; /// transitive modular dependencies and fills the parent \c ModuleDepCollector; /// with both.; /// Returns the ID or nothing if the dependency is spurious and is ignored.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang/Tooling/DependencyScanning/ModuleDepCollector.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/DependencyScanning/ModuleDepCollector.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/DependencyScanning/ModuleDepCollector.h:213,Integrability,depend,dependency,213,/// Traverses the previously collected direct modular dependencies to discover; /// transitive modular dependencies and fills the parent \c ModuleDepCollector; /// with both.; /// Returns the ID or nothing if the dependency is spurious and is ignored.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang/Tooling/DependencyScanning/ModuleDepCollector.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/DependencyScanning/ModuleDepCollector.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/DependencyScanning/ModuleDepCollector.h:40,Deployability,update,updates,40,/// Traverses the affecting modules and updates \c MD with references to the; /// parent \c ModuleDepCollector info.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang/Tooling/DependencyScanning/ModuleDepCollector.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/DependencyScanning/ModuleDepCollector.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/DependencyScanning/ModuleDepCollector.h:37,Integrability,depend,dependencies,37,/// Collects modular and non-modular dependencies of the main file by attaching; /// \c ModuleDepCollectorPP to the preprocessor.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang/Tooling/DependencyScanning/ModuleDepCollector.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/DependencyScanning/ModuleDepCollector.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/DependencyScanning/ModuleDepCollector.h:48,Integrability,depend,dependencies,48,"/// Apply any changes implied by the discovered dependencies to the given; /// invocation, (e.g. disable implicit modules, add explicit module paths).",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang/Tooling/DependencyScanning/ModuleDepCollector.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/DependencyScanning/ModuleDepCollector.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/DependencyScanning/ModuleDepCollector.h:30,Integrability,depend,dependency,30,/// The consumer of collected dependency information.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang/Tooling/DependencyScanning/ModuleDepCollector.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/DependencyScanning/ModuleDepCollector.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/DependencyScanning/ModuleDepCollector.h:28,Integrability,depend,dependency,28,/// Callbacks for computing dependency information.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang/Tooling/DependencyScanning/ModuleDepCollector.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/DependencyScanning/ModuleDepCollector.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/DependencyScanning/ModuleDepCollector.h:4,Security,Hash,Hash,4,/// Hash identifying the compilation conditions of the current TU.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang/Tooling/DependencyScanning/ModuleDepCollector.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/DependencyScanning/ModuleDepCollector.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/DependencyScanning/ModuleDepCollector.h:21,Integrability,depend,dependencies,21,/// Non-modular file dependencies. This includes the main source file and; /// textually included header files.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang/Tooling/DependencyScanning/ModuleDepCollector.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/DependencyScanning/ModuleDepCollector.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/DependencyScanning/ModuleDepCollector.h:34,Integrability,depend,dependencies,34,/// Direct and transitive modular dependencies of the main source file.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang/Tooling/DependencyScanning/ModuleDepCollector.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/DependencyScanning/ModuleDepCollector.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/DependencyScanning/ModuleDepCollector.h:19,Integrability,depend,dependencies,19,/// Direct modular dependencies that have already been built.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang/Tooling/DependencyScanning/ModuleDepCollector.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/DependencyScanning/ModuleDepCollector.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/DependencyScanning/ModuleDepCollector.h:34,Integrability,depend,dependencies,34,/// Working set of direct modular dependencies.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang/Tooling/DependencyScanning/ModuleDepCollector.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/DependencyScanning/ModuleDepCollector.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/DependencyScanning/ModuleDepCollector.h:29,Integrability,depend,dependency,29,/// Options that control the dependency output generation.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang/Tooling/DependencyScanning/ModuleDepCollector.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/DependencyScanning/ModuleDepCollector.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/DependencyScanning/ModuleDepCollector.h:181,Integrability,depend,dependency,181,/// A Clang invocation that's based on the original TU invocation and that has; /// been partially transformed into one that can perform explicit build of; /// a discovered modular dependency. Note that this still needs to be adjusted; /// for each individual module.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang/Tooling/DependencyScanning/ModuleDepCollector.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/DependencyScanning/ModuleDepCollector.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/DependencyScanning/ModuleDepCollector.h:129,Performance,perform,perform,129,/// A Clang invocation that's based on the original TU invocation and that has; /// been partially transformed into one that can perform explicit build of; /// a discovered modular dependency. Note that this still needs to be adjusted; /// for each individual module.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang/Tooling/DependencyScanning/ModuleDepCollector.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/DependencyScanning/ModuleDepCollector.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/DependencyScanning/ModuleDepCollector.h:15,Performance,optimiz,optimize,15,/// Whether to optimize the modules' command-line arguments.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang/Tooling/DependencyScanning/ModuleDepCollector.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/DependencyScanning/ModuleDepCollector.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/DependencyScanning/ModuleDepCollector.h:39,Performance,load,load,39,/// Whether to set up command-lines to load PCM files eagerly.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang/Tooling/DependencyScanning/ModuleDepCollector.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/DependencyScanning/ModuleDepCollector.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/DependencyScanning/ModuleDepCollector.h:24,Integrability,depend,dependency,24,/// If we're generating dependency output in P1689 format; /// for standard C++ modules.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang/Tooling/DependencyScanning/ModuleDepCollector.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/DependencyScanning/ModuleDepCollector.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/DependencyScanning/ModuleDepCollector.h:63,Integrability,depend,dependency,63,/// Get a Clang invocation adjusted to build the given modular dependency.; /// This excludes paths that are yet-to-be-provided by the build system.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang/Tooling/DependencyScanning/ModuleDepCollector.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/DependencyScanning/ModuleDepCollector.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/DependencyScanning/ModuleDepCollector.h:59,Integrability,depend,dependencies,59,/// Add paths that require looking up outputs to the given dependencies.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang/Tooling/DependencyScanning/ModuleDepCollector.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/DependencyScanning/ModuleDepCollector.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/DependencyScanning/ModuleDepCollector.h:24,Security,hash,hash,24,"/// Compute the context hash for \p Deps, and create the mapping; /// \c ModuleDepsByID[Deps.ID] = &Deps.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang/Tooling/DependencyScanning/ModuleDepCollector.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/DependencyScanning/ModuleDepCollector.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/DependencyScanning/ModuleDepCollector.h:17,Integrability,depend,dependencies,17,// end namespace dependencies,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang/Tooling/DependencyScanning/ModuleDepCollector.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/DependencyScanning/ModuleDepCollector.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/DependencyScanning/ModuleDepCollector.h:43,Security,hash,hash,43,// ~ is not a valid module name or context hash,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang/Tooling/DependencyScanning/ModuleDepCollector.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/DependencyScanning/ModuleDepCollector.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Inclusions/HeaderIncludes.h:265,Safety,safe,safe,265,"/// Returns the priority of the category which \p IncludeName belongs to.; /// If \p CheckMainHeader is true and \p IncludeName is a main header, returns; /// 0. Otherwise, returns the priority of the matching category or INT_MAX.; /// NOTE: this API is not thread-safe!",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang/Tooling/Inclusions/HeaderIncludes.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Inclusions/HeaderIncludes.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Inclusions/HeaderIncludes.h:341,Safety,avoid,avoid,341,"/// Inserts an #include or #import directive of \p Header into the code.; /// If \p IsAngled is true, \p Header will be quoted with <> in the directive;; /// otherwise, it will be quoted with """".; ///; /// When searching for points to insert new header, this ignores #include's; /// after the #include block(s) in the beginning of a file to avoid inserting; /// headers into code sections where new #include's should not be added by; /// default. These code sections include:; /// - raw string literals (containing #include).; /// - #if blocks.; /// - Special #include's among declarations (e.g. functions).; ///; /// Returns a replacement that inserts the new header into a suitable #include; /// block of the same category. This respects the order of the existing; /// #includes in the block; if the existing #includes are not already sorted,; /// this will simply insert the #include in front of the first #include of the; /// same category in the code that should be sorted after \p IncludeName. If; /// \p IncludeName already exists (with exactly the same spelling), this; /// returns std::nullopt.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang/Tooling/Inclusions/HeaderIncludes.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Inclusions/HeaderIncludes.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Inclusions/HeaderIncludes.h:860,Usability,simpl,simply,860,"/// Inserts an #include or #import directive of \p Header into the code.; /// If \p IsAngled is true, \p Header will be quoted with <> in the directive;; /// otherwise, it will be quoted with """".; ///; /// When searching for points to insert new header, this ignores #include's; /// after the #include block(s) in the beginning of a file to avoid inserting; /// headers into code sections where new #include's should not be added by; /// default. These code sections include:; /// - raw string literals (containing #include).; /// - #if blocks.; /// - Special #include's among declarations (e.g. functions).; ///; /// Returns a replacement that inserts the new header into a suitable #include; /// block of the same category. This respects the order of the existing; /// #includes in the block; if the existing #includes are not already sorted,; /// this will simply insert the #include in front of the first #include of the; /// same category in the code that should be sorted after \p IncludeName. If; /// \p IncludeName already exists (with exactly the same spelling), this; /// returns std::nullopt.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang/Tooling/Inclusions/HeaderIncludes.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Inclusions/HeaderIncludes.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Inclusions/HeaderIncludes.h:70,Safety,avoid,avoid,70,"// Max insertion offset in the original code. For example, we want to avoid; // inserting new #includes into the actual code section (e.g. after a; // declaration).",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang/Tooling/Inclusions/HeaderIncludes.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Inclusions/HeaderIncludes.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Inclusions/IncludeStyle.h:4,Integrability,Depend,Dependent,4,"/// Dependent on the value, multiple ``#include`` blocks can be sorted; /// as one and divided based on category.; /// \version 6",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang/Tooling/Inclusions/IncludeStyle.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Inclusions/IncludeStyle.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Inclusions/IncludeStyle.h:126,Modifiability,extend,extended,126,"/// Regular expressions denoting the different ``#include`` categories; /// used for ordering ``#includes``.; ///; /// `POSIX extended; /// <https://pubs.opengroup.org/onlinepubs/9699919799/basedefs/V1_chap09.html>`_; /// regular expressions are supported.; ///; /// These regular expressions are matched against the filename of an include; /// (including the <> or """") in order. The value belonging to the first; /// matching regular expression is assigned and ``#includes`` are sorted first; /// according to increasing category number and then alphabetically within; /// each category.; ///; /// If none of the regular expressions match, INT_MAX is assigned as; /// category. The main header for a source file automatically gets category 0.; /// so that it is generally kept at the beginning of the ``#includes``; /// (https://llvm.org/docs/CodingStandards.html#include-style). However, you; /// can also assign negative priorities if you have certain headers that; /// always need to be first.; ///; /// There is a third and optional field ``SortPriority`` which can used while; /// ``IncludeBlocks = IBS_Regroup`` to define the priority in which; /// ``#includes`` should be ordered. The value of ``Priority`` defines the; /// order of ``#include blocks`` and also allows the grouping of ``#includes``; /// of different priority. ``SortPriority`` is set to the value of; /// ``Priority`` as default if it is not assigned.; ///; /// Each regular expression can be marked as case sensitive with the field; /// ``CaseSensitive``, per default it is not.; ///; /// To configure this in the .clang-format file, use:; /// \code{.yaml}; /// IncludeCategories:; /// - Regex: '^""(llvm|llvm-c|clang|clang-c)/'; /// Priority: 2; /// SortPriority: 2; /// CaseSensitive: true; /// - Regex: '^((<|"")(gtest|gmock|isl|json)/)'; /// Priority: 3; /// - Regex: '<[[:alnum:].]+>'; /// Priority: 4; /// - Regex: '.*'; /// Priority: 1; /// SortPriority: 0; /// \endcode; /// \version 3.8",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang/Tooling/Inclusions/IncludeStyle.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Inclusions/IncludeStyle.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Inclusions/IncludeStyle.h:1568,Modifiability,config,configure,1568,"/// Regular expressions denoting the different ``#include`` categories; /// used for ordering ``#includes``.; ///; /// `POSIX extended; /// <https://pubs.opengroup.org/onlinepubs/9699919799/basedefs/V1_chap09.html>`_; /// regular expressions are supported.; ///; /// These regular expressions are matched against the filename of an include; /// (including the <> or """") in order. The value belonging to the first; /// matching regular expression is assigned and ``#includes`` are sorted first; /// according to increasing category number and then alphabetically within; /// each category.; ///; /// If none of the regular expressions match, INT_MAX is assigned as; /// category. The main header for a source file automatically gets category 0.; /// so that it is generally kept at the beginning of the ``#includes``; /// (https://llvm.org/docs/CodingStandards.html#include-style). However, you; /// can also assign negative priorities if you have certain headers that; /// always need to be first.; ///; /// There is a third and optional field ``SortPriority`` which can used while; /// ``IncludeBlocks = IBS_Regroup`` to define the priority in which; /// ``#includes`` should be ordered. The value of ``Priority`` defines the; /// order of ``#include blocks`` and also allows the grouping of ``#includes``; /// of different priority. ``SortPriority`` is set to the value of; /// ``Priority`` as default if it is not assigned.; ///; /// Each regular expression can be marked as case sensitive with the field; /// ``CaseSensitive``, per default it is not.; ///; /// To configure this in the .clang-format file, use:; /// \code{.yaml}; /// IncludeCategories:; /// - Regex: '^""(llvm|llvm-c|clang|clang-c)/'; /// Priority: 2; /// SortPriority: 2; /// CaseSensitive: true; /// - Regex: '^((<|"")(gtest|gmock|isl|json)/)'; /// Priority: 3; /// - Regex: '<[[:alnum:].]+>'; /// Priority: 4; /// - Regex: '.*'; /// Priority: 1; /// SortPriority: 0; /// \endcode; /// \version 3.8",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang/Tooling/Inclusions/IncludeStyle.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Inclusions/IncludeStyle.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Inclusions/IncludeStyle.h:393,Modifiability,config,configured,393,"/// Specify a regular expression of suffixes that are allowed in the; /// file-to-main-include mapping.; ///; /// When guessing whether a #include is the ""main"" include (to assign; /// category 0, see above), use this regex of allowed suffixes to the header; /// stem. A partial match is done, so that:; /// - """" means ""arbitrary suffix""; /// - ""$"" means ""no suffix""; ///; /// For example, if configured to ""(_test)?$"", then a header a.h would be seen; /// as the ""main"" include in both a.cc and a_test.cc.; /// \version 3.9",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang/Tooling/Inclusions/IncludeStyle.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Inclusions/IncludeStyle.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Inclusions/IncludeStyle.h:427,Modifiability,config,config,427,"/// Specify a regular expression for files being formatted; /// that are allowed to be considered ""main"" in the; /// file-to-main-include mapping.; ///; /// By default, clang-format considers files as ""main"" only when they end; /// with: ``.c``, ``.cc``, ``.cpp``, ``.c++``, ``.cxx``, ``.m`` or ``.mm``; /// extensions.; /// For these files a guessing of ""main"" include takes place; /// (to assign category 0, see above). This config option allows for; /// additional suffixes and extensions for files to be considered as ""main"".; ///; /// For example, if this option is configured to ``(Impl\.hpp)$``,; /// then a file ``ClassImpl.hpp`` is considered ""main"" (in addition to; /// ``Class.c``, ``Class.cc``, ``Class.cpp`` and so on) and ""main; /// include file"" logic will be executed (with *IncludeIsMainRegex* setting; /// also being respected in later phase). Without this option set,; /// ``ClassImpl.hpp`` would not have the main include file put on top; /// before any other include.; /// \version 10",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang/Tooling/Inclusions/IncludeStyle.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Inclusions/IncludeStyle.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Inclusions/IncludeStyle.h:571,Modifiability,config,configured,571,"/// Specify a regular expression for files being formatted; /// that are allowed to be considered ""main"" in the; /// file-to-main-include mapping.; ///; /// By default, clang-format considers files as ""main"" only when they end; /// with: ``.c``, ``.cc``, ``.cpp``, ``.c++``, ``.cxx``, ``.m`` or ``.mm``; /// extensions.; /// For these files a guessing of ""main"" include takes place; /// (to assign category 0, see above). This config option allows for; /// additional suffixes and extensions for files to be considered as ""main"".; ///; /// For example, if this option is configured to ``(Impl\.hpp)$``,; /// then a file ``ClassImpl.hpp`` is considered ""main"" (in addition to; /// ``Class.c``, ``Class.cc``, ``Class.cpp`` and so on) and ""main; /// include file"" logic will be executed (with *IncludeIsMainRegex* setting; /// also being respected in later phase). Without this option set,; /// ``ClassImpl.hpp`` would not have the main include file put on top; /// before any other include.; /// \version 10",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang/Tooling/Inclusions/IncludeStyle.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Inclusions/IncludeStyle.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Inclusions/IncludeStyle.h:761,Testability,log,logic,761,"/// Specify a regular expression for files being formatted; /// that are allowed to be considered ""main"" in the; /// file-to-main-include mapping.; ///; /// By default, clang-format considers files as ""main"" only when they end; /// with: ``.c``, ``.cc``, ``.cpp``, ``.c++``, ``.cxx``, ``.m`` or ``.mm``; /// extensions.; /// For these files a guessing of ""main"" include takes place; /// (to assign category 0, see above). This config option allows for; /// additional suffixes and extensions for files to be considered as ""main"".; ///; /// For example, if this option is configured to ``(Impl\.hpp)$``,; /// then a file ``ClassImpl.hpp`` is considered ""main"" (in addition to; /// ``Class.c``, ``Class.cc``, ``Class.cpp`` and so on) and ""main; /// include file"" logic will be executed (with *IncludeIsMainRegex* setting; /// also being respected in later phase). Without this option set,; /// ``ClassImpl.hpp`` would not have the main include file put on top; /// before any other include.; /// \version 10",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang/Tooling/Inclusions/IncludeStyle.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Inclusions/IncludeStyle.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Inclusions/StandardLibrary.h:408,Integrability,interface,interface,408,"//===--- StandardLibrary.h --------------------------------------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; ///; /// \file; /// Provides an interface for querying information about C and C++ Standard; /// Library headers and symbols.; ///; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang/Tooling/Inclusions/StandardLibrary.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Inclusions/StandardLibrary.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Inclusions/StandardLibrary.h:318,Availability,reliab,reliable,318,"// A top-level standard library symbol, such as std::vector; // Lightweight class, in fact just an index into a table.; // C++ and C Standard Library symbols are considered distinct: e.g. std::printf; // and ::printf are not treated as the same symbol.; // The symbols do not contain macros right now, we don't have a reliable index; // for them.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang/Tooling/Inclusions/StandardLibrary.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Inclusions/StandardLibrary.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Refactoring/ASTSelection.h:32,Modifiability,refactor,refactoring,32,"//===--- ASTSelection.h - Clang refactoring library -----------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang/Tooling/Refactoring/ASTSelection.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Refactoring/ASTSelection.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Refactoring/ASTSelection.h:141,Availability,down,down,141,"/// Represents a selected AST node.; ///; /// AST selection is represented using a tree of \c SelectedASTNode. The tree; /// follows the top-down shape of the actual AST. Each selected node has; /// a selection kind. The kind might be none as the node itself might not; /// actually be selected, e.g. a statement in macro whose child is in a macro; /// argument.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang/Tooling/Refactoring/ASTSelection.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Refactoring/ASTSelection.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Refactoring/ASTSelection.h:251,Modifiability,variab,variable,251,"/// Returns true when a selected code range is in a function-like body; /// of code, like a function, method or a block.; ///; /// This function can be used to test against selected expressions that are; /// located outside of a function, e.g. global variable initializers, default; /// argument values, or even template arguments.; ///; /// Use the \c getFunctionLikeNearestParent to get the function-like parent; /// declaration.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang/Tooling/Refactoring/ASTSelection.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Refactoring/ASTSelection.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Refactoring/ASTSelection.h:160,Testability,test,test,160,"/// Returns true when a selected code range is in a function-like body; /// of code, like a function, method or a block.; ///; /// This function can be used to test against selected expressions that are; /// located outside of a function, e.g. global variable initializers, default; /// argument values, or even template arguments.; ///; /// Use the \c getFunctionLikeNearestParent to get the function-like parent; /// declaration.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang/Tooling/Refactoring/ASTSelection.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Refactoring/ASTSelection.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Refactoring/AtomicChange.h:442,Availability,error,error,442,"/// An atomic change is used to create and group a set of source edits,; /// e.g. replacements or header insertions. Edits in an AtomicChange should be; /// related, e.g. replacements for the same type reference and the corresponding; /// header insertion/deletion.; ///; /// An AtomicChange is uniquely identified by a key and will either be fully; /// applied or not applied at all.; ///; /// Calling setError on an AtomicChange stores the error message and marks it as; /// bad, i.e. none of its source edits will be applied.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang/Tooling/Refactoring/AtomicChange.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Refactoring/AtomicChange.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Refactoring/AtomicChange.h:448,Integrability,message,message,448,"/// An atomic change is used to create and group a set of source edits,; /// e.g. replacements or header insertions. Edits in an AtomicChange should be; /// related, e.g. replacements for the same type reference and the corresponding; /// header insertion/deletion.; ///; /// An AtomicChange is uniquely identified by a key and will either be fully; /// applied or not applied at all.; ///; /// Calling setError on an AtomicChange stores the error message and marks it as; /// bad, i.e. none of its source edits will be applied.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang/Tooling/Refactoring/AtomicChange.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Refactoring/AtomicChange.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Refactoring/AtomicChange.h:263,Modifiability,refactor,refactored,263,"/// Creates an atomic change around \p KeyPosition with the key being a; /// concatenation of the file name and the offset of \p KeyPosition.; /// \p KeyPosition should be the location of the key syntactical element that; /// is being changed, e.g. the call to a refactored method.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang/Tooling/Refactoring/AtomicChange.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Refactoring/AtomicChange.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Refactoring/AtomicChange.h:124,Availability,error,error,124,"/// If this change could not be created successfully, e.g. because of; /// conflicts among replacements, use this to set an error description.; /// Thereby, places that cannot be fixed automatically can be gathered when; /// applying changes.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang/Tooling/Refactoring/AtomicChange.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Refactoring/AtomicChange.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Refactoring/AtomicChange.h:23,Availability,error,error,23,/// Returns whether an error has been set on this list.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang/Tooling/Refactoring/AtomicChange.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Refactoring/AtomicChange.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Refactoring/AtomicChange.h:16,Availability,error,error,16,/// Returns the error message or an empty string if it does not exist.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang/Tooling/Refactoring/AtomicChange.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Refactoring/AtomicChange.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Refactoring/AtomicChange.h:22,Integrability,message,message,22,/// Returns the error message or an empty string if it does not exist.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang/Tooling/Refactoring/AtomicChange.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Refactoring/AtomicChange.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Refactoring/AtomicChange.h:103,Availability,Error,Error,103,/// Adds a replacement that replaces the given Range with; /// ReplacementText.; /// \returns An llvm::Error carrying ReplacementError on error.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang/Tooling/Refactoring/AtomicChange.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Refactoring/AtomicChange.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Refactoring/AtomicChange.h:138,Availability,error,error,138,/// Adds a replacement that replaces the given Range with; /// ReplacementText.; /// \returns An llvm::Error carrying ReplacementError on error.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang/Tooling/Refactoring/AtomicChange.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Refactoring/AtomicChange.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Refactoring/AtomicChange.h:103,Availability,Error,Error,103,"/// Adds a replacement that replaces range [Loc, Loc+Length) with; /// \p Text.; /// \returns An llvm::Error carrying ReplacementError on error.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang/Tooling/Refactoring/AtomicChange.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Refactoring/AtomicChange.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Refactoring/AtomicChange.h:138,Availability,error,error,138,"/// Adds a replacement that replaces range [Loc, Loc+Length) with; /// \p Text.; /// \returns An llvm::Error carrying ReplacementError on error.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang/Tooling/Refactoring/AtomicChange.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Refactoring/AtomicChange.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Refactoring/AtomicChange.h:403,Availability,error,error,403,"/// Adds a replacement that inserts \p Text at \p Loc. If this; /// insertion conflicts with an existing insertion (at the same position),; /// this will be inserted before/after the existing insertion depending on; /// \p InsertAfter. Users should use `replace` with `Length=0` instead if they; /// do not want conflict resolving by default. If the conflicting replacement; /// is not an insertion, an error is returned.; ///; /// \returns An llvm::Error carrying ReplacementError on error.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang/Tooling/Refactoring/AtomicChange.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Refactoring/AtomicChange.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Refactoring/AtomicChange.h:450,Availability,Error,Error,450,"/// Adds a replacement that inserts \p Text at \p Loc. If this; /// insertion conflicts with an existing insertion (at the same position),; /// this will be inserted before/after the existing insertion depending on; /// \p InsertAfter. Users should use `replace` with `Length=0` instead if they; /// do not want conflict resolving by default. If the conflicting replacement; /// is not an insertion, an error is returned.; ///; /// \returns An llvm::Error carrying ReplacementError on error.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang/Tooling/Refactoring/AtomicChange.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Refactoring/AtomicChange.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Refactoring/AtomicChange.h:485,Availability,error,error,485,"/// Adds a replacement that inserts \p Text at \p Loc. If this; /// insertion conflicts with an existing insertion (at the same position),; /// this will be inserted before/after the existing insertion depending on; /// \p InsertAfter. Users should use `replace` with `Length=0` instead if they; /// do not want conflict resolving by default. If the conflicting replacement; /// is not an insertion, an error is returned.; ///; /// \returns An llvm::Error carrying ReplacementError on error.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang/Tooling/Refactoring/AtomicChange.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Refactoring/AtomicChange.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Refactoring/AtomicChange.h:202,Integrability,depend,depending,202,"/// Adds a replacement that inserts \p Text at \p Loc. If this; /// insertion conflicts with an existing insertion (at the same position),; /// this will be inserted before/after the existing insertion depending on; /// \p InsertAfter. Users should use `replace` with `Length=0` instead if they; /// do not want conflict resolving by default. If the conflicting replacement; /// is not an insertion, an error is returned.; ///; /// \returns An llvm::Error carrying ReplacementError on error.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang/Tooling/Refactoring/AtomicChange.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Refactoring/AtomicChange.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Refactoring/AtomicChange.h:22,Availability,redundant,redundant,22,"// If true, cleans up redundant/erroneous code around changed code with; // clang-format's cleanup functionality, e.g. redundant commas around deleted; // parameter or empty namespaces introduced by deletions.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang/Tooling/Refactoring/AtomicChange.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Refactoring/AtomicChange.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Refactoring/AtomicChange.h:119,Availability,redundant,redundant,119,"// If true, cleans up redundant/erroneous code around changed code with; // clang-format's cleanup functionality, e.g. redundant commas around deleted; // parameter or empty namespaces introduced by deletions.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang/Tooling/Refactoring/AtomicChange.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Refactoring/AtomicChange.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Refactoring/AtomicChange.h:22,Safety,redund,redundant,22,"// If true, cleans up redundant/erroneous code around changed code with; // clang-format's cleanup functionality, e.g. redundant commas around deleted; // parameter or empty namespaces introduced by deletions.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang/Tooling/Refactoring/AtomicChange.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Refactoring/AtomicChange.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Refactoring/AtomicChange.h:119,Safety,redund,redundant,119,"// If true, cleans up redundant/erroneous code around changed code with; // clang-format's cleanup functionality, e.g. redundant commas around deleted; // parameter or empty namespaces introduced by deletions.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang/Tooling/Refactoring/AtomicChange.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Refactoring/AtomicChange.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Refactoring/AtomicChange.h:348,Availability,Error,Error,348,"/// Applies all AtomicChanges in \p Changes to the \p Code.; ///; /// This completely ignores the file path in each change and replaces them with; /// \p FilePath, i.e. callers are responsible for ensuring all changes are for; /// the same file.; ///; /// \returns The changed code if all changes are applied successfully;; /// otherwise, an llvm::Error carrying llvm::StringError is returned (the Error; /// message can be converted to string with `llvm::toString()` and the; /// error_code should be ignored).",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang/Tooling/Refactoring/AtomicChange.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Refactoring/AtomicChange.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Refactoring/AtomicChange.h:398,Availability,Error,Error,398,"/// Applies all AtomicChanges in \p Changes to the \p Code.; ///; /// This completely ignores the file path in each change and replaces them with; /// \p FilePath, i.e. callers are responsible for ensuring all changes are for; /// the same file.; ///; /// \returns The changed code if all changes are applied successfully;; /// otherwise, an llvm::Error carrying llvm::StringError is returned (the Error; /// message can be converted to string with `llvm::toString()` and the; /// error_code should be ignored).",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang/Tooling/Refactoring/AtomicChange.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Refactoring/AtomicChange.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Refactoring/AtomicChange.h:409,Integrability,message,message,409,"/// Applies all AtomicChanges in \p Changes to the \p Code.; ///; /// This completely ignores the file path in each change and replaces them with; /// \p FilePath, i.e. callers are responsible for ensuring all changes are for; /// the same file.; ///; /// \returns The changed code if all changes are applied successfully;; /// otherwise, an llvm::Error carrying llvm::StringError is returned (the Error; /// message can be converted to string with `llvm::toString()` and the; /// error_code should be ignored).",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang/Tooling/Refactoring/AtomicChange.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Refactoring/AtomicChange.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Refactoring/Lookup.h:40,Modifiability,refactor,refactoring,40,"//===--- Lookup.h - Framework for clang refactoring tools --*- C++ -*------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file defines helper methods for clang tools performing name lookup.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang/Tooling/Refactoring/Lookup.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Refactoring/Lookup.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Refactoring/Lookup.h:432,Performance,perform,performing,432,"//===--- Lookup.h - Framework for clang refactoring tools --*- C++ -*------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file defines helper methods for clang tools performing name lookup.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang/Tooling/Refactoring/Lookup.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Refactoring/Lookup.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Refactoring/Lookup.h:162,Performance,perform,perform,162,"/// Emulate a lookup to replace one nested name specifier with another using as; /// few additional namespace qualifications as possible.; ///; /// This does not perform a full C++ lookup so ADL will not work.; ///; /// \param Use The nested name to be replaced.; /// \param UseLoc The location of name to be replaced.; /// \param UseContext The context in which the nested name is contained. This; /// will be used to minimize namespace qualifications.; /// \param FromDecl The declaration to which the nested name points.; /// \param ReplacementString The replacement nested name. Must be fully; /// qualified including a leading ""::"".; /// \returns The new name to be inserted in place of the current nested name.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang/Tooling/Refactoring/Lookup.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Refactoring/Lookup.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Refactoring/RecursiveSymbolVisitor.h:398,Integrability,wrap,wrapper,398,"//===--- RecursiveSymbolVisitor.h - Clang refactoring library -------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; ///; /// \file; /// A wrapper class around \c RecursiveASTVisitor that visits each; /// occurrences of a named symbol.; ///; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang/Tooling/Refactoring/RecursiveSymbolVisitor.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Refactoring/RecursiveSymbolVisitor.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Refactoring/RecursiveSymbolVisitor.h:42,Modifiability,refactor,refactoring,42,"//===--- RecursiveSymbolVisitor.h - Clang refactoring library -------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; ///; /// \file; /// A wrapper class around \c RecursiveASTVisitor that visits each; /// occurrences of a named symbol.; ///; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang/Tooling/Refactoring/RecursiveSymbolVisitor.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Refactoring/RecursiveSymbolVisitor.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Refactoring/RecursiveSymbolVisitor.h:25,Integrability,depend,dependent,25,// FIXME: Try to resolve dependent field references.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang/Tooling/Refactoring/RecursiveSymbolVisitor.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Refactoring/RecursiveSymbolVisitor.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Refactoring/RefactoringAction.h:9,Modifiability,Refactor,RefactoringAction,9,"//===--- RefactoringAction.h - Clang refactoring library ------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang/Tooling/Refactoring/RefactoringAction.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Refactoring/RefactoringAction.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Refactoring/RefactoringAction.h:37,Modifiability,refactor,refactoring,37,"//===--- RefactoringAction.h - Clang refactoring library ------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang/Tooling/Refactoring/RefactoringAction.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Refactoring/RefactoringAction.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Refactoring/RefactoringAction.h:6,Modifiability,refactor,refactoring,6,"/// A refactoring action is a class that defines a set of related refactoring; /// action rules. These rules get grouped under a common umbrella - a single; /// clang-refactor subcommand.; ///; /// A subclass of \c RefactoringAction is responsible for creating the set of; /// grouped refactoring action rules that represent one refactoring operation.; /// Although the rules in one action may have a number of different; /// implementations, they should strive to produce a similar result. It should; /// be easy for users to identify which refactoring action produced the result; /// regardless of which refactoring action rule was used.; ///; /// The distinction between actions and rules enables the creation of action; /// that uses very different rules, for example:; /// - local vs global: a refactoring operation like; /// ""add missing switch cases"" can be applied to one switch when it's; /// selected in an editor, or to all switches in a project when an enum; /// constant is added to an enum.; /// - tool vs editor: some refactoring operation can be initiated in the; /// editor when a declaration is selected, or in a tool when the name of; /// the declaration is passed using a command-line argument.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang/Tooling/Refactoring/RefactoringAction.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Refactoring/RefactoringAction.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Refactoring/RefactoringAction.h:66,Modifiability,refactor,refactoring,66,"/// A refactoring action is a class that defines a set of related refactoring; /// action rules. These rules get grouped under a common umbrella - a single; /// clang-refactor subcommand.; ///; /// A subclass of \c RefactoringAction is responsible for creating the set of; /// grouped refactoring action rules that represent one refactoring operation.; /// Although the rules in one action may have a number of different; /// implementations, they should strive to produce a similar result. It should; /// be easy for users to identify which refactoring action produced the result; /// regardless of which refactoring action rule was used.; ///; /// The distinction between actions and rules enables the creation of action; /// that uses very different rules, for example:; /// - local vs global: a refactoring operation like; /// ""add missing switch cases"" can be applied to one switch when it's; /// selected in an editor, or to all switches in a project when an enum; /// constant is added to an enum.; /// - tool vs editor: some refactoring operation can be initiated in the; /// editor when a declaration is selected, or in a tool when the name of; /// the declaration is passed using a command-line argument.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang/Tooling/Refactoring/RefactoringAction.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Refactoring/RefactoringAction.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Refactoring/RefactoringAction.h:167,Modifiability,refactor,refactor,167,"/// A refactoring action is a class that defines a set of related refactoring; /// action rules. These rules get grouped under a common umbrella - a single; /// clang-refactor subcommand.; ///; /// A subclass of \c RefactoringAction is responsible for creating the set of; /// grouped refactoring action rules that represent one refactoring operation.; /// Although the rules in one action may have a number of different; /// implementations, they should strive to produce a similar result. It should; /// be easy for users to identify which refactoring action produced the result; /// regardless of which refactoring action rule was used.; ///; /// The distinction between actions and rules enables the creation of action; /// that uses very different rules, for example:; /// - local vs global: a refactoring operation like; /// ""add missing switch cases"" can be applied to one switch when it's; /// selected in an editor, or to all switches in a project when an enum; /// constant is added to an enum.; /// - tool vs editor: some refactoring operation can be initiated in the; /// editor when a declaration is selected, or in a tool when the name of; /// the declaration is passed using a command-line argument.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang/Tooling/Refactoring/RefactoringAction.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Refactoring/RefactoringAction.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Refactoring/RefactoringAction.h:215,Modifiability,Refactor,RefactoringAction,215,"/// A refactoring action is a class that defines a set of related refactoring; /// action rules. These rules get grouped under a common umbrella - a single; /// clang-refactor subcommand.; ///; /// A subclass of \c RefactoringAction is responsible for creating the set of; /// grouped refactoring action rules that represent one refactoring operation.; /// Although the rules in one action may have a number of different; /// implementations, they should strive to produce a similar result. It should; /// be easy for users to identify which refactoring action produced the result; /// regardless of which refactoring action rule was used.; ///; /// The distinction between actions and rules enables the creation of action; /// that uses very different rules, for example:; /// - local vs global: a refactoring operation like; /// ""add missing switch cases"" can be applied to one switch when it's; /// selected in an editor, or to all switches in a project when an enum; /// constant is added to an enum.; /// - tool vs editor: some refactoring operation can be initiated in the; /// editor when a declaration is selected, or in a tool when the name of; /// the declaration is passed using a command-line argument.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang/Tooling/Refactoring/RefactoringAction.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Refactoring/RefactoringAction.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Refactoring/RefactoringAction.h:285,Modifiability,refactor,refactoring,285,"/// A refactoring action is a class that defines a set of related refactoring; /// action rules. These rules get grouped under a common umbrella - a single; /// clang-refactor subcommand.; ///; /// A subclass of \c RefactoringAction is responsible for creating the set of; /// grouped refactoring action rules that represent one refactoring operation.; /// Although the rules in one action may have a number of different; /// implementations, they should strive to produce a similar result. It should; /// be easy for users to identify which refactoring action produced the result; /// regardless of which refactoring action rule was used.; ///; /// The distinction between actions and rules enables the creation of action; /// that uses very different rules, for example:; /// - local vs global: a refactoring operation like; /// ""add missing switch cases"" can be applied to one switch when it's; /// selected in an editor, or to all switches in a project when an enum; /// constant is added to an enum.; /// - tool vs editor: some refactoring operation can be initiated in the; /// editor when a declaration is selected, or in a tool when the name of; /// the declaration is passed using a command-line argument.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang/Tooling/Refactoring/RefactoringAction.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Refactoring/RefactoringAction.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Refactoring/RefactoringAction.h:329,Modifiability,refactor,refactoring,329,"/// A refactoring action is a class that defines a set of related refactoring; /// action rules. These rules get grouped under a common umbrella - a single; /// clang-refactor subcommand.; ///; /// A subclass of \c RefactoringAction is responsible for creating the set of; /// grouped refactoring action rules that represent one refactoring operation.; /// Although the rules in one action may have a number of different; /// implementations, they should strive to produce a similar result. It should; /// be easy for users to identify which refactoring action produced the result; /// regardless of which refactoring action rule was used.; ///; /// The distinction between actions and rules enables the creation of action; /// that uses very different rules, for example:; /// - local vs global: a refactoring operation like; /// ""add missing switch cases"" can be applied to one switch when it's; /// selected in an editor, or to all switches in a project when an enum; /// constant is added to an enum.; /// - tool vs editor: some refactoring operation can be initiated in the; /// editor when a declaration is selected, or in a tool when the name of; /// the declaration is passed using a command-line argument.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang/Tooling/Refactoring/RefactoringAction.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Refactoring/RefactoringAction.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Refactoring/RefactoringAction.h:542,Modifiability,refactor,refactoring,542,"/// A refactoring action is a class that defines a set of related refactoring; /// action rules. These rules get grouped under a common umbrella - a single; /// clang-refactor subcommand.; ///; /// A subclass of \c RefactoringAction is responsible for creating the set of; /// grouped refactoring action rules that represent one refactoring operation.; /// Although the rules in one action may have a number of different; /// implementations, they should strive to produce a similar result. It should; /// be easy for users to identify which refactoring action produced the result; /// regardless of which refactoring action rule was used.; ///; /// The distinction between actions and rules enables the creation of action; /// that uses very different rules, for example:; /// - local vs global: a refactoring operation like; /// ""add missing switch cases"" can be applied to one switch when it's; /// selected in an editor, or to all switches in a project when an enum; /// constant is added to an enum.; /// - tool vs editor: some refactoring operation can be initiated in the; /// editor when a declaration is selected, or in a tool when the name of; /// the declaration is passed using a command-line argument.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang/Tooling/Refactoring/RefactoringAction.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Refactoring/RefactoringAction.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Refactoring/RefactoringAction.h:606,Modifiability,refactor,refactoring,606,"/// A refactoring action is a class that defines a set of related refactoring; /// action rules. These rules get grouped under a common umbrella - a single; /// clang-refactor subcommand.; ///; /// A subclass of \c RefactoringAction is responsible for creating the set of; /// grouped refactoring action rules that represent one refactoring operation.; /// Although the rules in one action may have a number of different; /// implementations, they should strive to produce a similar result. It should; /// be easy for users to identify which refactoring action produced the result; /// regardless of which refactoring action rule was used.; ///; /// The distinction between actions and rules enables the creation of action; /// that uses very different rules, for example:; /// - local vs global: a refactoring operation like; /// ""add missing switch cases"" can be applied to one switch when it's; /// selected in an editor, or to all switches in a project when an enum; /// constant is added to an enum.; /// - tool vs editor: some refactoring operation can be initiated in the; /// editor when a declaration is selected, or in a tool when the name of; /// the declaration is passed using a command-line argument.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang/Tooling/Refactoring/RefactoringAction.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Refactoring/RefactoringAction.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Refactoring/RefactoringAction.h:799,Modifiability,refactor,refactoring,799,"/// A refactoring action is a class that defines a set of related refactoring; /// action rules. These rules get grouped under a common umbrella - a single; /// clang-refactor subcommand.; ///; /// A subclass of \c RefactoringAction is responsible for creating the set of; /// grouped refactoring action rules that represent one refactoring operation.; /// Although the rules in one action may have a number of different; /// implementations, they should strive to produce a similar result. It should; /// be easy for users to identify which refactoring action produced the result; /// regardless of which refactoring action rule was used.; ///; /// The distinction between actions and rules enables the creation of action; /// that uses very different rules, for example:; /// - local vs global: a refactoring operation like; /// ""add missing switch cases"" can be applied to one switch when it's; /// selected in an editor, or to all switches in a project when an enum; /// constant is added to an enum.; /// - tool vs editor: some refactoring operation can be initiated in the; /// editor when a declaration is selected, or in a tool when the name of; /// the declaration is passed using a command-line argument.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang/Tooling/Refactoring/RefactoringAction.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Refactoring/RefactoringAction.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Refactoring/RefactoringAction.h:1033,Modifiability,refactor,refactoring,1033,"/// A refactoring action is a class that defines a set of related refactoring; /// action rules. These rules get grouped under a common umbrella - a single; /// clang-refactor subcommand.; ///; /// A subclass of \c RefactoringAction is responsible for creating the set of; /// grouped refactoring action rules that represent one refactoring operation.; /// Although the rules in one action may have a number of different; /// implementations, they should strive to produce a similar result. It should; /// be easy for users to identify which refactoring action produced the result; /// regardless of which refactoring action rule was used.; ///; /// The distinction between actions and rules enables the creation of action; /// that uses very different rules, for example:; /// - local vs global: a refactoring operation like; /// ""add missing switch cases"" can be applied to one switch when it's; /// selected in an editor, or to all switches in a project when an enum; /// constant is added to an enum.; /// - tool vs editor: some refactoring operation can be initiated in the; /// editor when a declaration is selected, or in a tool when the name of; /// the declaration is passed using a command-line argument.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang/Tooling/Refactoring/RefactoringAction.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Refactoring/RefactoringAction.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Refactoring/RefactoringAction.h:60,Modifiability,refactor,refactor,60,/// Returns the name of the subcommand that's used by clang-refactor for this; /// action.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang/Tooling/Refactoring/RefactoringAction.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Refactoring/RefactoringAction.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Refactoring/RefactoringAction.h:21,Modifiability,refactor,refactoring,21,/// Returns a set of refactoring actions rules that are defined by this; /// action.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang/Tooling/Refactoring/RefactoringAction.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Refactoring/RefactoringAction.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Refactoring/RefactoringAction.h:32,Availability,avail,available,32,/// Returns the list of all the available refactoring actions.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang/Tooling/Refactoring/RefactoringAction.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Refactoring/RefactoringAction.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Refactoring/RefactoringAction.h:42,Modifiability,refactor,refactoring,42,/// Returns the list of all the available refactoring actions.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang/Tooling/Refactoring/RefactoringAction.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Refactoring/RefactoringAction.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Refactoring/RefactoringActionRule.h:9,Modifiability,Refactor,RefactoringActionRule,9,"//===--- RefactoringActionRule.h - Clang refactoring library -------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang/Tooling/Refactoring/RefactoringActionRule.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Refactoring/RefactoringActionRule.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Refactoring/RefactoringActionRule.h:41,Modifiability,refactor,refactoring,41,"//===--- RefactoringActionRule.h - Clang refactoring library -------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang/Tooling/Refactoring/RefactoringActionRule.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Refactoring/RefactoringActionRule.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Refactoring/RefactoringActionRule.h:41,Modifiability,refactor,refactoring,41,/// A unique identifier for the specific refactoring.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang/Tooling/Refactoring/RefactoringActionRule.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Refactoring/RefactoringActionRule.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Refactoring/RefactoringActionRule.h:35,Modifiability,refactor,refactoring,35,/// A human readable title for the refactoring.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang/Tooling/Refactoring/RefactoringActionRule.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Refactoring/RefactoringActionRule.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Refactoring/RefactoringActionRule.h:45,Modifiability,refactor,refactoring,45,/// A human readable description of what the refactoring does.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang/Tooling/Refactoring/RefactoringActionRule.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Refactoring/RefactoringActionRule.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Refactoring/RefactoringActionRule.h:37,Integrability,interface,interface,37,/// A common refactoring action rule interface that defines the 'invoke'; /// function that performs the refactoring operation (either fully or; /// partially).,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang/Tooling/Refactoring/RefactoringActionRule.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Refactoring/RefactoringActionRule.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Refactoring/RefactoringActionRule.h:13,Modifiability,refactor,refactoring,13,/// A common refactoring action rule interface that defines the 'invoke'; /// function that performs the refactoring operation (either fully or; /// partially).,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang/Tooling/Refactoring/RefactoringActionRule.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Refactoring/RefactoringActionRule.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Refactoring/RefactoringActionRule.h:105,Modifiability,refactor,refactoring,105,/// A common refactoring action rule interface that defines the 'invoke'; /// function that performs the refactoring operation (either fully or; /// partially).,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang/Tooling/Refactoring/RefactoringActionRule.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Refactoring/RefactoringActionRule.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Refactoring/RefactoringActionRule.h:92,Performance,perform,performs,92,/// A common refactoring action rule interface that defines the 'invoke'; /// function that performs the refactoring operation (either fully or; /// partially).,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang/Tooling/Refactoring/RefactoringActionRule.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Refactoring/RefactoringActionRule.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Refactoring/RefactoringActionRule.h:38,Modifiability,refactor,refactoring,38,/// Initiates and performs a specific refactoring action.; ///; /// The specific rule will invoke an appropriate \c handle method on a; /// consumer to propagate the result of the refactoring action.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang/Tooling/Refactoring/RefactoringActionRule.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Refactoring/RefactoringActionRule.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Refactoring/RefactoringActionRule.h:180,Modifiability,refactor,refactoring,180,/// Initiates and performs a specific refactoring action.; ///; /// The specific rule will invoke an appropriate \c handle method on a; /// consumer to propagate the result of the refactoring action.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang/Tooling/Refactoring/RefactoringActionRule.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Refactoring/RefactoringActionRule.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Refactoring/RefactoringActionRule.h:18,Performance,perform,performs,18,/// Initiates and performs a specific refactoring action.; ///; /// The specific rule will invoke an appropriate \c handle method on a; /// consumer to propagate the result of the refactoring action.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang/Tooling/Refactoring/RefactoringActionRule.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Refactoring/RefactoringActionRule.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Refactoring/RefactoringActionRule.h:45,Modifiability,refactor,refactoring,45,/// Returns the structure that describes the refactoring.; // static const RefactoringDescriptor &describe() = 0;,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang/Tooling/Refactoring/RefactoringActionRule.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Refactoring/RefactoringActionRule.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Refactoring/RefactoringActionRule.h:75,Modifiability,Refactor,RefactoringDescriptor,75,/// Returns the structure that describes the refactoring.; // static const RefactoringDescriptor &describe() = 0;,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang/Tooling/Refactoring/RefactoringActionRule.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Refactoring/RefactoringActionRule.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Refactoring/RefactoringActionRule.h:35,Integrability,wrap,wrapper,35,"/// A refactoring action rule is a wrapper class around a specific refactoring; /// action rule (SourceChangeRefactoringRule, etc) that, in addition to invoking; /// the action, describes the requirements that determine when the action can be; /// initiated.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang/Tooling/Refactoring/RefactoringActionRule.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Refactoring/RefactoringActionRule.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Refactoring/RefactoringActionRule.h:6,Modifiability,refactor,refactoring,6,"/// A refactoring action rule is a wrapper class around a specific refactoring; /// action rule (SourceChangeRefactoringRule, etc) that, in addition to invoking; /// the action, describes the requirements that determine when the action can be; /// initiated.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang/Tooling/Refactoring/RefactoringActionRule.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Refactoring/RefactoringActionRule.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Refactoring/RefactoringActionRule.h:67,Modifiability,refactor,refactoring,67,"/// A refactoring action rule is a wrapper class around a specific refactoring; /// action rule (SourceChangeRefactoringRule, etc) that, in addition to invoking; /// the action, describes the requirements that determine when the action can be; /// initiated.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang/Tooling/Refactoring/RefactoringActionRule.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Refactoring/RefactoringActionRule.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Refactoring/RefactoringActionRule.h:103,Modifiability,refactor,refactoring,103,/// Returns true when the rule has a source selection requirement that has; /// to be fulfilled before refactoring can be performed.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang/Tooling/Refactoring/RefactoringActionRule.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Refactoring/RefactoringActionRule.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Refactoring/RefactoringActionRule.h:122,Performance,perform,performed,122,/// Returns true when the rule has a source selection requirement that has; /// to be fulfilled before refactoring can be performed.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang/Tooling/Refactoring/RefactoringActionRule.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Refactoring/RefactoringActionRule.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Refactoring/RefactoringActionRule.h:19,Modifiability,refactor,refactoring,19,"/// Traverses each refactoring option used by the rule and invokes the; /// \c visit callback in the consumer for each option.; ///; /// Options are visited in the order of use, e.g. if a rule has two; /// requirements that use options, the options from the first requirement; /// are visited before the options in the second requirement.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang/Tooling/Refactoring/RefactoringActionRule.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Refactoring/RefactoringActionRule.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Refactoring/RefactoringActionRuleRequirements.h:9,Modifiability,Refactor,RefactoringActionRuleRequirements,9,"//===--- RefactoringActionRuleRequirements.h - Clang refactoring library --===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang/Tooling/Refactoring/RefactoringActionRuleRequirements.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Refactoring/RefactoringActionRuleRequirements.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Refactoring/RefactoringActionRuleRequirements.h:53,Modifiability,refactor,refactoring,53,"//===--- RefactoringActionRuleRequirements.h - Clang refactoring library --===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang/Tooling/Refactoring/RefactoringActionRuleRequirements.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Refactoring/RefactoringActionRuleRequirements.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Refactoring/RefactoringActionRuleRequirements.h:605,Availability,error,error,605,"/// A refactoring action rule requirement determines when a refactoring action; /// rule can be invoked. The rule can be invoked only when all of the; /// requirements are satisfied.; ///; /// Subclasses must implement the; /// 'Expected<T> evaluate(RefactoringRuleContext &) const' member function.; /// \c T is used to determine the return type that is passed to the; /// refactoring rule's constructor.; /// For example, the \c SourceRangeSelectionRequirement subclass defines; /// 'Expected<SourceRange> evaluate(RefactoringRuleContext &Context) const'; /// function. When this function returns a non-error value, the resulting; /// source range is passed to the specific refactoring action rule; /// constructor (provided all other requirements are satisfied).",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang/Tooling/Refactoring/RefactoringActionRuleRequirements.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Refactoring/RefactoringActionRuleRequirements.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Refactoring/RefactoringActionRuleRequirements.h:6,Modifiability,refactor,refactoring,6,"/// A refactoring action rule requirement determines when a refactoring action; /// rule can be invoked. The rule can be invoked only when all of the; /// requirements are satisfied.; ///; /// Subclasses must implement the; /// 'Expected<T> evaluate(RefactoringRuleContext &) const' member function.; /// \c T is used to determine the return type that is passed to the; /// refactoring rule's constructor.; /// For example, the \c SourceRangeSelectionRequirement subclass defines; /// 'Expected<SourceRange> evaluate(RefactoringRuleContext &Context) const'; /// function. When this function returns a non-error value, the resulting; /// source range is passed to the specific refactoring action rule; /// constructor (provided all other requirements are satisfied).",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang/Tooling/Refactoring/RefactoringActionRuleRequirements.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Refactoring/RefactoringActionRuleRequirements.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Refactoring/RefactoringActionRuleRequirements.h:60,Modifiability,refactor,refactoring,60,"/// A refactoring action rule requirement determines when a refactoring action; /// rule can be invoked. The rule can be invoked only when all of the; /// requirements are satisfied.; ///; /// Subclasses must implement the; /// 'Expected<T> evaluate(RefactoringRuleContext &) const' member function.; /// \c T is used to determine the return type that is passed to the; /// refactoring rule's constructor.; /// For example, the \c SourceRangeSelectionRequirement subclass defines; /// 'Expected<SourceRange> evaluate(RefactoringRuleContext &Context) const'; /// function. When this function returns a non-error value, the resulting; /// source range is passed to the specific refactoring action rule; /// constructor (provided all other requirements are satisfied).",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang/Tooling/Refactoring/RefactoringActionRuleRequirements.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Refactoring/RefactoringActionRuleRequirements.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Refactoring/RefactoringActionRuleRequirements.h:250,Modifiability,Refactor,RefactoringRuleContext,250,"/// A refactoring action rule requirement determines when a refactoring action; /// rule can be invoked. The rule can be invoked only when all of the; /// requirements are satisfied.; ///; /// Subclasses must implement the; /// 'Expected<T> evaluate(RefactoringRuleContext &) const' member function.; /// \c T is used to determine the return type that is passed to the; /// refactoring rule's constructor.; /// For example, the \c SourceRangeSelectionRequirement subclass defines; /// 'Expected<SourceRange> evaluate(RefactoringRuleContext &Context) const'; /// function. When this function returns a non-error value, the resulting; /// source range is passed to the specific refactoring action rule; /// constructor (provided all other requirements are satisfied).",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang/Tooling/Refactoring/RefactoringActionRuleRequirements.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Refactoring/RefactoringActionRuleRequirements.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Refactoring/RefactoringActionRuleRequirements.h:374,Modifiability,refactor,refactoring,374,"/// A refactoring action rule requirement determines when a refactoring action; /// rule can be invoked. The rule can be invoked only when all of the; /// requirements are satisfied.; ///; /// Subclasses must implement the; /// 'Expected<T> evaluate(RefactoringRuleContext &) const' member function.; /// \c T is used to determine the return type that is passed to the; /// refactoring rule's constructor.; /// For example, the \c SourceRangeSelectionRequirement subclass defines; /// 'Expected<SourceRange> evaluate(RefactoringRuleContext &Context) const'; /// function. When this function returns a non-error value, the resulting; /// source range is passed to the specific refactoring action rule; /// constructor (provided all other requirements are satisfied).",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang/Tooling/Refactoring/RefactoringActionRuleRequirements.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Refactoring/RefactoringActionRuleRequirements.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Refactoring/RefactoringActionRuleRequirements.h:517,Modifiability,Refactor,RefactoringRuleContext,517,"/// A refactoring action rule requirement determines when a refactoring action; /// rule can be invoked. The rule can be invoked only when all of the; /// requirements are satisfied.; ///; /// Subclasses must implement the; /// 'Expected<T> evaluate(RefactoringRuleContext &) const' member function.; /// \c T is used to determine the return type that is passed to the; /// refactoring rule's constructor.; /// For example, the \c SourceRangeSelectionRequirement subclass defines; /// 'Expected<SourceRange> evaluate(RefactoringRuleContext &Context) const'; /// function. When this function returns a non-error value, the resulting; /// source range is passed to the specific refactoring action rule; /// constructor (provided all other requirements are satisfied).",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang/Tooling/Refactoring/RefactoringActionRuleRequirements.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Refactoring/RefactoringActionRuleRequirements.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Refactoring/RefactoringActionRuleRequirements.h:676,Modifiability,refactor,refactoring,676,"/// A refactoring action rule requirement determines when a refactoring action; /// rule can be invoked. The rule can be invoked only when all of the; /// requirements are satisfied.; ///; /// Subclasses must implement the; /// 'Expected<T> evaluate(RefactoringRuleContext &) const' member function.; /// \c T is used to determine the return type that is passed to the; /// refactoring rule's constructor.; /// For example, the \c SourceRangeSelectionRequirement subclass defines; /// 'Expected<SourceRange> evaluate(RefactoringRuleContext &Context) const'; /// function. When this function returns a non-error value, the resulting; /// source range is passed to the specific refactoring action rule; /// constructor (provided all other requirements are satisfied).",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang/Tooling/Refactoring/RefactoringActionRuleRequirements.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Refactoring/RefactoringActionRuleRequirements.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Refactoring/RefactoringActionRuleRequirements.h:24,Modifiability,Refactor,RefactoringRuleContext,24,// Expected<T> evaluate(RefactoringRuleContext &Context) const;,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang/Tooling/Refactoring/RefactoringActionRuleRequirements.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Refactoring/RefactoringActionRuleRequirements.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Refactoring/RefactoringActionRuleRequirements.h:115,Modifiability,refactor,refactoring,115,/// A base class for any requirement that expects some part of the source to be; /// selected in an editor (or the refactoring tool with the -selection option).,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang/Tooling/Refactoring/RefactoringActionRuleRequirements.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Refactoring/RefactoringActionRuleRequirements.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Refactoring/RefactoringActionRuleRequirements.h:218,Modifiability,refactor,refactoring,218,/// An AST selection requirement is satisfied when any portion of the AST; /// overlaps with the selection range.; ///; /// The requirement will be evaluated only once during the initiation and; /// search of matching refactoring action rules.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang/Tooling/Refactoring/RefactoringActionRuleRequirements.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Refactoring/RefactoringActionRuleRequirements.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Refactoring/RefactoringActionRuleRequirements.h:408,Modifiability,refactor,refactoring,408,/// A selection requirement that is satisfied when the selection range overlaps; /// with a number of neighbouring statements in the AST. The statemenst must be; /// contained in declaration like a function. The selection range must be a; /// non-empty source selection (i.e. cursors won't be accepted).; ///; /// The requirement will be evaluated only once during the initiation and search; /// of matching refactoring action rules.; ///; /// \see CodeRangeASTSelection,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang/Tooling/Refactoring/RefactoringActionRuleRequirements.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Refactoring/RefactoringActionRuleRequirements.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Refactoring/RefactoringActionRuleRequirements.h:56,Modifiability,refactor,refactoring,56,/// A base class for any requirement that requires some refactoring options.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang/Tooling/Refactoring/RefactoringActionRuleRequirements.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Refactoring/RefactoringActionRuleRequirements.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Refactoring/RefactoringActionRuleRequirements.h:23,Modifiability,refactor,refactoring,23,/// Returns the set of refactoring options that are used when evaluating this; /// requirement.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang/Tooling/Refactoring/RefactoringActionRuleRequirements.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Refactoring/RefactoringActionRuleRequirements.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Refactoring/RefactoringActionRuleRequirements.h:179,Modifiability,refactor,refactoring,179,/// The partially-owned option.; ///; /// The ownership of the option is shared among the different requirements; /// because the same option can be used by multiple rules in one refactoring; /// action.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang/Tooling/Refactoring/RefactoringActionRuleRequirements.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Refactoring/RefactoringActionRuleRequirements.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Refactoring/RefactoringActionRules.h:9,Modifiability,Refactor,RefactoringActionRules,9,"//===--- RefactoringActionRules.h - Clang refactoring library -------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang/Tooling/Refactoring/RefactoringActionRules.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Refactoring/RefactoringActionRules.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Refactoring/RefactoringActionRules.h:42,Modifiability,refactor,refactoring,42,"//===--- RefactoringActionRules.h - Clang refactoring library -------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang/Tooling/Refactoring/RefactoringActionRules.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Refactoring/RefactoringActionRules.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Refactoring/RefactoringActionRules.h:609,Availability,error,errors,609,"/// Creates a new refactoring action rule that constructs and invokes the; /// \c RuleType rule when all of the requirements are satisfied.; ///; /// This function takes in a list of values whose type derives from; /// \c RefactoringActionRuleRequirement. These values describe the initiation; /// requirements that have to be satisfied by the refactoring engine before; /// the provided action rule can be constructed and invoked. The engine; /// verifies that the requirements are satisfied by evaluating them (using the; /// 'evaluate' member function) and checking that the results don't contain; /// any errors. Once all requirements are satisfied, the provided refactoring; /// rule is constructed by passing in the values returned by the requirements'; /// evaluate functions as arguments to the constructor. The rule is then invoked; /// immediately after construction.; ///; /// The separation of requirements, their evaluation and the invocation of the; /// refactoring action rule allows the refactoring clients to:; /// - Disable refactoring action rules whose requirements are not supported.; /// - Gather the set of options and define a command-line / visual interface; /// that allows users to input these options without ever invoking the; /// action.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang/Tooling/Refactoring/RefactoringActionRules.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Refactoring/RefactoringActionRules.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Refactoring/RefactoringActionRules.h:1173,Integrability,interface,interface,1173,"/// Creates a new refactoring action rule that constructs and invokes the; /// \c RuleType rule when all of the requirements are satisfied.; ///; /// This function takes in a list of values whose type derives from; /// \c RefactoringActionRuleRequirement. These values describe the initiation; /// requirements that have to be satisfied by the refactoring engine before; /// the provided action rule can be constructed and invoked. The engine; /// verifies that the requirements are satisfied by evaluating them (using the; /// 'evaluate' member function) and checking that the results don't contain; /// any errors. Once all requirements are satisfied, the provided refactoring; /// rule is constructed by passing in the values returned by the requirements'; /// evaluate functions as arguments to the constructor. The rule is then invoked; /// immediately after construction.; ///; /// The separation of requirements, their evaluation and the invocation of the; /// refactoring action rule allows the refactoring clients to:; /// - Disable refactoring action rules whose requirements are not supported.; /// - Gather the set of options and define a command-line / visual interface; /// that allows users to input these options without ever invoking the; /// action.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang/Tooling/Refactoring/RefactoringActionRules.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Refactoring/RefactoringActionRules.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Refactoring/RefactoringActionRules.h:18,Modifiability,refactor,refactoring,18,"/// Creates a new refactoring action rule that constructs and invokes the; /// \c RuleType rule when all of the requirements are satisfied.; ///; /// This function takes in a list of values whose type derives from; /// \c RefactoringActionRuleRequirement. These values describe the initiation; /// requirements that have to be satisfied by the refactoring engine before; /// the provided action rule can be constructed and invoked. The engine; /// verifies that the requirements are satisfied by evaluating them (using the; /// 'evaluate' member function) and checking that the results don't contain; /// any errors. Once all requirements are satisfied, the provided refactoring; /// rule is constructed by passing in the values returned by the requirements'; /// evaluate functions as arguments to the constructor. The rule is then invoked; /// immediately after construction.; ///; /// The separation of requirements, their evaluation and the invocation of the; /// refactoring action rule allows the refactoring clients to:; /// - Disable refactoring action rules whose requirements are not supported.; /// - Gather the set of options and define a command-line / visual interface; /// that allows users to input these options without ever invoking the; /// action.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang/Tooling/Refactoring/RefactoringActionRules.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Refactoring/RefactoringActionRules.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Refactoring/RefactoringActionRules.h:222,Modifiability,Refactor,RefactoringActionRuleRequirement,222,"/// Creates a new refactoring action rule that constructs and invokes the; /// \c RuleType rule when all of the requirements are satisfied.; ///; /// This function takes in a list of values whose type derives from; /// \c RefactoringActionRuleRequirement. These values describe the initiation; /// requirements that have to be satisfied by the refactoring engine before; /// the provided action rule can be constructed and invoked. The engine; /// verifies that the requirements are satisfied by evaluating them (using the; /// 'evaluate' member function) and checking that the results don't contain; /// any errors. Once all requirements are satisfied, the provided refactoring; /// rule is constructed by passing in the values returned by the requirements'; /// evaluate functions as arguments to the constructor. The rule is then invoked; /// immediately after construction.; ///; /// The separation of requirements, their evaluation and the invocation of the; /// refactoring action rule allows the refactoring clients to:; /// - Disable refactoring action rules whose requirements are not supported.; /// - Gather the set of options and define a command-line / visual interface; /// that allows users to input these options without ever invoking the; /// action.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang/Tooling/Refactoring/RefactoringActionRules.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Refactoring/RefactoringActionRules.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Refactoring/RefactoringActionRules.h:344,Modifiability,refactor,refactoring,344,"/// Creates a new refactoring action rule that constructs and invokes the; /// \c RuleType rule when all of the requirements are satisfied.; ///; /// This function takes in a list of values whose type derives from; /// \c RefactoringActionRuleRequirement. These values describe the initiation; /// requirements that have to be satisfied by the refactoring engine before; /// the provided action rule can be constructed and invoked. The engine; /// verifies that the requirements are satisfied by evaluating them (using the; /// 'evaluate' member function) and checking that the results don't contain; /// any errors. Once all requirements are satisfied, the provided refactoring; /// rule is constructed by passing in the values returned by the requirements'; /// evaluate functions as arguments to the constructor. The rule is then invoked; /// immediately after construction.; ///; /// The separation of requirements, their evaluation and the invocation of the; /// refactoring action rule allows the refactoring clients to:; /// - Disable refactoring action rules whose requirements are not supported.; /// - Gather the set of options and define a command-line / visual interface; /// that allows users to input these options without ever invoking the; /// action.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang/Tooling/Refactoring/RefactoringActionRules.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Refactoring/RefactoringActionRules.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Refactoring/RefactoringActionRules.h:667,Modifiability,refactor,refactoring,667,"/// Creates a new refactoring action rule that constructs and invokes the; /// \c RuleType rule when all of the requirements are satisfied.; ///; /// This function takes in a list of values whose type derives from; /// \c RefactoringActionRuleRequirement. These values describe the initiation; /// requirements that have to be satisfied by the refactoring engine before; /// the provided action rule can be constructed and invoked. The engine; /// verifies that the requirements are satisfied by evaluating them (using the; /// 'evaluate' member function) and checking that the results don't contain; /// any errors. Once all requirements are satisfied, the provided refactoring; /// rule is constructed by passing in the values returned by the requirements'; /// evaluate functions as arguments to the constructor. The rule is then invoked; /// immediately after construction.; ///; /// The separation of requirements, their evaluation and the invocation of the; /// refactoring action rule allows the refactoring clients to:; /// - Disable refactoring action rules whose requirements are not supported.; /// - Gather the set of options and define a command-line / visual interface; /// that allows users to input these options without ever invoking the; /// action.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang/Tooling/Refactoring/RefactoringActionRules.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Refactoring/RefactoringActionRules.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Refactoring/RefactoringActionRules.h:968,Modifiability,refactor,refactoring,968,"/// Creates a new refactoring action rule that constructs and invokes the; /// \c RuleType rule when all of the requirements are satisfied.; ///; /// This function takes in a list of values whose type derives from; /// \c RefactoringActionRuleRequirement. These values describe the initiation; /// requirements that have to be satisfied by the refactoring engine before; /// the provided action rule can be constructed and invoked. The engine; /// verifies that the requirements are satisfied by evaluating them (using the; /// 'evaluate' member function) and checking that the results don't contain; /// any errors. Once all requirements are satisfied, the provided refactoring; /// rule is constructed by passing in the values returned by the requirements'; /// evaluate functions as arguments to the constructor. The rule is then invoked; /// immediately after construction.; ///; /// The separation of requirements, their evaluation and the invocation of the; /// refactoring action rule allows the refactoring clients to:; /// - Disable refactoring action rules whose requirements are not supported.; /// - Gather the set of options and define a command-line / visual interface; /// that allows users to input these options without ever invoking the; /// action.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang/Tooling/Refactoring/RefactoringActionRules.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Refactoring/RefactoringActionRules.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Refactoring/RefactoringActionRules.h:1003,Modifiability,refactor,refactoring,1003,"/// Creates a new refactoring action rule that constructs and invokes the; /// \c RuleType rule when all of the requirements are satisfied.; ///; /// This function takes in a list of values whose type derives from; /// \c RefactoringActionRuleRequirement. These values describe the initiation; /// requirements that have to be satisfied by the refactoring engine before; /// the provided action rule can be constructed and invoked. The engine; /// verifies that the requirements are satisfied by evaluating them (using the; /// 'evaluate' member function) and checking that the results don't contain; /// any errors. Once all requirements are satisfied, the provided refactoring; /// rule is constructed by passing in the values returned by the requirements'; /// evaluate functions as arguments to the constructor. The rule is then invoked; /// immediately after construction.; ///; /// The separation of requirements, their evaluation and the invocation of the; /// refactoring action rule allows the refactoring clients to:; /// - Disable refactoring action rules whose requirements are not supported.; /// - Gather the set of options and define a command-line / visual interface; /// that allows users to input these options without ever invoking the; /// action.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang/Tooling/Refactoring/RefactoringActionRules.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Refactoring/RefactoringActionRules.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Refactoring/RefactoringActionRules.h:1042,Modifiability,refactor,refactoring,1042,"/// Creates a new refactoring action rule that constructs and invokes the; /// \c RuleType rule when all of the requirements are satisfied.; ///; /// This function takes in a list of values whose type derives from; /// \c RefactoringActionRuleRequirement. These values describe the initiation; /// requirements that have to be satisfied by the refactoring engine before; /// the provided action rule can be constructed and invoked. The engine; /// verifies that the requirements are satisfied by evaluating them (using the; /// 'evaluate' member function) and checking that the results don't contain; /// any errors. Once all requirements are satisfied, the provided refactoring; /// rule is constructed by passing in the values returned by the requirements'; /// evaluate functions as arguments to the constructor. The rule is then invoked; /// immediately after construction.; ///; /// The separation of requirements, their evaluation and the invocation of the; /// refactoring action rule allows the refactoring clients to:; /// - Disable refactoring action rules whose requirements are not supported.; /// - Gather the set of options and define a command-line / visual interface; /// that allows users to input these options without ever invoking the; /// action.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang/Tooling/Refactoring/RefactoringActionRules.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Refactoring/RefactoringActionRules.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Refactoring/RefactoringActionRules.h:13,Modifiability,refactor,refactoring,13,/// A set of refactoring action rules that should have unique initiation; /// requirements.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang/Tooling/Refactoring/RefactoringActionRules.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Refactoring/RefactoringActionRules.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Refactoring/RefactoringActionRules.h:14,Modifiability,refactor,refactoring,14,/// A type of refactoring action rule that produces source replacements in the; /// form of atomic changes.; ///; /// This action rule is typically used for local refactorings that replace; /// source in a single AST unit.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang/Tooling/Refactoring/RefactoringActionRules.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Refactoring/RefactoringActionRules.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Refactoring/RefactoringActionRules.h:163,Modifiability,refactor,refactorings,163,/// A type of refactoring action rule that produces source replacements in the; /// form of atomic changes.; ///; /// This action rule is typically used for local refactorings that replace; /// source in a single AST unit.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang/Tooling/Refactoring/RefactoringActionRules.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Refactoring/RefactoringActionRules.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Refactoring/RefactoringActionRules.h:14,Modifiability,refactor,refactoring,14,/// A type of refactoring action rule that finds a set of symbol occurrences; /// that reference a particular symbol.; ///; /// This action rule is typically used for an interactive rename that allows; /// users to specify the new name and the set of selected occurrences during; /// the refactoring.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang/Tooling/Refactoring/RefactoringActionRules.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Refactoring/RefactoringActionRules.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Refactoring/RefactoringActionRules.h:288,Modifiability,refactor,refactoring,288,/// A type of refactoring action rule that finds a set of symbol occurrences; /// that reference a particular symbol.; ///; /// This action rule is typically used for an interactive rename that allows; /// users to specify the new name and the set of selected occurrences during; /// the refactoring.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang/Tooling/Refactoring/RefactoringActionRules.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Refactoring/RefactoringActionRules.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Refactoring/RefactoringActionRulesInternal.h:9,Modifiability,Refactor,RefactoringActionRulesInternal,9,"//===--- RefactoringActionRulesInternal.h - Clang refactoring library -----===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang/Tooling/Refactoring/RefactoringActionRulesInternal.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Refactoring/RefactoringActionRulesInternal.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Refactoring/RefactoringActionRulesInternal.h:50,Modifiability,refactor,refactoring,50,"//===--- RefactoringActionRulesInternal.h - Clang refactoring library -----===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang/Tooling/Refactoring/RefactoringActionRulesInternal.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Refactoring/RefactoringActionRulesInternal.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Refactoring/RefactoringActionRulesInternal.h:43,Availability,Error,Error,43,/// Scans the tuple and returns a valid \c Error if any of the values are; /// invalid.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang/Tooling/Refactoring/RefactoringActionRulesInternal.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Refactoring/RefactoringActionRulesInternal.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Refactoring/RefactoringActionRulesInternal.h:97,Integrability,wrap,wrappers,97,// Construct the target action rule by extracting the evaluated; // requirements from Expected<> wrappers and then run it.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang/Tooling/Refactoring/RefactoringActionRulesInternal.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Refactoring/RefactoringActionRulesInternal.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Refactoring/RefactoringActionRulesInternal.h:64,Modifiability,refactor,refactoring,64,/// Scans the list of requirements in a rule and visits all the refactoring; /// options that are used by all the requirements.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang/Tooling/Refactoring/RefactoringActionRulesInternal.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Refactoring/RefactoringActionRulesInternal.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Refactoring/RefactoringDiagnostic.h:9,Modifiability,Refactor,RefactoringDiagnostic,9,"//===--- RefactoringDiagnostic.h - ------------------------------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang/Tooling/Refactoring/RefactoringDiagnostic.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Refactoring/RefactoringDiagnostic.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Refactoring/RefactoringOption.h:9,Modifiability,Refactor,RefactoringOption,9,"//===--- RefactoringOption.h - Clang refactoring library ------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang/Tooling/Refactoring/RefactoringOption.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Refactoring/RefactoringOption.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Refactoring/RefactoringOption.h:37,Modifiability,refactor,refactoring,37,"//===--- RefactoringOption.h - Clang refactoring library ------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang/Tooling/Refactoring/RefactoringOption.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Refactoring/RefactoringOption.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Refactoring/RefactoringOption.h:31,Integrability,interface,interface,31,/// A refactoring option is an interface that describes a value that; /// has an impact on the outcome of a refactoring.; ///; /// Refactoring options can be specified using command-line arguments when; /// the clang-refactor tool is used.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang/Tooling/Refactoring/RefactoringOption.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Refactoring/RefactoringOption.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Refactoring/RefactoringOption.h:6,Modifiability,refactor,refactoring,6,/// A refactoring option is an interface that describes a value that; /// has an impact on the outcome of a refactoring.; ///; /// Refactoring options can be specified using command-line arguments when; /// the clang-refactor tool is used.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang/Tooling/Refactoring/RefactoringOption.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Refactoring/RefactoringOption.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Refactoring/RefactoringOption.h:108,Modifiability,refactor,refactoring,108,/// A refactoring option is an interface that describes a value that; /// has an impact on the outcome of a refactoring.; ///; /// Refactoring options can be specified using command-line arguments when; /// the clang-refactor tool is used.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang/Tooling/Refactoring/RefactoringOption.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Refactoring/RefactoringOption.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Refactoring/RefactoringOption.h:131,Modifiability,Refactor,Refactoring,131,/// A refactoring option is an interface that describes a value that; /// has an impact on the outcome of a refactoring.; ///; /// Refactoring options can be specified using command-line arguments when; /// the clang-refactor tool is used.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang/Tooling/Refactoring/RefactoringOption.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Refactoring/RefactoringOption.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Refactoring/RefactoringOption.h:217,Modifiability,refactor,refactor,217,/// A refactoring option is an interface that describes a value that; /// has an impact on the outcome of a refactoring.; ///; /// Refactoring options can be specified using command-line arguments when; /// the clang-refactor tool is used.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang/Tooling/Refactoring/RefactoringOption.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Refactoring/RefactoringOption.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Refactoring/RefactoringOption.h:28,Modifiability,refactor,refactoring,28,/// Returns the name of the refactoring option.; ///; /// Each refactoring option must have a unique name.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang/Tooling/Refactoring/RefactoringOption.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Refactoring/RefactoringOption.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Refactoring/RefactoringOption.h:63,Modifiability,refactor,refactoring,63,/// Returns the name of the refactoring option.; ///; /// Each refactoring option must have a unique name.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang/Tooling/Refactoring/RefactoringOption.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Refactoring/RefactoringOption.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Refactoring/RefactoringOption.h:64,Modifiability,refactor,refactoring,64,/// True when this option must be specified before invoking the refactoring; /// action.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang/Tooling/Refactoring/RefactoringOption.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Refactoring/RefactoringOption.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Refactoring/RefactoringOption.h:17,Modifiability,refactor,refactoring,17,/// Constructs a refactoring option of the given type.; ///; /// The ownership of options is shared among requirements that use it because; /// one option can be used by multiple rules in a refactoring action.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang/Tooling/Refactoring/RefactoringOption.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Refactoring/RefactoringOption.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Refactoring/RefactoringOption.h:190,Modifiability,refactor,refactoring,190,/// Constructs a refactoring option of the given type.; ///; /// The ownership of options is shared among requirements that use it because; /// one option can be used by multiple rules in a refactoring action.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang/Tooling/Refactoring/RefactoringOption.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Refactoring/RefactoringOption.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Refactoring/RefactoringOptions.h:9,Modifiability,Refactor,RefactoringOptions,9,"//===--- RefactoringOptions.h - Clang refactoring library -----------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang/Tooling/Refactoring/RefactoringOptions.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Refactoring/RefactoringOptions.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Refactoring/RefactoringOptions.h:38,Modifiability,refactor,refactoring,38,"//===--- RefactoringOptions.h - Clang refactoring library -----------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang/Tooling/Refactoring/RefactoringOptions.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Refactoring/RefactoringOptions.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Refactoring/RefactoringOptions.h:6,Modifiability,refactor,refactoring,6,/// A refactoring option that stores a value of type \c T.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang/Tooling/Refactoring/RefactoringOptions.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Refactoring/RefactoringOptions.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Refactoring/RefactoringOptions.h:15,Modifiability,refactor,refactoring,15,/// A required refactoring option that stores a value of type \c T.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang/Tooling/Refactoring/RefactoringOptions.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Refactoring/RefactoringOptions.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Refactoring/RefactoringOptionVisitor.h:9,Modifiability,Refactor,RefactoringOptionVisitor,9,"//===--- RefactoringOptionVisitor.h - Clang refactoring library -----------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang/Tooling/Refactoring/RefactoringOptionVisitor.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Refactoring/RefactoringOptionVisitor.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Refactoring/RefactoringOptionVisitor.h:44,Modifiability,refactor,refactoring,44,"//===--- RefactoringOptionVisitor.h - Clang refactoring library -----------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang/Tooling/Refactoring/RefactoringOptionVisitor.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Refactoring/RefactoringOptionVisitor.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Refactoring/RefactoringOptionVisitor.h:7,Integrability,interface,interface,7,/// An interface that declares functions that handle different refactoring; /// option types.; ///; /// A valid refactoring option type must have a corresponding \c visit; /// declaration in this interface.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang/Tooling/Refactoring/RefactoringOptionVisitor.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Refactoring/RefactoringOptionVisitor.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Refactoring/RefactoringOptionVisitor.h:196,Integrability,interface,interface,196,/// An interface that declares functions that handle different refactoring; /// option types.; ///; /// A valid refactoring option type must have a corresponding \c visit; /// declaration in this interface.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang/Tooling/Refactoring/RefactoringOptionVisitor.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Refactoring/RefactoringOptionVisitor.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Refactoring/RefactoringOptionVisitor.h:63,Modifiability,refactor,refactoring,63,/// An interface that declares functions that handle different refactoring; /// option types.; ///; /// A valid refactoring option type must have a corresponding \c visit; /// declaration in this interface.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang/Tooling/Refactoring/RefactoringOptionVisitor.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Refactoring/RefactoringOptionVisitor.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Refactoring/RefactoringOptionVisitor.h:112,Modifiability,refactor,refactoring,112,/// An interface that declares functions that handle different refactoring; /// option types.; ///; /// A valid refactoring option type must have a corresponding \c visit; /// declaration in this interface.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang/Tooling/Refactoring/RefactoringOptionVisitor.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Refactoring/RefactoringOptionVisitor.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Refactoring/RefactoringOptionVisitor.h:120,Modifiability,refactor,refactoring,120,// end namespace internal; /// A type trait that returns true iff the given type is a type that can be; /// stored in a refactoring option.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang/Tooling/Refactoring/RefactoringOptionVisitor.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Refactoring/RefactoringOptionVisitor.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Refactoring/RefactoringResultConsumer.h:9,Modifiability,Refactor,RefactoringResultConsumer,9,"//===--- RefactoringResultConsumer.h - Clang refactoring library ----------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang/Tooling/Refactoring/RefactoringResultConsumer.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Refactoring/RefactoringResultConsumer.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Refactoring/RefactoringResultConsumer.h:45,Modifiability,refactor,refactoring,45,"//===--- RefactoringResultConsumer.h - Clang refactoring library ----------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang/Tooling/Refactoring/RefactoringResultConsumer.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Refactoring/RefactoringResultConsumer.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Refactoring/RefactoringResultConsumer.h:16,Integrability,interface,interface,16,/// An abstract interface that consumes the various refactoring results that can; /// be produced by refactoring actions.; ///; /// A valid refactoring result must be handled by a \c handle method.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang/Tooling/Refactoring/RefactoringResultConsumer.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Refactoring/RefactoringResultConsumer.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Refactoring/RefactoringResultConsumer.h:52,Modifiability,refactor,refactoring,52,/// An abstract interface that consumes the various refactoring results that can; /// be produced by refactoring actions.; ///; /// A valid refactoring result must be handled by a \c handle method.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang/Tooling/Refactoring/RefactoringResultConsumer.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Refactoring/RefactoringResultConsumer.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Refactoring/RefactoringResultConsumer.h:101,Modifiability,refactor,refactoring,101,/// An abstract interface that consumes the various refactoring results that can; /// be produced by refactoring actions.; ///; /// A valid refactoring result must be handled by a \c handle method.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang/Tooling/Refactoring/RefactoringResultConsumer.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Refactoring/RefactoringResultConsumer.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Refactoring/RefactoringResultConsumer.h:140,Modifiability,refactor,refactoring,140,/// An abstract interface that consumes the various refactoring results that can; /// be produced by refactoring actions.; ///; /// A valid refactoring result must be handled by a \c handle method.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang/Tooling/Refactoring/RefactoringResultConsumer.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Refactoring/RefactoringResultConsumer.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Refactoring/RefactoringResultConsumer.h:43,Availability,error,error,43,/// Handles an initiation or an invication error. An initiation error typically; /// has a \c DiagnosticError payload that describes why initiation failed.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang/Tooling/Refactoring/RefactoringResultConsumer.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Refactoring/RefactoringResultConsumer.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Refactoring/RefactoringResultConsumer.h:64,Availability,error,error,64,/// Handles an initiation or an invication error. An initiation error typically; /// has a \c DiagnosticError payload that describes why initiation failed.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang/Tooling/Refactoring/RefactoringResultConsumer.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Refactoring/RefactoringResultConsumer.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Refactoring/RefactoringResultConsumer.h:59,Modifiability,refactor,refactoring,59,/// Handles the source replacements that are produced by a refactoring action.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang/Tooling/Refactoring/RefactoringResultConsumer.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Refactoring/RefactoringResultConsumer.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Refactoring/RefactoringResultConsumer.h:73,Modifiability,refactor,refactoring,73,/// Handles the symbol occurrences that are found by an interactive; /// refactoring action.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang/Tooling/Refactoring/RefactoringResultConsumer.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Refactoring/RefactoringResultConsumer.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Refactoring/RefactoringRuleContext.h:9,Modifiability,Refactor,RefactoringRuleContext,9,"//===--- RefactoringRuleContext.h - Clang refactoring library -------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang/Tooling/Refactoring/RefactoringRuleContext.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Refactoring/RefactoringRuleContext.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Refactoring/RefactoringRuleContext.h:42,Modifiability,refactor,refactoring,42,"//===--- RefactoringRuleContext.h - Clang refactoring library -------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang/Tooling/Refactoring/RefactoringRuleContext.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Refactoring/RefactoringRuleContext.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Refactoring/RefactoringRuleContext.h:8,Modifiability,refactor,refactoring,8,/// The refactoring rule context stores all of the inputs that might be needed; /// by a refactoring action rule. It can create the specialized; /// \c ASTRefactoringOperation or \c PreprocessorRefactoringOperation values; /// that can be used by the refactoring action rules.; ///; /// The following inputs are stored by the operation:; ///; /// - SourceManager: a reference to a valid source manager.; ///; /// - SelectionRange: an optional source selection ranges that can be used; /// to represent a selection in an editor.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang/Tooling/Refactoring/RefactoringRuleContext.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Refactoring/RefactoringRuleContext.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Refactoring/RefactoringRuleContext.h:89,Modifiability,refactor,refactoring,89,/// The refactoring rule context stores all of the inputs that might be needed; /// by a refactoring action rule. It can create the specialized; /// \c ASTRefactoringOperation or \c PreprocessorRefactoringOperation values; /// that can be used by the refactoring action rules.; ///; /// The following inputs are stored by the operation:; ///; /// - SourceManager: a reference to a valid source manager.; ///; /// - SelectionRange: an optional source selection ranges that can be used; /// to represent a selection in an editor.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang/Tooling/Refactoring/RefactoringRuleContext.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Refactoring/RefactoringRuleContext.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Refactoring/RefactoringRuleContext.h:251,Modifiability,refactor,refactoring,251,/// The refactoring rule context stores all of the inputs that might be needed; /// by a refactoring action rule. It can create the specialized; /// \c ASTRefactoringOperation or \c PreprocessorRefactoringOperation values; /// that can be used by the refactoring action rules.; ///; /// The following inputs are stored by the operation:; ///; /// - SourceManager: a reference to a valid source manager.; ///; /// - SelectionRange: an optional source selection ranges that can be used; /// to represent a selection in an editor.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang/Tooling/Refactoring/RefactoringRuleContext.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Refactoring/RefactoringRuleContext.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Refactoring/RefactoringRuleContext.h:66,Modifiability,refactor,refactoring,66,/// Returns the current source selection range as set by the; /// refactoring engine. Can be invalid.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang/Tooling/Refactoring/RefactoringRuleContext.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Refactoring/RefactoringRuleContext.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Refactoring/RefactoringRuleContext.h:21,Availability,Error,Error,21,/// Creates an llvm::Error value that contains a diagnostic.; ///; /// The errors should not outlive the context.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang/Tooling/Refactoring/RefactoringRuleContext.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Refactoring/RefactoringRuleContext.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Refactoring/RefactoringRuleContext.h:75,Availability,error,errors,75,/// Creates an llvm::Error value that contains a diagnostic.; ///; /// The errors should not outlive the context.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang/Tooling/Refactoring/RefactoringRuleContext.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Refactoring/RefactoringRuleContext.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Refactoring/RefactoringRuleContext.h:66,Modifiability,refactor,refactoring,66,/// The source manager for the translation unit / file on which a refactoring; /// action might operate on.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang/Tooling/Refactoring/RefactoringRuleContext.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Refactoring/RefactoringRuleContext.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Refactoring/RefactoringRuleContext.h:56,Modifiability,refactor,refactoring,56,/// An optional AST for the translation unit on which a refactoring action; /// might operate on.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang/Tooling/Refactoring/RefactoringRuleContext.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Refactoring/RefactoringRuleContext.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Refactoring/Extract/Extract.h:27,Modifiability,refactor,refactoring,27,"//===--- Extract.h - Clang refactoring library ----------------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang/Tooling/Refactoring/Extract/Extract.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Refactoring/Extract/Extract.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Refactoring/Extract/Extract.h:26,Modifiability,refactor,refactoring,26,"/// An ""Extract Function"" refactoring moves code into a new function that's; /// then called from the place where the original code was.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang/Tooling/Refactoring/Extract/Extract.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Refactoring/Extract/Extract.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Refactoring/Extract/Extract.h:35,Modifiability,refactor,refactoring,35,"/// Initiates the extract function refactoring operation.; ///; /// \param Code The selected set of statements.; /// \param DeclName The name of the extract function. If None,; /// ""extracted"" is used.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang/Tooling/Refactoring/Extract/Extract.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Refactoring/Extract/Extract.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Refactoring/Extract/Extract.h:47,Availability,error,error,47,"// FIXME: Account for naming collisions:; // - error when name is specified by user.; // - rename to ""extractedN"" when name is implicit.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang/Tooling/Refactoring/Extract/Extract.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Refactoring/Extract/Extract.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Refactoring/Extract/SourceExtraction.h:38,Modifiability,refactor,refactoring,38,"//===--- SourceExtraction.cpp - Clang refactoring library -----------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang/Tooling/Refactoring/Extract/SourceExtraction.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Refactoring/Extract/SourceExtraction.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Refactoring/Rename/RenamingAction.h:34,Modifiability,refactor,refactoring,34,"//===--- RenamingAction.h - Clang refactoring library ---------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; ///; /// \file; /// Provides an action to rename every symbol at a point.; ///; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang/Tooling/Refactoring/Rename/RenamingAction.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Refactoring/Rename/RenamingAction.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Refactoring/Rename/SymbolName.h:30,Modifiability,refactor,refactoring,30,"//===--- SymbolName.h - Clang refactoring library -------------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang/Tooling/Refactoring/Rename/SymbolName.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Refactoring/Rename/SymbolName.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Refactoring/Rename/SymbolOccurrences.h:37,Modifiability,refactor,refactoring,37,"//===--- SymbolOccurrences.h - Clang refactoring library ------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang/Tooling/Refactoring/Rename/SymbolOccurrences.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Refactoring/Rename/SymbolOccurrences.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Refactoring/Rename/SymbolOccurrences.h:524,Performance,perform,performing,524,"/// This occurrence is an exact match and can be renamed automatically.; ///; /// Note:; /// Symbol occurrences in macro arguments that expand to different; /// declarations get marked as exact matches, and thus the renaming engine; /// will rename them e.g.:; ///; /// \code; /// #define MACRO(x) x + ns::x; /// int foo(int var) {; /// return MACRO(var); // var is renamed automatically here when; /// // either var or ns::var is renamed.; /// };; /// \endcode; ///; /// The user will have to fix their code manually after performing such a; /// rename.; /// FIXME: The rename verifier should notify user about this issue.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang/Tooling/Refactoring/Rename/SymbolOccurrences.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Refactoring/Rename/SymbolOccurrences.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Refactoring/Rename/USRFinder.h:29,Modifiability,refactor,refactoring,29,"//===--- USRFinder.h - Clang refactoring library --------------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; ///; /// \file; /// Methods for determining the USR of a symbol at a location in source; /// code.; ///; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang/Tooling/Refactoring/Rename/USRFinder.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Refactoring/Rename/USRFinder.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Refactoring/Rename/USRFindingAction.h:36,Modifiability,refactor,refactoring,36,"//===--- USRFindingAction.h - Clang refactoring library -------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; ///; /// \file; /// Provides an action to find all relevant USRs at a point.; ///; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang/Tooling/Refactoring/Rename/USRFindingAction.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Refactoring/Rename/USRFindingAction.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Refactoring/Rename/USRLocFinder.h:32,Modifiability,refactor,refactoring,32,"//===--- USRLocFinder.h - Clang refactoring library -----------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; ///; /// \file; /// Provides functionality for finding all instances of a USR in a given; /// AST.; ///; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang/Tooling/Refactoring/Rename/USRLocFinder.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Refactoring/Rename/USRLocFinder.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Syntax/BuildTree.h:141,Testability,assert,assert,141,// Create syntax trees from subtrees not backed by the source code.; // Synthesis of Leafs; /// Create `Leaf` from token with `Spelling` and assert it has the desired; /// `TokenKind`.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang/Tooling/Syntax/BuildTree.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Syntax/BuildTree.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Syntax/Nodes.h:843,Availability,error,errors,843,"//===- Nodes.h - syntax nodes for C/C++ grammar constructs ----*- C++ -*-=====//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; // Syntax tree nodes for C, C++ and Objective-C grammar constructs.; //; // Nodes provide access to their syntactic components, e.g. IfStatement provides; // a way to get its condition, then and else branches, tokens for 'if' and; // 'else' keywords.; // When using the accessors, please assume they can return null. This happens; // because:; // - the corresponding subnode is optional in the C++ grammar, e.g. an else; // branch of an if statement,; // - syntactic errors occurred while parsing the corresponding subnode.; // One notable exception is ""introducer"" keywords, e.g. the accessor for the; // 'if' keyword of an if statement will never return null.; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang/Tooling/Syntax/Nodes.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Syntax/Nodes.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Syntax/Nodes.h:466,Security,access,access,466,"//===- Nodes.h - syntax nodes for C/C++ grammar constructs ----*- C++ -*-=====//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; // Syntax tree nodes for C, C++ and Objective-C grammar constructs.; //; // Nodes provide access to their syntactic components, e.g. IfStatement provides; // a way to get its condition, then and else branches, tokens for 'if' and; // 'else' keywords.; // When using the accessors, please assume they can return null. This happens; // because:; // - the corresponding subnode is optional in the C++ grammar, e.g. an else; // branch of an if statement,; // - syntactic errors occurred while parsing the corresponding subnode.; // One notable exception is ""introducer"" keywords, e.g. the accessor for the; // 'if' keyword of an if statement will never return null.; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang/Tooling/Syntax/Nodes.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Syntax/Nodes.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Syntax/Nodes.h:646,Security,access,accessors,646,"//===- Nodes.h - syntax nodes for C/C++ grammar constructs ----*- C++ -*-=====//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; // Syntax tree nodes for C, C++ and Objective-C grammar constructs.; //; // Nodes provide access to their syntactic components, e.g. IfStatement provides; // a way to get its condition, then and else branches, tokens for 'if' and; // 'else' keywords.; // When using the accessors, please assume they can return null. This happens; // because:; // - the corresponding subnode is optional in the C++ grammar, e.g. an else; // branch of an if statement,; // - syntactic errors occurred while parsing the corresponding subnode.; // One notable exception is ""introducer"" keywords, e.g. the accessor for the; // 'if' keyword of an if statement will never return null.; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang/Tooling/Syntax/Nodes.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Syntax/Nodes.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Syntax/Nodes.h:961,Security,access,accessor,961,"//===- Nodes.h - syntax nodes for C/C++ grammar constructs ----*- C++ -*-=====//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; // Syntax tree nodes for C, C++ and Objective-C grammar constructs.; //; // Nodes provide access to their syntactic components, e.g. IfStatement provides; // a way to get its condition, then and else branches, tokens for 'if' and; // 'else' keywords.; // When using the accessors, please assume they can return null. This happens; // because:; // - the corresponding subnode is optional in the C++ grammar, e.g. an else; // branch of an if statement,; // - syntactic errors occurred while parsing the corresponding subnode.; // One notable exception is ""introducer"" keywords, e.g. the accessor for the; // 'if' keyword of an if statement will never return null.; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang/Tooling/Syntax/Nodes.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Syntax/Nodes.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Syntax/Nodes.h:134,Modifiability,inherit,inheritance,134,"/// A kind of a syntax node, used for implementing casts. The ordering and; /// blocks of enumerator constants must correspond to the inheritance hierarchy; /// of syntax::Node.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang/Tooling/Syntax/Nodes.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Syntax/Nodes.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Syntax/Nodes.h:121,Security,access,accessors,121,"/// A relation between a parent and child node, e.g. 'left-hand-side of; /// a binary expression'. Used for implementing accessors.; ///; /// In general `NodeRole`s should be named the same as their accessors.; ///; /// Some roles describe parent/child relations that occur multiple times in; /// language grammar. We define only one role to describe all instances of such; /// recurring relations. For example, grammar for both ""if"" and ""while""; /// statements requires an opening paren and a closing paren. The opening; /// paren token is assigned the OpenParen role regardless of whether it appears; /// as a child of IfStatement or WhileStatement node. More generally, when; /// grammar requires a certain fixed token (like a specific keyword, or an; /// opening paren), we define a role for this token and use it across all; /// grammar rules with the same requirement. Names of such reusable roles end; /// with a ~Token or a ~Keyword suffix.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang/Tooling/Syntax/Nodes.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Syntax/Nodes.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Syntax/Nodes.h:199,Security,access,accessors,199,"/// A relation between a parent and child node, e.g. 'left-hand-side of; /// a binary expression'. Used for implementing accessors.; ///; /// In general `NodeRole`s should be named the same as their accessors.; ///; /// Some roles describe parent/child relations that occur multiple times in; /// language grammar. We define only one role to describe all instances of such; /// recurring relations. For example, grammar for both ""if"" and ""while""; /// statements requires an opening paren and a closing paren. The opening; /// paren token is assigned the OpenParen role regardless of whether it appears; /// as a child of IfStatement or WhileStatement node. More generally, when; /// grammar requires a certain fixed token (like a specific keyword, or an; /// opening paren), we define a role for this token and use it across all; /// grammar rules with the same requirement. Names of such reusable roles end; /// with a ~Token or a ~Keyword suffix.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang/Tooling/Syntax/Nodes.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Syntax/Nodes.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Syntax/Nodes.h:130,Usability,simpl,simplification,130,"/// Models arguments of a function call.; /// call-arguments:; /// delimited_list(expression, ','); /// Note: This construct is a simplification of the grammar rule for; /// `expression-list`, that is used in the definition of `call-expression`",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang/Tooling/Syntax/Nodes.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Syntax/Nodes.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Syntax/Nodes.h:82,Security,access,accessors,82,"/// An abstract node for C++ statements, e.g. 'while', 'if', etc.; /// FIXME: add accessors for semicolon of statements that have it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang/Tooling/Syntax/Nodes.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Syntax/Nodes.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Syntax/Nodes.h:106,Modifiability,variab,variable,106,/// if (cond) <then-statement> else <else-statement>; /// FIXME: add condition that models 'expression or variable declaration',MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang/Tooling/Syntax/Nodes.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Syntax/Nodes.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Syntax/Nodes.h:229,Modifiability,variab,variables,229,"/// A declaration that can appear at the top-level. Note that this does *not*; /// correspond 1-to-1 to clang::Decl. Syntax trees distinguish between top-level; /// declarations (e.g. namespace definitions) and declarators (e.g. variables,; /// typedefs, etc.). Declarators are stored inside SimpleDeclaration.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang/Tooling/Syntax/Nodes.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Syntax/Nodes.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Syntax/Nodes.h:292,Usability,Simpl,SimpleDeclaration,292,"/// A declaration that can appear at the top-level. Note that this does *not*; /// correspond 1-to-1 to clang::Decl. Syntax trees distinguish between top-level; /// declarations (e.g. namespace definitions) and declarators (e.g. variables,; /// typedefs, etc.). Declarators are stored inside SimpleDeclaration.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang/Tooling/Syntax/Nodes.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Syntax/Nodes.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Syntax/Nodes.h:32,Integrability,message,message,32,"/// static_assert(<condition>, <message>); /// static_assert(<condition>)",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang/Tooling/Syntax/Nodes.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Syntax/Nodes.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Syntax/Nodes.h:38,Modifiability,variab,variables,38,"/// Groups multiple declarators (e.g. variables, typedefs, etc.) together. All; /// grouped declarators share the same declaration specifiers (e.g. 'int' or; /// 'typedef').",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang/Tooling/Syntax/Nodes.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Syntax/Nodes.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Syntax/Nodes.h:364,Usability,Simpl,SimpleDeclarator,364,"/// Covers a name, an initializer and a part of the type outside declaration; /// specifiers. Examples are:; /// `*a` in `int *a`; /// `a[10]` in `int a[10]`; /// `*a = nullptr` in `int *a = nullptr`; /// Declarators can be unnamed too:; /// `**` in `new int**`; /// `* = nullptr` in `void foo(int* = nullptr)`; /// Most declarators you encounter are instances of SimpleDeclarator. They may; /// contain an inner declarator inside parentheses, we represent it as; /// ParenDeclarator. E.g.; /// `(*a)` in `int (*a) = 10`",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang/Tooling/Syntax/Nodes.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Syntax/Nodes.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Syntax/Nodes.h:16,Security,access,accessor,16,"// TODO: add an accessor for the ""static"" keyword.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang/Tooling/Syntax/Nodes.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Syntax/Nodes.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Syntax/Nodes.h:13,Security,access,accessors,13,// TODO: add accessors for specifiers.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang/Tooling/Syntax/Nodes.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Syntax/Nodes.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Syntax/TokenBufferTokenManager.h:18,Energy Efficiency,power,powered,18,"/// A TokenBuffer-powered token manager.; /// It tracks the underlying token buffers, source manager, etc.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang/Tooling/Syntax/TokenBufferTokenManager.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Syntax/TokenBufferTokenManager.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Syntax/TokenBufferTokenManager.h:99,Testability,log,logic,99,"// Handle 'eof' separately, calling text() on it produces an empty string.; // FIXME: this special logic is for syntax::Leaf dump, move it when we; // have a direct way to retrive token kind in the syntax::Leaf.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang/Tooling/Syntax/TokenBufferTokenManager.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Syntax/TokenBufferTokenManager.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Syntax/TokenBufferTokenManager.h:19,Energy Efficiency,power,powered,19,// This manager is powered by the TokenBuffer.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang/Tooling/Syntax/TokenBufferTokenManager.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Syntax/TokenBufferTokenManager.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Syntax/TokenManager.h:397,Integrability,interface,interfaces,397,"//===- TokenManager.h - Manage Tokens for syntax-tree ------------*- C++-*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // Defines Token interfaces for the clang syntax-tree. This is the level of; // abstraction that the syntax-tree uses to operate on Token.; //; // TokenManager decouples the syntax-tree from a particular token; // implementation. For example, a TokenBuffer captured from a clang parser may; // track macro expansions and associate tokens with clang's SourceManager, while; // a clang pseudoparser would use a flat array of raw-lexed tokens in memory.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang/Tooling/Syntax/TokenManager.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Syntax/TokenManager.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Syntax/TokenManager.h:12,Integrability,interface,interfaces,12,"/// Defines interfaces for operating ""Token"" in the clang syntax-tree.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang/Tooling/Syntax/TokenManager.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Syntax/TokenManager.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Syntax/TokenManager.h:58,Integrability,depend,depends,58,/// A key to identify a specific token. The token concept depends on the; /// underlying implementation -- it can be a spelled token from the original; /// source file or an expanded token.; /// The syntax-tree Leaf node holds a Key.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang/Tooling/Syntax/TokenManager.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Syntax/TokenManager.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Syntax/Tokens.h:13,Performance,cache,cache,13,/// Builds a cache to make future calls to expandedToken(SourceRange) faster.; /// Creates an index only once. Further calls to it will be no-op.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang/Tooling/Syntax/Tokens.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Syntax/Tokens.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Syntax/Tokens.h:142,Modifiability,refactor,refactoring,142,"/// Returns the subrange of spelled tokens corresponding to AST node spanning; /// \p Expanded. This is the text that should be replaced if a refactoring; /// were to rewrite the node. If \p Expanded is empty, the returned value is; /// std::nullopt.; ///; /// Will fail if the expanded tokens do not correspond to a sequence of; /// spelled tokens. E.g. for the following example:; ///; /// #define FIRST f1 f2 f3; /// #define SECOND s1 s2 s3; /// #define ID2(X, Y) X Y; ///; /// a FIRST b SECOND c // expanded tokens are: a f1 f2 f3 b s1 s2 s3 c; /// d ID2(e f g, h) i // expanded tokens are: d e f g h i; ///; /// the results would be:; /// expanded => spelled; /// ------------------------; /// a => a; /// s1 s2 s3 => SECOND; /// a f1 f2 f3 => a FIRST; /// a f1 => can't map; /// s1 s2 => can't map; /// e f => e f; /// g h => can't map; ///; /// EXPECTS: \p Expanded is a subrange of expandedTokens().; /// Complexity is logarithmic.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang/Tooling/Syntax/Tokens.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Syntax/Tokens.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Syntax/Tokens.h:167,Modifiability,rewrite,rewrite,167,"/// Returns the subrange of spelled tokens corresponding to AST node spanning; /// \p Expanded. This is the text that should be replaced if a refactoring; /// were to rewrite the node. If \p Expanded is empty, the returned value is; /// std::nullopt.; ///; /// Will fail if the expanded tokens do not correspond to a sequence of; /// spelled tokens. E.g. for the following example:; ///; /// #define FIRST f1 f2 f3; /// #define SECOND s1 s2 s3; /// #define ID2(X, Y) X Y; ///; /// a FIRST b SECOND c // expanded tokens are: a f1 f2 f3 b s1 s2 s3 c; /// d ID2(e f g, h) i // expanded tokens are: d e f g h i; ///; /// the results would be:; /// expanded => spelled; /// ------------------------; /// a => a; /// s1 s2 s3 => SECOND; /// a f1 f2 f3 => a FIRST; /// a f1 => can't map; /// s1 s2 => can't map; /// e f => e f; /// g h => can't map; ///; /// EXPECTS: \p Expanded is a subrange of expandedTokens().; /// Complexity is logarithmic.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang/Tooling/Syntax/Tokens.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Syntax/Tokens.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Syntax/Tokens.h:927,Testability,log,logarithmic,927,"/// Returns the subrange of spelled tokens corresponding to AST node spanning; /// \p Expanded. This is the text that should be replaced if a refactoring; /// were to rewrite the node. If \p Expanded is empty, the returned value is; /// std::nullopt.; ///; /// Will fail if the expanded tokens do not correspond to a sequence of; /// spelled tokens. E.g. for the following example:; ///; /// #define FIRST f1 f2 f3; /// #define SECOND s1 s2 s3; /// #define ID2(X, Y) X Y; ///; /// a FIRST b SECOND c // expanded tokens are: a f1 f2 f3 b s1 s2 s3 c; /// d ID2(e f g, h) i // expanded tokens are: d e f g h i; ///; /// the results would be:; /// expanded => spelled; /// ------------------------; /// a => a; /// s1 s2 s3 => SECOND; /// a f1 f2 f3 => a FIRST; /// a f1 => can't map; /// s1 s2 => can't map; /// e f => e f; /// g h => can't map; ///; /// EXPECTS: \p Expanded is a subrange of expandedTokens().; /// Complexity is logarithmic.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang/Tooling/Syntax/Tokens.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Syntax/Tokens.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Syntax/Tokens.h:34,Deployability,continuous,continuous,34,"/// Describes a mapping between a continuous subrange of spelled tokens and; /// expanded tokens. Represents macro expansions, preprocessor directives,; /// conditionally disabled pp regions, etc.; /// #define FOO 1+2; /// #define BAR(a) a + 1; /// FOO // invocation #1, tokens = {'1','+','2'}, macroTokens = {'FOO'}.; /// BAR(1) // invocation #2, tokens = {'a', '+', '1'},; /// macroTokens = {'BAR', '(', '1', ')'}.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang/Tooling/Syntax/Tokens.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Syntax/Tokens.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Syntax/Tokens.h:66,Testability,Assert,Asserts,66,"/// Returns the file that the Spelled tokens are taken from.; /// Asserts that they are non-empty, from a tracked file, and in-bounds.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang/Tooling/Syntax/Tokens.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Syntax/Tokens.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Syntax/Tokens.h:60,Safety,avoid,avoid,60,"// The value is never null, pointer instead of reference to avoid disabling; // implicit assignment operator.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang/Tooling/Syntax/Tokens.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Syntax/Tokens.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Syntax/Tokens.h:656,Availability,recover,recover,656,"/// Maps from a start to an end spelling location of transformations; /// performed by the preprocessor. These include:; /// 1. range from '#' to the last token in the line for PP directives,; /// 2. macro name and arguments for macro expansions.; /// Note that we record only top-level macro expansions, intermediate; /// expansions (e.g. inside macro arguments) are ignored.; ///; /// Used to find correct boundaries of macro calls and directives when; /// building mappings from spelled to expanded tokens.; ///; /// Logically, at each point of the preprocessor execution there is a stack of; /// macro expansions being processed and we could use it to recover the; /// location information we need. However, the public preprocessor API only; /// exposes the points when macro expansions start (when we push a macro onto; /// the stack) and not when they end (when we pop a macro from the stack).; /// To workaround this limitation, we rely on source location information; /// stored in this map.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang/Tooling/Syntax/Tokens.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Syntax/Tokens.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Syntax/Tokens.h:74,Performance,perform,performed,74,"/// Maps from a start to an end spelling location of transformations; /// performed by the preprocessor. These include:; /// 1. range from '#' to the last token in the line for PP directives,; /// 2. macro name and arguments for macro expansions.; /// Note that we record only top-level macro expansions, intermediate; /// expansions (e.g. inside macro arguments) are ignored.; ///; /// Used to find correct boundaries of macro calls and directives when; /// building mappings from spelled to expanded tokens.; ///; /// Logically, at each point of the preprocessor execution there is a stack of; /// macro expansions being processed and we could use it to recover the; /// location information we need. However, the public preprocessor API only; /// exposes the points when macro expansions start (when we push a macro onto; /// the stack) and not when they end (when we pop a macro from the stack).; /// To workaround this limitation, we rely on source location information; /// stored in this map.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang/Tooling/Syntax/Tokens.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Syntax/Tokens.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Syntax/Tokens.h:656,Safety,recover,recover,656,"/// Maps from a start to an end spelling location of transformations; /// performed by the preprocessor. These include:; /// 1. range from '#' to the last token in the line for PP directives,; /// 2. macro name and arguments for macro expansions.; /// Note that we record only top-level macro expansions, intermediate; /// expansions (e.g. inside macro arguments) are ignored.; ///; /// Used to find correct boundaries of macro calls and directives when; /// building mappings from spelled to expanded tokens.; ///; /// Logically, at each point of the preprocessor execution there is a stack of; /// macro expansions being processed and we could use it to recover the; /// location information we need. However, the public preprocessor API only; /// exposes the points when macro expansions start (when we push a macro onto; /// the stack) and not when they end (when we pop a macro from the stack).; /// To workaround this limitation, we rely on source location information; /// stored in this map.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang/Tooling/Syntax/Tokens.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Syntax/Tokens.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Syntax/Tokens.h:750,Security,expose,exposes,750,"/// Maps from a start to an end spelling location of transformations; /// performed by the preprocessor. These include:; /// 1. range from '#' to the last token in the line for PP directives,; /// 2. macro name and arguments for macro expansions.; /// Note that we record only top-level macro expansions, intermediate; /// expansions (e.g. inside macro arguments) are ignored.; ///; /// Used to find correct boundaries of macro calls and directives when; /// building mappings from spelled to expanded tokens.; ///; /// Logically, at each point of the preprocessor execution there is a stack of; /// macro expansions being processed and we could use it to recover the; /// location information we need. However, the public preprocessor API only; /// exposes the points when macro expansions start (when we push a macro onto; /// the stack) and not when they end (when we pop a macro from the stack).; /// To workaround this limitation, we rely on source location information; /// stored in this map.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang/Tooling/Syntax/Tokens.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Syntax/Tokens.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Syntax/Tokens.h:520,Testability,Log,Logically,520,"/// Maps from a start to an end spelling location of transformations; /// performed by the preprocessor. These include:; /// 1. range from '#' to the last token in the line for PP directives,; /// 2. macro name and arguments for macro expansions.; /// Note that we record only top-level macro expansions, intermediate; /// expansions (e.g. inside macro arguments) are ignored.; ///; /// Used to find correct boundaries of macro calls and directives when; /// building mappings from spelled to expanded tokens.; ///; /// Logically, at each point of the preprocessor execution there is a stack of; /// macro expansions being processed and we could use it to recover the; /// location information we need. However, the public preprocessor API only; /// exposes the points when macro expansions start (when we push a macro onto; /// the stack) and not when they end (when we pop a macro from the stack).; /// To workaround this limitation, we rely on source location information; /// stored in this map.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang/Tooling/Syntax/Tokens.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Syntax/Tokens.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Syntax/Tree.h:650,Deployability,continuous,continuous,650,"//===- Tree.h - structure of the syntax tree ------------------*- C++ -*-=====//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; // Defines the basic structure of the syntax tree. There are two kinds of nodes:; // - leaf nodes correspond to tokens,; // - tree nodes correspond to language grammar constructs.; //; // The tree is initially built from an AST. Each node of a newly built tree; // covers a continuous subrange of expanded tokens (i.e. tokens after; // preprocessing), the specific tokens coverered are stored in the leaf nodes of; // a tree. A post-order traversal of a tree will visit leaf nodes in an order; // corresponding the original order of expanded tokens.; //; // This is still work in progress and highly experimental, we leave room for; // ourselves to completely change the design and/or implementation.; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang/Tooling/Syntax/Tree.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Syntax/Tree.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Syntax/Tree.h:18,Energy Efficiency,allocate,allocated,18,/// Keeps all the allocated nodes and their intermediate data structures.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang/Tooling/Syntax/Tree.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Syntax/Tree.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Syntax/Tree.h:14,Energy Efficiency,allocate,allocated,14,/// Nodes are allocated on Arenas; the destructor is never called.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang/Tooling/Syntax/Tree.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Syntax/Tree.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Syntax/Tree.h:17,Usability,simpl,simply,17,/// Nodes cannot simply be copied without violating tree invariants.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang/Tooling/Syntax/Tree.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Syntax/Tree.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Syntax/Tree.h:29,Energy Efficiency,allocate,allocated,29,"/// Idiomatically, nodes are allocated on an Arena and never moved.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang/Tooling/Syntax/Tree.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Syntax/Tree.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Syntax/Tree.h:330,Usability,simpl,simply,330,"/// Whether the node was created from the AST backed by the source code; /// rather than added later through mutation APIs or created with factory; /// functions.; /// When this flag is true, all subtrees are also original.; /// This flag is set to false on any modifications to the node or any of its; /// subtrees, even if this simply involves swapping existing subtrees.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang/Tooling/Syntax/Tree.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Syntax/Tree.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Syntax/Tree.h:56,Testability,test,testing,56,/// Dumps the structure of a subtree. For debugging and testing purposes.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang/Tooling/Syntax/Tree.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Syntax/Tree.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Syntax/Tree.h:4,Testability,Assert,Asserts,4,/// Asserts invariants on this node of the tree and its immediate children.; /// Will not recurse into the subtree. No-op if NDEBUG is set.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang/Tooling/Syntax/Tree.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Syntax/Tree.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Syntax/Tree.h:146,Availability,error,errors,146,/// Whether this list can be empty in syntactically and semantically correct; /// code.; ///; /// This list may be empty when the source code has errors even if; /// canBeEmpty() returns false.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang/Tooling/Syntax/Tree.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Syntax/Tree.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Transformer/MatchConsumer.h:105,Availability,error,errors,105,/// A failable computation over nodes bound by AST matchers.; ///; /// The computation should report any errors though its return value (rather; /// than terminating the program) to enable usage in interactive scenarios like; /// clang-query.; ///; /// This is a central abstraction of the Transformer framework.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang/Tooling/Transformer/MatchConsumer.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Transformer/MatchConsumer.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Transformer/MatchConsumer.h:15,Availability,error,error,15,"/// Creates an error that signals that a `MatchConsumer` expected a certain node; /// to be bound by AST matchers, but it was not actually bound.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang/Tooling/Transformer/MatchConsumer.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Transformer/MatchConsumer.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Transformer/MatchConsumer.h:163,Availability,error,errors,163,"/// A failable computation over nodes bound by AST matchers, with (limited); /// reflection via the `toString` method.; ///; /// The computation should report any errors though its return value (rather; /// than terminating the program) to enable usage in interactive scenarios like; /// clang-query.; ///; /// This is a central abstraction of the Transformer framework. It is a; /// generalization of `MatchConsumer` and intended to replace it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang/Tooling/Transformer/MatchConsumer.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Transformer/MatchConsumer.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Transformer/MatchConsumer.h:129,Availability,error,error,129,/// Evaluates the computation and (potentially) updates the accumulator \c; /// Result. \c Result is undefined in the case of an error. `Result` is an; /// out parameter to optimize case where the computation involves composing; /// the result of sub-computation evaluations.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang/Tooling/Transformer/MatchConsumer.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Transformer/MatchConsumer.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Transformer/MatchConsumer.h:48,Deployability,update,updates,48,/// Evaluates the computation and (potentially) updates the accumulator \c; /// Result. \c Result is undefined in the case of an error. `Result` is an; /// out parameter to optimize case where the computation involves composing; /// the result of sub-computation evaluations.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang/Tooling/Transformer/MatchConsumer.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Transformer/MatchConsumer.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Transformer/MatchConsumer.h:173,Performance,optimiz,optimize,173,/// Evaluates the computation and (potentially) updates the accumulator \c; /// Result. \c Result is undefined in the case of an error. `Result` is an; /// out parameter to optimize case where the computation involves composing; /// the result of sub-computation evaluations.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang/Tooling/Transformer/MatchConsumer.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Transformer/MatchConsumer.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Transformer/RewriteRule.h:9,Modifiability,Rewrite,RewriteRule,9,"//===--- RewriteRule.h - RewriteRule class ----------------------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; ///; /// \file; /// Defines the RewriteRule class and related functions for creating,; /// modifying and interpreting RewriteRules.; ///; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang/Tooling/Transformer/RewriteRule.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Transformer/RewriteRule.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Transformer/RewriteRule.h:25,Modifiability,Rewrite,RewriteRule,25,"//===--- RewriteRule.h - RewriteRule class ----------------------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; ///; /// \file; /// Defines the RewriteRule class and related functions for creating,; /// modifying and interpreting RewriteRules.; ///; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang/Tooling/Transformer/RewriteRule.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Transformer/RewriteRule.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Transformer/RewriteRule.h:408,Modifiability,Rewrite,RewriteRule,408,"//===--- RewriteRule.h - RewriteRule class ----------------------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; ///; /// \file; /// Defines the RewriteRule class and related functions for creating,; /// modifying and interpreting RewriteRules.; ///; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang/Tooling/Transformer/RewriteRule.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Transformer/RewriteRule.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Transformer/RewriteRule.h:494,Modifiability,Rewrite,RewriteRules,494,"//===--- RewriteRule.h - RewriteRule class ----------------------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; ///; /// \file; /// Defines the RewriteRule class and related functions for creating,; /// modifying and interpreting RewriteRules.; ///; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang/Tooling/Transformer/RewriteRule.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Transformer/RewriteRule.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Transformer/RewriteRule.h:72,Availability,failure,failure,72,"/// Maps a match result to a list of concrete edits (with possible; /// failure). This type is a building block of rewrite rules, but users will; /// generally work in terms of `ASTEdit`s (below) rather than directly in terms; /// of `EditGenerator`.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang/Tooling/Transformer/RewriteRule.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Transformer/RewriteRule.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Transformer/RewriteRule.h:115,Modifiability,rewrite,rewrite,115,"/// Maps a match result to a list of concrete edits (with possible; /// failure). This type is a building block of rewrite rules, but users will; /// generally work in terms of `ASTEdit`s (below) rather than directly in terms; /// of `EditGenerator`.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang/Tooling/Transformer/RewriteRule.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Transformer/RewriteRule.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Transformer/RewriteRule.h:994,Modifiability,rewrite,rewrite,994,"// Description of a source-code edit, expressed in terms of an AST node.; // Includes: an ID for the (bound) node, a selector for source related to the; // node, a replacement and, optionally, an explanation for the edit.; //; // * Target: the source code impacted by the rule. This identifies an AST node,; // or part thereof (\c Part), whose source range indicates the extent of the; // replacement applied by the replacement term. By default, the extent is the; // node matched by the pattern term (\c NodePart::Node). Target's are typed; // (\c Kind), which guides the determination of the node extent.; //; // * Replacement: a function that produces a replacement string for the target,; // based on the match result.; //; // * Note: (optional) a note specifically for this edit, potentially referencing; // elements of the match. This will be displayed to the user, where possible;; // for example, in clang-tidy diagnostics. Use of notes should be rare --; // explanations of the entire rewrite should be set in the rule; // (`RewriteRule::Explanation`) instead. Notes serve the rare cases wherein; // edit-specific diagnostics are required.; //; // `ASTEdit` should be built using the `change` convenience functions. For; // example,; // \code; // changeTo(name(fun), cat(""Frodo"")); // \endcode; // Or, if we use Stencil for the TextGenerator:; // \code; // using stencil::cat;; // changeTo(statement(thenNode), cat(""{"", thenNode, ""}"")); // changeTo(callArgs(call), cat(x, "","", y)); // \endcode; // Or, if you are changing the node corresponding to the rule's matcher, you can; // use the single-argument override of \c change:; // \code; // changeTo(cat(""different_expr"")); // \endcode",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang/Tooling/Transformer/RewriteRule.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Transformer/RewriteRule.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Transformer/RewriteRule.h:1034,Modifiability,Rewrite,RewriteRule,1034,"// Description of a source-code edit, expressed in terms of an AST node.; // Includes: an ID for the (bound) node, a selector for source related to the; // node, a replacement and, optionally, an explanation for the edit.; //; // * Target: the source code impacted by the rule. This identifies an AST node,; // or part thereof (\c Part), whose source range indicates the extent of the; // replacement applied by the replacement term. By default, the extent is the; // node matched by the pattern term (\c NodePart::Node). Target's are typed; // (\c Kind), which guides the determination of the node extent.; //; // * Replacement: a function that produces a replacement string for the target,; // based on the match result.; //; // * Note: (optional) a note specifically for this edit, potentially referencing; // elements of the match. This will be displayed to the user, where possible;; // for example, in clang-tidy diagnostics. Use of notes should be rare --; // explanations of the entire rewrite should be set in the rule; // (`RewriteRule::Explanation`) instead. Notes serve the rare cases wherein; // edit-specific diagnostics are required.; //; // `ASTEdit` should be built using the `change` convenience functions. For; // example,; // \code; // changeTo(name(fun), cat(""Frodo"")); // \endcode; // Or, if we use Stencil for the TextGenerator:; // \code; // using stencil::cat;; // changeTo(statement(thenNode), cat(""{"", thenNode, ""}"")); // changeTo(callArgs(call), cat(x, "","", y)); // \endcode; // Or, if you are changing the node corresponding to the rule's matcher, you can; // use the single-argument override of \c change:; // \code; // changeTo(cat(""different_expr"")); // \endcode",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang/Tooling/Transformer/RewriteRule.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Transformer/RewriteRule.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Transformer/RewriteRule.h:562,Usability,guid,guides,562,"// Description of a source-code edit, expressed in terms of an AST node.; // Includes: an ID for the (bound) node, a selector for source related to the; // node, a replacement and, optionally, an explanation for the edit.; //; // * Target: the source code impacted by the rule. This identifies an AST node,; // or part thereof (\c Part), whose source range indicates the extent of the; // replacement applied by the replacement term. By default, the extent is the; // node matched by the pattern term (\c NodePart::Node). Target's are typed; // (\c Kind), which guides the determination of the node extent.; //; // * Replacement: a function that produces a replacement string for the target,; // based on the match result.; //; // * Note: (optional) a note specifically for this edit, potentially referencing; // elements of the match. This will be displayed to the user, where possible;; // for example, in clang-tidy diagnostics. Use of notes should be rare --; // explanations of the entire rewrite should be set in the rule; // (`RewriteRule::Explanation`) instead. Notes serve the rare cases wherein; // edit-specific diagnostics are required.; //; // `ASTEdit` should be built using the `change` convenience functions. For; // example,; // \code; // changeTo(name(fun), cat(""Frodo"")); // \endcode; // Or, if we use Stencil for the TextGenerator:; // \code; // using stencil::cat;; // changeTo(statement(thenNode), cat(""{"", thenNode, ""}"")); // changeTo(callArgs(call), cat(x, "","", y)); // \endcode; // Or, if you are changing the node corresponding to the rule's matcher, you can; // use the single-argument override of \c change:; // \code; // changeTo(cat(""different_expr"")); // \endcode",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang/Tooling/Transformer/RewriteRule.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Transformer/RewriteRule.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Transformer/RewriteRule.h:549,Safety,detect,detecting,549,"/// Lifts a list of `ASTEdit`s into an `EditGenerator`.; ///; /// The `EditGenerator` will return an empty vector if any of the edits apply to; /// portions of the source that are ineligible for rewriting (certain; /// interactions with macros, for example) and it will fail if any invariants; /// are violated relating to bound nodes in the match. However, it does not; /// fail in the case of conflicting edits -- conflict handling is left to; /// clients. We recommend use of the \c AtomicChange or \c Replacements classes; /// for assistance in detecting such conflicts.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang/Tooling/Transformer/RewriteRule.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Transformer/RewriteRule.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Transformer/RewriteRule.h:9,Modifiability,rewrite,rewrite,9,// Every rewrite rule is triggered by a match against some AST node.; // Transformer guarantees that this ID is bound to the triggering node whenever; // a rewrite rule is applied.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang/Tooling/Transformer/RewriteRule.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Transformer/RewriteRule.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Transformer/RewriteRule.h:156,Modifiability,rewrite,rewrite,156,// Every rewrite rule is triggered by a match against some AST node.; // Transformer guarantees that this ID is bound to the triggering node whenever; // a rewrite rule is applied.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang/Tooling/Transformer/RewriteRule.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Transformer/RewriteRule.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Transformer/RewriteRule.h:31,Modifiability,Rewrite,RewriteRule,31,"/// Replaces the entirety of a RewriteRule's match with \p Replacement. For; /// example, to replace a function call, one could write:; /// \code; /// makeRule(callExpr(callee(functionDecl(hasName(""foo"")))),; /// changeTo(cat(""bar()""))); /// \endcode",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang/Tooling/Transformer/RewriteRule.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Transformer/RewriteRule.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Transformer/RewriteRule.h:133,Availability,error,error,133,"// FIXME: If `Metadata` returns an `llvm::Expected<T>` the `AnyGenerator` will; // construct an `llvm::Expected<llvm::Any>` where no error is present but the; // `llvm::Any` holds the error. This is unlikely but potentially surprising.; // Perhaps the `llvm::Expected` should be unwrapped, or perhaps this should be a; // compile-time error. No solution here is perfect.; //; // Note: This function template accepts any type callable with a MatchResult; // rather than a `std::function` because the return-type needs to be deduced. If; // it accepted a `std::function<R(MatchResult)>`, lambdas or other callable; // types would not be able to deduce `R`, and users would be forced to specify; // explicitly the type they intended to return by wrapping the lambda at the; // call-site.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang/Tooling/Transformer/RewriteRule.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Transformer/RewriteRule.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Transformer/RewriteRule.h:184,Availability,error,error,184,"// FIXME: If `Metadata` returns an `llvm::Expected<T>` the `AnyGenerator` will; // construct an `llvm::Expected<llvm::Any>` where no error is present but the; // `llvm::Any` holds the error. This is unlikely but potentially surprising.; // Perhaps the `llvm::Expected` should be unwrapped, or perhaps this should be a; // compile-time error. No solution here is perfect.; //; // Note: This function template accepts any type callable with a MatchResult; // rather than a `std::function` because the return-type needs to be deduced. If; // it accepted a `std::function<R(MatchResult)>`, lambdas or other callable; // types would not be able to deduce `R`, and users would be forced to specify; // explicitly the type they intended to return by wrapping the lambda at the; // call-site.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang/Tooling/Transformer/RewriteRule.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Transformer/RewriteRule.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Transformer/RewriteRule.h:335,Availability,error,error,335,"// FIXME: If `Metadata` returns an `llvm::Expected<T>` the `AnyGenerator` will; // construct an `llvm::Expected<llvm::Any>` where no error is present but the; // `llvm::Any` holds the error. This is unlikely but potentially surprising.; // Perhaps the `llvm::Expected` should be unwrapped, or perhaps this should be a; // compile-time error. No solution here is perfect.; //; // Note: This function template accepts any type callable with a MatchResult; // rather than a `std::function` because the return-type needs to be deduced. If; // it accepted a `std::function<R(MatchResult)>`, lambdas or other callable; // types would not be able to deduce `R`, and users would be forced to specify; // explicitly the type they intended to return by wrapping the lambda at the; // call-site.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang/Tooling/Transformer/RewriteRule.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Transformer/RewriteRule.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Transformer/RewriteRule.h:743,Integrability,wrap,wrapping,743,"// FIXME: If `Metadata` returns an `llvm::Expected<T>` the `AnyGenerator` will; // construct an `llvm::Expected<llvm::Any>` where no error is present but the; // `llvm::Any` holds the error. This is unlikely but potentially surprising.; // Perhaps the `llvm::Expected` should be unwrapped, or perhaps this should be a; // compile-time error. No solution here is perfect.; //; // Note: This function template accepts any type callable with a MatchResult; // rather than a `std::function` because the return-type needs to be deduced. If; // it accepted a `std::function<R(MatchResult)>`, lambdas or other callable; // types would not be able to deduce `R`, and users would be forced to specify; // explicitly the type they intended to return by wrapping the lambda at the; // call-site.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang/Tooling/Transformer/RewriteRule.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Transformer/RewriteRule.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Transformer/RewriteRule.h:60,Modifiability,rewrite,rewrite,60,"/// Description of a source-code transformation.; //; // A *rewrite rule* describes a transformation of source code. A simple rule; // contains each of the following components:; //; // * Matcher: the pattern term, expressed as clang matchers (with Transformer; // extensions).; //; // * Edits: a set of Edits to the source code, described with ASTEdits.; //; // However, rules can also consist of (sub)rules, where the first that matches; // is applied and the rest are ignored. So, the above components together form; // a logical ""case"" and a rule is a sequence of cases.; //; // Rule cases have an additional, implicit, component: the parameters. These are; // portions of the pattern which are left unspecified, yet bound in the pattern; // so that we can reference them in the edits.; //; // The \c Transformer class can be used to apply the rewrite rule and obtain the; // corresponding replacements.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang/Tooling/Transformer/RewriteRule.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Transformer/RewriteRule.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Transformer/RewriteRule.h:848,Modifiability,rewrite,rewrite,848,"/// Description of a source-code transformation.; //; // A *rewrite rule* describes a transformation of source code. A simple rule; // contains each of the following components:; //; // * Matcher: the pattern term, expressed as clang matchers (with Transformer; // extensions).; //; // * Edits: a set of Edits to the source code, described with ASTEdits.; //; // However, rules can also consist of (sub)rules, where the first that matches; // is applied and the rest are ignored. So, the above components together form; // a logical ""case"" and a rule is a sequence of cases.; //; // Rule cases have an additional, implicit, component: the parameters. These are; // portions of the pattern which are left unspecified, yet bound in the pattern; // so that we can reference them in the edits.; //; // The \c Transformer class can be used to apply the rewrite rule and obtain the; // corresponding replacements.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang/Tooling/Transformer/RewriteRule.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Transformer/RewriteRule.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Transformer/RewriteRule.h:525,Testability,log,logical,525,"/// Description of a source-code transformation.; //; // A *rewrite rule* describes a transformation of source code. A simple rule; // contains each of the following components:; //; // * Matcher: the pattern term, expressed as clang matchers (with Transformer; // extensions).; //; // * Edits: a set of Edits to the source code, described with ASTEdits.; //; // However, rules can also consist of (sub)rules, where the first that matches; // is applied and the rest are ignored. So, the above components together form; // a logical ""case"" and a rule is a sequence of cases.; //; // Rule cases have an additional, implicit, component: the parameters. These are; // portions of the pattern which are left unspecified, yet bound in the pattern; // so that we can reference them in the edits.; //; // The \c Transformer class can be used to apply the rewrite rule and obtain the; // corresponding replacements.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang/Tooling/Transformer/RewriteRule.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Transformer/RewriteRule.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Transformer/RewriteRule.h:119,Usability,simpl,simple,119,"/// Description of a source-code transformation.; //; // A *rewrite rule* describes a transformation of source code. A simple rule; // contains each of the following components:; //; // * Matcher: the pattern term, expressed as clang matchers (with Transformer; // extensions).; //; // * Edits: a set of Edits to the source code, described with ASTEdits.; //; // However, rules can also consist of (sub)rules, where the first that matches; // is applied and the rest are ignored. So, the above components together form; // a logical ""case"" and a rule is a sequence of cases.; //; // Rule cases have an additional, implicit, component: the parameters. These are; // portions of the pattern which are left unspecified, yet bound in the pattern; // so that we can reference them in the edits.; //; // The \c Transformer class can be used to apply the rewrite rule and obtain the; // corresponding replacements.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang/Tooling/Transformer/RewriteRule.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Transformer/RewriteRule.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Transformer/RewriteRule.h:13,Modifiability,Rewrite,RewriteRules,13,// We expect RewriteRules will most commonly include only one case.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang/Tooling/Transformer/RewriteRule.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Transformer/RewriteRule.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Transformer/RewriteRule.h:48,Modifiability,Rewrite,RewriteRule,48,"// namespace detail; /// Constructs a simple \c RewriteRule. \c Edits can be an \c EditGenerator,; /// multiple \c ASTEdits, or a single \c ASTEdit.; /// @{",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang/Tooling/Transformer/RewriteRule.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Transformer/RewriteRule.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Transformer/RewriteRule.h:38,Usability,simpl,simple,38,"// namespace detail; /// Constructs a simple \c RewriteRule. \c Edits can be an \c EditGenerator,; /// multiple \c ASTEdits, or a single \c ASTEdit.; /// @{",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang/Tooling/Transformer/RewriteRule.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Transformer/RewriteRule.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Transformer/RewriteRule.h:1624,Modifiability,Rewrite,RewriteRule,1624,"/// Applies the first rule whose pattern matches; other rules are ignored. If; /// the matchers are independent then order doesn't matter. In that case,; /// `applyFirst` is simply joining the set of rules into one.; //; // `applyFirst` is like an `anyOf` matcher with an edit action attached to each; // of its cases. Anywhere you'd use `anyOf(m1.bind(""id1""), m2.bind(""id2""))` and; // then dispatch on those ids in your code for control flow, `applyFirst` lifts; // that behavior to the rule level. So, you can write `applyFirst({makeRule(m1,; // action1), makeRule(m2, action2), ...});`; //; // For example, consider a type `T` with a deterministic serialization function,; // `serialize()`. For performance reasons, we would like to make it; // non-deterministic. Therefore, we want to drop the expectation that; // `a.serialize() = b.serialize() iff a = b` (although we'll maintain; // `deserialize(a.serialize()) = a`).; //; // We have three cases to consider (for some equality function, `eq`):; // ```; // eq(a.serialize(), b.serialize()) --> eq(a,b); // eq(a, b.serialize()) --> eq(deserialize(a), b); // eq(a.serialize(), b) --> eq(a, deserialize(b)); // ```; //; // `applyFirst` allows us to specify each independently:; // ```; // auto eq_fun = functionDecl(...);; // auto method_call = cxxMemberCallExpr(...);; //; // auto two_calls = callExpr(callee(eq_fun), hasArgument(0, method_call),; // hasArgument(1, method_call));; // auto left_call =; // callExpr(callee(eq_fun), callExpr(hasArgument(0, method_call)));; // auto right_call =; // callExpr(callee(eq_fun), callExpr(hasArgument(1, method_call)));; //; // RewriteRule R = applyFirst({makeRule(two_calls, two_calls_action),; // makeRule(left_call, left_call_action),; // makeRule(right_call, right_call_action)});; // ```; /// @{",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang/Tooling/Transformer/RewriteRule.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Transformer/RewriteRule.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Transformer/RewriteRule.h:698,Performance,perform,performance,698,"/// Applies the first rule whose pattern matches; other rules are ignored. If; /// the matchers are independent then order doesn't matter. In that case,; /// `applyFirst` is simply joining the set of rules into one.; //; // `applyFirst` is like an `anyOf` matcher with an edit action attached to each; // of its cases. Anywhere you'd use `anyOf(m1.bind(""id1""), m2.bind(""id2""))` and; // then dispatch on those ids in your code for control flow, `applyFirst` lifts; // that behavior to the rule level. So, you can write `applyFirst({makeRule(m1,; // action1), makeRule(m2, action2), ...});`; //; // For example, consider a type `T` with a deterministic serialization function,; // `serialize()`. For performance reasons, we would like to make it; // non-deterministic. Therefore, we want to drop the expectation that; // `a.serialize() = b.serialize() iff a = b` (although we'll maintain; // `deserialize(a.serialize()) = a`).; //; // We have three cases to consider (for some equality function, `eq`):; // ```; // eq(a.serialize(), b.serialize()) --> eq(a,b); // eq(a, b.serialize()) --> eq(deserialize(a), b); // eq(a.serialize(), b) --> eq(a, deserialize(b)); // ```; //; // `applyFirst` allows us to specify each independently:; // ```; // auto eq_fun = functionDecl(...);; // auto method_call = cxxMemberCallExpr(...);; //; // auto two_calls = callExpr(callee(eq_fun), hasArgument(0, method_call),; // hasArgument(1, method_call));; // auto left_call =; // callExpr(callee(eq_fun), callExpr(hasArgument(0, method_call)));; // auto right_call =; // callExpr(callee(eq_fun), callExpr(hasArgument(1, method_call)));; //; // RewriteRule R = applyFirst({makeRule(two_calls, two_calls_action),; // makeRule(left_call, left_call_action),; // makeRule(right_call, right_call_action)});; // ```; /// @{",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang/Tooling/Transformer/RewriteRule.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Transformer/RewriteRule.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Transformer/RewriteRule.h:174,Usability,simpl,simply,174,"/// Applies the first rule whose pattern matches; other rules are ignored. If; /// the matchers are independent then order doesn't matter. In that case,; /// `applyFirst` is simply joining the set of rules into one.; //; // `applyFirst` is like an `anyOf` matcher with an edit action attached to each; // of its cases. Anywhere you'd use `anyOf(m1.bind(""id1""), m2.bind(""id2""))` and; // then dispatch on those ids in your code for control flow, `applyFirst` lifts; // that behavior to the rule level. So, you can write `applyFirst({makeRule(m1,; // action1), makeRule(m2, action2), ...});`; //; // For example, consider a type `T` with a deterministic serialization function,; // `serialize()`. For performance reasons, we would like to make it; // non-deterministic. Therefore, we want to drop the expectation that; // `a.serialize() = b.serialize() iff a = b` (although we'll maintain; // `deserialize(a.serialize()) = a`).; //; // We have three cases to consider (for some equality function, `eq`):; // ```; // eq(a.serialize(), b.serialize()) --> eq(a,b); // eq(a, b.serialize()) --> eq(deserialize(a), b); // eq(a.serialize(), b) --> eq(a, deserialize(b)); // ```; //; // `applyFirst` allows us to specify each independently:; // ```; // auto eq_fun = functionDecl(...);; // auto method_call = cxxMemberCallExpr(...);; //; // auto two_calls = callExpr(callee(eq_fun), hasArgument(0, method_call),; // hasArgument(1, method_call));; // auto left_call =; // callExpr(callee(eq_fun), callExpr(hasArgument(0, method_call)));; // auto right_call =; // callExpr(callee(eq_fun), callExpr(hasArgument(1, method_call)));; //; // RewriteRule R = applyFirst({makeRule(two_calls, two_calls_action),; // makeRule(left_call, left_call_action),; // makeRule(right_call, right_call_action)});; // ```; /// @{",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang/Tooling/Transformer/RewriteRule.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Transformer/RewriteRule.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Transformer/RewriteRule.h:26,Modifiability,Rewrite,RewriteRuleWith,26,/// @}; /// Converts a \c RewriteRuleWith<T> to a \c RewriteRule by stripping off the; /// metadata generators.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang/Tooling/Transformer/RewriteRule.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Transformer/RewriteRule.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Transformer/RewriteRule.h:53,Modifiability,Rewrite,RewriteRule,53,/// @}; /// Converts a \c RewriteRuleWith<T> to a \c RewriteRule by stripping off the; /// metadata generators.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang/Tooling/Transformer/RewriteRule.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Transformer/RewriteRule.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Transformer/RewriteRule.h:444,Modifiability,rewrite,rewriteDescendants,444,"/// Applies `Rule` to all descendants of the node bound to `NodeId`. `Rule` can; /// refer to nodes bound by the calling rule. `Rule` is not applied to the node; /// itself.; ///; /// For example,; /// ```; /// auto InlineX =; /// makeRule(declRefExpr(to(varDecl(hasName(""x"")))), changeTo(cat(""3"")));; /// makeRule(functionDecl(hasName(""f""), hasBody(stmt().bind(""body""))).bind(""f""),; /// flatten(; /// changeTo(name(""f""), cat(""newName"")),; /// rewriteDescendants(""body"", InlineX)));; /// ```; /// Here, we find the function `f`, change its name to `newName` and change all; /// appearances of `x` in its body to `3`.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang/Tooling/Transformer/RewriteRule.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Transformer/RewriteRule.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Transformer/RewriteRule.h:62,Modifiability,Rewrite,RewriteRule,62,"/// The following three functions are a low-level part of the RewriteRule; /// API. We expose them for use in implementing the fixtures that interpret; /// RewriteRule, like Transformer and TransfomerTidy, or for more advanced; /// users.; //; // FIXME: These functions are really public, if advanced, elements of the; // RewriteRule API. Recast them as such. Or, just declare these functions; // public and well-supported and move them out of `detail`.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang/Tooling/Transformer/RewriteRule.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Transformer/RewriteRule.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Transformer/RewriteRule.h:156,Modifiability,Rewrite,RewriteRule,156,"/// The following three functions are a low-level part of the RewriteRule; /// API. We expose them for use in implementing the fixtures that interpret; /// RewriteRule, like Transformer and TransfomerTidy, or for more advanced; /// users.; //; // FIXME: These functions are really public, if advanced, elements of the; // RewriteRule API. Recast them as such. Or, just declare these functions; // public and well-supported and move them out of `detail`.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang/Tooling/Transformer/RewriteRule.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Transformer/RewriteRule.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Transformer/RewriteRule.h:322,Modifiability,Rewrite,RewriteRule,322,"/// The following three functions are a low-level part of the RewriteRule; /// API. We expose them for use in implementing the fixtures that interpret; /// RewriteRule, like Transformer and TransfomerTidy, or for more advanced; /// users.; //; // FIXME: These functions are really public, if advanced, elements of the; // RewriteRule API. Recast them as such. Or, just declare these functions; // public and well-supported and move them out of `detail`.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang/Tooling/Transformer/RewriteRule.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Transformer/RewriteRule.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Transformer/RewriteRule.h:87,Security,expose,expose,87,"/// The following three functions are a low-level part of the RewriteRule; /// API. We expose them for use in implementing the fixtures that interpret; /// RewriteRule, like Transformer and TransfomerTidy, or for more advanced; /// users.; //; // FIXME: These functions are really public, if advanced, elements of the; // RewriteRule API. Recast them as such. Or, just declare these functions; // public and well-supported and move them out of `detail`.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang/Tooling/Transformer/RewriteRule.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Transformer/RewriteRule.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Transformer/RewriteRule.h:48,Modifiability,rewrite,rewriteDescendants,48,"/// The following overload set is a version of `rewriteDescendants` that; /// operates directly on the AST, rather than generating a Transformer; /// combinator. It applies `Rule` to all descendants of `Node`, although not; /// `Node` itself. `Rule` can refer to nodes bound in `Result`.; ///; /// For example, assuming that ""body"" is bound to a function body in MatchResult; /// `Results`, this will produce edits to change all appearances of `x` in that; /// body to `3`.; /// ```; /// auto InlineX =; /// makeRule(declRefExpr(to(varDecl(hasName(""x"")))), changeTo(cat(""3"")));; /// const auto *Node = Results.Nodes.getNodeAs<Stmt>(""body"");; /// auto Edits = rewriteDescendants(*Node, InlineX, Results);; /// ```; /// @{",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang/Tooling/Transformer/RewriteRule.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Transformer/RewriteRule.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Transformer/RewriteRule.h:659,Modifiability,rewrite,rewriteDescendants,659,"/// The following overload set is a version of `rewriteDescendants` that; /// operates directly on the AST, rather than generating a Transformer; /// combinator. It applies `Rule` to all descendants of `Node`, although not; /// `Node` itself. `Rule` can refer to nodes bound in `Result`.; ///; /// For example, assuming that ""body"" is bound to a function body in MatchResult; /// `Results`, this will produce edits to change all appearances of `x` in that; /// body to `3`.; /// ```; /// auto InlineX =; /// makeRule(declRefExpr(to(varDecl(hasName(""x"")))), changeTo(cat(""3"")));; /// const auto *Node = Results.Nodes.getNodeAs<Stmt>(""body"");; /// auto Edits = rewriteDescendants(*Node, InlineX, Results);; /// ```; /// @{",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang/Tooling/Transformer/RewriteRule.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Transformer/RewriteRule.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Transformer/RewriteRule.h:59,Modifiability,rewrite,rewrite,59,"/// Gets the beginning location of the source matched by a rewrite rule. If the; /// match occurs within a macro expansion, returns the beginning of the; /// expansion point. `Result` must come from the matching of a rewrite rule.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang/Tooling/Transformer/RewriteRule.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Transformer/RewriteRule.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Transformer/RewriteRule.h:217,Modifiability,rewrite,rewrite,217,"/// Gets the beginning location of the source matched by a rewrite rule. If the; /// match occurs within a macro expansion, returns the beginning of the; /// expansion point. `Result` must come from the matching of a rewrite rule.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang/Tooling/Transformer/RewriteRule.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Transformer/RewriteRule.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Transformer/SourceCode.h:49,Integrability,rout,routines,49,"//===--- SourceCode.h - Source code manipulation routines -------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file provides functions that simplify extraction of source code.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang/Tooling/Transformer/SourceCode.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Transformer/SourceCode.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Transformer/SourceCode.h:417,Usability,simpl,simplify,417,"//===--- SourceCode.h - Source code manipulation routines -------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file provides functions that simplify extraction of source code.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang/Tooling/Transformer/SourceCode.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Transformer/SourceCode.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Transformer/SourceCode.h:4,Modifiability,Extend,Extends,4,"/// Extends \p Range to include the token \p Terminator, if it immediately; /// follows the end of the range. Otherwise, returns \p Range unchanged.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang/Tooling/Transformer/SourceCode.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Transformer/SourceCode.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Transformer/SourceCode.h:48,Modifiability,extend,extended,48,"/// Returns the source range spanning the node, extended to include \p Next, if; /// it immediately follows \p Node. Otherwise, returns the normal range of \p; /// Node. See comments on `getExtendedText()` for examples.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang/Tooling/Transformer/SourceCode.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Transformer/SourceCode.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Transformer/SourceCode.h:49,Modifiability,extend,extended,49,"/// Returns the logical source range of the node extended to include associated; /// comments and whitespace before and after the node, and associated; /// terminators. The returned range consists of file locations, if valid file; /// locations can be found for the associated content; otherwise, an invalid; /// range is returned.; ///; /// Note that parsing comments is disabled by default. In order to select a; /// range containing associated comments, you may need to invoke the tool with; /// `-fparse-all-comments`.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang/Tooling/Transformer/SourceCode.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Transformer/SourceCode.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Transformer/SourceCode.h:16,Testability,log,logical,16,"/// Returns the logical source range of the node extended to include associated; /// comments and whitespace before and after the node, and associated; /// terminators. The returned range consists of file locations, if valid file; /// locations can be found for the associated content; otherwise, an invalid; /// range is returned.; ///; /// Note that parsing comments is disabled by default. In order to select a; /// range containing associated comments, you may need to invoke the tool with; /// `-fparse-all-comments`.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang/Tooling/Transformer/SourceCode.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Transformer/SourceCode.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Transformer/SourceCode.h:41,Modifiability,extend,extended,41,"/// Returns the source text of the node, extended to include \p Next, if it; /// immediately follows the node. Otherwise, returns the text of just \p Node.; ///; /// For example, given statements S1 and S2 below:; /// \code; /// {; /// // S1:; /// if (!x) return foo();; /// // S2:; /// if (!x) { return 3; }; /// }; /// \endcode; /// then; /// \code; /// getText(S1, Context) = ""if (!x) return foo()""; /// getExtendedText(S1, tok::TokenKind::semi, Context); /// = ""if (!x) return foo();""; /// getExtendedText(*S1.getThen(), tok::TokenKind::semi, Context); /// = ""return foo();""; /// getExtendedText(*S2.getThen(), tok::TokenKind::semi, Context); /// = getText(S2, Context) = ""{ return 3; }""; /// \endcode",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang/Tooling/Transformer/SourceCode.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Transformer/SourceCode.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Transformer/SourceCode.h:63,Modifiability,rewrite,rewrite,63,"/// Determines whether \p Range is one that can be edited by a rewrite;; /// generally, one that starts and ends within a particular file.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang/Tooling/Transformer/SourceCode.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Transformer/SourceCode.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Transformer/SourceCode.h:154,Security,validat,validation,154,"/// Determines whether \p Range is one that can be read from. If; /// `AllowSystemHeaders` is false, a range that falls within a system header; /// fails validation.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang/Tooling/Transformer/SourceCode.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Transformer/SourceCode.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Transformer/SourceCode.h:71,Modifiability,rewrite,rewrite,71,"/// Attempts to resolve the given range to one that can be edited by a rewrite;; /// generally, one that starts and ends within a particular file. If a value is; /// returned, it satisfies \c validateEditRange.; ///; /// If \c IncludeMacroExpansion is true, a limited set of cases involving source; /// locations in macro expansions is supported. For example, if we're looking to; /// rewrite the int literal 3 to 6, and we have the following definition:; /// #define DO_NOTHING(x) x; /// then; /// foo(DO_NOTHING(3)); /// will be rewritten to; /// foo(6)",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang/Tooling/Transformer/SourceCode.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Transformer/SourceCode.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Transformer/SourceCode.h:385,Modifiability,rewrite,rewrite,385,"/// Attempts to resolve the given range to one that can be edited by a rewrite;; /// generally, one that starts and ends within a particular file. If a value is; /// returned, it satisfies \c validateEditRange.; ///; /// If \c IncludeMacroExpansion is true, a limited set of cases involving source; /// locations in macro expansions is supported. For example, if we're looking to; /// rewrite the int literal 3 to 6, and we have the following definition:; /// #define DO_NOTHING(x) x; /// then; /// foo(DO_NOTHING(3)); /// will be rewritten to; /// foo(6)",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang/Tooling/Transformer/SourceCode.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Transformer/SourceCode.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Transformer/SourceCode.h:192,Security,validat,validateEditRange,192,"/// Attempts to resolve the given range to one that can be edited by a rewrite;; /// generally, one that starts and ends within a particular file. If a value is; /// returned, it satisfies \c validateEditRange.; ///; /// If \c IncludeMacroExpansion is true, a limited set of cases involving source; /// locations in macro expansions is supported. For example, if we're looking to; /// rewrite the int literal 3 to 6, and we have the following definition:; /// #define DO_NOTHING(x) x; /// then; /// foo(DO_NOTHING(3)); /// will be rewritten to; /// foo(6)",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang/Tooling/Transformer/SourceCode.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Transformer/SourceCode.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Transformer/SourceCodeBuilders.h:150,Availability,failure,failure,150,/// Builds idiomatic source for the dereferencing of `E`: prefix with `*` but; /// simplify when it already begins with `&`. \returns empty string on failure.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang/Tooling/Transformer/SourceCodeBuilders.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Transformer/SourceCodeBuilders.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Transformer/SourceCodeBuilders.h:83,Usability,simpl,simplify,83,/// Builds idiomatic source for the dereferencing of `E`: prefix with `*` but; /// simplify when it already begins with `&`. \returns empty string on failure.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang/Tooling/Transformer/SourceCodeBuilders.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Transformer/SourceCodeBuilders.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Transformer/SourceCodeBuilders.h:151,Availability,failure,failure,151,/// Builds idiomatic source for taking the address of `E`: prefix with `&` but; /// simplify when it already begins with `*`. \returns empty string on failure.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang/Tooling/Transformer/SourceCodeBuilders.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Transformer/SourceCodeBuilders.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Transformer/SourceCodeBuilders.h:84,Usability,simpl,simplify,84,/// Builds idiomatic source for taking the address of `E`: prefix with `&` but; /// simplify when it already begins with `*`. \returns empty string on failure.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang/Tooling/Transformer/SourceCodeBuilders.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Transformer/SourceCodeBuilders.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Transformer/SourceCodeBuilders.h:108,Usability,simpl,simplifies,108,"/// Adds a dot to the end of the given expression, but adds parentheses when; /// needed by the syntax, and simplifies to `->` when possible, e.g.:; ///; /// `x` becomes `x.`; /// `*a` becomes `a->`; /// `a+b` becomes `(a+b).`; ///; /// DEPRECATED. Use `buildAccess`.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang/Tooling/Transformer/SourceCodeBuilders.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Transformer/SourceCodeBuilders.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Transformer/SourceCodeBuilders.h:111,Usability,simpl,simplifies,111,"/// Adds an arrow to the end of the given expression, but adds parentheses; /// when needed by the syntax, and simplifies to `.` when possible, e.g.:; ///; /// `x` becomes `x->`; /// `&a` becomes `a.`; /// `a+b` becomes `(a+b)->`; ///; /// DEPRECATED. Use `buildAccess`.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang/Tooling/Transformer/SourceCodeBuilders.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Transformer/SourceCodeBuilders.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Transformer/SourceCodeBuilders.h:122,Security,access,access,122,/// Specifies how to classify pointer-like types -- like values or like pointers; /// -- with regard to generating member-access syntax.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang/Tooling/Transformer/SourceCodeBuilders.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Transformer/SourceCodeBuilders.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Transformer/SourceCodeBuilders.h:436,Integrability,depend,depending,436,"/// Adds an appropriate access operator (`.`, `->` or nothing, in the case of; /// implicit `this`) to the end of the given expression. Adds parentheses when; /// needed by the syntax and simplifies when possible. If `PLTypeClass` is; /// `Pointer`, for known pointer-like types (see `isKnownPointerLikeType`),; /// treats `operator->` and `operator*` like the built-in `->` and `*`; /// operators.; ///; /// `x` becomes `x->` or `x.`, depending on `E`'s type; /// `a+b` becomes `(a+b)->` or `(a+b).`, depending on `E`'s type; /// `&a` becomes `a.`; /// `*a` becomes `a->`",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang/Tooling/Transformer/SourceCodeBuilders.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Transformer/SourceCodeBuilders.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Transformer/SourceCodeBuilders.h:502,Integrability,depend,depending,502,"/// Adds an appropriate access operator (`.`, `->` or nothing, in the case of; /// implicit `this`) to the end of the given expression. Adds parentheses when; /// needed by the syntax and simplifies when possible. If `PLTypeClass` is; /// `Pointer`, for known pointer-like types (see `isKnownPointerLikeType`),; /// treats `operator->` and `operator*` like the built-in `->` and `*`; /// operators.; ///; /// `x` becomes `x->` or `x.`, depending on `E`'s type; /// `a+b` becomes `(a+b)->` or `(a+b).`, depending on `E`'s type; /// `&a` becomes `a.`; /// `*a` becomes `a->`",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang/Tooling/Transformer/SourceCodeBuilders.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Transformer/SourceCodeBuilders.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Transformer/SourceCodeBuilders.h:24,Security,access,access,24,"/// Adds an appropriate access operator (`.`, `->` or nothing, in the case of; /// implicit `this`) to the end of the given expression. Adds parentheses when; /// needed by the syntax and simplifies when possible. If `PLTypeClass` is; /// `Pointer`, for known pointer-like types (see `isKnownPointerLikeType`),; /// treats `operator->` and `operator*` like the built-in `->` and `*`; /// operators.; ///; /// `x` becomes `x->` or `x.`, depending on `E`'s type; /// `a+b` becomes `(a+b)->` or `(a+b).`, depending on `E`'s type; /// `&a` becomes `a.`; /// `*a` becomes `a->`",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang/Tooling/Transformer/SourceCodeBuilders.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Transformer/SourceCodeBuilders.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Transformer/SourceCodeBuilders.h:188,Usability,simpl,simplifies,188,"/// Adds an appropriate access operator (`.`, `->` or nothing, in the case of; /// implicit `this`) to the end of the given expression. Adds parentheses when; /// needed by the syntax and simplifies when possible. If `PLTypeClass` is; /// `Pointer`, for known pointer-like types (see `isKnownPointerLikeType`),; /// treats `operator->` and `operator*` like the built-in `->` and `*`; /// operators.; ///; /// `x` becomes `x->` or `x.`, depending on `E`'s type; /// `a+b` becomes `(a+b)->` or `(a+b).`, depending on `E`'s type; /// `&a` becomes `a.`; /// `*a` becomes `a->`",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang/Tooling/Transformer/SourceCodeBuilders.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Transformer/SourceCodeBuilders.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Transformer/Stencil.h:472,Modifiability,parameteriz,parameterized,472,"//===--- Stencil.h - Stencil class ------------------------------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; ///; /// \file; /// This file defines the *Stencil* abstraction: a code-generating object,; /// parameterized by named references to (bound) AST nodes. Given a match; /// result, a stencil can be evaluated to a string of source code.; ///; /// A stencil is similar in spirit to a format string: it is composed of a; /// series of raw text strings, references to nodes (the parameters) and helper; /// code-generation operations.; ///; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang/Tooling/Transformer/Stencil.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Transformer/Stencil.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Transformer/Stencil.h:178,Integrability,message,message,178,"/// A sequence of code fragments, references to parameters and code-generation; /// operations that together can be evaluated to (a fragment of) source code or; /// a diagnostic message, given a match result.; ///; /// We use a `shared_ptr` to allow for easy and cheap copying of stencils.; /// Since `StencilInterface` is an immutable interface, the sharing doesn't; /// impose any risks. Otherwise, we would have to add a virtual `copy` method to; /// the API and implement it for all derived classes.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang/Tooling/Transformer/Stencil.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Transformer/Stencil.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Transformer/Stencil.h:336,Integrability,interface,interface,336,"/// A sequence of code fragments, references to parameters and code-generation; /// operations that together can be evaluated to (a fragment of) source code or; /// a diagnostic message, given a match result.; ///; /// We use a `shared_ptr` to allow for easy and cheap copying of stencils.; /// Since `StencilInterface` is an immutable interface, the sharing doesn't; /// impose any risks. Otherwise, we would have to add a virtual `copy` method to; /// the API and implement it for all derived classes.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang/Tooling/Transformer/Stencil.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Transformer/Stencil.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Transformer/Stencil.h:383,Safety,risk,risks,383,"/// A sequence of code fragments, references to parameters and code-generation; /// operations that together can be evaluated to (a fragment of) source code or; /// a diagnostic message, given a match result.; ///; /// We use a `shared_ptr` to allow for easy and cheap copying of stencils.; /// Since `StencilInterface` is an immutable interface, the sharing doesn't; /// impose any risks. Otherwise, we would have to add a virtual `copy` method to; /// the API and implement it for all derived classes.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang/Tooling/Transformer/Stencil.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Transformer/Stencil.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Transformer/Stencil.h:117,Integrability,wrap,wrapping,117,"//; // Functions for conveniently building stencils.; //; /// Generates the source of the expression bound to \p Id, wrapping it in; /// parentheses if it may parse differently depending on context. For example, a; /// binary operation is always wrapped, while a variable reference is never; /// wrapped.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang/Tooling/Transformer/Stencil.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Transformer/Stencil.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Transformer/Stencil.h:177,Integrability,depend,depending,177,"//; // Functions for conveniently building stencils.; //; /// Generates the source of the expression bound to \p Id, wrapping it in; /// parentheses if it may parse differently depending on context. For example, a; /// binary operation is always wrapped, while a variable reference is never; /// wrapped.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang/Tooling/Transformer/Stencil.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Transformer/Stencil.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Transformer/Stencil.h:246,Integrability,wrap,wrapped,246,"//; // Functions for conveniently building stencils.; //; /// Generates the source of the expression bound to \p Id, wrapping it in; /// parentheses if it may parse differently depending on context. For example, a; /// binary operation is always wrapped, while a variable reference is never; /// wrapped.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang/Tooling/Transformer/Stencil.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Transformer/Stencil.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Transformer/Stencil.h:296,Integrability,wrap,wrapped,296,"//; // Functions for conveniently building stencils.; //; /// Generates the source of the expression bound to \p Id, wrapping it in; /// parentheses if it may parse differently depending on context. For example, a; /// binary operation is always wrapped, while a variable reference is never; /// wrapped.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang/Tooling/Transformer/Stencil.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Transformer/Stencil.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Transformer/Stencil.h:263,Modifiability,variab,variable,263,"//; // Functions for conveniently building stencils.; //; /// Generates the source of the expression bound to \p Id, wrapping it in; /// parentheses if it may parse differently depending on context. For example, a; /// binary operation is always wrapped, while a variable reference is never; /// wrapped.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang/Tooling/Transformer/Stencil.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Transformer/Stencil.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Transformer/Stencil.h:98,Integrability,wrap,wrapped,98,"/// Constructs an idiomatic dereferencing of the expression bound to \p ExprId.; /// \p ExprId is wrapped in parentheses, if needed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang/Tooling/Transformer/Stencil.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Transformer/Stencil.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Transformer/Stencil.h:128,Integrability,wrap,wrapping,128,"/// If \p ExprId is of pointer type, constructs an idiomatic dereferencing of; /// the expression bound to \p ExprId, including wrapping it in parentheses, if; /// needed. Otherwise, generates the original expression source.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang/Tooling/Transformer/Stencil.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Transformer/Stencil.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Transformer/Stencil.h:122,Integrability,wrap,wrapped,122,"/// Constructs an expression that idiomatically takes the address of the; /// expression bound to \p ExprId. \p ExprId is wrapped in parentheses, if; /// needed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang/Tooling/Transformer/Stencil.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Transformer/Stencil.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Transformer/Stencil.h:160,Integrability,wrap,wrapping,160,"/// If \p ExprId is not a pointer type, constructs an expression that; /// idiomatically takes the address of the expression bound to \p ExprId,; /// including wrapping \p ExprId in parentheses, if needed. Otherwise, generates; /// the original expression source.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang/Tooling/Transformer/Stencil.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Transformer/Stencil.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Transformer/Stencil.h:341,Integrability,wrap,wrapped,341,"/// Constructs a `MemberExpr` that accesses the named member (\p Member) of the; /// object bound to \p BaseId. The access is constructed idiomatically: if \p; /// BaseId is bound to `e` and \p Member identifies member `m`, then returns; /// `e->m`, when e is a pointer, `e2->m` when e = `*e2` and `e.m` otherwise.; /// Additionally, `e` is wrapped in parentheses, if needed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang/Tooling/Transformer/Stencil.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Transformer/Stencil.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Transformer/Stencil.h:35,Security,access,accesses,35,"/// Constructs a `MemberExpr` that accesses the named member (\p Member) of the; /// object bound to \p BaseId. The access is constructed idiomatically: if \p; /// BaseId is bound to `e` and \p Member identifies member `m`, then returns; /// `e->m`, when e is a pointer, `e2->m` when e = `*e2` and `e.m` otherwise.; /// Additionally, `e` is wrapped in parentheses, if needed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang/Tooling/Transformer/Stencil.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Transformer/Stencil.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Transformer/Stencil.h:116,Security,access,access,116,"/// Constructs a `MemberExpr` that accesses the named member (\p Member) of the; /// object bound to \p BaseId. The access is constructed idiomatically: if \p; /// BaseId is bound to `e` and \p Member identifies member `m`, then returns; /// `e->m`, when e is a pointer, `e2->m` when e = `*e2` and `e.m` otherwise.; /// Additionally, `e` is wrapped in parentheses, if needed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang/Tooling/Transformer/Stencil.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Transformer/Stencil.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Transformer/Stencil.h:512,Availability,error,error,512,"/// Chooses between multiple stencils, based on the presence of bound nodes. \p; /// CaseStencils takes a vector of (ID, \c Stencil) pairs and checks each ID in; /// order to see if it's bound to a node. If so, the associated \c Stencil is; /// run and all other cases are ignored. An optional \p DefaultStencil can be; /// provided to be run if all cases are exhausted beacause none of the provided; /// IDs are bound. If no default case is provided and all cases are exhausted,; /// the stencil will fail with error `llvm::errc::result_out_of_range`.; ///; /// For example, say one matches a statement's type with:; /// anyOf(; /// qualType(isInteger()).bind(""int""),; /// qualType(realFloatingPointType()).bind(""float""),; /// qualType(isAnyCharacter()).bind(""char""),; /// booleanType().bind(""bool"")); ///; /// Then, one can decide in a stencil how to construct a literal.; /// cat(""a = "",; /// selectBound(; /// {{""int"", cat(""0"")},; /// {""float"", cat(""0.0"")},; /// {""char"", cat(""'\\0'"")},; /// {""bool"", cat(""false"")}})); ///; /// In addition, one could supply a default case for all other types:; /// selectBound(; /// {{""int"", cat(""0"")},; /// ...; /// {""bool"", cat(""false"")}},; /// cat(""{}""))",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang/Tooling/Transformer/Stencil.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Transformer/Stencil.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Transformer/Stencil.h:4,Integrability,Wrap,Wraps,4,"/// Wraps a \c MatchConsumer in a \c Stencil, so that it can be used in a \c; /// Stencil. This supports user-defined extensions to the \c Stencil language.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang/Tooling/Transformer/Stencil.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Transformer/Stencil.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Transformer/Transformer.h:78,Modifiability,Rewrite,RewriteRule,78,/// Implementation details of \c Transformer with type erasure around; /// \c RewriteRule<T> as well as the corresponding consumers.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang/Tooling/Transformer/Transformer.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Transformer/Transformer.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Transformer/Transformer.h:88,Availability,error,error,88,"/// Converts a set of \c Edit into a \c AtomicChange per file modified.; /// Returns an error if the edits fail to compose, e.g. overlapping edits.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang/Tooling/Transformer/Transformer.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Transformer/Transformer.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Transformer/Transformer.h:50,Availability,avail,available,50,// FIXME: Use std::type_identity or backport when available.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang/Tooling/Transformer/Transformer.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Transformer/Transformer.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Transformer/Transformer.h:64,Modifiability,Rewrite,RewriteRule,64,"/// Handles the matcher and callback registration for a single `RewriteRule`, as; /// defined by the arguments of the constructor.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang/Tooling/Transformer/Transformer.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Transformer/Transformer.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Transformer/Transformer.h:68,Availability,error,error,68,"/// \param Consumer receives all rewrites for a single match, or an error.; /// Will not necessarily be called for each match; for example, if the rule; /// generates no edits but does not fail. Note that clients are responsible; /// for handling the case that independent \c AtomicChanges conflict with each; /// other.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang/Tooling/Transformer/Transformer.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Transformer/Transformer.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Transformer/Transformer.h:33,Modifiability,rewrite,rewrites,33,"/// \param Consumer receives all rewrites for a single match, or an error.; /// Will not necessarily be called for each match; for example, if the rule; /// generates no edits but does not fail. Note that clients are responsible; /// for handling the case that independent \c AtomicChanges conflict with each; /// other.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang/Tooling/Transformer/Transformer.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Transformer/Transformer.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Transformer/Transformer.h:101,Availability,error,error,101,"/// \param Consumer receives all rewrites and the associated metadata for a; /// single match, or an error. Will always be called for each match, even if; /// the rule generates no edits. Note that clients are responsible for; /// handling the case that independent \c AtomicChanges conflict with each; /// other.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang/Tooling/Transformer/Transformer.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Transformer/Transformer.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Transformer/Transformer.h:33,Modifiability,rewrite,rewrites,33,"/// \param Consumer receives all rewrites and the associated metadata for a; /// single match, or an error. Will always be called for each match, even if; /// the rule generates no edits. Note that clients are responsible for; /// handling the case that independent \c AtomicChanges conflict with each; /// other.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang/Tooling/Transformer/Transformer.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Transformer/Transformer.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Transformer/Transformer.h:71,Modifiability,rewrite,rewrite,71,/// @}; /// Implementation when metadata is generated as a part of the rewrite. This; /// happens when we have a \c RewriteRuleWith<T>.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang/Tooling/Transformer/Transformer.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Transformer/Transformer.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Transformer/Transformer.h:116,Modifiability,Rewrite,RewriteRuleWith,116,/// @}; /// Implementation when metadata is generated as a part of the rewrite. This; /// happens when we have a \c RewriteRuleWith<T>.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang/Tooling/Transformer/Transformer.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Transformer/Transformer.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/BuildSystem.h:183,Availability,error,error,183,"/**; * Map an absolute virtual file path to an absolute real one.; * The virtual path must be canonicalized (not contain "".""/"".."").; * \returns 0 for success, non-zero to indicate an error.; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang-c/BuildSystem.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/BuildSystem.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/BuildSystem.h:243,Availability,error,error,243,"/**; * Set the case sensitivity for the \c CXVirtualFileOverlay object.; * The \c CXVirtualFileOverlay object is case-sensitive by default, this; * option can be used to override the default.; * \returns 0 for success, non-zero to indicate an error.; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang-c/BuildSystem.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/BuildSystem.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/BuildSystem.h:347,Availability,error,error,347,"/**; * Write out the \c CXVirtualFileOverlay object to a char buffer.; *; * \param options is reserved, always pass 0.; * \param out_buffer_ptr pointer to receive the buffer pointer, which should be; * disposed using \c clang_free().; * \param out_buffer_size pointer to receive the buffer size.; * \returns 0 for success, non-zero to indicate an error.; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang-c/BuildSystem.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/BuildSystem.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/BuildSystem.h:19,Energy Efficiency,allocate,allocated,19,"/**; * free memory allocated by libclang, such as the buffer returned by; * \c CXVirtualFileOverlay() or \c clang_ModuleMapDescriptor_writeToBuffer().; *; * \param buffer memory pointer to free.; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang-c/BuildSystem.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/BuildSystem.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/BuildSystem.h:126,Availability,error,error,126,"/**; * Sets the framework module name that the module.modulemap describes.; * \returns 0 for success, non-zero to indicate an error.; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang-c/BuildSystem.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/BuildSystem.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/BuildSystem.h:125,Availability,error,error,125,"/**; * Sets the umbrella header name that the module.modulemap describes.; * \returns 0 for success, non-zero to indicate an error.; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang-c/BuildSystem.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/BuildSystem.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/BuildSystem.h:348,Availability,error,error,348,"/**; * Write out the \c CXModuleMapDescriptor object to a char buffer.; *; * \param options is reserved, always pass 0.; * \param out_buffer_ptr pointer to receive the buffer pointer, which should be; * disposed using \c clang_free().; * \param out_buffer_size pointer to receive the buffer size.; * \returns 0 for success, non-zero to indicate an error.; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang-c/BuildSystem.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/BuildSystem.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/CXCompilationDatabase.h:437,Integrability,interface,interface,437,"/*===-- clang-c/CXCompilationDatabase.h - Compilation database ---*- C -*-===*\; |* *|; |* Part of the LLVM Project, under the Apache License v2.0 with LLVM *|; |* Exceptions. *|; |* See https://llvm.org/LICENSE.txt for license information. *|; |* SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception *|; |* *|; |*===----------------------------------------------------------------------===*|; |* *|; |* This header provides a public interface to use CompilationDatabase without *|; |* the full Clang C++ API. *|; |* *|; \*===----------------------------------------------------------------------===*/",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang-c/CXCompilationDatabase.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/CXCompilationDatabase.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/CXCompilationDatabase.h:311,Integrability,wrap,wrapped,311,"/**; * Contains the results of a search in the compilation database; *; * When searching for the compile command for a file, the compilation db can; * return several commands, as the file may have been compiled with; * different options in different places of the project. This choice of compile; * commands is wrapped in this opaque data structure. It must be freed by; * \c clang_CompileCommands_dispose.; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang-c/CXCompilationDatabase.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/CXCompilationDatabase.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/CXCompilationDatabase.h:7,Availability,Error,Error,7,/**; * Error codes for Compilation Database; */,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang-c/CXCompilationDatabase.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/CXCompilationDatabase.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/CXCompilationDatabase.h:9,Availability,error,error,9,/*; * No error occurred; */,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang-c/CXCompilationDatabase.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/CXCompilationDatabase.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/CXCompilationDatabase.h:26,Performance,load,loaded,26,/*; * Database can not be loaded; */,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang-c/CXCompilationDatabase.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/CXCompilationDatabase.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/CXDiagnostic.h:433,Integrability,interface,interface,433,"/*===-- clang-c/CXDiagnostic.h - C Index Diagnostics --------------*- C -*-===*\; |* *|; |* Part of the LLVM Project, under the Apache License v2.0 with LLVM *|; |* Exceptions. *|; |* See https://llvm.org/LICENSE.txt for license information. *|; |* SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception *|; |* *|; |*===----------------------------------------------------------------------===*|; |* *|; |* This header provides the interface to C Index diagnostics. *|; |* *|; \*===----------------------------------------------------------------------===*/",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang-c/CXDiagnostic.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/CXDiagnostic.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/CXDiagnostic.h:88,Availability,recover,recovery,88,/**; * This diagnostic indicates that the code is ill-formed such; * that future parser recovery is unlikely to produce useful; * results.; */,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang-c/CXDiagnostic.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/CXDiagnostic.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/CXDiagnostic.h:88,Safety,recover,recovery,88,/**; * This diagnostic indicates that the code is ill-formed such; * that future parser recovery is unlikely to produce useful; * results.; */,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang-c/CXDiagnostic.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/CXDiagnostic.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/CXDiagnostic.h:29,Availability,error,error,29,/**; * Describes the kind of error that occurred (if any) in a call to; * \c clang_loadDiagnostics.; */,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang-c/CXDiagnostic.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/CXDiagnostic.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/CXDiagnostic.h:25,Availability,error,error,25,/**; * Indicates that no error occurred.; */,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang-c/CXDiagnostic.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/CXDiagnostic.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/CXDiagnostic.h:33,Availability,error,error,33,/**; * Indicates that an unknown error occurred while attempting to; * deserialize diagnostics.; */,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang-c/CXDiagnostic.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/CXDiagnostic.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/CXDiagnostic.h:147,Availability,error,error,147,"/**; * Deserialize a set of diagnostics from a Clang diagnostics bitcode; * file.; *; * \param file The name of the file to deserialize.; * \param error A pointer to a enum value recording if there was a problem; * deserializing the diagnostics.; * \param errorString A pointer to a CXString for recording the error string; * if the file was not successfully loaded.; *; * \returns A loaded CXDiagnosticSet if successful, and NULL otherwise. These; * diagnostics should be released using clang_disposeDiagnosticSet().; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang-c/CXDiagnostic.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/CXDiagnostic.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/CXDiagnostic.h:256,Availability,error,errorString,256,"/**; * Deserialize a set of diagnostics from a Clang diagnostics bitcode; * file.; *; * \param file The name of the file to deserialize.; * \param error A pointer to a enum value recording if there was a problem; * deserializing the diagnostics.; * \param errorString A pointer to a CXString for recording the error string; * if the file was not successfully loaded.; *; * \returns A loaded CXDiagnosticSet if successful, and NULL otherwise. These; * diagnostics should be released using clang_disposeDiagnosticSet().; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang-c/CXDiagnostic.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/CXDiagnostic.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/CXDiagnostic.h:310,Availability,error,error,310,"/**; * Deserialize a set of diagnostics from a Clang diagnostics bitcode; * file.; *; * \param file The name of the file to deserialize.; * \param error A pointer to a enum value recording if there was a problem; * deserializing the diagnostics.; * \param errorString A pointer to a CXString for recording the error string; * if the file was not successfully loaded.; *; * \returns A loaded CXDiagnosticSet if successful, and NULL otherwise. These; * diagnostics should be released using clang_disposeDiagnosticSet().; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang-c/CXDiagnostic.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/CXDiagnostic.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/CXDiagnostic.h:473,Deployability,release,released,473,"/**; * Deserialize a set of diagnostics from a Clang diagnostics bitcode; * file.; *; * \param file The name of the file to deserialize.; * \param error A pointer to a enum value recording if there was a problem; * deserializing the diagnostics.; * \param errorString A pointer to a CXString for recording the error string; * if the file was not successfully loaded.; *; * \returns A loaded CXDiagnosticSet if successful, and NULL otherwise. These; * diagnostics should be released using clang_disposeDiagnosticSet().; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang-c/CXDiagnostic.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/CXDiagnostic.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/CXDiagnostic.h:359,Performance,load,loaded,359,"/**; * Deserialize a set of diagnostics from a Clang diagnostics bitcode; * file.; *; * \param file The name of the file to deserialize.; * \param error A pointer to a enum value recording if there was a problem; * deserializing the diagnostics.; * \param errorString A pointer to a CXString for recording the error string; * if the file was not successfully loaded.; *; * \returns A loaded CXDiagnosticSet if successful, and NULL otherwise. These; * diagnostics should be released using clang_disposeDiagnosticSet().; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang-c/CXDiagnostic.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/CXDiagnostic.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/CXDiagnostic.h:384,Performance,load,loaded,384,"/**; * Deserialize a set of diagnostics from a Clang diagnostics bitcode; * file.; *; * \param file The name of the file to deserialize.; * \param error A pointer to a enum value recording if there was a problem; * deserializing the diagnostics.; * \param errorString A pointer to a CXString for recording the error string; * if the file was not successfully loaded.; *; * \returns A loaded CXDiagnosticSet if successful, and NULL otherwise. These; * diagnostics should be released using clang_disposeDiagnosticSet().; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang-c/CXDiagnostic.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/CXDiagnostic.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/CXDiagnostic.h:7,Deployability,Release,Release,7,/**; * Release a CXDiagnosticSet and all of its contained diagnostics.; */,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang-c/CXDiagnostic.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/CXDiagnostic.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/CXDiagnostic.h:104,Deployability,release,released,104,/**; * Retrieve the child diagnostics of a CXDiagnostic.; *; * This CXDiagnosticSet does not need to be released by; * clang_disposeDiagnosticSet.; */,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang-c/CXDiagnostic.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/CXDiagnostic.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/CXDiagnostic.h:235,Testability,test,test,235,"/**; * Display the source-location information where the; * diagnostic was located.; *; * When set, diagnostics will be prefixed by the file, line, and; * (optionally) column to which the diagnostic refers. For example,; *; * \code; * test.c:28: warning: extra tokens at end of #endif directive; * \endcode; *; * This option corresponds to the clang flag \c -fshow-source-location.; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang-c/CXDiagnostic.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/CXDiagnostic.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/CXDiagnostic.h:88,Integrability,rout,routine,88,"/**; * Format the given diagnostic in a manner that is suitable for display.; *; * This routine will format the given diagnostic to a string, rendering; * the diagnostic according to the various options given. The; * \c clang_defaultDiagnosticDisplayOptions() function returns the set of; * options that most closely mimics the behavior of the clang compiler.; *; * \param Diagnostic The diagnostic to print.; *; * \param Options A set of options that control the diagnostic display,; * created by combining \c CXDiagnosticDisplayOptions values.; *; * \returns A new string containing for formatted diagnostic.; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang-c/CXDiagnostic.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/CXDiagnostic.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/CXDiagnostic.h:201,Integrability,rout,routine,201,"/**; * Retrieve the category number for this diagnostic.; *; * Diagnostics can be categorized into groups along with other, related; * diagnostics (e.g., diagnostics under the same warning flag). This routine; * retrieves the category number for the given diagnostic.; *; * \returns The number of the category that contains this diagnostic, or zero; * if this diagnostic is uncategorized.; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang-c/CXDiagnostic.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/CXDiagnostic.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/CXErrorCode.h:40,Availability,Error,Error,40,"/*===-- clang-c/CXErrorCode.h - C Index Error Codes --------------*- C -*-===*\; |* *|; |* Part of the LLVM Project, under the Apache License v2.0 with LLVM *|; |* Exceptions. *|; |* See https://llvm.org/LICENSE.txt for license information. *|; |* SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception *|; |* *|; |*===----------------------------------------------------------------------===*|; |* *|; |* This header provides the CXErrorCode enumerators. *|; |* *|; \*===----------------------------------------------------------------------===*/",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang-c/CXErrorCode.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/CXErrorCode.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/CXErrorCode.h:7,Availability,Error,Error,7,"/**; * Error codes returned by libclang routines.; *; * Zero (\c CXError_Success) is the only error code indicating success. Other; * error codes, including not yet assigned non-zero values, indicate errors.; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang-c/CXErrorCode.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/CXErrorCode.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/CXErrorCode.h:94,Availability,error,error,94,"/**; * Error codes returned by libclang routines.; *; * Zero (\c CXError_Success) is the only error code indicating success. Other; * error codes, including not yet assigned non-zero values, indicate errors.; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang-c/CXErrorCode.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/CXErrorCode.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/CXErrorCode.h:134,Availability,error,error,134,"/**; * Error codes returned by libclang routines.; *; * Zero (\c CXError_Success) is the only error code indicating success. Other; * error codes, including not yet assigned non-zero values, indicate errors.; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang-c/CXErrorCode.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/CXErrorCode.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/CXErrorCode.h:200,Availability,error,errors,200,"/**; * Error codes returned by libclang routines.; *; * Zero (\c CXError_Success) is the only error code indicating success. Other; * error codes, including not yet assigned non-zero values, indicate errors.; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang-c/CXErrorCode.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/CXErrorCode.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/CXErrorCode.h:40,Integrability,rout,routines,40,"/**; * Error codes returned by libclang routines.; *; * Zero (\c CXError_Success) is the only error code indicating success. Other; * error codes, including not yet assigned non-zero values, indicate errors.; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang-c/CXErrorCode.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/CXErrorCode.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/CXErrorCode.h:10,Availability,error,error,10,/**; * No error.; */,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang-c/CXErrorCode.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/CXErrorCode.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/CXErrorCode.h:17,Availability,error,error,17,"/**; * A generic error code, no further details are available.; *; * Errors of this kind can get their own specific error codes in future; * libclang versions.; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang-c/CXErrorCode.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/CXErrorCode.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/CXErrorCode.h:52,Availability,avail,available,52,"/**; * A generic error code, no further details are available.; *; * Errors of this kind can get their own specific error codes in future; * libclang versions.; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang-c/CXErrorCode.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/CXErrorCode.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/CXErrorCode.h:69,Availability,Error,Errors,69,"/**; * A generic error code, no further details are available.; *; * Errors of this kind can get their own specific error codes in future; * libclang versions.; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang-c/CXErrorCode.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/CXErrorCode.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/CXErrorCode.h:116,Availability,error,error,116,"/**; * A generic error code, no further details are available.; *; * Errors of this kind can get their own specific error codes in future; * libclang versions.; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang-c/CXErrorCode.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/CXErrorCode.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/CXErrorCode.h:30,Performance,perform,performing,30,/**; * libclang crashed while performing the requested operation.; */,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang-c/CXErrorCode.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/CXErrorCode.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/CXErrorCode.h:72,Integrability,contract,contract,72,/**; * The function detected that the arguments violate the function; * contract.; */,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang-c/CXErrorCode.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/CXErrorCode.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/CXErrorCode.h:20,Safety,detect,detected,20,/**; * The function detected that the arguments violate the function; * contract.; */,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang-c/CXErrorCode.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/CXErrorCode.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/CXErrorCode.h:30,Availability,error,error,30,/**; * An AST deserialization error has occurred.; */,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang-c/CXErrorCode.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/CXErrorCode.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/CXFile.h:433,Integrability,interface,interface,433,"/*===-- clang-c/CXFile.h - C Index File ---------------------------*- C -*-===*\; |* *|; |* Part of the LLVM Project, under the Apache License v2.0 with LLVM *|; |* Exceptions. *|; |* See https://llvm.org/LICENSE.txt for license information. *|; |* SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception *|; |* *|; |*===----------------------------------------------------------------------===*|; |* *|; |* This header provides the interface to C Index files. *|; |* *|; \*===----------------------------------------------------------------------===*/",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang-c/CXFile.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/CXFile.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/CXFile.h:48,Integrability,rout,routines,48,/**; * \defgroup CINDEX_FILES File manipulation routines; *; * @{; */; /**; * A particular source file that is part of a translation unit.; */,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang-c/CXFile.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/CXFile.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/CXFile.h:178,Availability,failure,failure,178,"/**; * Retrieve the unique ID for the given \c file.; *; * \param file the file to get the ID for.; * \param outID stores the returned CXFileUniqueID.; * \returns If there was a failure getting the unique ID, returns non-zero,; * otherwise returns 0.; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang-c/CXFile.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/CXFile.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/CXSourceLocation.h:433,Integrability,interface,interface,433,"/*===-- clang-c/CXSourceLocation.h - C Index Source Location ------*- C -*-===*\; |* *|; |* Part of the LLVM Project, under the Apache License v2.0 with LLVM *|; |* Exceptions. *|; |* See https://llvm.org/LICENSE.txt for license information. *|; |* SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception *|; |* *|; |*===----------------------------------------------------------------------===*|; |* *|; |* This header provides the interface to C Index source locations. *|; |* *|; \*===----------------------------------------------------------------------===*/",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang-c/CXSourceLocation.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/CXSourceLocation.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/CXSourceLocation.h:121,Integrability,interface,interface,121,"/**; * Legacy API to retrieve the file, line, column, and offset represented; * by the given source location.; *; * This interface has been replaced by the newer interface; * #clang_getExpansionLocation(). See that interface's documentation for; * details.; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang-c/CXSourceLocation.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/CXSourceLocation.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/CXSourceLocation.h:162,Integrability,interface,interface,162,"/**; * Legacy API to retrieve the file, line, column, and offset represented; * by the given source location.; *; * This interface has been replaced by the newer interface; * #clang_getExpansionLocation(). See that interface's documentation for; * details.; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang-c/CXSourceLocation.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/CXSourceLocation.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/CXSourceLocation.h:215,Integrability,interface,interface,215,"/**; * Legacy API to retrieve the file, line, column, and offset represented; * by the given source location.; *; * This interface has been replaced by the newer interface; * #clang_getExpansionLocation(). See that interface's documentation for; * details.; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang-c/CXSourceLocation.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/CXSourceLocation.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/CXString.h:431,Integrability,interface,interface,431,"/*===-- clang-c/CXString.h - C Index strings --------------------*- C -*-===*\; |* *|; |* Part of the LLVM Project, under the Apache License v2.0 with LLVM *|; |* Exceptions. *|; |* See https://llvm.org/LICENSE.txt for license information. *|; |* SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception *|; |* *|; |*===----------------------------------------------------------------------===*|; |* *|; |* This header provides the interface to C Index strings. *|; |* *|; \*===----------------------------------------------------------------------===*/",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang-c/CXString.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/CXString.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/CXString.h:51,Integrability,rout,routines,51,"/**; * \defgroup CINDEX_STRING String manipulation routines; * \ingroup CINDEX; *; * @{; */; /**; * A character string.; *; * The \c CXString type is used to return strings from the interface when; * the ownership of that string might differ from one call to the next.; * Use \c clang_getCString() to retrieve the string data and, once finished; * with the string data, call \c clang_disposeString() to free the string.; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang-c/CXString.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/CXString.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/CXString.h:182,Integrability,interface,interface,182,"/**; * \defgroup CINDEX_STRING String manipulation routines; * \ingroup CINDEX; *; * @{; */; /**; * A character string.; *; * The \c CXString type is used to return strings from the interface when; * the ownership of that string might differ from one call to the next.; * Use \c clang_getCString() to retrieve the string data and, once finished; * with the string data, call \c clang_disposeString() to free the string.; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang-c/CXString.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/CXString.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/Documentation.h:445,Integrability,interface,interface,445,"/*==-- clang-c/Documentation.h - Utilities for comment processing -*- C -*-===*\; |* *|; |* Part of the LLVM Project, under the Apache License v2.0 with LLVM *|; |* Exceptions. *|; |* See https://llvm.org/LICENSE.txt for license information. *|; |* SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception *|; |* *|; |*===----------------------------------------------------------------------===*|; |* *|; |* This header provides a supplementary interface for inspecting *|; |* documentation comments. *|; |* *|; \*===----------------------------------------------------------------------===*/",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang-c/Documentation.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/Documentation.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/Documentation.h:226,Energy Efficiency,schedul,schedule,226,/**; * \defgroup CINDEX_COMMENT Comment introspection; *; * The routines in this group provide access to information in documentation; * comments. These facilities are distinct from the core and may be subject to; * their own schedule of stability and deprecation.; *; * @{; */; /**; * A parsed comment.; */,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang-c/Documentation.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/Documentation.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/Documentation.h:64,Integrability,rout,routines,64,/**; * \defgroup CINDEX_COMMENT Comment introspection; *; * The routines in this group provide access to information in documentation; * comments. These facilities are distinct from the core and may be subject to; * their own schedule of stability and deprecation.; *; * @{; */; /**; * A parsed comment.; */,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang-c/Documentation.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/Documentation.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/Documentation.h:95,Security,access,access,95,/**; * \defgroup CINDEX_COMMENT Comment introspection; *; * The routines in this group provide access to information in documentation; * comments. These facilities are distinct from the core and may be subject to; * their own schedule of stability and deprecation.; *; * @{; */; /**; * A parsed comment.; */,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang-c/Documentation.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/Documentation.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/Documentation.h:114,Availability,error,error,114,/**; * Null comment. No AST node is constructed at the requested location; * because there is no text or a syntax error.; */,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang-c/Documentation.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/Documentation.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/Documentation.h:93,Integrability,depend,depends,93,"/**; * A command that has zero or more word-like arguments (number of; * word-like arguments depends on command name) and a paragraph as an; * argument. Block command is block content.; *; * Paragraph argument is also a child of the block command.; *; * For example: \has 0 word-like arguments and a paragraph argument.; *; * AST nodes of special kinds that parser knows about (e. g., \\param; * command) have their own node kinds.; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang-c/Documentation.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/Documentation.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/Documentation.h:246,Testability,test,test,246,"/**; * \param Comment a \c CXComment_TParamCommand AST node.; *; * \returns zero-based nesting depth of this parameter in the template parameter list.; *; * For example,; * \verbatim; * template<typename C, template<typename T> class TT>; * void test(TT<int> aaa);; * \endverbatim; * for C and TT nesting depth is 0,; * for T nesting depth is 1.; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang-c/Documentation.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/Documentation.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/Documentation.h:258,Testability,test,test,258,"/**; * \param Comment a \c CXComment_TParamCommand AST node.; *; * \returns zero-based parameter index in the template parameter list at a; * given nesting depth.; *; * For example,; * \verbatim; * template<typename C, template<typename T> class TT>; * void test(TT<int> aaa);; * \endverbatim; * for C and TT nesting depth is 0, so we can ask for index at depth 0:; * at depth 0 C's index is 0, TT's index is 1.; *; * For T nesting depth is 1, so we can ask for index at depth 0 and 1:; * at depth 0 T's index is 1 (same as TT's),; * at depth 1 T's index is 0.; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang-c/Documentation.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/Documentation.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/Documentation.h:283,Availability,Error,Error,283,/**; * Traverses the translation unit to create a \c CXAPISet.; *; * \param tu is the \c CXTranslationUnit to build the \c CXAPISet for.; *; * \param out_api is a pointer to the output of this function. It is needs to be; * disposed of by calling clang_disposeAPISet.; *; * \returns Error code indicating success or failure of the APISet creation.; */,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang-c/Documentation.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/Documentation.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/Documentation.h:316,Availability,failure,failure,316,/**; * Traverses the translation unit to create a \c CXAPISet.; *; * \param tu is the \c CXTranslationUnit to build the \c CXAPISet for.; *; * \param out_api is a pointer to the output of this function. It is needs to be; * disposed of by calling clang_disposeAPISet.; *; * \returns Error code indicating success or failure of the APISet creation.; */,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang-c/Documentation.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/Documentation.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/ExternC.h:27,Integrability,Wrap,Wrapper,27,"/*===- clang-c/ExternC.h - Wrapper for 'extern ""C""' ---------------*- C -*-===*\; |* *|; |* Part of the LLVM Project, under the Apache License v2.0 with LLVM *|; |* Exceptions. *|; |* See https://llvm.org/LICENSE.txt for license information. *|; |* SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception *|; |* *|; |*===----------------------------------------------------------------------===*|; |* *|; |* This file defines an 'extern ""C""' wrapper. *|; |* *|; \*===----------------------------------------------------------------------===*/",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang-c/ExternC.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/ExternC.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/ExternC.h:442,Integrability,wrap,wrapper,442,"/*===- clang-c/ExternC.h - Wrapper for 'extern ""C""' ---------------*- C -*-===*\; |* *|; |* Part of the LLVM Project, under the Apache License v2.0 with LLVM *|; |* Exceptions. *|; |* See https://llvm.org/LICENSE.txt for license information. *|; |* SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception *|; |* *|; |*===----------------------------------------------------------------------===*|; |* *|; |* This file defines an 'extern ""C""' wrapper. *|; |* *|; \*===----------------------------------------------------------------------===*/",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang-c/ExternC.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/ExternC.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/FatalErrorHandler.h:44,Availability,Error,Error,44,"/*===-- clang-c/FatalErrorHandler.h - Fatal Error Handling --------*- C -*-===*\; |* *|; |* Part of the LLVM Project, under the Apache License v2.0 with LLVM *|; |* Exceptions. *|; |* See https://llvm.org/LICENSE.txt for license information. *|; |* SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception *|; |* *|; \*===----------------------------------------------------------------------===*/",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang-c/FatalErrorHandler.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/FatalErrorHandler.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/FatalErrorHandler.h:16,Availability,error,error,16,/**; * Installs error handler that prints error message to stderr and calls abort().; * Replaces currently installed error handler (if any).; */,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang-c/FatalErrorHandler.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/FatalErrorHandler.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/FatalErrorHandler.h:42,Availability,error,error,42,/**; * Installs error handler that prints error message to stderr and calls abort().; * Replaces currently installed error handler (if any).; */,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang-c/FatalErrorHandler.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/FatalErrorHandler.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/FatalErrorHandler.h:117,Availability,error,error,117,/**; * Installs error handler that prints error message to stderr and calls abort().; * Replaces currently installed error handler (if any).; */,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang-c/FatalErrorHandler.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/FatalErrorHandler.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/FatalErrorHandler.h:7,Deployability,Install,Installs,7,/**; * Installs error handler that prints error message to stderr and calls abort().; * Replaces currently installed error handler (if any).; */,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang-c/FatalErrorHandler.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/FatalErrorHandler.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/FatalErrorHandler.h:107,Deployability,install,installed,107,/**; * Installs error handler that prints error message to stderr and calls abort().; * Replaces currently installed error handler (if any).; */,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang-c/FatalErrorHandler.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/FatalErrorHandler.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/FatalErrorHandler.h:48,Integrability,message,message,48,/**; * Installs error handler that prints error message to stderr and calls abort().; * Replaces currently installed error handler (if any).; */,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang-c/FatalErrorHandler.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/FatalErrorHandler.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/FatalErrorHandler.h:76,Safety,abort,abort,76,/**; * Installs error handler that prints error message to stderr and calls abort().; * Replaces currently installed error handler (if any).; */,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang-c/FatalErrorHandler.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/FatalErrorHandler.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/FatalErrorHandler.h:35,Availability,error,error,35,"/**; * Removes currently installed error handler (if any).; * If no error handler is intalled, the default strategy is to print error; * message to stderr and call exit(1).; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang-c/FatalErrorHandler.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/FatalErrorHandler.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/FatalErrorHandler.h:68,Availability,error,error,68,"/**; * Removes currently installed error handler (if any).; * If no error handler is intalled, the default strategy is to print error; * message to stderr and call exit(1).; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang-c/FatalErrorHandler.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/FatalErrorHandler.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/FatalErrorHandler.h:128,Availability,error,error,128,"/**; * Removes currently installed error handler (if any).; * If no error handler is intalled, the default strategy is to print error; * message to stderr and call exit(1).; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang-c/FatalErrorHandler.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/FatalErrorHandler.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/FatalErrorHandler.h:25,Deployability,install,installed,25,"/**; * Removes currently installed error handler (if any).; * If no error handler is intalled, the default strategy is to print error; * message to stderr and call exit(1).; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang-c/FatalErrorHandler.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/FatalErrorHandler.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/FatalErrorHandler.h:137,Integrability,message,message,137,"/**; * Removes currently installed error handler (if any).; * If no error handler is intalled, the default strategy is to print error; * message to stderr and call exit(1).; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang-c/FatalErrorHandler.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/FatalErrorHandler.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/Index.h:44,Integrability,Interface,Interface,44,"/*===-- clang-c/Index.h - Indexing Public C Interface -------------*- C -*-===*\; |* *|; |* Part of the LLVM Project, under the Apache License v2.0 with LLVM *|; |* Exceptions. *|; |* See https://llvm.org/LICENSE.txt for license information. *|; |* SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception *|; |* *|; |*===----------------------------------------------------------------------===*|; |* *|; |* This header provides a public interface to a Clang library for extracting *|; |* high-level symbol information from source files without exposing the full *|; |* Clang C++ API. *|; |* *|; \*===----------------------------------------------------------------------===*/",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang-c/Index.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/Index.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/Index.h:438,Integrability,interface,interface,438,"/*===-- clang-c/Index.h - Indexing Public C Interface -------------*- C -*-===*\; |* *|; |* Part of the LLVM Project, under the Apache License v2.0 with LLVM *|; |* Exceptions. *|; |* See https://llvm.org/LICENSE.txt for license information. *|; |* SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception *|; |* *|; |*===----------------------------------------------------------------------===*|; |* *|; |* This header provides a public interface to a Clang library for extracting *|; |* high-level symbol information from source files without exposing the full *|; |* Clang C++ API. *|; |* *|; \*===----------------------------------------------------------------------===*/",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang-c/Index.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/Index.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/Index.h:598,Deployability,release,release,598,"/** \defgroup CINDEX libclang: C Interface to Clang; *; * The C Interface to Clang provides a relatively small API that exposes; * facilities for parsing source code into an abstract syntax tree (AST),; * loading already-parsed ASTs, traversing the AST, associating; * physical source locations with elements within the AST, and other; * facilities that support Clang-based development tools.; *; * This C interface to Clang will never provide all of the information; * representation stored in Clang's C++ AST, nor should it: the intent is to; * maintain an API that is relatively stable from one release to the next,; * providing only the basic functionality needed to support development tools.; *; * To avoid namespace pollution, data types are prefixed with ""CX"" and; * functions are prefixed with ""clang_"".; *; * @{; */; /**; * An ""index"" that consists of a set of translation units that would; * typically be linked together into an executable or library.; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang-c/Index.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/Index.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/Index.h:33,Integrability,Interface,Interface,33,"/** \defgroup CINDEX libclang: C Interface to Clang; *; * The C Interface to Clang provides a relatively small API that exposes; * facilities for parsing source code into an abstract syntax tree (AST),; * loading already-parsed ASTs, traversing the AST, associating; * physical source locations with elements within the AST, and other; * facilities that support Clang-based development tools.; *; * This C interface to Clang will never provide all of the information; * representation stored in Clang's C++ AST, nor should it: the intent is to; * maintain an API that is relatively stable from one release to the next,; * providing only the basic functionality needed to support development tools.; *; * To avoid namespace pollution, data types are prefixed with ""CX"" and; * functions are prefixed with ""clang_"".; *; * @{; */; /**; * An ""index"" that consists of a set of translation units that would; * typically be linked together into an executable or library.; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang-c/Index.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/Index.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/Index.h:64,Integrability,Interface,Interface,64,"/** \defgroup CINDEX libclang: C Interface to Clang; *; * The C Interface to Clang provides a relatively small API that exposes; * facilities for parsing source code into an abstract syntax tree (AST),; * loading already-parsed ASTs, traversing the AST, associating; * physical source locations with elements within the AST, and other; * facilities that support Clang-based development tools.; *; * This C interface to Clang will never provide all of the information; * representation stored in Clang's C++ AST, nor should it: the intent is to; * maintain an API that is relatively stable from one release to the next,; * providing only the basic functionality needed to support development tools.; *; * To avoid namespace pollution, data types are prefixed with ""CX"" and; * functions are prefixed with ""clang_"".; *; * @{; */; /**; * An ""index"" that consists of a set of translation units that would; * typically be linked together into an executable or library.; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang-c/Index.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/Index.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/Index.h:406,Integrability,interface,interface,406,"/** \defgroup CINDEX libclang: C Interface to Clang; *; * The C Interface to Clang provides a relatively small API that exposes; * facilities for parsing source code into an abstract syntax tree (AST),; * loading already-parsed ASTs, traversing the AST, associating; * physical source locations with elements within the AST, and other; * facilities that support Clang-based development tools.; *; * This C interface to Clang will never provide all of the information; * representation stored in Clang's C++ AST, nor should it: the intent is to; * maintain an API that is relatively stable from one release to the next,; * providing only the basic functionality needed to support development tools.; *; * To avoid namespace pollution, data types are prefixed with ""CX"" and; * functions are prefixed with ""clang_"".; *; * @{; */; /**; * An ""index"" that consists of a set of translation units that would; * typically be linked together into an executable or library.; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang-c/Index.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/Index.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/Index.h:205,Performance,load,loading,205,"/** \defgroup CINDEX libclang: C Interface to Clang; *; * The C Interface to Clang provides a relatively small API that exposes; * facilities for parsing source code into an abstract syntax tree (AST),; * loading already-parsed ASTs, traversing the AST, associating; * physical source locations with elements within the AST, and other; * facilities that support Clang-based development tools.; *; * This C interface to Clang will never provide all of the information; * representation stored in Clang's C++ AST, nor should it: the intent is to; * maintain an API that is relatively stable from one release to the next,; * providing only the basic functionality needed to support development tools.; *; * To avoid namespace pollution, data types are prefixed with ""CX"" and; * functions are prefixed with ""clang_"".; *; * @{; */; /**; * An ""index"" that consists of a set of translation units that would; * typically be linked together into an executable or library.; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang-c/Index.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/Index.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/Index.h:707,Safety,avoid,avoid,707,"/** \defgroup CINDEX libclang: C Interface to Clang; *; * The C Interface to Clang provides a relatively small API that exposes; * facilities for parsing source code into an abstract syntax tree (AST),; * loading already-parsed ASTs, traversing the AST, associating; * physical source locations with elements within the AST, and other; * facilities that support Clang-based development tools.; *; * This C interface to Clang will never provide all of the information; * representation stored in Clang's C++ AST, nor should it: the intent is to; * maintain an API that is relatively stable from one release to the next,; * providing only the basic functionality needed to support development tools.; *; * To avoid namespace pollution, data types are prefixed with ""CX"" and; * functions are prefixed with ""clang_"".; *; * @{; */; /**; * An ""index"" that consists of a set of translation units that would; * typically be linked together into an executable or library.; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang-c/Index.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/Index.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/Index.h:120,Security,expose,exposes,120,"/** \defgroup CINDEX libclang: C Interface to Clang; *; * The C Interface to Clang provides a relatively small API that exposes; * facilities for parsing source code into an abstract syntax tree (AST),; * loading already-parsed ASTs, traversing the AST, associating; * physical source locations with elements within the AST, and other; * facilities that support Clang-based development tools.; *; * This C interface to Clang will never provide all of the information; * representation stored in Clang's C++ AST, nor should it: the intent is to; * maintain an API that is relatively stable from one release to the next,; * providing only the basic functionality needed to support development tools.; *; * To avoid namespace pollution, data types are prefixed with ""CX"" and; * functions are prefixed with ""clang_"".; *; * @{; */; /**; * An ""index"" that consists of a set of translation units that would; * typically be linked together into an executable or library.; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang-c/Index.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/Index.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/Index.h:21,Availability,avail,availability,21,"/**; * Describes the availability of a particular entity, which indicates; * whether the use of this entity will result in a warning or error due to; * it being deprecated or unavailable.; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang-c/Index.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/Index.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/Index.h:136,Availability,error,error,136,"/**; * Describes the availability of a particular entity, which indicates; * whether the use of this entity will result in a warning or error due to; * it being deprecated or unavailable.; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang-c/Index.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/Index.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/Index.h:21,Availability,avail,available,21,/**; * The entity is available.; */,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang-c/Index.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/Index.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/Index.h:21,Availability,avail,available,21,"/**; * The entity is available, but has been deprecated (and its use is; * not recommended).; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang-c/Index.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/Index.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/Index.h:25,Availability,avail,available,25,/**; * The entity is not available; any use of it will be an error.; */,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang-c/Index.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/Index.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/Index.h:61,Availability,error,error,61,/**; * The entity is not available; any use of it will be an error.; */,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang-c/Index.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/Index.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/Index.h:21,Availability,avail,available,21,"/**; * The entity is available, but not accessible; any use of it will be; * an error.; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang-c/Index.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/Index.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/Index.h:80,Availability,error,error,80,"/**; * The entity is available, but not accessible; any use of it will be; * an error.; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang-c/Index.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/Index.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/Index.h:40,Security,access,accessible,40,"/**; * The entity is available, but not accessible; any use of it will be; * an error.; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang-c/Index.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/Index.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/Index.h:1463,Availability,redundant,redundant,1463,"/**; * Provides a shared context for creating translation units.; *; * It provides two options:; *; * - excludeDeclarationsFromPCH: When non-zero, allows enumeration of ""local""; * declarations (when loading any new translation units). A ""local"" declaration; * is one that belongs in the translation unit itself and not in a precompiled; * header that was used by the translation unit. If zero, all declarations; * will be enumerated.; *; * Here is an example:; *; * \code; * // excludeDeclsFromPCH = 1, displayDiagnostics=1; * Idx = clang_createIndex(1, 1);; *; * // IndexTest.pch was produced with the following command:; * // ""clang -x c IndexTest.h -emit-ast -o IndexTest.pch""; * TU = clang_createTranslationUnit(Idx, ""IndexTest.pch"");; *; * // This will load all the symbols from 'IndexTest.pch'; * clang_visitChildren(clang_getTranslationUnitCursor(TU),; * TranslationUnitVisitor, 0);; * clang_disposeTranslationUnit(TU);; *; * // This will load all the symbols from 'IndexTest.c', excluding symbols; * // from 'IndexTest.pch'.; * char *args[] = { ""-Xclang"", ""-include-pch=IndexTest.pch"" };; * TU = clang_createTranslationUnitFromSourceFile(Idx, ""IndexTest.c"", 2, args,; * 0, 0);; * clang_visitChildren(clang_getTranslationUnitCursor(TU),; * TranslationUnitVisitor, 0);; * clang_disposeTranslationUnit(TU);; * \endcode; *; * This process of creating the 'pch', loading it separately, and using it (via; * -include-pch) allows 'excludeDeclsFromPCH' to remove redundant callbacks; * (which gives the indexer the same performance benefit as the compiler).; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang-c/Index.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/Index.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/Index.h:199,Performance,load,loading,199,"/**; * Provides a shared context for creating translation units.; *; * It provides two options:; *; * - excludeDeclarationsFromPCH: When non-zero, allows enumeration of ""local""; * declarations (when loading any new translation units). A ""local"" declaration; * is one that belongs in the translation unit itself and not in a precompiled; * header that was used by the translation unit. If zero, all declarations; * will be enumerated.; *; * Here is an example:; *; * \code; * // excludeDeclsFromPCH = 1, displayDiagnostics=1; * Idx = clang_createIndex(1, 1);; *; * // IndexTest.pch was produced with the following command:; * // ""clang -x c IndexTest.h -emit-ast -o IndexTest.pch""; * TU = clang_createTranslationUnit(Idx, ""IndexTest.pch"");; *; * // This will load all the symbols from 'IndexTest.pch'; * clang_visitChildren(clang_getTranslationUnitCursor(TU),; * TranslationUnitVisitor, 0);; * clang_disposeTranslationUnit(TU);; *; * // This will load all the symbols from 'IndexTest.c', excluding symbols; * // from 'IndexTest.pch'.; * char *args[] = { ""-Xclang"", ""-include-pch=IndexTest.pch"" };; * TU = clang_createTranslationUnitFromSourceFile(Idx, ""IndexTest.c"", 2, args,; * 0, 0);; * clang_visitChildren(clang_getTranslationUnitCursor(TU),; * TranslationUnitVisitor, 0);; * clang_disposeTranslationUnit(TU);; * \endcode; *; * This process of creating the 'pch', loading it separately, and using it (via; * -include-pch) allows 'excludeDeclsFromPCH' to remove redundant callbacks; * (which gives the indexer the same performance benefit as the compiler).; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang-c/Index.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/Index.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/Index.h:758,Performance,load,load,758,"/**; * Provides a shared context for creating translation units.; *; * It provides two options:; *; * - excludeDeclarationsFromPCH: When non-zero, allows enumeration of ""local""; * declarations (when loading any new translation units). A ""local"" declaration; * is one that belongs in the translation unit itself and not in a precompiled; * header that was used by the translation unit. If zero, all declarations; * will be enumerated.; *; * Here is an example:; *; * \code; * // excludeDeclsFromPCH = 1, displayDiagnostics=1; * Idx = clang_createIndex(1, 1);; *; * // IndexTest.pch was produced with the following command:; * // ""clang -x c IndexTest.h -emit-ast -o IndexTest.pch""; * TU = clang_createTranslationUnit(Idx, ""IndexTest.pch"");; *; * // This will load all the symbols from 'IndexTest.pch'; * clang_visitChildren(clang_getTranslationUnitCursor(TU),; * TranslationUnitVisitor, 0);; * clang_disposeTranslationUnit(TU);; *; * // This will load all the symbols from 'IndexTest.c', excluding symbols; * // from 'IndexTest.pch'.; * char *args[] = { ""-Xclang"", ""-include-pch=IndexTest.pch"" };; * TU = clang_createTranslationUnitFromSourceFile(Idx, ""IndexTest.c"", 2, args,; * 0, 0);; * clang_visitChildren(clang_getTranslationUnitCursor(TU),; * TranslationUnitVisitor, 0);; * clang_disposeTranslationUnit(TU);; * \endcode; *; * This process of creating the 'pch', loading it separately, and using it (via; * -include-pch) allows 'excludeDeclsFromPCH' to remove redundant callbacks; * (which gives the indexer the same performance benefit as the compiler).; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang-c/Index.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/Index.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/Index.h:946,Performance,load,load,946,"/**; * Provides a shared context for creating translation units.; *; * It provides two options:; *; * - excludeDeclarationsFromPCH: When non-zero, allows enumeration of ""local""; * declarations (when loading any new translation units). A ""local"" declaration; * is one that belongs in the translation unit itself and not in a precompiled; * header that was used by the translation unit. If zero, all declarations; * will be enumerated.; *; * Here is an example:; *; * \code; * // excludeDeclsFromPCH = 1, displayDiagnostics=1; * Idx = clang_createIndex(1, 1);; *; * // IndexTest.pch was produced with the following command:; * // ""clang -x c IndexTest.h -emit-ast -o IndexTest.pch""; * TU = clang_createTranslationUnit(Idx, ""IndexTest.pch"");; *; * // This will load all the symbols from 'IndexTest.pch'; * clang_visitChildren(clang_getTranslationUnitCursor(TU),; * TranslationUnitVisitor, 0);; * clang_disposeTranslationUnit(TU);; *; * // This will load all the symbols from 'IndexTest.c', excluding symbols; * // from 'IndexTest.pch'.; * char *args[] = { ""-Xclang"", ""-include-pch=IndexTest.pch"" };; * TU = clang_createTranslationUnitFromSourceFile(Idx, ""IndexTest.c"", 2, args,; * 0, 0);; * clang_visitChildren(clang_getTranslationUnitCursor(TU),; * TranslationUnitVisitor, 0);; * clang_disposeTranslationUnit(TU);; * \endcode; *; * This process of creating the 'pch', loading it separately, and using it (via; * -include-pch) allows 'excludeDeclsFromPCH' to remove redundant callbacks; * (which gives the indexer the same performance benefit as the compiler).; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang-c/Index.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/Index.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/Index.h:1366,Performance,load,loading,1366,"/**; * Provides a shared context for creating translation units.; *; * It provides two options:; *; * - excludeDeclarationsFromPCH: When non-zero, allows enumeration of ""local""; * declarations (when loading any new translation units). A ""local"" declaration; * is one that belongs in the translation unit itself and not in a precompiled; * header that was used by the translation unit. If zero, all declarations; * will be enumerated.; *; * Here is an example:; *; * \code; * // excludeDeclsFromPCH = 1, displayDiagnostics=1; * Idx = clang_createIndex(1, 1);; *; * // IndexTest.pch was produced with the following command:; * // ""clang -x c IndexTest.h -emit-ast -o IndexTest.pch""; * TU = clang_createTranslationUnit(Idx, ""IndexTest.pch"");; *; * // This will load all the symbols from 'IndexTest.pch'; * clang_visitChildren(clang_getTranslationUnitCursor(TU),; * TranslationUnitVisitor, 0);; * clang_disposeTranslationUnit(TU);; *; * // This will load all the symbols from 'IndexTest.c', excluding symbols; * // from 'IndexTest.pch'.; * char *args[] = { ""-Xclang"", ""-include-pch=IndexTest.pch"" };; * TU = clang_createTranslationUnitFromSourceFile(Idx, ""IndexTest.c"", 2, args,; * 0, 0);; * clang_visitChildren(clang_getTranslationUnitCursor(TU),; * TranslationUnitVisitor, 0);; * clang_disposeTranslationUnit(TU);; * \endcode; *; * This process of creating the 'pch', loading it separately, and using it (via; * -include-pch) allows 'excludeDeclsFromPCH' to remove redundant callbacks; * (which gives the indexer the same performance benefit as the compiler).; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang-c/Index.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/Index.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/Index.h:1520,Performance,perform,performance,1520,"/**; * Provides a shared context for creating translation units.; *; * It provides two options:; *; * - excludeDeclarationsFromPCH: When non-zero, allows enumeration of ""local""; * declarations (when loading any new translation units). A ""local"" declaration; * is one that belongs in the translation unit itself and not in a precompiled; * header that was used by the translation unit. If zero, all declarations; * will be enumerated.; *; * Here is an example:; *; * \code; * // excludeDeclsFromPCH = 1, displayDiagnostics=1; * Idx = clang_createIndex(1, 1);; *; * // IndexTest.pch was produced with the following command:; * // ""clang -x c IndexTest.h -emit-ast -o IndexTest.pch""; * TU = clang_createTranslationUnit(Idx, ""IndexTest.pch"");; *; * // This will load all the symbols from 'IndexTest.pch'; * clang_visitChildren(clang_getTranslationUnitCursor(TU),; * TranslationUnitVisitor, 0);; * clang_disposeTranslationUnit(TU);; *; * // This will load all the symbols from 'IndexTest.c', excluding symbols; * // from 'IndexTest.pch'.; * char *args[] = { ""-Xclang"", ""-include-pch=IndexTest.pch"" };; * TU = clang_createTranslationUnitFromSourceFile(Idx, ""IndexTest.c"", 2, args,; * 0, 0);; * clang_visitChildren(clang_getTranslationUnitCursor(TU),; * TranslationUnitVisitor, 0);; * clang_disposeTranslationUnit(TU);; * \endcode; *; * This process of creating the 'pch', loading it separately, and using it (via; * -include-pch) allows 'excludeDeclsFromPCH' to remove redundant callbacks; * (which gives the indexer the same performance benefit as the compiler).; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang-c/Index.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/Index.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/Index.h:1463,Safety,redund,redundant,1463,"/**; * Provides a shared context for creating translation units.; *; * It provides two options:; *; * - excludeDeclarationsFromPCH: When non-zero, allows enumeration of ""local""; * declarations (when loading any new translation units). A ""local"" declaration; * is one that belongs in the translation unit itself and not in a precompiled; * header that was used by the translation unit. If zero, all declarations; * will be enumerated.; *; * Here is an example:; *; * \code; * // excludeDeclsFromPCH = 1, displayDiagnostics=1; * Idx = clang_createIndex(1, 1);; *; * // IndexTest.pch was produced with the following command:; * // ""clang -x c IndexTest.h -emit-ast -o IndexTest.pch""; * TU = clang_createTranslationUnit(Idx, ""IndexTest.pch"");; *; * // This will load all the symbols from 'IndexTest.pch'; * clang_visitChildren(clang_getTranslationUnitCursor(TU),; * TranslationUnitVisitor, 0);; * clang_disposeTranslationUnit(TU);; *; * // This will load all the symbols from 'IndexTest.c', excluding symbols; * // from 'IndexTest.pch'.; * char *args[] = { ""-Xclang"", ""-include-pch=IndexTest.pch"" };; * TU = clang_createTranslationUnitFromSourceFile(Idx, ""IndexTest.c"", 2, args,; * 0, 0);; * clang_visitChildren(clang_getTranslationUnitCursor(TU),; * TranslationUnitVisitor, 0);; * clang_disposeTranslationUnit(TU);; * \endcode; *; * This process of creating the 'pch', loading it separately, and using it (via; * -include-pch) allows 'excludeDeclsFromPCH' to remove redundant callbacks; * (which gives the indexer the same performance benefit as the compiler).; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang-c/Index.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/Index.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/Index.h:51,Integrability,depend,depend,51,/**; * Use the default value of an option that may depend on the process; * environment.; */,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang-c/Index.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/Index.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/Index.h:182,Energy Efficiency,adapt,adapting,182,"/**; * Index initialization options.; *; * 0 is the default value of each member of this struct except for Size.; * Initialize the struct in one of the following three ways to avoid adapting; * code each time a new member is added to it:; * \code; * CXIndexOptions Opts;; * memset(&Opts, 0, sizeof(Opts));; * Opts.Size = sizeof(CXIndexOptions);; * \endcode; * or explicitly initialize the first data member and zero-initialize the rest:; * \code; * CXIndexOptions Opts = { sizeof(CXIndexOptions) };; * \endcode; * or to prevent the -Wmissing-field-initializers warning for the above version:; * \code; * CXIndexOptions Opts{};; * Opts.Size = sizeof(CXIndexOptions);; * \endcode; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang-c/Index.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/Index.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/Index.h:182,Modifiability,adapt,adapting,182,"/**; * Index initialization options.; *; * 0 is the default value of each member of this struct except for Size.; * Initialize the struct in one of the following three ways to avoid adapting; * code each time a new member is added to it:; * \code; * CXIndexOptions Opts;; * memset(&Opts, 0, sizeof(Opts));; * Opts.Size = sizeof(CXIndexOptions);; * \endcode; * or explicitly initialize the first data member and zero-initialize the rest:; * \code; * CXIndexOptions Opts = { sizeof(CXIndexOptions) };; * \endcode; * or to prevent the -Wmissing-field-initializers warning for the above version:; * \code; * CXIndexOptions Opts{};; * Opts.Size = sizeof(CXIndexOptions);; * \endcode; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang-c/Index.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/Index.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/Index.h:176,Safety,avoid,avoid,176,"/**; * Index initialization options.; *; * 0 is the default value of each member of this struct except for Size.; * Initialize the struct in one of the following three ways to avoid adapting; * code each time a new member is added to it:; * \code; * CXIndexOptions Opts;; * memset(&Opts, 0, sizeof(Opts));; * Opts.Size = sizeof(CXIndexOptions);; * \endcode; * or explicitly initialize the first data member and zero-initialize the rest:; * \code; * CXIndexOptions Opts = { sizeof(CXIndexOptions) };; * \endcode; * or to prevent the -Wmissing-field-initializers warning for the above version:; * \code; * CXIndexOptions Opts{};; * Opts.Size = sizeof(CXIndexOptions);; * \endcode; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang-c/Index.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/Index.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/Index.h:43,Testability,log,log,43,/**; * Specifies a path which will contain log files for certain libclang; * invocations. A null value implies that libclang invocations are not logged.; */,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang-c/Index.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/Index.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/Index.h:145,Testability,log,logged,145,/**; * Specifies a path which will contain log files for certain libclang; * invocations. A null value implies that libclang invocations are not logged.; */,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang-c/Index.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/Index.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/Index.h:243,Availability,error,error,243,"/**; * Provides a shared context for creating translation units.; *; * Call this function instead of clang_createIndex() if you need to configure; * the additional options in CXIndexOptions.; *; * \returns The created index or null in case of error, such as an unsupported; * value of options->Size.; *; * For example:; * \code; * CXIndex createIndex(const char *ApplicationTemporaryPath) {; * const int ExcludeDeclarationsFromPCH = 1;; * const int DisplayDiagnostics = 1;; * CXIndex Idx;; * #if CINDEX_VERSION_MINOR >= 64; * CXIndexOptions Opts;; * memset(&Opts, 0, sizeof(Opts));; * Opts.Size = sizeof(CXIndexOptions);; * Opts.ThreadBackgroundPriorityForIndexing = 1;; * Opts.ExcludeDeclarationsFromPCH = ExcludeDeclarationsFromPCH;; * Opts.DisplayDiagnostics = DisplayDiagnostics;; * Opts.PreambleStoragePath = ApplicationTemporaryPath;; * Idx = clang_createIndexWithOptions(&Opts);; * if (Idx); * return Idx;; * fprintf(stderr,; * ""clang_createIndexWithOptions() failed. ""; * ""CINDEX_VERSION_MINOR = %d, sizeof(CXIndexOptions) = %u\n"",; * CINDEX_VERSION_MINOR, Opts.Size);; * #else; * (void)ApplicationTemporaryPath;; * #endif; * Idx = clang_createIndex(ExcludeDeclarationsFromPCH, DisplayDiagnostics);; * clang_CXIndex_setGlobalOptions(; * Idx, clang_CXIndex_getGlobalOptions(Idx) |; * CXGlobalOpt_ThreadBackgroundPriorityForIndexing);; * return Idx;; * }; * \endcode; *; * \sa clang_createIndex(); */",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang-c/Index.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/Index.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/Index.h:136,Modifiability,config,configure,136,"/**; * Provides a shared context for creating translation units.; *; * Call this function instead of clang_createIndex() if you need to configure; * the additional options in CXIndexOptions.; *; * \returns The created index or null in case of error, such as an unsupported; * value of options->Size.; *; * For example:; * \code; * CXIndex createIndex(const char *ApplicationTemporaryPath) {; * const int ExcludeDeclarationsFromPCH = 1;; * const int DisplayDiagnostics = 1;; * CXIndex Idx;; * #if CINDEX_VERSION_MINOR >= 64; * CXIndexOptions Opts;; * memset(&Opts, 0, sizeof(Opts));; * Opts.Size = sizeof(CXIndexOptions);; * Opts.ThreadBackgroundPriorityForIndexing = 1;; * Opts.ExcludeDeclarationsFromPCH = ExcludeDeclarationsFromPCH;; * Opts.DisplayDiagnostics = DisplayDiagnostics;; * Opts.PreambleStoragePath = ApplicationTemporaryPath;; * Idx = clang_createIndexWithOptions(&Opts);; * if (Idx); * return Idx;; * fprintf(stderr,; * ""clang_createIndexWithOptions() failed. ""; * ""CINDEX_VERSION_MINOR = %d, sizeof(CXIndexOptions) = %u\n"",; * CINDEX_VERSION_MINOR, Opts.Size);; * #else; * (void)ApplicationTemporaryPath;; * #endif; * Idx = clang_createIndex(ExcludeDeclarationsFromPCH, DisplayDiagnostics);; * clang_CXIndex_setGlobalOptions(; * Idx, clang_CXIndex_getGlobalOptions(Idx) |; * CXGlobalOpt_ThreadBackgroundPriorityForIndexing);; * return Idx;; * }; * \endcode; *; * \sa clang_createIndex(); */",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang-c/Index.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/Index.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/Index.h:263,Testability,log,log,263,/**; * Sets the invocation emission path option in a CXIndex.; *; * This function is DEPRECATED. Set CXIndexOptions::InvocationEmissionPath and; * call clang_createIndexWithOptions() instead.; *; * The invocation emission path specifies a path which will contain log; * files for certain libclang invocations. A null value (default) implies that; * libclang invocations are not logged..; */,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang-c/Index.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/Index.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/Index.h:378,Testability,log,logged,378,/**; * Sets the invocation emission path option in a CXIndex.; *; * This function is DEPRECATED. Set CXIndexOptions::InvocationEmissionPath and; * call clang_createIndexWithOptions() instead.; *; * The invocation emission path specifies a path which will contain log; * files for certain libclang invocations. A null value (default) implies that; * libclang invocations are not logged..; */,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang-c/Index.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/Index.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/Index.h:360,Performance,load,loaded,360,"/**; * Retrieve the buffer associated with the given file.; *; * \param tu the translation unit; *; * \param file the file for which to retrieve the buffer.; *; * \param size [out] if non-NULL, will be set to the size of the buffer.; *; * \returns a pointer to the buffer in memory that holds the contents of; * \p file, or a NULL pointer when the file is not loaded.; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang-c/Index.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/Index.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/Index.h:81,Integrability,rout,routines,81,"/**; * \defgroup CINDEX_TRANSLATION_UNIT Translation unit manipulation; *; * The routines in this group provide the ability to create and destroy; * translation units from files, either by parsing the contents of the files or; * by reading in a serialized representation of a translation unit.; *; * @{; */; /**; * Get the original translation unit source file name.; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang-c/Index.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/Index.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/Index.h:687,Performance,load,load,687,"/**; * Return the CXTranslationUnit for a given source file and the provided; * command line arguments one would pass to the compiler.; *; * Note: The 'source_filename' argument is optional. If the caller provides a; * NULL pointer, the name of the source file is expected to reside in the; * specified command line arguments.; *; * Note: When encountered in 'clang_command_line_args', the following options; * are ignored:; *; * '-c'; * '-emit-ast'; * '-fsyntax-only'; * '-o \<output file>' (both '-o' and '\<output file>' are ignored); *; * \param CIdx The index object with which the translation unit will be; * associated.; *; * \param source_filename The name of the source file to load, or NULL if the; * source file is included in \p clang_command_line_args.; *; * \param num_clang_command_line_args The number of command-line arguments in; * \p clang_command_line_args.; *; * \param clang_command_line_args The command-line arguments that would be; * passed to the \c clang executable if it were being invoked out-of-process.; * These command-line options will be parsed and will affect how the translation; * unit is parsed. Note that the following options are ignored: '-c',; * '-emit-ast', '-fsyntax-only' (which is the default), and '-o \<output file>'.; *; * \param num_unsaved_files the number of unsaved file entries in \p; * unsaved_files.; *; * \param unsaved_files the files that have not yet been saved to disk; * but may be required for code completion, including the contents of; * those files. The contents and name of these files (as specified by; * CXUnsavedFile) are copied when necessary, so the client only needs to; * guarantee their validity until the call to this function returns.; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang-c/Index.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/Index.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/Index.h:102,Availability,error,error,102,"/**; * Same as \c clang_createTranslationUnit2, but returns; * the \c CXTranslationUnit instead of an error code. In case of an error this; * routine returns a \c NULL \c CXTranslationUnit, without further detailed; * error codes.; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang-c/Index.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/Index.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/Index.h:128,Availability,error,error,128,"/**; * Same as \c clang_createTranslationUnit2, but returns; * the \c CXTranslationUnit instead of an error code. In case of an error this; * routine returns a \c NULL \c CXTranslationUnit, without further detailed; * error codes.; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang-c/Index.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/Index.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/Index.h:218,Availability,error,error,218,"/**; * Same as \c clang_createTranslationUnit2, but returns; * the \c CXTranslationUnit instead of an error code. In case of an error this; * routine returns a \c NULL \c CXTranslationUnit, without further detailed; * error codes.; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang-c/Index.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/Index.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/Index.h:142,Integrability,rout,routine,142,"/**; * Same as \c clang_createTranslationUnit2, but returns; * the \c CXTranslationUnit instead of an error code. In case of an error this; * routine returns a \c NULL \c CXTranslationUnit, without further detailed; * error codes.; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang-c/Index.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/Index.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/Index.h:209,Availability,error,error,209,"/**; * Create a translation unit from an AST file (\c -emit-ast).; *; * \param[out] out_TU A non-NULL pointer to store the created; * \c CXTranslationUnit.; *; * \returns Zero on success, otherwise returns an error code.; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang-c/Index.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/Index.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/Index.h:162,Performance,perform,performed,162,"/**; * Used to indicate that the translation unit is incomplete.; *; * When a translation unit is considered ""incomplete"", semantic; * analysis that is typically performed at the end of the; * translation unit will be suppressed. For example, this suppresses; * the completion of tentative declarations in C and of; * instantiation of implicitly-instantiation function templates in; * C++. This option is typically used when parsing a header with the; * intent of producing a precompiled header.; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang-c/Index.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/Index.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/Index.h:174,Performance,optimiz,optimization,174,"/**; * Used to indicate that the translation unit should be built with an; * implicit precompiled header for the preamble.; *; * An implicit precompiled header is used as an optimization when a; * particular translation unit is likely to be reparsed many times; * when the sources aren't changing that often. In this case, an; * implicit precompiled header will be built containing all of the; * initial includes at the top of the main file (what we refer to as; * the ""preamble"" of the file). In subsequent parses, if the; * preamble or the files in it have not changed, \c; * clang_reparseTranslationUnit() will re-use the implicit; * precompiled header to improve parsing performance.; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang-c/Index.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/Index.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/Index.h:675,Performance,perform,performance,675,"/**; * Used to indicate that the translation unit should be built with an; * implicit precompiled header for the preamble.; *; * An implicit precompiled header is used as an optimization when a; * particular translation unit is likely to be reparsed many times; * when the sources aren't changing that often. In this case, an; * implicit precompiled header will be built containing all of the; * initial includes at the top of the main file (what we refer to as; * the ""preamble"" of the file). In subsequent parses, if the; * preamble or the files in it have not changed, \c; * clang_reparseTranslationUnit() will re-use the implicit; * precompiled header to improve parsing performance.; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang-c/Index.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/Index.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/Index.h:57,Performance,cache,cache,57,/**; * Used to indicate that the translation unit should cache some; * code-completion results with each reparse of the source file.; *; * Caching of code-completion results is a performance optimization that; * introduces some overhead to reparsing but improves the performance of; * code-completion operations.; */,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang-c/Index.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/Index.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/Index.h:179,Performance,perform,performance,179,/**; * Used to indicate that the translation unit should cache some; * code-completion results with each reparse of the source file.; *; * Caching of code-completion results is a performance optimization that; * introduces some overhead to reparsing but improves the performance of; * code-completion operations.; */,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang-c/Index.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/Index.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/Index.h:191,Performance,optimiz,optimization,191,/**; * Used to indicate that the translation unit should cache some; * code-completion results with each reparse of the source file.; *; * Caching of code-completion results is a performance optimization that; * introduces some overhead to reparsing but improves the performance of; * code-completion operations.; */,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang-c/Index.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/Index.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/Index.h:267,Performance,perform,performance,267,/**; * Used to indicate that the translation unit should cache some; * code-completion results with each reparse of the source file.; *; * Caching of code-completion results is a performance optimization that; * introduces some overhead to reparsing but improves the performance of; * code-completion operations.; */,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang-c/Index.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/Index.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/Index.h:114,Availability,avail,available,114,/**; * DEPRECATED: Enabled chained precompiled preambles in C++.; *; * Note: this is a *temporary* option that is available only while; * we are testing C++ precompiled preamble support. It is deprecated.; */,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang-c/Index.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/Index.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/Index.h:145,Testability,test,testing,145,/**; * DEPRECATED: Enabled chained precompiled preambles in C++.; *; * Note: this is a *temporary* option that is available only while; * we are testing C++ precompiled preamble support. It is deprecated.; */,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang-c/Index.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/Index.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/Index.h:233,Energy Efficiency,reduce,reduced,233,/**; * Used to indicate that the precompiled preamble should be created on; * the first parse. Otherwise it will be created on the first reparse. This; * trades runtime on the first parse (serializing the preamble takes time) for; * reduced runtime on the second parse (can now reuse the preamble).; */,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang-c/Index.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/Index.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/Index.h:41,Availability,error,errors,41,"/**; * Do not stop processing when fatal errors are encountered.; *; * When fatal errors are encountered while parsing a translation unit,; * semantic analysis is typically stopped early when compiling code. A common; * source for fatal errors are unresolvable include files. For the; * purposes of an IDE, this is undesirable behavior and as much information; * as possible should be reported. Use this flag to enable this behavior.; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang-c/Index.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/Index.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/Index.h:82,Availability,error,errors,82,"/**; * Do not stop processing when fatal errors are encountered.; *; * When fatal errors are encountered while parsing a translation unit,; * semantic analysis is typically stopped early when compiling code. A common; * source for fatal errors are unresolvable include files. For the; * purposes of an IDE, this is undesirable behavior and as much information; * as possible should be reported. Use this flag to enable this behavior.; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang-c/Index.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/Index.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/Index.h:237,Availability,error,errors,237,"/**; * Do not stop processing when fatal errors are encountered.; *; * When fatal errors are encountered while parsing a translation unit,; * semantic analysis is typically stopped early when compiling code. A common; * source for fatal errors are unresolvable include files. For the; * purposes of an IDE, this is undesirable behavior and as much information; * as possible should be reported. Use this flag to enable this behavior.; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang-c/Index.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/Index.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/Index.h:33,Availability,error,errors,33,"/**; * Used to indicate that non-errors from included files should be ignored.; *; * If set, clang_getDiagnosticSetFromTU() will not report e.g. warnings from; * included files anymore. This speeds up clang_getDiagnosticSetFromTU() for; * the case where these warnings are not of interest, as for an IDE for; * example, which typically shows only the diagnostics in the main file.; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang-c/Index.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/Index.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/Index.h:558,Integrability,rout,routines,558,"/**; * Returns the set of flags that is suitable for parsing a translation; * unit that is being edited.; *; * The set of flags returned provide options for \c clang_parseTranslationUnit(); * to indicate that the translation unit is likely to be reparsed many times,; * either explicitly (via \c clang_reparseTranslationUnit()) or implicitly; * (e.g., by code completion (\c clang_codeCompletionAt())). The returned flag; * set contains an unspecified set of optimizations (e.g., the precompiled; * preamble) geared toward improving the performance of these routines. The; * set of optimizations enabled may change from one version to the next.; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang-c/Index.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/Index.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/Index.h:459,Performance,optimiz,optimizations,459,"/**; * Returns the set of flags that is suitable for parsing a translation; * unit that is being edited.; *; * The set of flags returned provide options for \c clang_parseTranslationUnit(); * to indicate that the translation unit is likely to be reparsed many times,; * either explicitly (via \c clang_reparseTranslationUnit()) or implicitly; * (e.g., by code completion (\c clang_codeCompletionAt())). The returned flag; * set contains an unspecified set of optimizations (e.g., the precompiled; * preamble) geared toward improving the performance of these routines. The; * set of optimizations enabled may change from one version to the next.; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang-c/Index.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/Index.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/Index.h:537,Performance,perform,performance,537,"/**; * Returns the set of flags that is suitable for parsing a translation; * unit that is being edited.; *; * The set of flags returned provide options for \c clang_parseTranslationUnit(); * to indicate that the translation unit is likely to be reparsed many times,; * either explicitly (via \c clang_reparseTranslationUnit()) or implicitly; * (e.g., by code completion (\c clang_codeCompletionAt())). The returned flag; * set contains an unspecified set of optimizations (e.g., the precompiled; * preamble) geared toward improving the performance of these routines. The; * set of optimizations enabled may change from one version to the next.; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang-c/Index.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/Index.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/Index.h:582,Performance,optimiz,optimizations,582,"/**; * Returns the set of flags that is suitable for parsing a translation; * unit that is being edited.; *; * The set of flags returned provide options for \c clang_parseTranslationUnit(); * to indicate that the translation unit is likely to be reparsed many times,; * either explicitly (via \c clang_reparseTranslationUnit()) or implicitly; * (e.g., by code completion (\c clang_codeCompletionAt())). The returned flag; * set contains an unspecified set of optimizations (e.g., the precompiled; * preamble) geared toward improving the performance of these routines. The; * set of optimizations enabled may change from one version to the next.; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang-c/Index.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/Index.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/Index.h:101,Availability,error,error,101,"/**; * Same as \c clang_parseTranslationUnit2, but returns; * the \c CXTranslationUnit instead of an error code. In case of an error this; * routine returns a \c NULL \c CXTranslationUnit, without further detailed; * error codes.; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang-c/Index.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/Index.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/Index.h:127,Availability,error,error,127,"/**; * Same as \c clang_parseTranslationUnit2, but returns; * the \c CXTranslationUnit instead of an error code. In case of an error this; * routine returns a \c NULL \c CXTranslationUnit, without further detailed; * error codes.; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang-c/Index.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/Index.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/Index.h:217,Availability,error,error,217,"/**; * Same as \c clang_parseTranslationUnit2, but returns; * the \c CXTranslationUnit instead of an error code. In case of an error this; * routine returns a \c NULL \c CXTranslationUnit, without further detailed; * error codes.; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang-c/Index.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/Index.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/Index.h:141,Integrability,rout,routine,141,"/**; * Same as \c clang_parseTranslationUnit2, but returns; * the \c CXTranslationUnit instead of an error code. In case of an error this; * routine returns a \c NULL \c CXTranslationUnit, without further detailed; * error codes.; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang-c/Index.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/Index.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/Index.h:2015,Availability,error,error,2015,"file and the translation unit corresponding; * to that file.; *; * This routine is the main entry point for the Clang C API, providing the; * ability to parse a source file into a translation unit that can then be; * queried by other functions in the API. This routine accepts a set of; * command-line arguments so that the compilation can be configured in the same; * way that the compiler is configured on the command line.; *; * \param CIdx The index object with which the translation unit will be; * associated.; *; * \param source_filename The name of the source file to load, or NULL if the; * source file is included in \c command_line_args.; *; * \param command_line_args The command-line arguments that would be; * passed to the \c clang executable if it were being invoked out-of-process.; * These command-line options will be parsed and will affect how the translation; * unit is parsed. Note that the following options are ignored: '-c',; * '-emit-ast', '-fsyntax-only' (which is the default), and '-o \<output file>'.; *; * \param num_command_line_args The number of command-line arguments in; * \c command_line_args.; *; * \param unsaved_files the files that have not yet been saved to disk; * but may be required for parsing, including the contents of; * those files. The contents and name of these files (as specified by; * CXUnsavedFile) are copied when necessary, so the client only needs to; * guarantee their validity until the call to this function returns.; *; * \param num_unsaved_files the number of unsaved file entries in \p; * unsaved_files.; *; * \param options A bitmask of options that affects how the translation unit; * is managed but not its compilation. This should be a bitwise OR of the; * CXTranslationUnit_XXX flags.; *; * \param[out] out_TU A non-NULL pointer to store the created; * \c CXTranslationUnit, describing the parsed code and containing any; * diagnostics produced by the compiler.; *; * \returns Zero on success, otherwise returns an error code.; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang-c/Index.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/Index.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/Index.h:102,Integrability,rout,routine,102,"/**; * Parse the given source file and the translation unit corresponding; * to that file.; *; * This routine is the main entry point for the Clang C API, providing the; * ability to parse a source file into a translation unit that can then be; * queried by other functions in the API. This routine accepts a set of; * command-line arguments so that the compilation can be configured in the same; * way that the compiler is configured on the command line.; *; * \param CIdx The index object with which the translation unit will be; * associated.; *; * \param source_filename The name of the source file to load, or NULL if the; * source file is included in \c command_line_args.; *; * \param command_line_args The command-line arguments that would be; * passed to the \c clang executable if it were being invoked out-of-process.; * These command-line options will be parsed and will affect how the translation; * unit is parsed. Note that the following options are ignored: '-c',; * '-emit-ast', '-fsyntax-only' (which is the default), and '-o \<output file>'.; *; * \param num_command_line_args The number of command-line arguments in; * \c command_line_args.; *; * \param unsaved_files the files that have not yet been saved to disk; * but may be required for parsing, including the contents of; * those files. The contents and name of these files (as specified by; * CXUnsavedFile) are copied when necessary, so the client only needs to; * guarantee their validity until the call to this function returns.; *; * \param num_unsaved_files the number of unsaved file entries in \p; * unsaved_files.; *; * \param options A bitmask of options that affects how the translation unit; * is managed but not its compilation. This should be a bitwise OR of the; * CXTranslationUnit_XXX flags.; *; * \param[out] out_TU A non-NULL pointer to store the created; * \c CXTranslationUnit, describing the parsed code and containing any; * diagnostics produced by the compiler.; *; * \returns Zero on success, otherwi",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang-c/Index.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/Index.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/Index.h:291,Integrability,rout,routine,291,"/**; * Parse the given source file and the translation unit corresponding; * to that file.; *; * This routine is the main entry point for the Clang C API, providing the; * ability to parse a source file into a translation unit that can then be; * queried by other functions in the API. This routine accepts a set of; * command-line arguments so that the compilation can be configured in the same; * way that the compiler is configured on the command line.; *; * \param CIdx The index object with which the translation unit will be; * associated.; *; * \param source_filename The name of the source file to load, or NULL if the; * source file is included in \c command_line_args.; *; * \param command_line_args The command-line arguments that would be; * passed to the \c clang executable if it were being invoked out-of-process.; * These command-line options will be parsed and will affect how the translation; * unit is parsed. Note that the following options are ignored: '-c',; * '-emit-ast', '-fsyntax-only' (which is the default), and '-o \<output file>'.; *; * \param num_command_line_args The number of command-line arguments in; * \c command_line_args.; *; * \param unsaved_files the files that have not yet been saved to disk; * but may be required for parsing, including the contents of; * those files. The contents and name of these files (as specified by; * CXUnsavedFile) are copied when necessary, so the client only needs to; * guarantee their validity until the call to this function returns.; *; * \param num_unsaved_files the number of unsaved file entries in \p; * unsaved_files.; *; * \param options A bitmask of options that affects how the translation unit; * is managed but not its compilation. This should be a bitwise OR of the; * CXTranslationUnit_XXX flags.; *; * \param[out] out_TU A non-NULL pointer to store the created; * \c CXTranslationUnit, describing the parsed code and containing any; * diagnostics produced by the compiler.; *; * \returns Zero on success, otherwi",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang-c/Index.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/Index.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/Index.h:373,Modifiability,config,configured,373,"/**; * Parse the given source file and the translation unit corresponding; * to that file.; *; * This routine is the main entry point for the Clang C API, providing the; * ability to parse a source file into a translation unit that can then be; * queried by other functions in the API. This routine accepts a set of; * command-line arguments so that the compilation can be configured in the same; * way that the compiler is configured on the command line.; *; * \param CIdx The index object with which the translation unit will be; * associated.; *; * \param source_filename The name of the source file to load, or NULL if the; * source file is included in \c command_line_args.; *; * \param command_line_args The command-line arguments that would be; * passed to the \c clang executable if it were being invoked out-of-process.; * These command-line options will be parsed and will affect how the translation; * unit is parsed. Note that the following options are ignored: '-c',; * '-emit-ast', '-fsyntax-only' (which is the default), and '-o \<output file>'.; *; * \param num_command_line_args The number of command-line arguments in; * \c command_line_args.; *; * \param unsaved_files the files that have not yet been saved to disk; * but may be required for parsing, including the contents of; * those files. The contents and name of these files (as specified by; * CXUnsavedFile) are copied when necessary, so the client only needs to; * guarantee their validity until the call to this function returns.; *; * \param num_unsaved_files the number of unsaved file entries in \p; * unsaved_files.; *; * \param options A bitmask of options that affects how the translation unit; * is managed but not its compilation. This should be a bitwise OR of the; * CXTranslationUnit_XXX flags.; *; * \param[out] out_TU A non-NULL pointer to store the created; * \c CXTranslationUnit, describing the parsed code and containing any; * diagnostics produced by the compiler.; *; * \returns Zero on success, otherwi",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang-c/Index.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/Index.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/Index.h:424,Modifiability,config,configured,424,"/**; * Parse the given source file and the translation unit corresponding; * to that file.; *; * This routine is the main entry point for the Clang C API, providing the; * ability to parse a source file into a translation unit that can then be; * queried by other functions in the API. This routine accepts a set of; * command-line arguments so that the compilation can be configured in the same; * way that the compiler is configured on the command line.; *; * \param CIdx The index object with which the translation unit will be; * associated.; *; * \param source_filename The name of the source file to load, or NULL if the; * source file is included in \c command_line_args.; *; * \param command_line_args The command-line arguments that would be; * passed to the \c clang executable if it were being invoked out-of-process.; * These command-line options will be parsed and will affect how the translation; * unit is parsed. Note that the following options are ignored: '-c',; * '-emit-ast', '-fsyntax-only' (which is the default), and '-o \<output file>'.; *; * \param num_command_line_args The number of command-line arguments in; * \c command_line_args.; *; * \param unsaved_files the files that have not yet been saved to disk; * but may be required for parsing, including the contents of; * those files. The contents and name of these files (as specified by; * CXUnsavedFile) are copied when necessary, so the client only needs to; * guarantee their validity until the call to this function returns.; *; * \param num_unsaved_files the number of unsaved file entries in \p; * unsaved_files.; *; * \param options A bitmask of options that affects how the translation unit; * is managed but not its compilation. This should be a bitwise OR of the; * CXTranslationUnit_XXX flags.; *; * \param[out] out_TU A non-NULL pointer to store the created; * \c CXTranslationUnit, describing the parsed code and containing any; * diagnostics produced by the compiler.; *; * \returns Zero on success, otherwi",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang-c/Index.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/Index.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/Index.h:606,Performance,load,load,606,"/**; * Parse the given source file and the translation unit corresponding; * to that file.; *; * This routine is the main entry point for the Clang C API, providing the; * ability to parse a source file into a translation unit that can then be; * queried by other functions in the API. This routine accepts a set of; * command-line arguments so that the compilation can be configured in the same; * way that the compiler is configured on the command line.; *; * \param CIdx The index object with which the translation unit will be; * associated.; *; * \param source_filename The name of the source file to load, or NULL if the; * source file is included in \c command_line_args.; *; * \param command_line_args The command-line arguments that would be; * passed to the \c clang executable if it were being invoked out-of-process.; * These command-line options will be parsed and will affect how the translation; * unit is parsed. Note that the following options are ignored: '-c',; * '-emit-ast', '-fsyntax-only' (which is the default), and '-o \<output file>'.; *; * \param num_command_line_args The number of command-line arguments in; * \c command_line_args.; *; * \param unsaved_files the files that have not yet been saved to disk; * but may be required for parsing, including the contents of; * those files. The contents and name of these files (as specified by; * CXUnsavedFile) are copied when necessary, so the client only needs to; * guarantee their validity until the call to this function returns.; *; * \param num_unsaved_files the number of unsaved file entries in \p; * unsaved_files.; *; * \param options A bitmask of options that affects how the translation unit; * is managed but not its compilation. This should be a bitwise OR of the; * CXTranslationUnit_XXX flags.; *; * \param[out] out_TU A non-NULL pointer to store the created; * \c CXTranslationUnit, describing the parsed code and containing any; * diagnostics produced by the compiler.; *; * \returns Zero on success, otherwi",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang-c/Index.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/Index.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/Index.h:29,Availability,error,error,29,/**; * Describes the kind of error that occurred (if any) in a call to; * \c clang_saveTranslationUnit().; */,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang-c/Index.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/Index.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/Index.h:25,Availability,error,error,25,/**; * Indicates that no error occurred while saving a translation unit.; */,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang-c/Index.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/Index.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/Index.h:33,Availability,error,error,33,/**; * Indicates that an unknown error occurred while attempting to save; * the file.; *; * This error typically indicates that file I/O failed when attempting to; * write the file.; */,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang-c/Index.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/Index.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/Index.h:97,Availability,error,error,97,/**; * Indicates that an unknown error occurred while attempting to save; * the file.; *; * This error typically indicates that file I/O failed when attempting to; * write the file.; */,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang-c/Index.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/Index.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/Index.h:22,Availability,error,errors,22,/**; * Indicates that errors during translation prevented this attempt; * to save the translation unit.; *; * Errors that prevent the translation unit from being saved can be; * extracted using \c clang_getNumDiagnostics() and \c clang_getDiagnostic().; */,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang-c/Index.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/Index.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/Index.h:110,Availability,Error,Errors,110,/**; * Indicates that errors during translation prevented this attempt; * to save the translation unit.; *; * Errors that prevent the translation unit from being saved can be; * extracted using \c clang_getNumDiagnostics() and \c clang_getDiagnostic().; */,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang-c/Index.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/Index.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/Index.h:153,Availability,error,error,153,"/**; * Saves a translation unit into a serialized representation of; * that translation unit on disk.; *; * Any translation unit that was parsed without error can be saved; * into a file. The translation unit can then be deserialized into a; * new \c CXTranslationUnit with \c clang_createTranslationUnit() or,; * if it is an incomplete translation unit that corresponds to a; * header, used as a precompiled header when parsing other translation; * units.; *; * \param TU The translation unit to save.; *; * \param FileName The file to which the translation unit will be saved.; *; * \param options A bitmask of options that affects how the translation unit; * is saved. This should be a bitwise OR of the; * CXSaveTranslationUnit_XXX flags.; *; * \returns A value that will match one of the enumerators of the CXSaveError; * enumeration. Zero (CXSaveError_None) indicates that the translation unit was; * saved successfully, while a non-zero value indicates that a problem occurred.; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang-c/Index.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/Index.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/Index.h:245,Usability,resume,resume,245,/**; * Suspend a translation unit in order to free memory associated with it.; *; * A suspended translation unit uses significantly less memory but on the other; * side does not support any other calls than \c clang_reparseTranslationUnit; * to resume it or \c clang_disposeTranslationUnit to dispose it completely.; */,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang-c/Index.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/Index.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/Index.h:243,Performance,optimiz,optimizations,243,/**; * Returns the set of flags that is suitable for reparsing a translation; * unit.; *; * The set of flags returned provide options for; * \c clang_reparseTranslationUnit() by default. The returned flag; * set contains an unspecified set of optimizations geared toward common uses; * of reparsing. The set of optimizations enabled may change from one version; * to the next.; */,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang-c/Index.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/Index.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/Index.h:311,Performance,optimiz,optimizations,311,/**; * Returns the set of flags that is suitable for reparsing a translation; * unit.; *; * The set of flags returned provide options for; * \c clang_reparseTranslationUnit() by default. The returned flag; * set contains an unspecified set of optimizations geared toward common uses; * of reparsing. The set of optimizations enabled may change from one version; * to the next.; */,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang-c/Index.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/Index.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/Index.h:1700,Availability,error,error,1700,"/**; * Reparse the source files that produced this translation unit.; *; * This routine can be used to re-parse the source files that originally; * created the given translation unit, for example because those source files; * have changed (either on disk or as passed via \p unsaved_files). The; * source code will be reparsed with the same command-line options as it; * was originally parsed.; *; * Reparsing a translation unit invalidates all cursors and source locations; * that refer into that translation unit. This makes reparsing a translation; * unit semantically equivalent to destroying the translation unit and then; * creating a new translation unit with the same command-line arguments.; * However, it may be more efficient to reparse a translation; * unit using this routine.; *; * \param TU The translation unit whose contents will be re-parsed. The; * translation unit must originally have been built with; * \c clang_createTranslationUnitFromSourceFile().; *; * \param num_unsaved_files The number of unsaved file entries in \p; * unsaved_files.; *; * \param unsaved_files The files that have not yet been saved to disk; * but may be required for parsing, including the contents of; * those files. The contents and name of these files (as specified by; * CXUnsavedFile) are copied when necessary, so the client only needs to; * guarantee their validity until the call to this function returns.; *; * \param options A bitset of options composed of the flags in CXReparse_Flags.; * The function \c clang_defaultReparseOptions() produces a default set of; * options recommended for most uses, based on the translation unit.; *; * \returns 0 if the sources could be reparsed. A non-zero error code will be; * returned if reparsing was impossible, such that the translation unit is; * invalid. In such cases, the only valid call for \c TU is; * \c clang_disposeTranslationUnit(TU). The error codes returned by this; * routine are described by the \c CXErrorCode enum.; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang-c/Index.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/Index.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/Index.h:1898,Availability,error,error,1898,"/**; * Reparse the source files that produced this translation unit.; *; * This routine can be used to re-parse the source files that originally; * created the given translation unit, for example because those source files; * have changed (either on disk or as passed via \p unsaved_files). The; * source code will be reparsed with the same command-line options as it; * was originally parsed.; *; * Reparsing a translation unit invalidates all cursors and source locations; * that refer into that translation unit. This makes reparsing a translation; * unit semantically equivalent to destroying the translation unit and then; * creating a new translation unit with the same command-line arguments.; * However, it may be more efficient to reparse a translation; * unit using this routine.; *; * \param TU The translation unit whose contents will be re-parsed. The; * translation unit must originally have been built with; * \c clang_createTranslationUnitFromSourceFile().; *; * \param num_unsaved_files The number of unsaved file entries in \p; * unsaved_files.; *; * \param unsaved_files The files that have not yet been saved to disk; * but may be required for parsing, including the contents of; * those files. The contents and name of these files (as specified by; * CXUnsavedFile) are copied when necessary, so the client only needs to; * guarantee their validity until the call to this function returns.; *; * \param options A bitset of options composed of the flags in CXReparse_Flags.; * The function \c clang_defaultReparseOptions() produces a default set of; * options recommended for most uses, based on the translation unit.; *; * \returns 0 if the sources could be reparsed. A non-zero error code will be; * returned if reparsing was impossible, such that the translation unit is; * invalid. In such cases, the only valid call for \c TU is; * \c clang_disposeTranslationUnit(TU). The error codes returned by this; * routine are described by the \c CXErrorCode enum.; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang-c/Index.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/Index.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/Index.h:727,Energy Efficiency,efficient,efficient,727,"/**; * Reparse the source files that produced this translation unit.; *; * This routine can be used to re-parse the source files that originally; * created the given translation unit, for example because those source files; * have changed (either on disk or as passed via \p unsaved_files). The; * source code will be reparsed with the same command-line options as it; * was originally parsed.; *; * Reparsing a translation unit invalidates all cursors and source locations; * that refer into that translation unit. This makes reparsing a translation; * unit semantically equivalent to destroying the translation unit and then; * creating a new translation unit with the same command-line arguments.; * However, it may be more efficient to reparse a translation; * unit using this routine.; *; * \param TU The translation unit whose contents will be re-parsed. The; * translation unit must originally have been built with; * \c clang_createTranslationUnitFromSourceFile().; *; * \param num_unsaved_files The number of unsaved file entries in \p; * unsaved_files.; *; * \param unsaved_files The files that have not yet been saved to disk; * but may be required for parsing, including the contents of; * those files. The contents and name of these files (as specified by; * CXUnsavedFile) are copied when necessary, so the client only needs to; * guarantee their validity until the call to this function returns.; *; * \param options A bitset of options composed of the flags in CXReparse_Flags.; * The function \c clang_defaultReparseOptions() produces a default set of; * options recommended for most uses, based on the translation unit.; *; * \returns 0 if the sources could be reparsed. A non-zero error code will be; * returned if reparsing was impossible, such that the translation unit is; * invalid. In such cases, the only valid call for \c TU is; * \c clang_disposeTranslationUnit(TU). The error codes returned by this; * routine are described by the \c CXErrorCode enum.; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang-c/Index.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/Index.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/Index.h:80,Integrability,rout,routine,80,"/**; * Reparse the source files that produced this translation unit.; *; * This routine can be used to re-parse the source files that originally; * created the given translation unit, for example because those source files; * have changed (either on disk or as passed via \p unsaved_files). The; * source code will be reparsed with the same command-line options as it; * was originally parsed.; *; * Reparsing a translation unit invalidates all cursors and source locations; * that refer into that translation unit. This makes reparsing a translation; * unit semantically equivalent to destroying the translation unit and then; * creating a new translation unit with the same command-line arguments.; * However, it may be more efficient to reparse a translation; * unit using this routine.; *; * \param TU The translation unit whose contents will be re-parsed. The; * translation unit must originally have been built with; * \c clang_createTranslationUnitFromSourceFile().; *; * \param num_unsaved_files The number of unsaved file entries in \p; * unsaved_files.; *; * \param unsaved_files The files that have not yet been saved to disk; * but may be required for parsing, including the contents of; * those files. The contents and name of these files (as specified by; * CXUnsavedFile) are copied when necessary, so the client only needs to; * guarantee their validity until the call to this function returns.; *; * \param options A bitset of options composed of the flags in CXReparse_Flags.; * The function \c clang_defaultReparseOptions() produces a default set of; * options recommended for most uses, based on the translation unit.; *; * \returns 0 if the sources could be reparsed. A non-zero error code will be; * returned if reparsing was impossible, such that the translation unit is; * invalid. In such cases, the only valid call for \c TU is; * \c clang_disposeTranslationUnit(TU). The error codes returned by this; * routine are described by the \c CXErrorCode enum.; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang-c/Index.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/Index.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/Index.h:781,Integrability,rout,routine,781,"/**; * Reparse the source files that produced this translation unit.; *; * This routine can be used to re-parse the source files that originally; * created the given translation unit, for example because those source files; * have changed (either on disk or as passed via \p unsaved_files). The; * source code will be reparsed with the same command-line options as it; * was originally parsed.; *; * Reparsing a translation unit invalidates all cursors and source locations; * that refer into that translation unit. This makes reparsing a translation; * unit semantically equivalent to destroying the translation unit and then; * creating a new translation unit with the same command-line arguments.; * However, it may be more efficient to reparse a translation; * unit using this routine.; *; * \param TU The translation unit whose contents will be re-parsed. The; * translation unit must originally have been built with; * \c clang_createTranslationUnitFromSourceFile().; *; * \param num_unsaved_files The number of unsaved file entries in \p; * unsaved_files.; *; * \param unsaved_files The files that have not yet been saved to disk; * but may be required for parsing, including the contents of; * those files. The contents and name of these files (as specified by; * CXUnsavedFile) are copied when necessary, so the client only needs to; * guarantee their validity until the call to this function returns.; *; * \param options A bitset of options composed of the flags in CXReparse_Flags.; * The function \c clang_defaultReparseOptions() produces a default set of; * options recommended for most uses, based on the translation unit.; *; * \returns 0 if the sources could be reparsed. A non-zero error code will be; * returned if reparsing was impossible, such that the translation unit is; * invalid. In such cases, the only valid call for \c TU is; * \c clang_disposeTranslationUnit(TU). The error codes returned by this; * routine are described by the \c CXErrorCode enum.; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang-c/Index.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/Index.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/Index.h:1930,Integrability,rout,routine,1930,"/**; * Reparse the source files that produced this translation unit.; *; * This routine can be used to re-parse the source files that originally; * created the given translation unit, for example because those source files; * have changed (either on disk or as passed via \p unsaved_files). The; * source code will be reparsed with the same command-line options as it; * was originally parsed.; *; * Reparsing a translation unit invalidates all cursors and source locations; * that refer into that translation unit. This makes reparsing a translation; * unit semantically equivalent to destroying the translation unit and then; * creating a new translation unit with the same command-line arguments.; * However, it may be more efficient to reparse a translation; * unit using this routine.; *; * \param TU The translation unit whose contents will be re-parsed. The; * translation unit must originally have been built with; * \c clang_createTranslationUnitFromSourceFile().; *; * \param num_unsaved_files The number of unsaved file entries in \p; * unsaved_files.; *; * \param unsaved_files The files that have not yet been saved to disk; * but may be required for parsing, including the contents of; * those files. The contents and name of these files (as specified by; * CXUnsavedFile) are copied when necessary, so the client only needs to; * guarantee their validity until the call to this function returns.; *; * \param options A bitset of options composed of the flags in CXReparse_Flags.; * The function \c clang_defaultReparseOptions() produces a default set of; * options recommended for most uses, based on the translation unit.; *; * \returns 0 if the sources could be reparsed. A non-zero error code will be; * returned if reparsing was impossible, such that the translation unit is; * invalid. In such cases, the only valid call for \c TU is; * \c clang_disposeTranslationUnit(TU). The error codes returned by this; * routine are described by the \c CXErrorCode enum.; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang-c/Index.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/Index.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/Index.h:45,Integrability,depend,depend,45,/* Amount of resources used.; The units will depend on the resource kind. */,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang-c/Index.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/Index.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/Index.h:79,Deployability,release,released,79,/**; * Return the memory usage of a translation unit. This object; * should be released with clang_disposeCXTUResourceUsage().; */,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang-c/Index.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/Index.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/Index.h:99,Availability,error,error,99,/**; * Get the normalized target triple as a string.; *; * Returns the empty string in case of any error.; */,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang-c/Index.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/Index.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/Index.h:80,Availability,error,error,80,/**; * Get the pointer width of the target in bits.; *; * Returns -1 in case of error.; */,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang-c/Index.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/Index.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/Index.h:88,Integrability,interface,interface,88,"/* Declarations */; /**; * A declaration whose specific kind is not exposed via this; * interface.; *; * Unexposed declarations have the same operations as any other kind; * of declaration; one can extract their location information,; * spelling, find their definitions, etc. However, the specific kind; * of the declaration is not reported.; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang-c/Index.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/Index.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/Index.h:68,Security,expose,exposed,68,"/* Declarations */; /**; * A declaration whose specific kind is not exposed via this; * interface.; *; * Unexposed declarations have the same operations as any other kind; * of declaration; one can extract their location information,; * spelling, find their definitions, etc. However, the specific kind; * of the declaration is not reported.; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang-c/Index.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/Index.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/Index.h:6,Modifiability,variab,variable,6,/** A variable. */,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang-c/Index.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/Index.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/Index.h:21,Integrability,interface,interface,21,/** An Objective-C \@interface. */,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang-c/Index.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/Index.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/Index.h:21,Integrability,interface,interface,21,/** An Objective-C \@interface for a category. */,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang-c/Index.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/Index.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/Index.h:21,Integrability,protocol,protocol,21,/** An Objective-C \@protocol declaration. */,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang-c/Index.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/Index.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/Index.h:28,Modifiability,variab,variable,28,/** An Objective-C instance variable. */,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang-c/Index.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/Index.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/Index.h:7,Security,access,access,7,/** An access specifier. */,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang-c/Index.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/Index.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/Index.h:315,Modifiability,variab,variable,315,"/**; * A reference to a type declaration.; *; * A type reference occurs anywhere where a type is named but not; * declared. For example, given:; *; * \code; * typedef unsigned size_type;; * size_type size;; * \endcode; *; * The typedef is a declaration of size_type (CXCursor_TypedefDecl),; * while the type of the variable ""size"" is referenced. The cursor; * referenced by the type of size is the typedef for size_type.; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang-c/Index.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/Index.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/Index.h:800,Availability,avail,available,800,"/**; * A reference to a set of overloaded functions or function templates; * that has not yet been resolved to a specific function or function template.; *; * An overloaded declaration reference cursor occurs in C++ templates where; * a dependent name refers to a function. For example:; *; * \code; * template<typename T> void swap(T&, T&);; *; * struct X { ... };; * void swap(X&, X&);; *; * template<typename T>; * void reverse(T* first, T* last) {; * while (first < last - 1) {; * swap(*first, *--last);; * ++first;; * }; * }; *; * struct Y { };; * void swap(Y&, Y&);; * \endcode; *; * Here, the identifier ""swap"" is associated with an overloaded declaration; * reference. In the template definition, ""swap"" refers to either of the two; * ""swap"" functions declared above, so both results will be available. At; * instantiation time, ""swap"" may also refer to other functions found via; * argument-dependent lookup (e.g., the ""swap"" function at the end of the; * example).; *; * The functions \c clang_getNumOverloadedDecls() and; * \c clang_getOverloadedDecl() can be used to retrieve the definitions; * referenced by this cursor.; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang-c/Index.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/Index.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/Index.h:237,Integrability,depend,dependent,237,"/**; * A reference to a set of overloaded functions or function templates; * that has not yet been resolved to a specific function or function template.; *; * An overloaded declaration reference cursor occurs in C++ templates where; * a dependent name refers to a function. For example:; *; * \code; * template<typename T> void swap(T&, T&);; *; * struct X { ... };; * void swap(X&, X&);; *; * template<typename T>; * void reverse(T* first, T* last) {; * while (first < last - 1) {; * swap(*first, *--last);; * ++first;; * }; * }; *; * struct Y { };; * void swap(Y&, Y&);; * \endcode; *; * Here, the identifier ""swap"" is associated with an overloaded declaration; * reference. In the template definition, ""swap"" refers to either of the two; * ""swap"" functions declared above, so both results will be available. At; * instantiation time, ""swap"" may also refer to other functions found via; * argument-dependent lookup (e.g., the ""swap"" function at the end of the; * example).; *; * The functions \c clang_getNumOverloadedDecls() and; * \c clang_getOverloadedDecl() can be used to retrieve the definitions; * referenced by this cursor.; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang-c/Index.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/Index.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/Index.h:900,Integrability,depend,dependent,900,"/**; * A reference to a set of overloaded functions or function templates; * that has not yet been resolved to a specific function or function template.; *; * An overloaded declaration reference cursor occurs in C++ templates where; * a dependent name refers to a function. For example:; *; * \code; * template<typename T> void swap(T&, T&);; *; * struct X { ... };; * void swap(X&, X&);; *; * template<typename T>; * void reverse(T* first, T* last) {; * while (first < last - 1) {; * swap(*first, *--last);; * ++first;; * }; * }; *; * struct Y { };; * void swap(Y&, Y&);; * \endcode; *; * Here, the identifier ""swap"" is associated with an overloaded declaration; * reference. In the template definition, ""swap"" refers to either of the two; * ""swap"" functions declared above, so both results will be available. At; * instantiation time, ""swap"" may also refer to other functions found via; * argument-dependent lookup (e.g., the ""swap"" function at the end of the; * example).; *; * The functions \c clang_getNumOverloadedDecls() and; * \c clang_getOverloadedDecl() can be used to retrieve the definitions; * referenced by this cursor.; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang-c/Index.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/Index.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/Index.h:24,Modifiability,variab,variable,24,"/**; * A reference to a variable that occurs in some non-expression; * context, e.g., a C++ lambda capture list.; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang-c/Index.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/Index.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/Index.h:3,Availability,Error,Error,3,/* Error conditions */,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang-c/Index.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/Index.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/Index.h:68,Integrability,interface,interface,68,"/**; * An expression whose specific kind is not exposed via this; * interface.; *; * Unexposed expressions have the same operations as any other kind; * of expression; one can extract their location information,; * spelling, children, etc. However, the specific kind of the; * expression is not reported.; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang-c/Index.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/Index.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/Index.h:48,Security,expose,exposed,48,"/**; * An expression whose specific kind is not exposed via this; * interface.; *; * Unexposed expressions have the same operations as any other kind; * of expression; one can extract their location information,; * spelling, children, etc. However, the specific kind of the; * expression is not reported.; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang-c/Index.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/Index.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/Index.h:83,Modifiability,variab,variable,83,"/**; * An expression that refers to some value declaration, such; * as a function, variable, or enumerator.; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang-c/Index.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/Index.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/Index.h:31,Integrability,message,message,31,/** An expression that sends a message to an Objective-C; object or class. */,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang-c/Index.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/Index.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/Index.h:21,Integrability,protocol,protocol,21,/** An Objective-C \@protocol expression.; */,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang-c/Index.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/Index.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/Index.h:20,Integrability,bridg,bridged,20,"/** An Objective-C ""bridged"" cast expression, which casts between; * Objective-C pointers and C pointers, transferring ownership in the process.; *; * \code; * NSString *str = (__bridge_transfer NSString *)CFCreateString();; * \endcode; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang-c/Index.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/Index.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/Index.h:19,Availability,avail,available,19,/** Represents an @available(...) check.; */,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang-c/Index.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/Index.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/Index.h:66,Integrability,interface,interface,66,"/**; * A statement whose specific kind is not exposed via this; * interface.; *; * Unexposed statements have the same operations as any other kind of; * statement; one can extract their location information, spelling,; * children, etc. However, the specific kind of the statement is not; * reported.; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang-c/Index.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/Index.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/Index.h:46,Security,expose,exposed,46,"/**; * A statement whose specific kind is not exposed via this; * interface.; *; * Unexposed statements have the same operations as any other kind of; * statement; one can extract their location information, spelling,; * children, etc. However, the specific kind of the statement is not; * reported.; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang-c/Index.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/Index.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/Index.h:20,Integrability,synchroniz,synchronized,20,/** Objective-C's \@synchronized statement.; */,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang-c/Index.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/Index.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/Index.h:4,Energy Efficiency,Adapt,Adaptor,4,/** Adaptor class for mixing declarations with statements and; * expressions.; */,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang-c/Index.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/Index.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/Index.h:4,Modifiability,Adapt,Adaptor,4,/** Adaptor class for mixing declarations with statements and; * expressions.; */,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang-c/Index.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/Index.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/Index.h:18,Deployability,update,update,18,/** OpenMP target update directive.; */,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang-c/Index.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/Index.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/Index.h:11,Availability,mask,masked,11,/** OpenMP masked directive.; */,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang-c/Index.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/Index.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/Index.h:20,Availability,mask,masked,20,/** OpenMP parallel masked directive.; */,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang-c/Index.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/Index.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/Index.h:11,Availability,mask,masked,11,/** OpenMP masked taskloop directive.; */,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang-c/Index.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/Index.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/Index.h:11,Availability,mask,masked,11,/** OpenMP masked taskloop simd directive.; */,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang-c/Index.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/Index.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/Index.h:20,Availability,mask,masked,20,/** OpenMP parallel masked taskloop directive.; */,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang-c/Index.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/Index.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/Index.h:20,Availability,mask,masked,20,/** OpenMP parallel masked taskloop simd directive.; */,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang-c/Index.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/Index.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/Index.h:11,Availability,error,error,11,/** OpenMP error directive.; */,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang-c/Index.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/Index.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/Index.h:67,Integrability,interface,interface,67,/**; * An attribute whose specific kind is not exposed via this; * interface.; */,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang-c/Index.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/Index.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/Index.h:47,Security,expose,exposed,47,/**; * An attribute whose specific kind is not exposed via this; * interface.; */,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang-c/Index.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/Index.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/Index.h:17,Security,hash,hash,17,/**; * Compute a hash value for the given cursor.; */,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang-c/Index.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/Index.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/Index.h:60,Usability,simpl,simple,60,/**; * Determine whether the given cursor kind represents a simple; * reference.; *; * Note that other kinds of cursors (such as expressions) can also refer to; * other cursors. Use clang_getCursorReferenced() to determine whether a; * particular cursor refers to another entity.; */,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang-c/Index.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/Index.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/Index.h:56,Availability,avail,available,56,/** This value indicates that no linkage information is available; * for a provided CXCursor. */,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang-c/Index.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/Index.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/Index.h:31,Modifiability,variab,variables,31,"/**; * This is the linkage for variables, parameters, and so on that; * have automatic storage. This covers normal (non-extern) local variables.; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang-c/Index.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/Index.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/Index.h:134,Modifiability,variab,variables,134,"/**; * This is the linkage for variables, parameters, and so on that; * have automatic storage. This covers normal (non-extern) local variables.; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang-c/Index.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/Index.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/Index.h:35,Modifiability,variab,variables,35,/** This is the linkage for static variables and static functions. */,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang-c/Index.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/Index.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/Index.h:59,Availability,avail,available,59,/** This value indicates that no visibility information is available; * for a provided CXCursor. */,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang-c/Index.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/Index.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/Index.h:21,Availability,avail,availability,21,"/**; * Determine the availability of the entity that this cursor refers to,; * taking the current target platform into account.; *; * \param cursor The cursor to query.; *; * \returns The availability of the cursor.; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang-c/Index.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/Index.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/Index.h:188,Availability,avail,availability,188,"/**; * Determine the availability of the entity that this cursor refers to,; * taking the current target platform into account.; *; * \param cursor The cursor to query.; *; * \returns The availability of the cursor.; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang-c/Index.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/Index.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/Index.h:21,Availability,avail,availability,21,"/**; * Describes the availability of a given entity on a particular platform, e.g.,; * a particular class might only be available on Mac OS 10.7 or newer.; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang-c/Index.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/Index.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/Index.h:120,Availability,avail,available,120,"/**; * Describes the availability of a given entity on a particular platform, e.g.,; * a particular class might only be available on Mac OS 10.7 or newer.; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang-c/Index.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/Index.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/Index.h:81,Availability,avail,availability,81,"/**; * A string that describes the platform for which this structure; * provides availability information.; *; * Possible values are ""ios"" or ""macos"".; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang-c/Index.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/Index.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/Index.h:79,Availability,avail,available,79,/**; * The version number in which this entity was deprecated (but is; * still available).; */,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang-c/Index.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/Index.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/Index.h:92,Availability,avail,available,92,"/**; * The version number in which this entity was obsoleted, and therefore; * is no longer available.; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang-c/Index.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/Index.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/Index.h:19,Integrability,message,message,19,"/**; * An optional message to provide to a user of this API, e.g., to; * suggest replacement APIs.; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang-c/Index.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/Index.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/Index.h:21,Availability,avail,availability,21,"/**; * Determine the availability of the entity that this cursor refers to; * on any platforms for which availability information is known.; *; * \param cursor The cursor to query.; *; * \param always_deprecated If non-NULL, will be set to indicate whether the; * entity is deprecated on all platforms.; *; * \param deprecated_message If non-NULL, will be set to the message text; * provided along with the unconditional deprecation of this entity. The client; * is responsible for deallocating this string.; *; * \param always_unavailable If non-NULL, will be set to indicate whether the; * entity is unavailable on all platforms.; *; * \param unavailable_message If non-NULL, will be set to the message text; * provided along with the unconditional unavailability of this entity. The; * client is responsible for deallocating this string.; *; * \param availability If non-NULL, an array of CXPlatformAvailability instances; * that will be populated with platform availability information, up to either; * the number of platforms for which availability information is available (as; * returned by this function) or \c availability_size, whichever is smaller.; *; * \param availability_size The number of elements available in the; * \c availability array.; *; * \returns The number of platforms (N) for which availability information is; * available (which is unrelated to \c availability_size).; *; * Note that the client is responsible for calling; * \c clang_disposeCXPlatformAvailability to free each of the; * platform-availability structures returned. There are; * \c min(N, availability_size) such structures.; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang-c/Index.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/Index.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/Index.h:105,Availability,avail,availability,105,"/**; * Determine the availability of the entity that this cursor refers to; * on any platforms for which availability information is known.; *; * \param cursor The cursor to query.; *; * \param always_deprecated If non-NULL, will be set to indicate whether the; * entity is deprecated on all platforms.; *; * \param deprecated_message If non-NULL, will be set to the message text; * provided along with the unconditional deprecation of this entity. The client; * is responsible for deallocating this string.; *; * \param always_unavailable If non-NULL, will be set to indicate whether the; * entity is unavailable on all platforms.; *; * \param unavailable_message If non-NULL, will be set to the message text; * provided along with the unconditional unavailability of this entity. The; * client is responsible for deallocating this string.; *; * \param availability If non-NULL, an array of CXPlatformAvailability instances; * that will be populated with platform availability information, up to either; * the number of platforms for which availability information is available (as; * returned by this function) or \c availability_size, whichever is smaller.; *; * \param availability_size The number of elements available in the; * \c availability array.; *; * \returns The number of platforms (N) for which availability information is; * available (which is unrelated to \c availability_size).; *; * Note that the client is responsible for calling; * \c clang_disposeCXPlatformAvailability to free each of the; * platform-availability structures returned. There are; * \c min(N, availability_size) such structures.; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang-c/Index.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/Index.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/Index.h:854,Availability,avail,availability,854,"/**; * Determine the availability of the entity that this cursor refers to; * on any platforms for which availability information is known.; *; * \param cursor The cursor to query.; *; * \param always_deprecated If non-NULL, will be set to indicate whether the; * entity is deprecated on all platforms.; *; * \param deprecated_message If non-NULL, will be set to the message text; * provided along with the unconditional deprecation of this entity. The client; * is responsible for deallocating this string.; *; * \param always_unavailable If non-NULL, will be set to indicate whether the; * entity is unavailable on all platforms.; *; * \param unavailable_message If non-NULL, will be set to the message text; * provided along with the unconditional unavailability of this entity. The; * client is responsible for deallocating this string.; *; * \param availability If non-NULL, an array of CXPlatformAvailability instances; * that will be populated with platform availability information, up to either; * the number of platforms for which availability information is available (as; * returned by this function) or \c availability_size, whichever is smaller.; *; * \param availability_size The number of elements available in the; * \c availability array.; *; * \returns The number of platforms (N) for which availability information is; * available (which is unrelated to \c availability_size).; *; * Note that the client is responsible for calling; * \c clang_disposeCXPlatformAvailability to free each of the; * platform-availability structures returned. There are; * \c min(N, availability_size) such structures.; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang-c/Index.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/Index.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/Index.h:965,Availability,avail,availability,965,"/**; * Determine the availability of the entity that this cursor refers to; * on any platforms for which availability information is known.; *; * \param cursor The cursor to query.; *; * \param always_deprecated If non-NULL, will be set to indicate whether the; * entity is deprecated on all platforms.; *; * \param deprecated_message If non-NULL, will be set to the message text; * provided along with the unconditional deprecation of this entity. The client; * is responsible for deallocating this string.; *; * \param always_unavailable If non-NULL, will be set to indicate whether the; * entity is unavailable on all platforms.; *; * \param unavailable_message If non-NULL, will be set to the message text; * provided along with the unconditional unavailability of this entity. The; * client is responsible for deallocating this string.; *; * \param availability If non-NULL, an array of CXPlatformAvailability instances; * that will be populated with platform availability information, up to either; * the number of platforms for which availability information is available (as; * returned by this function) or \c availability_size, whichever is smaller.; *; * \param availability_size The number of elements available in the; * \c availability array.; *; * \returns The number of platforms (N) for which availability information is; * available (which is unrelated to \c availability_size).; *; * Note that the client is responsible for calling; * \c clang_disposeCXPlatformAvailability to free each of the; * platform-availability structures returned. There are; * \c min(N, availability_size) such structures.; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang-c/Index.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/Index.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/Index.h:1041,Availability,avail,availability,1041,"/**; * Determine the availability of the entity that this cursor refers to; * on any platforms for which availability information is known.; *; * \param cursor The cursor to query.; *; * \param always_deprecated If non-NULL, will be set to indicate whether the; * entity is deprecated on all platforms.; *; * \param deprecated_message If non-NULL, will be set to the message text; * provided along with the unconditional deprecation of this entity. The client; * is responsible for deallocating this string.; *; * \param always_unavailable If non-NULL, will be set to indicate whether the; * entity is unavailable on all platforms.; *; * \param unavailable_message If non-NULL, will be set to the message text; * provided along with the unconditional unavailability of this entity. The; * client is responsible for deallocating this string.; *; * \param availability If non-NULL, an array of CXPlatformAvailability instances; * that will be populated with platform availability information, up to either; * the number of platforms for which availability information is available (as; * returned by this function) or \c availability_size, whichever is smaller.; *; * \param availability_size The number of elements available in the; * \c availability array.; *; * \returns The number of platforms (N) for which availability information is; * available (which is unrelated to \c availability_size).; *; * Note that the client is responsible for calling; * \c clang_disposeCXPlatformAvailability to free each of the; * platform-availability structures returned. There are; * \c min(N, availability_size) such structures.; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang-c/Index.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/Index.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/Index.h:1069,Availability,avail,available,1069,"/**; * Determine the availability of the entity that this cursor refers to; * on any platforms for which availability information is known.; *; * \param cursor The cursor to query.; *; * \param always_deprecated If non-NULL, will be set to indicate whether the; * entity is deprecated on all platforms.; *; * \param deprecated_message If non-NULL, will be set to the message text; * provided along with the unconditional deprecation of this entity. The client; * is responsible for deallocating this string.; *; * \param always_unavailable If non-NULL, will be set to indicate whether the; * entity is unavailable on all platforms.; *; * \param unavailable_message If non-NULL, will be set to the message text; * provided along with the unconditional unavailability of this entity. The; * client is responsible for deallocating this string.; *; * \param availability If non-NULL, an array of CXPlatformAvailability instances; * that will be populated with platform availability information, up to either; * the number of platforms for which availability information is available (as; * returned by this function) or \c availability_size, whichever is smaller.; *; * \param availability_size The number of elements available in the; * \c availability array.; *; * \returns The number of platforms (N) for which availability information is; * available (which is unrelated to \c availability_size).; *; * Note that the client is responsible for calling; * \c clang_disposeCXPlatformAvailability to free each of the; * platform-availability structures returned. There are; * \c min(N, availability_size) such structures.; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang-c/Index.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/Index.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/Index.h:1214,Availability,avail,available,1214,"/**; * Determine the availability of the entity that this cursor refers to; * on any platforms for which availability information is known.; *; * \param cursor The cursor to query.; *; * \param always_deprecated If non-NULL, will be set to indicate whether the; * entity is deprecated on all platforms.; *; * \param deprecated_message If non-NULL, will be set to the message text; * provided along with the unconditional deprecation of this entity. The client; * is responsible for deallocating this string.; *; * \param always_unavailable If non-NULL, will be set to indicate whether the; * entity is unavailable on all platforms.; *; * \param unavailable_message If non-NULL, will be set to the message text; * provided along with the unconditional unavailability of this entity. The; * client is responsible for deallocating this string.; *; * \param availability If non-NULL, an array of CXPlatformAvailability instances; * that will be populated with platform availability information, up to either; * the number of platforms for which availability information is available (as; * returned by this function) or \c availability_size, whichever is smaller.; *; * \param availability_size The number of elements available in the; * \c availability array.; *; * \returns The number of platforms (N) for which availability information is; * available (which is unrelated to \c availability_size).; *; * Note that the client is responsible for calling; * \c clang_disposeCXPlatformAvailability to free each of the; * platform-availability structures returned. There are; * \c min(N, availability_size) such structures.; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang-c/Index.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/Index.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/Index.h:1237,Availability,avail,availability,1237,"/**; * Determine the availability of the entity that this cursor refers to; * on any platforms for which availability information is known.; *; * \param cursor The cursor to query.; *; * \param always_deprecated If non-NULL, will be set to indicate whether the; * entity is deprecated on all platforms.; *; * \param deprecated_message If non-NULL, will be set to the message text; * provided along with the unconditional deprecation of this entity. The client; * is responsible for deallocating this string.; *; * \param always_unavailable If non-NULL, will be set to indicate whether the; * entity is unavailable on all platforms.; *; * \param unavailable_message If non-NULL, will be set to the message text; * provided along with the unconditional unavailability of this entity. The; * client is responsible for deallocating this string.; *; * \param availability If non-NULL, an array of CXPlatformAvailability instances; * that will be populated with platform availability information, up to either; * the number of platforms for which availability information is available (as; * returned by this function) or \c availability_size, whichever is smaller.; *; * \param availability_size The number of elements available in the; * \c availability array.; *; * \returns The number of platforms (N) for which availability information is; * available (which is unrelated to \c availability_size).; *; * Note that the client is responsible for calling; * \c clang_disposeCXPlatformAvailability to free each of the; * platform-availability structures returned. There are; * \c min(N, availability_size) such structures.; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang-c/Index.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/Index.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/Index.h:1310,Availability,avail,availability,1310,"/**; * Determine the availability of the entity that this cursor refers to; * on any platforms for which availability information is known.; *; * \param cursor The cursor to query.; *; * \param always_deprecated If non-NULL, will be set to indicate whether the; * entity is deprecated on all platforms.; *; * \param deprecated_message If non-NULL, will be set to the message text; * provided along with the unconditional deprecation of this entity. The client; * is responsible for deallocating this string.; *; * \param always_unavailable If non-NULL, will be set to indicate whether the; * entity is unavailable on all platforms.; *; * \param unavailable_message If non-NULL, will be set to the message text; * provided along with the unconditional unavailability of this entity. The; * client is responsible for deallocating this string.; *; * \param availability If non-NULL, an array of CXPlatformAvailability instances; * that will be populated with platform availability information, up to either; * the number of platforms for which availability information is available (as; * returned by this function) or \c availability_size, whichever is smaller.; *; * \param availability_size The number of elements available in the; * \c availability array.; *; * \returns The number of platforms (N) for which availability information is; * available (which is unrelated to \c availability_size).; *; * Note that the client is responsible for calling; * \c clang_disposeCXPlatformAvailability to free each of the; * platform-availability structures returned. There are; * \c min(N, availability_size) such structures.; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang-c/Index.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/Index.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/Index.h:1341,Availability,avail,available,1341,"/**; * Determine the availability of the entity that this cursor refers to; * on any platforms for which availability information is known.; *; * \param cursor The cursor to query.; *; * \param always_deprecated If non-NULL, will be set to indicate whether the; * entity is deprecated on all platforms.; *; * \param deprecated_message If non-NULL, will be set to the message text; * provided along with the unconditional deprecation of this entity. The client; * is responsible for deallocating this string.; *; * \param always_unavailable If non-NULL, will be set to indicate whether the; * entity is unavailable on all platforms.; *; * \param unavailable_message If non-NULL, will be set to the message text; * provided along with the unconditional unavailability of this entity. The; * client is responsible for deallocating this string.; *; * \param availability If non-NULL, an array of CXPlatformAvailability instances; * that will be populated with platform availability information, up to either; * the number of platforms for which availability information is available (as; * returned by this function) or \c availability_size, whichever is smaller.; *; * \param availability_size The number of elements available in the; * \c availability array.; *; * \returns The number of platforms (N) for which availability information is; * available (which is unrelated to \c availability_size).; *; * Note that the client is responsible for calling; * \c clang_disposeCXPlatformAvailability to free each of the; * platform-availability structures returned. There are; * \c min(N, availability_size) such structures.; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang-c/Index.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/Index.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/Index.h:1525,Availability,avail,availability,1525,"/**; * Determine the availability of the entity that this cursor refers to; * on any platforms for which availability information is known.; *; * \param cursor The cursor to query.; *; * \param always_deprecated If non-NULL, will be set to indicate whether the; * entity is deprecated on all platforms.; *; * \param deprecated_message If non-NULL, will be set to the message text; * provided along with the unconditional deprecation of this entity. The client; * is responsible for deallocating this string.; *; * \param always_unavailable If non-NULL, will be set to indicate whether the; * entity is unavailable on all platforms.; *; * \param unavailable_message If non-NULL, will be set to the message text; * provided along with the unconditional unavailability of this entity. The; * client is responsible for deallocating this string.; *; * \param availability If non-NULL, an array of CXPlatformAvailability instances; * that will be populated with platform availability information, up to either; * the number of platforms for which availability information is available (as; * returned by this function) or \c availability_size, whichever is smaller.; *; * \param availability_size The number of elements available in the; * \c availability array.; *; * \returns The number of platforms (N) for which availability information is; * available (which is unrelated to \c availability_size).; *; * Note that the client is responsible for calling; * \c clang_disposeCXPlatformAvailability to free each of the; * platform-availability structures returned. There are; * \c min(N, availability_size) such structures.; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang-c/Index.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/Index.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/Index.h:367,Integrability,message,message,367,"/**; * Determine the availability of the entity that this cursor refers to; * on any platforms for which availability information is known.; *; * \param cursor The cursor to query.; *; * \param always_deprecated If non-NULL, will be set to indicate whether the; * entity is deprecated on all platforms.; *; * \param deprecated_message If non-NULL, will be set to the message text; * provided along with the unconditional deprecation of this entity. The client; * is responsible for deallocating this string.; *; * \param always_unavailable If non-NULL, will be set to indicate whether the; * entity is unavailable on all platforms.; *; * \param unavailable_message If non-NULL, will be set to the message text; * provided along with the unconditional unavailability of this entity. The; * client is responsible for deallocating this string.; *; * \param availability If non-NULL, an array of CXPlatformAvailability instances; * that will be populated with platform availability information, up to either; * the number of platforms for which availability information is available (as; * returned by this function) or \c availability_size, whichever is smaller.; *; * \param availability_size The number of elements available in the; * \c availability array.; *; * \returns The number of platforms (N) for which availability information is; * available (which is unrelated to \c availability_size).; *; * Note that the client is responsible for calling; * \c clang_disposeCXPlatformAvailability to free each of the; * platform-availability structures returned. There are; * \c min(N, availability_size) such structures.; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang-c/Index.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/Index.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/Index.h:697,Integrability,message,message,697,"/**; * Determine the availability of the entity that this cursor refers to; * on any platforms for which availability information is known.; *; * \param cursor The cursor to query.; *; * \param always_deprecated If non-NULL, will be set to indicate whether the; * entity is deprecated on all platforms.; *; * \param deprecated_message If non-NULL, will be set to the message text; * provided along with the unconditional deprecation of this entity. The client; * is responsible for deallocating this string.; *; * \param always_unavailable If non-NULL, will be set to indicate whether the; * entity is unavailable on all platforms.; *; * \param unavailable_message If non-NULL, will be set to the message text; * provided along with the unconditional unavailability of this entity. The; * client is responsible for deallocating this string.; *; * \param availability If non-NULL, an array of CXPlatformAvailability instances; * that will be populated with platform availability information, up to either; * the number of platforms for which availability information is available (as; * returned by this function) or \c availability_size, whichever is smaller.; *; * \param availability_size The number of elements available in the; * \c availability array.; *; * \returns The number of platforms (N) for which availability information is; * available (which is unrelated to \c availability_size).; *; * Note that the client is responsible for calling; * \c clang_disposeCXPlatformAvailability to free each of the; * platform-availability structures returned. There are; * \c min(N, availability_size) such structures.; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang-c/Index.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/Index.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/Index.h:29,Modifiability,variab,variable,29,/**; * If cursor refers to a variable declaration and it has initializer returns; * cursor referring to the initializer otherwise return null cursor.; */,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang-c/Index.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/Index.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/Index.h:29,Modifiability,variab,variable,29,/**; * If cursor refers to a variable declaration that has global storage returns 1.; * If cursor refers to a variable declaration that doesn't have global storage; * returns 0. Otherwise returns -1.; */,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang-c/Index.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/Index.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/Index.h:110,Modifiability,variab,variable,110,/**; * If cursor refers to a variable declaration that has global storage returns 1.; * If cursor refers to a variable declaration that doesn't have global storage; * returns 0. Otherwise returns -1.; */,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang-c/Index.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/Index.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/Index.h:29,Modifiability,variab,variable,29,/**; * If cursor refers to a variable declaration that has external storage; * returns 1. If cursor refers to a variable declaration that doesn't have; * external storage returns 0. Otherwise returns -1.; */,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang-c/Index.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/Index.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/Index.h:112,Modifiability,variab,variable,112,/**; * If cursor refers to a variable declaration that has external storage; * returns 1. If cursor refers to a variable declaration that doesn't have; * external storage returns 0. Otherwise returns -1.; */,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang-c/Index.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/Index.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/Index.h:34,Deployability,release,releases,34,/**; * Disposes a CXCursorSet and releases its associated memory.; */,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang-c/Index.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/Index.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/Index.h:306,Integrability,protocol,protocols,306,"/**; * Determine the set of methods that are overridden by the given; * method.; *; * In both Objective-C and C++, a method (aka virtual member function,; * in C++) can override a virtual method in a base class. For; * Objective-C, a method is said to override any method in the class's; * base class, its protocols, or its categories' protocols, that has the same; * selector and is of the same kind (class or instance).; * If no such method exists, the search continues to the class's superclass,; * its protocols, and its categories, and so on. A method from an Objective-C; * implementation is considered to override the same methods as its; * corresponding method in the interface.; *; * For C++, a virtual member function overrides any virtual member; * function with the same signature that occurs in its base; * classes. With multiple inheritance, a virtual member function can; * override several virtual member functions coming from different; * base classes.; *; * In all cases, this function determines the immediate overridden; * method, rather than all of the overridden methods. For example, if; * a method is originally declared in a class A, then overridden in B; * (which in inherits from A) and also in C (which inherited from B),; * then the only overridden method returned from this function when; * invoked on C's method will be B's method. The client may then; * invoke this function again, given the previously-found overridden; * methods, to map out the complete method-override set.; *; * \param cursor A cursor representing an Objective-C or C++; * method. This routine will compute the set of methods that this; * method overrides.; *; * \param overridden A pointer whose pointee will be replaced with a; * pointer to an array of cursors, representing the set of overridden; * methods. If there are no overridden methods, the pointee will be; * set to NULL. The pointee must be freed via a call to; * \c clang_disposeOverriddenCursors().; *; * \param num_overridden A point",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang-c/Index.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/Index.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/Index.h:336,Integrability,protocol,protocols,336,"/**; * Determine the set of methods that are overridden by the given; * method.; *; * In both Objective-C and C++, a method (aka virtual member function,; * in C++) can override a virtual method in a base class. For; * Objective-C, a method is said to override any method in the class's; * base class, its protocols, or its categories' protocols, that has the same; * selector and is of the same kind (class or instance).; * If no such method exists, the search continues to the class's superclass,; * its protocols, and its categories, and so on. A method from an Objective-C; * implementation is considered to override the same methods as its; * corresponding method in the interface.; *; * For C++, a virtual member function overrides any virtual member; * function with the same signature that occurs in its base; * classes. With multiple inheritance, a virtual member function can; * override several virtual member functions coming from different; * base classes.; *; * In all cases, this function determines the immediate overridden; * method, rather than all of the overridden methods. For example, if; * a method is originally declared in a class A, then overridden in B; * (which in inherits from A) and also in C (which inherited from B),; * then the only overridden method returned from this function when; * invoked on C's method will be B's method. The client may then; * invoke this function again, given the previously-found overridden; * methods, to map out the complete method-override set.; *; * \param cursor A cursor representing an Objective-C or C++; * method. This routine will compute the set of methods that this; * method overrides.; *; * \param overridden A pointer whose pointee will be replaced with a; * pointer to an array of cursors, representing the set of overridden; * methods. If there are no overridden methods, the pointee will be; * set to NULL. The pointee must be freed via a call to; * \c clang_disposeOverriddenCursors().; *; * \param num_overridden A point",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang-c/Index.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/Index.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/Index.h:506,Integrability,protocol,protocols,506,"/**; * Determine the set of methods that are overridden by the given; * method.; *; * In both Objective-C and C++, a method (aka virtual member function,; * in C++) can override a virtual method in a base class. For; * Objective-C, a method is said to override any method in the class's; * base class, its protocols, or its categories' protocols, that has the same; * selector and is of the same kind (class or instance).; * If no such method exists, the search continues to the class's superclass,; * its protocols, and its categories, and so on. A method from an Objective-C; * implementation is considered to override the same methods as its; * corresponding method in the interface.; *; * For C++, a virtual member function overrides any virtual member; * function with the same signature that occurs in its base; * classes. With multiple inheritance, a virtual member function can; * override several virtual member functions coming from different; * base classes.; *; * In all cases, this function determines the immediate overridden; * method, rather than all of the overridden methods. For example, if; * a method is originally declared in a class A, then overridden in B; * (which in inherits from A) and also in C (which inherited from B),; * then the only overridden method returned from this function when; * invoked on C's method will be B's method. The client may then; * invoke this function again, given the previously-found overridden; * methods, to map out the complete method-override set.; *; * \param cursor A cursor representing an Objective-C or C++; * method. This routine will compute the set of methods that this; * method overrides.; *; * \param overridden A pointer whose pointee will be replaced with a; * pointer to an array of cursors, representing the set of overridden; * methods. If there are no overridden methods, the pointee will be; * set to NULL. The pointee must be freed via a call to; * \c clang_disposeOverriddenCursors().; *; * \param num_overridden A point",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang-c/Index.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/Index.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/Index.h:676,Integrability,interface,interface,676,"/**; * Determine the set of methods that are overridden by the given; * method.; *; * In both Objective-C and C++, a method (aka virtual member function,; * in C++) can override a virtual method in a base class. For; * Objective-C, a method is said to override any method in the class's; * base class, its protocols, or its categories' protocols, that has the same; * selector and is of the same kind (class or instance).; * If no such method exists, the search continues to the class's superclass,; * its protocols, and its categories, and so on. A method from an Objective-C; * implementation is considered to override the same methods as its; * corresponding method in the interface.; *; * For C++, a virtual member function overrides any virtual member; * function with the same signature that occurs in its base; * classes. With multiple inheritance, a virtual member function can; * override several virtual member functions coming from different; * base classes.; *; * In all cases, this function determines the immediate overridden; * method, rather than all of the overridden methods. For example, if; * a method is originally declared in a class A, then overridden in B; * (which in inherits from A) and also in C (which inherited from B),; * then the only overridden method returned from this function when; * invoked on C's method will be B's method. The client may then; * invoke this function again, given the previously-found overridden; * methods, to map out the complete method-override set.; *; * \param cursor A cursor representing an Objective-C or C++; * method. This routine will compute the set of methods that this; * method overrides.; *; * \param overridden A pointer whose pointee will be replaced with a; * pointer to an array of cursors, representing the set of overridden; * methods. If there are no overridden methods, the pointee will be; * set to NULL. The pointee must be freed via a call to; * \c clang_disposeOverriddenCursors().; *; * \param num_overridden A point",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang-c/Index.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/Index.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/Index.h:1589,Integrability,rout,routine,1589,"function,; * in C++) can override a virtual method in a base class. For; * Objective-C, a method is said to override any method in the class's; * base class, its protocols, or its categories' protocols, that has the same; * selector and is of the same kind (class or instance).; * If no such method exists, the search continues to the class's superclass,; * its protocols, and its categories, and so on. A method from an Objective-C; * implementation is considered to override the same methods as its; * corresponding method in the interface.; *; * For C++, a virtual member function overrides any virtual member; * function with the same signature that occurs in its base; * classes. With multiple inheritance, a virtual member function can; * override several virtual member functions coming from different; * base classes.; *; * In all cases, this function determines the immediate overridden; * method, rather than all of the overridden methods. For example, if; * a method is originally declared in a class A, then overridden in B; * (which in inherits from A) and also in C (which inherited from B),; * then the only overridden method returned from this function when; * invoked on C's method will be B's method. The client may then; * invoke this function again, given the previously-found overridden; * methods, to map out the complete method-override set.; *; * \param cursor A cursor representing an Objective-C or C++; * method. This routine will compute the set of methods that this; * method overrides.; *; * \param overridden A pointer whose pointee will be replaced with a; * pointer to an array of cursors, representing the set of overridden; * methods. If there are no overridden methods, the pointee will be; * set to NULL. The pointee must be freed via a call to; * \c clang_disposeOverriddenCursors().; *; * \param num_overridden A pointer to the number of overridden; * functions, will be set to the number of overridden functions in the; * array pointed to by \p overridden.; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang-c/Index.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/Index.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/Index.h:843,Modifiability,inherit,inheritance,843,"/**; * Determine the set of methods that are overridden by the given; * method.; *; * In both Objective-C and C++, a method (aka virtual member function,; * in C++) can override a virtual method in a base class. For; * Objective-C, a method is said to override any method in the class's; * base class, its protocols, or its categories' protocols, that has the same; * selector and is of the same kind (class or instance).; * If no such method exists, the search continues to the class's superclass,; * its protocols, and its categories, and so on. A method from an Objective-C; * implementation is considered to override the same methods as its; * corresponding method in the interface.; *; * For C++, a virtual member function overrides any virtual member; * function with the same signature that occurs in its base; * classes. With multiple inheritance, a virtual member function can; * override several virtual member functions coming from different; * base classes.; *; * In all cases, this function determines the immediate overridden; * method, rather than all of the overridden methods. For example, if; * a method is originally declared in a class A, then overridden in B; * (which in inherits from A) and also in C (which inherited from B),; * then the only overridden method returned from this function when; * invoked on C's method will be B's method. The client may then; * invoke this function again, given the previously-found overridden; * methods, to map out the complete method-override set.; *; * \param cursor A cursor representing an Objective-C or C++; * method. This routine will compute the set of methods that this; * method overrides.; *; * \param overridden A pointer whose pointee will be replaced with a; * pointer to an array of cursors, representing the set of overridden; * methods. If there are no overridden methods, the pointee will be; * set to NULL. The pointee must be freed via a call to; * \c clang_disposeOverriddenCursors().; *; * \param num_overridden A point",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang-c/Index.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/Index.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/Index.h:1193,Modifiability,inherit,inherits,1193,"function,; * in C++) can override a virtual method in a base class. For; * Objective-C, a method is said to override any method in the class's; * base class, its protocols, or its categories' protocols, that has the same; * selector and is of the same kind (class or instance).; * If no such method exists, the search continues to the class's superclass,; * its protocols, and its categories, and so on. A method from an Objective-C; * implementation is considered to override the same methods as its; * corresponding method in the interface.; *; * For C++, a virtual member function overrides any virtual member; * function with the same signature that occurs in its base; * classes. With multiple inheritance, a virtual member function can; * override several virtual member functions coming from different; * base classes.; *; * In all cases, this function determines the immediate overridden; * method, rather than all of the overridden methods. For example, if; * a method is originally declared in a class A, then overridden in B; * (which in inherits from A) and also in C (which inherited from B),; * then the only overridden method returned from this function when; * invoked on C's method will be B's method. The client may then; * invoke this function again, given the previously-found overridden; * methods, to map out the complete method-override set.; *; * \param cursor A cursor representing an Objective-C or C++; * method. This routine will compute the set of methods that this; * method overrides.; *; * \param overridden A pointer whose pointee will be replaced with a; * pointer to an array of cursors, representing the set of overridden; * methods. If there are no overridden methods, the pointee will be; * set to NULL. The pointee must be freed via a call to; * \c clang_disposeOverriddenCursors().; *; * \param num_overridden A pointer to the number of overridden; * functions, will be set to the number of overridden functions in the; * array pointed to by \p overridden.; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang-c/Index.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/Index.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/Index.h:1231,Modifiability,inherit,inherited,1231,"function,; * in C++) can override a virtual method in a base class. For; * Objective-C, a method is said to override any method in the class's; * base class, its protocols, or its categories' protocols, that has the same; * selector and is of the same kind (class or instance).; * If no such method exists, the search continues to the class's superclass,; * its protocols, and its categories, and so on. A method from an Objective-C; * implementation is considered to override the same methods as its; * corresponding method in the interface.; *; * For C++, a virtual member function overrides any virtual member; * function with the same signature that occurs in its base; * classes. With multiple inheritance, a virtual member function can; * override several virtual member functions coming from different; * base classes.; *; * In all cases, this function determines the immediate overridden; * method, rather than all of the overridden methods. For example, if; * a method is originally declared in a class A, then overridden in B; * (which in inherits from A) and also in C (which inherited from B),; * then the only overridden method returned from this function when; * invoked on C's method will be B's method. The client may then; * invoke this function again, given the previously-found overridden; * methods, to map out the complete method-override set.; *; * \param cursor A cursor representing an Objective-C or C++; * method. This routine will compute the set of methods that this; * method overrides.; *; * \param overridden A pointer whose pointee will be replaced with a; * pointer to an array of cursors, representing the set of overridden; * methods. If there are no overridden methods, the pointee will be; * set to NULL. The pointee must be freed via a call to; * \c clang_disposeOverriddenCursors().; *; * \param num_overridden A pointer to the number of overridden; * functions, will be set to the number of overridden functions in the; * array pointed to by \p overridden.; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang-c/Index.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/Index.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/Index.h:605,Availability,down,down,605,"/**; * @}; */; /**; * \defgroup CINDEX_CURSOR_SOURCE Mapping between cursors and source code; *; * Cursors represent a location within the Abstract Syntax Tree (AST). These; * routines help map between cursors and the physical locations where the; * described entities occur in the source code. The mapping is provided in; * both directions, so one can map from source code to the AST and back.; *; * @{; */; /**; * Map a source location to the cursor that describes the entity at that; * location in the source code.; *; * clang_getCursor() maps an arbitrary source location within a translation; * unit down to the most specific cursor that describes the entity at that; * location. For example, given an expression \c x + y, invoking; * clang_getCursor() with a source location pointing to ""x"" will return the; * cursor for ""x""; similarly for ""y"". If the cursor points anywhere between; * ""x"" or ""y"" (e.g., on the + or the whitespace around it), clang_getCursor(); * will return a cursor referring to the ""+"" expression.; *; * \returns a cursor representing the entity at the given source location, or; * a NULL cursor if no such entity can be found.; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang-c/Index.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/Index.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/Index.h:176,Integrability,rout,routines,176,"/**; * @}; */; /**; * \defgroup CINDEX_CURSOR_SOURCE Mapping between cursors and source code; *; * Cursors represent a location within the Abstract Syntax Tree (AST). These; * routines help map between cursors and the physical locations where the; * described entities occur in the source code. The mapping is provided in; * both directions, so one can map from source code to the AST and back.; *; * @{; */; /**; * Map a source location to the cursor that describes the entity at that; * location in the source code.; *; * clang_getCursor() maps an arbitrary source location within a translation; * unit down to the most specific cursor that describes the entity at that; * location. For example, given an expression \c x + y, invoking; * clang_getCursor() with a source location pointing to ""x"" will return the; * cursor for ""x""; similarly for ""y"". If the cursor points anywhere between; * ""x"" or ""y"" (e.g., on the + or the whitespace around it), clang_getCursor(); * will return a cursor referring to the ""+"" expression.; *; * \returns a cursor representing the entity at the given source location, or; * a NULL cursor if no such entity can be found.; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang-c/Index.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/Index.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/Index.h:58,Availability,avail,available,58,"/**; * Represents an invalid type (e.g., where no type is available).; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang-c/Index.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/Index.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/Index.h:61,Integrability,interface,interface,61,/**; * A type whose specific kind is not exposed via this; * interface.; */,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang-c/Index.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/Index.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/Index.h:41,Security,expose,exposed,41,/**; * A type whose specific kind is not exposed via this; * interface.; */,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang-c/Index.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/Index.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/Index.h:385,Integrability,depend,dependent,385,"/**; * Retrieve the bit width of a bit-field declaration as an integer.; *; * If the cursor does not reference a bit-field, or if the bit-field's width; * expression cannot be evaluated, -1 is returned.; *; * For example:; * \code; * if (clang_Cursor_isBitField(Cursor)) {; * int Width = clang_getFieldDeclBitWidth(Cursor);; * if (Width != -1) {; * // The bit-field width is not value-dependent.; * }; * }; * \endcode; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang-c/Index.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/Index.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/Index.h:16,Availability,error,error,16,"/* Indicates an error case, preventing the kind from being deduced. */",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang-c/Index.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/Index.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/Index.h:192,Availability,error,error,192,"/**; * Retrieve the exception specification type associated with a function type.; * This is a value of type CXCursor_ExceptionSpecificationKind.; *; * If a non-function type is passed in, an error code of -1 is returned.; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang-c/Index.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/Index.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/Index.h:30,Integrability,protocol,protocol,30,"/**; * Retrieve the number of protocol references associated with an ObjC object/id.; *; * If the type is not an ObjC object, 0 is returned.; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang-c/Index.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/Index.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/Index.h:31,Integrability,protocol,protocol,31,"/**; * Retrieve the decl for a protocol reference for an ObjC object/id.; *; * If the type is not an ObjC object or there are not enough protocol; * references, an invalid cursor is returned.; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang-c/Index.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/Index.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/Index.h:137,Integrability,protocol,protocol,137,"/**; * Retrieve the decl for a protocol reference for an ObjC object/id.; *; * If the type is not an ObjC object or there are not enough protocol; * references, an invalid cursor is returned.; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang-c/Index.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/Index.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/Index.h:197,Availability,error,error,197,"/**; * Generally behaves like Nullable, except when used in a block parameter that; * was imported into a swift async method. There, swift will assume that the; * parameter can get null even if no error occurred. _Nullable parameters are; * assumed to only get null on error.; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang-c/Index.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/Index.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/Index.h:269,Availability,error,error,269,"/**; * Generally behaves like Nullable, except when used in a block parameter that; * was imported into a swift async method. There, swift will assume that the; * parameter can get null even if no error occurred. _Nullable parameters are; * assumed to only get null on error.; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang-c/Index.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/Index.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/Index.h:25,Availability,error,error,25,"/**; * List the possible error codes for \c clang_Type_getSizeOf,; * \c clang_Type_getAlignOf, \c clang_Type_getOffsetOf and; * \c clang_Cursor_getOffsetOf.; *; * A value of this enumeration type can be returned if the target type is not; * a valid argument to sizeof, alignof or offsetof.; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang-c/Index.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/Index.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/Index.h:21,Integrability,depend,dependent,21,/**; * The type is a dependent Type.; */,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang-c/Index.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/Index.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/Index.h:293,Integrability,depend,dependent,293,"/**; * Return the alignment of a type in bytes as per C++[expr.alignof]; * standard.; *; * If the type declaration is invalid, CXTypeLayoutError_Invalid is returned.; * If the type declaration is an incomplete type, CXTypeLayoutError_Incomplete; * is returned.; * If the type declaration is a dependent type, CXTypeLayoutError_Dependent is; * returned.; * If the type declaration is not a constant size type,; * CXTypeLayoutError_NotConstantSize is returned.; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang-c/Index.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/Index.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/Index.h:284,Integrability,depend,dependent,284,"/**; * Return the size of a type in bytes as per C++[expr.sizeof] standard.; *; * If the type declaration is invalid, CXTypeLayoutError_Invalid is returned.; * If the type declaration is an incomplete type, CXTypeLayoutError_Incomplete; * is returned.; * If the type declaration is a dependent type, CXTypeLayoutError_Dependent is; * returned.; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang-c/Index.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/Index.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/Index.h:378,Integrability,depend,dependent,378,"/**; * Return the offset of a field named S in a record of type T in bits; * as it would be returned by __offsetof__ as per C++11[18.2p4]; *; * If the cursor is not a record field declaration, CXTypeLayoutError_Invalid; * is returned.; * If the field's type declaration is an incomplete type,; * CXTypeLayoutError_Incomplete is returned.; * If the field's type declaration is a dependent type,; * CXTypeLayoutError_Dependent is returned.; * If the field's name S is not found,; * CXTypeLayoutError_InvalidFieldName is returned.; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang-c/Index.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/Index.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/Index.h:382,Integrability,depend,dependent,382,"/**; * Return the offset of the field represented by the Cursor.; *; * If the cursor is not a field declaration, -1 is returned.; * If the cursor semantic parent is not a record field declaration,; * CXTypeLayoutError_Invalid is returned.; * If the field's type declaration is an incomplete type,; * CXTypeLayoutError_Incomplete is returned.; * If the field's type declaration is a dependent type,; * CXTypeLayoutError_Dependent is returned.; * If the field's name S is not found,; * CXTypeLayoutError_InvalidFieldName is returned.; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang-c/Index.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/Index.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/Index.h:26,Security,access,access,26,/**; * Represents the C++ access control level to a base class for a; * cursor with kind CX_CXXBaseSpecifier.; */,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang-c/Index.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/Index.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/Index.h:19,Security,access,access,19,"/**; * Returns the access control level for the referenced object.; *; * If the cursor refers to a C++ declaration, its access control level within; * its parent scope is returned. Otherwise, if the cursor refers to a base; * specifier or access specifier, the specifier itself is returned.; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang-c/Index.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/Index.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/Index.h:120,Security,access,access,120,"/**; * Returns the access control level for the referenced object.; *; * If the cursor refers to a C++ declaration, its access control level within; * its parent scope is returned. Otherwise, if the cursor refers to a base; * specifier or access specifier, the specifier itself is returned.; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang-c/Index.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/Index.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/Index.h:239,Security,access,access,239,"/**; * Returns the access control level for the referenced object.; *; * If the cursor refers to a C++ declaration, its access control level within; * its parent scope is returned. Otherwise, if the cursor refers to a base; * specifier or access specifier, the specifier itself is returned.; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang-c/Index.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/Index.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/Index.h:51,Modifiability,variab,variable,51,"/**; * Returns the storage class for a function or variable declaration.; *; * If the passed in Cursor is not a function or variable declaration,; * CX_SC_Invalid is returned else the storage class.; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang-c/Index.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/Index.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/Index.h:124,Modifiability,variab,variable,124,"/**; * Returns the storage class for a function or variable declaration.; *; * If the passed in Cursor is not a function or variable declaration,; * CX_SC_Invalid is returned else the storage class.; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang-c/Index.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/Index.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/Index.h:100,Integrability,rout,routines,100,/**; * @}; */; /**; * \defgroup CINDEX_CURSOR_TRAVERSAL Traversing the AST with cursors; *; * These routines provide the ability to traverse the abstract syntax tree; * using cursors.; *; * @{; */; /**; * Describes how the traversal of the children of a particular; * cursor should proceed after visiting a particular child cursor.; *; * A value of this enumeration type should be returned by each; * \c CXCursorVisitor to indicate how clang_visitChildren() proceed.; */,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang-c/Index.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/Index.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/Index.h:92,Integrability,rout,routines,92,"/**; * @}; */; /**; * \defgroup CINDEX_CURSOR_XREF Cross-referencing in the AST; *; * These routines provide the ability to determine references within and; * across translation units, by providing the names of the entities referenced; * by cursors, follow reference cursors to the declarations they reference,; * and associate declarations with their definitions.; *; * @{; */; /**; * Retrieve a Unified Symbol Resolution (USR) for the entity referenced; * by the given cursor.; *; * A Unified Symbol Resolution (USR) is a string that identifies a particular; * entity (function, class, variable, etc.) within a program. USRs can be; * compared across translation units to determine, e.g., when references in; * one translation refer to an entity defined in another translation unit.; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang-c/Index.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/Index.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/Index.h:588,Modifiability,variab,variable,588,"/**; * @}; */; /**; * \defgroup CINDEX_CURSOR_XREF Cross-referencing in the AST; *; * These routines provide the ability to determine references within and; * across translation units, by providing the names of the entities referenced; * by cursors, follow reference cursors to the declarations they reference,; * and associate declarations with their definitions.; *; * @{; */; /**; * Retrieve a Unified Symbol Resolution (USR) for the entity referenced; * by the given cursor.; *; * A Unified Symbol Resolution (USR) is a string that identifies a particular; * entity (function, class, variable, etc.) within a program. USRs can be; * compared across translation units to determine, e.g., when references in; * one translation refer to an entity defined in another translation unit.; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang-c/Index.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/Index.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/Index.h:51,Integrability,protocol,protocol,51,/**; * Construct a USR for a specified Objective-C protocol.; */,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang-c/Index.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/Index.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/Index.h:60,Modifiability,variab,variable,60,/**; * Construct a USR for a specified Objective-C instance variable and; * the USR for its containing class.; */,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang-c/Index.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/Index.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/Index.h:192,Integrability,message,message,192,"/**; * Retrieve a range for a piece that forms the cursors spelling name.; * Most of the times there is only one range for the complete spelling but for; * Objective-C methods and Objective-C message expressions, there are multiple; * pieces for each selector identifier.; *; * \param pieceIndex the index of the spelling name piece. If this is greater; * than the actual number of pieces, it will return a NULL (invalid) range.; *; * \param options Reserved.; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang-c/Index.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/Index.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/Index.h:78,Deployability,release,released,78,/**; * Retrieve the default policy for the cursor.; *; * The policy should be released after use with \c; * clang_PrintingPolicy_dispose.; */,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang-c/Index.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/Index.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/Index.h:7,Deployability,Release,Release,7,/**; * Release a printing policy.; */,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang-c/Index.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/Index.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/Index.h:84,Integrability,message,message,84,"/**; * If the cursor points to a selector identifier in an Objective-C; * method or message expression, this returns the selector index.; *; * After getting a cursor with #clang_getCursor, this can be called to; * determine if the location points to a selector identifier.; *; * \returns The selector index if the cursor is an Objective-C method or message; * expression and the cursor is pointing to a selector identifier, or -1; * otherwise.; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang-c/Index.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/Index.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/Index.h:349,Integrability,message,message,349,"/**; * If the cursor points to a selector identifier in an Objective-C; * method or message expression, this returns the selector index.; *; * After getting a cursor with #clang_getCursor, this can be called to; * determine if the location points to a selector identifier.; *; * \returns The selector index if the cursor is an Objective-C method or message; * expression and the cursor is pointing to a selector identifier, or -1; * otherwise.; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang-c/Index.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/Index.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/Index.h:73,Integrability,message,message,73,"/**; * Given a cursor pointing to a C++ method call or an Objective-C; * message, returns non-zero if the method/message is ""dynamic"", meaning:; *; * For a C++ method: the call is virtual.; * For an Objective-C message: the receiver is an object instance, not 'super'; * or a specific class.; *; * If the method/message is ""static"" or the cursor does not point to a; * method/message, it will return zero.; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang-c/Index.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/Index.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/Index.h:113,Integrability,message,message,113,"/**; * Given a cursor pointing to a C++ method call or an Objective-C; * message, returns non-zero if the method/message is ""dynamic"", meaning:; *; * For a C++ method: the call is virtual.; * For an Objective-C message: the receiver is an object instance, not 'super'; * or a specific class.; *; * If the method/message is ""static"" or the cursor does not point to a; * method/message, it will return zero.; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang-c/Index.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/Index.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/Index.h:211,Integrability,message,message,211,"/**; * Given a cursor pointing to a C++ method call or an Objective-C; * message, returns non-zero if the method/message is ""dynamic"", meaning:; *; * For a C++ method: the call is virtual.; * For an Objective-C message: the receiver is an object instance, not 'super'; * or a specific class.; *; * If the method/message is ""static"" or the cursor does not point to a; * method/message, it will return zero.; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang-c/Index.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/Index.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/Index.h:312,Integrability,message,message,312,"/**; * Given a cursor pointing to a C++ method call or an Objective-C; * message, returns non-zero if the method/message is ""dynamic"", meaning:; *; * For a C++ method: the call is virtual.; * For an Objective-C message: the receiver is an object instance, not 'super'; * or a specific class.; *; * If the method/message is ""static"" or the cursor does not point to a; * method/message, it will return zero.; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang-c/Index.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/Index.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/Index.h:376,Integrability,message,message,376,"/**; * Given a cursor pointing to a C++ method call or an Objective-C; * message, returns non-zero if the method/message is ""dynamic"", meaning:; *; * For a C++ method: the call is virtual.; * For an Objective-C message: the receiver is an object instance, not 'super'; * or a specific class.; *; * If the method/message is ""static"" or the cursor does not point to a; * method/message, it will return zero.; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang-c/Index.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/Index.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/Index.h:49,Integrability,message,message,49,"/**; * Given a cursor pointing to an Objective-C message or property; * reference, or C++ method call, returns the CXType of the receiver.; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang-c/Index.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/Index.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/Index.h:84,Integrability,interface,interface,84,/**; * Retrieve the CXStrings representing the mangled symbols of the ObjC; * class interface or implementation at the cursor.; */,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang-c/Index.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/Index.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/Index.h:109,Security,access,access,109,/**; * @}; */; /**; * \defgroup CINDEX_MODULE Module introspection; *; * The functions in this group provide access to information about modules.; *; * @{; */,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang-c/Index.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/Index.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/Index.h:75,Integrability,rout,routines,75,/**; * @}; */; /**; * \defgroup CINDEX_CPP C++ AST introspection; *; * The routines in this group provide access information in the ASTs specific; * to C++ language features.; *; * @{; */; /**; * Determine if a C++ constructor is a converting constructor.; */,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang-c/Index.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/Index.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/Index.h:106,Security,access,access,106,/**; * @}; */; /**; * \defgroup CINDEX_CPP C++ AST introspection; *; * The routines in this group provide access information in the ASTs specific; * to C++ language features.; *; * @{; */; /**; * Determine if a C++ constructor is a converting constructor.; */,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang-c/Index.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/Index.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/Index.h:166,Integrability,rout,routine,166,"/**; * Given a cursor that represents a template, determine; * the cursor kind of the specializations would be generated by instantiating; * the template.; *; * This routine can be used to determine what flavor of function template,; * class template, or class template partial specialization is stored in the; * cursor. For example, it can describe whether a class template cursor is; * declared with ""struct"", ""class"" or ""union"".; *; * \param C The cursor to query. This cursor should represent a template; * declaration.; *; * \returns The cursor kind of the specializations that would be generated; * by instantiating the template \p C. If \p C is not a template, returns; * \c CXCursor_NoDeclFound.; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang-c/Index.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/Index.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/Index.h:211,Integrability,rout,routine,211,"/**; * Given a cursor that may represent a specialization or instantiation; * of a template, retrieve the cursor that represents the template that it; * specializes or from which it was instantiated.; *; * This routine determines the template involved both for explicit; * specializations of templates and for implicit instantiations of the template,; * both of which are referred to as ""specializations"". For a class template; * specialization (e.g., \c std::vector<bool>), this routine will return; * either the primary template (\c std::vector) or, if the specialization was; * instantiated from a class template partial specialization, the class template; * partial specialization. For a class template partial specialization and a; * function template specialization (including instantiations), this; * this routine will return the specialized template.; *; * For members of a class template (e.g., member functions, member classes, or; * static data members), returns the specialized or instantiated member.; * Although not strictly ""templates"" in the C++ language, members of class; * templates have the same notions of specializations and instantiations that; * templates do, so this routine treats them similarly.; *; * \param C A cursor that may be a specialization of a template or a member; * of a template.; *; * \returns If the given cursor is a specialization or instantiation of a; * template or a member thereof, the template or member that it specializes or; * from which it was instantiated. Otherwise, returns a NULL cursor.; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang-c/Index.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/Index.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/Index.h:480,Integrability,rout,routine,480,"/**; * Given a cursor that may represent a specialization or instantiation; * of a template, retrieve the cursor that represents the template that it; * specializes or from which it was instantiated.; *; * This routine determines the template involved both for explicit; * specializations of templates and for implicit instantiations of the template,; * both of which are referred to as ""specializations"". For a class template; * specialization (e.g., \c std::vector<bool>), this routine will return; * either the primary template (\c std::vector) or, if the specialization was; * instantiated from a class template partial specialization, the class template; * partial specialization. For a class template partial specialization and a; * function template specialization (including instantiations), this; * this routine will return the specialized template.; *; * For members of a class template (e.g., member functions, member classes, or; * static data members), returns the specialized or instantiated member.; * Although not strictly ""templates"" in the C++ language, members of class; * templates have the same notions of specializations and instantiations that; * templates do, so this routine treats them similarly.; *; * \param C A cursor that may be a specialization of a template or a member; * of a template.; *; * \returns If the given cursor is a specialization or instantiation of a; * template or a member thereof, the template or member that it specializes or; * from which it was instantiated. Otherwise, returns a NULL cursor.; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang-c/Index.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/Index.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/Index.h:813,Integrability,rout,routine,813,"/**; * Given a cursor that may represent a specialization or instantiation; * of a template, retrieve the cursor that represents the template that it; * specializes or from which it was instantiated.; *; * This routine determines the template involved both for explicit; * specializations of templates and for implicit instantiations of the template,; * both of which are referred to as ""specializations"". For a class template; * specialization (e.g., \c std::vector<bool>), this routine will return; * either the primary template (\c std::vector) or, if the specialization was; * instantiated from a class template partial specialization, the class template; * partial specialization. For a class template partial specialization and a; * function template specialization (including instantiations), this; * this routine will return the specialized template.; *; * For members of a class template (e.g., member functions, member classes, or; * static data members), returns the specialized or instantiated member.; * Although not strictly ""templates"" in the C++ language, members of class; * templates have the same notions of specializations and instantiations that; * templates do, so this routine treats them similarly.; *; * \param C A cursor that may be a specialization of a template or a member; * of a template.; *; * \returns If the given cursor is a specialization or instantiation of a; * template or a member thereof, the template or member that it specializes or; * from which it was instantiated. Otherwise, returns a NULL cursor.; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang-c/Index.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/Index.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/Index.h:1192,Integrability,rout,routine,1192,"/**; * Given a cursor that may represent a specialization or instantiation; * of a template, retrieve the cursor that represents the template that it; * specializes or from which it was instantiated.; *; * This routine determines the template involved both for explicit; * specializations of templates and for implicit instantiations of the template,; * both of which are referred to as ""specializations"". For a class template; * specialization (e.g., \c std::vector<bool>), this routine will return; * either the primary template (\c std::vector) or, if the specialization was; * instantiated from a class template partial specialization, the class template; * partial specialization. For a class template partial specialization and a; * function template specialization (including instantiations), this; * this routine will return the specialized template.; *; * For members of a class template (e.g., member functions, member classes, or; * static data members), returns the specialized or instantiated member.; * Although not strictly ""templates"" in the C++ language, members of class; * templates have the same notions of specializations and instantiations that; * templates do, so this routine treats them similarly.; *; * \param C A cursor that may be a specialization of a template or a member; * of a template.; *; * \returns If the given cursor is a specialization or instantiation of a; * template or a member thereof, the template or member that it specializes or; * from which it was instantiated. Otherwise, returns a NULL cursor.; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang-c/Index.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/Index.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/Index.h:499,Availability,avail,available,499,"/**; * Given a cursor that references something else, return the source range; * covering that reference.; *; * \param C A cursor pointing to a member reference, a declaration reference, or; * an operator call.; * \param NameFlags A bitset with three independent flags:; * CXNameRange_WantQualifier, CXNameRange_WantTemplateArgs, and; * CXNameRange_WantSinglePiece.; * \param PieceIndex For contiguous names or when passing the flag; * CXNameRange_WantSinglePiece, only one piece with index 0 is; * available. When the CXNameRange_WantSinglePiece flag is not passed for a; * non-contiguous names, this index can be used to retrieve the individual; * pieces of the name. See also CXNameRange_WantSinglePiece.; *; * \returns The piece of the name pointed to by the given cursor. If there is no; * name, or if the PieceIndex is out-of-range, a null-cursor will be returned.; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang-c/Index.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/Index.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/Index.h:87,Integrability,rout,routines,87,"/**; * @}; */; /**; * \defgroup CINDEX_LEX Token extraction and manipulation; *; * The routines in this group provide access to the tokens within a; * translation unit, along with a semantic mapping of those tokens to; * their corresponding cursors.; *; * @{; */; /**; * Describes a kind of token.; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang-c/Index.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/Index.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/Index.h:118,Security,access,access,118,"/**; * @}; */; /**; * \defgroup CINDEX_LEX Token extraction and manipulation; *; * The routines in this group provide access to the tokens within a; * translation unit, along with a semantic mapping of those tokens to; * their corresponding cursors.; *; * @{; */; /**; * Describes a kind of token.; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang-c/Index.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/Index.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/Index.h:180,Integrability,rout,routine,180,"/**; * Annotate the given set of tokens by providing cursors for each token; * that can be mapped to a specific entity within the abstract syntax tree.; *; * This token-annotation routine is equivalent to invoking; * clang_getCursor() for the source locations of each of the; * tokens. The cursors provided are filtered, so that only those; * cursors that have a direct correspondence to the token are; * accepted. For example, given a function call \c f(x),; * clang_getCursor() would provide the following cursors:; *; * * when the cursor is over the 'f', a DeclRefExpr cursor referring to 'f'.; * * when the cursor is over the '(' or the ')', a CallExpr referring to 'f'.; * * when the cursor is over the 'x', a DeclRefExpr cursor referring to 'x'.; *; * Only the first and last of these cursors will occur within the; * annotate, since the tokens ""f"" and ""x' directly refer to a function; * and a variable, respectively, but the parentheses are just a small; * part of the full syntax of the function call expression, which is; * not provided as an annotation.; *; * \param TU the translation unit that owns the given tokens.; *; * \param Tokens the set of tokens to annotate.; *; * \param NumTokens the number of tokens in \p Tokens.; *; * \param Cursors an array of \p NumTokens cursors, whose contents will be; * replaced with the cursors corresponding to each token.; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang-c/Index.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/Index.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/Index.h:901,Modifiability,variab,variable,901,"/**; * Annotate the given set of tokens by providing cursors for each token; * that can be mapped to a specific entity within the abstract syntax tree.; *; * This token-annotation routine is equivalent to invoking; * clang_getCursor() for the source locations of each of the; * tokens. The cursors provided are filtered, so that only those; * cursors that have a direct correspondence to the token are; * accepted. For example, given a function call \c f(x),; * clang_getCursor() would provide the following cursors:; *; * * when the cursor is over the 'f', a DeclRefExpr cursor referring to 'f'.; * * when the cursor is over the '(' or the ')', a CallExpr referring to 'f'.; * * when the cursor is over the 'x', a DeclRefExpr cursor referring to 'x'.; *; * Only the first and last of these cursors will occur within the; * annotate, since the tokens ""f"" and ""x' directly refer to a function; * and a variable, respectively, but the parentheses are just a small; * part of the full syntax of the function call expression, which is; * not provided as an annotation.; *; * \param TU the translation unit that owns the given tokens.; *; * \param Tokens the set of tokens to annotate.; *; * \param NumTokens the number of tokens in \p Tokens.; *; * \param Cursors an array of \p NumTokens cursors, whose contents will be; * replaced with the cursors corresponding to each token.; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang-c/Index.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/Index.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/Index.h:78,Integrability,rout,routines,78,"/**; * @}; */; /**; * \defgroup CINDEX_DEBUG Debugging facilities; *; * These routines are used for testing and debugging, only, and should not; * be relied upon.; *; * @{; */; /* for debug/testing */",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang-c/Index.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/Index.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/Index.h:100,Testability,test,testing,100,"/**; * @}; */; /**; * \defgroup CINDEX_DEBUG Debugging facilities; *; * These routines are used for testing and debugging, only, and should not; * be relied upon.; *; * @{; */; /* for debug/testing */",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang-c/Index.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/Index.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/Index.h:190,Testability,test,testing,190,"/**; * @}; */; /**; * \defgroup CINDEX_DEBUG Debugging facilities; *; * These routines are used for testing and debugging, only, and should not; * be relied upon.; *; * @{; */; /* for debug/testing */",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang-c/Index.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/Index.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/Index.h:384,Integrability,rout,routines,384,"/**; * @}; */; /**; * \defgroup CINDEX_CODE_COMPLET Code completion; *; * Code completion involves taking an (incomplete) source file, along with; * knowledge of where the user is actively editing that file, and suggesting; * syntactically- and semantically-valid constructs that the user might want to; * use at that particular point in the source code. These data structures and; * routines provide support for code completion.; *; * @{; */; /**; * A semantic string that describes a code-completion result.; *; * A semantic string that describes the formatting of a code-completion; * result as a single ""template"" of text that should be inserted into the; * source buffer when a particular code-completion result is selected.; * Each semantic string is made up of some number of ""chunks"", each of which; * contains some text along with a description of what that text means, e.g.,; * the name of the entity being referenced, whether the text chunk is part of; * the template, or whether it is a ""placeholder"" that the user should replace; * with actual code,of a specific kind. See \c CXCompletionChunkKind for a; * description of the different kinds of chunks.; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang-c/Index.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/Index.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/Index.h:247,Security,access,accessible,247,"/**; * A code-completion string that describes ""optional"" text that; * could be a part of the template (but is not required).; *; * The Optional chunk is the only kind of chunk that has a code-completion; * string for its representation, which is accessible via; * \c clang_getCompletionChunkCompletionString(). The code-completion string; * describes an additional part of the template that is completely optional.; * For example, optional chunks can be used to describe the placeholders for; * arguments that match up with defaulted function parameters, e.g. given:; *; * \code; * void f(int x, float y = 3.14, double z = 2.71828);; * \endcode; *; * The code-completion string for this function would contain:; * - a TypedText chunk for ""f"".; * - a LeftParen chunk for ""("".; * - a Placeholder chunk for ""int x""; * - an Optional chunk containing the remaining defaulted arguments, e.g.,; * - a Comma chunk for "",""; * - a Placeholder chunk for ""float y""; * - an Optional chunk containing the last defaulted argument:; * - a Comma chunk for "",""; * - a Placeholder chunk for ""double z""; * - a RightParen chunk for "")""; *; * There are many ways to handle Optional chunks. Two simple approaches are:; * - Completely ignore optional chunks, in which case the template for the; * function ""f"" would only include the first parameter (""int x"").; * - Fully expand all optional chunks, in which case the template for the; * function ""f"" would have all of the parameters.; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang-c/Index.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/Index.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/Index.h:1173,Usability,simpl,simple,1173,"/**; * A code-completion string that describes ""optional"" text that; * could be a part of the template (but is not required).; *; * The Optional chunk is the only kind of chunk that has a code-completion; * string for its representation, which is accessible via; * \c clang_getCompletionChunkCompletionString(). The code-completion string; * describes an additional part of the template that is completely optional.; * For example, optional chunks can be used to describe the placeholders for; * arguments that match up with defaulted function parameters, e.g. given:; *; * \code; * void f(int x, float y = 3.14, double z = 2.71828);; * \endcode; *; * The code-completion string for this function would contain:; * - a TypedText chunk for ""f"".; * - a LeftParen chunk for ""("".; * - a Placeholder chunk for ""int x""; * - an Optional chunk containing the remaining defaulted arguments, e.g.,; * - a Comma chunk for "",""; * - a Placeholder chunk for ""float y""; * - an Optional chunk containing the last defaulted argument:; * - a Comma chunk for "",""; * - a Placeholder chunk for ""double z""; * - a RightParen chunk for "")""; *; * There are many ways to handle Optional chunks. Two simple approaches are:; * - Completely ignore optional chunks, in which case the template for the; * function ""f"" would only include the first parameter (""int x"").; * - Fully expand all optional chunks, in which case the template for the; * function ""f"" would have all of the parameters.; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang-c/Index.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/Index.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/Index.h:104,Integrability,message,message,104,"/**; * Text that describes the current parameter when code-completion is; * referring to function call, message send, or template specialization.; *; * A ""current parameter"" chunk occurs when code-completion is providing; * information about a parameter corresponding to the argument at the; * code-completion point. For example, given a function; *; * \code; * int add(int x, int y);; * \endcode; *; * and the source code \c add(, where the code-completion point is after the; * ""("", the code-completion string will contain a ""current parameter"" chunk; * for ""int x"", indicating that the current argument will initialize that; * parameter. After typing further, to \c add(17, (where the code-completion; * point is after the "",""), the code-completion string will contain a; * ""current parameter"" chunk to ""int y"".; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang-c/Index.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/Index.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/Index.h:77,Performance,perform,perform,77,"/**; * Vertical space ('\\n'), after which it is generally a good idea to; * perform indentation.; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang-c/Index.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/Index.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/Index.h:21,Availability,avail,availability,21,/**; * Determine the availability of the entity that this code-completion; * string refers to.; *; * \param completion_string The completion string to query.; *; * \returns The availability of the completion string.; */,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang-c/Index.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/Index.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/Index.h:177,Availability,avail,availability,177,/**; * Determine the availability of the entity that this code-completion; * string refers to.; *; * \param completion_string The completion string to query.; *; * \returns The availability of the completion string.; */,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang-c/Index.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/Index.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/Index.h:376,Availability,avail,available,376,"/**; * Retrieve the annotation associated with the given completion string.; *; * \param completion_string the completion string to query.; *; * \param annotation_number the 0-based index of the annotation of the; * completion string.; *; * \returns annotation string associated with the completion at index; * \c annotation_number, or a NULL string if that annotation is not available.; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang-c/Index.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/Index.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/Index.h:302,Integrability,protocol,protocol,302,"/**; * Retrieve the parent context of the given completion string.; *; * The parent context of a completion string is the semantic parent of; * the declaration (if any) that the code completion represents. For example,; * a code completion for an Objective-C method would have the method's class; * or protocol as its context.; *; * \param completion_string The code completion string whose parent is; * being queried.; *; * \param kind DEPRECATED: always set to CXCursor_NotImplemented if non-NULL.; *; * \returns The name of the completion parent, e.g., ""NSObject"" if; * the completion string represents a method in the NSObject class.; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang-c/Index.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/Index.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/Index.h:1428,Deployability,release,release,1428,"/**; * Fix-its that *must* be applied before inserting the text for the; * corresponding completion.; *; * By default, clang_codeCompleteAt() only returns completions with empty; * fix-its. Extra completions with non-empty fix-its should be explicitly; * requested by setting CXCodeComplete_IncludeCompletionsWithFixIts.; *; * For the clients to be able to compute position of the cursor after applying; * fix-its, the following conditions are guaranteed to hold for; * replacement_range of the stored fix-its:; * - Ranges in the fix-its are guaranteed to never contain the completion; * point (or identifier under completion point, if any) inside them, except; * at the start or at the end of the range.; * - If a fix-it range starts or ends with completion point (or starts or; * ends after the identifier under completion point), it will contain at; * least one character. It allows to unambiguously recompute completion; * point after applying the fix-it.; *; * The intuition is that provided fix-its change code around the identifier we; * complete, but are not allowed to touch the identifier itself or the; * completion point. One example of completions with corrections are the ones; * replacing '.' with '->' and vice versa:; *; * std::unique_ptr<std::vector<int>> vec_ptr;; * In 'vec_ptr.^', one of the completions is 'push_back', it requires; * replacing '.' with '->'.; * In 'vec_ptr->^', one of the completions is 'release', it requires; * replacing '->' with '.'.; *; * \param results The structure keeping all completion results; *; * \param completion_index The index of the completion; *; * \param fixit_index The index of the fix-it for the completion at; * completion_index; *; * \param replacement_range The fix-it range that must be replaced before the; * completion at completion_index can be applied; *; * \returns The fix-it string that must replace the code at replacement_range; * before the completion at completion_index can be applied; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang-c/Index.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/Index.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/Index.h:970,Usability,intuit,intuition,970,"/**; * Fix-its that *must* be applied before inserting the text for the; * corresponding completion.; *; * By default, clang_codeCompleteAt() only returns completions with empty; * fix-its. Extra completions with non-empty fix-its should be explicitly; * requested by setting CXCodeComplete_IncludeCompletionsWithFixIts.; *; * For the clients to be able to compute position of the cursor after applying; * fix-its, the following conditions are guaranteed to hold for; * replacement_range of the stored fix-its:; * - Ranges in the fix-its are guaranteed to never contain the completion; * point (or identifier under completion point, if any) inside them, except; * at the start or at the end of the range.; * - If a fix-it range starts or ends with completion point (or starts or; * ends after the identifier under completion point), it will contain at; * least one character. It allows to unambiguously recompute completion; * point after applying the fix-it.; *; * The intuition is that provided fix-its change code around the identifier we; * complete, but are not allowed to touch the identifier itself or the; * completion point. One example of completions with corrections are the ones; * replacing '.' with '->' and vice versa:; *; * std::unique_ptr<std::vector<int>> vec_ptr;; * In 'vec_ptr.^', one of the completions is 'push_back', it requires; * replacing '.' with '->'.; * In 'vec_ptr->^', one of the completions is 'release', it requires; * replacing '->' with '.'.; *; * \param results The structure keeping all completion results; *; * \param completion_index The index of the completion; *; * \param fixit_index The index of the fix-it for the completion at; * completion_index; *; * \param replacement_range The fix-it range that must be replaced before the; * completion at completion_index can be applied; *; * \returns The fix-it string that must replace the code at replacement_range; * before the completion at completion_index can be applied; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang-c/Index.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/Index.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/Index.h:95,Security,access,access,95,"/**; * Whether to include completions with small; * fix-its, e.g. change '.' to '->' on member access, etc.; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang-c/Index.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/Index.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/Index.h:43,Modifiability,variab,variables,43,"/**; * Completions for any possible value (variables, function calls, etc.); * should be included in the results.; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang-c/Index.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/Index.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/Index.h:50,Security,access,accessed,50,/**; * Completions for fields of the member being accessed using the dot; * operator should be included in the results.; */,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang-c/Index.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/Index.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/Index.h:50,Security,access,accessed,50,/**; * Completions for fields of the member being accessed using the arrow; * operator should be included in the results.; */,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang-c/Index.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/Index.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/Index.h:66,Security,access,accessed,66,/**; * Completions for properties of the Objective-C object being accessed; * using the dot operator should be included in the results.; */,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang-c/Index.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/Index.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/Index.h:35,Integrability,interface,interfaces,35,/**; * Completions for Objective-C interfaces (classes) should be included; * in the results.; */,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang-c/Index.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/Index.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/Index.h:35,Integrability,protocol,protocols,35,/**; * Completions for Objective-C protocols should be included in; * the results.; */,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang-c/Index.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/Index.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/Index.h:44,Integrability,message,messages,44,/**; * Completions for Objective-C instance messages should be included; * in the results.; */,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang-c/Index.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/Index.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/Index.h:41,Integrability,message,messages,41,/**; * Completions for Objective-C class messages should be included in; * the results.; */,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang-c/Index.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/Index.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/Index.h:1785,Integrability,interface,interface,1785,"e; * user types punctuation characters or whitespace, at which point the; * code-completion location will coincide with the cursor. For example, if \c p; * is a pointer, code-completion might be triggered after the ""-"" and then; * after the "">"" in \c p->. When the code-completion location is after the "">"",; * the completion results will provide, e.g., the members of the struct that; * ""p"" points to. The client is responsible for placing the cursor at the; * beginning of the token currently being typed, then filtering the results; * based on the contents of the token. For example, when code-completing for; * the expression \c p->get, the client should provide the location just after; * the "">"" (e.g., pointing at the ""g"") to this code-completion hook. Then, the; * client can filter the results based on the current token text (""get""), only; * showing those results that start with ""get"". The intent of this interface; * is to separate the relatively high-latency acquisition of code-completion; * results from the filtering of results on a per-character basis, which must; * have a lower latency.; *; * \param TU The translation unit in which code-completion should; * occur. The source files for this translation unit need not be; * completely up-to-date (and the contents of those source files may; * be overridden via \p unsaved_files). Cursors referring into the; * translation unit may be invalidated by this invocation.; *; * \param complete_filename The name of the source file where code; * completion should be performed. This filename may be any file; * included in the translation unit.; *; * \param complete_line The line at which code-completion should occur.; *; * \param complete_column The column at which code-completion should occur.; * Note that the column should point just after the syntactic construct that; * initiated code completion, and not in the middle of a lexical token.; *; * \param unsaved_files the Files that have not yet been saved to disk; * but may be req",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang-c/Index.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/Index.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/Index.h:7,Performance,Perform,Perform,7,"/**; * Perform code completion at a given location in a translation unit.; *; * This function performs code completion at a particular file, line, and; * column within source code, providing results that suggest potential; * code snippets based on the context of the completion. The basic model; * for code completion is that Clang will parse a complete source file,; * performing syntax checking up to the location where code-completion has; * been requested. At that point, a special code-completion token is passed; * to the parser, which recognizes this token and determines, based on the; * current location in the C/Objective-C/C++ grammar and the state of; * semantic analysis, what completions to provide. These completions are; * returned via a new \c CXCodeCompleteResults structure.; *; * Code completion itself is meant to be triggered by the client when the; * user types punctuation characters or whitespace, at which point the; * code-completion location will coincide with the cursor. For example, if \c p; * is a pointer, code-completion might be triggered after the ""-"" and then; * after the "">"" in \c p->. When the code-completion location is after the "">"",; * the completion results will provide, e.g., the members of the struct that; * ""p"" points to. The client is responsible for placing the cursor at the; * beginning of the token currently being typed, then filtering the results; * based on the contents of the token. For example, when code-completing for; * the expression \c p->get, the client should provide the location just after; * the "">"" (e.g., pointing at the ""g"") to this code-completion hook. Then, the; * client can filter the results based on the current token text (""get""), only; * showing those results that start with ""get"". The intent of this interface; * is to separate the relatively high-latency acquisition of code-completion; * results from the filtering of results on a per-character basis, which must; * have a lower latency.; *; * \param TU The transl",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang-c/Index.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/Index.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/Index.h:94,Performance,perform,performs,94,"/**; * Perform code completion at a given location in a translation unit.; *; * This function performs code completion at a particular file, line, and; * column within source code, providing results that suggest potential; * code snippets based on the context of the completion. The basic model; * for code completion is that Clang will parse a complete source file,; * performing syntax checking up to the location where code-completion has; * been requested. At that point, a special code-completion token is passed; * to the parser, which recognizes this token and determines, based on the; * current location in the C/Objective-C/C++ grammar and the state of; * semantic analysis, what completions to provide. These completions are; * returned via a new \c CXCodeCompleteResults structure.; *; * Code completion itself is meant to be triggered by the client when the; * user types punctuation characters or whitespace, at which point the; * code-completion location will coincide with the cursor. For example, if \c p; * is a pointer, code-completion might be triggered after the ""-"" and then; * after the "">"" in \c p->. When the code-completion location is after the "">"",; * the completion results will provide, e.g., the members of the struct that; * ""p"" points to. The client is responsible for placing the cursor at the; * beginning of the token currently being typed, then filtering the results; * based on the contents of the token. For example, when code-completing for; * the expression \c p->get, the client should provide the location just after; * the "">"" (e.g., pointing at the ""g"") to this code-completion hook. Then, the; * client can filter the results based on the current token text (""get""), only; * showing those results that start with ""get"". The intent of this interface; * is to separate the relatively high-latency acquisition of code-completion; * results from the filtering of results on a per-character basis, which must; * have a lower latency.; *; * \param TU The transl",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang-c/Index.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/Index.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/Index.h:370,Performance,perform,performing,370,"/**; * Perform code completion at a given location in a translation unit.; *; * This function performs code completion at a particular file, line, and; * column within source code, providing results that suggest potential; * code snippets based on the context of the completion. The basic model; * for code completion is that Clang will parse a complete source file,; * performing syntax checking up to the location where code-completion has; * been requested. At that point, a special code-completion token is passed; * to the parser, which recognizes this token and determines, based on the; * current location in the C/Objective-C/C++ grammar and the state of; * semantic analysis, what completions to provide. These completions are; * returned via a new \c CXCodeCompleteResults structure.; *; * Code completion itself is meant to be triggered by the client when the; * user types punctuation characters or whitespace, at which point the; * code-completion location will coincide with the cursor. For example, if \c p; * is a pointer, code-completion might be triggered after the ""-"" and then; * after the "">"" in \c p->. When the code-completion location is after the "">"",; * the completion results will provide, e.g., the members of the struct that; * ""p"" points to. The client is responsible for placing the cursor at the; * beginning of the token currently being typed, then filtering the results; * based on the contents of the token. For example, when code-completing for; * the expression \c p->get, the client should provide the location just after; * the "">"" (e.g., pointing at the ""g"") to this code-completion hook. Then, the; * client can filter the results based on the current token text (""get""), only; * showing those results that start with ""get"". The intent of this interface; * is to separate the relatively high-latency acquisition of code-completion; * results from the filtering of results on a per-character basis, which must; * have a lower latency.; *; * \param TU The transl",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang-c/Index.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/Index.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/Index.h:1833,Performance,latency,latency,1833,"e; * user types punctuation characters or whitespace, at which point the; * code-completion location will coincide with the cursor. For example, if \c p; * is a pointer, code-completion might be triggered after the ""-"" and then; * after the "">"" in \c p->. When the code-completion location is after the "">"",; * the completion results will provide, e.g., the members of the struct that; * ""p"" points to. The client is responsible for placing the cursor at the; * beginning of the token currently being typed, then filtering the results; * based on the contents of the token. For example, when code-completing for; * the expression \c p->get, the client should provide the location just after; * the "">"" (e.g., pointing at the ""g"") to this code-completion hook. Then, the; * client can filter the results based on the current token text (""get""), only; * showing those results that start with ""get"". The intent of this interface; * is to separate the relatively high-latency acquisition of code-completion; * results from the filtering of results on a per-character basis, which must; * have a lower latency.; *; * \param TU The translation unit in which code-completion should; * occur. The source files for this translation unit need not be; * completely up-to-date (and the contents of those source files may; * be overridden via \p unsaved_files). Cursors referring into the; * translation unit may be invalidated by this invocation.; *; * \param complete_filename The name of the source file where code; * completion should be performed. This filename may be any file; * included in the translation unit.; *; * \param complete_line The line at which code-completion should occur.; *; * \param complete_column The column at which code-completion should occur.; * Note that the column should point just after the syntactic construct that; * initiated code completion, and not in the middle of a lexical token.; *; * \param unsaved_files the Files that have not yet been saved to disk; * but may be req",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang-c/Index.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/Index.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/Index.h:1966,Performance,latency,latency,1966,"e; * user types punctuation characters or whitespace, at which point the; * code-completion location will coincide with the cursor. For example, if \c p; * is a pointer, code-completion might be triggered after the ""-"" and then; * after the "">"" in \c p->. When the code-completion location is after the "">"",; * the completion results will provide, e.g., the members of the struct that; * ""p"" points to. The client is responsible for placing the cursor at the; * beginning of the token currently being typed, then filtering the results; * based on the contents of the token. For example, when code-completing for; * the expression \c p->get, the client should provide the location just after; * the "">"" (e.g., pointing at the ""g"") to this code-completion hook. Then, the; * client can filter the results based on the current token text (""get""), only; * showing those results that start with ""get"". The intent of this interface; * is to separate the relatively high-latency acquisition of code-completion; * results from the filtering of results on a per-character basis, which must; * have a lower latency.; *; * \param TU The translation unit in which code-completion should; * occur. The source files for this translation unit need not be; * completely up-to-date (and the contents of those source files may; * be overridden via \p unsaved_files). Cursors referring into the; * translation unit may be invalidated by this invocation.; *; * \param complete_filename The name of the source file where code; * completion should be performed. This filename may be any file; * included in the translation unit.; *; * \param complete_line The line at which code-completion should occur.; *; * \param complete_column The column at which code-completion should occur.; * Note that the column should point just after the syntactic construct that; * initiated code completion, and not in the middle of a lexical token.; *; * \param unsaved_files the Files that have not yet been saved to disk; * but may be req",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang-c/Index.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/Index.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/Index.h:2398,Performance,perform,performed,2398,"urrently being typed, then filtering the results; * based on the contents of the token. For example, when code-completing for; * the expression \c p->get, the client should provide the location just after; * the "">"" (e.g., pointing at the ""g"") to this code-completion hook. Then, the; * client can filter the results based on the current token text (""get""), only; * showing those results that start with ""get"". The intent of this interface; * is to separate the relatively high-latency acquisition of code-completion; * results from the filtering of results on a per-character basis, which must; * have a lower latency.; *; * \param TU The translation unit in which code-completion should; * occur. The source files for this translation unit need not be; * completely up-to-date (and the contents of those source files may; * be overridden via \p unsaved_files). Cursors referring into the; * translation unit may be invalidated by this invocation.; *; * \param complete_filename The name of the source file where code; * completion should be performed. This filename may be any file; * included in the translation unit.; *; * \param complete_line The line at which code-completion should occur.; *; * \param complete_column The column at which code-completion should occur.; * Note that the column should point just after the syntactic construct that; * initiated code completion, and not in the middle of a lexical token.; *; * \param unsaved_files the Files that have not yet been saved to disk; * but may be required for parsing or code completion, including the; * contents of those files. The contents and name of these files (as; * specified by CXUnsavedFile) are copied when necessary, so the; * client only needs to guarantee their validity until the call to; * this function returns.; *; * \param num_unsaved_files The number of unsaved file entries in \p; * unsaved_files.; *; * \param options Extra options that control the behavior of code; * completion, expressed as a bitwise OR of the ",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang-c/Index.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/Index.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/Index.h:103,Performance,perform,performed,103,/**; * Determine the number of diagnostics produced prior to the; * location where code completion was performed.; */,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang-c/Index.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/Index.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/Index.h:217,Integrability,message,message,217,"/**; * Returns the cursor kind for the container for the current code; * completion context. The container is only guaranteed to be set for; * contexts where a container exists (i.e. member accesses or Objective-C; * message sends); if there is not a container, this function will return; * CXCursor_InvalidCode.; *; * \param Results the code completion results to query; *; * \param IsIncomplete on return, this value will be false if Clang has complete; * information about the container. If Clang does not have complete; * information, this value will be true.; *; * \returns the container kind, or CXCursor_InvalidCode if there is not a; * container; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang-c/Index.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/Index.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/Index.h:190,Security,access,accesses,190,"/**; * Returns the cursor kind for the container for the current code; * completion context. The container is only guaranteed to be set for; * contexts where a container exists (i.e. member accesses or Objective-C; * message sends); if there is not a container, this function will return; * CXCursor_InvalidCode.; *; * \param Results the code completion results to query; *; * \param IsIncomplete on return, this value will be false if Clang has complete; * information about the container. If Clang does not have complete; * information, this value will be true.; *; * \returns the container kind, or CXCursor_InvalidCode if there is not a; * container; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang-c/Index.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/Index.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/Index.h:65,Integrability,message,message,65,"/**; * Returns the currently-entered selector for an Objective-C message; * send, formatted like ""initWithFoo:bar:"". Only guaranteed to return a; * non-empty string for CXCompletionContext_ObjCInstanceMessage and; * CXCompletionContext_ObjCClassMessage.; *; * \param Results the code completion results to query; *; * \returns the selector (or partial selector) that has been entered thus far; * for an Objective-C message send.; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang-c/Index.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/Index.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/Index.h:415,Integrability,message,message,415,"/**; * Returns the currently-entered selector for an Objective-C message; * send, formatted like ""initWithFoo:bar:"". Only guaranteed to return a; * non-empty string for CXCompletionContext_ObjCInstanceMessage and; * CXCompletionContext_ObjCClassMessage.; *; * \param Results the code completion results to query; *; * \returns the selector (or partial selector) that has been entered thus far; * for an Objective-C message send.; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang-c/Index.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/Index.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/Index.h:28,Availability,recover,recovery,28,"/**; * Enable/disable crash recovery.; *; * \param isEnabled Flag to indicate if crash recovery is enabled. A non-zero; * value enables crash recovery, while 0 disables it.; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang-c/Index.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/Index.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/Index.h:87,Availability,recover,recovery,87,"/**; * Enable/disable crash recovery.; *; * \param isEnabled Flag to indicate if crash recovery is enabled. A non-zero; * value enables crash recovery, while 0 disables it.; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang-c/Index.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/Index.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/Index.h:142,Availability,recover,recovery,142,"/**; * Enable/disable crash recovery.; *; * \param isEnabled Flag to indicate if crash recovery is enabled. A non-zero; * value enables crash recovery, while 0 disables it.; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang-c/Index.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/Index.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/Index.h:28,Safety,recover,recovery,28,"/**; * Enable/disable crash recovery.; *; * \param isEnabled Flag to indicate if crash recovery is enabled. A non-zero; * value enables crash recovery, while 0 disables it.; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang-c/Index.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/Index.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/Index.h:87,Safety,recover,recovery,87,"/**; * Enable/disable crash recovery.; *; * \param isEnabled Flag to indicate if crash recovery is enabled. A non-zero; * value enables crash recovery, while 0 disables it.; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang-c/Index.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/Index.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/Index.h:142,Safety,recover,recovery,142,"/**; * Enable/disable crash recovery.; *; * \param isEnabled Flag to indicate if crash recovery is enabled. A non-zero; * value enables crash recovery, while 0 disables it.; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang-c/Index.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/Index.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/Index.h:90,Modifiability,variab,variable,90,"/**; * If cursor is a statement declaration tries to evaluate the; * statement and if its variable, tries to evaluate its initializer,; * into its corresponding type.; * If it's an expression, tries to evaluate the expression.; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang-c/Index.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/Index.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/Index.h:231,Availability,error,error,231,/**; * Retrieve a remapping.; *; * \param path the path that contains metadata about remappings.; *; * \returns the requested remapping. This remapping must be freed; * via a call to \c clang_remap_dispose(). Can return NULL if an error occurred.; */,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang-c/Index.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/Index.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/Index.h:291,Availability,error,error,291,/**; * Retrieve a remapping.; *; * \param filePaths pointer to an array of file paths containing remapping info.; *; * \param numFiles number of file paths.; *; * \returns the requested remapping. This remapping must be freed; * via a call to \c clang_remap_dispose(). Can return NULL if an error occurred.; */,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang-c/Index.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/Index.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/Index.h:185,Security,expose,exposed,185,/**; * Roles that are attributed to symbol occurrences.; *; * Internal: this currently mirrors low 9 bits of clang::index::SymbolRole with; * higher bits zeroed. These high bits may be exposed in the future.; */,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang-c/Index.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/Index.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/Index.h:145,Modifiability,variab,variable,145,"/**; * Immediate ""parent"" of the reference. For example:; *; * \code; * Foo *var;; * \endcode; *; * The parent of reference of type 'Foo' is the variable 'var'.; * For references inside statement bodies of functions/methods,; * the parentEntity will be the function/method.; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang-c/Index.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/Index.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/Index.h:63,Safety,abort,aborted,63,"/**; * Called periodically to check whether indexing should be aborted.; * Should return 0 to continue, and non-zero to abort.; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang-c/Index.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/Index.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/Index.h:120,Safety,abort,abort,120,"/**; * Called periodically to check whether indexing should be aborted.; * Should return 0 to continue, and non-zero to abort.; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang-c/Index.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/Index.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/Index.h:804,Availability,error,errors,804,"/**; * Index the given source file and the translation unit corresponding; * to that file via callbacks implemented through #IndexerCallbacks.; *; * \param client_data pointer data supplied by the client, which will; * be passed to the invoked callbacks.; *; * \param index_callbacks Pointer to indexing callbacks that the client; * implements.; *; * \param index_callbacks_size Size of #IndexerCallbacks structure that gets; * passed in index_callbacks.; *; * \param index_options A bitmask of options that affects how indexing is; * performed. This should be a bitwise OR of the CXIndexOpt_XXX flags.; *; * \param[out] out_TU pointer to store a \c CXTranslationUnit that can be; * reused after indexing is finished. Set to \c NULL if you do not require it.; *; * \returns 0 on success or if there were errors from which the compiler could; * recover. If there is a failure from which there is no recovery, returns; * a non-zero \c CXErrorCode.; *; * The rest of the parameters are the same as #clang_parseTranslationUnit.; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang-c/Index.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/Index.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/Index.h:844,Availability,recover,recover,844,"/**; * Index the given source file and the translation unit corresponding; * to that file via callbacks implemented through #IndexerCallbacks.; *; * \param client_data pointer data supplied by the client, which will; * be passed to the invoked callbacks.; *; * \param index_callbacks Pointer to indexing callbacks that the client; * implements.; *; * \param index_callbacks_size Size of #IndexerCallbacks structure that gets; * passed in index_callbacks.; *; * \param index_options A bitmask of options that affects how indexing is; * performed. This should be a bitwise OR of the CXIndexOpt_XXX flags.; *; * \param[out] out_TU pointer to store a \c CXTranslationUnit that can be; * reused after indexing is finished. Set to \c NULL if you do not require it.; *; * \returns 0 on success or if there were errors from which the compiler could; * recover. If there is a failure from which there is no recovery, returns; * a non-zero \c CXErrorCode.; *; * The rest of the parameters are the same as #clang_parseTranslationUnit.; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang-c/Index.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/Index.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/Index.h:867,Availability,failure,failure,867,"/**; * Index the given source file and the translation unit corresponding; * to that file via callbacks implemented through #IndexerCallbacks.; *; * \param client_data pointer data supplied by the client, which will; * be passed to the invoked callbacks.; *; * \param index_callbacks Pointer to indexing callbacks that the client; * implements.; *; * \param index_callbacks_size Size of #IndexerCallbacks structure that gets; * passed in index_callbacks.; *; * \param index_options A bitmask of options that affects how indexing is; * performed. This should be a bitwise OR of the CXIndexOpt_XXX flags.; *; * \param[out] out_TU pointer to store a \c CXTranslationUnit that can be; * reused after indexing is finished. Set to \c NULL if you do not require it.; *; * \returns 0 on success or if there were errors from which the compiler could; * recover. If there is a failure from which there is no recovery, returns; * a non-zero \c CXErrorCode.; *; * The rest of the parameters are the same as #clang_parseTranslationUnit.; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang-c/Index.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/Index.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/Index.h:898,Availability,recover,recovery,898,"/**; * Index the given source file and the translation unit corresponding; * to that file via callbacks implemented through #IndexerCallbacks.; *; * \param client_data pointer data supplied by the client, which will; * be passed to the invoked callbacks.; *; * \param index_callbacks Pointer to indexing callbacks that the client; * implements.; *; * \param index_callbacks_size Size of #IndexerCallbacks structure that gets; * passed in index_callbacks.; *; * \param index_options A bitmask of options that affects how indexing is; * performed. This should be a bitwise OR of the CXIndexOpt_XXX flags.; *; * \param[out] out_TU pointer to store a \c CXTranslationUnit that can be; * reused after indexing is finished. Set to \c NULL if you do not require it.; *; * \returns 0 on success or if there were errors from which the compiler could; * recover. If there is a failure from which there is no recovery, returns; * a non-zero \c CXErrorCode.; *; * The rest of the parameters are the same as #clang_parseTranslationUnit.; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang-c/Index.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/Index.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/Index.h:535,Performance,perform,performed,535,"/**; * Index the given source file and the translation unit corresponding; * to that file via callbacks implemented through #IndexerCallbacks.; *; * \param client_data pointer data supplied by the client, which will; * be passed to the invoked callbacks.; *; * \param index_callbacks Pointer to indexing callbacks that the client; * implements.; *; * \param index_callbacks_size Size of #IndexerCallbacks structure that gets; * passed in index_callbacks.; *; * \param index_options A bitmask of options that affects how indexing is; * performed. This should be a bitwise OR of the CXIndexOpt_XXX flags.; *; * \param[out] out_TU pointer to store a \c CXTranslationUnit that can be; * reused after indexing is finished. Set to \c NULL if you do not require it.; *; * \returns 0 on success or if there were errors from which the compiler could; * recover. If there is a failure from which there is no recovery, returns; * a non-zero \c CXErrorCode.; *; * The rest of the parameters are the same as #clang_parseTranslationUnit.; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang-c/Index.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/Index.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/Index.h:844,Safety,recover,recover,844,"/**; * Index the given source file and the translation unit corresponding; * to that file via callbacks implemented through #IndexerCallbacks.; *; * \param client_data pointer data supplied by the client, which will; * be passed to the invoked callbacks.; *; * \param index_callbacks Pointer to indexing callbacks that the client; * implements.; *; * \param index_callbacks_size Size of #IndexerCallbacks structure that gets; * passed in index_callbacks.; *; * \param index_options A bitmask of options that affects how indexing is; * performed. This should be a bitwise OR of the CXIndexOpt_XXX flags.; *; * \param[out] out_TU pointer to store a \c CXTranslationUnit that can be; * reused after indexing is finished. Set to \c NULL if you do not require it.; *; * \returns 0 on success or if there were errors from which the compiler could; * recover. If there is a failure from which there is no recovery, returns; * a non-zero \c CXErrorCode.; *; * The rest of the parameters are the same as #clang_parseTranslationUnit.; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang-c/Index.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/Index.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/Index.h:898,Safety,recover,recovery,898,"/**; * Index the given source file and the translation unit corresponding; * to that file via callbacks implemented through #IndexerCallbacks.; *; * \param client_data pointer data supplied by the client, which will; * be passed to the invoked callbacks.; *; * \param index_callbacks Pointer to indexing callbacks that the client; * implements.; *; * \param index_callbacks_size Size of #IndexerCallbacks structure that gets; * passed in index_callbacks.; *; * \param index_options A bitmask of options that affects how indexing is; * performed. This should be a bitwise OR of the CXIndexOpt_XXX flags.; *; * \param[out] out_TU pointer to store a \c CXTranslationUnit that can be; * reused after indexing is finished. Set to \c NULL if you do not require it.; *; * \returns 0 on success or if there were errors from which the compiler could; * recover. If there is a failure from which there is no recovery, returns; * a non-zero \c CXErrorCode.; *; * The rest of the parameters are the same as #clang_parseTranslationUnit.; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang-c/Index.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/Index.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/Index.h:450,Availability,failure,failure,450,"/**; * Index the given translation unit via callbacks implemented through; * #IndexerCallbacks.; *; * The order of callback invocations is not guaranteed to be the same as; * when indexing a source file. The high level order will be:; *; * -Preprocessor callbacks invocations; * -Declaration/reference callbacks invocations; * -Diagnostic callback invocations; *; * The parameters are the same as #clang_indexSourceFile.; *; * \returns If there is a failure from which there is no recovery, returns; * non-zero, otherwise returns 0.; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang-c/Index.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/Index.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/Index.h:481,Availability,recover,recovery,481,"/**; * Index the given translation unit via callbacks implemented through; * #IndexerCallbacks.; *; * The order of callback invocations is not guaranteed to be the same as; * when indexing a source file. The high level order will be:; *; * -Preprocessor callbacks invocations; * -Declaration/reference callbacks invocations; * -Diagnostic callback invocations; *; * The parameters are the same as #clang_indexSourceFile.; *; * \returns If there is a failure from which there is no recovery, returns; * non-zero, otherwise returns 0.; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang-c/Index.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/Index.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/Index.h:481,Safety,recover,recovery,481,"/**; * Index the given translation unit via callbacks implemented through; * #IndexerCallbacks.; *; * The order of callback invocations is not guaranteed to be the same as; * when indexing a source file. The high level order will be:; *; * -Preprocessor callbacks invocations; * -Declaration/reference callbacks invocations; * -Diagnostic callback invocations; *; * The parameters are the same as #clang_indexSourceFile.; *; * \returns If there is a failure from which there is no recovery, returns; * non-zero, otherwise returns 0.; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang-c/Index.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/Index.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/Index.h:4,Testability,Log,Logical,4,/** Logical AND operator. */,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang-c/Index.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/Index.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/Index.h:4,Testability,Log,Logical,4,/** Logical OR operator. */,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang-c/Index.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/Index.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/Rewrite.h:16,Modifiability,Rewrite,Rewrite,16,"/*===-- clang-c/Rewrite.h - C CXRewriter --------------------------*- C -*-===*\; |* *|; |* Part of the LLVM Project, under the Apache License v2.0 with LLVM *|; |* Exceptions. *|; |* See https://llvm.org/LICENSE.txt for license information. *|; |* SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception *|; |* *|; |*===----------------------------------------------------------------------===*/",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/include/clang-c/Rewrite.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang-c/Rewrite.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/AnalysisDeclContext.cpp:128,Modifiability,variab,variables,128,//===----------------------------------------------------------------------===//; // Lazily generated map to query the external variables referenced by a Block.; //===----------------------------------------------------------------------===//,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/AnalysisDeclContext.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/AnalysisDeclContext.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/AnalysisDeclContext.cpp:13,Modifiability,variab,variables,13,// Non-local variables are also directly modified.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/AnalysisDeclContext.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/AnalysisDeclContext.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/AnalysisDeclContext.cpp:58,Modifiability,variab,variables,58,// Blocks containing blocks can transitively capture more variables.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/AnalysisDeclContext.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/AnalysisDeclContext.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/AnalysisDeclContext.cpp:37,Modifiability,variab,variables,37,// Find the referenced global/static variables.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/AnalysisDeclContext.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/AnalysisDeclContext.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/BodyFarm.cpp:47,Usability,simpl,simple,47,/// Create a new BinaryOperator representing a simple assignment.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/BodyFarm.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/BodyFarm.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/BodyFarm.cpp:48,Modifiability,variab,variable,48,/// Create a new DeclRefExpr for the referenced variable.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/BodyFarm.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/BodyFarm.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/BodyFarm.cpp:23,Modifiability,variab,variable,23,"/// Make RValue out of variable declaration, creating a temporary; /// DeclRefExpr in the process.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/BodyFarm.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/BodyFarm.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/BodyFarm.cpp:3,Safety,Detect,DetectVirtual,3,/* DetectVirtual=*/,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/BodyFarm.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/BodyFarm.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/BodyFarm.cpp:159,Performance,queue,queue,159,"// Everything checks out. Create a fake body that just calls the block.; // This is basically just an AST dump of:; //; // void dispatch_sync(dispatch_queue_t queue, void (^block)(void)) {; // block();; // }; //",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/BodyFarm.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/BodyFarm.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/BodyFarm.cpp:108,Modifiability,variab,variable,108,"// When a readonly property is shadowed in a class extensions with a; // a readwrite property, the instance variable belongs to the shadowing; // property rather than the shadowed property. If there is no instance; // variable on a readonly property, check to see whether the property is; // shadowed and if so try to get the instance variable from shadowing; // property.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/BodyFarm.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/BodyFarm.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/BodyFarm.cpp:218,Modifiability,variab,variable,218,"// When a readonly property is shadowed in a class extensions with a; // a readwrite property, the instance variable belongs to the shadowing; // property rather than the shadowed property. If there is no instance; // variable on a readonly property, check to see whether the property is; // shadowed and if so try to get the instance variable from shadowing; // property.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/BodyFarm.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/BodyFarm.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/BodyFarm.cpp:335,Modifiability,variab,variable,335,"// When a readonly property is shadowed in a class extensions with a; // a readwrite property, the instance variable belongs to the shadowing; // property rather than the shadowed property. If there is no instance; // variable on a readonly property, check to see whether the property is; // shadowed and if so try to get the instance variable from shadowing; // property.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/BodyFarm.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/BodyFarm.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/BodyFarm.cpp:95,Integrability,interface,interface,95,// Property accessor stubs sometimes do not correspond to any property decl; // in the current interface (but in a superclass). They still have a; // corresponding property impl decl in this case.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/BodyFarm.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/BodyFarm.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/BodyFarm.cpp:12,Security,access,accessor,12,// Property accessor stubs sometimes do not correspond to any property decl; // in the current interface (but in a superclass). They still have a; // corresponding property impl decl in this case.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/BodyFarm.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/BodyFarm.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/BodyFarm.cpp:21,Testability,stub,stubs,21,// Property accessor stubs sometimes do not correspond to any property decl; // in the current interface (but in a superclass). They still have a; // corresponding property impl decl in this case.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/BodyFarm.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/BodyFarm.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/BodyFarm.cpp:15,Modifiability,variab,variables,15,"// Ignore weak variables, which have special behavior.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/BodyFarm.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/BodyFarm.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/BodyFarm.cpp:53,Security,access,accessors,53,// We currently only know how to synthesize property accessors.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/BodyFarm.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/BodyFarm.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/BodyFarm.cpp:56,Security,access,accessors,56,// We should not try to synthesize explicitly redefined accessors.; // We do not know for sure how they behave.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/BodyFarm.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/BodyFarm.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/BodyFarm.cpp:191,Modifiability,variab,variable,191,"// For now, we only synthesize getters.; // Synthesizing setters would cause false negatives in the; // RetainCountChecker because the method body would bind the parameter; // to an instance variable, causing it to escape. This would prevent; // warning in the following common scenario:; //; // id foo = [[NSObject alloc] init];; // self.foo = foo; // We should warn that foo leaks here.; //",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/BodyFarm.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/BodyFarm.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/CalledOnceCheck.cpp:756,Availability,error,error,756,"// Status kind is basically the main part of parameter's status.; // The kind represents our knowledge (so far) about a tracked parameter; // in the context of this analysis.; //; // Since we want to report on missing and extraneous calls, we need to; // track the fact whether paramater was called or not. This automatically; // decides two kinds: `NotCalled` and `Called`.; //; // One of the erroneous situations is the case when parameter is called only; // on some of the paths. We could've considered it `NotCalled`, but we want; // to report double call warnings even if these two calls are not guaranteed; // to happen in every execution. We also don't want to have it as `Called`; // because not calling tracked parameter on all of the paths is an error; // on its own. For these reasons, we need to have a separate kind,; // `MaybeCalled`, and change `Called` to `DefinitelyCalled` to avoid; // confusion.; //; // Two violations of calling parameter more than once and not calling it on; // every path are not, however, mutually exclusive. In situations where both; // violations take place, we prefer to report ONLY double call. It's always; // harder to pinpoint a bug that has arisen when a user neglects to take the; // right action (and therefore, no action is taken), than when a user takes; // the wrong action. And, in order to remember that we already reported; // a double call, we need another kind: `Reported`.; //; // Our analysis is intra-procedural and, while in the perfect world,; // developers only use tracked parameters to call them, in the real world,; // the picture might be different. Parameters can be stored in global; // variables or leaked into other functions that we know nothing about.; // We try to be lenient and trust users. Another kind `Escaped` reflects; // such situations. We don't know if it gets called there or not, but we; // should always think of `Escaped` as the best possible option.; //; // Some of the paths in the analyzed functions might end",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/CalledOnceCheck.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/CalledOnceCheck.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/CalledOnceCheck.cpp:1657,Modifiability,variab,variables,1657,"e it as `Called`; // because not calling tracked parameter on all of the paths is an error; // on its own. For these reasons, we need to have a separate kind,; // `MaybeCalled`, and change `Called` to `DefinitelyCalled` to avoid; // confusion.; //; // Two violations of calling parameter more than once and not calling it on; // every path are not, however, mutually exclusive. In situations where both; // violations take place, we prefer to report ONLY double call. It's always; // harder to pinpoint a bug that has arisen when a user neglects to take the; // right action (and therefore, no action is taken), than when a user takes; // the wrong action. And, in order to remember that we already reported; // a double call, we need another kind: `Reported`.; //; // Our analysis is intra-procedural and, while in the perfect world,; // developers only use tracked parameters to call them, in the real world,; // the picture might be different. Parameters can be stored in global; // variables or leaked into other functions that we know nothing about.; // We try to be lenient and trust users. Another kind `Escaped` reflects; // such situations. We don't know if it gets called there or not, but we; // should always think of `Escaped` as the best possible option.; //; // Some of the paths in the analyzed functions might end with a call; // to noreturn functions. Such paths are not required to have parameter; // calls and we want to track that. For the purposes of better diagnostics,; // we don't want to reuse `Escaped` and, thus, have another kind `NoReturn`.; //; // Additionally, we have `NotVisited` kind that tells us nothing about; // a tracked parameter, but is used for tracking analyzed (aka visited); // basic blocks.; //; // If we consider `|` to be a JOIN operation of two kinds coming from; // two different paths, the following properties must hold:; //; // 1. for any Kind K: K | K == K; // Joining two identical kinds should result in the same kind.; //; // 2. for any Kind ",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/CalledOnceCheck.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/CalledOnceCheck.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/CalledOnceCheck.cpp:894,Safety,avoid,avoid,894,"// Status kind is basically the main part of parameter's status.; // The kind represents our knowledge (so far) about a tracked parameter; // in the context of this analysis.; //; // Since we want to report on missing and extraneous calls, we need to; // track the fact whether paramater was called or not. This automatically; // decides two kinds: `NotCalled` and `Called`.; //; // One of the erroneous situations is the case when parameter is called only; // on some of the paths. We could've considered it `NotCalled`, but we want; // to report double call warnings even if these two calls are not guaranteed; // to happen in every execution. We also don't want to have it as `Called`; // because not calling tracked parameter on all of the paths is an error; // on its own. For these reasons, we need to have a separate kind,; // `MaybeCalled`, and change `Called` to `DefinitelyCalled` to avoid; // confusion.; //; // Two violations of calling parameter more than once and not calling it on; // every path are not, however, mutually exclusive. In situations where both; // violations take place, we prefer to report ONLY double call. It's always; // harder to pinpoint a bug that has arisen when a user neglects to take the; // right action (and therefore, no action is taken), than when a user takes; // the wrong action. And, in order to remember that we already reported; // a double call, we need another kind: `Reported`.; //; // Our analysis is intra-procedural and, while in the perfect world,; // developers only use tracked parameters to call them, in the real world,; // the picture might be different. Parameters can be stored in global; // variables or leaked into other functions that we know nothing about.; // We try to be lenient and trust users. Another kind `Escaped` reflects; // such situations. We don't know if it gets called there or not, but we; // should always think of `Escaped` as the best possible option.; //; // Some of the paths in the analyzed functions might end",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/CalledOnceCheck.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/CalledOnceCheck.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/CalledOnceCheck.cpp:2973,Usability,simpl,simply,2973,"only use tracked parameters to call them, in the real world,; // the picture might be different. Parameters can be stored in global; // variables or leaked into other functions that we know nothing about.; // We try to be lenient and trust users. Another kind `Escaped` reflects; // such situations. We don't know if it gets called there or not, but we; // should always think of `Escaped` as the best possible option.; //; // Some of the paths in the analyzed functions might end with a call; // to noreturn functions. Such paths are not required to have parameter; // calls and we want to track that. For the purposes of better diagnostics,; // we don't want to reuse `Escaped` and, thus, have another kind `NoReturn`.; //; // Additionally, we have `NotVisited` kind that tells us nothing about; // a tracked parameter, but is used for tracking analyzed (aka visited); // basic blocks.; //; // If we consider `|` to be a JOIN operation of two kinds coming from; // two different paths, the following properties must hold:; //; // 1. for any Kind K: K | K == K; // Joining two identical kinds should result in the same kind.; //; // 2. for any Kind K: Reported | K == Reported; // Doesn't matter on which path it was reported, it still is.; //; // 3. for any Kind K: NoReturn | K == K; // We can totally ignore noreturn paths during merges.; //; // 4. DefinitelyCalled | NotCalled == MaybeCalled; // Called on one path, not called on another - that's simply; // a definition for MaybeCalled.; //; // 5. for any Kind K in [DefinitelyCalled, NotCalled, MaybeCalled]:; // Escaped | K == K; // Escaped mirrors other statuses after joins.; // Every situation, when we join any of the listed kinds K,; // is a violation. For this reason, in order to assume the; // best outcome for this escape, we consider it to be the; // same as the other path.; //; // 6. for any Kind K in [DefinitelyCalled, NotCalled]:; // MaybeCalled | K == MaybeCalled; // MaybeCalled should basically stay after almost every join.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/CalledOnceCheck.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/CalledOnceCheck.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/CalledOnceCheck.cpp:74,Availability,error,errors,74,/* 0011 */; // Kinds less or equal to NON_ERROR_STATUS are not considered errors.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/CalledOnceCheck.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/CalledOnceCheck.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/CalledOnceCheck.cpp:132,Energy Efficiency,reduce,reduced,132,"// It would've been a perfect place to use llvm::PointerIntPair, but; // unfortunately NumLowBitsAvailable for clang::Expr had been reduced to 2.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/CalledOnceCheck.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/CalledOnceCheck.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/CalledOnceCheck.cpp:6,Usability,simpl,simple,6,"/// A simple class that finds DeclRefExpr in the given expression.; ///; /// However, we don't want to find ANY nested DeclRefExpr skipping whatever; /// expressions on our way. Only certain expressions considered ""no-op""; /// for our task are indeed skipped.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/CalledOnceCheck.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/CalledOnceCheck.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/CalledOnceCheck.cpp:156,Energy Efficiency,reduce,reduced,156,"/// Find a DeclRefExpr in the given expression.; ///; /// In its most basic form (ShouldRetrieveFromComparisons == false),; /// this function can be simply reduced to the following question:; ///; /// - If expression E is used as a function argument, could we say; /// that DeclRefExpr nested in E is used as an argument?; ///; /// According to this rule, we can say that parens, casts and dereferencing; /// (dereferencing only applied to function pointers, but this is our case); /// can be skipped.; ///; /// When we should look into comparisons the question changes to:; ///; /// - If expression E is used as a condition, could we say that; /// DeclRefExpr is being checked?; ///; /// And even though, these are two different questions, they have quite a lot; /// in common. Actually, we can say that whatever expression answers; /// positively the first question also fits the second question as well.; ///; /// In addition, we skip binary operators == and !=, and unary opeartor !.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/CalledOnceCheck.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/CalledOnceCheck.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/CalledOnceCheck.cpp:149,Usability,simpl,simply,149,"/// Find a DeclRefExpr in the given expression.; ///; /// In its most basic form (ShouldRetrieveFromComparisons == false),; /// this function can be simply reduced to the following question:; ///; /// - If expression E is used as a function argument, could we say; /// that DeclRefExpr nested in E is used as an argument?; ///; /// According to this rule, we can say that parens, casts and dereferencing; /// (dereferencing only applied to function pointers, but this is our case); /// can be skipped.; ///; /// When we should look into comparisons the question changes to:; ///; /// - If expression E is used as a condition, could we say that; /// DeclRefExpr is being checked?; ///; /// And even though, these are two different questions, they have quite a lot; /// in common. Actually, we can say that whatever expression answers; /// positively the first question also fits the second question as well.; ///; /// In addition, we skip binary operators == and !=, and unary opeartor !.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/CalledOnceCheck.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/CalledOnceCheck.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/CalledOnceCheck.cpp:17,Testability,log,logical,17,// We care about logical not only if we care about comparisons.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/CalledOnceCheck.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/CalledOnceCheck.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/CalledOnceCheck.cpp:23,Usability,simpl,simple,23,/// Clarification is a simple pair of a reason why parameter is not called; /// on every path and a statement to blame.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/CalledOnceCheck.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/CalledOnceCheck.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/CalledOnceCheck.cpp:601,Usability,clear,clear,601,"/// The main entrypoint for the class, the function that tries to find the; /// clarification of how to explain which sub-path starts with a CFG edge; /// from Conditional to SuccWithoutCall.; ///; /// This means that this function has one precondition:; /// SuccWithoutCall should be a successor block for Conditional.; ///; /// Because clarification is not needed for non-trivial pairs of blocks; /// (i.e. SuccWithoutCall is not the only successor), it returns meaningful; /// results only for such cases. For this very reason, the parent basic; /// block, Conditional, is named that way, so it is clear what kind of; /// block is expected.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/CalledOnceCheck.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/CalledOnceCheck.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/CalledOnceCheck.cpp:44,Testability,log,logical,44,// We don't want to report on short-curcuit logical operations.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/CalledOnceCheck.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/CalledOnceCheck.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/CalledOnceCheck.cpp:90,Testability,log,logic,90,//===----------------------------------------------------------------------===//; // Main logic 'check' functions; //===----------------------------------------------------------------------===//,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/CalledOnceCheck.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/CalledOnceCheck.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/CalledOnceCheck.cpp:1075,Integrability,message,message,1075,"// For our task, both backward and forward approaches suite well.; // However, in order to report better diagnostics, we decided to go with; // backward analysis.; //; // Let's consider the following CFG and how forward and backward analyses; // will work for it.; //; // FORWARD: | BACKWARD:; // #1 | #1; // +---------+ | +-----------+; // | if | | |MaybeCalled|; // +---------+ | +-----------+; // |NotCalled| | | if |; // +---------+ | +-----------+; // / \ | / \; // #2 / \ #3 | #2 / \ #3; // +----------------+ +---------+ | +----------------+ +---------+; // | foo() | | ... | | |DefinitelyCalled| |NotCalled|; // +----------------+ +---------+ | +----------------+ +---------+; // |DefinitelyCalled| |NotCalled| | | foo() | | ... |; // +----------------+ +---------+ | +----------------+ +---------+; // \ / | \ /; // \ #4 / | \ #4 /; // +-----------+ | +---------+; // | ... | | |NotCalled|; // +-----------+ | +---------+; // |MaybeCalled| | | ... |; // +-----------+ | +---------+; //; // The most natural way to report lacking call in the block #3 would be to; // message that the false branch of the if statement in the block #1 doesn't; // have a call. And while with the forward approach we'll need to find a; // least common ancestor or something like that to find the 'if' to blame,; // backward analysis gives it to us out of the box.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/CalledOnceCheck.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/CalledOnceCheck.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/CalledOnceCheck.cpp:78,Performance,perform,performing,78,"// Check that we have all tracked parameters at the last block.; // As we are performing a backward version of the analysis,; // it should be the ENTRY block.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/CalledOnceCheck.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/CalledOnceCheck.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/CalledOnceCheck.cpp:26,Modifiability,inherit,inherited,26,// We start with a state 'inherited' from all the successors.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/CalledOnceCheck.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/CalledOnceCheck.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/CalledOnceCheck.cpp:55,Availability,error,error,55,"// If we have 'maybe called' at this point, we have an error; // that there is at least one path where this parameter; // is not called.; //; // However, reporting the warning with only that information can be; // too vague for the users. For this reason, we mark such parameters; // as ""interesting"" for further analysis.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/CalledOnceCheck.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/CalledOnceCheck.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/CalledOnceCheck.cpp:24,Modifiability,variab,variables,24,"// ... or if we've seen variables with cleanup functions.; // We can't reason that we've seen every path in this case,; // and thus abandon reporting any warnings that imply that.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/CalledOnceCheck.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/CalledOnceCheck.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/CalledOnceCheck.cpp:545,Integrability,contract,contract,545,"// We are looking for a pair of blocks A, B so that the following is true:; // * A is a predecessor of B; // * B is marked as NotCalled; // * A has at least one successor marked as either; // Escaped or DefinitelyCalled; //; // In that situation, it is guaranteed that B is the first block of the path; // where the user doesn't call or use parameter in question.; //; // For this reason, branch A -> B can be used for reporting.; //; // This part of the algorithm is guarded by a condition that the function; // does indeed have a violation of contract. For this reason, we can; // spend more time to find a good spot to place the warning.; //; // The following algorithm has the worst case complexity of O(V + E),; // where V is the number of basic blocks in FunctionCFG,; // E is the number of edges between blocks in FunctionCFG.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/CalledOnceCheck.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/CalledOnceCheck.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/CalledOnceCheck.cpp:107,Integrability,depend,depending,107,"// Otherwise, we mark this parameter as escaped, which can be; // interpreted both as called or not called depending on the context.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/CalledOnceCheck.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/CalledOnceCheck.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/CalledOnceCheck.cpp:29,Availability,error,error,29,// Escape overrides whatever error we think happened.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/CalledOnceCheck.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/CalledOnceCheck.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/CalledOnceCheck.cpp:283,Integrability,message,message,283,"// We don't want to track the block through assignments and so on, instead; // we simply see how the block used and if it's used directly in a call,; // we decide based on call to what it is.; //; // In order to do this, we go up the parents of the block looking for; // a call or a message expressions. These might not be immediate parents; // of the actual block expression due to casts and parens, so we skip them.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/CalledOnceCheck.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/CalledOnceCheck.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/CalledOnceCheck.cpp:82,Usability,simpl,simply,82,"// We don't want to track the block through assignments and so on, instead; // we simply see how the block used and if it's used directly in a call,; // we decide based on call to what it is.; //; // In order to do this, we go up the parents of the block looking for; // a call or a message expressions. These might not be immediate parents; // of the actual block expression due to casts and parens, so we skip them.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/CalledOnceCheck.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/CalledOnceCheck.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/CalledOnceCheck.cpp:239,Performance,perform,perform,239,"/// Return true if the analyzed function is actually a default implementation; /// of the method that has to be overriden.; ///; /// These functions can have tracked parameters, but wouldn't call them; /// because they are not designed to perform any meaningful actions.; ///; /// There are a couple of flavors of such default implementations:; /// 1. Empty methods or methods with a single return statement; /// 2. Methods that have one block with a call to no return function; /// 3. Methods with only assertion-like operations",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/CalledOnceCheck.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/CalledOnceCheck.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/CalledOnceCheck.cpp:504,Testability,assert,assertion-like,504,"/// Return true if the analyzed function is actually a default implementation; /// of the method that has to be overriden.; ///; /// These functions can have tracked parameters, but wouldn't call them; /// because they are not designed to perform any meaningful actions.; ///; /// There are a couple of flavors of such default implementations:; /// 1. Empty methods or methods with a single return statement; /// 2. Methods that have one block with a call to no return function; /// 3. Methods with only assertion-like operations",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/CalledOnceCheck.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/CalledOnceCheck.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/CalledOnceCheck.cpp:62,Safety,detect,detect,62,"// Cases #1 (return statements) and #3.; //; // It is hard to detect that something is an assertion or came; // from assertion. Here we use a simple heuristic:; //; // - If it came from a macro, it can be an assertion.; //; // Additionally, we can't assume a number of basic blocks or the CFG's; // structure because assertions might include loops and conditions.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/CalledOnceCheck.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/CalledOnceCheck.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/CalledOnceCheck.cpp:90,Testability,assert,assertion,90,"// Cases #1 (return statements) and #3.; //; // It is hard to detect that something is an assertion or came; // from assertion. Here we use a simple heuristic:; //; // - If it came from a macro, it can be an assertion.; //; // Additionally, we can't assume a number of basic blocks or the CFG's; // structure because assertions might include loops and conditions.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/CalledOnceCheck.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/CalledOnceCheck.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/CalledOnceCheck.cpp:117,Testability,assert,assertion,117,"// Cases #1 (return statements) and #3.; //; // It is hard to detect that something is an assertion or came; // from assertion. Here we use a simple heuristic:; //; // - If it came from a macro, it can be an assertion.; //; // Additionally, we can't assume a number of basic blocks or the CFG's; // structure because assertions might include loops and conditions.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/CalledOnceCheck.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/CalledOnceCheck.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/CalledOnceCheck.cpp:208,Testability,assert,assertion,208,"// Cases #1 (return statements) and #3.; //; // It is hard to detect that something is an assertion or came; // from assertion. Here we use a simple heuristic:; //; // - If it came from a macro, it can be an assertion.; //; // Additionally, we can't assume a number of basic blocks or the CFG's; // structure because assertions might include loops and conditions.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/CalledOnceCheck.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/CalledOnceCheck.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/CalledOnceCheck.cpp:317,Testability,assert,assertions,317,"// Cases #1 (return statements) and #3.; //; // It is hard to detect that something is an assertion or came; // from assertion. Here we use a simple heuristic:; //; // - If it came from a macro, it can be an assertion.; //; // Additionally, we can't assume a number of basic blocks or the CFG's; // structure because assertions might include loops and conditions.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/CalledOnceCheck.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/CalledOnceCheck.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/CalledOnceCheck.cpp:142,Usability,simpl,simple,142,"// Cases #1 (return statements) and #3.; //; // It is hard to detect that something is an assertion or came; // from assertion. Here we use a simple heuristic:; //; // - If it came from a macro, it can be an assertion.; //; // Additionally, we can't assume a number of basic blocks or the CFG's; // structure because assertions might include loops and conditions.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/CalledOnceCheck.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/CalledOnceCheck.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/CalledOnceCheck.cpp:38,Testability,test,test,38,// Let's initialize this structure to test whether; // some further statement is a part of this return.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/CalledOnceCheck.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/CalledOnceCheck.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/CalledOnceCheck.cpp:160,Usability,clear,clearly,160,"// In this function, we try to deal with the following pattern:; //; // if (parameter); // parameter(...);; //; // It's not good to show a warning here because clearly 'parameter'; // couldn't and shouldn't be called on the 'else' path.; //; // Let's check if this if statement has a check involving one of; // the tracked parameters.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/CalledOnceCheck.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/CalledOnceCheck.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/CalledOnceCheck.cpp:130,Usability,simpl,simply,130,"// We don't want to deep dive into semantics of the check and; // figure out if that check was for null or something else.; // We simply trust the user that they know what they are doing.; //; // For this reason, in the following loop we look for the; // best-looking option.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/CalledOnceCheck.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/CalledOnceCheck.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/CalledOnceCheck.cpp:191,Availability,error,error,191,"// Even when the analysis is technically correct, it is a widespread pattern; // not to call completion handlers in some scenarios. These usually have; // typical conditional names, such as 'error' or 'cancel'.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/CalledOnceCheck.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/CalledOnceCheck.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/CalledOnceCheck.cpp:3,Integrability,Message,Message,3,"// Message expressions unlike calls, could not be direct.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/CalledOnceCheck.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/CalledOnceCheck.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/CalledOnceCheck.cpp:122,Modifiability,variab,variables,122,"// Let's check if one of the tracked parameters is assigned into; // something, and if it is we don't want to track extra variables, so we; // consider it as an escapee.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/CalledOnceCheck.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/CalledOnceCheck.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/CalledOnceCheck.cpp:3,Modifiability,Variab,Variable,3,// Variable initialization is not assignment and should be handled; // separately.; //; // Multiple declarations can be a part of declaration statement.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/CalledOnceCheck.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/CalledOnceCheck.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/CalledOnceCheck.cpp:237,Performance,perform,performs,237,"// Expected number of parameters that we actually track is 1.; //; // Also, the maximum number of declared parameters could not be on a scale; // of hundreds of thousands.; //; // In this setting, linear search seems reasonable and even performs better; // than bisection.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/CalledOnceCheck.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/CalledOnceCheck.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/CalledOnceCheck.cpp:25,Modifiability,variab,variable,25,"// The user can annotate variable declarations with cleanup functions, which; // essentially imposes a custom destructor logic on that variable.; // It is possible to use it, however, to call tracked parameters on all exits; // from the function. For this reason, we track the fact that the function; // actually has these.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/CalledOnceCheck.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/CalledOnceCheck.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/CalledOnceCheck.cpp:135,Modifiability,variab,variable,135,"// The user can annotate variable declarations with cleanup functions, which; // essentially imposes a custom destructor logic on that variable.; // It is possible to use it, however, to call tracked parameters on all exits; // from the function. For this reason, we track the fact that the function; // actually has these.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/CalledOnceCheck.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/CalledOnceCheck.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/CalledOnceCheck.cpp:121,Testability,log,logic,121,"// The user can annotate variable declarations with cleanup functions, which; // essentially imposes a custom destructor logic on that variable.; // It is possible to use it, however, to call tracked parameters on all exits; // from the function. For this reason, we track the fact that the function; // actually has these.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/CalledOnceCheck.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/CalledOnceCheck.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/CallGraph.cpp:10,Safety,detect,detection,10,// Simple detection of a call through a block.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/CallGraph.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/CallGraph.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/CallGraph.cpp:3,Usability,Simpl,Simple,3,// Simple detection of a call through a block.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/CallGraph.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/CallGraph.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/CallGraph.cpp:36,Integrability,message,message,36,// Adds may-call edges for the ObjC message sends.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/CallGraph.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/CallGraph.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/CallGraph.cpp:3,Energy Efficiency,Allocate,Allocate,3,"// Allocate a new node, mark it as root, and process its calls.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/CallGraph.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/CallGraph.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/CFG.cpp:185,Availability,error,error,185,"/// For an expression `x == Foo && x == Bar`, this determines whether the; /// `Foo` and `Bar` are either of the same enumeration type, or both integer; /// literals.; ///; /// It's an error to pass this arguments that are not either IntegerLiterals; /// or DeclRefExprs (that have decls of type EnumConstantDecl)",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/CFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/CFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/CFG.cpp:21,Usability,clear,clear,21,// User intent isn't clear if they're mixing int literals with enum; // constants.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/CFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/CFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/CFG.cpp:135,Modifiability,variab,variables,135,"/// LocalScope - Node in tree of local scopes created for C++ implicit; /// destructor calls generation. It contains list of automatic variables; /// declared in the scope and link to position in previous scope this scope; /// began in.; ///; /// The process of creating local scopes is as follows:; /// - Init CFGBuilder::ScopePos with invalid position (equivalent for null),; /// - Before processing statements in scope (e.g. CompoundStmt) create; /// LocalScope object using CFGBuilder::ScopePos as link to previous scope; /// and set CFGBuilder::ScopePos to the end of new scope,; /// - On every occurrence of VarDecl increase CFGBuilder::ScopePos if it points; /// at this VarDecl,; /// - For every normal (without jump) end of scope add to CFGBlock destructors; /// for objects in the current scope,; /// - For every jump add to CFGBlock destructors for objects; /// between CFGBuilder::ScopePos and local scope position saved for jump; /// target. Thanks to C++ restrictions on goto jumps we can be sure that; /// jump target position will be on the path to root from CFGBuilder::ScopePos; /// (adding any variable that doesn't need constructor to be called to; /// LocalScope can break this assumption),; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/CFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/CFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/CFG.cpp:1113,Modifiability,variab,variable,1113,"/// LocalScope - Node in tree of local scopes created for C++ implicit; /// destructor calls generation. It contains list of automatic variables; /// declared in the scope and link to position in previous scope this scope; /// began in.; ///; /// The process of creating local scopes is as follows:; /// - Init CFGBuilder::ScopePos with invalid position (equivalent for null),; /// - Before processing statements in scope (e.g. CompoundStmt) create; /// LocalScope object using CFGBuilder::ScopePos as link to previous scope; /// and set CFGBuilder::ScopePos to the end of new scope,; /// - On every occurrence of VarDecl increase CFGBuilder::ScopePos if it points; /// at this VarDecl,; /// - For every normal (without jump) end of scope add to CFGBlock destructors; /// for objects in the current scope,; /// - For every jump add to CFGBlock destructors for objects; /// between CFGBuilder::ScopePos and local scope position saved for jump; /// target. Thanks to C++ restrictions on goto jumps we can be sure that; /// jump target position will be on the path to root from CFGBuilder::ScopePos; /// (adding any variable that doesn't need constructor to be called to; /// LocalScope can break this assumption),; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/CFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/CFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/CFG.cpp:14,Modifiability,variab,variables,14,/// Automatic variables in order of declaration.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/CFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/CFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/CFG.cpp:16,Modifiability,variab,variable,16,/// Iterator to variable in previous scope that was declared just before; /// begin of this scope.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/CFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/CFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/CFG.cpp:175,Modifiability,variab,variables,175,"/// Calculates the closest parent of this iterator; /// that is in a scope reachable through the parents of L.; /// I.e. when using 'goto' from this to L, the lifetime of all variables; /// between this and shared_parent(L) end.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/CFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/CFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/CFG.cpp:57,Modifiability,variab,variables,57,"// Iterators are in the same scope, get common subset of variables.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/CFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/CFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/CFG.cpp:24,Modifiability,variab,variables,24,// Get common subset of variables in given scope,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/CFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/CFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/CFG.cpp:56,Performance,optimiz,optimize,56,// Note: Fill in this switch with more cases we want to optimize.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/CFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/CFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/CFG.cpp:3,Performance,Cache,Caches,3,// Caches boolean evaluations of expressions to avoid multiple re-evaluations; // during construction of branches for chained logical operators.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/CFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/CFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/CFG.cpp:48,Safety,avoid,avoid,48,// Caches boolean evaluations of expressions to avoid multiple re-evaluations; // during construction of branches for chained logical operators.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/CFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/CFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/CFG.cpp:126,Testability,log,logical,126,// Caches boolean evaluations of expressions to avoid multiple re-evaluations; // during construction of branches for chained logical operators.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/CFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/CFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/CFG.cpp:3,Integrability,Interface,Interface,3,// Interface to CFGBlock - adding CFGElements.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/CFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/CFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/CFG.cpp:173,Performance,perform,performed,173,// Helper function to get an APInt from an expression. Supports expressions; // which are an IntegerLiteral or a UnaryOperator and returns the value with; // all operations performed on it.; // FIXME: it would be good to unify this function with; // IsIntegerLiteralConstantExpr at some point given the similarity between the; // functions.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/CFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/CFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/CFG.cpp:3,Performance,Perform,Perform,3,// Perform the operation manually.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/CFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/CFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/CFG.cpp:257,Modifiability,variab,variable,257,"/// There are two checks handled by this function:; /// 1. Find a law-of-excluded-middle or law-of-noncontradiction expression; /// e.g. if (x || !x), if (x && !x); /// 2. Find a pair of comparison expressions with or without parentheses; /// with a shared variable and constants and a logical operator between them; /// that always evaluates to either true or false.; /// e.g. if (x != 3 || x != 4)",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/CFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/CFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/CFG.cpp:286,Testability,log,logical,286,"/// There are two checks handled by this function:; /// 1. Find a law-of-excluded-middle or law-of-noncontradiction expression; /// e.g. if (x || !x), if (x && !x); /// 2. Find a pair of comparison expressions with or without parentheses; /// with a shared variable and constants and a logical operator between them; /// that always evaluates to either true or false.; /// e.g. if (x != 3 || x != 4)",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/CFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/CFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/CFG.cpp:29,Modifiability,variab,variable,29,// Check that it is the same variable on both sides.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/CFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/CFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/CFG.cpp:34,Usability,clear,clear,34,"// Make sure the user's intent is clear (e.g. they're comparing against two; // int literals, or two things from the same enum)",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/CFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/CFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/CFG.cpp:54,Testability,log,logical,54,// Values that will be used to determine if result of logical; // operator is always true/false,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/CFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/CFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/CFG.cpp:83,Modifiability,variab,variable,83,// Check whether expression is always true/false by evaluating the following; // * variable x is less than the smallest literal.; // * variable x is equal to the smallest literal.; // * Variable x is between smallest and largest literal.; // * Variable x is equal to the largest literal.; // * Variable x is greater than largest literal.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/CFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/CFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/CFG.cpp:135,Modifiability,variab,variable,135,// Check whether expression is always true/false by evaluating the following; // * variable x is less than the smallest literal.; // * variable x is equal to the smallest literal.; // * Variable x is between smallest and largest literal.; // * Variable x is equal to the largest literal.; // * Variable x is greater than largest literal.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/CFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/CFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/CFG.cpp:186,Modifiability,Variab,Variable,186,// Check whether expression is always true/false by evaluating the following; // * variable x is less than the smallest literal.; // * variable x is equal to the smallest literal.; // * Variable x is between smallest and largest literal.; // * Variable x is equal to the largest literal.; // * Variable x is greater than largest literal.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/CFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/CFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/CFG.cpp:244,Modifiability,Variab,Variable,244,// Check whether expression is always true/false by evaluating the following; // * variable x is less than the smallest literal.; // * variable x is equal to the smallest literal.; // * Variable x is between smallest and largest literal.; // * Variable x is equal to the largest literal.; // * Variable x is greater than largest literal.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/CFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/CFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/CFG.cpp:294,Modifiability,Variab,Variable,294,// Check whether expression is always true/false by evaluating the following; // * variable x is less than the smallest literal.; // * variable x is equal to the smallest literal.; // * Variable x is between smallest and largest literal.; // * Variable x is equal to the largest literal.; // * Variable x is greater than largest literal.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/CFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/CFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/CFG.cpp:13,Performance,cache,cache,13,// Check the cache first.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/CFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/CFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/CFG.cpp:69,Deployability,update,updated,69,"// already in map;; // Retrieve result at first, or the map might be updated.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/CFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/CFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/CFG.cpp:3,Deployability,update,update,3,// update or insert,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/CFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/CFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/CFG.cpp:51,Performance,cache,cache,51,/// Evaluate as boolean \param E without using the cache.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/CFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/CFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/CFG.cpp:3,Performance,Perform,Perform,3,// Perform the lookup!,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/CFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/CFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/CFG.cpp:14,Deployability,update,update,14,"// No need to update 'cachedEntry', since it will always be null.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/CFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/CFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/CFG.cpp:22,Performance,cache,cachedEntry,22,"// No need to update 'cachedEntry', since it will always be null.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/CFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/CFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/CFG.cpp:26,Integrability,depend,dependent-sized,26,// FIXME: Add support for dependent-sized array types in C++?; // Does it even make sense to build a CFG for an uninstantiated template?,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/CFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/CFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/CFG.cpp:183,Availability,error,error,183,"// FIXME: This, like the main visit, doesn't support CUDAKernelCallExpr.; // FIXME: An isa<> would look much better but this whole switch is a; // workaround for an internal compiler error in MSVC 2015 (see r326021).",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/CFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/CFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/CFG.cpp:40,Integrability,wrap,wrapped,40,"// In general, appending the expression wrapped by a CXXDefaultInitExpr; // may cause the same Expr to appear more than once in the CFG. Doing it; // here is safe because there's only one initializer per field.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/CFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/CFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/CFG.cpp:158,Safety,safe,safe,158,"// In general, appending the expression wrapped by a CXXDefaultInitExpr; // may cause the same Expr to appear more than once in the CFG. Doing it; // here is safe because there's only one initializer per field.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/CFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/CFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/CFG.cpp:70,Modifiability,extend,extended,70,/// Retrieve the type of the temporary object whose lifetime was; /// extended by a local reference with the given initializer.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/CFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/CFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/CFG.cpp:19,Security,access,accesses,19,// Skip sub-object accesses into rvalues.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/CFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/CFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/CFG.cpp:146,Modifiability,variab,variables,146,"/// Adds the CFG elements for leaving the scope of automatic objects in; /// range [B, E). This include following:; /// * AutomaticObjectDtor for variables with non-trivial destructor; /// * LifetimeEnds for all variables; /// * ScopeEnd for each scope left",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/CFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/CFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/CFG.cpp:212,Modifiability,variab,variables,212,"/// Adds the CFG elements for leaving the scope of automatic objects in; /// range [B, E). This include following:; /// * AutomaticObjectDtor for variables with non-trivial destructor; /// * LifetimeEnds for all variables; /// * ScopeEnd for each scope left",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/CFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/CFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/CFG.cpp:96,Modifiability,variab,variables,96,"/// Add CFG elements corresponding to call destructor and end of lifetime; /// of all automatic variables with non-trivial destructor in range [B, E).; /// This include AutomaticObjectDtor and LifetimeEnds elements.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/CFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/CFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/CFG.cpp:177,Modifiability,variab,variables,177,"/// Add CFG elements corresponding to leaving a scope.; /// Assumes that range [B, E) corresponds to single scope.; /// This add following elements:; /// * LifetimeEnds for all variables with non-trivial destructor; /// * ScopeEnd for each scope left",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/CFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/CFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/CFG.cpp:14,Performance,perform,perform,14,// We need to perform the scope leaving in reverse order,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/CFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/CFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/CFG.cpp:106,Modifiability,variab,variables,106,"// Objects with trivial destructor ends their lifetime when their storage; // is destroyed, for automatic variables, this happens when the end of the; // scope is added.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/CFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/CFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/CFG.cpp:284,Integrability,depend,depending,284,"/// addScopeChangesHandling - appends information about destruction, lifetime; /// and cfgScopeEnd for variables in the scope that was left by the jump, and; /// appends cfgScopeBegin for all scopes that where entered.; /// We insert the cfgScopeBegin at the end of the jump node, as depending on; /// the sourceBlock, each goto, may enter different amount of scopes.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/CFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/CFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/CFG.cpp:103,Modifiability,variab,variables,103,"/// addScopeChangesHandling - appends information about destruction, lifetime; /// and cfgScopeEnd for variables in the scope that was left by the jump, and; /// appends cfgScopeBegin for all scopes that where entered.; /// We insert the cfgScopeBegin at the end of the jump node, as depending on; /// the sourceBlock, each goto, may enter different amount of scopes.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/CFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/CFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/CFG.cpp:11,Deployability,update,update,11,"// We will update CFBBuilder when creating new block, restore the; // previous state at exit.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/CFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/CFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/CFG.cpp:58,Modifiability,extend,extends,58,"// Attempt to determine whether this declaration lifetime-extends a; // temporary.; //; // FIXME: This is incorrect. Non-reference declarations can lifetime-extend; // temporaries, and a single declaration can extend multiple temporaries.; // We should look at the storage duration on each nested; // MaterializeTemporaryExpr instead.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/CFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/CFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/CFG.cpp:157,Modifiability,extend,extend,157,"// Attempt to determine whether this declaration lifetime-extends a; // temporary.; //; // FIXME: This is incorrect. Non-reference declarations can lifetime-extend; // temporaries, and a single declaration can extend multiple temporaries.; // We should look at the storage duration on each nested; // MaterializeTemporaryExpr instead.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/CFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/CFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/CFG.cpp:210,Modifiability,extend,extend,210,"// Attempt to determine whether this declaration lifetime-extends a; // temporary.; //; // FIXME: This is incorrect. Non-reference declarations can lifetime-extend; // temporaries, and a single declaration can extend multiple temporaries.; // We should look at the storage duration on each nested; // MaterializeTemporaryExpr instead.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/CFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/CFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/CFG.cpp:44,Modifiability,variab,variable,44,// Probably an exception catch-by-reference variable.; // FIXME: It doesn't really mean that the object has a trivial destructor.; // Also are there other cases?,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/CFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/CFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/CFG.cpp:12,Modifiability,extend,extending,12,// Lifetime-extending a temporary?,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/CFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/CFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/CFG.cpp:49,Modifiability,variab,variable,49,/// addLocalScopeForVarDecl - Add LocalScope for variable declaration. It will; /// create add scope for automatic objects and temporary objects bound to; /// const reference. Will reuse Scope if not NULL.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/CFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/CFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/CFG.cpp:12,Modifiability,variab,variable,12,// Check if variable is local.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/CFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/CFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/CFG.cpp:11,Modifiability,variab,variable,11,// Add the variable to scope,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/CFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/CFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/CFG.cpp:128,Usability,simpl,simply,128,"// FIXME: The expression inside a CXXDefaultArgExpr is owned by the; // called function's declaration, not by the caller. If we simply add; // this expression to the CFG, we could end up with the same Expr; // appearing multiple times (PR13385).; //; // It's likewise possible for multiple CXXDefaultInitExprs for the same; // expression to be used in the same function (through aggregate; // initialization).",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/CFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/CFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/CFG.cpp:41,Testability,log,logical,41,"// Introspect the RHS. If it is a nested logical operation, we recursively; // build the CFG using this function. Otherwise, resort to default; // CFG construction behavior.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/CFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/CFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/CFG.cpp:76,Availability,down,down,76,"// The RHS is not a nested logical operation. Don't push the terminator; // down further, but instead visit RHS and construct the respective; // pieces of the CFG, and link up the RHSBlock with the terminator; // we have been provided.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/CFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/CFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/CFG.cpp:27,Testability,log,logical,27,"// The RHS is not a nested logical operation. Don't push the terminator; // down further, but instead visit RHS and construct the respective; // pieces of the CFG, and link up the RHSBlock with the terminator; // we have been provided.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/CFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/CFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/CFG.cpp:101,Performance,perform,performs,101,"// Even though KnownVal is only used in the else branch of the next; // conditional, tryEvaluateBool performs additional checking on the; // Expr, so it should be called unconditionally.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/CFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/CFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/CFG.cpp:75,Availability,Recover,Recover,75,// We should only get a null bound type if processing a dependent; // CFG. Recover by assuming nothing.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/CFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/CFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/CFG.cpp:56,Integrability,depend,dependent,56,// We should only get a null bound type if processing a dependent; // CFG. Recover by assuming nothing.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/CFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/CFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/CFG.cpp:75,Safety,Recover,Recover,75,// We should only get a null bound type if processing a dependent; // CFG. Recover by assuming nothing.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/CFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/CFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/CFG.cpp:25,Testability,log,logical,25,"// If the condition is a logical '&&' or '||', build a more accurate CFG.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/CFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/CFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/CFG.cpp:3,Energy Efficiency,Allocate,Allocate,3,// Allocate the DeclStmt using the BumpPtrAllocator. It will get; // automatically freed with the CFG.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/CFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/CFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/CFG.cpp:14,Modifiability,variab,variables,14,"// For static variables, we need to create a branch to track; // whether or not they are initialized.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/CFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/CFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/CFG.cpp:10,Modifiability,variab,variable,10,// Remove variable from local scope.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/CFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/CFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/CFG.cpp:501,Modifiability,variab,variable,501,"// We may see an if statement in the middle of a basic block, or it may be the; // first statement we are processing. In either case, we create a new basic; // block. First, we create the blocks for the then...else statements, and; // then we create the block containing the if statement. If we were in the; // middle of a block, we stop processing that block. That block is then the; // implicit successor for the ""then"" and ""else"" clauses.; // Save local scope position because in case of condition variable ScopePos; // won't be restored when traversing AST.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/CFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/CFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/CFG.cpp:45,Modifiability,variab,variable,45,// Create local scope for possible condition variable.; // Store scope position. Add implicit destructor.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/CFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/CFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/CFG.cpp:163,Modifiability,variab,variable,163,"// Specially handle ""if (expr1 || ...)"" and ""if (expr1 && ...)"" by; // having these handle the actual control-flow jump. Note that; // if we introduce a condition variable, e.g. ""if (int x = exp1 || exp2)""; // we resort to the old control-flow behavior. This special handling; // removes infeasible paths from the control-flow graph by having the; // control-flow transfer of '&&' or '||' go directly into the then/else; // blocks directly.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/CFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/CFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/CFG.cpp:38,Modifiability,variab,variable,38,"// If the IfStmt contains a condition variable, add it and its; // initializer to the CFG.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/CFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/CFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/CFG.cpp:259,Usability,simpl,simple,259,"// If we were in the middle of a block we stop processing that block.; //; // NOTE: If a ""return"" or ""co_return"" appears in the middle of a block, this; // means that the code afterwards is DEAD (unreachable). We still keep; // a basic block for that code; a simple ""mark-and-sweep"" from the entry; // block will be able to report such dead blocks.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/CFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/CFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/CFG.cpp:149,Modifiability,variab,variable,149,"// SEHExceptStmt are treated like labels, so they are the first statement in a; // block.; // Save local scope position because in case of exception variable ScopePos; // won't be restored when traversing AST.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/CFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/CFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/CFG.cpp:86,Safety,avoid,avoid,86,"// Save ""Succ"" in BackpatchBlocks. In the backpatch processing, ""Succ"" is; // used to avoid adding ""Succ"" again.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/CFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/CFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/CFG.cpp:58,Modifiability,variab,variable,58,// Save local scope position because in case of condition variable ScopePos; // won't be restored when traversing AST.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/CFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/CFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/CFG.cpp:64,Modifiability,variab,variable,64,// Create local scope for init statement and possible condition variable.; // Add destructor for init statement and condition variable.; // Store scope position for continue statement.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/CFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/CFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/CFG.cpp:126,Modifiability,variab,variable,126,// Create local scope for init statement and possible condition variable.; // Add destructor for init statement and condition variable.; // Store scope position for continue statement.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/CFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/CFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/CFG.cpp:80,Modifiability,variab,variable,80,// Loop iteration (after increment) should end with destructor of Condition; // variable (if any).,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/CFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/CFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/CFG.cpp:20,Testability,log,logical,20,"// Specially handle logical operators, which have a slightly; // more optimal CFG representation.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/CFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/CFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/CFG.cpp:38,Testability,log,logical,38,// The default case when not handling logical operators.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/CFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/CFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/CFG.cpp:154,Deployability,update,update,154,"// Now add the actual condition to the condition block.; // Because the condition itself may contain control-flow, new blocks may; // be created. Thus we update ""Succ"" after adding the condition.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/CFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/CFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/CFG.cpp:38,Modifiability,variab,variable,38,"// If this block contains a condition variable, add both the condition; // variable and initializer to the CFG.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/CFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/CFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/CFG.cpp:75,Modifiability,variab,variable,75,"// If this block contains a condition variable, add both the condition; // variable and initializer to the CFG.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/CFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/CFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/CFG.cpp:374,Performance,perform,performs,374,"// Objective-C fast enumeration 'for' statements:; // http://developer.apple.com/documentation/Cocoa/Conceptual/ObjectiveC; //; // for ( Type newVariable in collection_expression ) { statements }; //; // becomes:; //; // prologue:; // 1. collection_expression; // T. jump to loop_entry; // loop_entry:; // 1. side-effects of element expression; // 1. ObjCForCollectionStmt [performs binding to newVariable]; // T. ObjCForCollectionStmt TB, FB [jumps to TB if newVariable != nil]; // TB:; // statements; // T. jump to loop_entry; // FB:; // what comes after; //; // and; //; // Type existingItem;; // for ( existingItem in expression ) { statements }; //; // becomes:; //; // the same with newVariable replaced with existingItem; the binding works; // the same except that for one ObjCForCollectionStmt::getElement() returns; // a DeclStmt and the other returns a DeclRefExpr.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/CFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/CFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/CFG.cpp:82,Performance,perform,performs,82,"// The last statement in the block should be the ObjCForCollectionStmt, which; // performs the actual binding to 'element' and determines if there are any; // more items in the collection.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/CFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/CFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/CFG.cpp:47,Integrability,synchroniz,synchronized,47,// FIXME: Add locking 'primitives' to CFG for @synchronized.; // Inline the body.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/CFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/CFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/CFG.cpp:12,Integrability,synchroniz,synchronized,12,// Add the @synchronized to the CFG.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/CFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/CFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/CFG.cpp:58,Modifiability,variab,variable,58,// Save local scope position because in case of condition variable ScopePos; // won't be restored when traversing AST.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/CFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/CFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/CFG.cpp:45,Modifiability,variab,variable,45,// Create local scope for possible condition variable.; // Store scope position for continue statement.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/CFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/CFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/CFG.cpp:53,Modifiability,variab,variable,53,// Loop body should end with destructor of Condition variable (if any).,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/CFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/CFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/CFG.cpp:20,Testability,log,logical,20,"// Specially handle logical operators, which have a slightly; // more optimal CFG representation.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/CFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/CFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/CFG.cpp:38,Testability,log,logical,38,// The default case when not handling logical operators.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/CFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/CFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/CFG.cpp:154,Deployability,update,update,154,"// Now add the actual condition to the condition block.; // Because the condition itself may contain control-flow, new blocks may; // be created. Thus we update ""Succ"" after adding the condition.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/CFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/CFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/CFG.cpp:38,Modifiability,variab,variable,38,"// If this block contains a condition variable, add both the condition; // variable and initializer to the CFG.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/CFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/CFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/CFG.cpp:75,Modifiability,variab,variable,75,"// If this block contains a condition variable, add both the condition; // variable and initializer to the CFG.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/CFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/CFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/CFG.cpp:151,Modifiability,variab,variable,151,"// ObjCAtCatchStmt are treated like labels, so they are the first statement; // in a block.; // Save local scope position because in case of exception variable ScopePos; // won't be restored when traversing AST.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/CFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/CFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/CFG.cpp:99,Modifiability,polymorphi,polymorphic,99,// C++ [expr.typeid]p3:; // When typeid is applied to an expression other than an glvalue of a; // polymorphic class type [...] [the] expression is an unevaluated; // operand. [...]; // We add only potentially evaluated statements to the block to avoid; // CFG generation for unevaluated operands.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/CFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/CFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/CFG.cpp:247,Safety,avoid,avoid,247,// C++ [expr.typeid]p3:; // When typeid is applied to an expression other than an glvalue of a; // polymorphic class type [...] [the] expression is an unevaluated; // operand. [...]; // We add only potentially evaluated statements to the block to avoid; // CFG generation for unevaluated operands.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/CFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/CFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/CFG.cpp:260,Energy Efficiency,efficient,efficiently,260,"// Add an intermediate block between the BodyBlock and the; // ExitConditionBlock to represent the ""loop back"" transition. Create an; // empty block to represent the transition block for looping back to the; // head of the loop.; // FIXME: Can we do this more efficiently without adding another block?",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/CFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/CFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/CFG.cpp:58,Modifiability,variab,variable,58,// Save local scope position because in case of condition variable ScopePos; // won't be restored when traversing AST.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/CFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/CFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/CFG.cpp:45,Modifiability,variab,variable,45,// Create local scope for possible condition variable.; // Store scope position. Add implicit destructor.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/CFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/CFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/CFG.cpp:42,Modifiability,variab,variable,42,"// If the SwitchStmt contains a condition variable, add both the; // SwitchStmt and the condition variable initialization to the CFG.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/CFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/CFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/CFG.cpp:98,Modifiability,variab,variable,98,"// If the SwitchStmt contains a condition variable, add both the; // SwitchStmt and the condition variable initialization to the CFG.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/CFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/CFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/CFG.cpp:148,Modifiability,variab,variable,148,"// CXXCatchStmt are treated like labels, so they are the first statement in a; // block.; // Save local scope position because in case of exception variable ScopePos; // won't be restored when traversing AST.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/CFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/CFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/CFG.cpp:45,Modifiability,variab,variable,45,// Create local scope for possible exception variable.; // Store scope position. Add implicit destructor.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/CFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/CFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/CFG.cpp:125,Modifiability,variab,variable,125,"// CXXCatchStmt is more than just a label. They have semantic meaning; // as well, as they implicitly ""initialize"" the catch variable. Add; // it to the CFG as a CFGElement so that the control-flow of these; // semantics gets captured.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/CFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/CFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/CFG.cpp:335,Modifiability,variab,variables,335,"// C++0x for-range statements are specified as [stmt.ranged]:; //; // {; // auto && __range = range-init;; // for ( auto __begin = begin-expr,; // __end = end-expr;; // __begin != __end;; // ++__begin ) {; // for-range-declaration = *__begin;; // statement; // }; // }; // Save local scope position before the addition of the implicit variables.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/CFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/CFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/CFG.cpp:64,Modifiability,variab,variables,64,"// Create local scopes and destructors for range, begin and end variables.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/CFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/CFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/CFG.cpp:41,Modifiability,variab,variable,41,// Add implicit scope and dtors for loop variable.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/CFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/CFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/CFG.cpp:58,Modifiability,variab,variable,58,// Populate a new block to contain the loop body and loop variable.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/CFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/CFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/CFG.cpp:50,Modifiability,extend,extended,50,// Find the expression whose lifetime needs to be extended.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/CFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/CFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/CFG.cpp:82,Integrability,wrap,wrapped,82,// Don't recurse into statement expressions; any cleanups inside them; // will be wrapped in their own ExprWithCleanups.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/CFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/CFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/CFG.cpp:120,Integrability,depend,depends,120,"// We do not know at CFG-construction time whether the right-hand-side was; // executed, thus we add a branch node that depends on the temporary; // constructor call.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/CFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/CFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/CFG.cpp:112,Performance,cache,cache,112,"// Traverse the CFG until we find a branch.; // TODO: While this should still be very fast,; // maybe we should cache the answer.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/CFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/CFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/CFG.cpp:68,Modifiability,extend,extending,68,// FIXME: See CFGBuilder::addLocalScopeForVarDecl.; //; // Lifetime-extending constructs are handled here. This works for a single; // temporary in an initializer expression.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/CFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/CFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/CFG.cpp:47,Modifiability,extend,extending,47,"// The situation when the type of the lifetime-extending reference; // does not correspond to the type of the object is supposed; // to be handled by now. In particular, 'ty' is now the unwrapped; // record type.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/CFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/CFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/CFG.cpp:13,Usability,simpl,simple,13,/// dump - A simple pretty printer of a CFG that outputs to stderr.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/CFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/CFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/CFG.cpp:14,Usability,simpl,simple,14,/// print - A simple pretty printer of a CFG that outputs to an ostream.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/CFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/CFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/CFG.cpp:13,Usability,simpl,simply,13,/// dump - A simply pretty printer of a CFGBlock that outputs to stderr.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/CFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/CFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/CFG.cpp:14,Usability,simpl,simple,14,/// print - A simple pretty printer of a CFGBlock that outputs to an ostream.; /// Generally this will only be called from CFG::print.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/CFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/CFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/CFG.cpp:24,Usability,simpl,simple,24,/// printTerminator - A simple pretty printer of the terminator of a CFGBlock.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/CFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/CFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/CFG.cpp:22,Usability,simpl,simply,22,"// Returns true if by simply looking at the block, we can be sure that it; // results in a sink during analysis. This is useful to know when the analysis; // was interrupted, and we try to figure out if it would sink eventually.; // There may be many more reasons why a sink would appear during analysis; // (eg. checkers may generate sinks arbitrarily), but here we only consider; // sinks that would be obvious by looking at the CFG.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/CFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/CFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/CFGReachabilityAnalysis.cpp:14,Performance,cache,cached,14,// Return the cached result,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/CFGReachabilityAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/CFGReachabilityAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/CFGReachabilityAnalysis.cpp:69,Performance,perform,perform,69,"// Start searching from the destination node, since we commonly will perform; // multiple queries relating to a destination node.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/CFGReachabilityAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/CFGReachabilityAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/CFGReachabilityAnalysis.cpp:3,Deployability,Update,Update,3,// Update reachability information for this node -> Dst,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/CFGReachabilityAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/CFGReachabilityAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/CloneDetection.cpp:253,Performance,perform,performance,253,"// Compare every group in the result with the rest. If one groups contains; // another group, we only need to return the bigger group.; // Note: This doesn't scale well, so if possible avoid calling any heavy; // function from this loop to minimize the performance impact.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/CloneDetection.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/CloneDetection.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/CloneDetection.cpp:185,Safety,avoid,avoid,185,"// Compare every group in the result with the rest. If one groups contains; // another group, we only need to return the bigger group.; // Note: This doesn't scale well, so if possible avoid calling any heavy; // function from this loop to minimize the performance impact.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/CloneDetection.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/CloneDetection.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/CloneDetection.cpp:352,Deployability,update,update,352,"/// This class defines what a type II code clone is: If it collects for two; /// statements the same data, then those two statements are considered to be; /// clones of each other.; ///; /// All collected data is forwarded to the given data consumer of the type T.; /// The data consumer class needs to provide a member method with the signature:; /// update(StringRef Str)",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/CloneDetection.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/CloneDetection.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/CloneDetection.cpp:25,Modifiability,variab,variable,25,"// Type II clones ignore variable names and literals, so let's skip them.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/CloneDetection.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/CloneDetection.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/CloneDetection.cpp:20,Security,hash,hash,20,// Create the final hash code for the current Stmt.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/CloneDetection.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/CloneDetection.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/CloneDetection.cpp:45,Security,hash,hash,45,// Copy as much as possible of the generated hash code to the Stmt's hash; // code.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/CloneDetection.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/CloneDetection.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/CloneDetection.cpp:69,Security,hash,hash,69,// Copy as much as possible of the generated hash code to the Stmt's hash; // code.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/CloneDetection.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/CloneDetection.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/CloneDetection.cpp:26,Security,hash,hash,26,"/// Generates and saves a hash code for the given Stmt.; /// \param S The given Stmt.; /// \param D The Decl containing S.; /// \param StmtsByHash Output parameter that will contain the hash codes for; /// each StmtSequence in the given Stmt.; /// \return The hash code of the given Stmt.; ///; /// If the given Stmt is a CompoundStmt, this method will also generate; /// hashes for all possible StmtSequences in the children of this Stmt.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/CloneDetection.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/CloneDetection.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/CloneDetection.cpp:186,Security,hash,hash,186,"/// Generates and saves a hash code for the given Stmt.; /// \param S The given Stmt.; /// \param D The Decl containing S.; /// \param StmtsByHash Output parameter that will contain the hash codes for; /// each StmtSequence in the given Stmt.; /// \return The hash code of the given Stmt.; ///; /// If the given Stmt is a CompoundStmt, this method will also generate; /// hashes for all possible StmtSequences in the children of this Stmt.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/CloneDetection.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/CloneDetection.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/CloneDetection.cpp:260,Security,hash,hash,260,"/// Generates and saves a hash code for the given Stmt.; /// \param S The given Stmt.; /// \param D The Decl containing S.; /// \param StmtsByHash Output parameter that will contain the hash codes for; /// each StmtSequence in the given Stmt.; /// \return The hash code of the given Stmt.; ///; /// If the given Stmt is a CompoundStmt, this method will also generate; /// hashes for all possible StmtSequences in the children of this Stmt.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/CloneDetection.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/CloneDetection.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/CloneDetection.cpp:372,Security,hash,hashes,372,"/// Generates and saves a hash code for the given Stmt.; /// \param S The given Stmt.; /// \param D The Decl containing S.; /// \param StmtsByHash Output parameter that will contain the hash codes for; /// each StmtSequence in the given Stmt.; /// \return The hash code of the given Stmt.; ///; /// If the given Stmt is a CompoundStmt, this method will also generate; /// hashes for all possible StmtSequences in the children of this Stmt.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/CloneDetection.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/CloneDetection.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/CloneDetection.cpp:34,Security,hash,hash,34,"// If we're in a CompoundStmt, we hash all possible combinations of child; // statements to find clones in those subsequences.; // We first go through every possible starting position of a subsequence.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/CloneDetection.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/CloneDetection.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/CloneDetection.cpp:87,Security,hash,hash,87,// Then we try all possible lengths this subsequence could have and; // reuse the same hash object to make sure we only hash every child; // hash exactly once.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/CloneDetection.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/CloneDetection.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/CloneDetection.cpp:120,Security,hash,hash,120,// Then we try all possible lengths this subsequence could have and; // reuse the same hash object to make sure we only hash every child; // hash exactly once.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/CloneDetection.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/CloneDetection.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/CloneDetection.cpp:141,Security,hash,hash,141,// Then we try all possible lengths this subsequence could have and; // reuse the same hash object to make sure we only hash every child; // hash exactly once.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/CloneDetection.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/CloneDetection.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/CloneDetection.cpp:26,Security,hash,hash,26,// Grab the current child hash and put it into our hash. We do; // -1 on the index because we start counting the length at 1.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/CloneDetection.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/CloneDetection.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/CloneDetection.cpp:51,Security,hash,hash,51,// Grab the current child hash and put it into our hash. We do; // -1 on the index because we start counting the length at 1.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/CloneDetection.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/CloneDetection.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/CloneDetection.cpp:4,Integrability,Wrap,Wrapper,4,/// Wrapper around FoldingSetNodeID that it can be used as the template; /// argument of the StmtDataCollector.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/CloneDetection.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/CloneDetection.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/CloneDetection.cpp:98,Security,hash,hash,98,// We collect the data from all statements in the sequence as we did before; // when generating a hash value for each sequence. But this time we don't; // hash the collected data and compare the whole data set instead. This; // prevents any false-positives due to hash code collisions.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/CloneDetection.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/CloneDetection.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/CloneDetection.cpp:155,Security,hash,hash,155,// We collect the data from all statements in the sequence as we did before; // when generating a hash value for each sequence. But this time we don't; // hash the collected data and compare the whole data set instead. This; // prevents any false-positives due to hash code collisions.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/CloneDetection.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/CloneDetection.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/CloneDetection.cpp:264,Security,hash,hash,264,// We collect the data from all statements in the sequence as we did before; // when generating a hash value for each sequence. But this time we don't; // hash the collected data and compare the whole data set instead. This; // prevents any false-positives due to hash code collisions.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/CloneDetection.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/CloneDetection.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/CloneDetection.cpp:12,Security,hash,hash,12,// Generate hash codes for all children of S and save them in StmtsByHash.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/CloneDetection.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/CloneDetection.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/CloneDetection.cpp:184,Safety,safe,safe,184,// Check for each StmtSequence if its successor has the same hash value.; // We don't check the last StmtSequence as it has no successor.; // Note: The 'size - 1 ' in the condition is safe because we check for an; // empty Group vector at the beginning of this function.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/CloneDetection.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/CloneDetection.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/CloneDetection.cpp:61,Security,hash,hash,61,// Check for each StmtSequence if its successor has the same hash value.; // We don't check the last StmtSequence as it has no successor.; // Note: The 'size - 1 ' in the condition is safe because we check for an; // empty Group vector at the beginning of this function.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/CloneDetection.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/CloneDetection.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/CloneDetection.cpp:15,Security,hash,hash,15,// A different hash value means we have reached the end of the sequence.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/CloneDetection.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/CloneDetection.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/CloneDetection.cpp:210,Security,hash,hash,210,// The current sequence could be the start of a new CloneGroup. So we; // decrement i so that we visit it again in the outer loop.; // Note: i can never be 0 at this point because we are just comparing; // the hash of the Current StmtSequence with itself in the 'if' above.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/CloneDetection.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/CloneDetection.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/CloneDetection.cpp:8,Security,hash,hash,8,// Same hash value means we should add the StmtSequence to the current; // group.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/CloneDetection.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/CloneDetection.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/CloneDetection.cpp:46,Security,hash,hash,46,// We created a new clone group with matching hash codes and move it to; // the result vector.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/CloneDetection.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/CloneDetection.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/CloneDetection.cpp:236,Energy Efficiency,reduce,reduce,236,"// First, check if ParentMacroStack is not empty which means we are currently; // dealing with a parent statement which was expanded from a macro.; // If this parent statement was expanded from the same macros as this; // statement, we reduce the initial complexity of this statement to zero.; // This causes that a group of statements that were generated by a single; // macro expansion will only increase the total complexity by one.; // Note: This is not the final complexity of this statement as we still; // add the complexity of the child statements to the complexity value.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/CloneDetection.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/CloneDetection.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/CloneDetection.cpp:27,Security,Hash,HashGroup,27,// Contains all indexes in HashGroup that were already added to a; // CloneGroup.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/CloneDetection.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/CloneDetection.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/CloneDetection.cpp:44,Modifiability,variab,variable,44,// First check if we already reference this variable,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/CloneDetection.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/CloneDetection.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/CloneDetection.cpp:77,Modifiability,Variab,Variables,77,"// If yes, add a new occurrence that points to the existing entry in; // the Variables vector.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/CloneDetection.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/CloneDetection.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/CloneDetection.cpp:11,Modifiability,variab,variable,11,"// If this variable wasn't already referenced, add it to the list of; // referenced variables and add a occurrence that points to this new entry.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/CloneDetection.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/CloneDetection.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/CloneDetection.cpp:84,Modifiability,variab,variables,84,"// If this variable wasn't already referenced, add it to the list of; // referenced variables and add a occurrence that points to this new entry.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/CloneDetection.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/CloneDetection.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/CloneDetection.cpp:148,Modifiability,variab,variables,148,// Sometimes we get a nullptr (such as from IfStmts which often have nullptr; // children). We skip such statements as they don't reference any; // variables.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/CloneDetection.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/CloneDetection.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/CloneDetection.cpp:34,Modifiability,variab,variable,34,"// Check if S is a reference to a variable. If yes, add it to the pattern.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/CloneDetection.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/CloneDetection.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/CloneDetection.cpp:26,Availability,avail,available,26,"// If there is a variable available in the list of referenced variables; // which wouldn't break the pattern if it is used in place of the; // current variable, we provide this variable as the suggested fix.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/CloneDetection.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/CloneDetection.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/CloneDetection.cpp:17,Modifiability,variab,variable,17,"// If there is a variable available in the list of referenced variables; // which wouldn't break the pattern if it is used in place of the; // current variable, we provide this variable as the suggested fix.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/CloneDetection.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/CloneDetection.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/CloneDetection.cpp:62,Modifiability,variab,variables,62,"// If there is a variable available in the list of referenced variables; // which wouldn't break the pattern if it is used in place of the; // current variable, we provide this variable as the suggested fix.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/CloneDetection.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/CloneDetection.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/CloneDetection.cpp:151,Modifiability,variab,variable,151,"// If there is a variable available in the list of referenced variables; // which wouldn't break the pattern if it is used in place of the; // current variable, we provide this variable as the suggested fix.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/CloneDetection.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/CloneDetection.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/CloneDetection.cpp:177,Modifiability,variab,variable,177,"// If there is a variable available in the list of referenced variables; // which wouldn't break the pattern if it is used in place of the; // current variable, we provide this variable as the suggested fix.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/CloneDetection.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/CloneDetection.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/CloneDetection.cpp:152,Availability,error,error,152,// Same as above but with the other clone. We do this for both clones as; // we don't know which clone is the one containing the unintended; // pattern error.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/CloneDetection.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/CloneDetection.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/CloneDetection.cpp:82,Modifiability,variab,variable,82,"// SuspiciousClonePair guarantees that the first clone always has a; // suggested variable associated with it. As we know that one of the two; // clones in the pair always has suggestion, we swap the two clones; // in case the first clone has no suggested variable which means that; // the second clone has a suggested variable and should be first.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/CloneDetection.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/CloneDetection.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/CloneDetection.cpp:256,Modifiability,variab,variable,256,"// SuspiciousClonePair guarantees that the first clone always has a; // suggested variable associated with it. As we know that one of the two; // clones in the pair always has suggestion, we swap the two clones; // in case the first clone has no suggested variable which means that; // the second clone has a suggested variable and should be first.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/CloneDetection.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/CloneDetection.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/CloneDetection.cpp:319,Modifiability,variab,variable,319,"// SuspiciousClonePair guarantees that the first clone always has a; // suggested variable associated with it. As we know that one of the two; // clones in the pair always has suggestion, we swap the two clones; // in case the first clone has no suggested variable which means that; // the second clone has a suggested variable and should be first.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/CloneDetection.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/CloneDetection.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/CocoaConventions.cpp:12,Integrability,interface,interface,12,// Does the interface subclass NSObject?; // FIXME: We can memoize here if this gets too expensive.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/CocoaConventions.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/CocoaConventions.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/CocoaConventions.cpp:72,Integrability,interface,interface,72,// Assume that anything declared with a forward declaration and no; // @interface subclasses NSObject.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/CocoaConventions.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/CocoaConventions.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/ConstructionContext.cpp:58,Modifiability,extend,extended,58,"// If the object requires destruction and is not lifetime-extended,; // then it must have a BTE within its MTE, otherwise it shouldn't.; // FIXME: This should be an assertion.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/ConstructionContext.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/ConstructionContext.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/ConstructionContext.cpp:165,Testability,assert,assertion,165,"// If the object requires destruction and is not lifetime-extended,; // then it must have a BTE within its MTE, otherwise it shouldn't.; // FIXME: This should be an assertion.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/ConstructionContext.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/ConstructionContext.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/ConstructionContext.cpp:32,Modifiability,extend,extended,32,"// If the temporary is lifetime-extended, don't save the BTE,; // because we don't need a temporary destructor, but an automatic; // destructor.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/ConstructionContext.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/ConstructionContext.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/ConstructionContext.cpp:6,Testability,assert,assert,6,// No assert. We may have an elidable copy on the grandparent layer.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/ConstructionContext.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/ConstructionContext.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/ConstructionContext.cpp:64,Modifiability,layers,layers,64,// Before this point all we've had was a stockpile of arbitrary layers.; // Now validate that it is shaped as one of the finite amount of expected; // patterns.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/ConstructionContext.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/ConstructionContext.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/ConstructionContext.cpp:80,Security,validat,validate,80,// Before this point all we've had was a stockpile of arbitrary layers.; // Now validate that it is shaped as one of the finite amount of expected; // patterns.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/ConstructionContext.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/ConstructionContext.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/Consumed.cpp:689,Integrability,message,messages,689,"// TODO: Adjust states of args to constructors in the same way that arguments to; // function calls are handled.; // TODO: Use information from tests in for- and while-loop conditional.; // TODO: Add notes about the actual and expected state for; // TODO: Correctly identify unreachable blocks when chaining boolean operators.; // TODO: Adjust the parser and AttributesList class to support lists of; // identifiers.; // TODO: Warn about unreachable code.; // TODO: Switch to using a bitmap to track unreachable blocks.; // TODO: Handle variable definitions, e.g. bool valid = x.isValid();; // if (valid) ...; (Deferred); // TODO: Take notes on state transitions to provide better warning messages.; // (Deferred); // TODO: Test nested conditionals: A) Checking the same value multiple times,; // and 2) Checking different values. (Deferred)",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/Consumed.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/Consumed.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/Consumed.cpp:537,Modifiability,variab,variable,537,"// TODO: Adjust states of args to constructors in the same way that arguments to; // function calls are handled.; // TODO: Use information from tests in for- and while-loop conditional.; // TODO: Add notes about the actual and expected state for; // TODO: Correctly identify unreachable blocks when chaining boolean operators.; // TODO: Adjust the parser and AttributesList class to support lists of; // identifiers.; // TODO: Warn about unreachable code.; // TODO: Switch to using a bitmap to track unreachable blocks.; // TODO: Handle variable definitions, e.g. bool valid = x.isValid();; // if (valid) ...; (Deferred); // TODO: Take notes on state transitions to provide better warning messages.; // (Deferred); // TODO: Test nested conditionals: A) Checking the same value multiple times,; // and 2) Checking different values. (Deferred)",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/Consumed.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/Consumed.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/Consumed.cpp:144,Testability,test,tests,144,"// TODO: Adjust states of args to constructors in the same way that arguments to; // function calls are handled.; // TODO: Use information from tests in for- and while-loop conditional.; // TODO: Add notes about the actual and expected state for; // TODO: Correctly identify unreachable blocks when chaining boolean operators.; // TODO: Adjust the parser and AttributesList class to support lists of; // identifiers.; // TODO: Warn about unreachable code.; // TODO: Switch to using a bitmap to track unreachable blocks.; // TODO: Handle variable definitions, e.g. bool valid = x.isValid();; // if (valid) ...; (Deferred); // TODO: Take notes on state transitions to provide better warning messages.; // (Deferred); // TODO: Test nested conditionals: A) Checking the same value multiple times,; // and 2) Checking different values. (Deferred)",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/Consumed.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/Consumed.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/Consumed.cpp:724,Testability,Test,Test,724,"// TODO: Adjust states of args to constructors in the same way that arguments to; // function calls are handled.; // TODO: Use information from tests in for- and while-loop conditional.; // TODO: Add notes about the actual and expected state for; // TODO: Correctly identify unreachable blocks when chaining boolean operators.; // TODO: Adjust the parser and AttributesList class to support lists of; // identifiers.; // TODO: Warn about unreachable code.; // TODO: Switch to using a bitmap to track unreachable blocks.; // TODO: Handle variable definitions, e.g. bool valid = x.isValid();; // if (valid) ...; (Deferred); // TODO: Take notes on state transitions to provide better warning messages.; // (Deferred); // TODO: Test nested conditionals: A) Checking the same value multiple times,; // and 2) Checking different values. (Deferred)",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/Consumed.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/Consumed.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/Consumed.cpp:39,Deployability,update,update,39,"// If we already have info for To then update it, otherwise create a new entry.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/Consumed.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/Consumed.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/Consumed.cpp:8,Modifiability,variab,variable,8,// Skip variable argument lists.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/Consumed.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/Consumed.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/Consumed.cpp:170,Testability,test,test,170,"// FIXME: This should be removed when template instantiation propagates; // attributes at template specialization definition, not; // declaration. When it is removed the test needs to be enabled; // in SemaDeclAttr.cpp.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/Consumed.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/Consumed.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/ExprMutationAnalyzer.cpp:93,Modifiability,polymorphi,polymorphic,93,// `CXXTypeidExpr` is unevaluated unless it's; // applied to an expression of glvalue of; // polymorphic class type.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/ExprMutationAnalyzer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/ExprMutationAnalyzer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/ExprMutationAnalyzer.cpp:119,Integrability,depend,dependent,119,"// In case of a templated type, calling overloaded operators is not; // resolved and modelled as `binaryOperator` on a dependent type.; // Such instances are considered a modification, because they can modify; // in different instantiations of the template.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/ExprMutationAnalyzer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/ExprMutationAnalyzer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/ExprMutationAnalyzer.cpp:142,Integrability,depend,dependent,142,// A fold expression may contain `Exp` as it's initializer.; // We don't know if the operator modifies `Exp` because the; // operator is type dependent due to the parameter pack.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/ExprMutationAnalyzer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/ExprMutationAnalyzer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/ExprMutationAnalyzer.cpp:70,Integrability,depend,dependent,70,"// Match on a call to a known method, but the call itself is type; // dependent (e.g. `vector<T> v; v.push(T{});` in a templated function).",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/ExprMutationAnalyzer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/ExprMutationAnalyzer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/ExprMutationAnalyzer.cpp:264,Integrability,depend,dependent,264,// Previous False Positive in the following Code:; // `template <typename T> void f() { int i = 42; new Type<T>(i); }`; // Where the constructor of `Type` takes its argument as reference.; // The AST does not resolve in a `cxxConstructExpr` because it is; // type-dependent.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/ExprMutationAnalyzer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/ExprMutationAnalyzer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/ExprMutationAnalyzer.cpp:76,Modifiability,variab,variable,76,"// If the initializer is for a reference type, there is no cast for; // the variable. Values are cast to RValue first.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/ExprMutationAnalyzer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/ExprMutationAnalyzer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/ExprMutationAnalyzer.cpp:157,Modifiability,variab,variable,157,"// Keep the ordering for the specific initialization matches to happen first,; // because it is cheaper to match all potential modifications of the loop; // variable.; // The range variable is a reference to a builtin array. In that case the; // array is considered modified if the loop-variable is a non-const reference.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/ExprMutationAnalyzer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/ExprMutationAnalyzer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/ExprMutationAnalyzer.cpp:181,Modifiability,variab,variable,181,"// Keep the ordering for the specific initialization matches to happen first,; // because it is cheaper to match all potential modifications of the loop; // variable.; // The range variable is a reference to a builtin array. In that case the; // array is considered modified if the loop-variable is a non-const reference.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/ExprMutationAnalyzer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/ExprMutationAnalyzer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/ExprMutationAnalyzer.cpp:287,Modifiability,variab,variable,287,"// Keep the ordering for the specific initialization matches to happen first,; // because it is cheaper to match all potential modifications of the loop; // variable.; // The range variable is a reference to a builtin array. In that case the; // array is considered modified if the loop-variable is a non-const reference.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/ExprMutationAnalyzer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/ExprMutationAnalyzer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/ExprMutationAnalyzer.cpp:189,Modifiability,variab,variable,189,"// Small helper to match special cases in range-for loops.; //; // It is possible that containers do not provide a const-overload for their; // iterator accessors. If this is the case, the variable is used non-const; // no matter what happens in the loop. This requires special detection as it; // is then faster to find all mutations of the loop variable.; // It aims at a different modification as well.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/ExprMutationAnalyzer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/ExprMutationAnalyzer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/ExprMutationAnalyzer.cpp:347,Modifiability,variab,variable,347,"// Small helper to match special cases in range-for loops.; //; // It is possible that containers do not provide a const-overload for their; // iterator accessors. If this is the case, the variable is used non-const; // no matter what happens in the loop. This requires special detection as it; // is then faster to find all mutations of the loop variable.; // It aims at a different modification as well.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/ExprMutationAnalyzer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/ExprMutationAnalyzer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/ExprMutationAnalyzer.cpp:278,Safety,detect,detection,278,"// Small helper to match special cases in range-for loops.; //; // It is possible that containers do not provide a const-overload for their; // iterator accessors. If this is the case, the variable is used non-const; // no matter what happens in the loop. This requires special detection as it; // is then faster to find all mutations of the loop variable.; // It aims at a different modification as well.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/ExprMutationAnalyzer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/ExprMutationAnalyzer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/ExprMutationAnalyzer.cpp:153,Security,access,accessors,153,"// Small helper to match special cases in range-for loops.; //; // It is possible that containers do not provide a const-overload for their; // iterator accessors. If this is the case, the variable is used non-const; // no matter what happens in the loop. This requires special detection as it; // is then faster to find all mutations of the loop variable.; // It aims at a different modification as well.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/ExprMutationAnalyzer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/ExprMutationAnalyzer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/ExprMutationAnalyzer.cpp:67,Modifiability,variab,variable,67,"// If range for looping over 'Exp' with a non-const reference loop variable,; // check all declRefExpr of the loop variable.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/ExprMutationAnalyzer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/ExprMutationAnalyzer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/ExprMutationAnalyzer.cpp:115,Modifiability,variab,variable,115,"// If range for looping over 'Exp' with a non-const reference loop variable,; // check all declRefExpr of the loop variable.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/ExprMutationAnalyzer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/ExprMutationAnalyzer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/IntervalPartition.cpp:125,Energy Efficiency,efficient,efficient,125,"// Use a vector to maintain the insertion order. Given the expected small; // number of nodes, vector should be sufficiently efficient. Elements must not; // be null.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/IntervalPartition.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/IntervalPartition.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/IntervalPartition.cpp:18,Performance,perform,performance,18,"// FIXME: Compare performance against using RPO to consider nodes, rather than; // following successors.; //; // Elements must not be null. Duplicates are prevented using `Workset`, below.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/IntervalPartition.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/IntervalPartition.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/IntervalPartition.cpp:38,Testability,test,test,38,"// Successors are unique, so we don't test against `Workset` before; // adding to `Worklist`.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/IntervalPartition.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/IntervalPartition.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/IntervalPartition.cpp:15,Deployability,patch,patch,15,// Go back and patch up all the Intervals -- the successors and predecessors.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/IntervalPartition.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/IntervalPartition.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/IntervalPartition.cpp:105,Usability,simpl,simple,105,"// Note: given the guard above, which guarantees we only ever insert; // unique elements, we could use a simple list (like `vector`) for; // `Successors`, rather than a set.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/IntervalPartition.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/IntervalPartition.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/IntervalPartition.cpp:27,Energy Efficiency,allocate,allocated,27,// Backing storage for the allocated nodes in each graph.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/IntervalPartition.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/IntervalPartition.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/IssueHash.cpp:56,Security,hash,hashes,56,"//===---------- IssueHash.cpp - Generate identification hashes --*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/IssueHash.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/IssueHash.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/IssueHash.cpp:91,Security,hash,hash,91,// When a flow sensitive bug happens in templated code we should not generate; // distinct hash value for every instantiation. Use the signature from the; // primary template.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/IssueHash.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/IssueHash.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/LiveVariables.cpp:30,Modifiability,Variab,Variable,30,"//=- LiveVariables.cpp - Live Variable Analysis for Source CFGs ----------*-==//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements Live Variables analysis for source-level CFGs.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/LiveVariables.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/LiveVariables.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/LiveVariables.cpp:409,Modifiability,Variab,Variables,409,"//=- LiveVariables.cpp - Live Variable Analysis for Source CFGs ----------*-==//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements Live Variables analysis for source-level CFGs.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/LiveVariables.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/LiveVariables.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/LiveVariables.cpp:21,Performance,perform,performance,21,// This is a *major* performance win.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/LiveVariables.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/LiveVariables.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/LiveVariables.cpp:18,Modifiability,variab,variable,18,// Assigning to a variable?,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/LiveVariables.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/LiveVariables.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/LiveVariables.cpp:22,Modifiability,variab,variable,22,// Kill the iteration variable.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/LiveVariables.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/LiveVariables.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/LiveVariables.cpp:41,Modifiability,extend,extend,41,"// While sizeof(var) doesn't technically extend the liveness of 'var', it; // does extent the liveness of metadata if 'var' is a VariableArrayType.; // We handle that special case here.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/LiveVariables.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/LiveVariables.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/LiveVariables.cpp:129,Modifiability,Variab,VariableArrayType,129,"// While sizeof(var) doesn't technically extend the liveness of 'var', it; // does extent the liveness of metadata if 'var' is a VariableArrayType.; // We handle that special case here.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/LiveVariables.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/LiveVariables.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/LiveVariables.cpp:30,Performance,scalab,scalability,30,// The analysis currently has scalability issues for very large CFGs.; // Bail out if it looks too large.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/LiveVariables.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/LiveVariables.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/LiveVariables.cpp:3,Deployability,Update,Update,3,// Update the dataflow value for the start of this block.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/LiveVariables.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/LiveVariables.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/ObjCNoReturn.cpp:25,Integrability,message,message,25,"// Check for the ""raise"" message.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/ObjCNoReturn.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/ObjCNoReturn.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/PathDiagnostic.cpp:428,Integrability,interface,interfaces,428,"//===- PathDiagnostic.cpp - Path-Specific Diagnostic Handling -------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file defines the PathDiagnostic-related interfaces.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/PathDiagnostic.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/PathDiagnostic.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/PathDiagnostic.cpp:74,Integrability,rout,routine,74,"// Keep the PathDiagnostic with the shorter path.; // Note, the enclosing routine is called in deterministic order, so the; // results will be consistent between runs (no reason to break ties if the; // size is the same).",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/PathDiagnostic.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/PathDiagnostic.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/PathDiagnostic.cpp:3,Usability,Clear,Clear,3,// Clear out the FoldingSet.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/PathDiagnostic.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/PathDiagnostic.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/PathDiagnostic.cpp:3,Energy Efficiency,Allocate,Allocate,3,// Allocate persistent storage for the file name.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/PathDiagnostic.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/PathDiagnostic.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/PathDiagnostic.cpp:27,Testability,assert,assert,27,"// FIXME: Ironically, this assert actually fails in some cases.; //assert(L.isValid());",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/PathDiagnostic.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/PathDiagnostic.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/PathDiagnostic.cpp:67,Testability,assert,assert,67,"// FIXME: Ironically, this assert actually fails in some cases.; //assert(L.isValid());",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/PathDiagnostic.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/PathDiagnostic.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/PathDiagnostic.cpp:140,Modifiability,extend,extended,140,"// Temporary destructors are for temporaries. They die immediately at around; // the location of CXXBindTemporaryExpr. If they are lifetime-extended,; // they'd be dealt with via an AutomaticObjectDtor instead.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/PathDiagnostic.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/PathDiagnostic.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/PathDiagnostic.cpp:28,Security,access,accessors,28,"// Autosynthesized property accessors are special because we'd never; // pop back up to non-autosynthesized code until we leave them.; // This is not generally true for autosynthesized callees, which may call; // non-autosynthesized callbacks.; // Unless set here, the IsCalleeAnAutosynthesizedPropertyAccessor flag; // defaults to false.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/PathDiagnostic.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/PathDiagnostic.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/PathDiagnostic.cpp:81,Security,access,accessors,81,// We do not produce call enters and call exits for autosynthesized property; // accessors. We do generally produce them for other functions coming from; // the body farm because they may call callbacks that bring us back into; // visible code.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/PathDiagnostic.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/PathDiagnostic.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/PathDiagnostic.cpp:2,Modifiability,Extend,ExtendedDescription,2,/*ExtendedDescription=*/,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/PathDiagnostic.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/PathDiagnostic.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/PathDiagnostic.cpp:2,Modifiability,Extend,ExtendedDescription,2,/*ExtendedDescription=*/,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/PathDiagnostic.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/PathDiagnostic.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/PathDiagnostic.cpp:81,Security,access,accessors,81,// We do not produce call enters and call exits for autosynthesized property; // accessors. We do generally produce them for other functions coming from; // the body farm because they may call callbacks that bring us back into; // visible code.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/PathDiagnostic.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/PathDiagnostic.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/PathDiagnostic.cpp:2,Modifiability,Extend,ExtendedDescription,2,/*ExtendedDescription=*/,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/PathDiagnostic.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/PathDiagnostic.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/ProgramPoint.cpp:405,Integrability,interface,interface,405,"//==- ProgramPoint.cpp - Program Points for Path-Sensitive Analysis -*- C++ -*-/; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file defines the interface ProgramPoint, which identifies a; // distinct location in a function.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/ProgramPoint.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/ProgramPoint.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/ReachableCode.cpp:112,Integrability,rout,routines,112,//===----------------------------------------------------------------------===//; // Core Reachability Analysis routines.; //===----------------------------------------------------------------------===//,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/ReachableCode.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/ReachableCode.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/ReachableCode.cpp:32,Safety,predict,predictable,32,"// Temporary destructors have a predictable control flow, thus we want to; // look into the next block for the return statement.; // We look into the false branch, as we know the true branch only contains; // the call to the destructor.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/ReachableCode.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/ReachableCode.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/ReachableCode.cpp:53,Deployability,configurat,configuration,53,/// Returns true if the statement is expanded from a configuration macro.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/ReachableCode.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/ReachableCode.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/ReachableCode.cpp:53,Modifiability,config,configuration,53,/// Returns true if the statement is expanded from a configuration macro.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/ReachableCode.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/ReachableCode.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/ReachableCode.cpp:175,Testability,log,logic,175,"// FIXME: This is not very precise. Here we just check to see if the; // value comes from a macro, but we can do much better. This is likely; // to be over conservative. This logic is factored into a separate function; // so that we can refine it later.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/ReachableCode.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/ReachableCode.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/ReachableCode.cpp:95,Deployability,configurat,configuration,95,// The Objective-C constant 'YES' and 'NO'; // are defined as macros. Do not treat them; // as configuration values.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/ReachableCode.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/ReachableCode.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/ReachableCode.cpp:95,Modifiability,config,configuration,95,// The Objective-C constant 'YES' and 'NO'; // are defined as macros. Do not treat them; // as configuration values.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/ReachableCode.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/ReachableCode.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/ReachableCode.cpp:47,Deployability,configurat,configuration,47,// Do not treat C 'false' and 'true' macros as configuration values.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/ReachableCode.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/ReachableCode.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/ReachableCode.cpp:47,Modifiability,config,configuration,47,// Do not treat C 'false' and 'true' macros as configuration values.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/ReachableCode.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/ReachableCode.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/ReachableCode.cpp:329,Availability,mask,mask,329,"/// Returns true if the statement represents a configuration value.; ///; /// A configuration value is something usually determined at compile-time; /// to conditionally always execute some branch. Such guards are for; /// ""sometimes unreachable"" code. Such code is usually not interesting; /// to report as unreachable, and may mask truly unreachable code within; /// those blocks.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/ReachableCode.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/ReachableCode.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/ReachableCode.cpp:47,Deployability,configurat,configuration,47,"/// Returns true if the statement represents a configuration value.; ///; /// A configuration value is something usually determined at compile-time; /// to conditionally always execute some branch. Such guards are for; /// ""sometimes unreachable"" code. Such code is usually not interesting; /// to report as unreachable, and may mask truly unreachable code within; /// those blocks.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/ReachableCode.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/ReachableCode.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/ReachableCode.cpp:80,Deployability,configurat,configuration,80,"/// Returns true if the statement represents a configuration value.; ///; /// A configuration value is something usually determined at compile-time; /// to conditionally always execute some branch. Such guards are for; /// ""sometimes unreachable"" code. Such code is usually not interesting; /// to report as unreachable, and may mask truly unreachable code within; /// those blocks.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/ReachableCode.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/ReachableCode.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/ReachableCode.cpp:47,Modifiability,config,configuration,47,"/// Returns true if the statement represents a configuration value.; ///; /// A configuration value is something usually determined at compile-time; /// to conditionally always execute some branch. Such guards are for; /// ""sometimes unreachable"" code. Such code is usually not interesting; /// to report as unreachable, and may mask truly unreachable code within; /// those blocks.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/ReachableCode.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/ReachableCode.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/ReachableCode.cpp:80,Modifiability,config,configuration,80,"/// Returns true if the statement represents a configuration value.; ///; /// A configuration value is something usually determined at compile-time; /// to conditionally always execute some branch. Such guards are for; /// ""sometimes unreachable"" code. Such code is usually not interesting; /// to report as unreachable, and may mask truly unreachable code within; /// those blocks.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/ReachableCode.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/ReachableCode.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/ReachableCode.cpp:44,Deployability,configurat,configuration,44,// Only include raw integers (not enums) as configuration; // values if they are used in a logical or comparison operator; // (not arithmetic).,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/ReachableCode.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/ReachableCode.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/ReachableCode.cpp:44,Modifiability,config,configuration,44,// Only include raw integers (not enums) as configuration; // values if they are used in a logical or comparison operator; // (not arithmetic).,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/ReachableCode.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/ReachableCode.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/ReachableCode.cpp:91,Testability,log,logical,91,// Only include raw integers (not enums) as configuration; // values if they are used in a logical or comparison operator; // (not arithmetic).,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/ReachableCode.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/ReachableCode.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/ReachableCode.cpp:3,Deployability,Update,Update,3,// Update the silenceable condition value source range only if the range; // was set directly by the child expression.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/ReachableCode.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/ReachableCode.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/ReachableCode.cpp:36,Deployability,configurat,configuration,36,"// As a heuristic, treat globals as configuration values. Note; // that we only will get here if Sema evaluated this; // condition to a constant expression, which means the global; // had to be declared in a way to be a truly constant value.; // We could generalize this to local variables, but it isn't; // clear if those truly represent configuration values that; // gate unreachable code.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/ReachableCode.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/ReachableCode.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/ReachableCode.cpp:339,Deployability,configurat,configuration,339,"// As a heuristic, treat globals as configuration values. Note; // that we only will get here if Sema evaluated this; // condition to a constant expression, which means the global; // had to be declared in a way to be a truly constant value.; // We could generalize this to local variables, but it isn't; // clear if those truly represent configuration values that; // gate unreachable code.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/ReachableCode.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/ReachableCode.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/ReachableCode.cpp:36,Modifiability,config,configuration,36,"// As a heuristic, treat globals as configuration values. Note; // that we only will get here if Sema evaluated this; // condition to a constant expression, which means the global; // had to be declared in a way to be a truly constant value.; // We could generalize this to local variables, but it isn't; // clear if those truly represent configuration values that; // gate unreachable code.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/ReachableCode.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/ReachableCode.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/ReachableCode.cpp:280,Modifiability,variab,variables,280,"// As a heuristic, treat globals as configuration values. Note; // that we only will get here if Sema evaluated this; // condition to a constant expression, which means the global; // had to be declared in a way to be a truly constant value.; // We could generalize this to local variables, but it isn't; // clear if those truly represent configuration values that; // gate unreachable code.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/ReachableCode.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/ReachableCode.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/ReachableCode.cpp:339,Modifiability,config,configuration,339,"// As a heuristic, treat globals as configuration values. Note; // that we only will get here if Sema evaluated this; // condition to a constant expression, which means the global; // had to be declared in a way to be a truly constant value.; // We could generalize this to local variables, but it isn't; // clear if those truly represent configuration values that; // gate unreachable code.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/ReachableCode.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/ReachableCode.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/ReachableCode.cpp:308,Usability,clear,clear,308,"// As a heuristic, treat globals as configuration values. Note; // that we only will get here if Sema evaluated this; // condition to a constant expression, which means the global; // had to be declared in a way to be a truly constant value.; // We could generalize this to local variables, but it isn't; // clear if those truly represent configuration values that; // gate unreachable code.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/ReachableCode.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/ReachableCode.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/ReachableCode.cpp:89,Deployability,configurat,configuration,89,"// As a heuristic, locals that have been marked 'const' explicitly; // can be treated as configuration values as well.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/ReachableCode.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/ReachableCode.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/ReachableCode.cpp:89,Modifiability,config,configuration,89,"// As a heuristic, locals that have been marked 'const' explicitly; // can be treated as configuration values as well.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/ReachableCode.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/ReachableCode.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/ReachableCode.cpp:13,Performance,queue,queue,13,// Prep work queue,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/ReachableCode.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/ReachableCode.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/ReachableCode.cpp:68,Deployability,configurat,configuration,68,// Check if the dead block has a predecessor whose branch has; // a configuration value that *could* be modified to; // silence the warning.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/ReachableCode.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/ReachableCode.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/ReachableCode.cpp:68,Modifiability,config,configuration,68,// Check if the dead block has a predecessor whose branch has; // a configuration value that *could* be modified to; // silence the warning.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/ReachableCode.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/ReachableCode.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/RetainSummaryManager.cpp:11,Usability,simpl,simple,11,"// Unique ""simple"" summaries -- those without ArgEffects.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/RetainSummaryManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/RetainSummaryManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/RetainSummaryManager.cpp:145,Integrability,contract,contract,145,// TODO: Add support for the slightly common *Matching(table) idiom.; // Cf. IOService::nameMatching() etc. - these function have an unusual; // contract of returning at +0 or +1 depending on their last argument.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/RetainSummaryManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/RetainSummaryManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/RetainSummaryManager.cpp:179,Integrability,depend,depending,179,// TODO: Add support for the slightly common *Matching(table) idiom.; // Cf. IOService::nameMatching() etc. - these function have an unusual; // contract of returning at +0 or +1 depending on their last argument.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/RetainSummaryManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/RetainSummaryManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/RetainSummaryManager.cpp:91,Deployability,release,release,91,"// It's not uncommon to pass a tracked object into the thread; // as 'void *arg', and then release it inside the thread.; // FIXME: We could build a much more precise model for these functions.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/RetainSummaryManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/RetainSummaryManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/RetainSummaryManager.cpp:58,Integrability,wrap,wrapper,58,// These API functions are known to NOT act as a CFRetain wrapper.; // They simply make a new object owned by the caller.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/RetainSummaryManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/RetainSummaryManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/RetainSummaryManager.cpp:76,Usability,simpl,simply,76,// These API functions are known to NOT act as a CFRetain wrapper.; // They simply make a new object owned by the caller.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/RetainSummaryManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/RetainSummaryManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/RetainSummaryManager.cpp:118,Deployability,release,released,118,"// Eventually this can be improved by recognizing that the pixel; // buffer passed to CVPixelBufferCreateWithBytes is released via; // a callback and doing full IPA to make sure this is done correctly.; // Note that it's passed as a 'void *', so it's hard to annotate.; // FIXME: This function also has an out parameter that returns an; // allocated object.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/RetainSummaryManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/RetainSummaryManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/RetainSummaryManager.cpp:340,Energy Efficiency,allocate,allocated,340,"// Eventually this can be improved by recognizing that the pixel; // buffer passed to CVPixelBufferCreateWithBytes is released via; // a callback and doing full IPA to make sure this is done correctly.; // Note that it's passed as a 'void *', so it's hard to annotate.; // FIXME: This function also has an out parameter that returns an; // allocated object.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/RetainSummaryManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/RetainSummaryManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/RetainSummaryManager.cpp:129,Deployability,release,releaseInfo,129,// This is similar to the CVPixelBufferCreateWithBytes situation above.; // Eventually this can be improved by recognizing that 'releaseInfo'; // passed to CGBitmapContextCreateWithData is released via; // a callback and doing full IPA to make sure this is done correctly.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/RetainSummaryManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/RetainSummaryManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/RetainSummaryManager.cpp:189,Deployability,release,released,189,// This is similar to the CVPixelBufferCreateWithBytes situation above.; // Eventually this can be improved by recognizing that 'releaseInfo'; // passed to CGBitmapContextCreateWithData is released via; // a callback and doing full IPA to make sure this is done correctly.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/RetainSummaryManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/RetainSummaryManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/RetainSummaryManager.cpp:196,Deployability,release,release,196,"// The context argument passed to VTCompressionSessionEncodeFrame() et.al.; // is passed to the callback specified when creating the session; // (e.g. with VTCompressionSessionCreate()) which can release it.; // To account for this possibility, conservatively stop tracking; // the context.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/RetainSummaryManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/RetainSummaryManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/RetainSummaryManager.cpp:90,Safety,safe,safe,90,"// CFRetain isn't supposed to be annotated. However, this may as; // well be a user-made ""safe"" CFRetain function that is incorrectly; // annotated as cf_returns_retained due to lack of better options.; // We want to ignore such annotation.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/RetainSummaryManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/RetainSummaryManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/RetainSummaryManager.cpp:13,Deployability,release,release,13,"// Check for release functions, the only kind of functions that we care; // about that don't return a pointer type.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/RetainSummaryManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/RetainSummaryManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/RetainSummaryManager.cpp:3,Testability,Test,Test,3,// Test for 'CGCF'.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/RetainSummaryManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/RetainSummaryManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/RetainSummaryManager.cpp:76,Availability,down,down,76,// Strip away preceding '_'. Doing this here will effect all the checks; // down below.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/RetainSummaryManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/RetainSummaryManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/RetainSummaryManager.cpp:28,Performance,cache,cache,28,// Look up a summary in our cache of FunctionDecls -> Summaries.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/RetainSummaryManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/RetainSummaryManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/RetainSummaryManager.cpp:58,Integrability,wrap,wrapper,58,// These API functions are known to NOT act as a CFRetain wrapper.; // They simply make a new object owned by the caller.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/RetainSummaryManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/RetainSummaryManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/RetainSummaryManager.cpp:76,Usability,simpl,simply,76,// These API functions are known to NOT act as a CFRetain wrapper.; // They simply make a new object owned by the caller.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/RetainSummaryManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/RetainSummaryManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/RetainSummaryManager.cpp:3,Safety,safe,safeMetaCast,3,"// safeMetaCast is called by OSDynamicCast.; // We assume that OSDynamicCast is either an identity (cast is OK,; // the input was non-zero),; // or that it returns zero (when the cast failed, or the input; // was zero).",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/RetainSummaryManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/RetainSummaryManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/RetainSummaryManager.cpp:130,Availability,failure,failure,130,"// For others:; // Do nothing. Retained out parameters will either point to a +1 reference; // or NULL, but the way you check for failure differs depending on the; // API. Consequently, we don't have a good way to track them yet.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/RetainSummaryManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/RetainSummaryManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/RetainSummaryManager.cpp:146,Integrability,depend,depending,146,"// For others:; // Do nothing. Retained out parameters will either point to a +1 reference; // or NULL, but the way you check for failure differs depending on the; // API. Consequently, we don't have a good way to track them yet.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/RetainSummaryManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/RetainSummaryManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/RetainSummaryManager.cpp:105,Performance,perform,performSelector,105,"// Assume all Objective-C methods follow Cocoa Memory Management rules.; // FIXME: Does the non-threaded performSelector family really belong here?; // The selector could be, say, @selector(copy).",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/RetainSummaryManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/RetainSummaryManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/RetainSummaryManager.cpp:141,Performance,perform,performSelector,141,"// FIXME: The receiver could be a reference to a class, meaning that; // we should use the class method.; // id x = [NSObject class];; // [x performSelector:... withObject:... afterDelay:...];",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/RetainSummaryManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/RetainSummaryManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/RetainSummaryManager.cpp:36,Performance,cache,cache,36,// Look up a summary in our summary cache.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/RetainSummaryManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/RetainSummaryManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/RetainSummaryManager.cpp:15,Deployability,release,release,15,"// Create the ""release"" selector.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/RetainSummaryManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/RetainSummaryManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/RetainSummaryManager.cpp:17,Energy Efficiency,allocate,allocated,17,"// For NSWindow, allocated objects are (initially) self-owned.; // FIXME: For now we opt for false negatives with NSWindow, as these objects; // self-own themselves. However, they only do this once they are displayed.; // Thus, we need to track an NSWindow's display status.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/RetainSummaryManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/RetainSummaryManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/RetainSummaryManager.cpp:44,Energy Efficiency,allocate,allocated,44,"// For NSPanel (which subclasses NSWindow), allocated objects are not; // self-owned.; // FIXME: For now we don't track NSPanels. object for the same reason; // as for NSWindow objects.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/RetainSummaryManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/RetainSummaryManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/RetainSummaryManager.cpp:79,Deployability,release,release,79,"// For NSNull, objects returned by +null are singletons that ignore; // retain/release semantics. Just don't track them.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/RetainSummaryManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/RetainSummaryManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/RetainSummaryManager.cpp:15,Energy Efficiency,allocate,allocated,15,"// Don't track allocated autorelease pools, as it is okay to prematurely; // exit a method.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/RetainSummaryManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/RetainSummaryManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/ThreadSafety.cpp:422,Safety,safe,safety,422,"//===- ThreadSafety.cpp ---------------------------------------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // A intra-procedural analysis for thread safety (e.g. deadlocks and race; // conditions), based off of an annotation system.; //; // See http://clang.llvm.org/docs/ThreadSafetyAnalysis.html; // for more information.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/ThreadSafety.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/ThreadSafety.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/ThreadSafety.cpp:68,Safety,safe,safety,68,"/// A set of CapabilityExpr objects, which are compiled from thread safety; /// attributes on a function.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/ThreadSafety.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/ThreadSafety.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/ThreadSafety.cpp:23,Testability,assert,asserted,23,///< The fact has been asserted to be held.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/ThreadSafety.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/ThreadSafety.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/ThreadSafety.cpp:103,Integrability,rout,routine,103,/// FactManager manages the memory for all facts that are created during; /// the analysis of a single routine.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/ThreadSafety.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/ThreadSafety.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/ThreadSafety.cpp:376,Security,hash,hashtable,376,"/// A FactSet is the set of facts that are known to be true at a; /// particular program point. FactSets must be small, because they are; /// frequently copied, and are thus implemented as a set of indices into a; /// table maintained by a FactManager. A typical FactSet only holds 1 or 2; /// locks, so we can get away with doing a linear search for lookup. Note; /// that a hashtable or map is inappropriate in this case, because lookups; /// may involve partial pattern matches, rather than exact matches.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/ThreadSafety.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/ThreadSafety.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/ThreadSafety.cpp:49,Modifiability,variab,variables,49,"// A LocalVariableMap maintains a map from local variables to their currently; // valid definitions. It provides SSA-like functionality when traversing the; // CFG. Like SSA, each definition or assignment to a variable is assigned a; // unique name (an integer), which acts as the SSA name for that definition.; // The total set of names is shared among all CFG basic blocks.; // Unlike SSA, we do not rewrite expressions to replace local variables declrefs; // with their SSA-names. Instead, we compute a Context for each point in the; // code, which maps local variables to the appropriate SSA-name. This map; // changes with each assignment.; //; // The map is computed in a single pass over the CFG. Subsequent analyses can; // then query the map to find the appropriate Context for a statement, and use; // that Context to look up the definitions of variables.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/ThreadSafety.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/ThreadSafety.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/ThreadSafety.cpp:210,Modifiability,variab,variable,210,"// A LocalVariableMap maintains a map from local variables to their currently; // valid definitions. It provides SSA-like functionality when traversing the; // CFG. Like SSA, each definition or assignment to a variable is assigned a; // unique name (an integer), which acts as the SSA name for that definition.; // The total set of names is shared among all CFG basic blocks.; // Unlike SSA, we do not rewrite expressions to replace local variables declrefs; // with their SSA-names. Instead, we compute a Context for each point in the; // code, which maps local variables to the appropriate SSA-name. This map; // changes with each assignment.; //; // The map is computed in a single pass over the CFG. Subsequent analyses can; // then query the map to find the appropriate Context for a statement, and use; // that Context to look up the definitions of variables.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/ThreadSafety.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/ThreadSafety.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/ThreadSafety.cpp:402,Modifiability,rewrite,rewrite,402,"// A LocalVariableMap maintains a map from local variables to their currently; // valid definitions. It provides SSA-like functionality when traversing the; // CFG. Like SSA, each definition or assignment to a variable is assigned a; // unique name (an integer), which acts as the SSA name for that definition.; // The total set of names is shared among all CFG basic blocks.; // Unlike SSA, we do not rewrite expressions to replace local variables declrefs; // with their SSA-names. Instead, we compute a Context for each point in the; // code, which maps local variables to the appropriate SSA-name. This map; // changes with each assignment.; //; // The map is computed in a single pass over the CFG. Subsequent analyses can; // then query the map to find the appropriate Context for a statement, and use; // that Context to look up the definitions of variables.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/ThreadSafety.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/ThreadSafety.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/ThreadSafety.cpp:439,Modifiability,variab,variables,439,"// A LocalVariableMap maintains a map from local variables to their currently; // valid definitions. It provides SSA-like functionality when traversing the; // CFG. Like SSA, each definition or assignment to a variable is assigned a; // unique name (an integer), which acts as the SSA name for that definition.; // The total set of names is shared among all CFG basic blocks.; // Unlike SSA, we do not rewrite expressions to replace local variables declrefs; // with their SSA-names. Instead, we compute a Context for each point in the; // code, which maps local variables to the appropriate SSA-name. This map; // changes with each assignment.; //; // The map is computed in a single pass over the CFG. Subsequent analyses can; // then query the map to find the appropriate Context for a statement, and use; // that Context to look up the definitions of variables.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/ThreadSafety.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/ThreadSafety.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/ThreadSafety.cpp:563,Modifiability,variab,variables,563,"// A LocalVariableMap maintains a map from local variables to their currently; // valid definitions. It provides SSA-like functionality when traversing the; // CFG. Like SSA, each definition or assignment to a variable is assigned a; // unique name (an integer), which acts as the SSA name for that definition.; // The total set of names is shared among all CFG basic blocks.; // Unlike SSA, we do not rewrite expressions to replace local variables declrefs; // with their SSA-names. Instead, we compute a Context for each point in the; // code, which maps local variables to the appropriate SSA-name. This map; // changes with each assignment.; //; // The map is computed in a single pass over the CFG. Subsequent analyses can; // then query the map to find the appropriate Context for a statement, and use; // that Context to look up the definitions of variables.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/ThreadSafety.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/ThreadSafety.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/ThreadSafety.cpp:855,Modifiability,variab,variables,855,"// A LocalVariableMap maintains a map from local variables to their currently; // valid definitions. It provides SSA-like functionality when traversing the; // CFG. Like SSA, each definition or assignment to a variable is assigned a; // unique name (an integer), which acts as the SSA name for that definition.; // The total set of names is shared among all CFG basic blocks.; // Unlike SSA, we do not rewrite expressions to replace local variables declrefs; // with their SSA-names. Instead, we compute a Context for each point in the; // code, which maps local variables to the appropriate SSA-name. This map; // changes with each assignment.; //; // The map is computed in a single pass over the CFG. Subsequent analyses can; // then query the map to find the appropriate Context for a statement, and use; // that Context to look up the definitions of variables.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/ThreadSafety.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/ThreadSafety.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/ThreadSafety.cpp:82,Modifiability,variab,variable,82,"/// A VarDefinition consists of an expression, representing the value of the; /// variable, along with the context in which that expression should be; /// interpreted. A reference VarDefinition does not itself contain this; /// information, but instead contains a pointer to a previous VarDefinition.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/ThreadSafety.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/ThreadSafety.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/ThreadSafety.cpp:37,Modifiability,variab,variable,37,// The original declaration for this variable.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/ThreadSafety.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/ThreadSafety.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/ThreadSafety.cpp:27,Modifiability,variab,variable,27,"// The expression for this variable, OR",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/ThreadSafety.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/ThreadSafety.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/ThreadSafety.cpp:19,Modifiability,variab,variable,19,// Create ordinary variable definition,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/ThreadSafety.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/ThreadSafety.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/ThreadSafety.cpp:42,Modifiability,variab,variables,42,// index 0 is a placeholder for undefined variables (aka phi-nodes).,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/ThreadSafety.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/ThreadSafety.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/ThreadSafety.cpp:41,Modifiability,variab,variable,41,/// Dumps an ASCII representation of the variable map to llvm::errs(),MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/ThreadSafety.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/ThreadSafety.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/ThreadSafety.cpp:15,Modifiability,variab,variable,15,/// Builds the variable map.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/ThreadSafety.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/ThreadSafety.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/ThreadSafety.cpp:128,Modifiability,variab,variable,128,"// Adds a new definition to the given context, and returns a new context.; // This method should be called when declaring a new variable.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/ThreadSafety.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/ThreadSafety.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/ThreadSafety.cpp:3,Deployability,Update,Updates,3,// Updates a definition only if that definition is already in the map.; // This method should be called when assigning to an existing variable.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/ThreadSafety.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/ThreadSafety.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/ThreadSafety.cpp:134,Modifiability,variab,variable,134,// Updates a definition only if that definition is already in the map.; // This method should be called when assigning to an existing variable.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/ThreadSafety.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/ThreadSafety.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/ThreadSafety.cpp:56,Modifiability,variab,variable,56,"// Removes a definition from the context, but keeps the variable name; // as a valid variable. The index 0 is a placeholder for cleared definitions.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/ThreadSafety.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/ThreadSafety.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/ThreadSafety.cpp:85,Modifiability,variab,variable,85,"// Removes a definition from the context, but keeps the variable name; // as a valid variable. The index 0 is a placeholder for cleared definitions.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/ThreadSafety.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/ThreadSafety.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/ThreadSafety.cpp:128,Usability,clear,cleared,128,"// Removes a definition from the context, but keeps the variable name; // as a valid variable. The index 0 is a placeholder for cleared definitions.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/ThreadSafety.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/ThreadSafety.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/ThreadSafety.cpp:31,Modifiability,variab,variables,31,// namespace; // Add new local variables to the variable map,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/ThreadSafety.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/ThreadSafety.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/ThreadSafety.cpp:48,Modifiability,variab,variable,48,// namespace; // Add new local variables to the variable map,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/ThreadSafety.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/ThreadSafety.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/ThreadSafety.cpp:13,Modifiability,variab,variables,13,// Add local variables with trivial type to the variable map,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/ThreadSafety.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/ThreadSafety.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/ThreadSafety.cpp:48,Modifiability,variab,variable,48,// Add local variables with trivial type to the variable map,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/ThreadSafety.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/ThreadSafety.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/ThreadSafety.cpp:3,Deployability,Update,Update,3,// Update local variable definitions in variable map,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/ThreadSafety.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/ThreadSafety.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/ThreadSafety.cpp:16,Modifiability,variab,variable,16,// Update local variable definitions in variable map,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/ThreadSafety.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/ThreadSafety.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/ThreadSafety.cpp:40,Modifiability,variab,variable,40,// Update local variable definitions in variable map,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/ThreadSafety.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/ThreadSafety.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/ThreadSafety.cpp:3,Deployability,Update,Update,3,// Update the variable map and current context.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/ThreadSafety.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/ThreadSafety.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/ThreadSafety.cpp:14,Modifiability,variab,variable,14,// Update the variable map and current context.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/ThreadSafety.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/ThreadSafety.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/ThreadSafety.cpp:81,Modifiability,variab,variables,81,// Computes the intersection of two contexts. The intersection is the; // set of variables which have the same definition in both contexts;; // variables with different definitions are discarded.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/ThreadSafety.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/ThreadSafety.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/ThreadSafety.cpp:144,Modifiability,variab,variables,144,// Computes the intersection of two contexts. The intersection is the; // set of variables which have the same definition in both contexts;; // variables with different definitions are discarded.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/ThreadSafety.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/ThreadSafety.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/ThreadSafety.cpp:3,Modifiability,variab,variable,3,// variable doesn't exist on second path,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/ThreadSafety.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/ThreadSafety.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/ThreadSafety.cpp:3,Modifiability,variab,variable,3,"// variable exists, but has different definition",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/ThreadSafety.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/ThreadSafety.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/ThreadSafety.cpp:13,Modifiability,variab,variable,13,"// For every variable in C, create a new variable that refers to the; // definition in C. Return a new context that contains these new variables.; // (We use this for a naive implementation of SSA on loop back-edges.)",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/ThreadSafety.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/ThreadSafety.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/ThreadSafety.cpp:41,Modifiability,variab,variable,41,"// For every variable in C, create a new variable that refers to the; // definition in C. Return a new context that contains these new variables.; // (We use this for a naive implementation of SSA on loop back-edges.)",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/ThreadSafety.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/ThreadSafety.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/ThreadSafety.cpp:135,Modifiability,variab,variables,135,"// For every variable in C, create a new variable that refers to the; // definition in C. Return a new context that contains these new variables.; // (We use this for a naive implementation of SSA on loop back-edges.)",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/ThreadSafety.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/ThreadSafety.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/ThreadSafety.cpp:8,Integrability,rout,routine,8,"// This routine also takes the intersection of C1 and C2, but it does so by; // altering the VarDefinitions. C1 must be the result of an earlier call to; // createReferenceContext.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/ThreadSafety.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/ThreadSafety.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/ThreadSafety.cpp:13,Modifiability,variab,variable,13,// Mark this variable as undefined,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/ThreadSafety.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/ThreadSafety.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/ThreadSafety.cpp:219,Modifiability,variab,variable,219,"// Traverse the CFG in topological order, so all predecessors of a block; // (excluding back-edges) are visited before the block itself. At; // each point in the code, we calculate a Context, which holds the set of; // variable definitions which are visible at that point in execution.; // Visible variables are mapped to their definitions using an array that; // contains all definitions.; //; // At join points in the CFG, the set is computed as the intersection of; // the incoming sets along each edge, E.g.; //; // { Context | VarDefinitions }; // int x = 0; { x -> x1 | x1 = 0 }; // int y = 0; { x -> x1, y -> y1 | y1 = 0, x1 = 0 }; // if (b) x = 1; { x -> x2, y -> y1 | x2 = 1, y1 = 0, ... }; // else x = 2; { x -> x3, y -> y1 | x3 = 2, x2 = 1, ... }; // ... { y -> y1 (x is unknown) | x3 = 2, x2 = 1, ... }; //; // This is essentially a simpler and more naive version of the standard SSA; // algorithm. Those definitions that remain in the intersection are from blocks; // that strictly dominate the current block. We do not bother to insert proper; // phi nodes, because they are not used in our analysis; instead, wherever; // a phi node would be required, we simply remove that definition from the; // context (E.g. x above).; //; // The initial traversal does not capture back-edges, so those need to be; // handled on a separate pass. Whenever the first pass encounters an; // incoming back edge, it duplicates the context, creating new definitions; // that refer back to the originals. (These correspond to places where SSA; // might have to insert a phi node.) On the second pass, these definitions are; // set to NULL if the variable has changed on the back-edge (i.e. a phi; // node was actually required.) E.g.; //; // { Context | VarDefinitions }; // int x = 0, y = 0; { x -> x1, y -> y1 | y1 = 0, x1 = 0 }; // while (b) { x -> x2, y -> y1 | [1st:] x2=x1; [2nd:] x2=NULL; }; // x = x+1; { x -> x3, y -> y1 | x3 = x2 + 1, ... }; // ... { y -> y1 | x3 = 2, x2 = 1, ... }",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/ThreadSafety.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/ThreadSafety.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/ThreadSafety.cpp:298,Modifiability,variab,variables,298,"// Traverse the CFG in topological order, so all predecessors of a block; // (excluding back-edges) are visited before the block itself. At; // each point in the code, we calculate a Context, which holds the set of; // variable definitions which are visible at that point in execution.; // Visible variables are mapped to their definitions using an array that; // contains all definitions.; //; // At join points in the CFG, the set is computed as the intersection of; // the incoming sets along each edge, E.g.; //; // { Context | VarDefinitions }; // int x = 0; { x -> x1 | x1 = 0 }; // int y = 0; { x -> x1, y -> y1 | y1 = 0, x1 = 0 }; // if (b) x = 1; { x -> x2, y -> y1 | x2 = 1, y1 = 0, ... }; // else x = 2; { x -> x3, y -> y1 | x3 = 2, x2 = 1, ... }; // ... { y -> y1 (x is unknown) | x3 = 2, x2 = 1, ... }; //; // This is essentially a simpler and more naive version of the standard SSA; // algorithm. Those definitions that remain in the intersection are from blocks; // that strictly dominate the current block. We do not bother to insert proper; // phi nodes, because they are not used in our analysis; instead, wherever; // a phi node would be required, we simply remove that definition from the; // context (E.g. x above).; //; // The initial traversal does not capture back-edges, so those need to be; // handled on a separate pass. Whenever the first pass encounters an; // incoming back edge, it duplicates the context, creating new definitions; // that refer back to the originals. (These correspond to places where SSA; // might have to insert a phi node.) On the second pass, these definitions are; // set to NULL if the variable has changed on the back-edge (i.e. a phi; // node was actually required.) E.g.; //; // { Context | VarDefinitions }; // int x = 0, y = 0; { x -> x1, y -> y1 | y1 = 0, x1 = 0 }; // while (b) { x -> x2, y -> y1 | [1st:] x2=x1; [2nd:] x2=NULL; }; // x = x+1; { x -> x3, y -> y1 | x3 = x2 + 1, ... }; // ... { y -> y1 | x3 = 2, x2 = 1, ... }",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/ThreadSafety.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/ThreadSafety.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/ThreadSafety.cpp:1641,Modifiability,variab,variable,1641,"// Traverse the CFG in topological order, so all predecessors of a block; // (excluding back-edges) are visited before the block itself. At; // each point in the code, we calculate a Context, which holds the set of; // variable definitions which are visible at that point in execution.; // Visible variables are mapped to their definitions using an array that; // contains all definitions.; //; // At join points in the CFG, the set is computed as the intersection of; // the incoming sets along each edge, E.g.; //; // { Context | VarDefinitions }; // int x = 0; { x -> x1 | x1 = 0 }; // int y = 0; { x -> x1, y -> y1 | y1 = 0, x1 = 0 }; // if (b) x = 1; { x -> x2, y -> y1 | x2 = 1, y1 = 0, ... }; // else x = 2; { x -> x3, y -> y1 | x3 = 2, x2 = 1, ... }; // ... { y -> y1 (x is unknown) | x3 = 2, x2 = 1, ... }; //; // This is essentially a simpler and more naive version of the standard SSA; // algorithm. Those definitions that remain in the intersection are from blocks; // that strictly dominate the current block. We do not bother to insert proper; // phi nodes, because they are not used in our analysis; instead, wherever; // a phi node would be required, we simply remove that definition from the; // context (E.g. x above).; //; // The initial traversal does not capture back-edges, so those need to be; // handled on a separate pass. Whenever the first pass encounters an; // incoming back edge, it duplicates the context, creating new definitions; // that refer back to the originals. (These correspond to places where SSA; // might have to insert a phi node.) On the second pass, these definitions are; // set to NULL if the variable has changed on the back-edge (i.e. a phi; // node was actually required.) E.g.; //; // { Context | VarDefinitions }; // int x = 0, y = 0; { x -> x1, y -> y1 | y1 = 0, x1 = 0 }; // while (b) { x -> x2, y -> y1 | [1st:] x2=x1; [2nd:] x2=NULL; }; // x = x+1; { x -> x3, y -> y1 | x3 = x2 + 1, ... }; // ... { y -> y1 | x3 = 2, x2 = 1, ... }",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/ThreadSafety.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/ThreadSafety.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/ThreadSafety.cpp:845,Usability,simpl,simpler,845,"// Traverse the CFG in topological order, so all predecessors of a block; // (excluding back-edges) are visited before the block itself. At; // each point in the code, we calculate a Context, which holds the set of; // variable definitions which are visible at that point in execution.; // Visible variables are mapped to their definitions using an array that; // contains all definitions.; //; // At join points in the CFG, the set is computed as the intersection of; // the incoming sets along each edge, E.g.; //; // { Context | VarDefinitions }; // int x = 0; { x -> x1 | x1 = 0 }; // int y = 0; { x -> x1, y -> y1 | y1 = 0, x1 = 0 }; // if (b) x = 1; { x -> x2, y -> y1 | x2 = 1, y1 = 0, ... }; // else x = 2; { x -> x3, y -> y1 | x3 = 2, x2 = 1, ... }; // ... { y -> y1 (x is unknown) | x3 = 2, x2 = 1, ... }; //; // This is essentially a simpler and more naive version of the standard SSA; // algorithm. Those definitions that remain in the intersection are from blocks; // that strictly dominate the current block. We do not bother to insert proper; // phi nodes, because they are not used in our analysis; instead, wherever; // a phi node would be required, we simply remove that definition from the; // context (E.g. x above).; //; // The initial traversal does not capture back-edges, so those need to be; // handled on a separate pass. Whenever the first pass encounters an; // incoming back edge, it duplicates the context, creating new definitions; // that refer back to the originals. (These correspond to places where SSA; // might have to insert a phi node.) On the second pass, these definitions are; // set to NULL if the variable has changed on the back-edge (i.e. a phi; // node was actually required.) E.g.; //; // { Context | VarDefinitions }; // int x = 0, y = 0; { x -> x1, y -> y1 | y1 = 0, x1 = 0 }; // while (b) { x -> x2, y -> y1 | [1st:] x2=x1; [2nd:] x2=NULL; }; // x = x+1; { x -> x3, y -> y1 | x3 = x2 + 1, ... }; // ... { y -> y1 | x3 = 2, x2 = 1, ... }",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/ThreadSafety.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/ThreadSafety.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/ThreadSafety.cpp:1170,Usability,simpl,simply,1170,"// Traverse the CFG in topological order, so all predecessors of a block; // (excluding back-edges) are visited before the block itself. At; // each point in the code, we calculate a Context, which holds the set of; // variable definitions which are visible at that point in execution.; // Visible variables are mapped to their definitions using an array that; // contains all definitions.; //; // At join points in the CFG, the set is computed as the intersection of; // the incoming sets along each edge, E.g.; //; // { Context | VarDefinitions }; // int x = 0; { x -> x1 | x1 = 0 }; // int y = 0; { x -> x1, y -> y1 | y1 = 0, x1 = 0 }; // if (b) x = 1; { x -> x2, y -> y1 | x2 = 1, y1 = 0, ... }; // else x = 2; { x -> x3, y -> y1 | x3 = 2, x2 = 1, ... }; // ... { y -> y1 (x is unknown) | x3 = 2, x2 = 1, ... }; //; // This is essentially a simpler and more naive version of the standard SSA; // algorithm. Those definitions that remain in the intersection are from blocks; // that strictly dominate the current block. We do not bother to insert proper; // phi nodes, because they are not used in our analysis; instead, wherever; // a phi node would be required, we simply remove that definition from the; // context (E.g. x above).; //; // The initial traversal does not capture back-edges, so those need to be; // handled on a separate pass. Whenever the first pass encounters an; // incoming back edge, it duplicates the context, creating new definitions; // that refer back to the originals. (These correspond to places where SSA; // might have to insert a phi node.) On the second pass, these definitions are; // set to NULL if the variable has changed on the back-edge (i.e. a phi; // node was actually required.) E.g.; //; // { Context | VarDefinitions }; // int x = 0, y = 0; { x -> x1, y -> y1 | y1 = 0, x1 = 0 }; // while (b) { x -> x2, y -> y1 | [1st:] x2=x1; [2nd:] x2=NULL; }; // x = x+1; { x -> x3, y -> y1 | x3 = x2 + 1, ... }; // ... { y -> y1 | x3 = 2, x2 = 1, ... }",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/ThreadSafety.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/ThreadSafety.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/ThreadSafety.cpp:8,Modifiability,variab,variables,8,"// Mark variables on back edges as ""unknown"" if they've been changed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/ThreadSafety.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/ThreadSafety.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/ThreadSafety.cpp:32,Deployability,release,released,32,///< Shared capability that was released.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/ThreadSafety.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/ThreadSafety.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/ThreadSafety.cpp:35,Deployability,release,released,35,///< Exclusive capability that was released.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/ThreadSafety.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/ThreadSafety.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/ThreadSafety.cpp:59,Integrability,rout,routines,59,/// Class which implements the core thread safety analysis routines.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/ThreadSafety.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/ThreadSafety.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/ThreadSafety.cpp:43,Safety,safe,safety,43,/// Class which implements the core thread safety analysis routines.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/ThreadSafety.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/ThreadSafety.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/ThreadSafety.cpp:3,Modifiability,Variab,Variables,3,// Variables defined in a function are always inaccessible.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/ThreadSafety.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/ThreadSafety.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/ThreadSafety.cpp:10,Modifiability,variab,variables,10,// Global variables are always in scope.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/ThreadSafety.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/ThreadSafety.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/ThreadSafety.cpp:140,Availability,error,error,140,"/// Remove a lock from the lockset, warning if the lock is not there.; /// \param UnlockLoc The source location of the unlock (only used in error msg)",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/ThreadSafety.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/ThreadSafety.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/ThreadSafety.cpp:93,Modifiability,variab,variable,93,"// If Cond can be traced back to a function call, return the call expression.; // The negate variable should be called with false, and will be set to true; // if the function call is negated, e.g. if (!mu.tryLock(...))",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/ThreadSafety.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/ThreadSafety.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/ThreadSafety.cpp:200,Availability,error,error,200,"/// We use this class to visit different types of expressions in; /// CFGBlocks, and build up the lockset.; /// An expression may cause us to add or remove locks from the lockset, or else; /// output error messages related to missing locks.; /// FIXME: In future, we may be able to not inherit from a visitor.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/ThreadSafety.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/ThreadSafety.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/ThreadSafety.cpp:206,Integrability,message,messages,206,"/// We use this class to visit different types of expressions in; /// CFGBlocks, and build up the lockset.; /// An expression may cause us to add or remove locks from the lockset, or else; /// output error messages related to missing locks.; /// FIXME: In future, we may be able to not inherit from a visitor.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/ThreadSafety.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/ThreadSafety.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/ThreadSafety.cpp:286,Modifiability,inherit,inherit,286,"/// We use this class to visit different types of expressions in; /// CFGBlocks, and build up the lockset.; /// An expression may cause us to add or remove locks from the lockset, or else; /// output error messages related to missing locks.; /// FIXME: In future, we may be able to not inherit from a visitor.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/ThreadSafety.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/ThreadSafety.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/ThreadSafety.cpp:81,Security,access,access,81,// namespace; /// Warn if the LSet does not contain a lock sufficient to protect access; /// of at least the passed in AccessKind.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/ThreadSafety.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/ThreadSafety.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/ThreadSafety.cpp:119,Security,Access,AccessKind,119,// namespace; /// Warn if the LSet does not contain a lock sufficient to protect access; /// of at least the passed in AccessKind.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/ThreadSafety.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/ThreadSafety.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/ThreadSafety.cpp:81,Security,access,access,81,"/// Checks guarded_by and pt_guarded_by attributes.; /// Whenever we identify an access (read or write) to a DeclRefExpr that is; /// marked with guarded_by, we must ensure the appropriate mutexes are held.; /// Similarly, we check if the access is to an expression that dereferences; /// a pointer marked with pt_guarded_by.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/ThreadSafety.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/ThreadSafety.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/ThreadSafety.cpp:239,Security,access,access,239,"/// Checks guarded_by and pt_guarded_by attributes.; /// Whenever we identify an access (read or write) to a DeclRefExpr that is; /// marked with guarded_by, we must ensure the appropriate mutexes are held.; /// Similarly, we check if the access is to an expression that dereferences; /// a pointer marked with pt_guarded_by.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/ThreadSafety.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/ThreadSafety.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/ThreadSafety.cpp:9,Modifiability,variab,variables,9,// Local variables of reference type cannot be re-assigned;; // map them to their initializer.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/ThreadSafety.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/ThreadSafety.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/ThreadSafety.cpp:6,Testability,assert,assert,6,"// An assert will add a lock to the lockset, but will not generate; // a warning if it is already there, and will not generate a warning; // if it is not removed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/ThreadSafety.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/ThreadSafety.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/ThreadSafety.cpp:41,Safety,safe,safety,41,// Ignore attributes unrelated to thread-safety,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/ThreadSafety.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/ThreadSafety.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/ThreadSafety.cpp:46,Availability,down,downgrading,46,// Remove locks first to allow lock upgrading/downgrading.; // FIXME -- should only fully remove if the attribute refers to 'this'.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/ThreadSafety.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/ThreadSafety.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/ThreadSafety.cpp:48,Modifiability,variab,variable,48,"/// For unary operations which read and write a variable, we need to; /// check whether we hold any required mutexes. Reads are checked in; /// VisitCastExpr.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/ThreadSafety.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/ThreadSafety.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/ThreadSafety.cpp:44,Modifiability,variab,variable,44,"/// For binary operations which assign to a variable (writes), we need to check; /// whether we hold any required mutexes.; /// FIXME: Deal with non-primitive types.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/ThreadSafety.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/ThreadSafety.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/ThreadSafety.cpp:62,Modifiability,variab,variable,62,"/// Whenever we do an LValue to Rvalue cast, we are reading a variable and; /// need to ensure we hold any required mutexes.; /// FIXME: Deal with non-primitive types.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/ThreadSafety.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/ThreadSafety.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/ThreadSafety.cpp:92,Testability,assert,asserted,92,"// For managed capabilities, the destructor should unlock in the right mode; // anyway. For asserted capabilities no unlocking is needed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/ThreadSafety.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/ThreadSafety.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/ThreadSafety.cpp:36,Energy Efficiency,reduce,reduce,36,// Take the exclusive capability to reduce further warnings.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/ThreadSafety.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/ThreadSafety.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/ThreadSafety.cpp:11,Testability,assert,asserted,11,// The non-asserted capability is the one we want to track.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/ThreadSafety.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/ThreadSafety.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/ThreadSafety.cpp:668,Availability,error,error,668,"/// Compute the intersection of two locksets and issue warnings for any; /// locks in the symmetric difference.; ///; /// This function is used at a merge point in the CFG when comparing the lockset; /// of each branch being merged. For example, given the following sequence:; /// A; if () then B; else C; D; we need to check that the lockset after B and C; /// are the same. In the event of a difference, we use the intersection of these; /// two locksets at the start of D.; ///; /// \param EntrySet A lockset for entry into a (possibly new) block.; /// \param ExitSet The lockset on exiting a preceding block.; /// \param JoinLoc The location of the join point for error reporting; /// \param EntryLEK The warning if a mutex is missing from \p EntrySet.; /// \param ExitLEK The warning if a mutex is missing from \p ExitSet.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/ThreadSafety.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/ThreadSafety.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/ThreadSafety.cpp:38,Safety,safe,safety,38,"/// Check a function's CFG for thread-safety violations.; ///; /// We traverse the blocks in the CFG, compute the set of mutexes that are held; /// at the end of each block, and issue warnings for thread safety violations.; /// Each block in the CFG is traversed exactly once.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/ThreadSafety.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/ThreadSafety.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/ThreadSafety.cpp:204,Safety,safe,safety,204,"/// Check a function's CFG for thread-safety violations.; ///; /// We traverse the blocks in the CFG, compute the set of mutexes that are held; /// at the end of each block, and issue warnings for thread safety violations.; /// Each block in the CFG is traversed exactly once.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/ThreadSafety.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/ThreadSafety.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/ThreadSafety.cpp:180,Modifiability,variab,variable,180,"// FIXME: Do something a bit more intelligent inside constructor and; // destructor code. Constructors and destructors must assume unique access; // to 'this', so checks on member variable access is disabled, but we should; // still enable checks on other objects.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/ThreadSafety.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/ThreadSafety.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/ThreadSafety.cpp:138,Security,access,access,138,"// FIXME: Do something a bit more intelligent inside constructor and; // destructor code. Constructors and destructors must assume unique access; // to 'this', so checks on member variable access is disabled, but we should; // still enable checks on other objects.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/ThreadSafety.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/ThreadSafety.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/ThreadSafety.cpp:189,Security,access,access,189,"// FIXME: Do something a bit more intelligent inside constructor and; // destructor code. Constructors and destructors must assume unique access; // to 'this', so checks on member variable access is disabled, but we should; // still enable checks on other objects.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/ThreadSafety.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/ThreadSafety.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/ThreadSafety.cpp:31,Modifiability,variab,variables,31,// Compute SSA names for local variables,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/ThreadSafety.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/ThreadSafety.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/ThreadSafety.cpp:267,Availability,error,errors,267,"// Iterate through the predecessor blocks and warn if the lockset for all; // predecessors is not the same. We take the entry lockset of the current; // block to be the intersection of all previous locksets.; // FIXME: By keeping the intersection, we may output more errors in future; // for a lock which is not in the intersection, but was in the union. We; // may want to also keep the union in future. As an example, let's say; // the intersection contains Mutex L, and the union contains L and M.; // Later we unlock M. At this point, we would output an error because we; // never locked M; although the real error is probably that we forgot to; // lock M on all code paths. Conversely, let's say that later we lock M.; // In this case, we should compare against the intersection instead of the; // union because the real error is probably that we forgot to unlock M on; // all code paths.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/ThreadSafety.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/ThreadSafety.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/ThreadSafety.cpp:558,Availability,error,error,558,"// Iterate through the predecessor blocks and warn if the lockset for all; // predecessors is not the same. We take the entry lockset of the current; // block to be the intersection of all previous locksets.; // FIXME: By keeping the intersection, we may output more errors in future; // for a lock which is not in the intersection, but was in the union. We; // may want to also keep the union in future. As an example, let's say; // the intersection contains Mutex L, and the union contains L and M.; // Later we unlock M. At this point, we would output an error because we; // never locked M; although the real error is probably that we forgot to; // lock M on all code paths. Conversely, let's say that later we lock M.; // In this case, we should compare against the intersection instead of the; // union because the real error is probably that we forgot to unlock M on; // all code paths.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/ThreadSafety.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/ThreadSafety.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/ThreadSafety.cpp:613,Availability,error,error,613,"// Iterate through the predecessor blocks and warn if the lockset for all; // predecessors is not the same. We take the entry lockset of the current; // block to be the intersection of all previous locksets.; // FIXME: By keeping the intersection, we may output more errors in future; // for a lock which is not in the intersection, but was in the union. We; // may want to also keep the union in future. As an example, let's say; // the intersection contains Mutex L, and the union contains L and M.; // Later we unlock M. At this point, we would output an error because we; // never locked M; although the real error is probably that we forgot to; // lock M on all code paths. Conversely, let's say that later we lock M.; // In this case, we should compare against the intersection instead of the; // union because the real error is probably that we forgot to unlock M on; // all code paths.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/ThreadSafety.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/ThreadSafety.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/ThreadSafety.cpp:826,Availability,error,error,826,"// Iterate through the predecessor blocks and warn if the lockset for all; // predecessors is not the same. We take the entry lockset of the current; // block to be the intersection of all previous locksets.; // FIXME: By keeping the intersection, we may output more errors in future; // for a lock which is not in the intersection, but was in the union. We; // may want to also keep the union in future. As an example, let's say; // the intersection contains Mutex L, and the union contains L and M.; // Later we unlock M. At this point, we would output an error because we; // never locked M; although the real error is probably that we forgot to; // lock M on all code paths. Conversely, let's say that later we lock M.; // In this case, we should compare against the intersection instead of the; // union because the real error is probably that we forgot to unlock M on; // all code paths.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/ThreadSafety.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/ThreadSafety.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/ThreadSafety.cpp:38,Safety,safe,safety,38,"/// Check a function's CFG for thread-safety violations.; ///; /// We traverse the blocks in the CFG, compute the set of mutexes that are held; /// at the end of each block, and issue warnings for thread safety violations.; /// Each block in the CFG is traversed exactly once.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/ThreadSafety.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/ThreadSafety.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/ThreadSafety.cpp:204,Safety,safe,safety,204,"/// Check a function's CFG for thread-safety violations.; ///; /// We traverse the blocks in the CFG, compute the set of mutexes that are held; /// at the end of each block, and issue warnings for thread safety violations.; /// Each block in the CFG is traversed exactly once.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/ThreadSafety.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/ThreadSafety.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/ThreadSafety.cpp:81,Security,access,access,81,/// Helper function that returns a LockKind required for the given level; /// of access.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/ThreadSafety.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/ThreadSafety.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/ThreadSafetyCommon.cpp:405,Integrability,interface,interfaces,405,"//===- ThreadSafetyCommon.cpp ---------------------------------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // Implementation of the interfaces declared in ThreadSafetyCommon.h; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/ThreadSafetyCommon.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/ThreadSafetyCommon.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/ThreadSafetyCommon.cpp:25,Modifiability,variab,variable,25,// Return true if E is a variable that points to an incomplete Phi node.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/ThreadSafetyCommon.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/ThreadSafetyCommon.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/ThreadSafetyCommon.cpp:100,Modifiability,variab,variables,100,// Translate a clang statement or expression to a TIL expression.; // Also performs substitution of variables; Ctx provides the context.; // Dispatches on the type of S.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/ThreadSafetyCommon.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/ThreadSafetyCommon.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/ThreadSafetyCommon.cpp:75,Performance,perform,performs,75,// Translate a clang statement or expression to a TIL expression.; // Also performs substitution of variables; Ctx provides the context.; // Dispatches on the type of S.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/ThreadSafetyCommon.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/ThreadSafetyCommon.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/ThreadSafetyCommon.cpp:46,Performance,cache,cached,46,// Check if S has already been translated and cached.; // This handles the lookup of SSA names for DeclRefExprs here.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/ThreadSafetyCommon.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/ThreadSafetyCommon.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/ThreadSafetyCommon.cpp:17,Modifiability,variab,variables,17,"// For non-local variables, treat it as a reference to a named object.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/ThreadSafetyCommon.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/ThreadSafetyCommon.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/ThreadSafetyCommon.cpp:81,Modifiability,inherit,inheritance,81,// Method does not override anything; // FIXME: this does not work with multiple inheritance.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/ThreadSafetyCommon.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/ThreadSafetyCommon.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/ThreadSafetyCommon.cpp:18,Performance,Load,Load,18,// FIXME!! -- get Load working properly; // return new (Arena) til::Load(E0);,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/ThreadSafetyCommon.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/ThreadSafetyCommon.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/ThreadSafetyCommon.cpp:68,Performance,Load,Load,68,// FIXME!! -- get Load working properly; // return new (Arena) til::Load(E0);,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/ThreadSafetyCommon.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/ThreadSafetyCommon.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/ThreadSafetyCommon.cpp:13,Modifiability,variab,variables,13,// Add local variables with trivial type to the variable map,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/ThreadSafetyCommon.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/ThreadSafetyCommon.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/ThreadSafetyCommon.cpp:48,Modifiability,variab,variable,48,// Add local variables with trivial type to the variable map,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/ThreadSafetyCommon.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/ThreadSafetyCommon.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/ThreadSafetyCommon.cpp:74,Deployability,update,update,74,"// If (E) is non-trivial, then add it to the current basic block, and; // update the statement map so that S refers to E. Returns a new variable; // that refers to E.; // If E is trivial returns E.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/ThreadSafetyCommon.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/ThreadSafetyCommon.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/ThreadSafetyCommon.cpp:136,Modifiability,variab,variable,136,"// If (E) is non-trivial, then add it to the current basic block, and; // update the statement map so that S refers to E. Returns a new variable; // that refers to E.; // If E is trivial returns E.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/ThreadSafetyCommon.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/ThreadSafetyCommon.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/ThreadSafetyCommon.cpp:28,Deployability,update,update,28,"// if E is a til::Variable, update its clangDecl.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/ThreadSafetyCommon.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/ThreadSafetyCommon.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/ThreadSafetyCommon.cpp:18,Modifiability,Variab,Variable,18,"// if E is a til::Variable, update its clangDecl.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/ThreadSafetyCommon.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/ThreadSafetyCommon.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/ThreadSafetyCommon.cpp:14,Modifiability,variab,variable,14,// Adds a new variable declaration.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/ThreadSafetyCommon.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/ThreadSafetyCommon.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/ThreadSafetyCommon.cpp:3,Deployability,Update,Updates,3,// Updates a current variable declaration. (E.g. by assignment),MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/ThreadSafetyCommon.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/ThreadSafetyCommon.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/ThreadSafetyCommon.cpp:21,Modifiability,variab,variable,21,// Updates a current variable declaration. (E.g. by assignment),MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/ThreadSafetyCommon.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/ThreadSafetyCommon.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/ThreadSafetyCommon.cpp:53,Modifiability,variab,variable,53,"// Make a Phi node in the current block for the i^th variable in CurrentVarMap.; // If E != null, sets Phi[CurrentBlockInfo->ArgIndex] = E.; // If E == null, this is a backedge and will be set later.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/ThreadSafetyCommon.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/ThreadSafetyCommon.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/ThreadSafetyCommon.cpp:76,Modifiability,variab,variable,76,"// We already have a Phi node in the current block,; // so just add the new variable to the Phi node.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/ThreadSafetyCommon.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/ThreadSafetyCommon.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/ThreadSafetyCommon.cpp:38,Deployability,update,update,38,"// Add Phi node to current block, and update CurrentLVarMap[i]",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/ThreadSafetyCommon.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/ThreadSafetyCommon.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/ThreadSafetyCommon.cpp:42,Modifiability,variab,variable,42,// Merge values from Map into the current variable map.; // This will construct Phi nodes in the current basic block as necessary.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/ThreadSafetyCommon.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/ThreadSafetyCommon.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/ThreadSafetyCommon.cpp:28,Modifiability,variab,variables,28,// We've reached the end of variables in common.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/ThreadSafetyCommon.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/ThreadSafetyCommon.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/ThreadSafetyCommon.cpp:38,Modifiability,variab,variable,38,// Merge a back edge into the current variable map.; // This will create phi nodes for all variables in the variable map.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/ThreadSafetyCommon.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/ThreadSafetyCommon.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/ThreadSafetyCommon.cpp:91,Modifiability,variab,variables,91,// Merge a back edge into the current variable map.; // This will create phi nodes for all variables in the variable map.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/ThreadSafetyCommon.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/ThreadSafetyCommon.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/ThreadSafetyCommon.cpp:108,Modifiability,variab,variable,108,// Merge a back edge into the current variable map.; // This will create phi nodes for all variables in the variable map.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/ThreadSafetyCommon.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/ThreadSafetyCommon.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/ThreadSafetyCommon.cpp:411,Energy Efficiency,reduce,reduced,411,"// We don't have definitions for variables on the backedge, because we; // haven't gotten that far in the CFG. Thus, when encountering a back edge,; // we conservatively create Phi nodes for all variables. Unnecessary Phi; // nodes will be marked as incomplete, and stripped out at the end.; //; // An Phi node is unnecessary if it only refers to itself and one other; // variable, e.g. x = Phi(y, y, x) can be reduced to x = y.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/ThreadSafetyCommon.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/ThreadSafetyCommon.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/ThreadSafetyCommon.cpp:33,Modifiability,variab,variables,33,"// We don't have definitions for variables on the backedge, because we; // haven't gotten that far in the CFG. Thus, when encountering a back edge,; // we conservatively create Phi nodes for all variables. Unnecessary Phi; // nodes will be marked as incomplete, and stripped out at the end.; //; // An Phi node is unnecessary if it only refers to itself and one other; // variable, e.g. x = Phi(y, y, x) can be reduced to x = y.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/ThreadSafetyCommon.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/ThreadSafetyCommon.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/ThreadSafetyCommon.cpp:195,Modifiability,variab,variables,195,"// We don't have definitions for variables on the backedge, because we; // haven't gotten that far in the CFG. Thus, when encountering a back edge,; // we conservatively create Phi nodes for all variables. Unnecessary Phi; // nodes will be marked as incomplete, and stripped out at the end.; //; // An Phi node is unnecessary if it only refers to itself and one other; // variable, e.g. x = Phi(y, y, x) can be reduced to x = y.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/ThreadSafetyCommon.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/ThreadSafetyCommon.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/ThreadSafetyCommon.cpp:372,Modifiability,variab,variable,372,"// We don't have definitions for variables on the backedge, because we; // haven't gotten that far in the CFG. Thus, when encountering a back edge,; // we conservatively create Phi nodes for all variables. Unnecessary Phi; // nodes will be marked as incomplete, and stripped out at the end.; //; // An Phi node is unnecessary if it only refers to itself and one other; // variable, e.g. x = Phi(y, y, x) can be reduced to x = y.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/ThreadSafetyCommon.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/ThreadSafetyCommon.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/ThreadSafetyCommon.cpp:3,Deployability,Update,Update,3,"// Update the phi nodes that were initially created for a back edge; // once the variable definitions have been computed.; // I.e., merge the current variable map into the phi nodes for Blk.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/ThreadSafetyCommon.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/ThreadSafetyCommon.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/ThreadSafetyCommon.cpp:81,Modifiability,variab,variable,81,"// Update the phi nodes that were initially created for a back edge; // once the variable definitions have been computed.; // I.e., merge the current variable map into the phi nodes for Blk.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/ThreadSafetyCommon.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/ThreadSafetyCommon.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/ThreadSafetyCommon.cpp:150,Modifiability,variab,variable,150,"// Update the phi nodes that were initially created for a back edge; // once the variable definitions have been computed.; // I.e., merge the current variable map into the phi nodes for Blk.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/ThreadSafetyCommon.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/ThreadSafetyCommon.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/ThreadSafetyCommon.cpp:3,Performance,Perform,Perform,3,// Perform initial setup operations.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/ThreadSafetyCommon.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/ThreadSafetyCommon.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/ThreadSafetyCommon.cpp:3,Energy Efficiency,allocate,allocate,3,"// allocate all basic blocks immediately, to handle forward references.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/ThreadSafetyCommon.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/ThreadSafetyCommon.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/ThreadSafetyCommon.cpp:27,Modifiability,variab,variable,27,// Add parameters to local variable map.; // FIXME: right now we emulate params with loads; that should be fixed.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/ThreadSafetyCommon.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/ThreadSafetyCommon.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/ThreadSafetyCommon.cpp:85,Performance,load,loads,85,// Add parameters to local variable map.; // FIXME: right now we emulate params with loads; that should be fixed.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/ThreadSafetyCommon.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/ThreadSafetyCommon.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/ThreadSafetyCommon.cpp:115,Testability,assert,assert,115,"// CurrentLVarMap is moved to ExitMap on block exit.; // FIXME: the entry block will hold function parameters.; // assert(!CurrentLVarMap.valid() && ""CurrentLVarMap already initialized."");",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/ThreadSafetyCommon.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/ThreadSafetyCommon.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/ThreadSafetyLogical.cpp:418,Testability,log,logical,418,"//===- ThreadSafetyLogical.cpp ---------------------------------*- C++ --*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; // This file defines a representation for logical expressions with SExpr leaves; // that are used as part of fact-checking capability expressions.; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/ThreadSafetyLogical.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/ThreadSafetyLogical.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/ThreadSafetyLogical.cpp:70,Testability,log,logical,70,"// In comments below, we write => for implication.; // Calculates the logical AND implication operator.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/ThreadSafetyLogical.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/ThreadSafetyLogical.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/ThreadSafetyLogical.cpp:18,Testability,log,logical,18,// Calculates the logical OR implication operator.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/ThreadSafetyLogical.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/ThreadSafetyLogical.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/ThreadSafetyLogical.cpp:8,Performance,perform,performing,8,// When performing right recursion:; // C => A & B [if] C => A and C => B; // When performing right recursion (negated):; // C => !(A & B) [if] C => !A | !B [===] C => !A or C => !B,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/ThreadSafetyLogical.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/ThreadSafetyLogical.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/ThreadSafetyLogical.cpp:83,Performance,perform,performing,83,// When performing right recursion:; // C => A & B [if] C => A and C => B; // When performing right recursion (negated):; // C => !(A & B) [if] C => !A | !B [===] C => !A or C => !B,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/ThreadSafetyLogical.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/ThreadSafetyLogical.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/ThreadSafetyLogical.cpp:8,Performance,perform,performing,8,// When performing right recursion:; // C => (A | B) [if] C => A or C => B; // When performing right recursion (negated):; // C => !(A | B) [if] C => !A & !B [===] C => !A and C => !B,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/ThreadSafetyLogical.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/ThreadSafetyLogical.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/ThreadSafetyLogical.cpp:84,Performance,perform,performing,84,// When performing right recursion:; // C => (A | B) [if] C => A or C => B; // When performing right recursion (negated):; // C => !(A | B) [if] C => !A & !B [===] C => !A and C => !B,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/ThreadSafetyLogical.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/ThreadSafetyLogical.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/ThreadSafetyLogical.cpp:8,Performance,perform,performing,8,// When performing left recursion:; // A & B => C [if] A => C or B => C; // When performing left recursion (negated):; // !(A & B) => C [if] !A | !B => C [===] !A => C and !B => C,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/ThreadSafetyLogical.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/ThreadSafetyLogical.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/ThreadSafetyLogical.cpp:81,Performance,perform,performing,81,// When performing left recursion:; // A & B => C [if] A => C or B => C; // When performing left recursion (negated):; // !(A & B) => C [if] !A | !B => C [===] !A => C and !B => C,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/ThreadSafetyLogical.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/ThreadSafetyLogical.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/ThreadSafetyLogical.cpp:8,Performance,perform,performing,8,// When performing left recursion:; // A | B => C [if] A => C and B => C; // When performing left recursion (negated):; // !(A | B) => C [if] !A & !B => C [===] !A => C or !B => C,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/ThreadSafetyLogical.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/ThreadSafetyLogical.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/ThreadSafetyLogical.cpp:82,Performance,perform,performing,82,// When performing left recursion:; // A | B => C [if] A => C and B => C; // When performing left recursion (negated):; // !(A | B) => C [if] !A & !B => C [===] !A => C or !B => C,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/ThreadSafetyLogical.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/ThreadSafetyLogical.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/ThreadSafetyLogical.cpp:45,Performance,perform,perform,45,"// After reaching the terminal, it's time to perform identity comparisons.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/ThreadSafetyLogical.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/ThreadSafetyLogical.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/ThreadSafetyTIL.cpp:62,Availability,redundant,redundant,62,"// If E is a variable, then trace back through any aliases or redundant; // Phi nodes to find the canonical definition.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/ThreadSafetyTIL.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/ThreadSafetyTIL.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/ThreadSafetyTIL.cpp:13,Modifiability,variab,variable,13,"// If E is a variable, then trace back through any aliases or redundant; // Phi nodes to find the canonical definition.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/ThreadSafetyTIL.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/ThreadSafetyTIL.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/ThreadSafetyTIL.cpp:62,Safety,redund,redundant,62,"// If E is a variable, then trace back through any aliases or redundant; // Phi nodes to find the canonical definition.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/ThreadSafetyTIL.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/ThreadSafetyTIL.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/ThreadSafetyTIL.cpp:62,Availability,redundant,redundant,62,"// If E is a variable, then trace back through any aliases or redundant; // Phi nodes to find the canonical definition.; // The non-const version will simplify incomplete Phi nodes.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/ThreadSafetyTIL.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/ThreadSafetyTIL.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/ThreadSafetyTIL.cpp:13,Modifiability,variab,variable,13,"// If E is a variable, then trace back through any aliases or redundant; // Phi nodes to find the canonical definition.; // The non-const version will simplify incomplete Phi nodes.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/ThreadSafetyTIL.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/ThreadSafetyTIL.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/ThreadSafetyTIL.cpp:62,Safety,redund,redundant,62,"// If E is a variable, then trace back through any aliases or redundant; // Phi nodes to find the canonical definition.; // The non-const version will simplify incomplete Phi nodes.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/ThreadSafetyTIL.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/ThreadSafetyTIL.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/ThreadSafetyTIL.cpp:151,Usability,simpl,simplify,151,"// If E is a variable, then trace back through any aliases or redundant; // Phi nodes to find the canonical definition.; // The non-const version will simplify incomplete Phi nodes.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/ThreadSafetyTIL.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/ThreadSafetyTIL.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/ThreadSafetyTIL.cpp:13,Availability,redundant,redundant,13,"// Eliminate redundant variables, e.g. x = y, or x = 5,; // but keep anything more complicated.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/ThreadSafetyTIL.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/ThreadSafetyTIL.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/ThreadSafetyTIL.cpp:23,Modifiability,variab,variables,23,"// Eliminate redundant variables, e.g. x = y, or x = 5,; // but keep anything more complicated.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/ThreadSafetyTIL.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/ThreadSafetyTIL.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/ThreadSafetyTIL.cpp:13,Safety,redund,redundant,13,"// Eliminate redundant variables, e.g. x = y, or x = 5,; // but keep anything more complicated.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/ThreadSafetyTIL.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/ThreadSafetyTIL.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/ThreadSafetyTIL.cpp:13,Availability,redundant,redundant,13,// Eliminate redundant Phi nodes.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/ThreadSafetyTIL.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/ThreadSafetyTIL.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/ThreadSafetyTIL.cpp:13,Safety,redund,redundant,13,// Eliminate redundant Phi nodes.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/ThreadSafetyTIL.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/ThreadSafetyTIL.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/ThreadSafetyTIL.cpp:132,Availability,redundant,redundant,132,"// Trace the arguments of an incomplete Phi node to see if they have the same; // canonical definition. If so, mark the Phi node as redundant.; // getCanonicalVal() will recursively call simplifyIncompletePhi().",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/ThreadSafetyTIL.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/ThreadSafetyTIL.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/ThreadSafetyTIL.cpp:132,Safety,redund,redundant,132,"// Trace the arguments of an incomplete Phi node to see if they have the same; // canonical definition. If so, mark the Phi node as redundant.; // getCanonicalVal() will recursively call simplifyIncompletePhi().",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/ThreadSafetyTIL.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/ThreadSafetyTIL.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/ThreadSafetyTIL.cpp:187,Usability,simpl,simplifyIncompletePhi,187,"// Trace the arguments of an incomplete Phi node to see if they have the same; // canonical definition. If so, mark the Phi node as redundant.; // getCanonicalVal() will recursively call simplifyIncompletePhi().",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/ThreadSafetyTIL.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/ThreadSafetyTIL.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/ThreadSafetyTIL.cpp:64,Availability,redundant,redundant,64,// eliminate infinite recursion -- assume that this node is not redundant.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/ThreadSafetyTIL.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/ThreadSafetyTIL.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/ThreadSafetyTIL.cpp:64,Safety,redund,redundant,64,// eliminate infinite recursion -- assume that this node is not redundant.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/ThreadSafetyTIL.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/ThreadSafetyTIL.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/ThreadSafetyTIL.cpp:14,Deployability,update,update,14,// set ID and update block array in place.; // We may lose pointers to unreachable blocks.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/ThreadSafetyTIL.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/ThreadSafetyTIL.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/ThreadSafetyTIL.cpp:3,Performance,Perform,Performs,3,"// Performs a reverse topological traversal, starting from the exit block and; // following back-edges. The dominator is serialized before any predecessors,; // which guarantees that all blocks are serialized after their dominator and; // before their post-dominator (because it's a reverse topological traversal).; // ID should be initially set to 0.; //; // This sort assumes that (1) dominators have been computed, (2) there are no; // critical edges, and (3) the entry block is reachable from the exit block; // and no blocks are accessible via traversal of back-edges from the exit that; // weren't accessible via forward edges from the entry.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/ThreadSafetyTIL.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/ThreadSafetyTIL.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/ThreadSafetyTIL.cpp:534,Security,access,accessible,534,"// Performs a reverse topological traversal, starting from the exit block and; // following back-edges. The dominator is serialized before any predecessors,; // which guarantees that all blocks are serialized after their dominator and; // before their post-dominator (because it's a reverse topological traversal).; // ID should be initially set to 0.; //; // This sort assumes that (1) dominators have been computed, (2) there are no; // critical edges, and (3) the entry block is reachable from the exit block; // and no blocks are accessible via traversal of back-edges from the exit that; // weren't accessible via forward edges from the entry.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/ThreadSafetyTIL.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/ThreadSafetyTIL.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/ThreadSafetyTIL.cpp:604,Security,access,accessible,604,"// Performs a reverse topological traversal, starting from the exit block and; // following back-edges. The dominator is serialized before any predecessors,; // which guarantees that all blocks are serialized after their dominator and; // before their post-dominator (because it's a reverse topological traversal).; // ID should be initially set to 0.; //; // This sort assumes that (1) dominators have been computed, (2) there are no; // critical edges, and (3) the entry block is reachable from the exit block; // and no blocks are accessible via traversal of back-edges from the exit that; // weren't accessible via forward edges from the entry.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/ThreadSafetyTIL.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/ThreadSafetyTIL.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/ThreadSafetyTIL.cpp:53,Availability,down,down,53,"// If there were unreachable blocks shift everything down, and delete them.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/ThreadSafetyTIL.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/ThreadSafetyTIL.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/ThreadSafetyTIL.cpp:61,Performance,perform,performed,61,"// Once dominators have been computed, the final sort may be performed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/ThreadSafetyTIL.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/ThreadSafetyTIL.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/UninitializedValues.cpp:61,Modifiability,variab,variable,61,"/// If E is an expression comprising a reference to a single variable, find that; /// variable.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/UninitializedValues.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/UninitializedValues.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/UninitializedValues.cpp:86,Modifiability,variab,variable,86,"/// If E is an expression comprising a reference to a single variable, find that; /// variable.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/UninitializedValues.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/UninitializedValues.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/UninitializedValues.cpp:150,Modifiability,variab,variable,150,"// Ignore the evaluation of a DeclRefExpr on the LHS of an assignment. If this; // is not a compound-assignment, we will treat it as initializing the variable; // when TransferFunctions visits it. A compound-assignment does not affect; // whether a variable is uninitialized, and there's no point counting it as a; // use.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/UninitializedValues.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/UninitializedValues.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/UninitializedValues.cpp:249,Modifiability,variab,variable,249,"// Ignore the evaluation of a DeclRefExpr on the LHS of an assignment. If this; // is not a compound-assignment, we will treat it as initializing the variable; // when TransferFunctions visits it. A compound-assignment does not affect; // whether a variable is uninitialized, and there's no point counting it as a; // use.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/UninitializedValues.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/UninitializedValues.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/UninitializedValues.cpp:24,Performance,load,load,24,// Squelch any detected load of an uninitialized value if; // we cast it to void.; // e.g. (void) x;,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/UninitializedValues.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/UninitializedValues.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/UninitializedValues.cpp:15,Safety,detect,detected,15,// Squelch any detected load of an uninitialized value if; // we cast it to void.; // e.g. (void) x;,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/UninitializedValues.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/UninitializedValues.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/UninitializedValues.cpp:81,Modifiability,variab,variable,81,"// If an edge which leads unconditionally to this use did not initialize; // the variable, we can say something stronger than 'may be uninitialized':; // we can say 'either it's used uninitialized or you have dead code'.; //; // We track the number of successors of a node which have been visited, and; // visit a node once we have visited all of its successors. Only edges where; // the variable might still be uninitialized are followed. Since a variable; // can't transfer from being initialized to being uninitialized, this will; // trace out the subgraph which inevitably leads to the use and does not; // initialize the variable. We do not want to skip past loops, since their; // non-termination might be correlated with the initialization condition.; //; // For example:; //; // void f(bool a, bool b) {; // block1: int n;; // if (a) {; // block2: if (b); // block3: n = 1;; // block4: } else if (b) {; // block5: while (!a) {; // block6: do_work(&a);; // n = 2;; // }; // }; // block7: if (a); // block8: g();; // block9: return n;; // }; //; // Starting from the maybe-uninitialized use in block 9:; // * Block 7 is not visited because we have only visited one of its two; // successors.; // * Block 8 is visited because we've visited its only successor.; // From block 8:; // * Block 7 is visited because we've now visited both of its successors.; // From block 7:; // * Blocks 1, 2, 4, 5, and 6 are not visited because we didn't visit all; // of their successors (we didn't visit 4, 3, 5, 6, and 5, respectively).; // * Block 3 is not visited because it initializes 'n'.; // Now the algorithm terminates, having visited blocks 7 and 8, and having; // found the frontier is blocks 2, 4, and 5.; //; // 'n' is definitely uninitialized for two edges into block 7 (from blocks 2; // and 4), so we report that any time either of those edges is taken (in; // each case when 'b == false'), 'n' is used uninitialized.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/UninitializedValues.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/UninitializedValues.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/UninitializedValues.cpp:388,Modifiability,variab,variable,388,"// If an edge which leads unconditionally to this use did not initialize; // the variable, we can say something stronger than 'may be uninitialized':; // we can say 'either it's used uninitialized or you have dead code'.; //; // We track the number of successors of a node which have been visited, and; // visit a node once we have visited all of its successors. Only edges where; // the variable might still be uninitialized are followed. Since a variable; // can't transfer from being initialized to being uninitialized, this will; // trace out the subgraph which inevitably leads to the use and does not; // initialize the variable. We do not want to skip past loops, since their; // non-termination might be correlated with the initialization condition.; //; // For example:; //; // void f(bool a, bool b) {; // block1: int n;; // if (a) {; // block2: if (b); // block3: n = 1;; // block4: } else if (b) {; // block5: while (!a) {; // block6: do_work(&a);; // n = 2;; // }; // }; // block7: if (a); // block8: g();; // block9: return n;; // }; //; // Starting from the maybe-uninitialized use in block 9:; // * Block 7 is not visited because we have only visited one of its two; // successors.; // * Block 8 is visited because we've visited its only successor.; // From block 8:; // * Block 7 is visited because we've now visited both of its successors.; // From block 7:; // * Blocks 1, 2, 4, 5, and 6 are not visited because we didn't visit all; // of their successors (we didn't visit 4, 3, 5, 6, and 5, respectively).; // * Block 3 is not visited because it initializes 'n'.; // Now the algorithm terminates, having visited blocks 7 and 8, and having; // found the frontier is blocks 2, 4, and 5.; //; // 'n' is definitely uninitialized for two edges into block 7 (from blocks 2; // and 4), so we report that any time either of those edges is taken (in; // each case when 'b == false'), 'n' is used uninitialized.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/UninitializedValues.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/UninitializedValues.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/UninitializedValues.cpp:448,Modifiability,variab,variable,448,"// If an edge which leads unconditionally to this use did not initialize; // the variable, we can say something stronger than 'may be uninitialized':; // we can say 'either it's used uninitialized or you have dead code'.; //; // We track the number of successors of a node which have been visited, and; // visit a node once we have visited all of its successors. Only edges where; // the variable might still be uninitialized are followed. Since a variable; // can't transfer from being initialized to being uninitialized, this will; // trace out the subgraph which inevitably leads to the use and does not; // initialize the variable. We do not want to skip past loops, since their; // non-termination might be correlated with the initialization condition.; //; // For example:; //; // void f(bool a, bool b) {; // block1: int n;; // if (a) {; // block2: if (b); // block3: n = 1;; // block4: } else if (b) {; // block5: while (!a) {; // block6: do_work(&a);; // n = 2;; // }; // }; // block7: if (a); // block8: g();; // block9: return n;; // }; //; // Starting from the maybe-uninitialized use in block 9:; // * Block 7 is not visited because we have only visited one of its two; // successors.; // * Block 8 is visited because we've visited its only successor.; // From block 8:; // * Block 7 is visited because we've now visited both of its successors.; // From block 7:; // * Blocks 1, 2, 4, 5, and 6 are not visited because we didn't visit all; // of their successors (we didn't visit 4, 3, 5, 6, and 5, respectively).; // * Block 3 is not visited because it initializes 'n'.; // Now the algorithm terminates, having visited blocks 7 and 8, and having; // found the frontier is blocks 2, 4, and 5.; //; // 'n' is definitely uninitialized for two edges into block 7 (from blocks 2; // and 4), so we report that any time either of those edges is taken (in; // each case when 'b == false'), 'n' is used uninitialized.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/UninitializedValues.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/UninitializedValues.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/UninitializedValues.cpp:626,Modifiability,variab,variable,626,"// If an edge which leads unconditionally to this use did not initialize; // the variable, we can say something stronger than 'may be uninitialized':; // we can say 'either it's used uninitialized or you have dead code'.; //; // We track the number of successors of a node which have been visited, and; // visit a node once we have visited all of its successors. Only edges where; // the variable might still be uninitialized are followed. Since a variable; // can't transfer from being initialized to being uninitialized, this will; // trace out the subgraph which inevitably leads to the use and does not; // initialize the variable. We do not want to skip past loops, since their; // non-termination might be correlated with the initialization condition.; //; // For example:; //; // void f(bool a, bool b) {; // block1: int n;; // if (a) {; // block2: if (b); // block3: n = 1;; // block4: } else if (b) {; // block5: while (!a) {; // block6: do_work(&a);; // n = 2;; // }; // }; // block7: if (a); // block8: g();; // block9: return n;; // }; //; // Starting from the maybe-uninitialized use in block 9:; // * Block 7 is not visited because we have only visited one of its two; // successors.; // * Block 8 is visited because we've visited its only successor.; // From block 8:; // * Block 7 is visited because we've now visited both of its successors.; // From block 7:; // * Blocks 1, 2, 4, 5, and 6 are not visited because we didn't visit all; // of their successors (we didn't visit 4, 3, 5, 6, and 5, respectively).; // * Block 3 is not visited because it initializes 'n'.; // Now the algorithm terminates, having visited blocks 7 and 8, and having; // found the frontier is blocks 2, 4, and 5.; //; // 'n' is definitely uninitialized for two edges into block 7 (from blocks 2; // and 4), so we report that any time either of those edges is taken (in; // each case when 'b == false'), 'n' is used uninitialized.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/UninitializedValues.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/UninitializedValues.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/UninitializedValues.cpp:141,Performance,queue,queue,141,"// Specify that we've already visited all successors of the starting block.; // This has the dual purpose of ensuring we never add it to the queue, and; // of marking it as not being a candidate element of the frontier.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/UninitializedValues.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/UninitializedValues.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/UninitializedValues.cpp:30,Modifiability,variab,variable,30,// This block initializes the variable.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/UninitializedValues.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/UninitializedValues.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/UninitializedValues.cpp:300,Availability,down,down,300,"// This block declares the variable (uninitialized), and is reachable; // from a block that initializes the variable. We can't guarantee to; // give an earlier location for the diagnostic (and it appears that; // this code is intended to be reachable) so give a diagnostic here; // and go no further down this path.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/UninitializedValues.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/UninitializedValues.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/UninitializedValues.cpp:27,Modifiability,variab,variable,27,"// This block declares the variable (uninitialized), and is reachable; // from a block that initializes the variable. We can't guarantee to; // give an earlier location for the diagnostic (and it appears that; // this code is intended to be reachable) so give a diagnostic here; // and go no further down this path.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/UninitializedValues.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/UninitializedValues.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/UninitializedValues.cpp:108,Modifiability,variab,variable,108,"// This block declares the variable (uninitialized), and is reachable; // from a block that initializes the variable. We can't guarantee to; // give an earlier location for the diagnostic (and it appears that; // this code is intended to be reachable) so give a diagnostic here; // and go no further down this path.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/UninitializedValues.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/UninitializedValues.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/UninitializedValues.cpp:74,Modifiability,variab,variable,74,// All paths from this block lead to the use and don't initialize the; // variable.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/UninitializedValues.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/UninitializedValues.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/UninitializedValues.cpp:51,Modifiability,variab,variable,51,"// Scan the frontier, looking for blocks where the variable was; // uninitialized.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/UninitializedValues.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/UninitializedValues.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/UninitializedValues.cpp:111,Modifiability,variab,variable,111,"// This block inevitably leads to the use. If we have an edge from here; // to a post-dominator block, and the variable is uninitialized on that; // edge, we have found a bug.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/UninitializedValues.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/UninitializedValues.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/UninitializedValues.cpp:56,Modifiability,variab,variable,56,"// After a call to a function like setjmp or vfork, any variable which is; // initialized anywhere within this function may now be initialized. For; // now, just assume such a call initializes all variables. FIXME: Only; // mark variables as initialized if they have an initializer which is; // reachable from here.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/UninitializedValues.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/UninitializedValues.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/UninitializedValues.cpp:197,Modifiability,variab,variables,197,"// After a call to a function like setjmp or vfork, any variable which is; // initialized anywhere within this function may now be initialized. For; // now, just assume such a call initializes all variables. FIXME: Only; // mark variables as initialized if they have an initializer which is; // reachable from here.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/UninitializedValues.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/UninitializedValues.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/UninitializedValues.cpp:229,Modifiability,variab,variables,229,"// After a call to a function like setjmp or vfork, any variable which is; // initialized anywhere within this function may now be initialized. For; // now, just assume such a call initializes all variables. FIXME: Only; // mark variables as initialized if they have an initializer which is; // reachable from here.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/UninitializedValues.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/UninitializedValues.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/UninitializedValues.cpp:91,Modifiability,variab,variable,91,"// If the initializer consists solely of a reference to itself, we; // explicitly mark the variable as uninitialized. This allows code; // like the following:; //; // int x = x;; //; // to deliberately leave a variable uninitialized. Different analysis; // clients can detect this pattern and adjust their reporting; // appropriately, but we need to continue to analyze subsequent uses; // of the variable.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/UninitializedValues.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/UninitializedValues.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/UninitializedValues.cpp:210,Modifiability,variab,variable,210,"// If the initializer consists solely of a reference to itself, we; // explicitly mark the variable as uninitialized. This allows code; // like the following:; //; // int x = x;; //; // to deliberately leave a variable uninitialized. Different analysis; // clients can detect this pattern and adjust their reporting; // appropriately, but we need to continue to analyze subsequent uses; // of the variable.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/UninitializedValues.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/UninitializedValues.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/UninitializedValues.cpp:397,Modifiability,variab,variable,397,"// If the initializer consists solely of a reference to itself, we; // explicitly mark the variable as uninitialized. This allows code; // like the following:; //; // int x = x;; //; // to deliberately leave a variable uninitialized. Different analysis; // clients can detect this pattern and adjust their reporting; // appropriately, but we need to continue to analyze subsequent uses; // of the variable.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/UninitializedValues.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/UninitializedValues.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/UninitializedValues.cpp:269,Safety,detect,detect,269,"// If the initializer consists solely of a reference to itself, we; // explicitly mark the variable as uninitialized. This allows code; // like the following:; //; // int x = x;; //; // to deliberately leave a variable uninitialized. Different analysis; // clients can detect this pattern and adjust their reporting; // appropriately, but we need to continue to analyze subsequent uses; // of the variable.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/UninitializedValues.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/UninitializedValues.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/UninitializedValues.cpp:17,Modifiability,variab,variable,17,// Treat the new variable as initialized.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/UninitializedValues.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/UninitializedValues.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/UninitializedValues.cpp:23,Modifiability,variab,variable,23,"// No initializer: the variable is now uninitialized. This matters; // for cases like:; // while (...) {; // int n;; // use(n);; // n = 0;; // }; // FIXME: Mark the variable as uninitialized whenever its scope is; // left, since its scope could be re-entered by a jump over the; // declaration.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/UninitializedValues.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/UninitializedValues.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/UninitializedValues.cpp:165,Modifiability,variab,variable,165,"// No initializer: the variable is now uninitialized. This matters; // for cases like:; // while (...) {; // int n;; // use(n);; // n = 0;; // }; // FIXME: Mark the variable as uninitialized whenever its scope is; // left, since its scope could be re-entered by a jump over the; // declaration.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/UninitializedValues.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/UninitializedValues.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/UninitializedValues.cpp:68,Modifiability,variab,variables,68,"// An ""asm goto"" statement is a terminator that may initialize some variables.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/UninitializedValues.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/UninitializedValues.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/UninitializedValues.cpp:12,Modifiability,variab,variable,12,"// Mark the variable as potentially uninitialized for those cases where; // it's used on an indirect path, where it's not guaranteed to be; // defined.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/UninitializedValues.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/UninitializedValues.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/UninitializedValues.cpp:22,Integrability,message,message,22,"// If the Objective-C message expression is an implicit no-return that; // is not modeled in the CFG, set the tracked dataflow values to Unknown.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/UninitializedValues.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/UninitializedValues.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/UninitializedValues.cpp:105,Testability,log,logic,105,"//------------------------------------------------------------------------====//; // High-level ""driver"" logic for uninitialized values analysis.; //====------------------------------------------------------------------------//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/UninitializedValues.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/UninitializedValues.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/UninitializedValues.cpp:152,Modifiability,variab,variable,152,/// PruneBlocksHandler is a special UninitVariablesHandler that is used; /// to detect when a CFGBlock has any *potential* use of an uninitialized; /// variable. It is mainly used to prune out work during the final; /// reporting pass.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/UninitializedValues.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/UninitializedValues.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/UninitializedValues.cpp:80,Safety,detect,detect,80,/// PruneBlocksHandler is a special UninitVariablesHandler that is used; /// to detect when a CFGBlock has any *potential* use of an uninitialized; /// variable. It is mainly used to prune out work during the final; /// reporting pass.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/UninitializedValues.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/UninitializedValues.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/UninitializedValues.cpp:66,Modifiability,variab,variable,66,/// Records if a CFGBlock had a potential use of an uninitialized variable.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/UninitializedValues.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/UninitializedValues.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/UninitializedValues.cpp:68,Modifiability,variab,variable,68,/// Records if any CFGBlock had a potential use of an uninitialized variable.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/UninitializedValues.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/UninitializedValues.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/UninitializedValues.cpp:34,Modifiability,variab,variable,34,/// Called when the uninitialized variable analysis detects the; /// idiom 'int x = x'. All other uses of 'x' within the initializer; /// are handled by handleUseOfUninitVariable.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/UninitializedValues.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/UninitializedValues.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/UninitializedValues.cpp:52,Safety,detect,detects,52,/// Called when the uninitialized variable analysis detects the; /// idiom 'int x = x'. All other uses of 'x' within the initializer; /// are handled by handleUseOfUninitVariable.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/UninitializedValues.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/UninitializedValues.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/UninitializedValues.cpp:12,Modifiability,variab,variables,12,// Mark all variables uninitialized at the entry.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/UninitializedValues.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/UninitializedValues.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/UninitializedValues.cpp:66,Modifiability,variab,variables,66,"// Run through the blocks one more time, and report uninitialized variables.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/UninitializedValues.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/UninitializedValues.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/UnsafeBufferUsage.cpp:7,Safety,Unsafe,UnsafeBufferUsage,7,"//===- UnsafeBufferUsage.cpp - Replace pointers with modern C++ -----------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/UnsafeBufferUsage.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/UnsafeBufferUsage.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/UnsafeBufferUsage.cpp:210,Safety,safe,safe,210,"// The following are overriding methods from the base visitor class.; // They are public only to allow CRTP to work. They are *not *part; // of the public API of this class.; // For the matchers so far used in safe buffers, we only need to match; // `Stmt`s. To override more as needed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/UnsafeBufferUsage.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/UnsafeBufferUsage.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/UnsafeBufferUsage.cpp:3,Safety,Abort,Abort,3,// Abort as soon as a match is found.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/UnsafeBufferUsage.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/UnsafeBufferUsage.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/UnsafeBufferUsage.cpp:46,Safety,safe,safe-buffer,46,// Matches a `Stmt` node iff the node is in a safe-buffer opt-out region,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/UnsafeBufferUsage.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/UnsafeBufferUsage.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/UnsafeBufferUsage.cpp:40,Modifiability,variab,variables,40,"// Because the analysis revolves around variables and their types, we'll need to; // track uses of variables (aka DeclRefExprs).",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/UnsafeBufferUsage.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/UnsafeBufferUsage.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/UnsafeBufferUsage.cpp:99,Modifiability,variab,variables,99,"// Because the analysis revolves around variables and their types, we'll need to; // track uses of variables (aka DeclRefExprs).",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/UnsafeBufferUsage.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/UnsafeBufferUsage.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/UnsafeBufferUsage.cpp:37,Modifiability,variab,variables,37,"/// Returns the list of pointer-type variables on which this gadget performs; /// its operation. Typically, there's only one variable. This isn't a list; /// of all DeclRefExprs in the gadget's AST!",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/UnsafeBufferUsage.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/UnsafeBufferUsage.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/UnsafeBufferUsage.cpp:125,Modifiability,variab,variable,125,"/// Returns the list of pointer-type variables on which this gadget performs; /// its operation. Typically, there's only one variable. This isn't a list; /// of all DeclRefExprs in the gadget's AST!",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/UnsafeBufferUsage.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/UnsafeBufferUsage.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/UnsafeBufferUsage.cpp:68,Performance,perform,performs,68,"/// Returns the list of pointer-type variables on which this gadget performs; /// its operation. Typically, there's only one variable. This isn't a list; /// of all DeclRefExprs in the gadget's AST!",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/UnsafeBufferUsage.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/UnsafeBufferUsage.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/UnsafeBufferUsage.cpp:34,Safety,unsafe,unsafe,34,/// Warning gadgets correspond to unsafe code patterns that warrants; /// an immediate warning.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/UnsafeBufferUsage.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/UnsafeBufferUsage.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/UnsafeBufferUsage.cpp:298,Deployability,update,updated,298,"/// Fixable gadgets correspond to code patterns that aren't always unsafe but need to be; /// properly recognized in order to emit fixes. For example, if a raw pointer-type; /// variable is replaced by a safe C++ container, every use of such variable must be; /// carefully considered and possibly updated.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/UnsafeBufferUsage.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/UnsafeBufferUsage.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/UnsafeBufferUsage.cpp:178,Modifiability,variab,variable,178,"/// Fixable gadgets correspond to code patterns that aren't always unsafe but need to be; /// properly recognized in order to emit fixes. For example, if a raw pointer-type; /// variable is replaced by a safe C++ container, every use of such variable must be; /// carefully considered and possibly updated.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/UnsafeBufferUsage.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/UnsafeBufferUsage.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/UnsafeBufferUsage.cpp:242,Modifiability,variab,variable,242,"/// Fixable gadgets correspond to code patterns that aren't always unsafe but need to be; /// properly recognized in order to emit fixes. For example, if a raw pointer-type; /// variable is replaced by a safe C++ container, every use of such variable must be; /// carefully considered and possibly updated.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/UnsafeBufferUsage.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/UnsafeBufferUsage.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/UnsafeBufferUsage.cpp:67,Safety,unsafe,unsafe,67,"/// Fixable gadgets correspond to code patterns that aren't always unsafe but need to be; /// properly recognized in order to emit fixes. For example, if a raw pointer-type; /// variable is replaced by a safe C++ container, every use of such variable must be; /// carefully considered and possibly updated.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/UnsafeBufferUsage.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/UnsafeBufferUsage.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/UnsafeBufferUsage.cpp:204,Safety,safe,safe,204,"/// Fixable gadgets correspond to code patterns that aren't always unsafe but need to be; /// properly recognized in order to emit fixes. For example, if a raw pointer-type; /// variable is replaced by a safe C++ container, every use of such variable must be; /// carefully considered and possibly updated.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/UnsafeBufferUsage.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/UnsafeBufferUsage.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/UnsafeBufferUsage.cpp:320,Modifiability,variab,variables,320,/// Returns a list of two elements where the first element is the LHS of a pointer assignment; /// statement and the second element is the RHS. This two-element list represents the fact that; /// the LHS buffer gets its bounds information from the RHS buffer. This information will be used; /// later to group all those variables whose types must be modified together to prevent type; /// mismatches.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/UnsafeBufferUsage.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/UnsafeBufferUsage.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/UnsafeBufferUsage.cpp:44,Safety,unsafe,unsafe,44,/// An increment of a pointer-type value is unsafe as it may run the pointer; /// out of bounds.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/UnsafeBufferUsage.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/UnsafeBufferUsage.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/UnsafeBufferUsage.cpp:43,Safety,unsafe,unsafe,43,/// A decrement of a pointer-type value is unsafe as it may run the pointer; /// out of bounds.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/UnsafeBufferUsage.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/UnsafeBufferUsage.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/UnsafeBufferUsage.cpp:70,Safety,Unsafe,Unsafe,70,/// Array subscript expressions on raw pointers as if they're arrays. Unsafe as; /// it doesn't have any bounds checks for the array.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/UnsafeBufferUsage.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/UnsafeBufferUsage.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/UnsafeBufferUsage.cpp:71,Safety,safe,safe,71,// FIXME: What if the index is integer literal 0? Should this be; // a safe gadget in this case?; // clang-format off,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/UnsafeBufferUsage.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/UnsafeBufferUsage.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/UnsafeBufferUsage.cpp:40,Performance,perform,performs,40,/// A call of a function or method that performs unchecked buffer operations; /// over one of its pointer parameters.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/UnsafeBufferUsage.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/UnsafeBufferUsage.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/UnsafeBufferUsage.cpp:22,Safety,unsafe,unsafe,22,// Warning gadget for unsafe invocation of span::data method.; // Triggers when the pointer returned by the invocation is immediately; // cast to a larger type.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/UnsafeBufferUsage.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/UnsafeBufferUsage.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/UnsafeBufferUsage.cpp:3,Energy Efficiency,Allocate,Allocate,3,// Allocate on the heap for easier move.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/UnsafeBufferUsage.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/UnsafeBufferUsage.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/UnsafeBufferUsage.cpp:9,Safety,avoid,avoid,9,// Let's avoid copies.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/UnsafeBufferUsage.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/UnsafeBufferUsage.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/UnsafeBufferUsage.cpp:5,Modifiability,variab,variable,5,// A variable is unclaimed if at least one use is unclaimed.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/UnsafeBufferUsage.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/UnsafeBufferUsage.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/UnsafeBufferUsage.cpp:10,Testability,Assert,Assertion,10,"// FIXME: Assertion temporarily disabled due to a bug in; // ASTMatcher internal behavior in presence of GNU; // statement-expressions. We need to properly investigate this; // because it can screw up our algorithm in other ways.; // assert(Defs.count(VD) == 0 && ""Definition already discovered!"");",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/UnsafeBufferUsage.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/UnsafeBufferUsage.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/UnsafeBufferUsage.cpp:234,Testability,assert,assert,234,"// FIXME: Assertion temporarily disabled due to a bug in; // ASTMatcher internal behavior in presence of GNU; // statement-expressions. We need to properly investigate this; // because it can screw up our algorithm in other ways.; // assert(Defs.count(VD) == 0 && ""Definition already discovered!"");",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/UnsafeBufferUsage.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/UnsafeBufferUsage.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/UnsafeBufferUsage.cpp:176,Integrability,depend,depending,176,// Strategy is a map from variables to the way we plan to emit fixes for; // these variables. It is figured out gradually by trying different fixes; // for different variables depending on gadgets in which these variables; // participate.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/UnsafeBufferUsage.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/UnsafeBufferUsage.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/UnsafeBufferUsage.cpp:26,Modifiability,variab,variables,26,// Strategy is a map from variables to the way we plan to emit fixes for; // these variables. It is figured out gradually by trying different fixes; // for different variables depending on gadgets in which these variables; // participate.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/UnsafeBufferUsage.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/UnsafeBufferUsage.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/UnsafeBufferUsage.cpp:83,Modifiability,variab,variables,83,// Strategy is a map from variables to the way we plan to emit fixes for; // these variables. It is figured out gradually by trying different fixes; // for different variables depending on gadgets in which these variables; // participate.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/UnsafeBufferUsage.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/UnsafeBufferUsage.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/UnsafeBufferUsage.cpp:166,Modifiability,variab,variables,166,// Strategy is a map from variables to the way we plan to emit fixes for; // these variables. It is figured out gradually by trying different fixes; // for different variables depending on gadgets in which these variables; // participate.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/UnsafeBufferUsage.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/UnsafeBufferUsage.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/UnsafeBufferUsage.cpp:212,Modifiability,variab,variables,212,// Strategy is a map from variables to the way we plan to emit fixes for; // these variables. It is figured out gradually by trying different fixes; // for different variables depending on gadgets in which these variables; // participate.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/UnsafeBufferUsage.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/UnsafeBufferUsage.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/UnsafeBufferUsage.cpp:42,Modifiability,variab,variable,42,// We don't plan to emit a fixit for this variable.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/UnsafeBufferUsage.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/UnsafeBufferUsage.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/UnsafeBufferUsage.cpp:30,Modifiability,variab,variable,30,// We recommend replacing the variable with std::span.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/UnsafeBufferUsage.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/UnsafeBufferUsage.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/UnsafeBufferUsage.cpp:30,Modifiability,variab,variable,30,// We recommend replacing the variable with std::span::iterator.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/UnsafeBufferUsage.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/UnsafeBufferUsage.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/UnsafeBufferUsage.cpp:30,Modifiability,variab,variable,30,// We recommend replacing the variable with std::array.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/UnsafeBufferUsage.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/UnsafeBufferUsage.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/UnsafeBufferUsage.cpp:30,Modifiability,variab,variable,30,// We recommend replacing the variable with std::vector.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/UnsafeBufferUsage.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/UnsafeBufferUsage.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/UnsafeBufferUsage.cpp:9,Safety,avoid,avoid,9,// Let's avoid copies.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/UnsafeBufferUsage.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/UnsafeBufferUsage.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/UnsafeBufferUsage.cpp:46,Integrability,interface,interface,46,// TODO remove this method from FixableGadget interface,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/UnsafeBufferUsage.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/UnsafeBufferUsage.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/UnsafeBufferUsage.cpp:80,Safety,avoid,avoid,80,"// In debug mode, assert that we've found exactly one gadget.; // This helps us avoid conflicts in .bind() tags.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/UnsafeBufferUsage.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/UnsafeBufferUsage.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/UnsafeBufferUsage.cpp:18,Testability,assert,assert,18,"// In debug mode, assert that we've found exactly one gadget.; // This helps us avoid conflicts in .bind() tags.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/UnsafeBufferUsage.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/UnsafeBufferUsage.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/UnsafeBufferUsage.cpp:123,Testability,log,logarithmically,123,"// Figure out which matcher we've found, and call the appropriate; // subclass constructor.; // FIXME: Can we do this more logarithmically?",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/UnsafeBufferUsage.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/UnsafeBufferUsage.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/UnsafeBufferUsage.cpp:3,Safety,Avoid,Avoid,3,// Avoid a hanging comma.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/UnsafeBufferUsage.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/UnsafeBufferUsage.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/UnsafeBufferUsage.cpp:44,Modifiability,variab,variables,44,// These Gadgets are not related to pointer variables (e. g. temporaries).,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/UnsafeBufferUsage.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/UnsafeBufferUsage.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/UnsafeBufferUsage.cpp:43,Modifiability,variab,variable,43,"// If some gadgets cover more than one; // variable, they'll appear more than once in the map.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/UnsafeBufferUsage.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/UnsafeBufferUsage.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/UnsafeBufferUsage.cpp:29,Safety,detect,detection,29,// A simple interval overlap detection algorithm. Sorts all ranges by their; // begin location then finds the first overlap in one pass.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/UnsafeBufferUsage.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/UnsafeBufferUsage.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/UnsafeBufferUsage.cpp:5,Usability,simpl,simple,5,// A simple interval overlap detection algorithm. Sorts all ranges by their; // begin location then finds the first overlap in one pass.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/UnsafeBufferUsage.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/UnsafeBufferUsage.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/UnsafeBufferUsage.cpp:61,Modifiability,variab,variable,61,// Returns the begin location of the identifier of the given variable; // declaration.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/UnsafeBufferUsage.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/UnsafeBufferUsage.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/UnsafeBufferUsage.cpp:59,Modifiability,variab,variable,59,// Returns the literal text of the identifier of the given variable declaration.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/UnsafeBufferUsage.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/UnsafeBufferUsage.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/UnsafeBufferUsage.cpp:19,Modifiability,variab,variable,19,// We cannot fix a variable declaration if it has some other specifiers than the; // type specifier. Because the source ranges of those specifiers could overlap; // with the source range that is being replaced using fix-its. Especially when; // we often cannot obtain accurate source ranges of cv-qualified type; // specifiers.; // FIXME: also deal with type attributes,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/UnsafeBufferUsage.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/UnsafeBufferUsage.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/UnsafeBufferUsage.cpp:114,Modifiability,variab,variable,114,"// We only deal with the cases where the source text of the pointee type; // appears on the left-hand side of the variable identifier completely,; // including the following forms:; // `T ident`,; // `T ident[]`, where `T` is any type.; // Examples of excluded cases are `T (*ident)[]` or `T ident[][n]`.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/UnsafeBufferUsage.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/UnsafeBufferUsage.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/UnsafeBufferUsage.cpp:47,Modifiability,layers,layers,47,// note that the expr may (oddly) has multiple layers of parens; // example:; // *((..(pointer + 123)..)); // goal:; // pointer[123]; // Fix-It:; // remove '*('; // replace ' + ' with '['; // replace ')' with ']'; // example:; // *((..(123 + pointer)..)); // goal:; // 123[pointer]; // Fix-It:; // remove '*('; // replace ' + ' with '['; // replace ')' with ']',MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/UnsafeBufferUsage.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/UnsafeBufferUsage.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/UnsafeBufferUsage.cpp:380,Modifiability,variab,variable,380,"// For a non-null initializer `Init` of `T *` type, this function returns; // `FixItHint`s producing a list initializer `{Init, S}` as a part of a fix-it; // to output stream.; // In many cases, this function cannot figure out the actual extent `S`. It; // then will use a place holder to replace `S` to ask users to fill `S` in. The; // initializer shall be used to initialize a variable of type `std::span<T>`.; //; // FIXME: Support multi-level pointers; //; // Parameters:; // `Init` a pointer to the initializer expression; // `Ctx` a reference to the ASTContext",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/UnsafeBufferUsage.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/UnsafeBufferUsage.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/UnsafeBufferUsage.cpp:166,Modifiability,variab,variable,166,"// If `Init` has a constant value that is (or equivalent to) a; // NULL pointer, we use the default constructor to initialize the span; // object, i.e., a `std:span` variable declaration with no initializer.; // So the fix-it is just to remove the initializer.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/UnsafeBufferUsage.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/UnsafeBufferUsage.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/UnsafeBufferUsage.cpp:101,Deployability,patch,patch,101,// FIXME: Why does this function not ask for `const ASTContext; // &`? It should. Maybe worth an NFC patch later.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/UnsafeBufferUsage.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/UnsafeBufferUsage.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/UnsafeBufferUsage.cpp:221,Usability,simpl,simpler,221,"// In cases `Init` is `new T[n]` and there is no explicit cast over; // `Init`, we know that `Init` must evaluates to a pointer to `n` objects; // of `T`. So the extent is `n` unless `n` has side effects. Similar but; // simpler for the case where `Init` is `new T`.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/UnsafeBufferUsage.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/UnsafeBufferUsage.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/UnsafeBufferUsage.cpp:72,Modifiability,variab,variable,72,"// Although the initializer is not allocating a buffer, the pointer; // variable could still be used in buffer access operations.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/UnsafeBufferUsage.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/UnsafeBufferUsage.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/UnsafeBufferUsage.cpp:111,Security,access,access,111,"// Although the initializer is not allocating a buffer, the pointer; // variable could still be used in buffer access operations.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/UnsafeBufferUsage.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/UnsafeBufferUsage.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/UnsafeBufferUsage.cpp:17,Modifiability,variab,variable,17,"// For the given variable declaration with a pointer-to-T type, returns the text; // `std::span<T>`. If it is unable to generate the text, returns; // `std::nullopt`.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/UnsafeBufferUsage.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/UnsafeBufferUsage.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/UnsafeBufferUsage.cpp:303,Modifiability,variab,variable,303,"// For a `VarDecl` of the form `T * var (= Init)?`, this; // function generates fix-its that; // 1) replace `T * var` with `std::span<T> var`; and; // 2) change `Init` accordingly to a span constructor, if it exists.; //; // FIXME: support Multi-level pointers; //; // Parameters:; // `D` a pointer the variable declaration node; // `Ctx` a reference to the ASTContext; // `UserFillPlaceHolder` the user-input placeholder text; // Returns:; // the non-empty fix-it list, if fix-its are successfuly generated; empty; // list otherwise.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/UnsafeBufferUsage.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/UnsafeBufferUsage.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/UnsafeBufferUsage.cpp:50,Integrability,depend,depends,50,// FIXME: whether we should create std::span type depends on the Strategy.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/UnsafeBufferUsage.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/UnsafeBufferUsage.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/UnsafeBufferUsage.cpp:12,Safety,unsafe,unsafe-buffer,12,// Adds the unsafe-buffer attribute (if not already there) to `FReDecl`:,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/UnsafeBufferUsage.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/UnsafeBufferUsage.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/UnsafeBufferUsage.cpp:29,Modifiability,variab,variable,29,"// Currently DS is an unused variable but we'll need it when; // non-single decls are implemented, where the pointee type name; // and the '*' are spread around the place.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/UnsafeBufferUsage.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/UnsafeBufferUsage.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/UnsafeBufferUsage.cpp:8,Testability,test,test,8,// TODO test all these cases,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/UnsafeBufferUsage.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/UnsafeBufferUsage.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/UnsafeBufferUsage.cpp:10,Modifiability,variab,variables,10,"// Erases variables in `FixItsForVariable`, if such a variable has an unfixable; // group mate. A variable `v` is unfixable iff `FixItsForVariable` does not; // contain `v`.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/UnsafeBufferUsage.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/UnsafeBufferUsage.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/UnsafeBufferUsage.cpp:54,Modifiability,variab,variable,54,"// Erases variables in `FixItsForVariable`, if such a variable has an unfixable; // group mate. A variable `v` is unfixable iff `FixItsForVariable` does not; // contain `v`.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/UnsafeBufferUsage.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/UnsafeBufferUsage.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/UnsafeBufferUsage.cpp:98,Modifiability,variab,variable,98,"// Erases variables in `FixItsForVariable`, if such a variable has an unfixable; // group mate. A variable `v` is unfixable iff `FixItsForVariable` does not; // contain `v`.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/UnsafeBufferUsage.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/UnsafeBufferUsage.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/UnsafeBufferUsage.cpp:3,Modifiability,Variab,Variables,3,// Variables will be removed from `FixItsForVariable`:,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/UnsafeBufferUsage.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/UnsafeBufferUsage.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/UnsafeBufferUsage.cpp:42,Safety,safe,safe,42,"// Returns the fix-its that create bounds-safe function overloads for the; // function `D`, if `D`'s parameters will be changed to safe-types through; // fix-its in `FixItsForVariable`.; //; // NOTE: In case `D`'s parameters will be changed but bounds-safe function; // overloads cannot created, the whole group that contains the parameters will; // be erased from `FixItsForVariable`.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/UnsafeBufferUsage.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/UnsafeBufferUsage.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/UnsafeBufferUsage.cpp:131,Safety,safe,safe-types,131,"// Returns the fix-its that create bounds-safe function overloads for the; // function `D`, if `D`'s parameters will be changed to safe-types through; // fix-its in `FixItsForVariable`.; //; // NOTE: In case `D`'s parameters will be changed but bounds-safe function; // overloads cannot created, the whole group that contains the parameters will; // be erased from `FixItsForVariable`.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/UnsafeBufferUsage.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/UnsafeBufferUsage.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/UnsafeBufferUsage.cpp:252,Safety,safe,safe,252,"// Returns the fix-its that create bounds-safe function overloads for the; // function `D`, if `D`'s parameters will be changed to safe-types through; // fix-its in `FixItsForVariable`.; //; // NOTE: In case `D`'s parameters will be changed but bounds-safe function; // overloads cannot created, the whole group that contains the parameters will; // be erased from `FixItsForVariable`.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/UnsafeBufferUsage.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/UnsafeBufferUsage.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/UnsafeBufferUsage.cpp:46,Modifiability,variab,variable,46,// Constructs self-contained fix-its for each variable in `FixablesForAllVars`.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/UnsafeBufferUsage.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/UnsafeBufferUsage.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/UnsafeBufferUsage.cpp:37,Modifiability,variab,variable,37,// `FixItsForVariable` will map each variable to a set of fix-its directly; // associated to the variable itself. Fix-its of distinct variables in; // `FixItsForVariable` are disjoint.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/UnsafeBufferUsage.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/UnsafeBufferUsage.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/UnsafeBufferUsage.cpp:97,Modifiability,variab,variable,97,// `FixItsForVariable` will map each variable to a set of fix-its directly; // associated to the variable itself. Fix-its of distinct variables in; // `FixItsForVariable` are disjoint.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/UnsafeBufferUsage.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/UnsafeBufferUsage.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/UnsafeBufferUsage.cpp:134,Modifiability,variab,variables,134,// `FixItsForVariable` will map each variable to a set of fix-its directly; // associated to the variable itself. Fix-its of distinct variables in; // `FixItsForVariable` are disjoint.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/UnsafeBufferUsage.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/UnsafeBufferUsage.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/UnsafeBufferUsage.cpp:79,Modifiability,variab,variable,79,// Populate `FixItsForVariable` with fix-its directly associated with each; // variable. Fix-its directly associated to a variable 'v' are the ones; // produced by the `FixableGadget`s whose claimed variable is 'v'.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/UnsafeBufferUsage.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/UnsafeBufferUsage.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/UnsafeBufferUsage.cpp:122,Modifiability,variab,variable,122,// Populate `FixItsForVariable` with fix-its directly associated with each; // variable. Fix-its directly associated to a variable 'v' are the ones; // produced by the `FixableGadget`s whose claimed variable is 'v'.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/UnsafeBufferUsage.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/UnsafeBufferUsage.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/UnsafeBufferUsage.cpp:199,Modifiability,variab,variable,199,// Populate `FixItsForVariable` with fix-its directly associated with each; // variable. Fix-its directly associated to a variable 'v' are the ones; // produced by the `FixableGadget`s whose claimed variable is 'v'.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/UnsafeBufferUsage.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/UnsafeBufferUsage.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/UnsafeBufferUsage.cpp:76,Modifiability,variab,variable,76,// If we fail to produce Fix-It for the declaration we have to skip the; // variable entirely.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/UnsafeBufferUsage.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/UnsafeBufferUsage.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/UnsafeBufferUsage.cpp:41,Modifiability,variab,variables,41,// `FixItsForVariable` now contains only variables that can be; // fixed. A variable can be fixed if its' declaration and all Fixables; // associated to it can all be fixed.; // To further remove from `FixItsForVariable` variables whose group mates; // cannot be fixed...,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/UnsafeBufferUsage.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/UnsafeBufferUsage.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/UnsafeBufferUsage.cpp:76,Modifiability,variab,variable,76,// `FixItsForVariable` now contains only variables that can be; // fixed. A variable can be fixed if its' declaration and all Fixables; // associated to it can all be fixed.; // To further remove from `FixItsForVariable` variables whose group mates; // cannot be fixed...,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/UnsafeBufferUsage.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/UnsafeBufferUsage.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/UnsafeBufferUsage.cpp:221,Modifiability,variab,variables,221,// `FixItsForVariable` now contains only variables that can be; // fixed. A variable can be fixed if its' declaration and all Fixables; // associated to it can all be fixed.; // To further remove from `FixItsForVariable` variables whose group mates; // cannot be fixed...,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/UnsafeBufferUsage.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/UnsafeBufferUsage.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/UnsafeBufferUsage.cpp:40,Energy Efficiency,reduce,reduced,40,"// Now `FixItsForVariable` gets further reduced: a variable is in; // `FixItsForVariable` iff it can be fixed and all its group mates can be; // fixed.; // Fix-its of bounds-safe overloads of `D` are shared by parameters of `D`.; // That is, when fixing multiple parameters in one step, these fix-its will; // be applied only once (instead of being applied per parameter).",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/UnsafeBufferUsage.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/UnsafeBufferUsage.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/UnsafeBufferUsage.cpp:51,Modifiability,variab,variable,51,"// Now `FixItsForVariable` gets further reduced: a variable is in; // `FixItsForVariable` iff it can be fixed and all its group mates can be; // fixed.; // Fix-its of bounds-safe overloads of `D` are shared by parameters of `D`.; // That is, when fixing multiple parameters in one step, these fix-its will; // be applied only once (instead of being applied per parameter).",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/UnsafeBufferUsage.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/UnsafeBufferUsage.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/UnsafeBufferUsage.cpp:174,Safety,safe,safe,174,"// Now `FixItsForVariable` gets further reduced: a variable is in; // `FixItsForVariable` iff it can be fixed and all its group mates can be; // fixed.; // Fix-its of bounds-safe overloads of `D` are shared by parameters of `D`.; // That is, when fixing multiple parameters in one step, these fix-its will; // be applied only once (instead of being applied per parameter).",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/UnsafeBufferUsage.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/UnsafeBufferUsage.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/UnsafeBufferUsage.cpp:26,Modifiability,variab,variable,26,// The map that maps each variable `v` to fix-its for the whole group where; // `v` is in:,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/UnsafeBufferUsage.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/UnsafeBufferUsage.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/UnsafeBufferUsage.cpp:8,Testability,assert,assertion,8,// This assertion should never fail. Otherwise we have a bug.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/UnsafeBufferUsage.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/UnsafeBufferUsage.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/UnsafeBufferUsage.cpp:11,Modifiability,variab,variable,11,// Manages variable groups:,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/UnsafeBufferUsage.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/UnsafeBufferUsage.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/UnsafeBufferUsage.cpp:188,Modifiability,variab,variable,188,"// Our job is very easy without suggestions. Just warn about; // every problematic operation and consider it done. No need to deal; // with fixable gadgets, no need to group operations by variable.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/UnsafeBufferUsage.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/UnsafeBufferUsage.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/UnsafeBufferUsage.cpp:52,Safety,unsafe,unsafe,52,"// If no `WarningGadget`s ever matched, there is no unsafe operations in the; // function under the analysis. No need to fix any Fixables.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/UnsafeBufferUsage.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/UnsafeBufferUsage.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/UnsafeBufferUsage.cpp:19,Modifiability,variab,variables,19,"// Gadgets ""claim"" variables they're responsible for. Once this loop; // finishes, the tracker will only track DREs that weren't claimed by any; // gadgets, i.e. not understood by the analysis.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/UnsafeBufferUsage.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/UnsafeBufferUsage.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/UnsafeBufferUsage.cpp:260,Modifiability,variab,variable,260,"// If no `WarningGadget`s ever matched, there is no unsafe operations in the; // function under the analysis. Thus, it early returns here as there is; // nothing needs to be fixed.; //; // Note this claim is based on the assumption that there is no unsafe; // variable whose declaration is invisible from the analyzing function.; // Otherwise, we need to consider if the uses of those unsafe varuables needs; // fix.; // So far, we are not fixing any global variables or class members. And,; // lambdas will be analyzed along with the enclosing function. So this early; // return is correct for now.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/UnsafeBufferUsage.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/UnsafeBufferUsage.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/UnsafeBufferUsage.cpp:458,Modifiability,variab,variables,458,"// If no `WarningGadget`s ever matched, there is no unsafe operations in the; // function under the analysis. Thus, it early returns here as there is; // nothing needs to be fixed.; //; // Note this claim is based on the assumption that there is no unsafe; // variable whose declaration is invisible from the analyzing function.; // Otherwise, we need to consider if the uses of those unsafe varuables needs; // fix.; // So far, we are not fixing any global variables or class members. And,; // lambdas will be analyzed along with the enclosing function. So this early; // return is correct for now.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/UnsafeBufferUsage.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/UnsafeBufferUsage.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/UnsafeBufferUsage.cpp:52,Safety,unsafe,unsafe,52,"// If no `WarningGadget`s ever matched, there is no unsafe operations in the; // function under the analysis. Thus, it early returns here as there is; // nothing needs to be fixed.; //; // Note this claim is based on the assumption that there is no unsafe; // variable whose declaration is invisible from the analyzing function.; // Otherwise, we need to consider if the uses of those unsafe varuables needs; // fix.; // So far, we are not fixing any global variables or class members. And,; // lambdas will be analyzed along with the enclosing function. So this early; // return is correct for now.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/UnsafeBufferUsage.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/UnsafeBufferUsage.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/UnsafeBufferUsage.cpp:249,Safety,unsafe,unsafe,249,"// If no `WarningGadget`s ever matched, there is no unsafe operations in the; // function under the analysis. Thus, it early returns here as there is; // nothing needs to be fixed.; //; // Note this claim is based on the assumption that there is no unsafe; // variable whose declaration is invisible from the analyzing function.; // Otherwise, we need to consider if the uses of those unsafe varuables needs; // fix.; // So far, we are not fixing any global variables or class members. And,; // lambdas will be analyzed along with the enclosing function. So this early; // return is correct for now.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/UnsafeBufferUsage.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/UnsafeBufferUsage.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/UnsafeBufferUsage.cpp:385,Safety,unsafe,unsafe,385,"// If no `WarningGadget`s ever matched, there is no unsafe operations in the; // function under the analysis. Thus, it early returns here as there is; // nothing needs to be fixed.; //; // Note this claim is based on the assumption that there is no unsafe; // variable whose declaration is invisible from the analyzing function.; // Otherwise, we need to consider if the uses of those unsafe varuables needs; // fix.; // So far, we are not fixing any global variables or class members. And,; // lambdas will be analyzed along with the enclosing function. So this early; // return is correct for now.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/UnsafeBufferUsage.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/UnsafeBufferUsage.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/UnsafeBufferUsage.cpp:35,Modifiability,variab,variables,35,// FIXME: need to deal with global variables later,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/UnsafeBufferUsage.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/UnsafeBufferUsage.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/UnsafeBufferUsage.cpp:156,Integrability,Depend,DependenciesMap,156,"/*; The following code does a BFS traversal of the `PtrAssignmentGraph`; considering all unsafe vars as starting nodes and constructs an undirected; graph `DependenciesMap`. Constructing the `DependenciesMap` in this manner; elimiates all variables that are unreachable from any unsafe var. In other; words, this removes all dependencies that don't include any unsafe variable; and consequently don't need any fixit generation.; Note: A careful reader would observe that the code traverses; `PtrAssignmentGraph` using `CurrentVar` but adds edges between `Var` and; `Adj` and not between `CurrentVar` and `Adj`. Both approaches would; achieve the same result but the one used here dramatically cuts the; amount of hoops the second part of the algorithm needs to jump, given that; a lot of these connections become ""direct"". The reader is advised not to; imagine how the graph is transformed because of using `Var` instead of; `CurrentVar`. The reader can continue reading as if `CurrentVar` was used,; and think about why it's equivalent later.; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/UnsafeBufferUsage.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/UnsafeBufferUsage.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/UnsafeBufferUsage.cpp:192,Integrability,Depend,DependenciesMap,192,"/*; The following code does a BFS traversal of the `PtrAssignmentGraph`; considering all unsafe vars as starting nodes and constructs an undirected; graph `DependenciesMap`. Constructing the `DependenciesMap` in this manner; elimiates all variables that are unreachable from any unsafe var. In other; words, this removes all dependencies that don't include any unsafe variable; and consequently don't need any fixit generation.; Note: A careful reader would observe that the code traverses; `PtrAssignmentGraph` using `CurrentVar` but adds edges between `Var` and; `Adj` and not between `CurrentVar` and `Adj`. Both approaches would; achieve the same result but the one used here dramatically cuts the; amount of hoops the second part of the algorithm needs to jump, given that; a lot of these connections become ""direct"". The reader is advised not to; imagine how the graph is transformed because of using `Var` instead of; `CurrentVar`. The reader can continue reading as if `CurrentVar` was used,; and think about why it's equivalent later.; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/UnsafeBufferUsage.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/UnsafeBufferUsage.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/UnsafeBufferUsage.cpp:325,Integrability,depend,dependencies,325,"/*; The following code does a BFS traversal of the `PtrAssignmentGraph`; considering all unsafe vars as starting nodes and constructs an undirected; graph `DependenciesMap`. Constructing the `DependenciesMap` in this manner; elimiates all variables that are unreachable from any unsafe var. In other; words, this removes all dependencies that don't include any unsafe variable; and consequently don't need any fixit generation.; Note: A careful reader would observe that the code traverses; `PtrAssignmentGraph` using `CurrentVar` but adds edges between `Var` and; `Adj` and not between `CurrentVar` and `Adj`. Both approaches would; achieve the same result but the one used here dramatically cuts the; amount of hoops the second part of the algorithm needs to jump, given that; a lot of these connections become ""direct"". The reader is advised not to; imagine how the graph is transformed because of using `Var` instead of; `CurrentVar`. The reader can continue reading as if `CurrentVar` was used,; and think about why it's equivalent later.; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/UnsafeBufferUsage.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/UnsafeBufferUsage.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/UnsafeBufferUsage.cpp:239,Modifiability,variab,variables,239,"/*; The following code does a BFS traversal of the `PtrAssignmentGraph`; considering all unsafe vars as starting nodes and constructs an undirected; graph `DependenciesMap`. Constructing the `DependenciesMap` in this manner; elimiates all variables that are unreachable from any unsafe var. In other; words, this removes all dependencies that don't include any unsafe variable; and consequently don't need any fixit generation.; Note: A careful reader would observe that the code traverses; `PtrAssignmentGraph` using `CurrentVar` but adds edges between `Var` and; `Adj` and not between `CurrentVar` and `Adj`. Both approaches would; achieve the same result but the one used here dramatically cuts the; amount of hoops the second part of the algorithm needs to jump, given that; a lot of these connections become ""direct"". The reader is advised not to; imagine how the graph is transformed because of using `Var` instead of; `CurrentVar`. The reader can continue reading as if `CurrentVar` was used,; and think about why it's equivalent later.; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/UnsafeBufferUsage.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/UnsafeBufferUsage.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/UnsafeBufferUsage.cpp:368,Modifiability,variab,variable,368,"/*; The following code does a BFS traversal of the `PtrAssignmentGraph`; considering all unsafe vars as starting nodes and constructs an undirected; graph `DependenciesMap`. Constructing the `DependenciesMap` in this manner; elimiates all variables that are unreachable from any unsafe var. In other; words, this removes all dependencies that don't include any unsafe variable; and consequently don't need any fixit generation.; Note: A careful reader would observe that the code traverses; `PtrAssignmentGraph` using `CurrentVar` but adds edges between `Var` and; `Adj` and not between `CurrentVar` and `Adj`. Both approaches would; achieve the same result but the one used here dramatically cuts the; amount of hoops the second part of the algorithm needs to jump, given that; a lot of these connections become ""direct"". The reader is advised not to; imagine how the graph is transformed because of using `Var` instead of; `CurrentVar`. The reader can continue reading as if `CurrentVar` was used,; and think about why it's equivalent later.; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/UnsafeBufferUsage.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/UnsafeBufferUsage.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/UnsafeBufferUsage.cpp:89,Safety,unsafe,unsafe,89,"/*; The following code does a BFS traversal of the `PtrAssignmentGraph`; considering all unsafe vars as starting nodes and constructs an undirected; graph `DependenciesMap`. Constructing the `DependenciesMap` in this manner; elimiates all variables that are unreachable from any unsafe var. In other; words, this removes all dependencies that don't include any unsafe variable; and consequently don't need any fixit generation.; Note: A careful reader would observe that the code traverses; `PtrAssignmentGraph` using `CurrentVar` but adds edges between `Var` and; `Adj` and not between `CurrentVar` and `Adj`. Both approaches would; achieve the same result but the one used here dramatically cuts the; amount of hoops the second part of the algorithm needs to jump, given that; a lot of these connections become ""direct"". The reader is advised not to; imagine how the graph is transformed because of using `Var` instead of; `CurrentVar`. The reader can continue reading as if `CurrentVar` was used,; and think about why it's equivalent later.; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/UnsafeBufferUsage.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/UnsafeBufferUsage.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/UnsafeBufferUsage.cpp:279,Safety,unsafe,unsafe,279,"/*; The following code does a BFS traversal of the `PtrAssignmentGraph`; considering all unsafe vars as starting nodes and constructs an undirected; graph `DependenciesMap`. Constructing the `DependenciesMap` in this manner; elimiates all variables that are unreachable from any unsafe var. In other; words, this removes all dependencies that don't include any unsafe variable; and consequently don't need any fixit generation.; Note: A careful reader would observe that the code traverses; `PtrAssignmentGraph` using `CurrentVar` but adds edges between `Var` and; `Adj` and not between `CurrentVar` and `Adj`. Both approaches would; achieve the same result but the one used here dramatically cuts the; amount of hoops the second part of the algorithm needs to jump, given that; a lot of these connections become ""direct"". The reader is advised not to; imagine how the graph is transformed because of using `Var` instead of; `CurrentVar`. The reader can continue reading as if `CurrentVar` was used,; and think about why it's equivalent later.; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/UnsafeBufferUsage.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/UnsafeBufferUsage.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/UnsafeBufferUsage.cpp:361,Safety,unsafe,unsafe,361,"/*; The following code does a BFS traversal of the `PtrAssignmentGraph`; considering all unsafe vars as starting nodes and constructs an undirected; graph `DependenciesMap`. Constructing the `DependenciesMap` in this manner; elimiates all variables that are unreachable from any unsafe var. In other; words, this removes all dependencies that don't include any unsafe variable; and consequently don't need any fixit generation.; Note: A careful reader would observe that the code traverses; `PtrAssignmentGraph` using `CurrentVar` but adds edges between `Var` and; `Adj` and not between `CurrentVar` and `Adj`. Both approaches would; achieve the same result but the one used here dramatically cuts the; amount of hoops the second part of the algorithm needs to jump, given that; a lot of these connections become ""direct"". The reader is advised not to; imagine how the graph is transformed because of using `Var` instead of; `CurrentVar`. The reader can continue reading as if `CurrentVar` was used,; and think about why it's equivalent later.; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/UnsafeBufferUsage.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/UnsafeBufferUsage.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/UnsafeBufferUsage.cpp:20,Modifiability,variab,variables,20,// `VarGrpMap` maps variables that need fix to the groups (indexes) that the; // variables belong to. Group indexes refer to the elements in `Groups`.; // `VarGrpMap` is complete in that every variable that needs fix is in it.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/UnsafeBufferUsage.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/UnsafeBufferUsage.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/UnsafeBufferUsage.cpp:81,Modifiability,variab,variables,81,// `VarGrpMap` maps variables that need fix to the groups (indexes) that the; // variables belong to. Group indexes refer to the elements in `Groups`.; // `VarGrpMap` is complete in that every variable that needs fix is in it.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/UnsafeBufferUsage.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/UnsafeBufferUsage.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/UnsafeBufferUsage.cpp:193,Modifiability,variab,variable,193,// `VarGrpMap` maps variables that need fix to the groups (indexes) that the; // variables belong to. Group indexes refer to the elements in `Groups`.; // `VarGrpMap` is complete in that every variable that needs fix is in it.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/UnsafeBufferUsage.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/UnsafeBufferUsage.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/UnsafeBufferUsage.cpp:100,Integrability,Depend,Dependencies,100,// these variables need to be fixed in one step; // Group Connected Components for Unsafe Vars; // (Dependencies based on pointer assignments),MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/UnsafeBufferUsage.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/UnsafeBufferUsage.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/UnsafeBufferUsage.cpp:9,Modifiability,variab,variables,9,// these variables need to be fixed in one step; // Group Connected Components for Unsafe Vars; // (Dependencies based on pointer assignments),MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/UnsafeBufferUsage.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/UnsafeBufferUsage.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/UnsafeBufferUsage.cpp:83,Safety,Unsafe,Unsafe,83,// these variables need to be fixed in one step; // Group Connected Components for Unsafe Vars; // (Dependencies based on pointer assignments),MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/UnsafeBufferUsage.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/UnsafeBufferUsage.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/UnsafeBufferUsage.cpp:46,Modifiability,variab,variable,46,"// Remove a `FixableGadget` if the associated variable is not in the graph; // computed above. We do not want to generate fix-its for such variables,; // since they are neither warned nor reachable from a warned one.; //; // Note a variable is not warned if it is not directly used in any unsafe; // operation. A variable `v` is NOT reachable from an unsafe variable, if it; // does not exist another variable `u` such that `u` is warned and fixing `u`; // (transitively) implicates fixing `v`.; //; // For example,; // ```; // void f(int * p) {; // int * a = p; *p = 0;; // }; // ```; // `*p = 0` is a fixable gadget associated with a variable `p` that is neither; // warned nor reachable from a warned one. If we add `a[5] = 0` to the end of; // the function above, `p` becomes reachable from a warned variable.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/UnsafeBufferUsage.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/UnsafeBufferUsage.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/UnsafeBufferUsage.cpp:139,Modifiability,variab,variables,139,"// Remove a `FixableGadget` if the associated variable is not in the graph; // computed above. We do not want to generate fix-its for such variables,; // since they are neither warned nor reachable from a warned one.; //; // Note a variable is not warned if it is not directly used in any unsafe; // operation. A variable `v` is NOT reachable from an unsafe variable, if it; // does not exist another variable `u` such that `u` is warned and fixing `u`; // (transitively) implicates fixing `v`.; //; // For example,; // ```; // void f(int * p) {; // int * a = p; *p = 0;; // }; // ```; // `*p = 0` is a fixable gadget associated with a variable `p` that is neither; // warned nor reachable from a warned one. If we add `a[5] = 0` to the end of; // the function above, `p` becomes reachable from a warned variable.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/UnsafeBufferUsage.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/UnsafeBufferUsage.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/UnsafeBufferUsage.cpp:232,Modifiability,variab,variable,232,"// Remove a `FixableGadget` if the associated variable is not in the graph; // computed above. We do not want to generate fix-its for such variables,; // since they are neither warned nor reachable from a warned one.; //; // Note a variable is not warned if it is not directly used in any unsafe; // operation. A variable `v` is NOT reachable from an unsafe variable, if it; // does not exist another variable `u` such that `u` is warned and fixing `u`; // (transitively) implicates fixing `v`.; //; // For example,; // ```; // void f(int * p) {; // int * a = p; *p = 0;; // }; // ```; // `*p = 0` is a fixable gadget associated with a variable `p` that is neither; // warned nor reachable from a warned one. If we add `a[5] = 0` to the end of; // the function above, `p` becomes reachable from a warned variable.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/UnsafeBufferUsage.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/UnsafeBufferUsage.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/UnsafeBufferUsage.cpp:313,Modifiability,variab,variable,313,"// Remove a `FixableGadget` if the associated variable is not in the graph; // computed above. We do not want to generate fix-its for such variables,; // since they are neither warned nor reachable from a warned one.; //; // Note a variable is not warned if it is not directly used in any unsafe; // operation. A variable `v` is NOT reachable from an unsafe variable, if it; // does not exist another variable `u` such that `u` is warned and fixing `u`; // (transitively) implicates fixing `v`.; //; // For example,; // ```; // void f(int * p) {; // int * a = p; *p = 0;; // }; // ```; // `*p = 0` is a fixable gadget associated with a variable `p` that is neither; // warned nor reachable from a warned one. If we add `a[5] = 0` to the end of; // the function above, `p` becomes reachable from a warned variable.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/UnsafeBufferUsage.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/UnsafeBufferUsage.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/UnsafeBufferUsage.cpp:358,Modifiability,variab,variable,358,"// Remove a `FixableGadget` if the associated variable is not in the graph; // computed above. We do not want to generate fix-its for such variables,; // since they are neither warned nor reachable from a warned one.; //; // Note a variable is not warned if it is not directly used in any unsafe; // operation. A variable `v` is NOT reachable from an unsafe variable, if it; // does not exist another variable `u` such that `u` is warned and fixing `u`; // (transitively) implicates fixing `v`.; //; // For example,; // ```; // void f(int * p) {; // int * a = p; *p = 0;; // }; // ```; // `*p = 0` is a fixable gadget associated with a variable `p` that is neither; // warned nor reachable from a warned one. If we add `a[5] = 0` to the end of; // the function above, `p` becomes reachable from a warned variable.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/UnsafeBufferUsage.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/UnsafeBufferUsage.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/UnsafeBufferUsage.cpp:401,Modifiability,variab,variable,401,"// Remove a `FixableGadget` if the associated variable is not in the graph; // computed above. We do not want to generate fix-its for such variables,; // since they are neither warned nor reachable from a warned one.; //; // Note a variable is not warned if it is not directly used in any unsafe; // operation. A variable `v` is NOT reachable from an unsafe variable, if it; // does not exist another variable `u` such that `u` is warned and fixing `u`; // (transitively) implicates fixing `v`.; //; // For example,; // ```; // void f(int * p) {; // int * a = p; *p = 0;; // }; // ```; // `*p = 0` is a fixable gadget associated with a variable `p` that is neither; // warned nor reachable from a warned one. If we add `a[5] = 0` to the end of; // the function above, `p` becomes reachable from a warned variable.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/UnsafeBufferUsage.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/UnsafeBufferUsage.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/UnsafeBufferUsage.cpp:636,Modifiability,variab,variable,636,"// Remove a `FixableGadget` if the associated variable is not in the graph; // computed above. We do not want to generate fix-its for such variables,; // since they are neither warned nor reachable from a warned one.; //; // Note a variable is not warned if it is not directly used in any unsafe; // operation. A variable `v` is NOT reachable from an unsafe variable, if it; // does not exist another variable `u` such that `u` is warned and fixing `u`; // (transitively) implicates fixing `v`.; //; // For example,; // ```; // void f(int * p) {; // int * a = p; *p = 0;; // }; // ```; // `*p = 0` is a fixable gadget associated with a variable `p` that is neither; // warned nor reachable from a warned one. If we add `a[5] = 0` to the end of; // the function above, `p` becomes reachable from a warned variable.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/UnsafeBufferUsage.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/UnsafeBufferUsage.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/UnsafeBufferUsage.cpp:804,Modifiability,variab,variable,804,"// Remove a `FixableGadget` if the associated variable is not in the graph; // computed above. We do not want to generate fix-its for such variables,; // since they are neither warned nor reachable from a warned one.; //; // Note a variable is not warned if it is not directly used in any unsafe; // operation. A variable `v` is NOT reachable from an unsafe variable, if it; // does not exist another variable `u` such that `u` is warned and fixing `u`; // (transitively) implicates fixing `v`.; //; // For example,; // ```; // void f(int * p) {; // int * a = p; *p = 0;; // }; // ```; // `*p = 0` is a fixable gadget associated with a variable `p` that is neither; // warned nor reachable from a warned one. If we add `a[5] = 0` to the end of; // the function above, `p` becomes reachable from a warned variable.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/UnsafeBufferUsage.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/UnsafeBufferUsage.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/UnsafeBufferUsage.cpp:289,Safety,unsafe,unsafe,289,"// Remove a `FixableGadget` if the associated variable is not in the graph; // computed above. We do not want to generate fix-its for such variables,; // since they are neither warned nor reachable from a warned one.; //; // Note a variable is not warned if it is not directly used in any unsafe; // operation. A variable `v` is NOT reachable from an unsafe variable, if it; // does not exist another variable `u` such that `u` is warned and fixing `u`; // (transitively) implicates fixing `v`.; //; // For example,; // ```; // void f(int * p) {; // int * a = p; *p = 0;; // }; // ```; // `*p = 0` is a fixable gadget associated with a variable `p` that is neither; // warned nor reachable from a warned one. If we add `a[5] = 0` to the end of; // the function above, `p` becomes reachable from a warned variable.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/UnsafeBufferUsage.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/UnsafeBufferUsage.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/UnsafeBufferUsage.cpp:351,Safety,unsafe,unsafe,351,"// Remove a `FixableGadget` if the associated variable is not in the graph; // computed above. We do not want to generate fix-its for such variables,; // since they are neither warned nor reachable from a warned one.; //; // Note a variable is not warned if it is not directly used in any unsafe; // operation. A variable `v` is NOT reachable from an unsafe variable, if it; // does not exist another variable `u` such that `u` is warned and fixing `u`; // (transitively) implicates fixing `v`.; //; // For example,; // ```; // void f(int * p) {; // int * a = p; *p = 0;; // }; // ```; // `*p = 0` is a fixable gadget associated with a variable `p` that is neither; // warned nor reachable from a warned one. If we add `a[5] = 0` to the end of; // the function above, `p` becomes reachable from a warned variable.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/UnsafeBufferUsage.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/UnsafeBufferUsage.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/UnsafeBufferUsage.cpp:38,Modifiability,variab,variables,38,// Note `VisitedVars` contain all the variables in the graph:,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/UnsafeBufferUsage.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/UnsafeBufferUsage.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/UnsafeBufferUsage.cpp:27,Modifiability,variab,variables,27,"// We assign strategies to variables that are 1) in the graph and 2) can be; // fixed. Other variables have the default ""Won't fix"" strategy.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/UnsafeBufferUsage.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/UnsafeBufferUsage.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/UnsafeBufferUsage.cpp:93,Modifiability,variab,variables,93,"// We assign strategies to variables that are 1) in the graph and 2) can be; // fixed. Other variables have the default ""Won't fix"" strategy.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/UnsafeBufferUsage.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/UnsafeBufferUsage.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/UnsafeBufferUsage.cpp:15,Modifiability,variab,variable,15,"// If a warned variable has no ""Fixable"", it is considered unfixable:",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/UnsafeBufferUsage.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/UnsafeBufferUsage.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/UnsafeBufferUsage.cpp:96,Modifiability,variab,variables,96,// The only case where `D` is not a `NamedDecl` is when `D` is a; // `BlockDecl`. Let's not fix variables in blocks for now,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/UnsafeBufferUsage.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/UnsafeBufferUsage.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/FlowSensitive/Arena.cpp:33,Modifiability,variab,variables,33,"// For now, only support unnamed variables V0, V1 etc.; // FIXME: parse e.g. ""X"" by allocating an atom and storing a name somewhere.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/FlowSensitive/Arena.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/FlowSensitive/Arena.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/FlowSensitive/ControlFlowContext.cpp:53,Integrability,depend,depending,53,// The shape of certain elements of the AST can vary depending on the; // language. We currently only support C++.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/FlowSensitive/ControlFlowContext.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/FlowSensitive/ControlFlowContext.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/FlowSensitive/DataflowAnalysisContext.cpp:54,Energy Efficiency,allocate,allocated,54,"// During context-sensitive analysis, a struct may be allocated in one; // function, but its field accessed in a function lower in the stack than; // the allocation. Since we only collect fields used in the function where; // the allocation occurs, we can't apply that filter when performing; // context-sensitive analysis. But, this only applies to storage locations,; // since field access it not allowed to fail. In contrast, field *values*; // don't need this allowance, since the API allows for uninitialized fields.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/FlowSensitive/DataflowAnalysisContext.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/FlowSensitive/DataflowAnalysisContext.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/FlowSensitive/DataflowAnalysisContext.cpp:281,Performance,perform,performing,281,"// During context-sensitive analysis, a struct may be allocated in one; // function, but its field accessed in a function lower in the stack than; // the allocation. Since we only collect fields used in the function where; // the allocation occurs, we can't apply that filter when performing; // context-sensitive analysis. But, this only applies to storage locations,; // since field access it not allowed to fail. In contrast, field *values*; // don't need this allowance, since the API allows for uninitialized fields.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/FlowSensitive/DataflowAnalysisContext.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/FlowSensitive/DataflowAnalysisContext.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/FlowSensitive/DataflowAnalysisContext.cpp:99,Security,access,accessed,99,"// During context-sensitive analysis, a struct may be allocated in one; // function, but its field accessed in a function lower in the stack than; // the allocation. Since we only collect fields used in the function where; // the allocation occurs, we can't apply that filter when performing; // context-sensitive analysis. But, this only applies to storage locations,; // since field access it not allowed to fail. In contrast, field *values*; // don't need this allowance, since the API allows for uninitialized fields.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/FlowSensitive/DataflowAnalysisContext.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/FlowSensitive/DataflowAnalysisContext.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/FlowSensitive/DataflowAnalysisContext.cpp:385,Security,access,access,385,"// During context-sensitive analysis, a struct may be allocated in one; // function, but its field accessed in a function lower in the stack than; // the allocation. Since we only collect fields used in the function where; // the allocation occurs, we can't apply that filter when performing; // context-sensitive analysis. But, this only applies to storage locations,; // since field access it not allowed to fail. In contrast, field *values*; // don't need this allowance, since the API allows for uninitialized fields.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/FlowSensitive/DataflowAnalysisContext.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/FlowSensitive/DataflowAnalysisContext.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/FlowSensitive/DataflowAnalysisContext.cpp:17,Availability,error,errors,17,// FIXME: Handle errors.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/FlowSensitive/DataflowAnalysisContext.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/FlowSensitive/DataflowAnalysisContext.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/FlowSensitive/DataflowAnalysisContext.cpp:43,Testability,log,log,43,"// All analysis runs within a process will log to the same directory.; // Share a counter so they don't all overwrite each other's 0.html.; // (Don't share a logger, it's not threadsafe).",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/FlowSensitive/DataflowAnalysisContext.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/FlowSensitive/DataflowAnalysisContext.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/FlowSensitive/DataflowAnalysisContext.cpp:158,Testability,log,logger,158,"// All analysis runs within a process will log to the same directory.; // Share a counter so they don't all overwrite each other's 0.html.; // (Don't share a logger, it's not threadsafe).",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/FlowSensitive/DataflowAnalysisContext.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/FlowSensitive/DataflowAnalysisContext.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/FlowSensitive/DataflowAnalysisContext.cpp:20,Testability,log,log,20,"// If the -dataflow-log command-line flag was set, synthesize a logger.; // This is ugly but provides a uniform method for ad-hoc debugging dataflow-; // based tools.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/FlowSensitive/DataflowAnalysisContext.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/FlowSensitive/DataflowAnalysisContext.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/FlowSensitive/DataflowAnalysisContext.cpp:64,Testability,log,logger,64,"// If the -dataflow-log command-line flag was set, synthesize a logger.; // This is ugly but provides a uniform method for ad-hoc debugging dataflow-; // based tools.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/FlowSensitive/DataflowAnalysisContext.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/FlowSensitive/DataflowAnalysisContext.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/FlowSensitive/DataflowAnalysisContext.cpp:54,Testability,log,log,54,"// FIXME: if the flag is given a value, write an HTML log to a file.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/FlowSensitive/DataflowAnalysisContext.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/FlowSensitive/DataflowAnalysisContext.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/FlowSensitive/DataflowAnalysisContext.cpp:56,Modifiability,inherit,inheritance,56,// FIXME: Does not precisely handle non-virtual diamond inheritance. A single; // field decl will be modeled for all instances of the inherited field.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/FlowSensitive/DataflowAnalysisContext.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/FlowSensitive/DataflowAnalysisContext.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/FlowSensitive/DataflowAnalysisContext.cpp:134,Modifiability,inherit,inherited,134,// FIXME: Does not precisely handle non-virtual diamond inheritance. A single; // field decl will be modeled for all instances of the inherited field.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/FlowSensitive/DataflowAnalysisContext.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/FlowSensitive/DataflowAnalysisContext.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/FlowSensitive/DataflowEnvironment.cpp:115,Security,validat,validated,115,"// FIXME: convert these to parameters of the analysis or environment. Current; // settings have been experimentaly validated, but only for a particular; // analysis.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/FlowSensitive/DataflowEnvironment.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/FlowSensitive/DataflowEnvironment.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/FlowSensitive/DataflowEnvironment.cpp:178,Testability,log,logic,178,"// Note: Potentially costly, but, for booleans, we could check whether both; // can be proven equivalent in their respective environments.; // FIXME: move the reference/pointers logic from `areEquivalentValues` to here; // and implement separate, join/widen specific handling for; // reference/pointers.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/FlowSensitive/DataflowEnvironment.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/FlowSensitive/DataflowEnvironment.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/FlowSensitive/DataflowEnvironment.cpp:246,Integrability,depend,depends,246,"/// Attempts to merge distinct values `Val1` and `Val2` in `Env1` and `Env2`,; /// respectively, of the same type `Type`. Merging generally produces a single; /// value that (soundly) approximates the two inputs, although the actual; /// meaning depends on `Model`.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/FlowSensitive/DataflowEnvironment.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/FlowSensitive/DataflowEnvironment.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/FlowSensitive/DataflowEnvironment.cpp:172,Modifiability,variab,variables,172,"// FIXME: Checking both values should be unnecessary, since they should have; // a consistent shape. However, right now we can end up with BoolValue's in; // integer-typed variables due to our incorrect handling of; // boolean-to-integer casts (we just propagate the BoolValue to the result; // of the cast). So, a join can encounter an integer in one branch but a; // bool in the other.; // For example:; // ```; // std::optional<bool> o;; // int x;; // if (o.has_value()); // x = o.value();; // ```",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/FlowSensitive/DataflowEnvironment.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/FlowSensitive/DataflowEnvironment.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/FlowSensitive/DataflowEnvironment.cpp:100,Safety,avoid,avoid,100,// FIXME: Consider destroying `MergedValue` immediately if `ValueModel::merge`; // returns false to avoid storing unneeded values in `DACtx`.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/FlowSensitive/DataflowEnvironment.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/FlowSensitive/DataflowEnvironment.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/FlowSensitive/DataflowEnvironment.cpp:175,Usability,simpl,simply,175,"// We may need to widen to Top, but before we do so, check whether both; // values are implied to be either true or false in the current environment.; // In that case, we can simply return a literal instead.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/FlowSensitive/DataflowEnvironment.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/FlowSensitive/DataflowEnvironment.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/FlowSensitive/DataflowEnvironment.cpp:3,Performance,Perform,Perform,3,// Perform a join on two `LocToVal` maps.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/FlowSensitive/DataflowEnvironment.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/FlowSensitive/DataflowEnvironment.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/FlowSensitive/DataflowEnvironment.cpp:3,Performance,Perform,Perform,3,// Perform widening on either `LocToVal` or `ExprToVal`. `Key` must be either; // `const StorageLocation *` or `const Expr *`.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/FlowSensitive/DataflowEnvironment.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/FlowSensitive/DataflowEnvironment.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/FlowSensitive/DataflowEnvironment.cpp:88,Modifiability,variab,variables,88,"/// Traverses `S` and inserts into `Fields`, `Vars` and `Funcs` any fields,; /// global variables and functions that are declared in or referenced from; /// sub-statements.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/FlowSensitive/DataflowEnvironment.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/FlowSensitive/DataflowEnvironment.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/FlowSensitive/DataflowEnvironment.cpp:45,Modifiability,variab,variable,45,"// If this is a method that returns a member variable but does nothing else,; // model the field of the return value.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/FlowSensitive/DataflowEnvironment.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/FlowSensitive/DataflowEnvironment.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/FlowSensitive/DataflowEnvironment.cpp:19,Modifiability,variab,variable,19,// Look for global variable and field references in the; // constructor-initializers.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/FlowSensitive/DataflowEnvironment.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/FlowSensitive/DataflowEnvironment.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/FlowSensitive/DataflowEnvironment.cpp:407,Testability,test,test,407,"// `ReturnVal` might not always get set -- for example if we have a return; // statement of the form `return some_other_func()` and we decide not to; // analyze `some_other_func()`.; // In this case, we can't say anything about the joined return value -- we; // don't simply want to propagate the return value that we do have, because; // it might not be the correct one.; // This occurs for example in the test `ContextSensitiveMutualRecursion`.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/FlowSensitive/DataflowEnvironment.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/FlowSensitive/DataflowEnvironment.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/FlowSensitive/DataflowEnvironment.cpp:268,Usability,simpl,simply,268,"// `ReturnVal` might not always get set -- for example if we have a return; // statement of the form `return some_other_func()` and we decide not to; // analyze `some_other_func()`.; // In this case, we can't say anything about the joined return value -- we; // don't simply want to propagate the return value that we do have, because; // it might not be the correct one.; // This occurs for example in the test `ContextSensitiveMutualRecursion`.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/FlowSensitive/DataflowEnvironment.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/FlowSensitive/DataflowEnvironment.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/FlowSensitive/DataflowEnvironment.cpp:10,Deployability,update,update,10,// FIXME: update join to detect backedges and simplify the flow condition; // accordingly.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/FlowSensitive/DataflowEnvironment.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/FlowSensitive/DataflowEnvironment.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/FlowSensitive/DataflowEnvironment.cpp:25,Safety,detect,detect,25,// FIXME: update join to detect backedges and simplify the flow condition; // accordingly.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/FlowSensitive/DataflowEnvironment.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/FlowSensitive/DataflowEnvironment.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/FlowSensitive/DataflowEnvironment.cpp:46,Usability,simpl,simplify,46,// FIXME: update join to detect backedges and simplify the flow condition; // accordingly.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/FlowSensitive/DataflowEnvironment.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/FlowSensitive/DataflowEnvironment.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/FlowSensitive/DataflowEnvironment.cpp:105,Security,access,access,105,"// We intentionally leave `JoinedEnv.ExprToLoc` and `JoinedEnv.ExprToVal`; // empty, as we never need to access entries in these maps outside of the; // basic block that sets them.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/FlowSensitive/DataflowEnvironment.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/FlowSensitive/DataflowEnvironment.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/FlowSensitive/DataflowEnvironment.cpp:379,Availability,down,down,379,"// The framework currently does not propagate the objects created in; // the two branches of a `ConditionalOperator` because there is no way; // to reconcile their storage locations, which are different. We; // therefore claim that the `ConditionalOperator` is the expression; // that originally constructs the object.; // Ultimately, this will be fixed by propagating locations down from; // the result object, rather than up from the original constructor as; // we do now (see also the FIXME in the documentation for; // `getResultObjectLocation()`).",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/FlowSensitive/DataflowEnvironment.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/FlowSensitive/DataflowEnvironment.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/FlowSensitive/DataflowEnvironment.cpp:49,Testability,assert,assertions,49,// Returns a storage location that we can use if assertions fail.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/FlowSensitive/DataflowEnvironment.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/FlowSensitive/DataflowEnvironment.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/FlowSensitive/DataflowEnvironment.cpp:12,Modifiability,variab,variables,12,"// Although variables of reference type always need to be initialized, it; // can happen that we can't see the initializer, so `InitExpr` may still; // be null.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/FlowSensitive/DataflowEnvironment.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/FlowSensitive/DataflowEnvironment.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/FlowSensitive/DataflowEnvironment.cpp:688,Deployability,update,update,688,"// In the (few) cases where an expression is intentionally; // ""uninterpreted"", `InitExpr` is not associated with a value. There are; // two ways to handle this situation: propagate the status, so that; // uninterpreted initializers result in uninterpreted variables, or; // provide a default value. We choose the latter so that later refinements; // of the variable can be used for reasoning about the surrounding code.; // For this reason, we let this case be handled by the `createValue()`; // call below.; //; // FIXME. If and when we interpret all language cases, change this to; // assert that `InitExpr` is interpreted, rather than supplying a; // default value (assuming we don't update the environment API to return; // references).",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/FlowSensitive/DataflowEnvironment.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/FlowSensitive/DataflowEnvironment.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/FlowSensitive/DataflowEnvironment.cpp:257,Modifiability,variab,variables,257,"// In the (few) cases where an expression is intentionally; // ""uninterpreted"", `InitExpr` is not associated with a value. There are; // two ways to handle this situation: propagate the status, so that; // uninterpreted initializers result in uninterpreted variables, or; // provide a default value. We choose the latter so that later refinements; // of the variable can be used for reasoning about the surrounding code.; // For this reason, we let this case be handled by the `createValue()`; // call below.; //; // FIXME. If and when we interpret all language cases, change this to; // assert that `InitExpr` is interpreted, rather than supplying a; // default value (assuming we don't update the environment API to return; // references).",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/FlowSensitive/DataflowEnvironment.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/FlowSensitive/DataflowEnvironment.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/FlowSensitive/DataflowEnvironment.cpp:358,Modifiability,variab,variable,358,"// In the (few) cases where an expression is intentionally; // ""uninterpreted"", `InitExpr` is not associated with a value. There are; // two ways to handle this situation: propagate the status, so that; // uninterpreted initializers result in uninterpreted variables, or; // provide a default value. We choose the latter so that later refinements; // of the variable can be used for reasoning about the surrounding code.; // For this reason, we let this case be handled by the `createValue()`; // call below.; //; // FIXME. If and when we interpret all language cases, change this to; // assert that `InitExpr` is interpreted, rather than supplying a; // default value (assuming we don't update the environment API to return; // references).",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/FlowSensitive/DataflowEnvironment.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/FlowSensitive/DataflowEnvironment.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/FlowSensitive/DataflowEnvironment.cpp:588,Testability,assert,assert,588,"// In the (few) cases where an expression is intentionally; // ""uninterpreted"", `InitExpr` is not associated with a value. There are; // two ways to handle this situation: propagate the status, so that; // uninterpreted initializers result in uninterpreted variables, or; // provide a default value. We choose the latter so that later refinements; // of the variable can be used for reasoning about the surrounding code.; // For this reason, we let this case be handled by the `createValue()`; // call below.; //; // FIXME. If and when we interpret all language cases, change this to; // assert that `InitExpr` is interpreted, rather than supplying a; // default value (assuming we don't update the environment API to return; // references).",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/FlowSensitive/DataflowEnvironment.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/FlowSensitive/DataflowEnvironment.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/FlowSensitive/DataflowEnvironment.cpp:232,Safety,avoid,avoid,232,"// Unnamed bitfields are only used for padding and do not appear in; // `InitListExpr`'s inits. However, those fields do appear in `RecordDecl`'s; // field list, and we thus need to remove them before mapping inits to; // fields to avoid mapping inits to the wrongs fields.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/FlowSensitive/DataflowEnvironment.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/FlowSensitive/DataflowEnvironment.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/FlowSensitive/HTMLLogger.cpp:1936,Deployability,update,updated,1936,"rst analysis, etc.; // These files contain a visualization that allows inspecting the CFG and the; // state of the analysis at each point.; // Static assets (HTMLLogger.js, HTMLLogger.css) and SVG graphs etc are embedded; // so each output file is self-contained.; //; // VIEWS; //; // The timeline and function view are always shown. These allow selecting basic; // blocks, statements within them, and processing iterations (BBs are visited; // multiple times when e.g. loops are involved).; // These are written directly into the HTML body.; //; // There are also listings of particular basic blocks, and dumps of the state; // at particular analysis points (i.e. BB2 iteration 3 statement 2).; // These are only shown when the relevant BB/analysis point is *selected*.; //; // DATA AND TEMPLATES; //; // The HTML proper is mostly static.; // The analysis data is in a JSON object HTMLLoggerData which is embedded as; // a <script> in the <head>.; // This gets rendered into DOM by a simple template processor which substitutes; // the data into <template> tags embedded in the HTML. (see inflate() in JS).; //; // SELECTION; //; // This is the only real interactive mechanism.; //; // At any given time, there are several named selections, e.g.:; // bb: B2 (basic block 0 is selected); // elt: B2.4 (statement 4 is selected); // iter: B2:1 (iteration 1 of the basic block is selected); // hover: B3 (hovering over basic block 3); //; // The selection is updated by mouse events: hover by moving the mouse and; // others by clicking. Elements that are click targets generally have attributes; // (id or data-foo) that define what they should select.; // See watchSelection() in JS for the exact logic.; //; // When the ""bb"" selection is set to ""B2"":; // - sections <section data-selection=""bb""> get shown; // - templates under such sections get re-rendered; // - elements with class/id ""B2"" get class ""bb-select""; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/FlowSensitive/HTMLLogger.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/FlowSensitive/HTMLLogger.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/FlowSensitive/HTMLLogger.cpp:413,Testability,log,logger,413,"//===-- HTMLLogger.cpp ----------------------------------------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements the HTML logger. Given a directory dir/, we write; // dir/0.html for the first analysis, etc.; // These files contain a visualization that allows inspecting the CFG and the; // state of the analysis at each point.; // Static assets (HTMLLogger.js, HTMLLogger.css) and SVG graphs etc are embedded; // so each output file is self-contained.; //; // VIEWS; //; // The timeline and function view are always shown. These allow selecting basic; // blocks, statements within them, and processing iterations (BBs are visited; // multiple times when e.g. loops are involved).; // These are written directly into the HTML body.; //; // There are also listings of particular basic blocks, and dumps of the state; // at particular analysis points (i.e. BB2 iteration 3 statement 2).; // These are only shown when the relevant BB/analysis point is *selected*.; //; // DATA AND TEMPLATES; //; // The HTML proper is mostly static.; // The analysis data is in a JSON object HTMLLoggerData which is embedded as; // a <script> in the <head>.; // This gets rendered into DOM by a simple template processor which substitutes; // the data into <template> tags embedded in the HTML. (see inflate() in JS).; //; // SELECTION; //; // This is the only real interactive mechanism.; //; // At any given time, there are several named selections, e.g.:; // bb: B2 (basic block 0 is selected); // elt: B2.4 (statement 4 is selected); // iter: B2:1 (iteration 1 of the basic block is selected); // hover: B3 (hovering over basic block 3); //; // The selection is updated by mouse events: hover by moving the mouse and; // others",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/FlowSensitive/HTMLLogger.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/FlowSensitive/HTMLLogger.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/FlowSensitive/HTMLLogger.cpp:2176,Testability,log,logic,2176,"rst analysis, etc.; // These files contain a visualization that allows inspecting the CFG and the; // state of the analysis at each point.; // Static assets (HTMLLogger.js, HTMLLogger.css) and SVG graphs etc are embedded; // so each output file is self-contained.; //; // VIEWS; //; // The timeline and function view are always shown. These allow selecting basic; // blocks, statements within them, and processing iterations (BBs are visited; // multiple times when e.g. loops are involved).; // These are written directly into the HTML body.; //; // There are also listings of particular basic blocks, and dumps of the state; // at particular analysis points (i.e. BB2 iteration 3 statement 2).; // These are only shown when the relevant BB/analysis point is *selected*.; //; // DATA AND TEMPLATES; //; // The HTML proper is mostly static.; // The analysis data is in a JSON object HTMLLoggerData which is embedded as; // a <script> in the <head>.; // This gets rendered into DOM by a simple template processor which substitutes; // the data into <template> tags embedded in the HTML. (see inflate() in JS).; //; // SELECTION; //; // This is the only real interactive mechanism.; //; // At any given time, there are several named selections, e.g.:; // bb: B2 (basic block 0 is selected); // elt: B2.4 (statement 4 is selected); // iter: B2:1 (iteration 1 of the basic block is selected); // hover: B3 (hovering over basic block 3); //; // The selection is updated by mouse events: hover by moving the mouse and; // others by clicking. Elements that are click targets generally have attributes; // (id or data-foo) that define what they should select.; // See watchSelection() in JS for the exact logic.; //; // When the ""bb"" selection is set to ""B2"":; // - sections <section data-selection=""bb""> get shown; // - templates under such sections get re-rendered; // - elements with class/id ""B2"" get class ""bb-select""; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/FlowSensitive/HTMLLogger.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/FlowSensitive/HTMLLogger.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/FlowSensitive/HTMLLogger.cpp:1465,Usability,simpl,simple,1465,"rst analysis, etc.; // These files contain a visualization that allows inspecting the CFG and the; // state of the analysis at each point.; // Static assets (HTMLLogger.js, HTMLLogger.css) and SVG graphs etc are embedded; // so each output file is self-contained.; //; // VIEWS; //; // The timeline and function view are always shown. These allow selecting basic; // blocks, statements within them, and processing iterations (BBs are visited; // multiple times when e.g. loops are involved).; // These are written directly into the HTML body.; //; // There are also listings of particular basic blocks, and dumps of the state; // at particular analysis points (i.e. BB2 iteration 3 statement 2).; // These are only shown when the relevant BB/analysis point is *selected*.; //; // DATA AND TEMPLATES; //; // The HTML proper is mostly static.; // The analysis data is in a JSON object HTMLLoggerData which is embedded as; // a <script> in the <head>.; // This gets rendered into DOM by a simple template processor which substitutes; // the data into <template> tags embedded in the HTML. (see inflate() in JS).; //; // SELECTION; //; // This is the only real interactive mechanism.; //; // At any given time, there are several named selections, e.g.:; // bb: B2 (basic block 0 is selected); // elt: B2.4 (statement 4 is selected); // iter: B2:1 (iteration 1 of the basic block is selected); // hover: B3 (hovering over basic block 3); //; // The selection is updated by mouse events: hover by moving the mouse and; // others by clicking. Elements that are click targets generally have attributes; // (id or data-foo) that define what they should select.; // See watchSelection() in JS for the exact logic.; //; // When the ""bb"" selection is set to ""B2"":; // - sections <section data-selection=""bb""> get shown; // - templates under such sections get re-rendered; // - elements with class/id ""B2"" get class ""bb-select""; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/FlowSensitive/HTMLLogger.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/FlowSensitive/HTMLLogger.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/FlowSensitive/HTMLLogger.cpp:7,Integrability,message,messages,7,// The messages logged in the current context but not yet written.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/FlowSensitive/HTMLLogger.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/FlowSensitive/HTMLLogger.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/FlowSensitive/HTMLLogger.cpp:16,Testability,log,logged,16,// The messages logged in the current context but not yet written.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/FlowSensitive/HTMLLogger.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/FlowSensitive/HTMLLogger.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/FlowSensitive/HTMLLogger.cpp:128,Usability,simpl,simple,128,// Construct one TokenInfo per character in a flat array.; // This is inefficient (chars in a token all have the same info) but simple.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/FlowSensitive/HTMLLogger.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/FlowSensitive/HTMLLogger.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/FlowSensitive/HTMLLogger.js:3,Usability,Clear,Clear,3,// Clear previously rendered template contents.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/FlowSensitive/HTMLLogger.js,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/FlowSensitive/HTMLLogger.js
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/FlowSensitive/HTMLLogger.js:661,Usability,clear,cleared,661,"// Handle a mouse event on a region containing selectable items.; // This might end up changing the hover state or the selection state.; //; // targetSelector describes what target HTML element is selectable.; // targetToID specifies how to determine the selection from it:; // hover: a function from target to the class name to highlight; // bb: a function from target to the basic-block name to select (BB4); // elt: a function from target to the CFG element name to select (BB4.5); // iter: a function from target to the BB iteration to select (BB4:2); // If an entry is missing, the selection is unmodified.; // If an entry is null, the selection is always cleared.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/FlowSensitive/HTMLLogger.js,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/FlowSensitive/HTMLLogger.js
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/FlowSensitive/HTMLLogger.js:124,Safety,avoid,avoid,124,"// Turns a class name into a CSS selector matching it, with some wrinkles:; // - we treat id=""foo"" just like class=""foo"" to avoid repetition in the HTML; // - cls can be an array of strings, we match them all",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/FlowSensitive/HTMLLogger.js,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/FlowSensitive/HTMLLogger.js
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/FlowSensitive/Logger.cpp:8,Testability,Log,Logger,8,"//===-- Logger.cpp --------------------------------------------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/FlowSensitive/Logger.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/FlowSensitive/Logger.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/FlowSensitive/SimplifyConstraints.cpp:8,Usability,Simpl,SimplifyConstraints,8,"//===-- SimplifyConstraints.cpp ---------------------------------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/FlowSensitive/SimplifyConstraints.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/FlowSensitive/SimplifyConstraints.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/FlowSensitive/Transfer.cpp:461,Deployability,update,update,461,"//===-- Transfer.cpp --------------------------------------------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file defines transfer functions that evaluate program statements and; // update an environment accordingly.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/FlowSensitive/Transfer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/FlowSensitive/Transfer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/FlowSensitive/Transfer.cpp:54,Deployability,update,updates,54,"// Unpacks the value (if any) associated with `E` and updates `E` to the new; // value, if any unpacking occured. Also, does the lvalue-to-rvalue conversion,; // by skipping past the reference.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/FlowSensitive/Transfer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/FlowSensitive/Transfer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/FlowSensitive/Transfer.cpp:200,Modifiability,variab,variables,200,"// Some `DeclRefExpr`s aren't glvalues, so we can't associate them with a; // `StorageLocation`, and there's also no sensible `Value` that we can; // assign to them. Examples:; // - Non-static member variables; // - Non static member functions; // Note: Member operators are an exception to this, but apparently only; // if the `DeclRefExpr` is used within the callee of a; // `CXXOperatorCallExpr`. In other cases, for example when applying the; // address-of operator, the `DeclRefExpr` is a prvalue.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/FlowSensitive/Transfer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/FlowSensitive/Transfer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/FlowSensitive/Transfer.cpp:83,Safety,safe,safe,83,// Group decls are converted into single decls in the CFG so the cast below; // is safe.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/FlowSensitive/Transfer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/FlowSensitive/Transfer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/FlowSensitive/Transfer.cpp:26,Modifiability,variab,variable,26,"// If this is the holding variable for a `BindingDecl`, we may already; // have a storage location set up -- so check. (See also explanation below; // where we process the `BindingDecl`.)",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/FlowSensitive/Transfer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/FlowSensitive/Transfer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/FlowSensitive/Transfer.cpp:45,Deployability,update,update,45,"// FIXME: If integer modeling is added, then update this code to create; // the boolean based on the integer model.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/FlowSensitive/Transfer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/FlowSensitive/Transfer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/FlowSensitive/Transfer.cpp:226,Deployability,update,update,226,"// FIXME: This cast creates a new integral value from the; // subexpression. But, because we don't model integers, we don't; // distinguish between this new value and the underlying one. If integer; // modeling is added, then update this code to create a fresh location and; // value.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/FlowSensitive/Transfer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/FlowSensitive/Transfer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/FlowSensitive/Transfer.cpp:14,Testability,test,tests,14,"// FIXME: Add tests that excercise CK_UncheckedDerivedToBase,; // CK_ConstructorConversion, and CK_UserDefinedConversion.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/FlowSensitive/Transfer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/FlowSensitive/Transfer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/FlowSensitive/Transfer.cpp:367,Testability,log,logical,367,"// FIXME: Revisit this once flow conditions are added to the framework. For; // `a = b ? c : d` we can add `b => a == c && !b => a == d` to the flow; // condition.; // When we do this, we will need to retrieve the values of the operands from; // the environments for the basic blocks they are computed in, in a similar; // way to how this is done for short-circuited logical operators in; // `getLogicOperatorSubExprValue()`.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/FlowSensitive/Transfer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/FlowSensitive/Transfer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/FlowSensitive/Transfer.cpp:60,Testability,log,logic,60,/// Returns the value for the sub-expression `SubExpr` of a logic operator.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/FlowSensitive/Transfer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/FlowSensitive/Transfer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/FlowSensitive/Transfer.cpp:98,Security,access,access,98,// `SubExpr` and its parent logic operator might be part of different basic; // blocks. We try to access the value that is assigned to `SubExpr` in the; // corresponding environment.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/FlowSensitive/Transfer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/FlowSensitive/Transfer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/FlowSensitive/Transfer.cpp:28,Testability,log,logic,28,// `SubExpr` and its parent logic operator might be part of different basic; // blocks. We try to access the value that is assigned to `SubExpr` in the; // corresponding environment.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/FlowSensitive/Transfer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/FlowSensitive/Transfer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/FlowSensitive/TypeErasedDataflowAnalysis.cpp:4,Modifiability,Extend,Extends,4,/// Extends the flow condition of an environment based on a terminator; /// statement.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/FlowSensitive/TypeErasedDataflowAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/FlowSensitive/TypeErasedDataflowAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/FlowSensitive/TypeErasedDataflowAnalysis.cpp:103,Testability,assert,assert,103,"// In transferCFGBlock(), we ensure that we always have a `Value` for the; // terminator condition, so assert this.; // We consciously assert ourselves instead of asserting via `cast()` so; // that we get a more meaningful line number if the assertion fails.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/FlowSensitive/TypeErasedDataflowAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/FlowSensitive/TypeErasedDataflowAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/FlowSensitive/TypeErasedDataflowAnalysis.cpp:135,Testability,assert,assert,135,"// In transferCFGBlock(), we ensure that we always have a `Value` for the; // terminator condition, so assert this.; // We consciously assert ourselves instead of asserting via `cast()` so; // that we get a more meaningful line number if the assertion fails.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/FlowSensitive/TypeErasedDataflowAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/FlowSensitive/TypeErasedDataflowAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/FlowSensitive/TypeErasedDataflowAnalysis.cpp:163,Testability,assert,asserting,163,"// In transferCFGBlock(), we ensure that we always have a `Value` for the; // terminator condition, so assert this.; // We consciously assert ourselves instead of asserting via `cast()` so; // that we get a more meaningful line number if the assertion fails.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/FlowSensitive/TypeErasedDataflowAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/FlowSensitive/TypeErasedDataflowAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/FlowSensitive/TypeErasedDataflowAnalysis.cpp:242,Testability,assert,assertion,242,"// In transferCFGBlock(), we ensure that we always have a `Value` for the; // terminator condition, so assert this.; // We consciously assert ourselves instead of asserting via `cast()` so; // that we get a more meaningful line number if the assertion fails.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/FlowSensitive/TypeErasedDataflowAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/FlowSensitive/TypeErasedDataflowAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/FlowSensitive/TypeErasedDataflowAnalysis.cpp:217,Safety,Avoid,Avoids,217,"// Builds a joined TypeErasedDataflowAnalysisState from 0 or more sources,; // each of which may be owned (built as part of the join) or external (a; // reference to an Environment that will outlive the builder).; // Avoids unneccesary copies of the environment.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/FlowSensitive/TypeErasedDataflowAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/FlowSensitive/TypeErasedDataflowAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/FlowSensitive/TypeErasedDataflowAnalysis.cpp:217,Usability,clear,clear,217,"// Join the environment with itself so that we discard the entries from; // `ExprToLoc` and `ExprToVal`.; // FIXME: We could consider writing special-case code for this that only; // does the discarding, but it's not clear if this is worth it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/FlowSensitive/TypeErasedDataflowAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/FlowSensitive/TypeErasedDataflowAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/FlowSensitive/TypeErasedDataflowAnalysis.cpp:86,Usability,simpl,simply,86,"// FIXME: Instead of these case distinctions, we would ideally want to be able; // to simply use `Environment::createObject()` here, the same way that we do; // this in `TransferVisitor::VisitInitListExpr()`. However, this would require; // us to be able to build a list of fields that we then use to initialize an; // `RecordStorageLocation` -- and the problem is that, when we get here,; // the `RecordStorageLocation` already exists. We should explore if there's; // anything that we can do to change this.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/FlowSensitive/TypeErasedDataflowAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/FlowSensitive/TypeErasedDataflowAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/FlowSensitive/TypeErasedDataflowAnalysis.cpp:22,Performance,perform,performing,22,"// FIXME: Rather than performing a copy here, we should really be; // initializing the field in place. This would require us to propagate the; // storage location of the field to the AST node that creates the; // `RecordValue`.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/FlowSensitive/TypeErasedDataflowAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/FlowSensitive/TypeErasedDataflowAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/FlowSensitive/TypeErasedDataflowAnalysis.cpp:155,Testability,assert,assert,155,"// Removing declarations when their lifetime ends serves two purposes:; // - Eliminate unnecessary clutter from `Environment::DeclToLoc`; // - Allow us to assert that, when joining two `Environment`s, the two; // `DeclToLoc` maps never contain entries that map the same declaration to; // different storage locations.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/FlowSensitive/TypeErasedDataflowAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/FlowSensitive/TypeErasedDataflowAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/FlowSensitive/TypeErasedDataflowAnalysis.cpp:160,Modifiability,extend,extend,160,"// If the transfer function didn't produce a value, create an atom so that; // we have *some* value for the condition expression. This ensures that; // when we extend the flow condition, it actually changes.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/FlowSensitive/TypeErasedDataflowAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/FlowSensitive/TypeErasedDataflowAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/FlowSensitive/TypeErasedDataflowAnalysis.cpp:116,Usability,clear,clear,116,"// FIXME: remove relative cap. There isn't really any good setting for; // `MaxAverageVisitsPerBlock`, so it has no clear value over using; // `MaxBlockVisits` directly.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/FlowSensitive/TypeErasedDataflowAnalysis.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/FlowSensitive/TypeErasedDataflowAnalysis.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/FlowSensitive/WatchedLiteralsSolver.cpp:296,Modifiability,variab,variables,296,"// `WatchedLiteralsSolver` is an implementation of Algorithm D from Knuth's; // The Art of Computer Programming Volume 4: Satisfiability, Fascicle 6. It is; // based on the backtracking DPLL algorithm [1], keeps references to a single; // ""watched"" literal per clause, and uses a set of ""active"" variables to perform; // unit propagation.; //; // The solver expects that its input is a boolean formula in conjunctive normal; // form that consists of clauses of at least one literal. A literal is either a; // boolean variable or its negation. Below we define types, data structures, and; // utilities that are used to represent boolean formulas in conjunctive normal; // form.; //; // [1] https://en.wikipedia.org/wiki/DPLL_algorithm; /// Boolean variables are represented as positive integers.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/FlowSensitive/WatchedLiteralsSolver.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/FlowSensitive/WatchedLiteralsSolver.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/FlowSensitive/WatchedLiteralsSolver.cpp:517,Modifiability,variab,variable,517,"// `WatchedLiteralsSolver` is an implementation of Algorithm D from Knuth's; // The Art of Computer Programming Volume 4: Satisfiability, Fascicle 6. It is; // based on the backtracking DPLL algorithm [1], keeps references to a single; // ""watched"" literal per clause, and uses a set of ""active"" variables to perform; // unit propagation.; //; // The solver expects that its input is a boolean formula in conjunctive normal; // form that consists of clauses of at least one literal. A literal is either a; // boolean variable or its negation. Below we define types, data structures, and; // utilities that are used to represent boolean formulas in conjunctive normal; // form.; //; // [1] https://en.wikipedia.org/wiki/DPLL_algorithm; /// Boolean variables are represented as positive integers.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/FlowSensitive/WatchedLiteralsSolver.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/FlowSensitive/WatchedLiteralsSolver.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/FlowSensitive/WatchedLiteralsSolver.cpp:747,Modifiability,variab,variables,747,"// `WatchedLiteralsSolver` is an implementation of Algorithm D from Knuth's; // The Art of Computer Programming Volume 4: Satisfiability, Fascicle 6. It is; // based on the backtracking DPLL algorithm [1], keeps references to a single; // ""watched"" literal per clause, and uses a set of ""active"" variables to perform; // unit propagation.; //; // The solver expects that its input is a boolean formula in conjunctive normal; // form that consists of clauses of at least one literal. A literal is either a; // boolean variable or its negation. Below we define types, data structures, and; // utilities that are used to represent boolean formulas in conjunctive normal; // form.; //; // [1] https://en.wikipedia.org/wiki/DPLL_algorithm; /// Boolean variables are represented as positive integers.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/FlowSensitive/WatchedLiteralsSolver.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/FlowSensitive/WatchedLiteralsSolver.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/FlowSensitive/WatchedLiteralsSolver.cpp:309,Performance,perform,perform,309,"// `WatchedLiteralsSolver` is an implementation of Algorithm D from Knuth's; // The Art of Computer Programming Volume 4: Satisfiability, Fascicle 6. It is; // based on the backtracking DPLL algorithm [1], keeps references to a single; // ""watched"" literal per clause, and uses a set of ""active"" variables to perform; // unit propagation.; //; // The solver expects that its input is a boolean formula in conjunctive normal; // form that consists of clauses of at least one literal. A literal is either a; // boolean variable or its negation. Below we define types, data structures, and; // utilities that are used to represent boolean formulas in conjunctive normal; // form.; //; // [1] https://en.wikipedia.org/wiki/DPLL_algorithm; /// Boolean variables are represented as positive integers.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/FlowSensitive/WatchedLiteralsSolver.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/FlowSensitive/WatchedLiteralsSolver.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/FlowSensitive/WatchedLiteralsSolver.cpp:19,Modifiability,variab,variable,19,/// A null boolean variable is used as a placeholder in various data structures; /// and algorithms.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/FlowSensitive/WatchedLiteralsSolver.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/FlowSensitive/WatchedLiteralsSolver.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/FlowSensitive/WatchedLiteralsSolver.cpp:84,Modifiability,variab,variable,84,"/// Literals are represented as positive integers. Specifically, for a boolean; /// variable `V` that is represented as the positive integer `I`, the positive; /// literal `V` is represented as the integer `2*I` and the negative literal; /// `!V` is represented as the integer `2*I+1`.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/FlowSensitive/WatchedLiteralsSolver.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/FlowSensitive/WatchedLiteralsSolver.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/FlowSensitive/WatchedLiteralsSolver.cpp:16,Modifiability,variab,variable,16,/// Returns the variable of `L`.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/FlowSensitive/WatchedLiteralsSolver.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/FlowSensitive/WatchedLiteralsSolver.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/FlowSensitive/WatchedLiteralsSolver.cpp:81,Modifiability,variab,variable,81,/// `LargestVar` is equal to the largest positive integer that represents a; /// variable in the formula.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/FlowSensitive/WatchedLiteralsSolver.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/FlowSensitive/WatchedLiteralsSolver.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/FlowSensitive/WatchedLiteralsSolver.cpp:511,Integrability,depend,depends,511,"/// Start indices of clauses of the formula in `Clauses`.; ///; /// The element at index 0 stands for the start index of the null clause. It; /// is set to 0 and isn't used. Start indices of clauses in the formula start; /// from the element at index 1.; ///; /// For example, for the formula `(L1 v L2) ^ (L2 v L3 v L4)` the elements of; /// `ClauseStarts` will be `[0, 1, 3]`. Note that the literals of the first; /// clause always start at index 1. The start index for the literals of the; /// second clause depends on the size of the first clause and so on.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/FlowSensitive/WatchedLiteralsSolver.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/FlowSensitive/WatchedLiteralsSolver.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/FlowSensitive/WatchedLiteralsSolver.cpp:15,Modifiability,variab,variable,15,/// Stores the variable identifier and Atom for atomic booleans in the; /// formula.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/FlowSensitive/WatchedLiteralsSolver.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/FlowSensitive/WatchedLiteralsSolver.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/FlowSensitive/WatchedLiteralsSolver.cpp:100,Usability,simpl,simple,100,"/// Indicates that we already know the formula is unsatisfiable.; /// During construction, we catch simple cases of conflicting unit-clauses.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/FlowSensitive/WatchedLiteralsSolver.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/FlowSensitive/WatchedLiteralsSolver.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/FlowSensitive/WatchedLiteralsSolver.cpp:114,Modifiability,variab,variables,114,"/// Applies simplifications while building up a BooleanFormula.; /// We keep track of unit clauses, which tell us variables that must be; /// true/false in any model that satisfies the overall formula.; /// Such variables can be dropped from subsequently-added clauses, which; /// may in turn yield more unit clauses or even a contradiction.; /// The total added complexity of this preprocessing is O(N) where we; /// for every clause, we do a lookup for each unit clauses.; /// The lookup is O(1) on average. This method won't catch all; /// contradictory formulas, more passes can in principle catch; /// more cases but we leave all these and the general case to the; /// proper SAT solver.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/FlowSensitive/WatchedLiteralsSolver.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/FlowSensitive/WatchedLiteralsSolver.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/FlowSensitive/WatchedLiteralsSolver.cpp:212,Modifiability,variab,variables,212,"/// Applies simplifications while building up a BooleanFormula.; /// We keep track of unit clauses, which tell us variables that must be; /// true/false in any model that satisfies the overall formula.; /// Such variables can be dropped from subsequently-added clauses, which; /// may in turn yield more unit clauses or even a contradiction.; /// The total added complexity of this preprocessing is O(N) where we; /// for every clause, we do a lookup for each unit clauses.; /// The lookup is O(1) on average. This method won't catch all; /// contradictory formulas, more passes can in principle catch; /// more cases but we leave all these and the general case to the; /// proper SAT solver.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/FlowSensitive/WatchedLiteralsSolver.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/FlowSensitive/WatchedLiteralsSolver.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/FlowSensitive/WatchedLiteralsSolver.cpp:12,Usability,simpl,simplifications,12,"/// Applies simplifications while building up a BooleanFormula.; /// We keep track of unit clauses, which tell us variables that must be; /// true/false in any model that satisfies the overall formula.; /// Such variables can be dropped from subsequently-added clauses, which; /// may in turn yield more unit clauses or even a contradiction.; /// The total added complexity of this preprocessing is O(N) where we; /// for every clause, we do a lookup for each unit clauses.; /// The lookup is O(1) on average. This method won't catch all; /// contradictory formulas, more passes can in principle catch; /// more cases but we leave all these and the general case to the; /// proper SAT solver.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/FlowSensitive/WatchedLiteralsSolver.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/FlowSensitive/WatchedLiteralsSolver.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/FlowSensitive/WatchedLiteralsSolver.cpp:65,Usability,simpl,simplifications,65,"/// Adds the `L1 v ... v Ln` clause to the formula. Applies; /// simplifications, based on single-literal clauses.; ///; /// Requirements:; ///; /// `Li` must not be `NullLit`.; ///; /// All literals must be distinct.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/FlowSensitive/WatchedLiteralsSolver.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/FlowSensitive/WatchedLiteralsSolver.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/FlowSensitive/WatchedLiteralsSolver.cpp:28,Usability,simpl,simplified,28,// Contains literals of the simplified clause.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/FlowSensitive/WatchedLiteralsSolver.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/FlowSensitive/WatchedLiteralsSolver.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/FlowSensitive/WatchedLiteralsSolver.cpp:3,Usability,Simpl,Simplification,3,"// Simplification made the clause empty, which is equivalent to `false`.; // We already know that this formula is unsatisfiable.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/FlowSensitive/WatchedLiteralsSolver.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/FlowSensitive/WatchedLiteralsSolver.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/FlowSensitive/WatchedLiteralsSolver.cpp:118,Modifiability,variab,variable,118,// The general strategy of the algorithm implemented below is to map each; // of the sub-values in `Vals` to a unique variable and use these variables in; // the resulting CNF expression to avoid exponential blow up. The number of; // literals in the resulting formula is guaranteed to be linear in the number; // of sub-formulas in `Vals`.; // Map each sub-formula in `Vals` to a unique variable.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/FlowSensitive/WatchedLiteralsSolver.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/FlowSensitive/WatchedLiteralsSolver.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/FlowSensitive/WatchedLiteralsSolver.cpp:141,Modifiability,variab,variables,141,// The general strategy of the algorithm implemented below is to map each; // of the sub-values in `Vals` to a unique variable and use these variables in; // the resulting CNF expression to avoid exponential blow up. The number of; // literals in the resulting formula is guaranteed to be linear in the number; // of sub-formulas in `Vals`.; // Map each sub-formula in `Vals` to a unique variable.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/FlowSensitive/WatchedLiteralsSolver.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/FlowSensitive/WatchedLiteralsSolver.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/FlowSensitive/WatchedLiteralsSolver.cpp:388,Modifiability,variab,variable,388,// The general strategy of the algorithm implemented below is to map each; // of the sub-values in `Vals` to a unique variable and use these variables in; // the resulting CNF expression to avoid exponential blow up. The number of; // literals in the resulting formula is guaranteed to be linear in the number; // of sub-formulas in `Vals`.; // Map each sub-formula in `Vals` to a unique variable.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/FlowSensitive/WatchedLiteralsSolver.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/FlowSensitive/WatchedLiteralsSolver.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/FlowSensitive/WatchedLiteralsSolver.cpp:190,Safety,avoid,avoid,190,// The general strategy of the algorithm implemented below is to map each; // of the sub-values in `Vals` to a unique variable and use these variables in; // the resulting CNF expression to avoid exponential blow up. The number of; // literals in the resulting formula is guaranteed to be linear in the number; // of sub-formulas in `Vals`.; // Map each sub-formula in `Vals` to a unique variable.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/FlowSensitive/WatchedLiteralsSolver.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/FlowSensitive/WatchedLiteralsSolver.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/FlowSensitive/WatchedLiteralsSolver.cpp:9,Modifiability,variab,variable,9,// Store variable identifiers and Atom of atomic booleans.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/FlowSensitive/WatchedLiteralsSolver.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/FlowSensitive/WatchedLiteralsSolver.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/FlowSensitive/WatchedLiteralsSolver.cpp:27,Modifiability,variab,variable,27,// Add a conjunct for each variable that represents a top-level conjunction; // value in `Vals`.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/FlowSensitive/WatchedLiteralsSolver.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/FlowSensitive/WatchedLiteralsSolver.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/FlowSensitive/WatchedLiteralsSolver.cpp:66,Modifiability,variab,variables,66,// Add conjuncts that represent the mapping between newly-created variables; // and their corresponding sub-formulas.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/FlowSensitive/WatchedLiteralsSolver.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/FlowSensitive/WatchedLiteralsSolver.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/FlowSensitive/WatchedLiteralsSolver.cpp:70,Usability,simpl,simplification,70,// Unit clauses that were added later were not; // considered for the simplification of earlier clauses. Do a final; // pass to find more opportunities for simplification.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/FlowSensitive/WatchedLiteralsSolver.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/FlowSensitive/WatchedLiteralsSolver.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/FlowSensitive/WatchedLiteralsSolver.cpp:156,Usability,simpl,simplification,156,// Unit clauses that were added later were not; // considered for the simplification of earlier clauses. Do a final; // pass to find more opportunities for simplification.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/FlowSensitive/WatchedLiteralsSolver.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/FlowSensitive/WatchedLiteralsSolver.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/FlowSensitive/WatchedLiteralsSolver.cpp:50,Modifiability,variab,variables,50,"/// The search for a satisfying assignment of the variables in `Formula` will; /// proceed in levels, starting from 1 and going up to `Formula.LargestVar`; /// (inclusive). The current level is stored in `Level`. At each level the; /// solver will assign a value to an unassigned variable. If this leads to a; /// consistent partial assignment, `Level` will be incremented. Otherwise, if; /// it results in a conflict, the solver will backtrack by decrementing; /// `Level` until it reaches the most recent level where a decision was made.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/FlowSensitive/WatchedLiteralsSolver.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/FlowSensitive/WatchedLiteralsSolver.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/FlowSensitive/WatchedLiteralsSolver.cpp:280,Modifiability,variab,variable,280,"/// The search for a satisfying assignment of the variables in `Formula` will; /// proceed in levels, starting from 1 and going up to `Formula.LargestVar`; /// (inclusive). The current level is stored in `Level`. At each level the; /// solver will assign a value to an unassigned variable. If this leads to a; /// consistent partial assignment, `Level` will be incremented. Otherwise, if; /// it results in a conflict, the solver will backtrack by decrementing; /// `Level` until it reaches the most recent level where a decision was made.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/FlowSensitive/WatchedLiteralsSolver.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/FlowSensitive/WatchedLiteralsSolver.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/FlowSensitive/WatchedLiteralsSolver.cpp:43,Modifiability,variab,variables,43,/// Maps levels (indices of the vector) to variables (elements of the vector); /// that are assigned values at the respective levels.; ///; /// The element at index 0 isn't used. Variables start from the element at; /// index 1.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/FlowSensitive/WatchedLiteralsSolver.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/FlowSensitive/WatchedLiteralsSolver.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/FlowSensitive/WatchedLiteralsSolver.cpp:179,Modifiability,Variab,Variables,179,/// Maps levels (indices of the vector) to variables (elements of the vector); /// that are assigned values at the respective levels.; ///; /// The element at index 0 isn't used. Variables start from the element at; /// index 1.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/FlowSensitive/WatchedLiteralsSolver.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/FlowSensitive/WatchedLiteralsSolver.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/FlowSensitive/WatchedLiteralsSolver.cpp:9,Modifiability,variab,variables,9,/// Maps variables (indices of the vector) to their assignments (elements of; /// the vector).; ///; /// The element at index 0 isn't used. Variable assignments start from the; /// element at index 1.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/FlowSensitive/WatchedLiteralsSolver.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/FlowSensitive/WatchedLiteralsSolver.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/FlowSensitive/WatchedLiteralsSolver.cpp:140,Modifiability,Variab,Variable,140,/// Maps variables (indices of the vector) to their assignments (elements of; /// the vector).; ///; /// The element at index 0 isn't used. Variable assignments start from the; /// element at index 1.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/FlowSensitive/WatchedLiteralsSolver.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/FlowSensitive/WatchedLiteralsSolver.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/FlowSensitive/WatchedLiteralsSolver.cpp:24,Modifiability,variab,variables,24,/// A set of unassigned variables that appear in watched literals in; /// `Formula`. The vector is guaranteed to contain unique elements.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/FlowSensitive/WatchedLiteralsSolver.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/FlowSensitive/WatchedLiteralsSolver.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/FlowSensitive/WatchedLiteralsSolver.cpp:18,Modifiability,variab,variables,18,// Initialize all variables as unassigned.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/FlowSensitive/WatchedLiteralsSolver.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/FlowSensitive/WatchedLiteralsSolver.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/FlowSensitive/WatchedLiteralsSolver.cpp:25,Modifiability,variab,variables,25,// Initialize the active variables.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/FlowSensitive/WatchedLiteralsSolver.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/FlowSensitive/WatchedLiteralsSolver.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/FlowSensitive/WatchedLiteralsSolver.cpp:64,Modifiability,variab,variables,64,// Assert that the following invariants hold:; // 1. All active variables are unassigned.; // 2. All active variables form watched literals.; // 3. Unassigned variables that form watched literals are active.; // FIXME: Consider replacing these with test cases that fail if the any; // of the invariants is broken. That might not be easy due to the; // transformations performed by `buildCNF`.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/FlowSensitive/WatchedLiteralsSolver.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/FlowSensitive/WatchedLiteralsSolver.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/FlowSensitive/WatchedLiteralsSolver.cpp:108,Modifiability,variab,variables,108,// Assert that the following invariants hold:; // 1. All active variables are unassigned.; // 2. All active variables form watched literals.; // 3. Unassigned variables that form watched literals are active.; // FIXME: Consider replacing these with test cases that fail if the any; // of the invariants is broken. That might not be easy due to the; // transformations performed by `buildCNF`.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/FlowSensitive/WatchedLiteralsSolver.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/FlowSensitive/WatchedLiteralsSolver.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/FlowSensitive/WatchedLiteralsSolver.cpp:159,Modifiability,variab,variables,159,// Assert that the following invariants hold:; // 1. All active variables are unassigned.; // 2. All active variables form watched literals.; // 3. Unassigned variables that form watched literals are active.; // FIXME: Consider replacing these with test cases that fail if the any; // of the invariants is broken. That might not be easy due to the; // transformations performed by `buildCNF`.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/FlowSensitive/WatchedLiteralsSolver.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/FlowSensitive/WatchedLiteralsSolver.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/FlowSensitive/WatchedLiteralsSolver.cpp:368,Performance,perform,performed,368,// Assert that the following invariants hold:; // 1. All active variables are unassigned.; // 2. All active variables form watched literals.; // 3. Unassigned variables that form watched literals are active.; // FIXME: Consider replacing these with test cases that fail if the any; // of the invariants is broken. That might not be easy due to the; // transformations performed by `buildCNF`.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/FlowSensitive/WatchedLiteralsSolver.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/FlowSensitive/WatchedLiteralsSolver.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/FlowSensitive/WatchedLiteralsSolver.cpp:3,Testability,Assert,Assert,3,// Assert that the following invariants hold:; // 1. All active variables are unassigned.; // 2. All active variables form watched literals.; // 3. Unassigned variables that form watched literals are active.; // FIXME: Consider replacing these with test cases that fail if the any; // of the invariants is broken. That might not be easy due to the; // transformations performed by `buildCNF`.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/FlowSensitive/WatchedLiteralsSolver.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/FlowSensitive/WatchedLiteralsSolver.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/FlowSensitive/WatchedLiteralsSolver.cpp:249,Testability,test,test,249,// Assert that the following invariants hold:; // 1. All active variables are unassigned.; // 2. All active variables form watched literals.; // 3. Unassigned variables that form watched literals are active.; // FIXME: Consider replacing these with test cases that fail if the any; // of the invariants is broken. That might not be easy due to the; // transformations performed by `buildCNF`.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/FlowSensitive/WatchedLiteralsSolver.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/FlowSensitive/WatchedLiteralsSolver.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/FlowSensitive/WatchedLiteralsSolver.cpp:49,Modifiability,variab,variable,49,// Look for unit clauses that contain the active variable.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/FlowSensitive/WatchedLiteralsSolver.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/FlowSensitive/WatchedLiteralsSolver.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/FlowSensitive/WatchedLiteralsSolver.cpp:55,Modifiability,variab,variable,55,// We found a unit clause! The value of its unassigned variable is; // forced.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/FlowSensitive/WatchedLiteralsSolver.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/FlowSensitive/WatchedLiteralsSolver.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/FlowSensitive/WatchedLiteralsSolver.cpp:14,Modifiability,variab,variable,14,// Remove the variable that was just assigned from the set of active; // variables.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/FlowSensitive/WatchedLiteralsSolver.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/FlowSensitive/WatchedLiteralsSolver.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/FlowSensitive/WatchedLiteralsSolver.cpp:73,Modifiability,variab,variables,73,// Remove the variable that was just assigned from the set of active; // variables.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/FlowSensitive/WatchedLiteralsSolver.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/FlowSensitive/WatchedLiteralsSolver.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/FlowSensitive/WatchedLiteralsSolver.cpp:85,Energy Efficiency,efficient,efficient,85,// Replace the variable that was just assigned with the last active; // variable for efficient removal.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/FlowSensitive/WatchedLiteralsSolver.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/FlowSensitive/WatchedLiteralsSolver.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/FlowSensitive/WatchedLiteralsSolver.cpp:15,Modifiability,variab,variable,15,// Replace the variable that was just assigned with the last active; // variable for efficient removal.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/FlowSensitive/WatchedLiteralsSolver.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/FlowSensitive/WatchedLiteralsSolver.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/FlowSensitive/WatchedLiteralsSolver.cpp:72,Modifiability,variab,variable,72,// Replace the variable that was just assigned with the last active; // variable for efficient removal.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/FlowSensitive/WatchedLiteralsSolver.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/FlowSensitive/WatchedLiteralsSolver.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/FlowSensitive/WatchedLiteralsSolver.cpp:28,Modifiability,variab,variable,28,// This was the last active variable. Repeat the process from the; // beginning.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/FlowSensitive/WatchedLiteralsSolver.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/FlowSensitive/WatchedLiteralsSolver.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/FlowSensitive/WatchedLiteralsSolver.cpp:97,Modifiability,variab,variables,97,// There are no remaining unit clauses in the formula! Make a decision; // for one of the active variables at the current level.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/FlowSensitive/WatchedLiteralsSolver.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/FlowSensitive/WatchedLiteralsSolver.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/FlowSensitive/WatchedLiteralsSolver.cpp:14,Modifiability,variab,variable,14,// Remove the variable that was just assigned from the set of active; // variables.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/FlowSensitive/WatchedLiteralsSolver.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/FlowSensitive/WatchedLiteralsSolver.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/FlowSensitive/WatchedLiteralsSolver.cpp:73,Modifiability,variab,variables,73,// Remove the variable that was just assigned from the set of active; // variables.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/FlowSensitive/WatchedLiteralsSolver.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/FlowSensitive/WatchedLiteralsSolver.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/FlowSensitive/WatchedLiteralsSolver.cpp:28,Modifiability,variab,variable,28,// This was the last active variable. Repeat the process from the; // beginning.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/FlowSensitive/WatchedLiteralsSolver.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/FlowSensitive/WatchedLiteralsSolver.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/FlowSensitive/WatchedLiteralsSolver.cpp:5,Modifiability,variab,variable,5,"// A variable may have a definite true/false assignment, or it may be; // unassigned indicating its truth value does not affect the result of; // the formula. Unassigned variables are assigned to true as a default.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/FlowSensitive/WatchedLiteralsSolver.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/FlowSensitive/WatchedLiteralsSolver.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/FlowSensitive/WatchedLiteralsSolver.cpp:170,Modifiability,variab,variables,170,"// A variable may have a definite true/false assignment, or it may be; // unassigned indicating its truth value does not affect the result of; // the formula. Unassigned variables are assigned to true as a default.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/FlowSensitive/WatchedLiteralsSolver.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/FlowSensitive/WatchedLiteralsSolver.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/FlowSensitive/WatchedLiteralsSolver.cpp:108,Modifiability,variab,variable,108,/// Reverses forced moves until the most recent level where a decision was; /// made on the assignment of a variable.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/FlowSensitive/WatchedLiteralsSolver.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/FlowSensitive/WatchedLiteralsSolver.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/FlowSensitive/WatchedLiteralsSolver.cpp:10,Modifiability,variab,variable,10,// If the variable that we pass through is watched then we add it to the; // active variables.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/FlowSensitive/WatchedLiteralsSolver.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/FlowSensitive/WatchedLiteralsSolver.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/FlowSensitive/WatchedLiteralsSolver.cpp:84,Modifiability,variab,variables,84,// If the variable that we pass through is watched then we add it to the; // active variables.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/FlowSensitive/WatchedLiteralsSolver.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/FlowSensitive/WatchedLiteralsSolver.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/FlowSensitive/WatchedLiteralsSolver.cpp:4,Deployability,Update,Updates,4,/// Updates watched literals that are affected by a variable assignment.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/FlowSensitive/WatchedLiteralsSolver.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/FlowSensitive/WatchedLiteralsSolver.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/FlowSensitive/WatchedLiteralsSolver.cpp:52,Modifiability,variab,variable,52,/// Updates watched literals that are affected by a variable assignment.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/FlowSensitive/WatchedLiteralsSolver.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/FlowSensitive/WatchedLiteralsSolver.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/FlowSensitive/WatchedLiteralsSolver.cpp:3,Deployability,Update,Update,3,// Update the watched literals of clauses that currently watch the literal; // that falsifies `Var`.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/FlowSensitive/WatchedLiteralsSolver.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/FlowSensitive/WatchedLiteralsSolver.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/FlowSensitive/WatchedLiteralsSolver.cpp:76,Modifiability,variab,variable,76,// If the new watched literal isn't watched by any other clause and its; // variable isn't assigned we need to add it to the active variables.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/FlowSensitive/WatchedLiteralsSolver.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/FlowSensitive/WatchedLiteralsSolver.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/FlowSensitive/WatchedLiteralsSolver.cpp:132,Modifiability,variab,variables,132,// If the new watched literal isn't watched by any other clause and its; // variable isn't assigned we need to add it to the active variables.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/FlowSensitive/WatchedLiteralsSolver.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/FlowSensitive/WatchedLiteralsSolver.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/FlowSensitive/WatchedLiteralsSolver.cpp:190,Deployability,update,updateWatchedLiterals,190,// Assert the invariant that the watched literal is always the first one; // in the clause.; // FIXME: Consider replacing this with a test case that fails if the; // invariant is broken by `updateWatchedLiterals`. That might not be easy; // due to the transformations performed by `buildCNF`.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/FlowSensitive/WatchedLiteralsSolver.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/FlowSensitive/WatchedLiteralsSolver.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/FlowSensitive/WatchedLiteralsSolver.cpp:268,Performance,perform,performed,268,// Assert the invariant that the watched literal is always the first one; // in the clause.; // FIXME: Consider replacing this with a test case that fails if the; // invariant is broken by `updateWatchedLiterals`. That might not be easy; // due to the transformations performed by `buildCNF`.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/FlowSensitive/WatchedLiteralsSolver.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/FlowSensitive/WatchedLiteralsSolver.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/FlowSensitive/WatchedLiteralsSolver.cpp:3,Testability,Assert,Assert,3,// Assert the invariant that the watched literal is always the first one; // in the clause.; // FIXME: Consider replacing this with a test case that fails if the; // invariant is broken by `updateWatchedLiterals`. That might not be easy; // due to the transformations performed by `buildCNF`.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/FlowSensitive/WatchedLiteralsSolver.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/FlowSensitive/WatchedLiteralsSolver.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/FlowSensitive/WatchedLiteralsSolver.cpp:134,Testability,test,test,134,// Assert the invariant that the watched literal is always the first one; // in the clause.; // FIXME: Consider replacing this with a test case that fails if the; // invariant is broken by `updateWatchedLiterals`. That might not be easy; // due to the transformations performed by `buildCNF`.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/FlowSensitive/WatchedLiteralsSolver.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/FlowSensitive/WatchedLiteralsSolver.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/FlowSensitive/WatchedLiteralsSolver.cpp:44,Modifiability,variab,variable,44,/// Returns an assignment for an unassigned variable.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/FlowSensitive/WatchedLiteralsSolver.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/FlowSensitive/WatchedLiteralsSolver.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/FlowSensitive/WatchedLiteralsSolver.cpp:43,Modifiability,variab,variables,43,/// Returns true if and only if all active variables are unassigned.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/FlowSensitive/WatchedLiteralsSolver.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/FlowSensitive/WatchedLiteralsSolver.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/FlowSensitive/WatchedLiteralsSolver.cpp:43,Modifiability,variab,variables,43,/// Returns true if and only if all active variables form watched literals.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/FlowSensitive/WatchedLiteralsSolver.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/FlowSensitive/WatchedLiteralsSolver.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/FlowSensitive/WatchedLiteralsSolver.cpp:47,Modifiability,variab,variables,47,/// Returns true if and only if all unassigned variables that are forming; /// watched literals are active.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/FlowSensitive/WatchedLiteralsSolver.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/FlowSensitive/WatchedLiteralsSolver.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/FlowSensitive/Models/ChromiumCheckModel.cpp:49,Safety,avoid,avoid,49,"// All of the methods of interest are static, so avoid any lookup for; // non-static methods (the common case).",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/FlowSensitive/Models/ChromiumCheckModel.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/FlowSensitive/Models/ChromiumCheckModel.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/FlowSensitive/Models/ChromiumCheckModel.cpp:31,Testability,log,logging,31,"// Check whether namespace is ""logging"".",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/FlowSensitive/Models/ChromiumCheckModel.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/FlowSensitive/Models/ChromiumCheckModel.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/FlowSensitive/Models/ChromiumCheckModel.cpp:18,Testability,log,logging,18,"// Check whether ""logging"" is a top-level namespace.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/FlowSensitive/Models/ChromiumCheckModel.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/FlowSensitive/Models/ChromiumCheckModel.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/FlowSensitive/Models/UncheckedOptionalAccessModel.cpp:426,Safety,detect,detects,426,"//===-- UncheckedOptionalAccessModel.cpp ------------------------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file defines a dataflow analysis that detects unsafe uses of optional; // values.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/FlowSensitive/Models/UncheckedOptionalAccessModel.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/FlowSensitive/Models/UncheckedOptionalAccessModel.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/FlowSensitive/Models/UncheckedOptionalAccessModel.cpp:434,Safety,unsafe,unsafe,434,"//===-- UncheckedOptionalAccessModel.cpp ------------------------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file defines a dataflow analysis that detects unsafe uses of optional; // values.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/FlowSensitive/Models/UncheckedOptionalAccessModel.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/FlowSensitive/Models/UncheckedOptionalAccessModel.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/FlowSensitive/Models/UncheckedOptionalAccessModel.cpp:35,Integrability,wrap,wrappers,35,"/// Returns the number of optional wrappers in `Type`.; ///; /// For example, if `Type` is `optional<optional<int>>`, the result of this; /// function will be 2.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/FlowSensitive/Models/UncheckedOptionalAccessModel.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/FlowSensitive/Models/UncheckedOptionalAccessModel.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/FlowSensitive/Models/UncheckedOptionalAccessModel.cpp:25,Testability,log,logical,25,/// `ModelPred` builds a logical formula relating the predicate in; /// `ValueOrPredExpr` to the optional's `has_value` property.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/FlowSensitive/Models/UncheckedOptionalAccessModel.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/FlowSensitive/Models/UncheckedOptionalAccessModel.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/FlowSensitive/Models/UncheckedOptionalAccessModel.cpp:138,Usability,learn,learn,138,"// If the result is *not* empty, then we know the; // optional must have been holding a value. If; // `ExprVal` is true, though, we don't learn; // anything definite about `has_value`, so we; // don't add any corresponding implications to; // the flow condition.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/FlowSensitive/Models/UncheckedOptionalAccessModel.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/FlowSensitive/Models/UncheckedOptionalAccessModel.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/FlowSensitive/Models/UncheckedOptionalAccessModel.cpp:353,Energy Efficiency,allocate,allocate,353,"// Both expressions have locations, though they may not have corresponding; // values. In that case, we create a fresh value at this point. Note that if; // two branches both do this, they will not share the value, but it at least; // allows for local reasoning about the value. To avoid the above, we would; // need *lazy* value allocation.; // FIXME: allocate values lazily, instead of just creating a fresh value.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/FlowSensitive/Models/UncheckedOptionalAccessModel.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/FlowSensitive/Models/UncheckedOptionalAccessModel.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/FlowSensitive/Models/UncheckedOptionalAccessModel.cpp:282,Safety,avoid,avoid,282,"// Both expressions have locations, though they may not have corresponding; // values. In that case, we create a fresh value at this point. Note that if; // two branches both do this, they will not share the value, but it at least; // allows for local reasoning about the value. To avoid the above, we would; // need *lazy* value allocation.; // FIXME: allocate values lazily, instead of just creating a fresh value.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/FlowSensitive/Models/UncheckedOptionalAccessModel.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/FlowSensitive/Models/UncheckedOptionalAccessModel.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/FlowSensitive/Models/UncheckedOptionalAccessModel.cpp:733,Modifiability,rewrite,rewrite,733,"// Logically, an optional<T> object is composed of two values - a `has_value`; // bit and a value of type T. Equality of optional objects compares both; // values. Therefore, merely comparing the `has_value` bits isn't sufficient:; // when two optional objects are engaged, the equality of their respective; // values of type T matters. Since we only track the `has_value` bits, we; // can't make any conclusions about equality when we know that two optional; // objects are engaged.; //; // We express this as two facts about the equality:; // a) EqVal => (LHS & RHS) v (!RHS & !LHS); // If they are equal, then either both are set or both are unset.; // b) (!LHS & !RHS) => EqVal; // If neither is set, then they are equal.; // We rewrite b) as !EqVal => (LHS v RHS), for a more compact formula.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/FlowSensitive/Models/UncheckedOptionalAccessModel.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/FlowSensitive/Models/UncheckedOptionalAccessModel.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/FlowSensitive/Models/UncheckedOptionalAccessModel.cpp:3,Testability,Log,Logically,3,"// Logically, an optional<T> object is composed of two values - a `has_value`; // bit and a value of type T. Equality of optional objects compares both; // values. Therefore, merely comparing the `has_value` bits isn't sufficient:; // when two optional objects are engaged, the equality of their respective; // values of type T matters. Since we only track the `has_value` bits, we; // can't make any conclusions about equality when we know that two optional; // objects are engaged.; //; // We express this as two facts about the equality:; // a) EqVal => (LHS & RHS) v (!RHS & !LHS); // If they are equal, then either both are set or both are unset.; // b) (!LHS & !RHS) => EqVal; // If neither is set, then they are equal.; // We rewrite b) as !EqVal => (LHS v RHS), for a more compact formula.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/FlowSensitive/Models/UncheckedOptionalAccessModel.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/FlowSensitive/Models/UncheckedOptionalAccessModel.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/FlowSensitive/Models/UncheckedOptionalAccessModel.cpp:165,Safety,avoid,avoid,165,"// FIXME: Evaluate the efficiency of matchers. If using matchers results in a; // lot of duplicated work (e.g. string comparisons), consider providing APIs; // that avoid it through memoization.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/FlowSensitive/Models/UncheckedOptionalAccessModel.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/FlowSensitive/Models/UncheckedOptionalAccessModel.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/FlowSensitive/Models/UncheckedOptionalAccessModel.cpp:45,Safety,safe,safe,45,// Record that this unwrap is *not* provably safe.; // FIXME: include either the name of the optional (if applicable) or a source; // range of the access for easier interpretation of the result.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/FlowSensitive/Models/UncheckedOptionalAccessModel.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/FlowSensitive/Models/UncheckedOptionalAccessModel.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/FlowSensitive/Models/UncheckedOptionalAccessModel.cpp:147,Security,access,access,147,// Record that this unwrap is *not* provably safe.; // FIXME: include either the name of the optional (if applicable) or a source; // range of the access for easier interpretation of the result.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/FlowSensitive/Models/UncheckedOptionalAccessModel.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/FlowSensitive/Models/UncheckedOptionalAccessModel.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/FlowSensitive/Models/UncheckedOptionalAccessModel.cpp:165,Safety,avoid,avoid,165,"// FIXME: Evaluate the efficiency of matchers. If using matchers results in a; // lot of duplicated work (e.g. string comparisons), consider providing APIs; // that avoid it through memoization.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/FlowSensitive/Models/UncheckedOptionalAccessModel.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/FlowSensitive/Models/UncheckedOptionalAccessModel.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/plugins/CheckerDependencyHandling/CheckerDependencyHandling.cpp:40,Modifiability,plugin,plugin,40,// end anonymous namespace; // Register plugin!,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/plugins/CheckerDependencyHandling/CheckerDependencyHandling.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/plugins/CheckerDependencyHandling/CheckerDependencyHandling.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/plugins/CheckerOptionHandling/CheckerOptionHandling.cpp:40,Modifiability,plugin,plugin,40,// end anonymous namespace; // Register plugin!,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/plugins/CheckerOptionHandling/CheckerOptionHandling.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/plugins/CheckerOptionHandling/CheckerOptionHandling.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/plugins/SampleAnalyzer/MainCallChecker.cpp:27,Usability,simpl,simple,27,"// if no identifier, not a simple C function",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/plugins/SampleAnalyzer/MainCallChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/plugins/SampleAnalyzer/MainCallChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/plugins/SampleAnalyzer/MainCallChecker.cpp:12,Modifiability,plugin,plugin,12,// Register plugin!,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/Analysis/plugins/SampleAnalyzer/MainCallChecker.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/plugins/SampleAnalyzer/MainCallChecker.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/APINotes/APINotesFormat.h:116,Performance,load,loading,116,"/// The control block, which contains all of the information that needs to; /// be validated prior to committing to loading the API notes file.; ///; /// \sa control_block",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/APINotes/APINotesFormat.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/APINotes/APINotesFormat.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/APINotes/APINotesFormat.h:83,Security,validat,validated,83,"/// The control block, which contains all of the information that needs to; /// be validated prior to committing to loading the API notes file.; ///; /// \sa control_block",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/APINotes/APINotesFormat.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/APINotes/APINotesFormat.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/APINotes/APINotesFormat.h:102,Integrability,protocol,protocols,102,"/// The Objective-C context data block, which contains information about; /// Objective-C classes and protocols.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/APINotes/APINotesFormat.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/APINotes/APINotesFormat.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/APINotes/APINotesFormat.h:15,Modifiability,variab,variables,15,"/// The global variables data block, which maps global variable names to; /// information about the global variable.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/APINotes/APINotesFormat.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/APINotes/APINotesFormat.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/APINotes/APINotesFormat.h:55,Modifiability,variab,variable,55,"/// The global variables data block, which maps global variable names to; /// information about the global variable.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/APINotes/APINotesFormat.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/APINotes/APINotesFormat.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/APINotes/APINotesFormat.h:107,Modifiability,variab,variable,107,"/// The global variables data block, which maps global variable names to; /// information about the global variable.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/APINotes/APINotesFormat.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/APINotes/APINotesFormat.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/APINotes/APINotesFormat.h:29,Integrability,protocol,protocol,29,// map from ObjC class names/protocol (as; // IDs) to context IDs,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/APINotes/APINotesFormat.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/APINotes/APINotesFormat.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/APINotes/APINotesFormat.h:27,Modifiability,variab,variable,27,// map from name to global variable information,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/APINotes/APINotesFormat.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/APINotes/APINotesFormat.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/APINotes/APINotesManager.cpp:54,Availability,alive,alive,54,"/// Prints two successive strings, which much be kept alive as long as the; /// PrettyStackTrace entry.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/APINotes/APINotesManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/APINotes/APINotesManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/APINotes/APINotesManager.cpp:166,Availability,avail,availability,166,"// Compile the API notes source into a buffer.; // FIXME: Either propagate OSType through or, better yet, improve the binary; // APINotes format to maintain complete availability information.; // FIXME: We don't even really need to go through the binary format at all;; // we're just going to immediately deserialize it again.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/APINotes/APINotesManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/APINotes/APINotesManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/APINotes/APINotesManager.cpp:3,Performance,Load,Load,3,// Load the binary form we just compiled.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/APINotes/APINotesManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/APINotes/APINotesManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/APINotes/APINotesManager.cpp:10,Security,access,access,10,// Try to access the header directory.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/APINotes/APINotesManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/APINotes/APINotesManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/APINotes/APINotesManager.cpp:10,Performance,load,load,10,// Try to load the API notes.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/APINotes/APINotesManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/APINotes/APINotesManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/APINotes/APINotesManager.cpp:25,Performance,load,loading,25,// Local function to try loading an API notes file in the given directory.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/APINotes/APINotesManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/APINotes/APINotesManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/APINotes/APINotesManager.cpp:38,Performance,load,load,38,"// If we're not allowed to implicitly load API notes files, we're done.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/APINotes/APINotesManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/APINotes/APINotesManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/APINotes/APINotesManager.cpp:46,Performance,load,load,46,"// If there is an API notes file here, try to load it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/APINotes/APINotesManager.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/APINotes/APINotesManager.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/APINotes/APINotesReader.cpp:15,Security,hash,hash,15,/// An on-disk hash table whose data is versioned based on the Swift version.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/APINotes/APINotesReader.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/APINotes/APINotesReader.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/APINotes/APINotesReader.cpp:20,Modifiability,Variab,VariableInfo,20,/// Read serialized VariableInfo.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/APINotes/APINotesReader.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/APINotes/APINotesReader.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/APINotes/APINotesReader.cpp:43,Modifiability,variab,variable,43,/// Used to deserialize the on-disk global variable table.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/APINotes/APINotesReader.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/APINotes/APINotesReader.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/APINotes/APINotesReader.cpp:15,Modifiability,variab,variable,15,/// The global variable table.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/APINotes/APINotesReader.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/APINotes/APINotesReader.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/APINotes/APINotesReader.cpp:24,Availability,error,error,24,// FIXME this drops the error on the floor.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/APINotes/APINotesReader.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/APINotes/APINotesReader.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/APINotes/APINotesReader.cpp:24,Availability,error,error,24,// FIXME this drops the error on the floor.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/APINotes/APINotesReader.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/APINotes/APINotesReader.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/APINotes/APINotesReader.cpp:24,Availability,error,error,24,// FIXME this drops the error on the floor.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/APINotes/APINotesReader.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/APINotes/APINotesReader.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/APINotes/APINotesReader.cpp:24,Availability,error,error,24,// FIXME this drops the error on the floor.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/APINotes/APINotesReader.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/APINotes/APINotesReader.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/APINotes/APINotesReader.cpp:24,Availability,error,error,24,// FIXME this drops the error on the floor.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/APINotes/APINotesReader.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/APINotes/APINotesReader.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/APINotes/APINotesReader.cpp:24,Availability,error,error,24,// FIXME this drops the error on the floor.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/APINotes/APINotesReader.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/APINotes/APINotesReader.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/APINotes/APINotesReader.cpp:24,Availability,error,error,24,// FIXME this drops the error on the floor.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/APINotes/APINotesReader.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/APINotes/APINotesReader.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/APINotes/APINotesReader.cpp:24,Availability,error,error,24,// FIXME this drops the error on the floor.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/APINotes/APINotesReader.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/APINotes/APINotesReader.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/APINotes/APINotesReader.cpp:24,Availability,error,error,24,// FIXME this drops the error on the floor.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/APINotes/APINotesReader.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/APINotes/APINotesReader.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/APINotes/APINotesReader.cpp:24,Availability,error,error,24,// FIXME this drops the error on the floor.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/APINotes/APINotesReader.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/APINotes/APINotesReader.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/APINotes/APINotesReader.cpp:24,Availability,error,error,24,// FIXME this drops the error on the floor.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/APINotes/APINotesReader.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/APINotes/APINotesReader.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/APINotes/APINotesReader.cpp:24,Availability,error,error,24,// FIXME this drops the error on the floor.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/APINotes/APINotesReader.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/APINotes/APINotesReader.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/APINotes/APINotesReader.cpp:24,Availability,error,error,24,// FIXME this drops the error on the floor.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/APINotes/APINotesReader.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/APINotes/APINotesReader.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/APINotes/APINotesReader.cpp:24,Availability,error,error,24,// FIXME this drops the error on the floor.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/APINotes/APINotesReader.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/APINotes/APINotesReader.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/APINotes/APINotesReader.cpp:24,Availability,error,error,24,// FIXME this drops the error on the floor.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/APINotes/APINotesReader.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/APINotes/APINotesReader.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/APINotes/APINotesReader.cpp:24,Availability,error,error,24,// FIXME this drops the error on the floor.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/APINotes/APINotesReader.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/APINotes/APINotesReader.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/APINotes/APINotesReader.cpp:24,Availability,error,error,24,// FIXME this drops the error on the floor.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/APINotes/APINotesReader.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/APINotes/APINotesReader.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/APINotes/APINotesReader.cpp:24,Availability,error,error,24,// FIXME this drops the error on the floor.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/APINotes/APINotesReader.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/APINotes/APINotesReader.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/APINotes/APINotesReader.cpp:24,Availability,error,error,24,// FIXME this drops the error on the floor.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/APINotes/APINotesReader.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/APINotes/APINotesReader.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/APINotes/APINotesReader.cpp:24,Availability,error,error,24,// FIXME this drops the error on the floor.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/APINotes/APINotesReader.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/APINotes/APINotesReader.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/APINotes/APINotesReader.cpp:24,Availability,error,error,24,// FIXME this drops the error on the floor.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/APINotes/APINotesReader.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/APINotes/APINotesReader.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/APINotes/APINotesReader.cpp:24,Availability,error,error,24,// FIXME this drops the error on the floor.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/APINotes/APINotesReader.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/APINotes/APINotesReader.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/APINotes/APINotesReader.cpp:24,Availability,error,error,24,// FIXME this drops the error on the floor.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/APINotes/APINotesReader.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/APINotes/APINotesReader.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/APINotes/APINotesReader.cpp:24,Availability,error,error,24,// FIXME this drops the error on the floor.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/APINotes/APINotesReader.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/APINotes/APINotesReader.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/APINotes/APINotesReader.cpp:24,Availability,error,error,24,// FIXME this drops the error on the floor.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/APINotes/APINotesReader.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/APINotes/APINotesReader.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/APINotes/APINotesReader.cpp:24,Availability,error,error,24,// FIXME this drops the error on the floor.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/APINotes/APINotesReader.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/APINotes/APINotesReader.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/APINotes/APINotesReader.cpp:24,Availability,error,error,24,// FIXME this drops the error on the floor.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/APINotes/APINotesReader.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/APINotes/APINotesReader.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/APINotes/APINotesReader.cpp:22,Modifiability,variab,variable,22,// Already saw global variable table.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/APINotes/APINotesReader.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/APINotes/APINotesReader.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/APINotes/APINotesReader.cpp:24,Availability,error,error,24,// FIXME this drops the error on the floor.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/APINotes/APINotesReader.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/APINotes/APINotesReader.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/APINotes/APINotesReader.cpp:24,Availability,error,error,24,// FIXME this drops the error on the floor.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/APINotes/APINotesReader.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/APINotes/APINotesReader.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/APINotes/APINotesReader.cpp:24,Availability,error,error,24,// FIXME this drops the error on the floor.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/APINotes/APINotesReader.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/APINotes/APINotesReader.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/APINotes/APINotesReader.cpp:24,Availability,error,error,24,// FIXME this drops the error on the floor.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/APINotes/APINotesReader.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/APINotes/APINotesReader.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/APINotes/APINotesReader.cpp:24,Availability,error,error,24,// FIXME this drops the error on the floor.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/APINotes/APINotesReader.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/APINotes/APINotesReader.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/APINotes/APINotesReader.cpp:24,Availability,error,error,24,// FIXME this drops the error on the floor.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/APINotes/APINotesReader.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/APINotes/APINotesReader.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/APINotes/APINotesReader.cpp:24,Availability,error,error,24,// FIXME this drops the error on the floor.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/APINotes/APINotesReader.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/APINotes/APINotesReader.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/APINotes/APINotesReader.cpp:24,Availability,error,error,24,// FIXME this drops the error on the floor.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/APINotes/APINotesReader.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/APINotes/APINotesReader.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/APINotes/APINotesReader.cpp:24,Availability,error,error,24,// FIXME this drops the error on the floor.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/APINotes/APINotesReader.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/APINotes/APINotesReader.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/APINotes/APINotesReader.cpp:24,Availability,error,error,24,// FIXME this drops the error on the floor.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/APINotes/APINotesReader.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/APINotes/APINotesReader.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/APINotes/APINotesReader.cpp:24,Availability,error,error,24,// FIXME this drops the error on the floor.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/APINotes/APINotesReader.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/APINotes/APINotesReader.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/APINotes/APINotesReader.cpp:24,Availability,error,error,24,// FIXME this drops the error on the floor.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/APINotes/APINotesReader.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/APINotes/APINotesReader.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/APINotes/APINotesReader.cpp:24,Availability,error,error,24,// FIXME this drops the error on the floor.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/APINotes/APINotesReader.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/APINotes/APINotesReader.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/APINotes/APINotesReader.cpp:24,Availability,error,error,24,// FIXME this drops the error on the floor.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/APINotes/APINotesReader.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/APINotes/APINotesReader.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/APINotes/APINotesReader.cpp:24,Availability,error,error,24,// FIXME this drops the error on the floor.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/APINotes/APINotesReader.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/APINotes/APINotesReader.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/APINotes/APINotesReader.cpp:24,Availability,error,error,24,// FIXME this drops the error on the floor.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/APINotes/APINotesReader.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/APINotes/APINotesReader.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/APINotes/APINotesReader.cpp:24,Availability,error,error,24,// FIXME this drops the error on the floor.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/APINotes/APINotesReader.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/APINotes/APINotesReader.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/APINotes/APINotesReader.cpp:3,Security,Validat,Validate,3,// Validate signature.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/APINotes/APINotesReader.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/APINotes/APINotesReader.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/APINotes/APINotesReader.cpp:24,Availability,error,error,24,// FIXME this drops the error on the floor.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/APINotes/APINotesReader.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/APINotes/APINotesReader.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/APINotes/APINotesReader.cpp:24,Availability,error,error,24,// FIXME this drops the error on the floor.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/APINotes/APINotesReader.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/APINotes/APINotesReader.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/APINotes/APINotesWriter.cpp:55,Integrability,protocol,protocols,55,"/// Information about contexts (Objective-C classes or protocols or C++; /// namespaces).; ///; /// Indexed by the parent context ID, context kind and the identifier ID of; /// this context and provides both the context ID and information describing; /// the context within that module.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/APINotes/APINotesWriter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/APINotes/APINotesWriter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/APINotes/APINotesWriter.cpp:29,Modifiability,variab,variables,29,"/// Information about global variables.; ///; /// Indexed by the context ID, contextKind, identifier ID.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/APINotes/APINotesWriter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/APINotes/APINotesWriter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/APINotes/APINotesWriter.cpp:36,Integrability,depend,dependent,36,"/// Localized helper to make a type dependent, thwarting template argument; /// deduction.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/APINotes/APINotesWriter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/APINotes/APINotesWriter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/APINotes/APINotesWriter.cpp:84,Security,hash,hash,84,"/// Retrieve the serialized size of the given VersionTuple, for use in; /// on-disk hash tables.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/APINotes/APINotesWriter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/APINotes/APINotesWriter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/APINotes/APINotesWriter.cpp:12,Security,hash,hash,12,/// On-disk hash table info key base for handling versioned data.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/APINotes/APINotesWriter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/APINotes/APINotesWriter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/APINotes/APINotesWriter.cpp:88,Security,hash,hash,88,"/// Retrieve the serialized size of the given CommonEntityInfo, for use in; /// on-disk hash tables.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/APINotes/APINotesWriter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/APINotes/APINotesWriter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/APINotes/APINotesWriter.cpp:84,Security,hash,hash,84,"// Retrieve the serialized size of the given CommonTypeInfo, for use; // in on-disk hash tables.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/APINotes/APINotesWriter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/APINotes/APINotesWriter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/APINotes/APINotesWriter.cpp:46,Modifiability,Variab,VariableInfo,46,"/// Retrieve the serialized size of the given VariableInfo, for use in; /// on-disk hash tables.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/APINotes/APINotesWriter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/APINotes/APINotesWriter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/APINotes/APINotesWriter.cpp:84,Security,hash,hash,84,"/// Retrieve the serialized size of the given VariableInfo, for use in; /// on-disk hash tables.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/APINotes/APINotesWriter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/APINotes/APINotesWriter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/APINotes/APINotesWriter.cpp:44,Modifiability,variab,variable,44,/// Emit a serialized representation of the variable information.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/APINotes/APINotesWriter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/APINotes/APINotesWriter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/APINotes/APINotesWriter.cpp:41,Modifiability,variab,variable,41,/// Used to serialize the on-disk global variable table.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/APINotes/APINotesWriter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/APINotes/APINotesWriter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/APINotes/APINotesWriter.cpp:84,Security,hash,hash,84,"/// Retrieve the serialized size of the given FunctionInfo, for use in on-disk; /// hash tables.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/APINotes/APINotesWriter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/APINotes/APINotesWriter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/APINotes/APINotesWriter.cpp:47,Deployability,update,update,47,"// If this method is a designated initializer, update the class to note that; // it has designated initializers.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/APINotes/APINotesWriter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/APINotes/APINotesWriter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/APINotes/APINotesYAMLCompiler.cpp:13,Integrability,protocol,protocols,13,// Write all protocols.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/APINotes/APINotesYAMLCompiler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/APINotes/APINotesYAMLCompiler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/APINotes/APINotesYAMLCompiler.cpp:23,Integrability,protocol,protocol,23,// Check for duplicate protocol definitions.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/APINotes/APINotesYAMLCompiler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/APINotes/APINotesYAMLCompiler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/APINotes/APINotesYAMLCompiler.cpp:20,Modifiability,variab,variables,20,// Write all global variables.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/APINotes/APINotesYAMLCompiler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/APINotes/APINotesYAMLCompiler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/APINotes/APINotesYAMLCompiler.cpp:30,Modifiability,variab,variables,30,// Check for duplicate global variables.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/APINotes/APINotesYAMLCompiler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/APINotes/APINotesYAMLCompiler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/APINotes/APINotesYAMLCompiler.cpp:66,Availability,error,error,66,/// Simple diagnostic handler that prints diagnostics to standard error.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/APINotes/APINotesYAMLCompiler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/APINotes/APINotesYAMLCompiler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/APINotes/APINotesYAMLCompiler.cpp:4,Usability,Simpl,Simple,4,/// Simple diagnostic handler that prints diagnostics to standard error.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/APINotes/APINotesYAMLCompiler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/APINotes/APINotesYAMLCompiler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/ARCMigrate/ARCMT.cpp:15,Usability,clear,clear,15,// empty means clear all diagnostics in the range.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/ARCMigrate/ARCMT.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/ARCMigrate/ARCMT.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/ARCMigrate/ARCMT.cpp:3,Usability,Clear,Clear,3,// Clear the diagnostic and any notes following it.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/ARCMigrate/ARCMT.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/ARCMigrate/ARCMT.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/ARCMigrate/ARCMT.cpp:24,Integrability,message,message,24,// Pass BeginSourceFile message onto DiagClient on first call.; // The corresponding EndSourceFile call will be made from an; // explicit call to FinishCapture.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/ARCMigrate/ARCMT.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/ARCMigrate/ARCMT.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/ARCMigrate/ARCMT.cpp:155,Safety,avoid,avoid,155,"// This duplicates some functionality from Darwin::AddDeploymentTarget; // but this function is well defined, so keep it decoupled from the driver; // and avoid unrelated complications.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/ARCMigrate/ARCMT.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/ARCMigrate/ARCMT.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/ARCMigrate/ARCMTActions.cpp:3,Availability,error,errors,3,"// errors, stop the action.; // We only want to see warnings reported from arcmt::checkForManualIssues.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/ARCMigrate/ARCMTActions.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/ARCMigrate/ARCMTActions.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/ARCMigrate/ARCMTActions.cpp:3,Availability,error,errors,3,"// errors, stop the action.; // We only want to see diagnostics emitted by migrateWithTemporaryFiles.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/ARCMigrate/ARCMTActions.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/ARCMigrate/ARCMTActions.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/ARCMigrate/FileRemapper.cpp:76,Deployability,update,update,76,"// If we are updating a file that overridden an original file,; // actually update the original file.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/ARCMigrate/FileRemapper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/ARCMigrate/FileRemapper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/ARCMigrate/ObjCMT.cpp:33,Modifiability,Rewrite,RewriteObjCFoundationAPI,33,// FIXME. This duplicates one in RewriteObjCFoundationAPI.cpp,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/ARCMigrate/ObjCMT.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/ARCMigrate/ObjCMT.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/ARCMigrate/ObjCMT.cpp:14,Integrability,message,message,14,/// - Rewrite message expression for Objective-C setter and getters into; /// property-dot syntax.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/ARCMigrate/ObjCMT.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/ARCMigrate/ObjCMT.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/ARCMigrate/ObjCMT.cpp:6,Modifiability,Rewrite,Rewrite,6,/// - Rewrite message expression for Objective-C setter and getters into; /// property-dot syntax.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/ARCMigrate/ObjCMT.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/ARCMigrate/ObjCMT.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/ARCMigrate/ObjCMT.cpp:3,Modifiability,rewrite,rewrite,3,// rewrite getter method expression into: receiver.property or; // (receiver).property,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/ARCMigrate/ObjCMT.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/ARCMigrate/ObjCMT.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/ARCMigrate/ObjCMT.cpp:30,Modifiability,rewrite,rewrite,30,// Do depth first; we want to rewrite the subexpressions first so that if; // we have to move expressions we will move them already rewritten.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/ARCMigrate/ObjCMT.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/ARCMigrate/ObjCMT.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/ARCMigrate/ObjCMT.cpp:118,Deployability,continuous,continuous,118,"// property name must strip off ""is"" and lower case the first character; // after that; e.g. isContinuous will become continuous.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/ARCMigrate/ObjCMT.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/ARCMigrate/ObjCMT.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/ARCMigrate/ObjCMT.cpp:22,Integrability,protocol,protocol,22,"// In auto-synthesis, protocol properties are not synthesized. So,; // a conforming protocol must have its required properties declared; // in class interface.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/ARCMigrate/ObjCMT.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/ARCMigrate/ObjCMT.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/ARCMigrate/ObjCMT.cpp:84,Integrability,protocol,protocol,84,"// In auto-synthesis, protocol properties are not synthesized. So,; // a conforming protocol must have its required properties declared; // in class interface.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/ARCMigrate/ObjCMT.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/ARCMigrate/ObjCMT.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/ARCMigrate/ObjCMT.cpp:149,Integrability,interface,interface,149,"// In auto-synthesis, protocol properties are not synthesized. So,; // a conforming protocol must have its required properties declared; // in class interface.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/ARCMigrate/ObjCMT.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/ARCMigrate/ObjCMT.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/ARCMigrate/ObjCMT.cpp:157,Integrability,protocol,protocol,157,// Relax the rule and look into class's implementation for a synthesize; // or dynamic declaration. Class is implementing a property coming from; // another protocol. This still makes the target protocol as conforming.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/ARCMigrate/ObjCMT.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/ARCMigrate/ObjCMT.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/ARCMigrate/ObjCMT.cpp:195,Integrability,protocol,protocol,195,// Relax the rule and look into class's implementation for a synthesize; // or dynamic declaration. Class is implementing a property coming from; // another protocol. This still makes the target protocol as conforming.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/ARCMigrate/ObjCMT.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/ARCMigrate/ObjCMT.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/ARCMigrate/ObjCMT.cpp:50,Integrability,protocol,protocol,50,"// At this point, all required properties in this protocol conform to those; // declared in the class.; // Check that class implements the required methods of the protocol too.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/ARCMigrate/ObjCMT.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/ARCMigrate/ObjCMT.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/ARCMigrate/ObjCMT.cpp:163,Integrability,protocol,protocol,163,"// At this point, all required properties in this protocol conform to those; // declared in the class.; // Check that class implements the required methods of the protocol too.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/ARCMigrate/ObjCMT.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/ARCMigrate/ObjCMT.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/ARCMigrate/ObjCMT.cpp:32,Integrability,protocol,protocols,32,// Find all implicit conforming protocols for this class; // and make them explicit.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/ARCMigrate/ObjCMT.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/ARCMigrate/ObjCMT.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/ARCMigrate/ObjCMT.cpp:66,Integrability,protocol,protocol,66,"// go through list of non-optional methods and properties in each protocol; // in the PotentialImplicitProtocols list. If class implements every one of the; // methods and properties, then this class conforms to this protocol.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/ARCMigrate/ObjCMT.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/ARCMigrate/ObjCMT.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/ARCMigrate/ObjCMT.cpp:217,Integrability,protocol,protocol,217,"// go through list of non-optional methods and properties in each protocol; // in the PotentialImplicitProtocols list. If class implements every one of the; // methods and properties, then this class conforms to this protocol.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/ARCMigrate/ObjCMT.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/ARCMigrate/ObjCMT.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/ARCMigrate/ObjCMT.cpp:11,Energy Efficiency,reduce,reduce,11,"// Further reduce number of conforming protocols. If protocol P1 is in the list; // protocol P2 (P2<P1>), No need to include P1.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/ARCMigrate/ObjCMT.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/ARCMigrate/ObjCMT.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/ARCMigrate/ObjCMT.cpp:39,Integrability,protocol,protocols,39,"// Further reduce number of conforming protocols. If protocol P1 is in the list; // protocol P2 (P2<P1>), No need to include P1.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/ARCMigrate/ObjCMT.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/ARCMigrate/ObjCMT.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/ARCMigrate/ObjCMT.cpp:53,Integrability,protocol,protocol,53,"// Further reduce number of conforming protocols. If protocol P1 is in the list; // protocol P2 (P2<P1>), No need to include P1.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/ARCMigrate/ObjCMT.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/ARCMigrate/ObjCMT.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/ARCMigrate/ObjCMT.cpp:84,Integrability,protocol,protocol,84,"// Further reduce number of conforming protocols. If protocol P1 is in the list; // protocol P2 (P2<P1>), No need to include P1.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/ARCMigrate/ObjCMT.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/ARCMigrate/ObjCMT.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/ARCMigrate/ObjCMT.cpp:4,Availability,Avail,AvailabilityAttrsMatch,4,"/// AvailabilityAttrsMatch - This routine checks that if comparing two; /// availability attributes, all their components match. It returns; /// true, if not dealing with availability or when all components of; /// availability attributes match. This routine is only called when; /// the attributes are of the same kind.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/ARCMigrate/ObjCMT.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/ARCMigrate/ObjCMT.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/ARCMigrate/ObjCMT.cpp:76,Availability,avail,availability,76,"/// AvailabilityAttrsMatch - This routine checks that if comparing two; /// availability attributes, all their components match. It returns; /// true, if not dealing with availability or when all components of; /// availability attributes match. This routine is only called when; /// the attributes are of the same kind.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/ARCMigrate/ObjCMT.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/ARCMigrate/ObjCMT.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/ARCMigrate/ObjCMT.cpp:171,Availability,avail,availability,171,"/// AvailabilityAttrsMatch - This routine checks that if comparing two; /// availability attributes, all their components match. It returns; /// true, if not dealing with availability or when all components of; /// availability attributes match. This routine is only called when; /// the attributes are of the same kind.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/ARCMigrate/ObjCMT.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/ARCMigrate/ObjCMT.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/ARCMigrate/ObjCMT.cpp:215,Availability,avail,availability,215,"/// AvailabilityAttrsMatch - This routine checks that if comparing two; /// availability attributes, all their components match. It returns; /// true, if not dealing with availability or when all components of; /// availability attributes match. This routine is only called when; /// the attributes are of the same kind.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/ARCMigrate/ObjCMT.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/ARCMigrate/ObjCMT.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/ARCMigrate/ObjCMT.cpp:34,Integrability,rout,routine,34,"/// AvailabilityAttrsMatch - This routine checks that if comparing two; /// availability attributes, all their components match. It returns; /// true, if not dealing with availability or when all components of; /// availability attributes match. This routine is only called when; /// the attributes are of the same kind.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/ARCMigrate/ObjCMT.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/ARCMigrate/ObjCMT.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/ARCMigrate/ObjCMT.cpp:251,Integrability,rout,routine,251,"/// AvailabilityAttrsMatch - This routine checks that if comparing two; /// availability attributes, all their components match. It returns; /// true, if not dealing with availability or when all components of; /// availability attributes match. This routine is only called when; /// the attributes are of the same kind.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/ARCMigrate/ObjCMT.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/ARCMigrate/ObjCMT.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/ARCMigrate/ObjCMT.cpp:48,Performance,optimiz,optimized,48,"// This list is very small, so this need not be optimized.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/ARCMigrate/ObjCMT.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/ARCMigrate/ObjCMT.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/ARCMigrate/ObjCMT.cpp:44,Availability,Avail,Availability,44,"// Matching attribute kind only. Except for Availability attributes,; // we are not getting into details of the attributes. For all practical purposes; // this is sufficient.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/ARCMigrate/ObjCMT.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/ARCMigrate/ObjCMT.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/ARCMigrate/ObjCMT.cpp:277,Availability,avail,availability,277,"/// AttributesMatch - This routine checks list of attributes for two; /// decls. It returns false, if there is a mismatch in kind of; /// attributes seen in the decls. It returns true if the two decls; /// have list of same kind of attributes. Furthermore, when there; /// are availability attributes in the two decls, it sets the; /// AvailabilityArgsMatch to false if availability attributes have; /// different versions, etc.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/ARCMigrate/ObjCMT.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/ARCMigrate/ObjCMT.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/ARCMigrate/ObjCMT.cpp:336,Availability,Avail,AvailabilityArgsMatch,336,"/// AttributesMatch - This routine checks list of attributes for two; /// decls. It returns false, if there is a mismatch in kind of; /// attributes seen in the decls. It returns true if the two decls; /// have list of same kind of attributes. Furthermore, when there; /// are availability attributes in the two decls, it sets the; /// AvailabilityArgsMatch to false if availability attributes have; /// different versions, etc.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/ARCMigrate/ObjCMT.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/ARCMigrate/ObjCMT.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/ARCMigrate/ObjCMT.cpp:370,Availability,avail,availability,370,"/// AttributesMatch - This routine checks list of attributes for two; /// decls. It returns false, if there is a mismatch in kind of; /// attributes seen in the decls. It returns true if the two decls; /// have list of same kind of attributes. Furthermore, when there; /// are availability attributes in the two decls, it sets the; /// AvailabilityArgsMatch to false if availability attributes have; /// different versions, etc.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/ARCMigrate/ObjCMT.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/ARCMigrate/ObjCMT.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/ARCMigrate/ObjCMT.cpp:27,Integrability,rout,routine,27,"/// AttributesMatch - This routine checks list of attributes for two; /// decls. It returns false, if there is a mismatch in kind of; /// attributes seen in the decls. It returns true if the two decls; /// have list of same kind of attributes. Furthermore, when there; /// are availability attributes in the two decls, it sets the; /// AvailabilityArgsMatch to false if availability attributes have; /// different versions, etc.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/ARCMigrate/ObjCMT.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/ARCMigrate/ObjCMT.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/ARCMigrate/ObjCMT.cpp:2,Availability,Avail,AvailabilityArgsMatch,2,/*AvailabilityArgsMatch*/,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/ARCMigrate/ObjCMT.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/ARCMigrate/ObjCMT.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/ARCMigrate/ObjCMT.cpp:23,Integrability,rout,routine,23,"/// AuditedType - This routine audits the type AT and returns false if it is one of known; /// CF object types or of the ""void *"" variety. It returns true if we don't care about the type; /// such as a non-pointer or pointers which have no ownership issues (such as ""int *"").",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/ARCMigrate/ObjCMT.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/ARCMigrate/ObjCMT.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/ARCMigrate/ObjCMT.cpp:4,Security,Audit,AuditedType,4,"/// AuditedType - This routine audits the type AT and returns false if it is one of known; /// CF object types or of the ""void *"" variety. It returns true if we don't care about the type; /// such as a non-pointer or pointers which have no ownership issues (such as ""int *"").",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/ARCMigrate/ObjCMT.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/ARCMigrate/ObjCMT.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/ARCMigrate/ObjCMT.cpp:31,Security,audit,audits,31,"/// AuditedType - This routine audits the type AT and returns false if it is one of known; /// CF object types or of the ""void *"" variety. It returns true if we don't care about the type; /// such as a non-pointer or pointers which have no ownership issues (such as ""int *"").",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/ARCMigrate/ObjCMT.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/ARCMigrate/ObjCMT.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/ARCMigrate/ObjCMT.cpp:93,Security,audit,audited,93,"// If an ObjC object is type, assuming that it is not a CF function and; // that it is an un-audited function.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/ARCMigrate/ObjCMT.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/ARCMigrate/ObjCMT.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/ARCMigrate/ObjCMT.cpp:34,Security,audit,audited,34,// All other pointers are assumed audited as harmless.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/ARCMigrate/ObjCMT.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/ARCMigrate/ObjCMT.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/ARCMigrate/ObjCMT.cpp:32,Security,audit,audited,32,// At this point result type is audited for potential inclusion.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/ARCMigrate/ObjCMT.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/ARCMigrate/ObjCMT.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/ARCMigrate/ObjCMT.cpp:52,Security,audit,audited,52,// At this point result type is either annotated or audited.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/ARCMigrate/ObjCMT.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/ARCMigrate/ObjCMT.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/ARCMigrate/TransAPIUses.cpp:411,Availability,error,error,411,"//===--- TransAPIUses.cpp - Transformations to ARC mode -------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // checkAPIUses:; //; // Emits error/fix with some API uses that are obsolete or not safe in ARC mode:; //; // - NSInvocation's [get/set]ReturnValue and [get/set]Argument are only safe; // with __unsafe_unretained objects.; // - Calling -zone gets replaced with 'nil'.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/ARCMigrate/TransAPIUses.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/ARCMigrate/TransAPIUses.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/ARCMigrate/TransAPIUses.cpp:465,Safety,safe,safe,465,"//===--- TransAPIUses.cpp - Transformations to ARC mode -------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // checkAPIUses:; //; // Emits error/fix with some API uses that are obsolete or not safe in ARC mode:; //; // - NSInvocation's [get/set]ReturnValue and [get/set]Argument are only safe; // with __unsafe_unretained objects.; // - Calling -zone gets replaced with 'nil'.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/ARCMigrate/TransAPIUses.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/ARCMigrate/TransAPIUses.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/ARCMigrate/TransAPIUses.cpp:560,Safety,safe,safe,560,"//===--- TransAPIUses.cpp - Transformations to ARC mode -------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // checkAPIUses:; //; // Emits error/fix with some API uses that are obsolete or not safe in ARC mode:; //; // - NSInvocation's [get/set]ReturnValue and [get/set]Argument are only safe; // with __unsafe_unretained objects.; // - Calling -zone gets replaced with 'nil'.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/ARCMigrate/TransAPIUses.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/ARCMigrate/TransAPIUses.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/ARCMigrate/TransAutoreleasePool.cpp:573,Deployability,release,release,573,"//===--- TransAutoreleasePool.cpp - Transformations to ARC mode -----------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // rewriteAutoreleasePool:; //; // Calls to NSAutoreleasePools will be rewritten as an @autorelease scope.; //; // NSAutoreleasePool *pool = [[NSAutoreleasePool alloc] init];; // ...; // [pool release];; // ---->; // @autorelease {; // ...; // }; //; // An NSAutoreleasePool will not be touched if:; // - There is not a corresponding -release/-drain in the same scope; // - Not all references of the NSAutoreleasePool variable can be removed; // - There is a variable that is declared inside the intended @autorelease scope; // which is also used outside it.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/ARCMigrate/TransAutoreleasePool.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/ARCMigrate/TransAutoreleasePool.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/ARCMigrate/TransAutoreleasePool.cpp:715,Deployability,release,release,715,"//===--- TransAutoreleasePool.cpp - Transformations to ARC mode -----------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // rewriteAutoreleasePool:; //; // Calls to NSAutoreleasePools will be rewritten as an @autorelease scope.; //; // NSAutoreleasePool *pool = [[NSAutoreleasePool alloc] init];; // ...; // [pool release];; // ---->; // @autorelease {; // ...; // }; //; // An NSAutoreleasePool will not be touched if:; // - There is not a corresponding -release/-drain in the same scope; // - Not all references of the NSAutoreleasePool variable can be removed; // - There is a variable that is declared inside the intended @autorelease scope; // which is also used outside it.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/ARCMigrate/TransAutoreleasePool.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/ARCMigrate/TransAutoreleasePool.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/ARCMigrate/TransAutoreleasePool.cpp:724,Energy Efficiency,drain,drain,724,"//===--- TransAutoreleasePool.cpp - Transformations to ARC mode -----------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // rewriteAutoreleasePool:; //; // Calls to NSAutoreleasePools will be rewritten as an @autorelease scope.; //; // NSAutoreleasePool *pool = [[NSAutoreleasePool alloc] init];; // ...; // [pool release];; // ---->; // @autorelease {; // ...; // }; //; // An NSAutoreleasePool will not be touched if:; // - There is not a corresponding -release/-drain in the same scope; // - Not all references of the NSAutoreleasePool variable can be removed; // - There is a variable that is declared inside the intended @autorelease scope; // which is also used outside it.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/ARCMigrate/TransAutoreleasePool.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/ARCMigrate/TransAutoreleasePool.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/ARCMigrate/TransAutoreleasePool.cpp:383,Modifiability,rewrite,rewriteAutoreleasePool,383,"//===--- TransAutoreleasePool.cpp - Transformations to ARC mode -----------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // rewriteAutoreleasePool:; //; // Calls to NSAutoreleasePools will be rewritten as an @autorelease scope.; //; // NSAutoreleasePool *pool = [[NSAutoreleasePool alloc] init];; // ...; // [pool release];; // ---->; // @autorelease {; // ...; // }; //; // An NSAutoreleasePool will not be touched if:; // - There is not a corresponding -release/-drain in the same scope; // - Not all references of the NSAutoreleasePool variable can be removed; // - There is a variable that is declared inside the intended @autorelease scope; // which is also used outside it.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/ARCMigrate/TransAutoreleasePool.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/ARCMigrate/TransAutoreleasePool.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/ARCMigrate/TransAutoreleasePool.cpp:798,Modifiability,variab,variable,798,"//===--- TransAutoreleasePool.cpp - Transformations to ARC mode -----------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // rewriteAutoreleasePool:; //; // Calls to NSAutoreleasePools will be rewritten as an @autorelease scope.; //; // NSAutoreleasePool *pool = [[NSAutoreleasePool alloc] init];; // ...; // [pool release];; // ---->; // @autorelease {; // ...; // }; //; // An NSAutoreleasePool will not be touched if:; // - There is not a corresponding -release/-drain in the same scope; // - Not all references of the NSAutoreleasePool variable can be removed; // - There is a variable that is declared inside the intended @autorelease scope; // which is also used outside it.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/ARCMigrate/TransAutoreleasePool.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/ARCMigrate/TransAutoreleasePool.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/ARCMigrate/TransAutoreleasePool.cpp:839,Modifiability,variab,variable,839,"//===--- TransAutoreleasePool.cpp - Transformations to ARC mode -----------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // rewriteAutoreleasePool:; //; // Calls to NSAutoreleasePools will be rewritten as an @autorelease scope.; //; // NSAutoreleasePool *pool = [[NSAutoreleasePool alloc] init];; // ...; // [pool release];; // ---->; // @autorelease {; // ...; // }; //; // An NSAutoreleasePool will not be touched if:; // - There is not a corresponding -release/-drain in the same scope; // - Not all references of the NSAutoreleasePool variable can be removed; // - There is a variable that is declared inside the intended @autorelease scope; // which is also used outside it.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/ARCMigrate/TransAutoreleasePool.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/ARCMigrate/TransAutoreleasePool.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/ARCMigrate/TransAutoreleasePool.cpp:28,Modifiability,rewrite,rewrite,28,// Check that we can handle/rewrite all references of the pool.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/ARCMigrate/TransAutoreleasePool.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/ARCMigrate/TransAutoreleasePool.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/ARCMigrate/TransAutoreleasePool.cpp:84,Modifiability,variab,variable,84,// Even if one reference is not handled we will not do anything about that; // pool variable.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/ARCMigrate/TransAutoreleasePool.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/ARCMigrate/TransAutoreleasePool.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/ARCMigrate/TransAutoreleasePool.cpp:55,Usability,simpl,simple,55,"// Check if the autoreleasepool scope is followed by a simple return; // statement, in which case we will include the return in the scope.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/ARCMigrate/TransAutoreleasePool.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/ARCMigrate/TransAutoreleasePool.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/ARCMigrate/TransAutoreleasePool.cpp:52,Modifiability,variab,variables,52,// If not all references were cleared it means some variables/typenames/etc; // declared inside the pool scope are used outside of it.; // We won't try to rewrite the pool.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/ARCMigrate/TransAutoreleasePool.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/ARCMigrate/TransAutoreleasePool.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/ARCMigrate/TransAutoreleasePool.cpp:155,Modifiability,rewrite,rewrite,155,// If not all references were cleared it means some variables/typenames/etc; // declared inside the pool scope are used outside of it.; // We won't try to rewrite the pool.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/ARCMigrate/TransAutoreleasePool.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/ARCMigrate/TransAutoreleasePool.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/ARCMigrate/TransAutoreleasePool.cpp:30,Usability,clear,cleared,30,// If not all references were cleared it means some variables/typenames/etc; // declared inside the pool scope are used outside of it.; // We won't try to rewrite the pool.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/ARCMigrate/TransAutoreleasePool.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/ARCMigrate/TransAutoreleasePool.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/ARCMigrate/TransAutoreleasePool.cpp:15,Deployability,release,releases,15,// Collect all releases of the pool; they will be removed.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/ARCMigrate/TransAutoreleasePool.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/ARCMigrate/TransAutoreleasePool.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/ARCMigrate/TransBlockObjCVariable.cpp:383,Modifiability,rewrite,rewriteBlockObjCVariable,383,"//===--- TransBlockObjCVariable.cpp - Transformations to ARC mode ---------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // rewriteBlockObjCVariable:; //; // Adding __block to an obj-c variable could be either because the variable; // is used for output storage or the user wanted to break a retain cycle.; // This transformation checks whether a reference of the variable for the block; // is actually needed (it is assigned to or its address is taken) or not.; // If the reference is not needed it will assume __block was added to break a; // cycle so it will remove '__block' and add __weak/__unsafe_unretained.; // e.g; //; // __block Foo *x;; // bar(^ { [x cake]; });; // ---->; // __weak Foo *x;; // bar(^ { [x cake]; });; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/ARCMigrate/TransBlockObjCVariable.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/ARCMigrate/TransBlockObjCVariable.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/ARCMigrate/TransBlockObjCVariable.cpp:444,Modifiability,variab,variable,444,"//===--- TransBlockObjCVariable.cpp - Transformations to ARC mode ---------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // rewriteBlockObjCVariable:; //; // Adding __block to an obj-c variable could be either because the variable; // is used for output storage or the user wanted to break a retain cycle.; // This transformation checks whether a reference of the variable for the block; // is actually needed (it is assigned to or its address is taken) or not.; // If the reference is not needed it will assume __block was added to break a; // cycle so it will remove '__block' and add __weak/__unsafe_unretained.; // e.g; //; // __block Foo *x;; // bar(^ { [x cake]; });; // ---->; // __weak Foo *x;; // bar(^ { [x cake]; });; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/ARCMigrate/TransBlockObjCVariable.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/ARCMigrate/TransBlockObjCVariable.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/ARCMigrate/TransBlockObjCVariable.cpp:481,Modifiability,variab,variable,481,"//===--- TransBlockObjCVariable.cpp - Transformations to ARC mode ---------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // rewriteBlockObjCVariable:; //; // Adding __block to an obj-c variable could be either because the variable; // is used for output storage or the user wanted to break a retain cycle.; // This transformation checks whether a reference of the variable for the block; // is actually needed (it is assigned to or its address is taken) or not.; // If the reference is not needed it will assume __block was added to break a; // cycle so it will remove '__block' and add __weak/__unsafe_unretained.; // e.g; //; // __block Foo *x;; // bar(^ { [x cake]; });; // ---->; // __weak Foo *x;; // bar(^ { [x cake]; });; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/ARCMigrate/TransBlockObjCVariable.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/ARCMigrate/TransBlockObjCVariable.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/ARCMigrate/TransBlockObjCVariable.cpp:623,Modifiability,variab,variable,623,"//===--- TransBlockObjCVariable.cpp - Transformations to ARC mode ---------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // rewriteBlockObjCVariable:; //; // Adding __block to an obj-c variable could be either because the variable; // is used for output storage or the user wanted to break a retain cycle.; // This transformation checks whether a reference of the variable for the block; // is actually needed (it is assigned to or its address is taken) or not.; // If the reference is not needed it will assume __block was added to break a; // cycle so it will remove '__block' and add __weak/__unsafe_unretained.; // e.g; //; // __block Foo *x;; // bar(^ { [x cake]; });; // ---->; // __weak Foo *x;; // bar(^ { [x cake]; });; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/ARCMigrate/TransBlockObjCVariable.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/ARCMigrate/TransBlockObjCVariable.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/ARCMigrate/TransBlockObjCVariable.cpp:26,Modifiability,variab,variable,26,// Using the value of the variable.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/ARCMigrate/TransBlockObjCVariable.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/ARCMigrate/TransBlockObjCVariable.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/ARCMigrate/TransBlockObjCVariable.cpp:24,Modifiability,variab,variable,24,"// The reference of the variable, and not just its value,; // is needed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/ARCMigrate/TransBlockObjCVariable.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/ARCMigrate/TransBlockObjCVariable.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/ARCMigrate/TransEmptyStatementsAndDealloc.cpp:202,Usability,clear,clear,202,"// We make the reasonable assumption that a semicolon after 100 characters; // means that it is not the next token after our macro. If this assumption; // fails it is not critical, we will just fail to clear out, e.g., an empty; // 'if'.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/ARCMigrate/TransEmptyStatementsAndDealloc.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/ARCMigrate/TransEmptyStatementsAndDealloc.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/ARCMigrate/TransformActions.cpp:176,Modifiability,rewrite,rewriter,176,"/// Collects transformations and merges them before applying them with; /// with applyRewrites(). E.g. if the same source range; /// is requested to be removed twice, only one rewriter remove will be invoked.; /// Rewrites happen in ""transactions""; if one rewrite in the transaction cannot; /// be done (e.g. it resides in a macro) all rewrites in the transaction are; /// aborted.; /// FIXME: ""Transactional"" rewrites support should be baked in the Rewriter.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/ARCMigrate/TransformActions.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/ARCMigrate/TransformActions.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/ARCMigrate/TransformActions.cpp:214,Modifiability,Rewrite,Rewrites,214,"/// Collects transformations and merges them before applying them with; /// with applyRewrites(). E.g. if the same source range; /// is requested to be removed twice, only one rewriter remove will be invoked.; /// Rewrites happen in ""transactions""; if one rewrite in the transaction cannot; /// be done (e.g. it resides in a macro) all rewrites in the transaction are; /// aborted.; /// FIXME: ""Transactional"" rewrites support should be baked in the Rewriter.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/ARCMigrate/TransformActions.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/ARCMigrate/TransformActions.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/ARCMigrate/TransformActions.cpp:256,Modifiability,rewrite,rewrite,256,"/// Collects transformations and merges them before applying them with; /// with applyRewrites(). E.g. if the same source range; /// is requested to be removed twice, only one rewriter remove will be invoked.; /// Rewrites happen in ""transactions""; if one rewrite in the transaction cannot; /// be done (e.g. it resides in a macro) all rewrites in the transaction are; /// aborted.; /// FIXME: ""Transactional"" rewrites support should be baked in the Rewriter.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/ARCMigrate/TransformActions.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/ARCMigrate/TransformActions.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/ARCMigrate/TransformActions.cpp:336,Modifiability,rewrite,rewrites,336,"/// Collects transformations and merges them before applying them with; /// with applyRewrites(). E.g. if the same source range; /// is requested to be removed twice, only one rewriter remove will be invoked.; /// Rewrites happen in ""transactions""; if one rewrite in the transaction cannot; /// be done (e.g. it resides in a macro) all rewrites in the transaction are; /// aborted.; /// FIXME: ""Transactional"" rewrites support should be baked in the Rewriter.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/ARCMigrate/TransformActions.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/ARCMigrate/TransformActions.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/ARCMigrate/TransformActions.cpp:410,Modifiability,rewrite,rewrites,410,"/// Collects transformations and merges them before applying them with; /// with applyRewrites(). E.g. if the same source range; /// is requested to be removed twice, only one rewriter remove will be invoked.; /// Rewrites happen in ""transactions""; if one rewrite in the transaction cannot; /// be done (e.g. it resides in a macro) all rewrites in the transaction are; /// aborted.; /// FIXME: ""Transactional"" rewrites support should be baked in the Rewriter.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/ARCMigrate/TransformActions.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/ARCMigrate/TransformActions.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/ARCMigrate/TransformActions.cpp:450,Modifiability,Rewrite,Rewriter,450,"/// Collects transformations and merges them before applying them with; /// with applyRewrites(). E.g. if the same source range; /// is requested to be removed twice, only one rewriter remove will be invoked.; /// Rewrites happen in ""transactions""; if one rewrite in the transaction cannot; /// be done (e.g. it resides in a macro) all rewrites in the transaction are; /// aborted.; /// FIXME: ""Transactional"" rewrites support should be baked in the Rewriter.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/ARCMigrate/TransformActions.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/ARCMigrate/TransformActions.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/ARCMigrate/TransformActions.cpp:373,Safety,abort,aborted,373,"/// Collects transformations and merges them before applying them with; /// with applyRewrites(). E.g. if the same source range; /// is requested to be removed twice, only one rewriter remove will be invoked.; /// Rewrites happen in ""transactions""; if one rewrite in the transaction cannot; /// be done (e.g. it resides in a macro) all rewrites in the transaction are; /// aborted.; /// FIXME: ""Transactional"" rewrites support should be baked in the Rewriter.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/ARCMigrate/TransformActions.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/ARCMigrate/TransformActions.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/ARCMigrate/TransformActions.cpp:78,Availability,alive,alive,78,"/// Stores text passed to the transformation methods to keep the string; /// ""alive"". Since the vast majority of text will be the same, we also unique; /// the strings using a StringMap.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/ARCMigrate/TransformActions.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/ARCMigrate/TransformActions.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/ARCMigrate/TransformActions.cpp:50,Safety,abort,abort,50,// Verify that all actions are possible otherwise abort the whole transaction.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/ARCMigrate/TransformActions.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/ARCMigrate/TransformActions.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/ARCMigrate/TransformActions.cpp:31,Modifiability,rewrite,rewrites,31,// We are just checking source rewrites.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/ARCMigrate/TransformActions.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/ARCMigrate/TransformActions.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/ARCMigrate/TransformActions.cpp:9,Availability,down,down,9,// Break down the source location.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/ARCMigrate/TransformActions.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/ARCMigrate/TransformActions.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/ARCMigrate/TransformActions.cpp:10,Performance,load,load,10,// Try to load the file buffer.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/ARCMigrate/TransformActions.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/ARCMigrate/TransformActions.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/ARCMigrate/TransformActions.cpp:43,Deployability,release,release,43,"// Although we asserted, be extra safe for release build.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/ARCMigrate/TransformActions.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/ARCMigrate/TransformActions.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/ARCMigrate/TransformActions.cpp:34,Safety,safe,safe,34,"// Although we asserted, be extra safe for release build.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/ARCMigrate/TransformActions.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/ARCMigrate/TransformActions.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/ARCMigrate/TransformActions.cpp:15,Testability,assert,asserted,15,"// Although we asserted, be extra safe for release build.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/ARCMigrate/TransformActions.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/ARCMigrate/TransformActions.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/ARCMigrate/TransformActions.cpp:78,Availability,alive,alive,78,"/// Stores text passed to the transformation methods to keep the string; /// ""alive"". Since the vast majority of text will be the same, we also unique; /// the strings using a StringMap.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/ARCMigrate/TransformActions.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/ARCMigrate/TransformActions.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/ARCMigrate/Transforms.cpp:17,Safety,safe,safe,17,// iOS is always safe to use 'weak'.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/ARCMigrate/Transforms.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/ARCMigrate/Transforms.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/ARCMigrate/Transforms.cpp:22,Safety,safe,safe,22,// id/NSObject is not safe for weak.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/ARCMigrate/Transforms.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/ARCMigrate/Transforms.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/ARCMigrate/Transforms.cpp:53,Safety,safe,safe,53,"// forward classes are not verifiable, therefore not safe.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/ARCMigrate/Transforms.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/ARCMigrate/Transforms.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/ARCMigrate/Transforms.cpp:9,Availability,down,down,9,// Break down the source location.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/ARCMigrate/Transforms.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/ARCMigrate/Transforms.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/ARCMigrate/Transforms.cpp:10,Performance,load,load,10,// Try to load the file buffer.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/ARCMigrate/Transforms.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/ARCMigrate/Transforms.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/ARCMigrate/Transforms.cpp:9,Availability,down,down,9,// Break down the source location.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/ARCMigrate/Transforms.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/ARCMigrate/Transforms.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/ARCMigrate/Transforms.cpp:10,Performance,load,load,10,// Try to load the file buffer.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/ARCMigrate/Transforms.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/ARCMigrate/Transforms.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/ARCMigrate/Transforms.cpp:9,Availability,down,down,9,// Break down the source location.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/ARCMigrate/Transforms.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/ARCMigrate/Transforms.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/ARCMigrate/Transforms.cpp:10,Performance,load,load,10,// Try to load the file buffer.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/ARCMigrate/Transforms.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/ARCMigrate/Transforms.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/ARCMigrate/Transforms.cpp:8,Integrability,depend,depends,8,// This depends on previous transformations removing various expressions.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/ARCMigrate/Transforms.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/ARCMigrate/Transforms.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/ARCMigrate/Transforms.h:81,Integrability,interface,interface,81,"/// true if the attribute is owned, e.g. it is in a body and not just; /// in an interface.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/ARCMigrate/Transforms.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/ARCMigrate/Transforms.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/ARCMigrate/TransProperties.cpp:717,Integrability,interface,interface,717,"//===--- TransProperties.cpp - Transformations to ARC mode ----------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // rewriteProperties:; //; // - Adds strong/weak/unsafe_unretained ownership specifier to properties that; // are missing one.; // - Migrates properties from (retain) to (strong) and (assign) to; // (unsafe_unretained/weak).; // - If a property is synthesized, adds the ownership specifier in the ivar; // backing the property.; //; // @interface Foo : NSObject {; // NSObject *x;; // }; // @property (assign) id x;; // @end; // ---->; // @interface Foo : NSObject {; // NSObject *__weak x;; // }; // @property (weak) id x;; // @end; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/ARCMigrate/TransProperties.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/ARCMigrate/TransProperties.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/ARCMigrate/TransProperties.cpp:820,Integrability,interface,interface,820,"//===--- TransProperties.cpp - Transformations to ARC mode ----------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // rewriteProperties:; //; // - Adds strong/weak/unsafe_unretained ownership specifier to properties that; // are missing one.; // - Migrates properties from (retain) to (strong) and (assign) to; // (unsafe_unretained/weak).; // - If a property is synthesized, adds the ownership specifier in the ivar; // backing the property.; //; // @interface Foo : NSObject {; // NSObject *x;; // }; // @property (assign) id x;; // @end; // ---->; // @interface Foo : NSObject {; // NSObject *__weak x;; // }; // @property (weak) id x;; // @end; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/ARCMigrate/TransProperties.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/ARCMigrate/TransProperties.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/ARCMigrate/TransProperties.cpp:383,Modifiability,rewrite,rewriteProperties,383,"//===--- TransProperties.cpp - Transformations to ARC mode ----------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // rewriteProperties:; //; // - Adds strong/weak/unsafe_unretained ownership specifier to properties that; // are missing one.; // - Migrates properties from (retain) to (strong) and (assign) to; // (unsafe_unretained/weak).; // - If a property is synthesized, adds the ownership specifier in the ivar; // backing the property.; //; // @interface Foo : NSObject {; // NSObject *x;; // }; // @property (assign) id x;; // @end; // ---->; // @interface Foo : NSObject {; // NSObject *__weak x;; // }; // @property (weak) id x;; // @end; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/ARCMigrate/TransProperties.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/ARCMigrate/TransProperties.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/ARCMigrate/TransProtectedScope.cpp:527,Availability,error,error,527,"//===--- TransProtectedScope.cpp - Transformations to ARC mode ------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // Adds brackets in case statements that ""contain"" initialization of retaining; // variable, thus emitting the ""switch case is in protected scope"" error.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/ARCMigrate/TransProtectedScope.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/ARCMigrate/TransProtectedScope.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/ARCMigrate/TransProtectedScope.cpp:463,Modifiability,variab,variable,463,"//===--- TransProtectedScope.cpp - Transformations to ARC mode ------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // Adds brackets in case statements that ""contain"" initialization of retaining; // variable, thus emitting the ""switch case is in protected scope"" error.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/ARCMigrate/TransProtectedScope.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/ARCMigrate/TransProtectedScope.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/ARCMigrate/TransRetainReleaseDealloc.cpp:434,Deployability,release,release,434,"//===--- TransRetainReleaseDealloc.cpp - Transformations to ARC mode ------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // removeRetainReleaseDealloc:; //; // Removes retain/release/autorelease/dealloc messages.; //; // return [[foo retain] autorelease];; // ---->; // return foo;; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/ARCMigrate/TransRetainReleaseDealloc.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/ARCMigrate/TransRetainReleaseDealloc.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/ARCMigrate/TransRetainReleaseDealloc.cpp:462,Integrability,message,messages,462,"//===--- TransRetainReleaseDealloc.cpp - Transformations to ARC mode ------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // removeRetainReleaseDealloc:; //; // Removes retain/release/autorelease/dealloc messages.; //; // return [[foo retain] autorelease];; // ---->; // return foo;; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/ARCMigrate/TransRetainReleaseDealloc.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/ARCMigrate/TransRetainReleaseDealloc.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/ARCMigrate/TransRetainReleaseDealloc.cpp:127,Availability,alive,alive,127,"// An unused autorelease is badness. If we remove it the receiver; // will likely die immediately while previously it was kept alive; // by the autorelease pool. This is bad practice in general, leave it; // and emit an error to force the user to restructure their code.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/ARCMigrate/TransRetainReleaseDealloc.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/ARCMigrate/TransRetainReleaseDealloc.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/ARCMigrate/TransRetainReleaseDealloc.cpp:220,Availability,error,error,220,"// An unused autorelease is badness. If we remove it the receiver; // will likely die immediately while previously it was kept alive; // by the autorelease pool. This is bad practice in general, leave it; // and emit an error to force the user to restructure their code.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/ARCMigrate/TransRetainReleaseDealloc.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/ARCMigrate/TransRetainReleaseDealloc.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/ARCMigrate/TransRetainReleaseDealloc.cpp:15,Deployability,release,release,15,"// Change the -release to ""receiver = nil"" in a finally to avoid a leak; // when an exception is thrown.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/ARCMigrate/TransRetainReleaseDealloc.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/ARCMigrate/TransRetainReleaseDealloc.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/ARCMigrate/TransRetainReleaseDealloc.cpp:59,Safety,avoid,avoid,59,"// Change the -release to ""receiver = nil"" in a finally to avoid a leak; // when an exception is thrown.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/ARCMigrate/TransRetainReleaseDealloc.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/ARCMigrate/TransRetainReleaseDealloc.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/ARCMigrate/TransRetainReleaseDealloc.cpp:22,Modifiability,variab,variable,22,"// Check for ""return <variable>;"".",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/ARCMigrate/TransRetainReleaseDealloc.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/ARCMigrate/TransRetainReleaseDealloc.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/ARCMigrate/TransRetainReleaseDealloc.cpp:24,Deployability,release,release,24,/// Check if the retain/release is due to a GCD/XPC macro that are; /// defined as:; ///; /// #define dispatch_retain(object) ({ dispatch_object_t _o = (object); _dispatch_object_validate(_o); (void)[_o retain]; }); /// #define dispatch_release(object) ({ dispatch_object_t _o = (object); _dispatch_object_validate(_o); [_o release]; }); /// #define xpc_retain(object) ({ xpc_object_t _o = (object); _xpc_object_validate(_o); [_o retain]; }); /// #define xpc_release(object) ({ xpc_object_t _o = (object); _xpc_object_validate(_o); [_o release]; }); ///; /// and return the top container which is the StmtExpr and the macro argument; /// expression.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/ARCMigrate/TransRetainReleaseDealloc.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/ARCMigrate/TransRetainReleaseDealloc.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/ARCMigrate/TransRetainReleaseDealloc.cpp:324,Deployability,release,release,324,/// Check if the retain/release is due to a GCD/XPC macro that are; /// defined as:; ///; /// #define dispatch_retain(object) ({ dispatch_object_t _o = (object); _dispatch_object_validate(_o); (void)[_o retain]; }); /// #define dispatch_release(object) ({ dispatch_object_t _o = (object); _dispatch_object_validate(_o); [_o release]; }); /// #define xpc_retain(object) ({ xpc_object_t _o = (object); _xpc_object_validate(_o); [_o retain]; }); /// #define xpc_release(object) ({ xpc_object_t _o = (object); _xpc_object_validate(_o); [_o release]; }); ///; /// and return the top container which is the StmtExpr and the macro argument; /// expression.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/ARCMigrate/TransRetainReleaseDealloc.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/ARCMigrate/TransRetainReleaseDealloc.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/ARCMigrate/TransRetainReleaseDealloc.cpp:536,Deployability,release,release,536,/// Check if the retain/release is due to a GCD/XPC macro that are; /// defined as:; ///; /// #define dispatch_retain(object) ({ dispatch_object_t _o = (object); _dispatch_object_validate(_o); (void)[_o retain]; }); /// #define dispatch_release(object) ({ dispatch_object_t _o = (object); _dispatch_object_validate(_o); [_o release]; }); /// #define xpc_retain(object) ({ xpc_object_t _o = (object); _xpc_object_validate(_o); [_o retain]; }); /// #define xpc_release(object) ({ xpc_object_t _o = (object); _xpc_object_validate(_o); [_o release]; }); ///; /// and return the top container which is the StmtExpr and the macro argument; /// expression.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/ARCMigrate/TransRetainReleaseDealloc.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/ARCMigrate/TransRetainReleaseDealloc.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/ARCMigrate/TransUnbridgedCasts.cpp:383,Modifiability,rewrite,rewriteUnbridgedCasts,383,"//===--- TransUnbridgedCasts.cpp - Transformations to ARC mode ------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // rewriteUnbridgedCasts:; //; // A cast of non-objc pointer to an objc one is checked. If the non-objc pointer; // is from a file-level variable, __bridge cast is used to convert it.; // For the result of a function call that we know is +1/+0,; // __bridge/CFBridgingRelease is used.; //; // NSString *str = (NSString *)kUTTypePlainText;; // str = b ? kUTTypeRTF : kUTTypePlainText;; // NSString *_uuidString = (NSString *)CFUUIDCreateString(kCFAllocatorDefault,; // _uuid);; // ---->; // NSString *str = (__bridge NSString *)kUTTypePlainText;; // str = (__bridge NSString *)(b ? kUTTypeRTF : kUTTypePlainText);; // NSString *_uuidString = (NSString *); // CFBridgingRelease(CFUUIDCreateString(kCFAllocatorDefault, _uuid));; //; // For a C pointer to ObjC, for casting 'self', __bridge is used.; //; // CFStringRef str = (CFStringRef)self;; // ---->; // CFStringRef str = (__bridge CFStringRef)self;; //; // Uses of Block_copy/Block_release macros are rewritten:; //; // c = Block_copy(b);; // Block_release(c);; // ---->; // c = [b copy];; // <removed>; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/ARCMigrate/TransUnbridgedCasts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/ARCMigrate/TransUnbridgedCasts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/ARCMigrate/TransUnbridgedCasts.cpp:517,Modifiability,variab,variable,517,"//===--- TransUnbridgedCasts.cpp - Transformations to ARC mode ------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // rewriteUnbridgedCasts:; //; // A cast of non-objc pointer to an objc one is checked. If the non-objc pointer; // is from a file-level variable, __bridge cast is used to convert it.; // For the result of a function call that we know is +1/+0,; // __bridge/CFBridgingRelease is used.; //; // NSString *str = (NSString *)kUTTypePlainText;; // str = b ? kUTTypeRTF : kUTTypePlainText;; // NSString *_uuidString = (NSString *)CFUUIDCreateString(kCFAllocatorDefault,; // _uuid);; // ---->; // NSString *str = (__bridge NSString *)kUTTypePlainText;; // str = (__bridge NSString *)(b ? kUTTypeRTF : kUTTypePlainText);; // NSString *_uuidString = (NSString *); // CFBridgingRelease(CFUUIDCreateString(kCFAllocatorDefault, _uuid));; //; // For a C pointer to ObjC, for casting 'self', __bridge is used.; //; // CFStringRef str = (CFStringRef)self;; // ---->; // CFStringRef str = (__bridge CFStringRef)self;; //; // Uses of Block_copy/Block_release macros are rewritten:; //; // c = Block_copy(b);; // Block_release(c);; // ---->; // c = [b copy];; // <removed>; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/ARCMigrate/TransUnbridgedCasts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/ARCMigrate/TransUnbridgedCasts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/ARCMigrate/TransUnbridgedCasts.cpp:108,Availability,error,error,108,// Do not migrate to couple of bridge transfer casts which; // cancel each other out. Leave it unchanged so error gets user; // attention instead.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/ARCMigrate/TransUnbridgedCasts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/ARCMigrate/TransUnbridgedCasts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/ARCMigrate/TransUnbridgedCasts.cpp:31,Integrability,bridg,bridge,31,// Do not migrate to couple of bridge transfer casts which; // cancel each other out. Leave it unchanged so error gets user; // attention instead.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/ARCMigrate/TransUnbridgedCasts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/ARCMigrate/TransUnbridgedCasts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/ARCMigrate/TransUnusedInitDelegate.cpp:486,Modifiability,rewrite,rewriteUnusedInitDelegate,486,"//===--- TransUnusedInitDelegate.cpp - Transformations to ARC mode --------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; // Transformations:; //===----------------------------------------------------------------------===//; //; // rewriteUnusedInitDelegate:; //; // Rewrites an unused result of calling a delegate initialization, to assigning; // the result to self.; // e.g; // [self init];; // ---->; // self = [self init];; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/ARCMigrate/TransUnusedInitDelegate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/ARCMigrate/TransUnusedInitDelegate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/ARCMigrate/TransUnusedInitDelegate.cpp:521,Modifiability,Rewrite,Rewrites,521,"//===--- TransUnusedInitDelegate.cpp - Transformations to ARC mode --------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; // Transformations:; //===----------------------------------------------------------------------===//; //; // rewriteUnusedInitDelegate:; //; // Rewrites an unused result of calling a delegate initialization, to assigning; // the result to self.; // e.g; // [self init];; // ---->; // self = [self init];; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/ARCMigrate/TransUnusedInitDelegate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/ARCMigrate/TransUnusedInitDelegate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/ARCMigrate/TransZeroOutPropsInDealloc.cpp:21,Integrability,message,message,21,// Remove the setter message if RHS is null,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/ARCMigrate/TransZeroOutPropsInDealloc.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/ARCMigrate/TransZeroOutPropsInDealloc.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/ARCMigrate/TransZeroOutPropsInDealloc.cpp:3,Usability,clear,clear,3,// clear out for next method.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/ARCMigrate/TransZeroOutPropsInDealloc.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/ARCMigrate/TransZeroOutPropsInDealloc.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/APValue.cpp:39,Integrability,depend,depends,39,/// The identity of a type_info object depends on the canonical unqualified; /// type only.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/APValue.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/APValue.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/APValue.cpp:122,Performance,perform,performing,122,"/// Path - The sequence of base classes, fields and array indices to follow to; /// walk from Base to the subobject. When performing GCC-style folding, there; /// may not be such a path.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/APValue.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/APValue.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/APValue.cpp:10,Energy Efficiency,Reduce,Reduce,10,// FIXME: Reduce the malloc traffic here.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/APValue.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/APValue.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/APValue.cpp:26,Integrability,depend,depend,26,"// The profile should not depend on whether the array is expanded or; // not, but we don't want to profile the array filler many times for; // a large array. So treat all equal trailing elements as the filler.; // Elements are profiled in reverse order to support this, and the; // first profiled element is followed by a count. For example:; //; // ['a', 'c', 'x', 'x', 'x'] is profiled as; // [5, 'x', 3, 'c', 'a']",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/APValue.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/APValue.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/APValue.cpp:18,Integrability,message,message,18,// The diagnostic message is 'quoted',MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/APValue.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/APValue.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/APValue.cpp:84,Modifiability,inherit,inheritance,84,// FIXME: This is not enough to unambiguously identify the member in a; // multiple-inheritance scenario.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/APValue.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/APValue.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/APValue.cpp:75,Modifiability,extend,extended,75,"// Almost all expression bases are internal. The exception is; // lifetime-extended temporaries.; // FIXME: These should be modeled as having the; // LifetimeExtendedTemporaryDecl itself as the base.; // FIXME: If we permit Objective-C object literals in template arguments,; // they should not imply internal linkage.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/APValue.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/APValue.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTConsumer.cpp:36,Integrability,interface,interface,36,"//===--- ASTConsumer.cpp - Abstract interface for reading ASTs --*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file defines the ASTConsumer class.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ASTConsumer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTConsumer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTContext.cpp:419,Integrability,interface,interface,419,"//===- ASTContext.cpp - Context to hold long-lived AST nodes --------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements the ASTContext interface.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ASTContext.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTContext.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTContext.cpp:3,Deployability,Release,Release,3,// Release the DenseMaps associated with DeclContext objects.; // FIXME: Is this the ideal solution?,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ASTContext.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTContext.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTContext.cpp:138,Usability,simpl,simplify,138,"// One special case: if we add a module initializer that imports another; // module, and that module's only initializer is an ImportDecl, simplify.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ASTContext.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTContext.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTContext.cpp:20,Modifiability,extend,extended,20,// __ibm128 for IBM extended precision,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ASTContext.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTContext.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTContext.cpp:218,Availability,failure,failures,218,"// Placeholder type for type-dependent expressions whose type is; // completely unknown. No code should ever check a type against; // DependentTy and users should never see it; however, it is here to; // help diagnose failures to properly check for type-dependent; // expressions.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ASTContext.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTContext.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTContext.cpp:29,Integrability,depend,dependent,29,"// Placeholder type for type-dependent expressions whose type is; // completely unknown. No code should ever check a type against; // DependentTy and users should never see it; however, it is here to; // help diagnose failures to properly check for type-dependent; // expressions.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ASTContext.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTContext.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTContext.cpp:134,Integrability,Depend,DependentTy,134,"// Placeholder type for type-dependent expressions whose type is; // completely unknown. No code should ever check a type against; // DependentTy and users should never see it; however, it is here to; // help diagnose failures to properly check for type-dependent; // expressions.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ASTContext.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTContext.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTContext.cpp:254,Integrability,depend,dependent,254,"// Placeholder type for type-dependent expressions whose type is; // completely unknown. No code should ever check a type against; // DependentTy and users should never see it; however, it is here to; // help diagnose failures to properly check for type-dependent; // expressions.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ASTContext.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTContext.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTContext.cpp:196,Availability,error,error,196,"// __attribute__((aligned)) can increase or decrease alignment; // *except* on a struct or struct member, where it only increases; // alignment unless 'packed' is also specified.; //; // It is an error for alignas to decrease alignment, so we can; // ignore that possibility; Sema should diagnose it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ASTContext.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTContext.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTContext.cpp:39,Modifiability,variab,variables,39,// Ensure miminum alignment for global variables.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ASTContext.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTContext.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTContext.cpp:25,Energy Efficiency,power,power,25,"// Alignment is always a power of 2, so the GCD will be a power of 2,; // which means we get to do this crazy thing instead of Euclid's.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ASTContext.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTContext.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTContext.cpp:58,Energy Efficiency,power,power,58,"// Alignment is always a power of 2, so the GCD will be a power of 2,; // which means we get to do this crazy thing instead of Euclid's.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ASTContext.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTContext.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTContext.cpp:110,Modifiability,variab,variables,110,// Some targets have hard limitation on the maximum requestable alignment in; // aligned attribute for static variables.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ASTContext.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTContext.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTContext.cpp:167,Performance,perform,performed,167,"// getTypeInfoDataSizeInChars - Return the size of a type, in; // chars. If the type is a record, its data size is returned. This is; // the size of the memcpy that's performed when assigning this type; // using a trivial copy/move assignment operator.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ASTContext.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTContext.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTContext.cpp:36,Energy Efficiency,allocate,allocated,36,"// In C++, objects can sometimes be allocated into the tail padding; // of a base-class subobject. We decide whether that's possible; // during class layout, so here we can just trust the layout results.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ASTContext.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTContext.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTContext.cpp:34,Performance,Perform,Performing,34,/// getConstantArrayInfoInChars - Performing the computation in CharUnits; /// instead of in bits prevents overflowing the uint64_t for some large arrays.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ASTContext.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTContext.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTContext.cpp:29,Energy Efficiency,power,power,29,"// If the alignment is not a power of 2, round up to the next power of 2.; // This happens for non-power-of-2 length vectors.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ASTContext.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTContext.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTContext.cpp:62,Energy Efficiency,power,power,62,"// If the alignment is not a power of 2, round up to the next power of 2.; // This happens for non-power-of-2 length vectors.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ASTContext.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTContext.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTContext.cpp:99,Energy Efficiency,power,power-of-,99,"// If the alignment is not a power of 2, round up to the next power of 2.; // This happens for non-power-of-2 length vectors.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ASTContext.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTContext.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTContext.cpp:84,Energy Efficiency,power,power-of-,84,// Adjust the alignment for fixed-length SVE vectors. This is important; // for non-power-of-2 vector lengths.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ASTContext.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTContext.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTContext.cpp:87,Integrability,rout,route,87,"// alignof and sizeof should never enter this code path here, so we go; // the pointer route.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ASTContext.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTContext.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTContext.cpp:185,Energy Efficiency,power,power,185,"// If the size of the type doesn't exceed the platform's max; // atomic promotion width, make the size and alignment more; // favorable to atomic operations:; // Round the size up to a power of 2.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ASTContext.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTContext.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTContext.cpp:206,Performance,perform,performance,206,"/// getPreferredTypeAlign - Return the ""preferred"" alignment of the specified; /// type for the current target in bits. This can be different than the ABI; /// alignment in cases where it is beneficial for performance or backwards; /// compatibility preserving to overalign a data type. (Note: despite the name,; /// the preferred alignment is ABI-impacting, and not an optimization.)",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ASTContext.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTContext.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTContext.cpp:370,Performance,optimiz,optimization,370,"/// getPreferredTypeAlign - Return the ""preferred"" alignment of the specified; /// type for the current target in bits. This can be different than the ABI; /// alignment in cases where it is beneficial for performance or backwards; /// compatibility preserving to overalign a data type. (Note: despite the name,; /// the preferred alignment is ABI-impacting, and not an optimization.)",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ASTContext.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTContext.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTContext.cpp:44,Energy Efficiency,power,power,44,"// Double (and, for targets supporting AIX `power` alignment, long double) and; // long long should be naturally aligned (despite requiring less alignment) if; // possible.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ASTContext.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTContext.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTContext.cpp:93,Modifiability,variab,variable,93,/// getAlignOfGlobalVar - Return the alignment in bits that should be given; /// to a global variable of the specified type.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ASTContext.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTContext.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTContext.cpp:106,Modifiability,variab,variable,106,/// getAlignOfGlobalVarInChars - Return the alignment in characters that; /// should be given to a global variable of the specified type.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ASTContext.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTContext.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTContext.cpp:37,Integrability,rout,routine,37,"/// DeepCollectObjCIvars -; /// This routine first collects all declared, but not synthesized, ivars in; /// super class and then collects all ivars, including those synthesized for; /// current class. This routine is used for implementation of current class; /// when all ivars, declared and synthesized are known.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ASTContext.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTContext.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTContext.cpp:207,Integrability,rout,routine,207,"/// DeepCollectObjCIvars -; /// This routine first collects all declared, but not synthesized, ivars in; /// super class and then collects all ivars, including those synthesized for; /// current class. This routine is used for implementation of current class; /// when all ivars, declared and synthesized are known.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ASTContext.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTContext.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTContext.cpp:44,Integrability,protocol,protocols,44,/// CollectInheritedProtocols - Collect all protocols in current class and; /// those inherited by it.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ASTContext.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTContext.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTContext.cpp:86,Modifiability,inherit,inherited,86,/// CollectInheritedProtocols - Collect all protocols in current class and; /// those inherited by it.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ASTContext.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTContext.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTContext.cpp:22,Integrability,Interface,Interface,22,// Categories of this Interface.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ASTContext.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTContext.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTContext.cpp:14,Integrability,protocol,protocol,14,// Insert the protocol.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ASTContext.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTContext.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTContext.cpp:130,Availability,error,error,130,"// Empty types can be inherited from, and non-empty types can potentially; // have tail padding, so just make sure there isn't an error.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ASTContext.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTContext.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTContext.cpp:22,Modifiability,inherit,inherited,22,"// Empty types can be inherited from, and non-empty types can potentially; // have tail padding, so just make sure there isn't an error.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ASTContext.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTContext.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTContext.cpp:23,Modifiability,extend,extended,23,"// If we are composing extended qualifiers together, merge together; // into one ExtQuals node.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ASTContext.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTContext.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTContext.cpp:23,Modifiability,extend,extended,23,"// If we are composing extended qualifiers together, merge together; // into one ExtQuals node.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ASTContext.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTContext.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTContext.cpp:133,Testability,assert,asserts,133,"// Removal of the address space can mean there are no longer any; // non-fast qualifiers, so creating an ExtQualType isn't possible (asserts); // or required.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ASTContext.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTContext.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTContext.cpp:23,Modifiability,extend,extended,23,"// If we are composing extended qualifiers together, merge together; // into one ExtQuals node.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ASTContext.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTContext.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTContext.cpp:12,Integrability,wrap,wrapped,12,// Might be wrapped in a macro qualified type.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ASTContext.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTContext.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTContext.cpp:3,Deployability,Update,Update,3,// Update the type.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ASTContext.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTContext.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTContext.cpp:3,Deployability,Update,Update,3,// Update the type in the type source information too.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ASTContext.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTContext.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTContext.cpp:62,Deployability,update,update,62,"// If the type and the type-as-written differ, we may need to update; // the type-as-written too.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ASTContext.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTContext.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTContext.cpp:139,Deployability,patch,patch,139,"// FIXME: When we get proper type location information for exceptions,; // we'll also have to rebuild the TypeSourceInfo. For now, we just patch; // up the TypeSourceInfo;",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ASTContext.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTContext.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTContext.cpp:67,Integrability,depend,dependent,67,// We only need the size as part of the type if it's instantiation-dependent.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ASTContext.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTContext.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTContext.cpp:98,Integrability,depend,dependent,98,"// If the element type isn't canonical or has qualifiers, or the array bound; // is instantiation-dependent, this won't be a canonical type either, so fill; // in the canonical type field.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ASTContext.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTContext.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTContext.cpp:74,Modifiability,variab,variably-modified,74,"/// getVariableArrayDecayedType - Turns the given type, which may be; /// variably-modified, into the corresponding type with all the known; /// sizes replaced with [*].",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ASTContext.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTContext.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTContext.cpp:31,Modifiability,variab,variably-modified,31,// These types should never be variably-modified.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ASTContext.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTContext.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTContext.cpp:22,Modifiability,variab,variably-modified,22,// These types can be variably-modified but should never need to; // further decay.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ASTContext.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTContext.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTContext.cpp:200,Availability,avail,available,200,"// These types can be variably-modified. All these modifications; // preserve structure except as noted by comments.; // TODO: if we ever care about optimizing VLAs, there are no-op; // optimizations available here.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ASTContext.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTContext.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTContext.cpp:22,Modifiability,variab,variably-modified,22,"// These types can be variably-modified. All these modifications; // preserve structure except as noted by comments.; // TODO: if we ever care about optimizing VLAs, there are no-op; // optimizations available here.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ASTContext.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTContext.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTContext.cpp:149,Performance,optimiz,optimizing,149,"// These types can be variably-modified. All these modifications; // preserve structure except as noted by comments.; // TODO: if we ever care about optimizing VLAs, there are no-op; // optimizations available here.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ASTContext.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTContext.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTContext.cpp:186,Performance,optimiz,optimizations,186,"// These types can be variably-modified. All these modifications; // preserve structure except as noted by comments.; // TODO: if we ever care about optimizing VLAs, there are no-op; // optimizations available here.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ASTContext.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTContext.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTContext.cpp:81,Modifiability,variab,variable,81,/// getVariableArrayType - Returns a non-unique reference to the type for a; /// variable array of the specified element type.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ASTContext.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTContext.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTContext.cpp:87,Integrability,depend,dependently-sized,87,/// getDependentSizedArrayType - Returns a non-unique reference to; /// the type for a dependently-sized array of the specified element; /// type.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ASTContext.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTContext.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTContext.cpp:3,Integrability,Depend,Dependently-sized,3,"// Dependently-sized array types that do not have a specified number; // of elements will have their sizes deduced from a dependent; // initializer. We do no canonicalization here at all, which is okay; // because they can't be used in most locations.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ASTContext.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTContext.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTContext.cpp:122,Integrability,depend,dependent,122,"// Dependently-sized array types that do not have a specified number; // of elements will have their sizes deduced from a dependent; // initializer. We do no canonicalization here at all, which is okay; // because they can't be used in most locations.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ASTContext.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTContext.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTContext.cpp:61,Performance,scalab,scalable,61,/// getScalableVectorType - Return the unique reference to a scalable vector; /// type of the specified element type and size. VectorType must be a built-in; /// type.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ASTContext.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTContext.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTContext.cpp:49,Energy Efficiency,power,power,49,// Only support _BitInt elements with byte-sized power of 2 NumBits.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ASTContext.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTContext.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTContext.cpp:57,Modifiability,extend,extended,57,/// getExtVectorType - Return the unique reference to an extended vector type of; /// the specified element type and size. VectorType must be a built-in type.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ASTContext.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTContext.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTContext.cpp:49,Energy Efficiency,power,power,49,// Only support _BitInt elements with byte-sized power of 2 NumBits.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ASTContext.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTContext.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTContext.cpp:66,Modifiability,rewrite,rewriter,66,"// FIXME: This assertion cannot be enabled (yet) because the ObjC rewriter; // functionality creates a function without a prototype regardless of; // language mode (so it makes them even in C++). Once the rewriter has been; // fixed, this assertion can be enabled again.; //assert(!LangOpts.requiresStrictPrototypes() &&; // ""strict prototypes are disabled"");; // Unique functions, to guarantee there is only one function of a particular; // structure.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ASTContext.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTContext.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTContext.cpp:205,Modifiability,rewrite,rewriter,205,"// FIXME: This assertion cannot be enabled (yet) because the ObjC rewriter; // functionality creates a function without a prototype regardless of; // language mode (so it makes them even in C++). Once the rewriter has been; // fixed, this assertion can be enabled again.; //assert(!LangOpts.requiresStrictPrototypes() &&; // ""strict prototypes are disabled"");; // Unique functions, to guarantee there is only one function of a particular; // structure.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ASTContext.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTContext.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTContext.cpp:15,Testability,assert,assertion,15,"// FIXME: This assertion cannot be enabled (yet) because the ObjC rewriter; // functionality creates a function without a prototype regardless of; // language mode (so it makes them even in C++). Once the rewriter has been; // fixed, this assertion can be enabled again.; //assert(!LangOpts.requiresStrictPrototypes() &&; // ""strict prototypes are disabled"");; // Unique functions, to guarantee there is only one function of a particular; // structure.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ASTContext.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTContext.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTContext.cpp:239,Testability,assert,assertion,239,"// FIXME: This assertion cannot be enabled (yet) because the ObjC rewriter; // functionality creates a function without a prototype regardless of; // language mode (so it makes them even in C++). Once the rewriter has been; // fixed, this assertion can be enabled again.; //assert(!LangOpts.requiresStrictPrototypes() &&; // ""strict prototypes are disabled"");; // Unique functions, to guarantee there is only one function of a particular; // structure.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ASTContext.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTContext.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTContext.cpp:274,Testability,assert,assert,274,"// FIXME: This assertion cannot be enabled (yet) because the ObjC rewriter; // functionality creates a function without a prototype regardless of; // language mode (so it makes them even in C++). Once the rewriter has been; // fixed, this assertion can be enabled again.; //assert(!LangOpts.requiresStrictPrototypes() &&; // ""strict prototypes are disabled"");; // Unique functions, to guarantee there is only one function of a particular; // structure.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ASTContext.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTContext.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTContext.cpp:68,Usability,simpl,simple,68,"// C++17 onwards: exception specification is part of the type, as a simple; // boolean ""can this function type throw"".",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ASTContext.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTContext.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTContext.cpp:79,Integrability,depend,dependent,79,// A noexcept(expr) specification is (possibly) canonical if expr is; // value-dependent.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ASTContext.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTContext.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTContext.cpp:141,Integrability,depend,dependent,141,"// If we find a pre-existing equivalent FunctionProtoType, we can just reuse; // it so long as our exception specification doesn't contain a dependent; // noexcept expression, or we're just looking for a canonical type.; // Otherwise, we're going to need to create a type; // sugar node to hold the concrete expression.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ASTContext.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTContext.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTContext.cpp:71,Integrability,inject,injected,71,/// getInjectedClassNameType - Return the unique reference to the; /// injected class name type for the specified templated declaration.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ASTContext.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTContext.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTContext.cpp:71,Security,inject,injected,71,/// getInjectedClassNameType - Return the unique reference to the; /// injected class name type for the specified templated declaration.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ASTContext.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTContext.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTContext.cpp:3,Energy Efficiency,Allocate,Allocate,3,"// Allocate the (non-canonical) template specialization type, but don't; // try to unique it: these types typically have location information that; // we don't unique and don't want to lose.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ASTContext.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTContext.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTContext.cpp:3,Energy Efficiency,Allocate,Allocate,3,// Allocate a new canonical template specialization type.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ASTContext.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTContext.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTContext.cpp:9,Safety,avoid,avoid,9,// TODO: avoid this copy,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ASTContext.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTContext.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTContext.cpp:56,Integrability,protocol,protocols,56,/// CmpProtocolNames - Comparison predicate for sorting protocols; /// alphabetically.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ASTContext.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTContext.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTContext.cpp:8,Integrability,protocol,protocols,8,"// Sort protocols, keyed by name.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ASTContext.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTContext.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTContext.cpp:26,Integrability,interface,interface,26,"// If the base type is an interface and there aren't any protocols or; // type arguments to add, then the interface type will do just fine.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ASTContext.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTContext.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTContext.cpp:57,Integrability,protocol,protocols,57,"// If the base type is an interface and there aren't any protocols or; // type arguments to add, then the interface type will do just fine.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ASTContext.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTContext.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTContext.cpp:106,Integrability,interface,interface,106,"// If the base type is an interface and there aren't any protocols or; // type arguments to add, then the interface type will do just fine.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ASTContext.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTContext.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTContext.cpp:100,Integrability,protocol,protocols,100,"// Build the canonical type, which has the canonical base type and a; // sorted-and-uniqued list of protocols and the type arguments; // canonicalized.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ASTContext.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTContext.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTContext.cpp:22,Integrability,protocol,protocol,22,"/// Apply Objective-C protocol qualifiers to the given type.; /// If this is for the canonical type of a type parameter, we can apply; /// protocol qualifiers on the ObjCObjectPointerType.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ASTContext.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTContext.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTContext.cpp:139,Integrability,protocol,protocol,139,"/// Apply Objective-C protocol qualifiers to the given type.; /// If this is for the canonical type of a type parameter, we can apply; /// protocol qualifiers on the ObjCObjectPointerType.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ASTContext.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTContext.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTContext.cpp:9,Integrability,protocol,protocol,9,// Apply protocol qualifiers to ObjCObjectPointerType.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ASTContext.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTContext.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTContext.cpp:9,Integrability,protocol,protocol,9,// Merge protocol lists and construct ObjCObjectType.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ASTContext.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTContext.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTContext.cpp:9,Integrability,protocol,protocol,9,// Apply protocol qualifiers to ObjCObjectType.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ASTContext.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTContext.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTContext.cpp:20,Integrability,protocol,protocols,20,// FIXME: Check for protocols to which the class type is already; // known to conform.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ASTContext.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTContext.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTContext.cpp:35,Integrability,protocol,protocol,35,// Silently overwrite any existing protocol qualifiers.; // TODO: determine whether that's the right thing to do.; // FIXME: Check for protocols to which the class type is already; // known to conform.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ASTContext.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTContext.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTContext.cpp:135,Integrability,protocol,protocols,135,// Silently overwrite any existing protocol qualifiers.; // TODO: determine whether that's the right thing to do.; // FIXME: Check for protocols to which the class type is already; // known to conform.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ASTContext.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTContext.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTContext.cpp:6,Integrability,protocol,protocol-list,6,// id<protocol-list>,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ASTContext.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTContext.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTContext.cpp:9,Integrability,protocol,protocol-list,9,// Class<protocol-list>,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ASTContext.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTContext.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTContext.cpp:13,Integrability,protocol,protocol,13,// Apply the protocol qualifers.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ASTContext.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTContext.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTContext.cpp:3,Deployability,Update,Update,3,// Update TypeForDecl after updating TypeSourceInfo.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ASTContext.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTContext.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTContext.cpp:49,Integrability,protocol,protocols,49,/// ObjCObjectAdoptsQTypeProtocols - Checks that protocols in IC's; /// protocol list adopt all protocols in QT's qualified-id protocol; /// list.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ASTContext.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTContext.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTContext.cpp:72,Integrability,protocol,protocol,72,/// ObjCObjectAdoptsQTypeProtocols - Checks that protocols in IC's; /// protocol list adopt all protocols in QT's qualified-id protocol; /// list.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ASTContext.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTContext.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTContext.cpp:96,Integrability,protocol,protocols,96,/// ObjCObjectAdoptsQTypeProtocols - Checks that protocols in IC's; /// protocol list adopt all protocols in QT's qualified-id protocol; /// list.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ASTContext.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTContext.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTContext.cpp:127,Integrability,protocol,protocol,127,/// ObjCObjectAdoptsQTypeProtocols - Checks that protocols in IC's; /// protocol list adopt all protocols in QT's qualified-id protocol; /// list.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ASTContext.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTContext.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTContext.cpp:55,Integrability,protocol,protocols,55,/// QIdProtocolsAdoptObjCObjectProtocols - Checks that protocols in; /// QT's qualified-id protocol list adopt all protocols in IDecl's list; /// of protocols.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ASTContext.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTContext.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTContext.cpp:91,Integrability,protocol,protocol,91,/// QIdProtocolsAdoptObjCObjectProtocols - Checks that protocols in; /// QT's qualified-id protocol list adopt all protocols in IDecl's list; /// of protocols.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ASTContext.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTContext.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTContext.cpp:115,Integrability,protocol,protocols,115,/// QIdProtocolsAdoptObjCObjectProtocols - Checks that protocols in; /// QT's qualified-id protocol list adopt all protocols in IDecl's list; /// of protocols.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ASTContext.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTContext.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTContext.cpp:149,Integrability,protocol,protocols,149,/// QIdProtocolsAdoptObjCObjectProtocols - Checks that protocols in; /// QT's qualified-id protocol list adopt all protocols in IDecl's list; /// of protocols.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ASTContext.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTContext.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTContext.cpp:23,Integrability,protocol,protocol,23,"// Check that if every protocol in list of id<plist> conforms to a protocol; // of IDecl's, then bridge casting is ok.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ASTContext.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTContext.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTContext.cpp:67,Integrability,protocol,protocol,67,"// Check that if every protocol in list of id<plist> conforms to a protocol; // of IDecl's, then bridge casting is ok.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ASTContext.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTContext.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTContext.cpp:97,Integrability,bridg,bridge,97,"// Check that if every protocol in list of id<plist> conforms to a protocol; // of IDecl's, then bridge casting is ok.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ASTContext.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTContext.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTContext.cpp:35,Modifiability,inherit,inheritance,35,// return 'true' if 'PI' is in the inheritance hierarchy of Proto,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ASTContext.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTContext.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTContext.cpp:95,Integrability,interface,interface,95,/// getObjCInterfaceType - Return the unique reference to the type for the; /// specified ObjC interface decl. The list of protocols is optional.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ASTContext.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTContext.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTContext.cpp:123,Integrability,protocol,protocols,123,/// getObjCInterfaceType - Return the unique reference to the type for the; /// specified ObjC interface decl. The list of protocols is optional.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ASTContext.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTContext.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTContext.cpp:58,Integrability,depend,dependent,58,"// We already have a ""canonical"" version of an identical, dependent; // typeof(expr) type. Use that as our canonical type.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ASTContext.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTContext.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTContext.cpp:176,Security,access,access,176,"/// getReferenceQualifiedType - Given an expr, will return the type for; /// that expression, as in [dcl.type.simple]p4 but without taking id-expressions; /// and class member access into account.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ASTContext.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTContext.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTContext.cpp:110,Usability,simpl,simple,110,"/// getReferenceQualifiedType - Given an expr, will return the type for; /// that expression, as in [dcl.type.simple]p4 but without taking id-expressions; /// and class member access into account.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ASTContext.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTContext.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTContext.cpp:19,Usability,simpl,simple,19,// C++11 [dcl.type.simple]p4:; // [...],MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ASTContext.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTContext.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTContext.cpp:111,Integrability,depend,dependent,111,"// C++11 [temp.type]p2:; // If an expression e involves a template parameter, decltype(e) denotes a; // unique dependent type. Two such decltype-specifiers refer to the same; // type only if their expressions are equivalent (14.5.6.1).",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ASTContext.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTContext.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTContext.cpp:190,Integrability,depend,dependent,190,"/// getAutoType - Return the uniqued reference to the 'auto' type which has been; /// deduced to the given type, or to the canonical undeduced 'auto' type, or the; /// canonical deduced-but-dependent 'auto' type.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ASTContext.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTContext.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTContext.cpp:199,Integrability,depend,dependent,199,"/// Return the uniqued reference to the deduced template specialization type; /// which has been deduced to the given type, or to the canonical undeduced; /// such type, or the canonical deduced-but-dependent such type.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ASTContext.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTContext.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTContext.cpp:142,Integrability,depend,dependent,142,"/// getSizeType - Return the unique type for ""size_t"" (C99 7.17), the result; /// of the sizeof operator (C99 6.5.3.4p4). The value is target dependent and; /// needs to agree with the definition in <stddef.h>.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ASTContext.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTContext.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTContext.cpp:189,Modifiability,layers,layers,189,"/// Attempt to unwrap two types that may be similar (C++ [conv.qual]).; ///; /// If T1 and T2 are both pointer types of the same kind, or both array types; /// with the same bound, unwraps layers from T1 and T2 until a pointer type is; /// unwrapped. Top-level qualifiers on T1 and T2 are ignored.; ///; /// This function will typically be called in a loop that successively; /// ""unwraps"" pointer and pointer-to-member types to compare them at each; /// level.; ///; /// \param AllowPiMismatch Allow the Pi1 and Pi2 to differ as described in; /// C++20 [conv.qual], if permitted by the current language mode.; ///; /// \return \c true if a pointer type was unwrapped, \c false if we reached a; /// pair of types that can't be unwrapped further.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ASTContext.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTContext.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTContext.cpp:165,Safety,avoid,avoided,165,"// Caution: this function is called by the AST reader during deserialization,; // so it cannot rely on AST invariants being met. Non-trivial accessors; // should be avoided, along with any traversal of redeclaration chains.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ASTContext.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTContext.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTContext.cpp:141,Security,access,accessors,141,"// Caution: this function is called by the AST reader during deserialization,; // so it cannot rely on AST invariants being met. Non-trivial accessors; // should be avoided, along with any traversal of redeclaration chains.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ASTContext.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTContext.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTContext.cpp:27,Integrability,protocol,protocols,27,// Objective-C classes and protocols with the same name always match.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ASTContext.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTContext.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTContext.cpp:157,Modifiability,inherit,inherited,157,"// Map to the first declaration that we've already merged into this one.; // The TSI of redeclarations might not match (due to calling conventions; // being inherited onto the type but not the TSI), but the TSI type of; // the first declaration of the function should match across modules.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ASTContext.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTContext.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTContext.cpp:3,Modifiability,Variab,Variables,3,// Variables with the same type and linkage match.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ASTContext.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTContext.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTContext.cpp:44,Modifiability,variab,variables,44,"// During deserialization, we might compare variables before we load; // their types. Assume the types will end up being the same.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ASTContext.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTContext.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTContext.cpp:64,Performance,load,load,64,"// During deserialization, we might compare variables before we load; // their types. Assume the types will end up being the same.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ASTContext.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTContext.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTContext.cpp:27,Integrability,depend,dependent-named,27,"// If we have some kind of dependent-named type (e.g., ""typename T::type""),; // break it apart into its prefix and identifier, then reconsititute those; // as the canonical nested-name-specifier. This is required to canonicalize; // a dependent nested-name-specifier involving typedefs of dependent-name; // types, e.g.,; // typedef typename T::type T1;; // typedef typename T1::type T2;",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ASTContext.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTContext.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTContext.cpp:235,Integrability,depend,dependent,235,"// If we have some kind of dependent-named type (e.g., ""typename T::type""),; // break it apart into its prefix and identifier, then reconsititute those; // as the canonical nested-name-specifier. This is required to canonicalize; // a dependent nested-name-specifier involving typedefs of dependent-name; // types, e.g.,; // typedef typename T::type T1;; // typedef typename T1::type T2;",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ASTContext.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTContext.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTContext.cpp:289,Integrability,depend,dependent-name,289,"// If we have some kind of dependent-named type (e.g., ""typename T::type""),; // break it apart into its prefix and identifier, then reconsititute those; // as the canonical nested-name-specifier. This is required to canonicalize; // a dependent nested-name-specifier involving typedefs of dependent-name; // types, e.g.,; // typedef typename T::type T1;; // typedef typename T1::type T2;",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ASTContext.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTContext.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTContext.cpp:33,Energy Efficiency,efficient,efficiently,33,// Handle the non-qualified case efficiently.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ASTContext.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTContext.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTContext.cpp:407,Availability,down,down,407,"// Apply any qualifiers from the array type to the element type. This; // implements C99 6.7.3p8: ""If the specification of an array type includes; // any type qualifiers, the element type is so qualified, not the array type.""; // If we get here, we either have type qualifiers on the type, or we have; // sugar such as a typedef in the way. If we have type qualifiers on the type; // we must propagate them down into the element type.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ASTContext.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTContext.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTContext.cpp:16,Usability,simpl,simple,16,"// If we have a simple case, just return now.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ASTContext.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTContext.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTContext.cpp:81,Integrability,rout,routine,81,/// getFloatingRank - Return a relative rank for floating point types.; /// This routine will assert if passed a built-in type that isn't a float.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ASTContext.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTContext.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTContext.cpp:94,Testability,assert,assert,94,/// getFloatingRank - Return a relative rank for floating point types.; /// This routine will assert if passed a built-in type that isn't a float.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ASTContext.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTContext.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTContext.cpp:82,Integrability,rout,routine,82,"/// getIntegerRank - Return an integer conversion rank (C99 6.3.1.1p1). This; /// routine will assert if passed a built-in type that isn't an integer or enum,; /// or if it is not canonicalized.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ASTContext.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTContext.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTContext.cpp:95,Testability,assert,assert,95,"/// getIntegerRank - Return an integer conversion rank (C99 6.3.1.1p1). This; /// routine will assert if passed a built-in type that isn't an integer or enum,; /// or if it is not canonicalized.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ASTContext.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTContext.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTContext.cpp:722,Performance,perform,perform,722,"// C++ [conv.prom]p5:; // A prvalue for an integral bit-field can be converted to a prvalue of type; // int if int can represent all the values of the bit-field; otherwise, it; // can be converted to unsigned int if unsigned int can represent all the; // values of the bit-field. If the bit-field is larger yet, no integral; // promotion applies to it.; // C11 6.3.1.1/2:; // [For a bit-field of type _Bool, int, signed int, or unsigned int:]; // If an int can represent all values of the original type (as restricted by; // the width, for a bit-field), the value is converted to an int; otherwise,; // it is converted to an unsigned int.; //; // FIXME: C does not permit promotion of a 'long : 3' bitfield to int.; // We perform that promotion here to match GCC and C++.; // FIXME: C does not permit promotion of an enum bit-field whose rank is; // greater than that of 'int'. We perform that promotion to match GCC.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ASTContext.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTContext.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTContext.cpp:881,Performance,perform,perform,881,"// C++ [conv.prom]p5:; // A prvalue for an integral bit-field can be converted to a prvalue of type; // int if int can represent all the values of the bit-field; otherwise, it; // can be converted to unsigned int if unsigned int can represent all the; // values of the bit-field. If the bit-field is larger yet, no integral; // promotion applies to it.; // C11 6.3.1.1/2:; // [For a bit-field of type _Bool, int, signed int, or unsigned int:]; // If an int can represent all values of the original type (as restricted by; // the width, for a bit-field), the value is converted to an int; otherwise,; // it is converted to an unsigned int.; //; // FIXME: C does not permit promotion of a 'long : 3' bitfield to int.; // We perform that promotion here to match GCC and C++.; // FIXME: C does not permit promotion of an enum bit-field whose rank is; // greater than that of 'int'. We perform that promotion to match GCC.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ASTContext.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTContext.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTContext.cpp:148,Energy Efficiency,power,powers,148,"// If the signed type can represent all values of the unsigned type, it; // wins. Because we are dealing with 2's complement and types that are; // powers of two larger than each other, this is always safe.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ASTContext.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTContext.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTContext.cpp:201,Safety,safe,safe,201,"// If the signed type can represent all values of the unsigned type, it; // wins. Because we are dealing with 2's complement and types that are; // powers of two larger than each other, this is always safe.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ASTContext.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTContext.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTContext.cpp:148,Energy Efficiency,power,powers,148,"// If the signed type can represent all values of the unsigned type, it; // wins. Because we are dealing with 2's complement and types that are; // powers of two larger than each other, this is always safe.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ASTContext.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTContext.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTContext.cpp:201,Safety,safe,safe,201,"// If the signed type can represent all values of the unsigned type, it; // wins. Because we are dealing with 2's complement and types that are; // powers of two larger than each other, this is always safe.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ASTContext.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTContext.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTContext.cpp:128,Integrability,interface,interface,128,"// This type is designed to be compatible with NSConstantString, but cannot; // use the same name, since NSConstantString is an interface.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ASTContext.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTContext.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTContext.cpp:49,Modifiability,variab,variable,49,"/// BlockRequiresCopying - Returns true if byref variable ""D"" of type ""Ty""; /// requires copy/dispose. Note that this must match the logic; /// in buildByrefHelpers.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ASTContext.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTContext.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTContext.cpp:133,Testability,log,logic,133,"/// BlockRequiresCopying - Returns true if byref variable ""D"" of type ""Ty""; /// requires copy/dispose. Note that this must match the logic; /// in buildByrefHelpers.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ASTContext.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTContext.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTContext.cpp:2,Modifiability,Extend,Extended,2,/*Extended*/,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ASTContext.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTContext.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTContext.cpp:2,Modifiability,Extend,Extended,2,/*Extended*/,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ASTContext.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTContext.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTContext.cpp:118,Modifiability,Extend,Extended,118,"/// getObjCEncodingForMethodParameter - Return the encoded type for a single; /// method parameter or return type. If Extended, include class names and; /// block object types.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ASTContext.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTContext.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTContext.cpp:27,Energy Efficiency,efficient,efficient,27,// FIXME: This is not very efficient.; // Encode return type.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ASTContext.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTContext.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTContext.cpp:246,Integrability,protocol,protocol,246,"/// getObjCEncodingForPropertyDecl - Return the encoded type for this; /// property declaration. If non-NULL, Container must be either an; /// ObjCCategoryImplDecl or ObjCImplementationDecl; it should only be; /// NULL when getting encodings for protocol properties.; /// Property attributes are stored as a comma-delimited C string. The simple; /// attributes readonly and bycopy are encoded as single characters. The; /// parametrized attributes, getter=name, setter=name, and ivar=name, are; /// encoded as single characters, followed by an identifier. Property types; /// are also encoded as a parametrized attribute. The characters used to encode; /// these attributes are defined by the following enumeration:; /// @code; /// enum PropertyAttributes {; /// kPropertyReadOnly = 'R', // property is read-only.; /// kPropertyBycopy = 'C', // property is a copy of the value last assigned; /// kPropertyByref = '&', // property is a reference to the value last assigned; /// kPropertyDynamic = 'D', // property is dynamic; /// kPropertyGetter = 'G', // followed by getter selector name; /// kPropertySetter = 'S', // followed by setter selector name; /// kPropertyInstanceVariable = 'V' // followed by instance variable name; /// kPropertyType = 'T' // followed by old-style type encoding.; /// kPropertyWeak = 'W' // 'weak' property; /// kPropertyStrong = 'P' // property GC'able; /// kPropertyNonAtomic = 'N' // property non-atomic; /// kPropertyOptional = '?' // property optional; /// };; /// @endcode",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ASTContext.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTContext.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTContext.cpp:1213,Modifiability,variab,variable,1213,"/// getObjCEncodingForPropertyDecl - Return the encoded type for this; /// property declaration. If non-NULL, Container must be either an; /// ObjCCategoryImplDecl or ObjCImplementationDecl; it should only be; /// NULL when getting encodings for protocol properties.; /// Property attributes are stored as a comma-delimited C string. The simple; /// attributes readonly and bycopy are encoded as single characters. The; /// parametrized attributes, getter=name, setter=name, and ivar=name, are; /// encoded as single characters, followed by an identifier. Property types; /// are also encoded as a parametrized attribute. The characters used to encode; /// these attributes are defined by the following enumeration:; /// @code; /// enum PropertyAttributes {; /// kPropertyReadOnly = 'R', // property is read-only.; /// kPropertyBycopy = 'C', // property is a copy of the value last assigned; /// kPropertyByref = '&', // property is a reference to the value last assigned; /// kPropertyDynamic = 'D', // property is dynamic; /// kPropertyGetter = 'G', // followed by getter selector name; /// kPropertySetter = 'S', // followed by setter selector name; /// kPropertyInstanceVariable = 'V' // followed by instance variable name; /// kPropertyType = 'T' // followed by old-style type encoding.; /// kPropertyWeak = 'W' // 'weak' property; /// kPropertyStrong = 'P' // property GC'able; /// kPropertyNonAtomic = 'N' // property non-atomic; /// kPropertyOptional = '?' // property optional; /// };; /// @endcode",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ASTContext.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTContext.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTContext.cpp:338,Usability,simpl,simple,338,"/// getObjCEncodingForPropertyDecl - Return the encoded type for this; /// property declaration. If non-NULL, Container must be either an; /// ObjCCategoryImplDecl or ObjCImplementationDecl; it should only be; /// NULL when getting encodings for protocol properties.; /// Property attributes are stored as a comma-delimited C string. The simple; /// attributes readonly and bycopy are encoded as single characters. The; /// parametrized attributes, getter=name, setter=name, and ivar=name, are; /// encoded as single characters, followed by an identifier. Property types; /// are also encoded as a parametrized attribute. The characters used to encode; /// these attributes are defined by the following enumeration:; /// @code; /// enum PropertyAttributes {; /// kPropertyReadOnly = 'R', // property is read-only.; /// kPropertyBycopy = 'C', // property is a copy of the value last assigned; /// kPropertyByref = '&', // property is a reference to the value last assigned; /// kPropertyDynamic = 'D', // property is dynamic; /// kPropertyGetter = 'G', // followed by getter selector name; /// kPropertySetter = 'S', // followed by setter selector name; /// kPropertyInstanceVariable = 'V' // followed by instance variable name; /// kPropertyType = 'T' // followed by old-style type encoding.; /// kPropertyWeak = 'W' // 'weak' property; /// kPropertyStrong = 'P' // property GC'able; /// kPropertyNonAtomic = 'N' // property non-atomic; /// kPropertyOptional = '?' // property optional; /// };; /// @endcode",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ASTContext.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTContext.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTContext.cpp:27,Energy Efficiency,efficient,efficient,27,// FIXME: This is not very efficient.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ASTContext.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTContext.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTContext.cpp:19,Usability,clear,clear,19,"// It really isn't clear at all what this means, since properties; // are ""dynamic by default"".",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ASTContext.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTContext.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTContext.cpp:115,Modifiability,Rewrite,Rewrite,115,"// Another legacy compatibility encoding. Some ObjC qualifier and type; // combinations need to be rearranged.; // Rewrite ""in const"" from ""nr"" to ""rn""",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ASTContext.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTContext.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTContext.cpp:2,Modifiability,Variab,Variable,2,//Variable length arrays are encoded as a regular array with 0 elements.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ASTContext.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTContext.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTContext.cpp:10,Integrability,protocol,protocol,10,// Ignore protocol qualifiers when mangling at this level.; // @encode(class_name),MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ASTContext.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTContext.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTContext.cpp:40,Integrability,protocol,protocol,40,// Note that we do extended encoding of protocol qualifier list; // Only when doing ivar or property encoding.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ASTContext.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTContext.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTContext.cpp:19,Modifiability,extend,extended,19,// Note that we do extended encoding of protocol qualifier list; // Only when doing ivar or property encoding.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ASTContext.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTContext.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTContext.cpp:95,Availability,avail,available,95,// gcc just blithely ignores member pointers.; // FIXME: we should do better than that. 'M' is available.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ASTContext.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTContext.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTContext.cpp:51,Availability,error,error,51,// We could see an undeduced auto type here during error recovery.; // Just ignore it.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ASTContext.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTContext.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTContext.cpp:57,Availability,recover,recovery,57,// We could see an undeduced auto type here during error recovery.; // Just ignore it.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ASTContext.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTContext.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTContext.cpp:57,Safety,recover,recovery,57,// We could see an undeduced auto type here during error recovery.; // Just ignore it.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ASTContext.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTContext.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTContext.cpp:49,Integrability,depend,dependent,49,/// Retrieve the template name that represents a dependent; /// template name such as \c MetaFun::template apply.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ASTContext.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTContext.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTContext.cpp:49,Integrability,depend,dependent,49,/// Retrieve the template name that represents a dependent; /// template name such as \c MetaFun::template operator+.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ASTContext.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTContext.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTContext.cpp:104,Testability,Test,Testing,104,//===----------------------------------------------------------------------===//; // Type Compatibility Testing; //===----------------------------------------------------------------------===//; /// areCompatVectorTypes - Return true if the two specified vector types are; /// compatible.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ASTContext.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTContext.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTContext.cpp:250,Integrability,Protocol,ProtocolCompatibleWithProtocol,250,//===----------------------------------------------------------------------===//; // ObjCQualifiedIdTypesAreCompatible - Compatibility testing for qualified id's.; //===----------------------------------------------------------------------===//; /// ProtocolCompatibleWithProtocol - return 'true' if 'lProto' is in the; /// inheritance hierarchy of 'rProto'.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ASTContext.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTContext.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTContext.cpp:324,Modifiability,inherit,inheritance,324,//===----------------------------------------------------------------------===//; // ObjCQualifiedIdTypesAreCompatible - Compatibility testing for qualified id's.; //===----------------------------------------------------------------------===//; /// ProtocolCompatibleWithProtocol - return 'true' if 'lProto' is in the; /// inheritance hierarchy of 'rProto'.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ASTContext.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTContext.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTContext.cpp:135,Testability,test,testing,135,//===----------------------------------------------------------------------===//; // ObjCQualifiedIdTypesAreCompatible - Compatibility testing for qualified id's.; //===----------------------------------------------------------------------===//; /// ProtocolCompatibleWithProtocol - return 'true' if 'lProto' is in the; /// inheritance hierarchy of 'rProto'.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ASTContext.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTContext.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTContext.cpp:31,Integrability,interface,interface,31,"// If the RHS is a unqualified interface pointer ""NSString*"",; // make sure we check the class hierarchy.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ASTContext.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTContext.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTContext.cpp:108,Integrability,protocol,protocols,108,"// when comparing an id<P> on lhs with a static type on rhs,; // see if static class implements all of id's protocols, directly or; // through its super class and categories.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ASTContext.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTContext.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTContext.cpp:37,Integrability,interface,interface,37,"// If there are no qualifiers and no interface, we have an 'id'.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ASTContext.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTContext.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTContext.cpp:108,Integrability,protocol,protocols,108,"// when comparing an id<P> on lhs with a static type on rhs,; // see if static class implements all of id's protocols, directly or; // through its super class and categories.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ASTContext.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTContext.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTContext.cpp:29,Integrability,interface,interface,29,"// If the RHS is a qualified interface pointer ""NSString<P>*"",; // make sure we check the class hierarchy.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ASTContext.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTContext.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTContext.cpp:108,Integrability,protocol,protocols,108,"// when comparing an id<P> on lhs with a static type on rhs,; // see if static class implements all of id's protocols, directly or; // through its super class and categories.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ASTContext.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTContext.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTContext.cpp:108,Integrability,protocol,protocols,108,"// when comparing an id<P> on rhs with a static type on lhs,; // see if static class implements all of id's protocols, directly or; // through its super class and categories.; // First, lhs protocols in the qualifier list must be found, direct; // or indirect in rhs's qualifier list or it is a mismatch.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ASTContext.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTContext.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTContext.cpp:190,Integrability,protocol,protocols,190,"// when comparing an id<P> on rhs with a static type on lhs,; // see if static class implements all of id's protocols, directly or; // through its super class and categories.; // First, lhs protocols in the qualifier list must be found, direct; // or indirect in rhs's qualifier list or it is a mismatch.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ASTContext.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTContext.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTContext.cpp:18,Integrability,protocol,protocols,18,"// Static class's protocols, or its super class or category protocols; // must be found, direct or indirect in rhs's qualifier list or it is a mismatch.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ASTContext.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTContext.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTContext.cpp:60,Integrability,protocol,protocols,60,"// Static class's protocols, or its super class or category protocols; // must be found, direct or indirect in rhs's qualifier list or it is a mismatch.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ASTContext.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTContext.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTContext.cpp:115,Integrability,protocol,protocol,115,// This is rather dubious but matches gcc's behavior. If lhs has; // no type qualifier and its class has no static protocol(s); // assume that it is mismatch.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ASTContext.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTContext.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTContext.cpp:53,Integrability,interface,interface,53,/// canAssignObjCInterfaces - Return true if the two interface types are; /// compatible for assignment from RHS to LHS. This handles validation of any; /// protocol qualifiers on the LHS or RHS.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ASTContext.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTContext.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTContext.cpp:157,Integrability,protocol,protocol,157,/// canAssignObjCInterfaces - Return true if the two interface types are; /// compatible for assignment from RHS to LHS. This handles validation of any; /// protocol qualifiers on the LHS or RHS.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ASTContext.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTContext.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTContext.cpp:134,Security,validat,validation,134,/// canAssignObjCInterfaces - Return true if the two interface types are; /// compatible for assignment from RHS to LHS. This handles validation of any; /// protocol qualifiers on the LHS or RHS.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ASTContext.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTContext.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTContext.cpp:26,Integrability,protocol,protocol,26,"// Strip off __kindof and protocol qualifiers, then check whether; // we can assign the other way.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ASTContext.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTContext.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTContext.cpp:77,Integrability,protocol,protocols,77,// Casts from or to id<P> are allowed when the other side has compatible; // protocols.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ASTContext.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTContext.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTContext.cpp:10,Integrability,protocol,protocol,10,// Verify protocol compatibility for casts from Class<P1> to Class<P2>.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ASTContext.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTContext.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTContext.cpp:49,Integrability,rout,routine,49,"/// canAssignObjCInterfacesInBlockPointer - This routine is specifically written; /// for providing type-safety for objective-c pointers used to pass/return; /// arguments in block literals. When passed as arguments, passing 'A*' where; /// 'id' is expected is not OK. Passing 'Sub *"" where 'Super *"" is expected is; /// not OK. For the return type, the opposite is not OK.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ASTContext.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTContext.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTContext.cpp:105,Safety,safe,safety,105,"/// canAssignObjCInterfacesInBlockPointer - This routine is specifically written; /// for providing type-safety for objective-c pointers used to pass/return; /// arguments in block literals. When passed as arguments, passing 'A*' where; /// 'id' is expected is not OK. Passing 'Sub *"" where 'Super *"" is expected is; /// not OK. For the return type, the opposite is not OK.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ASTContext.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTContext.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTContext.cpp:26,Integrability,protocol,protocol,26,"// Strip off __kindof and protocol qualifiers, then check whether; // we can assign the other way.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ASTContext.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTContext.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTContext.cpp:15,Integrability,rout,routine,15,/// Comparison routine for Objective-C protocols to be used with; /// llvm::array_pod_sort.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ASTContext.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTContext.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTContext.cpp:39,Integrability,protocol,protocols,39,/// Comparison routine for Objective-C protocols to be used with; /// llvm::array_pod_sort.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ASTContext.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTContext.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTContext.cpp:38,Integrability,rout,routine,38,/// getIntersectionOfProtocols - This routine finds the intersection of set; /// of protocols inherited from two distinct objective-c pointer objects with; /// the given common base.; /// It is used to build composite qualifier list of the composite type of; /// the conditional expression involving two objective-c pointer objects.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ASTContext.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTContext.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTContext.cpp:84,Integrability,protocol,protocols,84,/// getIntersectionOfProtocols - This routine finds the intersection of set; /// of protocols inherited from two distinct objective-c pointer objects with; /// the given common base.; /// It is used to build composite qualifier list of the composite type of; /// the conditional expression involving two objective-c pointer objects.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ASTContext.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTContext.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTContext.cpp:94,Modifiability,inherit,inherited,94,/// getIntersectionOfProtocols - This routine finds the intersection of set; /// of protocols inherited from two distinct objective-c pointer objects with; /// the given common base.; /// It is used to build composite qualifier list of the composite type of; /// the conditional expression involving two objective-c pointer objects.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ASTContext.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTContext.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTContext.cpp:18,Integrability,protocol,protocols,18,// Add all of the protocols for the LHS.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ASTContext.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTContext.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTContext.cpp:18,Integrability,protocol,protocol,18,// Start with the protocol qualifiers.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ASTContext.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTContext.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTContext.cpp:16,Integrability,protocol,protocols,16,// Also add the protocols associated with the LHS interface.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ASTContext.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTContext.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTContext.cpp:50,Integrability,interface,interface,50,// Also add the protocols associated with the LHS interface.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ASTContext.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTContext.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTContext.cpp:18,Integrability,protocol,protocols,18,// Add all of the protocols for the RHS.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ASTContext.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTContext.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTContext.cpp:18,Integrability,protocol,protocol,18,// Start with the protocol qualifiers.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ASTContext.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTContext.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTContext.cpp:16,Integrability,protocol,protocols,16,// Also add the protocols associated with the RHS interface.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ASTContext.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTContext.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTContext.cpp:50,Integrability,interface,interface,50,// Also add the protocols associated with the RHS interface.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ASTContext.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTContext.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTContext.cpp:45,Integrability,protocol,protocol,45,// Compute the intersection of the collected protocol sets.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ASTContext.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTContext.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTContext.cpp:22,Integrability,protocol,protocols,22,// Compute the set of protocols that is implied by either the common type or; // the protocols within the intersection.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ASTContext.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTContext.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTContext.cpp:85,Integrability,protocol,protocols,85,// Compute the set of protocols that is implied by either the common type or; // the protocols within the intersection.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ASTContext.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTContext.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTContext.cpp:22,Integrability,protocol,protocols,22,// Remove any implied protocols from the list of inherited protocols.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ASTContext.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTContext.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTContext.cpp:59,Integrability,protocol,protocols,59,// Remove any implied protocols from the list of inherited protocols.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ASTContext.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTContext.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTContext.cpp:49,Modifiability,inherit,inherited,49,// Remove any implied protocols from the list of inherited protocols.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ASTContext.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTContext.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTContext.cpp:22,Integrability,protocol,protocols,22,// Sort the remaining protocols by name.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ASTContext.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTContext.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTContext.cpp:31,Integrability,protocol,protocols,31,// Compute the intersection of protocols.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ASTContext.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTContext.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTContext.cpp:95,Performance,cache,cached,95,// We didn't find anything by following the LHS to its root; now check; // the RHS against the cached set of ancestors.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ASTContext.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTContext.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTContext.cpp:31,Integrability,protocol,protocols,31,// Compute the intersection of protocols.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ASTContext.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTContext.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTContext.cpp:18,Integrability,protocol,protocol,18,"// If the LHS has protocol qualifiers, determine whether all of them are; // satisfied by the RHS (i.e., the RHS has a superset of the protocols in the; // LHS).",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ASTContext.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTContext.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTContext.cpp:135,Integrability,protocol,protocols,135,"// If the LHS has protocol qualifiers, determine whether all of them are; // satisfied by the RHS (i.e., the RHS has a superset of the protocols in the; // LHS).",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ASTContext.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTContext.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTContext.cpp:128,Integrability,protocol,protocols,128,"// OK if conversion of LHS to SuperClass results in narrowing of types; // ; i.e., SuperClass may implement at least one of the protocols; // in LHS's protocol list. Example, SuperObj<P1> = lhs<P1,P2> is ok.; // But not SuperObj<P1,P2,P3> = lhs<P1,P2>.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ASTContext.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTContext.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTContext.cpp:151,Integrability,protocol,protocol,151,"// OK if conversion of LHS to SuperClass results in narrowing of types; // ; i.e., SuperClass may implement at least one of the protocols; // in LHS's protocol list. Example, SuperObj<P1> = lhs<P1,P2> is ok.; // But not SuperObj<P1,P2,P3> = lhs<P1,P2>.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ASTContext.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTContext.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTContext.cpp:18,Integrability,protocol,protocols,18,"// If there is no protocols associated with RHS, it is not a match.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ASTContext.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTContext.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTContext.cpp:49,Availability,error,error,49,// FIXME: double check this; // FIXME: should we error if lbase->getRegParmAttr() != 0 &&; // rbase->getRegParmAttr() != 0 &&; // lbase->getRegParmAttr() != rbase->getRegParmAttr()?,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ASTContext.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTContext.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTContext.cpp:1081,Usability,simpl,simpler,1081,"// When merging declarations, it's common for supplemental information like; // attributes to only be present in one of the declarations, and we generally; // want type merging to preserve the union of information. So a merged; // function type should be noreturn if it was noreturn in *either* operand; // type.; //; // But for the conditional operator, this is backwards. The result of the; // operator could be either operand, and its type should conservatively; // reflect that. So a function type in a composite type is noreturn only; // if it's noreturn in *both* operand types.; //; // Arguably, noreturn is a kind of subtype, and the conditional operator; // ought to produce the most specific common supertype of its operand types.; // That would differ from this rule in contravariant positions. However,; // neither C nor C++ generally uses this kind of subtype reasoning. Also,; // as a practical matter, it would only affect C code that does abstraction of; // higher-order functions (taking noreturn callbacks!), which is uncommon to; // say the least. So we use the simpler rule.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ASTContext.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTContext.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTContext.cpp:255,Integrability,depend,depending,255,"// Check that the types are compatible with the types that; // would result from default argument promotions (C99 6.7.5.3p15).; // The only types actually affected are promotable integer; // types and floats, which would be passed as a different; // type depending on whether the prototype is visible.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ASTContext.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTContext.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTContext.cpp:23,Modifiability,variab,variable,23,"// If either side is a variable array, and both are complete, check whether; // the current dimension is definite.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ASTContext.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTContext.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTContext.cpp:61,Testability,test,tested,61,"// Only exactly equal builtin types are compatible, which is tested above.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ASTContext.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTContext.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTContext.cpp:33,Integrability,rout,routine,33,/// mergeObjCGCQualifiers - This routine merges ObjC's GC attribute of 'LHS' and; /// 'RHS' attributes and returns the merged version; including for function; /// return types.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ASTContext.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTContext.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTContext.cpp:76,Integrability,depend,depends,76,"// This is a ""reference"" to a va_list; however, what exactly; // this means depends on how va_list is defined. There are two; // different kinds of va_list: ones passed by value, and ones; // passed by reference. An example of a by-value va_list is; // x86, where va_list is a char*. An example of by-ref va_list; // is x86-64, where va_list is a __va_list_tag[1]. For x86,; // we want this argument to be a char*&; for x86-64, we want; // it to be a __va_list_tag*.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ASTContext.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTContext.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTContext.cpp:27,Energy Efficiency,Power,PowerPC,27,"// On some targets such as PowerPC, some of the builtins are defined with custom; // type descriptors for target-dependent types. These descriptors are decoded in; // other functions, but it may be useful to be able to fall back to default; // descriptor decoding to define builtins mixing target-dependent and target-; // independent types. This function allows decoding one type descriptor with; // default decoding.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ASTContext.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTContext.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTContext.cpp:113,Integrability,depend,dependent,113,"// On some targets such as PowerPC, some of the builtins are defined with custom; // type descriptors for target-dependent types. These descriptors are decoded in; // other functions, but it may be useful to be able to fall back to default; // descriptor decoding to define builtins mixing target-dependent and target-; // independent types. This function allows decoding one type descriptor with; // default decoding.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ASTContext.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTContext.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTContext.cpp:297,Integrability,depend,dependent,297,"// On some targets such as PowerPC, some of the builtins are defined with custom; // type descriptors for target-dependent types. These descriptors are decoded in; // other functions, but it may be useful to be able to fall back to default; // descriptor decoding to define builtins mixing target-dependent and target-; // independent types. This function allows decoding one type descriptor with; // default decoding.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ASTContext.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTContext.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTContext.cpp:19,Modifiability,inherit,inheriting,19,"// Our approach to inheriting constructors is fundamentally different from; // that used by the MS ABI, so keep our inheriting constructor thunks; // internal rather than trying to pick an unambiguous mangling for them.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ASTContext.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTContext.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTContext.cpp:116,Modifiability,inherit,inheriting,116,"// Our approach to inheriting constructors is fundamentally different from; // that used by the MS ABI, so keep our inheriting constructor thunks; // internal rather than trying to pick an unambiguous mangling for them.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ASTContext.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTContext.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTContext.cpp:96,Modifiability,variab,variables,96,// Single source offloading languages like CUDA/HIP need to be able to; // access static device variables from host code of the same compilation; // unit. This is done by externalizing the static variable with a shared; // name between the host and device compilation which is the same for the; // same compilation unit whereas different among different compilation; // units.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ASTContext.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTContext.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTContext.cpp:196,Modifiability,variab,variable,196,// Single source offloading languages like CUDA/HIP need to be able to; // access static device variables from host code of the same compilation; // unit. This is done by externalizing the static variable with a shared; // name between the host and device compilation which is the same for the; // same compilation unit whereas different among different compilation; // units.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ASTContext.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTContext.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTContext.cpp:75,Security,access,access,75,// Single source offloading languages like CUDA/HIP need to be able to; // access static device variables from host code of the same compilation; // unit. This is done by externalizing the static variable with a shared; // name between the host and device compilation which is the same for the; // same compilation unit whereas different among different compilation; // units.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ASTContext.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTContext.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTContext.cpp:61,Modifiability,variab,variables,61,"// As an extension for interactive REPLs, make sure constant variables are; // only emitted once instead of LinkageComputer::getLVForNamespaceScopeDecl; // marking them as internal.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ASTContext.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTContext.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTContext.cpp:32,Modifiability,variab,variables,32,// ObjC Blocks can create local variables that don't have a FunctionDecl; // LexicalContext.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ASTContext.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTContext.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTContext.cpp:35,Modifiability,variab,variable,35,"// Otherwise, let the static local variable inherit its linkage from the; // nearest enclosing function.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ASTContext.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTContext.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTContext.cpp:44,Modifiability,inherit,inherit,44,"// Otherwise, let the static local variable inherit its linkage from the; // nearest enclosing function.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ASTContext.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTContext.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTContext.cpp:286,Availability,Avail,AvailableExternally,286,"// Itanium ABI 5.2.2: ""Each COMDAT group [for a static local variable] must; // be emitted in any object with references to the symbol for the object it; // contains, whether inline or out-of-line.""; // Similar behavior is observed with MSVC. An alternative ABI could use; // StrongODR/AvailableExternally to match the function, but none are; // known/supported currently.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ASTContext.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTContext.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTContext.cpp:61,Modifiability,variab,variable,61,"// Itanium ABI 5.2.2: ""Each COMDAT group [for a static local variable] must; // be emitted in any object with references to the symbol for the object it; // contains, whether inline or out-of-line.""; // Similar behavior is observed with MSVC. An alternative ABI could use; // StrongODR/AvailableExternally to match the function, but none are; // known/supported currently.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ASTContext.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTContext.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTContext.cpp:156,Availability,error,errors,156,"// MSVC treats in-class initialized static data members as definitions.; // By giving them non-strong linkage, out-of-line definitions won't; // cause link errors.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ASTContext.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTContext.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTContext.cpp:21,Modifiability,variab,variables,21,"// Most non-template variables have strong linkage; inline variables are; // linkonce_odr or (occasionally, for compatibility) weak_odr.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ASTContext.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTContext.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTContext.cpp:59,Modifiability,variab,variables,59,"// Most non-template variables have strong linkage; inline variables are; // linkonce_odr or (occasionally, for compatibility) weak_odr.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ASTContext.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTContext.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTContext.cpp:25,Modifiability,variab,variables,25,// Global named register variables (GNU extension) are never emitted.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ASTContext.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTContext.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTContext.cpp:3,Modifiability,Variab,Variables,3,// Variables in other module units shouldn't be forced to be emitted.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ASTContext.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTContext.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTContext.cpp:3,Modifiability,Variab,Variables,3,// Variables that can be needed in other TUs are required.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ASTContext.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTContext.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTContext.cpp:44,Availability,avail,available,44,// We never need to emit a variable that is available in another TU.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ASTContext.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTContext.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTContext.cpp:27,Modifiability,variab,variable,27,// We never need to emit a variable that is available in another TU.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ASTContext.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTContext.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTContext.cpp:3,Modifiability,Variab,Variables,3,// Variables that have destruction with side-effects are required.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ASTContext.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTContext.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTContext.cpp:3,Modifiability,Variab,Variables,3,// Variables that have initialization with side-effects are required.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ASTContext.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTContext.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTContext.cpp:51,Availability,error,error,51,// We can get a value-dependent initializer during error recovery.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ASTContext.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTContext.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTContext.cpp:57,Availability,recover,recovery,57,// We can get a value-dependent initializer during error recovery.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ASTContext.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTContext.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTContext.cpp:22,Integrability,depend,dependent,22,// We can get a value-dependent initializer during error recovery.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ASTContext.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTContext.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTContext.cpp:57,Safety,recover,recovery,57,// We can get a value-dependent initializer during error recovery.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ASTContext.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTContext.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTContext.cpp:13,Modifiability,variab,variables,13,"// Likewise, variables with tuple-like bindings are required if their; // bindings have side-effects.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ASTContext.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTContext.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTContext.cpp:50,Integrability,depend,depends,50,"// FIXME: The order of traversal here matters and depends on the order of; // lookup results, which happens to be (mostly) oldest-to-newest, but we; // shouldn't rely on that.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ASTContext.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTContext.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTContext.cpp:28,Integrability,depend,dependent,28,"// If we're left with value-dependent computed noexcept expressions, we're; // stuck. Before C++17, we can just drop the exception specification entirely,; // since it's not actually part of the canonical type. And this should never; // happen in C++17, because it would mean we were computing the composite; // pointer type of dependent types, which should never happen.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ASTContext.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTContext.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTContext.cpp:328,Integrability,depend,dependent,328,"// If we're left with value-dependent computed noexcept expressions, we're; // stuck. Before C++17, we can just drop the exception specification entirely,; // since it's not actually part of the canonical type. And this should never; // happen in C++17, because it would mean we were computing the composite; // pointer type of dependent types, which should never happen.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ASTContext.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTContext.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTContext.cpp:78,Deployability,update,update,78,// Switch over the possibilities so that people adding new values know to; // update this function.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ASTContext.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTContext.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTContext.cpp:28,Integrability,depend,dependent,28,"// Both auto types can't be dependent, otherwise they wouldn't have been; // sugar. This implies they can't contain unexpanded packs either.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ASTContext.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTContext.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTContext.cpp:21,Modifiability,variab,variables,21,"// CUDA/HIP: managed variables need to be externalized since it is; // a declaration in IR, therefore cannot have internal linkage. Kernels in; // anonymous name space needs to be externalized to avoid duplicate symbols.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ASTContext.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTContext.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTContext.cpp:196,Safety,avoid,avoid,196,"// CUDA/HIP: managed variables need to be externalized since it is; // a declaration in IR, therefore cannot have internal linkage. Kernels in; // anonymous name space needs to be externalized to avoid duplicate symbols.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ASTContext.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTContext.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTDiagnostic.cpp:1112,Energy Efficiency,allocate,allocated,1112,"/// Convert the given type to a string suitable for printing as part of; /// a diagnostic.; ///; /// There are four main criteria when determining whether we should have an; /// a.k.a. clause when pretty-printing a type:; ///; /// 1) Some types provide very minimal sugar that doesn't impede the; /// user's understanding --- for example, elaborated type; /// specifiers. If this is all the sugar we see, we don't want an; /// a.k.a. clause.; /// 2) Some types are technically sugared but are much more familiar; /// when seen in their sugared form --- for example, va_list,; /// vector types, and the magic Objective C types. We don't; /// want to desugar these, even if we do produce an a.k.a. clause.; /// 3) Some types may have already been desugared previously in this diagnostic.; /// if this is the case, doing another ""aka"" would just be clutter.; /// 4) Two different types within the same diagnostic have the same output; /// string. In this case, force an a.k.a with the desugared type when; /// doing so will provide additional information.; ///; /// \param Context the context in which the type was allocated; /// \param Ty the type to print; /// \param QualTypeVals pointer values to QualTypes which are used in the; /// diagnostic message",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ASTDiagnostic.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTDiagnostic.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTDiagnostic.cpp:1246,Integrability,message,message,1246,"/// Convert the given type to a string suitable for printing as part of; /// a diagnostic.; ///; /// There are four main criteria when determining whether we should have an; /// a.k.a. clause when pretty-printing a type:; ///; /// 1) Some types provide very minimal sugar that doesn't impede the; /// user's understanding --- for example, elaborated type; /// specifiers. If this is all the sugar we see, we don't want an; /// a.k.a. clause.; /// 2) Some types are technically sugared but are much more familiar; /// when seen in their sugared form --- for example, va_list,; /// vector types, and the magic Objective C types. We don't; /// want to desugar these, even if we do produce an a.k.a. clause.; /// 3) Some types may have already been desugared previously in this diagnostic.; /// if this is the case, doing another ""aka"" would just be clutter.; /// 4) Two different types within the same diagnostic have the same output; /// string. In this case, force an a.k.a with the desugared type when; /// doing so will provide additional information.; ///; /// \param Context the context in which the type was allocated; /// \param Ty the type to print; /// \param QualTypeVals pointer values to QualTypes which are used in the; /// diagnostic message",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ASTDiagnostic.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTDiagnostic.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTDiagnostic.cpp:62,Modifiability,variab,variables,62,// Attempting to do a template diff on non-templates. Set the variables; // and continue with regular type printing of the appropriate type.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ASTDiagnostic.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTDiagnostic.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTDiagnostic.cpp:23,Security,access,access,23,/// operator-> - Allow access to the underlying TemplateArgument.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ASTDiagnostic.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTDiagnostic.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTDiagnostic.cpp:23,Security,access,access,23,/// operator-> - Allow access to the underlying TemplateArgument.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ASTDiagnostic.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTDiagnostic.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTDiagnostic.cpp:58,Availability,avail,available,58,/// isEnd - Returns true if no more TemplateArguments are available.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ASTDiagnostic.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTDiagnostic.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTDiagnostic.cpp:76,Availability,avail,available,76,/// hasDesugaredTA - Returns true if there is another TemplateArgument; /// available.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ASTDiagnostic.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTDiagnostic.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTDiagnostic.cpp:124,Integrability,depend,dependent,124,"/// IsEqualExpr - Returns true if the expressions are the same in regards to; /// template arguments. These expressions are dependent, so profile them; /// instead of trying to evaluate them.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ASTDiagnostic.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTDiagnostic.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTDiagnostic.cpp:100,Integrability,inject,injected,100,"// To signal to the text printer that a certain text needs to be bolded,; // a special character is injected into the character stream which the; // text printer will later strip out.; /// Bold - Start bolding text.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ASTDiagnostic.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTDiagnostic.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTDiagnostic.cpp:100,Security,inject,injected,100,"// To signal to the text printer that a certain text needs to be bolded,; // a special character is injected into the character stream which the; // text printer will later strip out.; /// Bold - Start bolding text.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ASTDiagnostic.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTDiagnostic.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTDiagnostic.cpp:143,Safety,detect,detect,143,"// Functions to print out the arguments and highlighting the difference.; /// PrintTypeNames - prints the typenames, bolding differences. Will detect; /// typenames that are the same and attempt to disambiguate them by using; /// canonical typenames.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ASTDiagnostic.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTDiagnostic.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTDumper.cpp:468,Security,expose,exposes,468,"//===--- ASTDumper.cpp - Dumping implementation for ASTs ------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements the AST dump methods, which dump out the; // AST in a form that exposes type details and other fields.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ASTDumper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTDumper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTDumper.cpp:119,Testability,assert,assertion,119,"// An invalid DeclContext is one for which a dyn_cast() from a DeclContext; // pointer to a Decl pointer would fail an assertion or otherwise fall prey; // to undefined behavior as a result of an invalid associated DeclKind.; // Such invalidity is not supposed to happen of course, but, when it does,; // the information provided below is intended to provide some hints about; // what might have gone awry.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ASTDumper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTDumper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTDumper.cpp:324,Performance,perform,performs,324,"// By design, DeclContext is required to be a base class of some class that; // derives from Decl. Thus, it should always be possible to dyn_cast() from; // a DeclContext pointer to a Decl pointer and Decl::castFromDeclContext(); // asserts that to be the case. Since this function is intended for use in a; // debugger, it performs an additional check in order to prevent a failed; // cast and assertion. If that check fails, then the (invalid) DeclContext; // is dumped with an indication of its invalidity.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ASTDumper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTDumper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTDumper.cpp:233,Testability,assert,asserts,233,"// By design, DeclContext is required to be a base class of some class that; // derives from Decl. Thus, it should always be possible to dyn_cast() from; // a DeclContext pointer to a Decl pointer and Decl::castFromDeclContext(); // asserts that to be the case. Since this function is intended for use in a; // debugger, it performs an additional check in order to prevent a failed; // cast and assertion. If that check fails, then the (invalid) DeclContext; // is dumped with an indication of its invalidity.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ASTDumper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTDumper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTDumper.cpp:395,Testability,assert,assertion,395,"// By design, DeclContext is required to be a base class of some class that; // derives from Decl. Thus, it should always be possible to dyn_cast() from; // a DeclContext pointer to a Decl pointer and Decl::castFromDeclContext(); // asserts that to be the case. Since this function is intended for use in a; // debugger, it performs an additional check in order to prevent a failed; // cast and assertion. If that check fails, then the (invalid) DeclContext; // is dumped with an indication of its invalidity.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ASTDumper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTDumper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTDumper.cpp:27,Availability,avail,available,27,"// If an ASTContext is not available, a less capable ASTDumper is; // constructed for which color diagnostics are, regrettably, disabled.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ASTDumper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTDumper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp:18,Availability,error,error,18,// FIXME: Improve error texts.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp:25,Availability,error,errors,25,/// How to handle import errors that occur when import of a child declaration; /// of a DeclContext fails.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp:18,Availability,error,errors,18,"/// Ignore import errors of the children.; /// If true, the context can be imported successfully if a child; /// of it failed to import. Otherwise the import errors of the child nodes; /// are accumulated (joined) into the import error object of the parent.; /// (Import of a parent can fail in other ways.)",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp:158,Availability,error,errors,158,"/// Ignore import errors of the children.; /// If true, the context can be imported successfully if a child; /// of it failed to import. Otherwise the import errors of the child nodes; /// are accumulated (joined) into the import error object of the parent.; /// (Import of a parent can fail in other ways.)",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp:230,Availability,error,error,230,"/// Ignore import errors of the children.; /// If true, the context can be imported successfully if a child; /// of it failed to import. Otherwise the import errors of the child nodes; /// are accumulated (joined) into the import error object of the parent.; /// (Import of a parent can fail in other ways.)",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp:104,Availability,error,error,104,/// Process the import result of a child (of the current declaration).; /// \param ResultErr The import error that can be used as result of; /// importing the parent. This may be changed by the function.; /// \param ChildErr Result of importing a child. Can be success or error.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp:272,Availability,error,error,272,/// Process the import result of a child (of the current declaration).; /// \param ResultErr The import error that can be used as result of; /// importing the parent. This may be changed by the function.; /// \param ChildErr Result of importing a child. Can be success or error.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp:24,Availability,failure,failure,24,/// Determine if import failure of a child does not cause import failure of; /// its parent.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp:65,Availability,failure,failure,65,/// Determine if import failure of a child does not cause import failure of; /// its parent.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp:3,Integrability,Wrap,Wrapper,3,// Wrapper for an overload set.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp:150,Integrability,wrap,wrapper,150,"// There may be several overloads of ToDeclT::Create. We must make sure; // to call the one which would be chosen by the arguments, thus we use a; // wrapper for the overload set.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp:29,Availability,error,error,29,// Already imported but with error.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp:56,Availability,error,error,56,"// Helper for chaining together multiple imports. If an error is detected,; // subsequent imports will return default constructed nodes, so that failure; // can be detected with a single conditional branch after a sequence of; // imports.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp:145,Availability,failure,failure,145,"// Helper for chaining together multiple imports. If an error is detected,; // subsequent imports will return default constructed nodes, so that failure; // can be detected with a single conditional branch after a sequence of; // imports.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp:65,Safety,detect,detected,65,"// Helper for chaining together multiple imports. If an error is detected,; // subsequent imports will return default constructed nodes, so that failure; // can be detected with a single conditional branch after a sequence of; // imports.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp:164,Safety,detect,detected,164,"// Helper for chaining together multiple imports. If an error is detected,; // subsequent imports will return default constructed nodes, so that failure; // can be detected with a single conditional branch after a sequence of; // imports.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp:46,Availability,error,error,46,// Don't attempt to import nodes if we hit an error earlier.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp:81,Availability,error,error,81,"// Import every item from a container structure into an output container.; // If error occurs, stops at first error and returns the error.; // The output container should have space for all needed elements (it is not; // expanded, new items are put into from the beginning).",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp:110,Availability,error,error,110,"// Import every item from a container structure into an output container.; // If error occurs, stops at first error and returns the error.; // The output container should have space for all needed elements (it is not; // expanded, new items are put into from the beginning).",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp:132,Availability,error,error,132,"// Import every item from a container structure into an output container.; // If error occurs, stops at first error and returns the error.; // The output container should have space for all needed elements (it is not; // expanded, new items are put into from the beginning).",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp:7,Integrability,Inject,InjectedClassNameType,7,// The InjectedClassNameType is created in VisitRecordDecl when the; // T->getDecl() is imported. Here we can return the existing type.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp:7,Security,Inject,InjectedClassNameType,7,// The InjectedClassNameType is created in VisitRecordDecl when the; // T->getDecl() is imported. Here we can return the existing type.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp:56,Safety,avoid,avoid,56,// Check if RecordDecl is in FunctionDecl parameters to avoid infinite loop.; // example: int struct_in_proto(struct data_t{int a;int b;} *d);; // FIXME: We could support these constructs by importing a different type of; // this parameter and by importing the original type of the parameter only; // after the FunctionDecl is created. See; // VisitFunctionDecl::UsedDifferentProtoType.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp:17,Availability,error,error,17,"// We use strict error handling in case of records and enums, but not; // with e.g. namespaces.; //; // FIXME Clients of the ASTImporter should be able to choose an; // appropriate error handling strategy for their needs. For instance,; // they may not want to mark an entire namespace as erroneous merely; // because there is an ODR error with two typedefs. As another example,; // the client may allow EnumConstantDecls with same names but with; // different values in two distinct translation units.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp:181,Availability,error,error,181,"// We use strict error handling in case of records and enums, but not; // with e.g. namespaces.; //; // FIXME Clients of the ASTImporter should be able to choose an; // appropriate error handling strategy for their needs. For instance,; // they may not want to mark an entire namespace as erroneous merely; // because there is an ODR error with two typedefs. As another example,; // the client may allow EnumConstantDecls with same names but with; // different values in two distinct translation units.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp:334,Availability,error,error,334,"// We use strict error handling in case of records and enums, but not; // with e.g. namespaces.; //; // FIXME Clients of the ASTImporter should be able to choose an; // appropriate error handling strategy for their needs. For instance,; // they may not want to mark an entire namespace as erroneous merely; // because there is an ODR error with two typedefs. As another example,; // the client may allow EnumConstantDecls with same names but with; // different values in two distinct translation units.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp:329,Integrability,depend,dependencies,329,"// We reorder declarations in RecordDecls because they may have another order; // in the ""to"" context than they have in the ""from"" context. This may happen; // e.g when we import a class like this:; // struct declToImport {; // int a = c + b;; // int b = 1;; // int c = 2;; // };; // During the import of `a` we import first the dependencies in sequence,; // thus the order would be `c`, `b`, `a`. We will get the normal order by; // first removing the already imported members and then adding them in the; // order as they appear in the ""from"" context.; //; // Keeping field order is vital because it determines structure layout.; //; // Here and below, we cannot call field_begin() method and its callers on; // ToDC if it has an external storage. Calling field_begin() will; // automatically load all the fields by calling; // LoadFieldsFromExternalStorage(). LoadFieldsFromExternalStorage() would; // call ASTImporter::Import(). This is because the ExternalASTSource; // interface in LLDB is implemented by the means of the ASTImporter. However,; // calling an import at this point would result in an uncontrolled import, we; // must avoid that.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp:975,Integrability,interface,interface,975,"// We reorder declarations in RecordDecls because they may have another order; // in the ""to"" context than they have in the ""from"" context. This may happen; // e.g when we import a class like this:; // struct declToImport {; // int a = c + b;; // int b = 1;; // int c = 2;; // };; // During the import of `a` we import first the dependencies in sequence,; // thus the order would be `c`, `b`, `a`. We will get the normal order by; // first removing the already imported members and then adding them in the; // order as they appear in the ""from"" context.; //; // Keeping field order is vital because it determines structure layout.; //; // Here and below, we cannot call field_begin() method and its callers on; // ToDC if it has an external storage. Calling field_begin() will; // automatically load all the fields by calling; // LoadFieldsFromExternalStorage(). LoadFieldsFromExternalStorage() would; // call ASTImporter::Import(). This is because the ExternalASTSource; // interface in LLDB is implemented by the means of the ASTImporter. However,; // calling an import at this point would result in an uncontrolled import, we; // must avoid that.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp:795,Performance,load,load,795,"// We reorder declarations in RecordDecls because they may have another order; // in the ""to"" context than they have in the ""from"" context. This may happen; // e.g when we import a class like this:; // struct declToImport {; // int a = c + b;; // int b = 1;; // int c = 2;; // };; // During the import of `a` we import first the dependencies in sequence,; // thus the order would be `c`, `b`, `a`. We will get the normal order by; // first removing the already imported members and then adding them in the; // order as they appear in the ""from"" context.; //; // Keeping field order is vital because it determines structure layout.; //; // Here and below, we cannot call field_begin() method and its callers on; // ToDC if it has an external storage. Calling field_begin() will; // automatically load all the fields by calling; // LoadFieldsFromExternalStorage(). LoadFieldsFromExternalStorage() would; // call ASTImporter::Import(). This is because the ExternalASTSource; // interface in LLDB is implemented by the means of the ASTImporter. However,; // calling an import at this point would result in an uncontrolled import, we; // must avoid that.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp:830,Performance,Load,LoadFieldsFromExternalStorage,830,"// We reorder declarations in RecordDecls because they may have another order; // in the ""to"" context than they have in the ""from"" context. This may happen; // e.g when we import a class like this:; // struct declToImport {; // int a = c + b;; // int b = 1;; // int c = 2;; // };; // During the import of `a` we import first the dependencies in sequence,; // thus the order would be `c`, `b`, `a`. We will get the normal order by; // first removing the already imported members and then adding them in the; // order as they appear in the ""from"" context.; //; // Keeping field order is vital because it determines structure layout.; //; // Here and below, we cannot call field_begin() method and its callers on; // ToDC if it has an external storage. Calling field_begin() will; // automatically load all the fields by calling; // LoadFieldsFromExternalStorage(). LoadFieldsFromExternalStorage() would; // call ASTImporter::Import(). This is because the ExternalASTSource; // interface in LLDB is implemented by the means of the ASTImporter. However,; // calling an import at this point would result in an uncontrolled import, we; // must avoid that.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp:863,Performance,Load,LoadFieldsFromExternalStorage,863,"// We reorder declarations in RecordDecls because they may have another order; // in the ""to"" context than they have in the ""from"" context. This may happen; // e.g when we import a class like this:; // struct declToImport {; // int a = c + b;; // int b = 1;; // int c = 2;; // };; // During the import of `a` we import first the dependencies in sequence,; // thus the order would be `c`, `b`, `a`. We will get the normal order by; // first removing the already imported members and then adding them in the; // order as they appear in the ""from"" context.; //; // Keeping field order is vital because it determines structure layout.; //; // Here and below, we cannot call field_begin() method and its callers on; // ToDC if it has an external storage. Calling field_begin() will; // automatically load all the fields by calling; // LoadFieldsFromExternalStorage(). LoadFieldsFromExternalStorage() would; // call ASTImporter::Import(). This is because the ExternalASTSource; // interface in LLDB is implemented by the means of the ASTImporter. However,; // calling an import at this point would result in an uncontrolled import, we; // must avoid that.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp:1138,Safety,avoid,avoid,1138,"// We reorder declarations in RecordDecls because they may have another order; // in the ""to"" context than they have in the ""from"" context. This may happen; // e.g when we import a class like this:; // struct declToImport {; // int a = c + b;; // int b = 1;; // int c = 2;; // };; // During the import of `a` we import first the dependencies in sequence,; // thus the order would be `c`, `b`, `a`. We will get the normal order by; // first removing the already imported members and then adding them in the; // order as they appear in the ""from"" context.; //; // Keeping field order is vital because it determines structure layout.; //; // Here and below, we cannot call field_begin() method and its callers on; // ToDC if it has an external storage. Calling field_begin() will; // automatically load all the fields by calling; // LoadFieldsFromExternalStorage(). LoadFieldsFromExternalStorage() would; // call ASTImporter::Import(). This is because the ExternalASTSource; // interface in LLDB is implemented by the means of the ASTImporter. However,; // calling an import at this point would result in an uncontrolled import, we; // must avoid that.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp:35,Availability,error,error,35,// Complete the definition even if error is returned.; // The RecordDecl may be already part of the AST so it is better to; // have it in complete state even if something is wrong with it.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp:25,Availability,failure,failure,25,// Eliminate a potential failure point where we attempt to re-import; // something we're trying to import while completing ToRecord.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp:2,Availability,Error,ErrorOnTagTypeMismatch,2,/*ErrorOnTagTypeMismatch=*/,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp:79,Security,access,accessSpec,79,// Lexical DeclContext and Semantic DeclContext; // is always the same for the accessSpec.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp:103,Testability,test,testable,103,// This is an anonymous namespace. Adopt an existing anonymous; // namespace if we can.; // FIXME: Not testable.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp:434,Safety,avoid,avoid,434,"// If the underlying declarations are unnamed records these can be; // imported as different types. We should create a distinct typedef; // node in this case.; // If we found an existing underlying type with a record in a; // different context (than the imported), this is already reason for; // having distinct typedef nodes for these.; // Again this can create situation like; // 'typedef int T; typedef int T;' but this is hard to avoid without; // a rename strategy at import.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp:202,Availability,avail,available,202,// In a record describing a template the type should be an; // InjectedClassNameType (see Sema::CheckClassTemplate). Update the; // previously set type to the correct value here (ToDescribed is not; // available at record create).,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp:117,Deployability,Update,Update,117,// In a record describing a template the type should be an; // InjectedClassNameType (see Sema::CheckClassTemplate). Update the; // previously set type to the correct value here (ToDescribed is not; // available at record create).,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp:63,Integrability,Inject,InjectedClassNameType,63,// In a record describing a template the type should be an; // InjectedClassNameType (see Sema::CheckClassTemplate). Update the; // previously set type to the correct value here (ToDescribed is not; // available at record create).,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp:63,Security,Inject,InjectedClassNameType,63,// In a record describing a template the type should be an; // InjectedClassNameType (see Sema::CheckClassTemplate). Update the; // previously set type to the correct value here (ToDescribed is not; // available at record create).,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp:13,Integrability,inject,injected,13,"// Create an injected type for the whole redecl chain.; // The chain may contain an already existing injected type at the start,; // if yes this should be reused. We must ensure that only one type; // object exists for the injected type (including the injected record; // declaration), ASTContext does not check it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp:101,Integrability,inject,injected,101,"// Create an injected type for the whole redecl chain.; // The chain may contain an already existing injected type at the start,; // if yes this should be reused. We must ensure that only one type; // object exists for the injected type (including the injected record; // declaration), ASTContext does not check it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp:223,Integrability,inject,injected,223,"// Create an injected type for the whole redecl chain.; // The chain may contain an already existing injected type at the start,; // if yes this should be reused. We must ensure that only one type; // object exists for the injected type (including the injected record; // declaration), ASTContext does not check it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp:252,Integrability,inject,injected,252,"// Create an injected type for the whole redecl chain.; // The chain may contain an already existing injected type at the start,; // if yes this should be reused. We must ensure that only one type; // object exists for the injected type (including the injected record; // declaration), ASTContext does not check it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp:13,Security,inject,injected,13,"// Create an injected type for the whole redecl chain.; // The chain may contain an already existing injected type at the start,; // if yes this should be reused. We must ensure that only one type; // object exists for the injected type (including the injected record; // declaration), ASTContext does not check it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp:101,Security,inject,injected,101,"// Create an injected type for the whole redecl chain.; // The chain may contain an already existing injected type at the start,; // if yes this should be reused. We must ensure that only one type; // object exists for the injected type (including the injected record; // declaration), ASTContext does not check it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp:223,Security,inject,injected,223,"// Create an injected type for the whole redecl chain.; // The chain may contain an already existing injected type at the start,; // if yes this should be reused. We must ensure that only one type; // object exists for the injected type (including the injected record; // declaration), ASTContext does not check it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp:252,Security,inject,injected,252,"// Create an injected type for the whole redecl chain.; // The chain may contain an already existing injected type at the start,; // if yes this should be reused. We must ensure that only one type; // object exists for the injected type (including the injected record; // declaration), ASTContext does not check it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp:34,Integrability,inject,injected,34,"// This function tries to get the injected type from getTypeForDecl,; // then from the previous declaration if possible. If not, it creates; // a new type.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp:34,Security,inject,injected,34,"// This function tries to get the injected type from getTypeForDecl,; // then from the previous declaration if possible. If not, it creates; // a new type.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp:28,Integrability,inject,injected,28,// Set the new type for the injected decl too.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp:28,Security,inject,injected,28,// Set the new type for the injected decl too.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp:31,Integrability,inject,injected,31,// This function will copy the injected type from D2CXX into Injected.; // The injected decl does not have a previous decl to copy from.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp:61,Integrability,Inject,Injected,61,// This function will copy the injected type from D2CXX into Injected.; // The injected decl does not have a previous decl to copy from.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp:79,Integrability,inject,injected,79,// This function will copy the injected type from D2CXX into Injected.; // The injected decl does not have a previous decl to copy from.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp:31,Security,inject,injected,31,// This function will copy the injected type from D2CXX into Injected.; // The injected decl does not have a previous decl to copy from.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp:61,Security,Inject,Injected,61,// This function will copy the injected type from D2CXX into Injected.; // The injected decl does not have a previous decl to copy from.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp:79,Security,inject,injected,79,// This function will copy the injected type from D2CXX into Injected.; // The injected decl does not have a previous decl to copy from.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp:794,Integrability,depend,dependent,794,"/// Check if a type has any reference to a declaration that is inside the body; /// of a function.; /// The \c CheckType(QualType) function should be used to determine; /// this property.; ///; /// The type visitor visits one type object only (not recursive).; /// To find all referenced declarations we must discover all type objects until; /// the canonical type is reached (walk over typedef and similar objects). This; /// is done by loop over all ""sugar"" type objects. For every such type we must; /// check all declarations that are referenced from it. For this check the; /// visitor is used. In the visit functions all referenced declarations except; /// the one that follows in the sugar chain (if any) must be checked. For this; /// check the same visitor is re-used (it has no state-dependent data).; ///; /// The visit functions have 3 possible return values:; /// - True, found a declaration inside \c ParentDC.; /// - False, found declarations only outside \c ParentDC and it is not possible; /// to find more declarations (the ""sugar"" chain does not continue).; /// - Empty optional value, found no declarations or only outside \c ParentDC,; /// but it is possible to find more declarations in the type ""sugar"" chain.; /// The loop over the ""sugar"" types can be implemented by using type visit; /// functions only (call \c CheckType with the desugared type). With the current; /// solution no visit function is needed if the type has only a desugared type; /// as data.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp:120,Testability,assert,asserts,120,// We do not allow more than one in-class declaration of a function. This is; // because AST clients like VTableBuilder asserts on this. VTableBuilder; // assumes there is only one in-class declaration. Building a redecl; // chain would result in more than one in-class declaration for; // overrides (even if they are part of the same redecl chain inside the; // derived class.),MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp:80,Safety,avoid,avoids,80,"// Handle a ""templated"" function together with its described; // template. This avoids need for a similar check at import of the; // described template.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp:285,Deployability,update,update,285,"// Set to true if we do not import the type of the function as is. There are; // cases when the original type would result in an infinite recursion during; // the import. To avoid an infinite recursion when importing, we create the; // FunctionDecl with a simplified function type and update it only after the; // relevant AST nodes are already imported.; // The type is related to TypeSourceInfo (it references the type), so we must; // do the same with TypeSourceInfo.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp:174,Safety,avoid,avoid,174,"// Set to true if we do not import the type of the function as is. There are; // cases when the original type would result in an infinite recursion during; // the import. To avoid an infinite recursion when importing, we create the; // FunctionDecl with a simplified function type and update it only after the; // relevant AST nodes are already imported.; // The type is related to TypeSourceInfo (it references the type), so we must; // do the same with TypeSourceInfo.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp:256,Usability,simpl,simplified,256,"// Set to true if we do not import the type of the function as is. There are; // cases when the original type would result in an infinite recursion during; // the import. To avoid an infinite recursion when importing, we create the; // FunctionDecl with a simplified function type and update it only after the; // relevant AST nodes are already imported.; // The type is related to TypeSourceInfo (it references the type), so we must; // do the same with TypeSourceInfo.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp:181,Safety,avoid,avoid,181,"// Functions with auto return type may define a struct inside their body; // and the return type could refer to that struct.; // E.g.: auto foo() { struct X{}; return X(); }; // To avoid an infinite recursion when importing, create the FunctionDecl; // with a simplified return type.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp:260,Usability,simpl,simplified,260,"// Functions with auto return type may define a struct inside their body; // and the return type could refer to that struct.; // E.g.: auto foo() { struct X{}; return X(); }; // To avoid an infinite recursion when importing, create the FunctionDecl; // with a simplified return type.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp:145,Safety,avoid,avoid,145,"// FunctionProtoType::ExtProtoInfo's ExceptionSpecDecl can point to the; // FunctionDecl that we are importing the FunctionProtoType for.; // To avoid an infinite recursion when importing, create the FunctionDecl; // with a simplified function type.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp:224,Usability,simpl,simplified,224,"// FunctionProtoType::ExtProtoInfo's ExceptionSpecDecl can point to the; // FunctionDecl that we are importing the FunctionProtoType for.; // To avoid an infinite recursion when importing, create the FunctionDecl; // with a simplified function type.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp:63,Availability,error,error,63,"// Import first, then allocate memory and copy if there was no error.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp:22,Energy Efficiency,allocate,allocate,22,"// Import first, then allocate memory and copy if there was no error.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp:56,Modifiability,variab,variable,56,// Import the major distinguishing characteristics of a variable.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp:56,Modifiability,variab,variable,56,// Import the major distinguishing characteristics of a variable.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp:44,Energy Efficiency,allocate,allocated,44,// FIXME here we leak `NamedChain` which is allocated before,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp:156,Availability,redundant,redundant,156,// Determine whether we've already imported this decl.; // FriendDecl is not a NamedDecl so we cannot use lookup.; // We try to maintain order and count of redundant friend declarations.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp:156,Safety,redund,redundant,156,// Determine whether we've already imported this decl.; // FriendDecl is not a NamedDecl so we cannot use lookup.; // We try to maintain order and count of redundant friend declarations.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp:56,Modifiability,variab,variable,56,// Import the major distinguishing characteristics of a variable.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp:17,Modifiability,variab,variable,17,"// Try to find a variable in our own (""to"") context with the same name and; // in the same context as the variable we're importing.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp:106,Modifiability,variab,variable,106,"// Try to find a variable in our own (""to"") context with the same name and; // in the same context as the variable we're importing.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp:23,Availability,error,error,23,// FIXME Check for ODR error if the two definitions have; // different initializers?,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp:22,Availability,error,error,22,// FIXME Diagnose ODR error if the two initializers are different?,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp:23,Modifiability,variab,variable,23,// Create the imported variable.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp:214,Integrability,depend,dependency,214,// Set the default argument. It should be no problem if it was already done.; // Do not import the default expression before GetImportedOrCreateDecl call; // to avoid possible infinite import loop because circular dependency.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp:161,Safety,avoid,avoid,161,// Set the default argument. It should be no problem if it was already done.; // Do not import the default expression before GetImportedOrCreateDecl call; // to avoid possible infinite import loop because circular dependency.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp:205,Integrability,interface,interface,205,// Implicit params are declared when Sema encounters the definition but this; // never happens when the method is imported. Manually declare the implicit; // params now that the MethodDecl knows its class interface.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp:56,Safety,avoid,avoid,56,"// Import the type parameter list after MapImported, to avoid; // loops when bringing in their DeclContext.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp:10,Integrability,protocol,protocols,10,// Import protocols,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp:47,Integrability,protocol,protocol,47,"// FIXME: If we're merging, make sure that the protocol list is the same.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp:13,Integrability,protocol,protocol,13,// Start the protocol definition,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp:10,Integrability,protocol,protocols,10,// Import protocols,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp:47,Integrability,protocol,protocol,47,"// FIXME: If we're merging, make sure that the protocol list is the same.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp:37,Integrability,protocol,protocol,37,// Import all of the members of this protocol.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp:11,Integrability,protocol,protocol,11,"// If this protocol has a definition in the translation unit we're coming; // from, but this particular declaration is not that definition, import the; // definition and map to that.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp:56,Integrability,protocol,protocol,56,// Import the major distinguishing characteristics of a protocol.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp:20,Availability,error,error,20,// FIXME: We return error here but the definition is already created; // and available with lookups. How to fix this?..,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp:77,Availability,avail,available,77,// FIXME: We return error here but the definition is already created; // and available with lookups. How to fix this?..,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp:20,Availability,error,error,20,// FIXME: We return error here but the definition is already created; // and available with lookups. How to fix this?..,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp:77,Availability,avail,available,77,// FIXME: We return error here but the definition is already created; // and available with lookups. How to fix this?..,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp:10,Integrability,protocol,protocols,10,// Import protocols,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp:47,Integrability,protocol,protocol,47,"// FIXME: If we're merging, make sure that the protocol list is the same.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp:105,Integrability,interface,interface,105,"// Import categories. When the categories themselves are imported, they'll; // hook themselves into this interface.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp:58,Integrability,interface,interface,58,// Import the major distinguishing characteristics of an @interface.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp:24,Integrability,interface,interface,24,// Look for an existing interface with the same name.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp:13,Integrability,interface,interface,13,"// Create an interface declaration, if one does not already exist.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp:56,Safety,avoid,avoid,56,"// Import the type parameter list after MapImported, to avoid; // loops when bringing in their DeclContext.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp:26,Integrability,interface,interface,26,// Find the corresponding interface.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp:48,Integrability,depend,dependent,48,"// Should check if a declaration is friend in a dependent context.; // Such templates are not linked together in a declaration chain.; // The ASTImporter strategy is to map existing forward declarations to; // imported ones only if strictly necessary, otherwise import these as new; // forward declarations. In case of the ""dependent friend"" declarations, new; // declarations are created, but not linked in a declaration chain.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp:324,Integrability,depend,dependent,324,"// Should check if a declaration is friend in a dependent context.; // Such templates are not linked together in a declaration chain.; // The ASTImporter strategy is to map existing forward declarations to; // imported ones only if strictly necessary, otherwise import these as new; // forward declarations. In case of the ""dependent friend"" declarations, new; // declarations are created, but not linked in a declaration chain.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp:85,Testability,test,test,85,"// Search in all matches because there may be multiple decl chains,; // see ASTTests test ImportExistingFriendClassTemplateDef.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp:3,Deployability,Update,Update,3,"// Update InsertPos, because preceding import calls may have invalidated; // it by adding new specializations.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp:3,Deployability,Update,Update,3,"// Update InsertPos, because preceding import calls may have invalidated; // it by adding new specializations.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp:59,Modifiability,variab,variable,59,// Import the major distinguishing characteristics of this variable template.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp:23,Availability,error,error,23,// FIXME Check for ODR error if the two definitions have; // different initializers?,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp:14,Modifiability,variab,variable,14,// Create the variable template declaration itself.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp:143,Availability,error,errors,143,// We already have a variable template specialization with these template; // arguments.; // FIXME: Check for specialization vs. instantiation errors.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp:21,Modifiability,variab,variable,21,// We already have a variable template specialization with these template; // arguments.; // FIXME: Check for specialization vs. instantiation errors.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp:135,Modifiability,variab,variable,135,"// The record types structurally match, or the ""from"" translation; // unit only had a forward declaration anyway; call it the same; // variable.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp:19,Deployability,update,update,19,// FIXME: Use this update if VarTemplatePartialSpecializationDecl is fixed; // to adopt template parameters.; // updateLookupTableForTemplateParameters(**ToTPListOrErr);,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp:113,Deployability,update,updateLookupTableForTemplateParameters,113,// FIXME: Use this update if VarTemplatePartialSpecializationDecl is fixed; // to adopt template parameters.; // updateLookupTableForTemplateParameters(**ToTPListOrErr);,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp:155,Deployability,update,updated,155,"// At creation of the template the template parameters are ""adopted""; // (DeclContext is changed). After this possible change the lookup table; // must be updated.; // At deduction guides the DeclContext of the template parameters may be; // different from what we would expect, it may be the class template, or a; // probably different CXXDeductionGuideDecl. This may come from the fact that; // the template parameter objects may be shared between deduction guides or; // the class template, and at creation of multiple FunctionTemplateDecl; // objects (for deduction guides) the same parameters are re-used. The; // ""adoption"" happens multiple times with different parent, even recursively; // for TemplateTemplateParmDecl. The same happens at import when the; // FunctionTemplateDecl objects are created, but in different order.; // In this way the DeclContext of these template parameters is not necessarily; // the same as in the ""from"" context.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp:181,Usability,guid,guides,181,"// At creation of the template the template parameters are ""adopted""; // (DeclContext is changed). After this possible change the lookup table; // must be updated.; // At deduction guides the DeclContext of the template parameters may be; // different from what we would expect, it may be the class template, or a; // probably different CXXDeductionGuideDecl. This may come from the fact that; // the template parameter objects may be shared between deduction guides or; // the class template, and at creation of multiple FunctionTemplateDecl; // objects (for deduction guides) the same parameters are re-used. The; // ""adoption"" happens multiple times with different parent, even recursively; // for TemplateTemplateParmDecl. The same happens at import when the; // FunctionTemplateDecl objects are created, but in different order.; // In this way the DeclContext of these template parameters is not necessarily; // the same as in the ""from"" context.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp:460,Usability,guid,guides,460,"// At creation of the template the template parameters are ""adopted""; // (DeclContext is changed). After this possible change the lookup table; // must be updated.; // At deduction guides the DeclContext of the template parameters may be; // different from what we would expect, it may be the class template, or a; // probably different CXXDeductionGuideDecl. This may come from the fact that; // the template parameter objects may be shared between deduction guides or; // the class template, and at creation of multiple FunctionTemplateDecl; // objects (for deduction guides) the same parameters are re-used. The; // ""adoption"" happens multiple times with different parent, even recursively; // for TemplateTemplateParmDecl. The same happens at import when the; // FunctionTemplateDecl objects are created, but in different order.; // In this way the DeclContext of these template parameters is not necessarily; // the same as in the ""from"" context.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp:570,Usability,guid,guides,570,"// At creation of the template the template parameters are ""adopted""; // (DeclContext is changed). After this possible change the lookup table; // must be updated.; // At deduction guides the DeclContext of the template parameters may be; // different from what we would expect, it may be the class template, or a; // probably different CXXDeductionGuideDecl. This may come from the fact that; // the template parameter objects may be shared between deduction guides or; // the class template, and at creation of multiple FunctionTemplateDecl; // objects (for deduction guides) the same parameters are re-used. The; // ""adoption"" happens multiple times with different parent, even recursively; // for TemplateTemplateParmDecl. The same happens at import when the; // FunctionTemplateDecl objects are created, but in different order.; // In this way the DeclContext of these template parameters is not necessarily; // the same as in the ""from"" context.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp:74,Integrability,depend,dependent,74,// The value of CondIsTrue only matters if the value is not; // condition-dependent.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp:54,Integrability,depend,dependent,54,"// According to Sema::BuildTypeTrait(), if E is value-dependent,; // Value is always false.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp:176,Modifiability,variab,variable,176,"// We search in the redecl context because of transparent contexts.; // E.g. a simple C language enum is a transparent context:; // enum E { A, B };; // Now if we had a global variable in the TU; // int A;; // then the enum constant 'A' and the variable 'A' violates ODR.; // We can diagnose this only if we search in the redecl context.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp:245,Modifiability,variab,variable,245,"// We search in the redecl context because of transparent contexts.; // E.g. a simple C language enum is a transparent context:; // enum E { A, B };; // Now if we had a global variable in the TU; // int A;; // then the enum constant 'A' and the variable 'A' violates ODR.; // We can diagnose this only if we search in the redecl context.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp:79,Usability,simpl,simple,79,"// We search in the redecl context because of transparent contexts.; // E.g. a simple C language enum is a transparent context:; // enum E { A, B };; // Now if we had a global variable in the TU; // int A;; // then the enum constant 'A' and the variable 'A' violates ODR.; // We can diagnose this only if we search in the redecl context.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp:203,Performance,load,load,203,"// We must search by the slow case of localUncachedLookup because that is; // working even if there is no LookupPtr for the DC. We could use; // DC::buildLookup() to create the LookupPtr, but that would load external; // decls again, we must avoid that case.; // Also, even if we had the LookupPtr, we must find Decls which are not; // in the LookupPtr, so we need the slow case.; // These cases are handled in ASTImporterLookupTable, but we cannot use; // that with LLDB since that traverses through the AST which initiates the; // load of external decls again via DC::decls(). And again, we must avoid; // loading external decls during the import.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp:533,Performance,load,load,533,"// We must search by the slow case of localUncachedLookup because that is; // working even if there is no LookupPtr for the DC. We could use; // DC::buildLookup() to create the LookupPtr, but that would load external; // decls again, we must avoid that case.; // Also, even if we had the LookupPtr, we must find Decls which are not; // in the LookupPtr, so we need the slow case.; // These cases are handled in ASTImporterLookupTable, but we cannot use; // that with LLDB since that traverses through the AST which initiates the; // load of external decls again via DC::decls(). And again, we must avoid; // loading external decls during the import.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp:608,Performance,load,loading,608,"// We must search by the slow case of localUncachedLookup because that is; // working even if there is no LookupPtr for the DC. We could use; // DC::buildLookup() to create the LookupPtr, but that would load external; // decls again, we must avoid that case.; // Also, even if we had the LookupPtr, we must find Decls which are not; // in the LookupPtr, so we need the slow case.; // These cases are handled in ASTImporterLookupTable, but we cannot use; // that with LLDB since that traverses through the AST which initiates the; // load of external decls again via DC::decls(). And again, we must avoid; // loading external decls during the import.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp:242,Safety,avoid,avoid,242,"// We must search by the slow case of localUncachedLookup because that is; // working even if there is no LookupPtr for the DC. We could use; // DC::buildLookup() to create the LookupPtr, but that would load external; // decls again, we must avoid that case.; // Also, even if we had the LookupPtr, we must find Decls which are not; // in the LookupPtr, so we need the slow case.; // These cases are handled in ASTImporterLookupTable, but we cannot use; // that with LLDB since that traverses through the AST which initiates the; // load of external decls again via DC::decls(). And again, we must avoid; // loading external decls during the import.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp:598,Safety,avoid,avoid,598,"// We must search by the slow case of localUncachedLookup because that is; // working even if there is no LookupPtr for the DC. We could use; // DC::buildLookup() to create the LookupPtr, but that would load external; // decls again, we must avoid that case.; // Also, even if we had the LookupPtr, we must find Decls which are not; // in the LookupPtr, so we need the slow case.; // These cases are handled in ASTImporterLookupTable, but we cannot use; // that with LLDB since that traverses through the AST which initiates the; // load of external decls again via DC::decls(). And again, we must avoid; // loading external decls during the import.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp:146,Performance,perform,performs,146,"// To use this object, it should be created before the new attribute is created,; // and destructed after it is created. The construction already performs the; // import of the data.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp:146,Performance,perform,performs,146,"// To use this object, it should be created before the new attribute is created,; // and destructed after it is created. The construction already performs the; // import of the data. The array data is accessible in a pointer form, this form; // is used by the attribute classes. This object should be created once for the; // array data to be imported (the array size is not imported, just copied).",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp:201,Security,access,accessible,201,"// To use this object, it should be created before the new attribute is created,; // and destructed after it is created. The construction already performs the; // import of the data. The array data is accessible in a pointer form, this form; // is used by the attribute classes. This object should be created once for the; // array data to be imported (the array size is not imported, just copied).",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp:14,Security,access,accessing,14,// Useful for accessing the imported attribute.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp:452,Availability,error,error,452,"// Create an attribute object with the specified arguments.; // The 'FromAttr' is the original (not imported) attribute, the 'ImportedArg'; // should be values that are passed to the 'Create' function of the attribute.; // (The 'Create' with 'ASTContext' first and 'AttributeCommonInfo' last is; // used here.) As much data is copied or imported from the old attribute; // as possible. The passed arguments should be already imported.; // If an import error happens, the internal error is set to it, and any; // further import attempt is ignored.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp:480,Availability,error,error,480,"// Create an attribute object with the specified arguments.; // The 'FromAttr' is the original (not imported) attribute, the 'ImportedArg'; // should be values that are passed to the 'Create' function of the attribute.; // (The 'Create' with 'ASTContext' first and 'AttributeCommonInfo' last is; // used here.) As much data is copied or imported from the old attribute; // as possible. The passed arguments should be already imported.; // If an import error happens, the internal error is set to it, and any; // further import attempt is ignored.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp:84,Availability,error,error,84,// Check whether there was a previous failed import.; // If yes return the existing error.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp:59,Availability,error,error,59,// Already imported (possibly from another TU) and with an error.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp:21,Deployability,update,updated,21,"// If FromD has some updated flags after last import, apply it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp:179,Availability,error,error,179,"// FIXME: AST may contain remaining references to the failed object.; // However, the ImportDeclErrors in the shared state contains all the; // failed objects together with their error.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp:3,Availability,Error,Error,3,// Error encountered for the first time.; // After takeError the error is not usable any more in ToDOrErr.; // Get a copy of the error object (any more simple solution for this?).,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp:65,Availability,error,error,65,// Error encountered for the first time.; // After takeError the error is not usable any more in ToDOrErr.; // Get a copy of the error object (any more simple solution for this?).,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp:129,Availability,error,error,129,// Error encountered for the first time.; // After takeError the error is not usable any more in ToDOrErr.; // Get a copy of the error object (any more simple solution for this?).,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp:78,Usability,usab,usable,78,// Error encountered for the first time.; // After takeError the error is not usable any more in ToDOrErr.; // Get a copy of the error object (any more simple solution for this?).,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp:152,Usability,simpl,simple,152,// Error encountered for the first time.; // After takeError the error is not usable any more in ToDOrErr.; // Get a copy of the error object (any more simple solution for this?).,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp:11,Availability,error,error,11,"// Set the error for the mapped to Decl, which is in the ""to"" context.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp:11,Availability,error,error,11,// Set the error for all nodes which have been created before we; // recognized the error.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp:84,Availability,error,error,84,// Set the error for all nodes which have been created before we; // recognized the error.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp:35,Integrability,depend,dependency,35,// The import path contains import-dependency nodes first.; // Save the node that was imported as dependency of the current node.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp:98,Integrability,depend,dependency,98,// The import path contains import-dependency nodes first.; // Save the node that was imported as dependency of the current node.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp:28,Availability,error,error,28,// We should not set import error on a node and all following nodes in; // the path if child import errors are ignored.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp:100,Availability,error,errors,100,// We should not set import error on a node and all following nodes in; // the path if child import errors are ignored.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp:69,Availability,error,error,69,"//FIXME Should we remove these Decls from ImportedDecls?; // Set the error for the mapped to Decl, which is in the ""to"" context.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp:27,Availability,error,error,27,"// Do not return ToDOrErr, error was taken out of it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp:44,Availability,error,error,44,"// FIXME: Handle the ""already imported with error"" case. We can get here; // nullptr only if GetImportedOrCreateDecl returned nullptr (after a; // previously failed create was requested).; // Later GetImportedOrCreateDecl can be updated to return the error.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp:251,Availability,error,error,251,"// FIXME: Handle the ""already imported with error"" case. We can get here; // nullptr only if GetImportedOrCreateDecl returned nullptr (after a; // previously failed create was requested).; // Later GetImportedOrCreateDecl can be updated to return the error.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp:229,Deployability,update,updated,229,"// FIXME: Handle the ""already imported with error"" case. We can get here; // nullptr only if GetImportedOrCreateDecl returned nullptr (after a; // previously failed create was requested).; // Later GetImportedOrCreateDecl can be updated to return the error.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp:47,Availability,error,error,47,// We could import from the current TU without error. But previously we; // already had imported a Decl as `ToD` from another TU (with another; // ASTImporter object) and with an error.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp:179,Availability,error,error,179,// We could import from the current TU without error. But previously we; // already had imported a Decl as `ToD` from another TU (with another; // ASTImporter object) and with an error.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp:52,Integrability,protocol,protocol,52,"// When we're using a record/enum/Objective-C class/protocol as a context, we; // need it to have a definition.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp:289,Modifiability,inherit,inherit,289,// If FromRecord is not defined we need to force it to be.; // Simply calling CompleteDecl(...) for a RecordDecl will break some cases; // it will start the definition but we never finish it.; // If there are base classes they won't be imported and we will; // be missing anything that we inherit from those bases.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp:63,Usability,Simpl,Simply,63,// If FromRecord is not defined we need to force it to be.; // Simply calling CompleteDecl(...) for a RecordDecl will break some cases; // it will start the definition but we never finish it.; // If there are base classes they won't be imported and we will; // be missing anything that we inherit from those bases.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp:10,Testability,assert,assert,10,// FIXME: assert?,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp:10,Availability,error,error,10,// Report error at any name conflict.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp:21,Availability,error,error,21,"// Either we set the error for the first time, or we already had set one and; // now we want to set the same error.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp:109,Availability,error,error,109,"// Either we set the error for the first time, or we already had set one and; // now we want to set the same error.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTImporterLookupTable.cpp:23,Integrability,depend,dependent,23,"// A FriendDecl with a dependent type (e.g. ClassTemplateSpecialization); // always has that decl as child node.; // However, there are non-dependent cases which does not have the; // type as a child node. We have to dig up that type now.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ASTImporterLookupTable.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTImporterLookupTable.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTImporterLookupTable.cpp:140,Integrability,depend,dependent,140,"// A FriendDecl with a dependent type (e.g. ClassTemplateSpecialization); // always has that decl as child node.; // However, there are non-dependent cases which does not have the; // type as a child node. We have to dig up that type now.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ASTImporterLookupTable.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTImporterLookupTable.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTStructuralEquivalence.cpp:773,Performance,Queue,Queue,773,"//===- ASTStructuralEquivalence.cpp ---------------------------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implement StructuralEquivalenceContext class and helper functions; // for layout matching.; //; // The structural equivalence check could have been implemented as a parallel; // BFS on a pair of graphs. That must have been the original approach at the; // beginning.; // Let's consider this simple BFS algorithm from the `s` source:; // ```; // void bfs(Graph G, int s); // {; // Queue<Integer> queue = new Queue<Integer>();; // marked[s] = true; // Mark the source; // queue.enqueue(s); // and put it on the queue.; // while (!q.isEmpty()) {; // int v = queue.dequeue(); // Remove next vertex from the queue.; // for (int w : G.adj(v)); // if (!marked[w]) // For every unmarked adjacent vertex,; // {; // marked[w] = true;; // queue.enqueue(w);; // }; // }; // }; // ```; // Indeed, it has it's queue, which holds pairs of nodes, one from each graph,; // this is the `DeclsToCheck` member. `VisitedDecls` plays the role of the; // marking (`marked`) functionality above, we use it to check whether we've; // already seen a pair of nodes.; //; // We put in the elements into the queue only in the toplevel decl check; // function:; // ```; // static bool IsStructurallyEquivalent(StructuralEquivalenceContext &Context,; // Decl *D1, Decl *D2);; // ```; // The `while` loop where we iterate over the children is implemented in; // `Finish()`. And `Finish` is called only from the two **member** functions; // which check the equivalency of two Decls or two Types. ASTImporter (and; // other clients) call only these functions.; //; // The `static` implementation functions are called from `Finish`, these push",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ASTStructuralEquivalence.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTStructuralEquivalence.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTStructuralEquivalence.cpp:788,Performance,queue,queue,788,"//===- ASTStructuralEquivalence.cpp ---------------------------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implement StructuralEquivalenceContext class and helper functions; // for layout matching.; //; // The structural equivalence check could have been implemented as a parallel; // BFS on a pair of graphs. That must have been the original approach at the; // beginning.; // Let's consider this simple BFS algorithm from the `s` source:; // ```; // void bfs(Graph G, int s); // {; // Queue<Integer> queue = new Queue<Integer>();; // marked[s] = true; // Mark the source; // queue.enqueue(s); // and put it on the queue.; // while (!q.isEmpty()) {; // int v = queue.dequeue(); // Remove next vertex from the queue.; // for (int w : G.adj(v)); // if (!marked[w]) // For every unmarked adjacent vertex,; // {; // marked[w] = true;; // queue.enqueue(w);; // }; // }; // }; // ```; // Indeed, it has it's queue, which holds pairs of nodes, one from each graph,; // this is the `DeclsToCheck` member. `VisitedDecls` plays the role of the; // marking (`marked`) functionality above, we use it to check whether we've; // already seen a pair of nodes.; //; // We put in the elements into the queue only in the toplevel decl check; // function:; // ```; // static bool IsStructurallyEquivalent(StructuralEquivalenceContext &Context,; // Decl *D1, Decl *D2);; // ```; // The `while` loop where we iterate over the children is implemented in; // `Finish()`. And `Finish` is called only from the two **member** functions; // which check the equivalency of two Decls or two Types. ASTImporter (and; // other clients) call only these functions.; //; // The `static` implementation functions are called from `Finish`, these push",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ASTStructuralEquivalence.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTStructuralEquivalence.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTStructuralEquivalence.cpp:800,Performance,Queue,Queue,800,"//===- ASTStructuralEquivalence.cpp ---------------------------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implement StructuralEquivalenceContext class and helper functions; // for layout matching.; //; // The structural equivalence check could have been implemented as a parallel; // BFS on a pair of graphs. That must have been the original approach at the; // beginning.; // Let's consider this simple BFS algorithm from the `s` source:; // ```; // void bfs(Graph G, int s); // {; // Queue<Integer> queue = new Queue<Integer>();; // marked[s] = true; // Mark the source; // queue.enqueue(s); // and put it on the queue.; // while (!q.isEmpty()) {; // int v = queue.dequeue(); // Remove next vertex from the queue.; // for (int w : G.adj(v)); // if (!marked[w]) // For every unmarked adjacent vertex,; // {; // marked[w] = true;; // queue.enqueue(w);; // }; // }; // }; // ```; // Indeed, it has it's queue, which holds pairs of nodes, one from each graph,; // this is the `DeclsToCheck` member. `VisitedDecls` plays the role of the; // marking (`marked`) functionality above, we use it to check whether we've; // already seen a pair of nodes.; //; // We put in the elements into the queue only in the toplevel decl check; // function:; // ```; // static bool IsStructurallyEquivalent(StructuralEquivalenceContext &Context,; // Decl *D1, Decl *D2);; // ```; // The `while` loop where we iterate over the children is implemented in; // `Finish()`. And `Finish` is called only from the two **member** functions; // which check the equivalency of two Decls or two Types. ASTImporter (and; // other clients) call only these functions.; //; // The `static` implementation functions are called from `Finish`, these push",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ASTStructuralEquivalence.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTStructuralEquivalence.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTStructuralEquivalence.cpp:863,Performance,queue,queue,863,"//===- ASTStructuralEquivalence.cpp ---------------------------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implement StructuralEquivalenceContext class and helper functions; // for layout matching.; //; // The structural equivalence check could have been implemented as a parallel; // BFS on a pair of graphs. That must have been the original approach at the; // beginning.; // Let's consider this simple BFS algorithm from the `s` source:; // ```; // void bfs(Graph G, int s); // {; // Queue<Integer> queue = new Queue<Integer>();; // marked[s] = true; // Mark the source; // queue.enqueue(s); // and put it on the queue.; // while (!q.isEmpty()) {; // int v = queue.dequeue(); // Remove next vertex from the queue.; // for (int w : G.adj(v)); // if (!marked[w]) // For every unmarked adjacent vertex,; // {; // marked[w] = true;; // queue.enqueue(w);; // }; // }; // }; // ```; // Indeed, it has it's queue, which holds pairs of nodes, one from each graph,; // this is the `DeclsToCheck` member. `VisitedDecls` plays the role of the; // marking (`marked`) functionality above, we use it to check whether we've; // already seen a pair of nodes.; //; // We put in the elements into the queue only in the toplevel decl check; // function:; // ```; // static bool IsStructurallyEquivalent(StructuralEquivalenceContext &Context,; // Decl *D1, Decl *D2);; // ```; // The `while` loop where we iterate over the children is implemented in; // `Finish()`. And `Finish` is called only from the two **member** functions; // which check the equivalency of two Decls or two Types. ASTImporter (and; // other clients) call only these functions.; //; // The `static` implementation functions are called from `Finish`, these push",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ASTStructuralEquivalence.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTStructuralEquivalence.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTStructuralEquivalence.cpp:902,Performance,queue,queue,902,"//===- ASTStructuralEquivalence.cpp ---------------------------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implement StructuralEquivalenceContext class and helper functions; // for layout matching.; //; // The structural equivalence check could have been implemented as a parallel; // BFS on a pair of graphs. That must have been the original approach at the; // beginning.; // Let's consider this simple BFS algorithm from the `s` source:; // ```; // void bfs(Graph G, int s); // {; // Queue<Integer> queue = new Queue<Integer>();; // marked[s] = true; // Mark the source; // queue.enqueue(s); // and put it on the queue.; // while (!q.isEmpty()) {; // int v = queue.dequeue(); // Remove next vertex from the queue.; // for (int w : G.adj(v)); // if (!marked[w]) // For every unmarked adjacent vertex,; // {; // marked[w] = true;; // queue.enqueue(w);; // }; // }; // }; // ```; // Indeed, it has it's queue, which holds pairs of nodes, one from each graph,; // this is the `DeclsToCheck` member. `VisitedDecls` plays the role of the; // marking (`marked`) functionality above, we use it to check whether we've; // already seen a pair of nodes.; //; // We put in the elements into the queue only in the toplevel decl check; // function:; // ```; // static bool IsStructurallyEquivalent(StructuralEquivalenceContext &Context,; // Decl *D1, Decl *D2);; // ```; // The `while` loop where we iterate over the children is implemented in; // `Finish()`. And `Finish` is called only from the two **member** functions; // which check the equivalency of two Decls or two Types. ASTImporter (and; // other clients) call only these functions.; //; // The `static` implementation functions are called from `Finish`, these push",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ASTStructuralEquivalence.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTStructuralEquivalence.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTStructuralEquivalence.cpp:948,Performance,queue,queue,948,"//===- ASTStructuralEquivalence.cpp ---------------------------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implement StructuralEquivalenceContext class and helper functions; // for layout matching.; //; // The structural equivalence check could have been implemented as a parallel; // BFS on a pair of graphs. That must have been the original approach at the; // beginning.; // Let's consider this simple BFS algorithm from the `s` source:; // ```; // void bfs(Graph G, int s); // {; // Queue<Integer> queue = new Queue<Integer>();; // marked[s] = true; // Mark the source; // queue.enqueue(s); // and put it on the queue.; // while (!q.isEmpty()) {; // int v = queue.dequeue(); // Remove next vertex from the queue.; // for (int w : G.adj(v)); // if (!marked[w]) // For every unmarked adjacent vertex,; // {; // marked[w] = true;; // queue.enqueue(w);; // }; // }; // }; // ```; // Indeed, it has it's queue, which holds pairs of nodes, one from each graph,; // this is the `DeclsToCheck` member. `VisitedDecls` plays the role of the; // marking (`marked`) functionality above, we use it to check whether we've; // already seen a pair of nodes.; //; // We put in the elements into the queue only in the toplevel decl check; // function:; // ```; // static bool IsStructurallyEquivalent(StructuralEquivalenceContext &Context,; // Decl *D1, Decl *D2);; // ```; // The `while` loop where we iterate over the children is implemented in; // `Finish()`. And `Finish` is called only from the two **member** functions; // which check the equivalency of two Decls or two Types. ASTImporter (and; // other clients) call only these functions.; //; // The `static` implementation functions are called from `Finish`, these push",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ASTStructuralEquivalence.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTStructuralEquivalence.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTStructuralEquivalence.cpp:996,Performance,queue,queue,996,"//===- ASTStructuralEquivalence.cpp ---------------------------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implement StructuralEquivalenceContext class and helper functions; // for layout matching.; //; // The structural equivalence check could have been implemented as a parallel; // BFS on a pair of graphs. That must have been the original approach at the; // beginning.; // Let's consider this simple BFS algorithm from the `s` source:; // ```; // void bfs(Graph G, int s); // {; // Queue<Integer> queue = new Queue<Integer>();; // marked[s] = true; // Mark the source; // queue.enqueue(s); // and put it on the queue.; // while (!q.isEmpty()) {; // int v = queue.dequeue(); // Remove next vertex from the queue.; // for (int w : G.adj(v)); // if (!marked[w]) // For every unmarked adjacent vertex,; // {; // marked[w] = true;; // queue.enqueue(w);; // }; // }; // }; // ```; // Indeed, it has it's queue, which holds pairs of nodes, one from each graph,; // this is the `DeclsToCheck` member. `VisitedDecls` plays the role of the; // marking (`marked`) functionality above, we use it to check whether we've; // already seen a pair of nodes.; //; // We put in the elements into the queue only in the toplevel decl check; // function:; // ```; // static bool IsStructurallyEquivalent(StructuralEquivalenceContext &Context,; // Decl *D1, Decl *D2);; // ```; // The `while` loop where we iterate over the children is implemented in; // `Finish()`. And `Finish` is called only from the two **member** functions; // which check the equivalency of two Decls or two Types. ASTImporter (and; // other clients) call only these functions.; //; // The `static` implementation functions are called from `Finish`, these push",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ASTStructuralEquivalence.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTStructuralEquivalence.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTStructuralEquivalence.cpp:1121,Performance,queue,queue,1121,"-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implement StructuralEquivalenceContext class and helper functions; // for layout matching.; //; // The structural equivalence check could have been implemented as a parallel; // BFS on a pair of graphs. That must have been the original approach at the; // beginning.; // Let's consider this simple BFS algorithm from the `s` source:; // ```; // void bfs(Graph G, int s); // {; // Queue<Integer> queue = new Queue<Integer>();; // marked[s] = true; // Mark the source; // queue.enqueue(s); // and put it on the queue.; // while (!q.isEmpty()) {; // int v = queue.dequeue(); // Remove next vertex from the queue.; // for (int w : G.adj(v)); // if (!marked[w]) // For every unmarked adjacent vertex,; // {; // marked[w] = true;; // queue.enqueue(w);; // }; // }; // }; // ```; // Indeed, it has it's queue, which holds pairs of nodes, one from each graph,; // this is the `DeclsToCheck` member. `VisitedDecls` plays the role of the; // marking (`marked`) functionality above, we use it to check whether we've; // already seen a pair of nodes.; //; // We put in the elements into the queue only in the toplevel decl check; // function:; // ```; // static bool IsStructurallyEquivalent(StructuralEquivalenceContext &Context,; // Decl *D1, Decl *D2);; // ```; // The `while` loop where we iterate over the children is implemented in; // `Finish()`. And `Finish` is called only from the two **member** functions; // which check the equivalency of two Decls or two Types. ASTImporter (and; // other clients) call only these functions.; //; // The `static` implementation functions are called from `Finish`, these push; // the children nodes to the queue via `static bool; // IsStructurallyEq",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ASTStructuralEquivalence.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTStructuralEquivalence.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTStructuralEquivalence.cpp:1189,Performance,queue,queue,1189,"or license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implement StructuralEquivalenceContext class and helper functions; // for layout matching.; //; // The structural equivalence check could have been implemented as a parallel; // BFS on a pair of graphs. That must have been the original approach at the; // beginning.; // Let's consider this simple BFS algorithm from the `s` source:; // ```; // void bfs(Graph G, int s); // {; // Queue<Integer> queue = new Queue<Integer>();; // marked[s] = true; // Mark the source; // queue.enqueue(s); // and put it on the queue.; // while (!q.isEmpty()) {; // int v = queue.dequeue(); // Remove next vertex from the queue.; // for (int w : G.adj(v)); // if (!marked[w]) // For every unmarked adjacent vertex,; // {; // marked[w] = true;; // queue.enqueue(w);; // }; // }; // }; // ```; // Indeed, it has it's queue, which holds pairs of nodes, one from each graph,; // this is the `DeclsToCheck` member. `VisitedDecls` plays the role of the; // marking (`marked`) functionality above, we use it to check whether we've; // already seen a pair of nodes.; //; // We put in the elements into the queue only in the toplevel decl check; // function:; // ```; // static bool IsStructurallyEquivalent(StructuralEquivalenceContext &Context,; // Decl *D1, Decl *D2);; // ```; // The `while` loop where we iterate over the children is implemented in; // `Finish()`. And `Finish` is called only from the two **member** functions; // which check the equivalency of two Decls or two Types. ASTImporter (and; // other clients) call only these functions.; //; // The `static` implementation functions are called from `Finish`, these push; // the children nodes to the queue via `static bool; // IsStructurallyEquivalent(StructuralEquivalenceContext &Context, Decl *D1,; // Decl *D2)`. So far so good, this is almost like the BFS. However, if",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ASTStructuralEquivalence.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTStructuralEquivalence.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTStructuralEquivalence.cpp:1472,Performance,queue,queue,1472,"ir of graphs. That must have been the original approach at the; // beginning.; // Let's consider this simple BFS algorithm from the `s` source:; // ```; // void bfs(Graph G, int s); // {; // Queue<Integer> queue = new Queue<Integer>();; // marked[s] = true; // Mark the source; // queue.enqueue(s); // and put it on the queue.; // while (!q.isEmpty()) {; // int v = queue.dequeue(); // Remove next vertex from the queue.; // for (int w : G.adj(v)); // if (!marked[w]) // For every unmarked adjacent vertex,; // {; // marked[w] = true;; // queue.enqueue(w);; // }; // }; // }; // ```; // Indeed, it has it's queue, which holds pairs of nodes, one from each graph,; // this is the `DeclsToCheck` member. `VisitedDecls` plays the role of the; // marking (`marked`) functionality above, we use it to check whether we've; // already seen a pair of nodes.; //; // We put in the elements into the queue only in the toplevel decl check; // function:; // ```; // static bool IsStructurallyEquivalent(StructuralEquivalenceContext &Context,; // Decl *D1, Decl *D2);; // ```; // The `while` loop where we iterate over the children is implemented in; // `Finish()`. And `Finish` is called only from the two **member** functions; // which check the equivalency of two Decls or two Types. ASTImporter (and; // other clients) call only these functions.; //; // The `static` implementation functions are called from `Finish`, these push; // the children nodes to the queue via `static bool; // IsStructurallyEquivalent(StructuralEquivalenceContext &Context, Decl *D1,; // Decl *D2)`. So far so good, this is almost like the BFS. However, if we; // let a static implementation function to call `Finish` via another **member**; // function that means we end up with two nested while loops each of them; // working on the same queue. This is wrong and nobody can reason about it's; // doing. Thus, static implementation functions must not call the **member**; // functions.; //; //===-------------------------------------",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ASTStructuralEquivalence.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTStructuralEquivalence.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTStructuralEquivalence.cpp:2032,Performance,queue,queue,2032,"riginal approach at the; // beginning.; // Let's consider this simple BFS algorithm from the `s` source:; // ```; // void bfs(Graph G, int s); // {; // Queue<Integer> queue = new Queue<Integer>();; // marked[s] = true; // Mark the source; // queue.enqueue(s); // and put it on the queue.; // while (!q.isEmpty()) {; // int v = queue.dequeue(); // Remove next vertex from the queue.; // for (int w : G.adj(v)); // if (!marked[w]) // For every unmarked adjacent vertex,; // {; // marked[w] = true;; // queue.enqueue(w);; // }; // }; // }; // ```; // Indeed, it has it's queue, which holds pairs of nodes, one from each graph,; // this is the `DeclsToCheck` member. `VisitedDecls` plays the role of the; // marking (`marked`) functionality above, we use it to check whether we've; // already seen a pair of nodes.; //; // We put in the elements into the queue only in the toplevel decl check; // function:; // ```; // static bool IsStructurallyEquivalent(StructuralEquivalenceContext &Context,; // Decl *D1, Decl *D2);; // ```; // The `while` loop where we iterate over the children is implemented in; // `Finish()`. And `Finish` is called only from the two **member** functions; // which check the equivalency of two Decls or two Types. ASTImporter (and; // other clients) call only these functions.; //; // The `static` implementation functions are called from `Finish`, these push; // the children nodes to the queue via `static bool; // IsStructurallyEquivalent(StructuralEquivalenceContext &Context, Decl *D1,; // Decl *D2)`. So far so good, this is almost like the BFS. However, if we; // let a static implementation function to call `Finish` via another **member**; // function that means we end up with two nested while loops each of them; // working on the same queue. This is wrong and nobody can reason about it's; // doing. Thus, static implementation functions must not call the **member**; // functions.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ASTStructuralEquivalence.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTStructuralEquivalence.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTStructuralEquivalence.cpp:2389,Performance,queue,queue,2389,"riginal approach at the; // beginning.; // Let's consider this simple BFS algorithm from the `s` source:; // ```; // void bfs(Graph G, int s); // {; // Queue<Integer> queue = new Queue<Integer>();; // marked[s] = true; // Mark the source; // queue.enqueue(s); // and put it on the queue.; // while (!q.isEmpty()) {; // int v = queue.dequeue(); // Remove next vertex from the queue.; // for (int w : G.adj(v)); // if (!marked[w]) // For every unmarked adjacent vertex,; // {; // marked[w] = true;; // queue.enqueue(w);; // }; // }; // }; // ```; // Indeed, it has it's queue, which holds pairs of nodes, one from each graph,; // this is the `DeclsToCheck` member. `VisitedDecls` plays the role of the; // marking (`marked`) functionality above, we use it to check whether we've; // already seen a pair of nodes.; //; // We put in the elements into the queue only in the toplevel decl check; // function:; // ```; // static bool IsStructurallyEquivalent(StructuralEquivalenceContext &Context,; // Decl *D1, Decl *D2);; // ```; // The `while` loop where we iterate over the children is implemented in; // `Finish()`. And `Finish` is called only from the two **member** functions; // which check the equivalency of two Decls or two Types. ASTImporter (and; // other clients) call only these functions.; //; // The `static` implementation functions are called from `Finish`, these push; // the children nodes to the queue via `static bool; // IsStructurallyEquivalent(StructuralEquivalenceContext &Context, Decl *D1,; // Decl *D2)`. So far so good, this is almost like the BFS. However, if we; // let a static implementation function to call `Finish` via another **member**; // function that means we end up with two nested while loops each of them; // working on the same queue. This is wrong and nobody can reason about it's; // doing. Thus, static implementation functions must not call the **member**; // functions.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ASTStructuralEquivalence.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTStructuralEquivalence.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTStructuralEquivalence.cpp:684,Usability,simpl,simple,684,"//===- ASTStructuralEquivalence.cpp ---------------------------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implement StructuralEquivalenceContext class and helper functions; // for layout matching.; //; // The structural equivalence check could have been implemented as a parallel; // BFS on a pair of graphs. That must have been the original approach at the; // beginning.; // Let's consider this simple BFS algorithm from the `s` source:; // ```; // void bfs(Graph G, int s); // {; // Queue<Integer> queue = new Queue<Integer>();; // marked[s] = true; // Mark the source; // queue.enqueue(s); // and put it on the queue.; // while (!q.isEmpty()) {; // int v = queue.dequeue(); // Remove next vertex from the queue.; // for (int w : G.adj(v)); // if (!marked[w]) // For every unmarked adjacent vertex,; // {; // marked[w] = true;; // queue.enqueue(w);; // }; // }; // }; // ```; // Indeed, it has it's queue, which holds pairs of nodes, one from each graph,; // this is the `DeclsToCheck` member. `VisitedDecls` plays the role of the; // marking (`marked`) functionality above, we use it to check whether we've; // already seen a pair of nodes.; //; // We put in the elements into the queue only in the toplevel decl check; // function:; // ```; // static bool IsStructurallyEquivalent(StructuralEquivalenceContext &Context,; // Decl *D1, Decl *D2);; // ```; // The `while` loop where we iterate over the children is implemented in; // `Finish()`. And `Finish` is called only from the two **member** functions; // which check the equivalency of two Decls or two Types. ASTImporter (and; // other clients) call only these functions.; //; // The `static` implementation functions are called from `Finish`, these push",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ASTStructuralEquivalence.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTStructuralEquivalence.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTStructuralEquivalence.cpp:33,Testability,log,logic,33,/// Encapsulates Stmt comparison logic.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ASTStructuralEquivalence.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTStructuralEquivalence.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTStructuralEquivalence.cpp:18,Integrability,depend,depend,18,// Semantics only depend on children.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ASTStructuralEquivalence.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTStructuralEquivalence.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTStructuralEquivalence.cpp:315,Performance,optimiz,optimization,315,"// Number of children is actually checked by the generic children comparison; // code, but a CompoundStmt is one of the few statements where the number of; // children frequently differs and the number of statements is also always; // precomputed. Directly comparing the number of children here is thus; // just an optimization.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ASTStructuralEquivalence.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTStructuralEquivalence.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTStructuralEquivalence.cpp:8,Integrability,wrap,wraps,8,// Just wraps a StringLiteral child.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ASTStructuralEquivalence.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTStructuralEquivalence.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTStructuralEquivalence.cpp:18,Integrability,depend,depend,18,// Semantics only depend on children.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ASTStructuralEquivalence.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTStructuralEquivalence.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTStructuralEquivalence.cpp:80,Availability,down,down,80,"// We aren't being strict about token-to-token equivalence of types,; // so map down to the canonical type.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ASTStructuralEquivalence.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTStructuralEquivalence.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTStructuralEquivalence.cpp:180,Performance,Load,LoadFieldsFromExternalStorage,180,// If any of the records has external storage and we do a minimal check (or; // AST import) we assume they are equivalent. (If we didn't have this; // assumption then `RecordDecl::LoadFieldsFromExternalStorage` could trigger; // another AST import which in turn would call the structural equivalency; // check again and finally we'd have an improper result.),MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ASTStructuralEquivalence.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTStructuralEquivalence.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTStructuralEquivalence.cpp:33,Modifiability,inherit,inheritance,33,// Check virtual vs. non-virtual inheritance mismatch.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ASTStructuralEquivalence.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTStructuralEquivalence.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTStructuralEquivalence.cpp:11,Integrability,protocol,protocols,11,// Compare protocols.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ASTStructuralEquivalence.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTStructuralEquivalence.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTStructuralEquivalence.cpp:267,Availability,fault,faulty,267,"// Ensure that the implementation functions (all static functions in this TU); // never call the public ASTStructuralEquivalence::IsEquivalent() functions,; // because that will wreak havoc the internal state (DeclsToCheck and; // VisitedDecls members) and can cause faulty behaviour.; // In other words: Do not start a graph search from a new node with the; // internal data of another search in progress.; // FIXME: Better encapsulation and separation of internal and public; // functionality.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ASTStructuralEquivalence.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTStructuralEquivalence.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTTypeTraits.cpp:549,Safety,safe,safe,549,"//===--- ASTTypeTraits.cpp --------------------------------------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // Provides a dynamic type identifier and a dynamically typed node container; // that can be used to store an AST base node at runtime in the same storage in; // a type safe way.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ASTTypeTraits.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTTypeTraits.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/AttrImpl.cpp:37,Testability,test,testing,37,// Use fake syntax because it is for testing and debugging purpose only.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/AttrImpl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/AttrImpl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Comment.cpp:69,Energy Efficiency,allocate,allocated,69,// Check that no comment class has a non-trival destructor. They are allocated; // with a BumpPtrAllocator and therefore their destructor is not executed.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/Comment.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Comment.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Comment.cpp:20,Energy Efficiency,allocate,allocated,20,// DeclInfo is also allocated with a BumpPtrAllocator.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/Comment.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Comment.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Comment.cpp:182,Integrability,wrap,wrapper,182,"// If we have a typedef to a template specialization with exactly one; // template argument of a function type, this looks like std::function,; // boost::function, or other function wrapper. Treat these typedefs as; // functions.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/Comment.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Comment.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/CommentCommandTraits.cpp:94,Testability,log,logic,94,"// Single-character command impostures, such as \t or \n, should not go; // through the fixit logic.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/CommentCommandTraits.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/CommentCommandTraits.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/CommentCommandTraits.cpp:131,Integrability,wrap,wrap,131,"// We only have a limited number of bits to encode command IDs in the; // CommandInfo structure, so the ID numbers can potentially wrap around.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/CommentCommandTraits.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/CommentCommandTraits.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/CommentSema.cpp:28,Integrability,interface,interface,28,"// Allow @class command on @interface declarations.; // FIXME. Currently, \class and @class are indistinguishable. So,; // \class is also allowed on an @interface declaration",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/CommentSema.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/CommentSema.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/CommentSema.cpp:153,Integrability,interface,interface,153,"// Allow @class command on @interface declarations.; // FIXME. Currently, \class and @class are indistinguishable. So,; // \class is also allowed on an @interface declaration",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/CommentSema.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/CommentSema.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ComparisonCategories.cpp:9,Modifiability,Extend,Extend,9,// TODO: Extend support for operator<=> to ObjC types.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ComparisonCategories.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ComparisonCategories.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ComparisonCategories.cpp:30,Performance,cache,cache,30,// Check if we already have a cache entry for this value.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ComparisonCategories.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ComparisonCategories.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ComparisonCategories.cpp:45,Modifiability,variab,variable,45,// We don't have a cached result. Lookup the variable declaration and create; // a new entry representing it.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ComparisonCategories.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ComparisonCategories.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ComparisonCategories.cpp:19,Performance,cache,cached,19,// We don't have a cached result. Lookup the variable declaration and create; // a new entry representing it.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ComparisonCategories.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ComparisonCategories.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ComparisonCategories.cpp:62,Performance,cache,cached,62,// Check to see if we have information for the specified type cached.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ComparisonCategories.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ComparisonCategories.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ComparisonCategories.cpp:57,Performance,cache,cache,57,// We've found the comparison category type. Build a new cache entry for; // it.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ComparisonCategories.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ComparisonCategories.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ComputeDependence.cpp:111,Integrability,depend,dependent,111,// C++ [temp.dep.constexpr]p5:; // An expression of the form & qualified-id where the qualified-id names a; // dependent member of the current instantiation is value-dependent. An; // expression of the form & cast-expression is also value-dependent if; // evaluating cast-expression as a core constant expression succeeds and; // the result of the evaluation refers to a templated entity that is an; // object with static or thread storage duration or a member function.; //; // What this amounts to is: constant-evaluate the operand and check whether it; // refers to a templated entity other than a variable with local storage.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ComputeDependence.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ComputeDependence.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ComputeDependence.cpp:166,Integrability,depend,dependent,166,// C++ [temp.dep.constexpr]p5:; // An expression of the form & qualified-id where the qualified-id names a; // dependent member of the current instantiation is value-dependent. An; // expression of the form & cast-expression is also value-dependent if; // evaluating cast-expression as a core constant expression succeeds and; // the result of the evaluation refers to a templated entity that is an; // object with static or thread storage duration or a member function.; //; // What this amounts to is: constant-evaluate the operand and check whether it; // refers to a templated entity other than a variable with local storage.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ComputeDependence.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ComputeDependence.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ComputeDependence.cpp:239,Integrability,depend,dependent,239,// C++ [temp.dep.constexpr]p5:; // An expression of the form & qualified-id where the qualified-id names a; // dependent member of the current instantiation is value-dependent. An; // expression of the form & cast-expression is also value-dependent if; // evaluating cast-expression as a core constant expression succeeds and; // the result of the evaluation refers to a templated entity that is an; // object with static or thread storage duration or a member function.; //; // What this amounts to is: constant-evaluate the operand and check whether it; // refers to a templated entity other than a variable with local storage.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ComputeDependence.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ComputeDependence.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ComputeDependence.cpp:601,Modifiability,variab,variable,601,// C++ [temp.dep.constexpr]p5:; // An expression of the form & qualified-id where the qualified-id names a; // dependent member of the current instantiation is value-dependent. An; // expression of the form & cast-expression is also value-dependent if; // evaluating cast-expression as a core constant expression succeeds and; // the result of the evaluation refers to a templated entity that is an; // object with static or thread storage duration or a member function.; //; // What this amounts to is: constant-evaluate the operand and check whether it; // refers to a templated entity other than a variable with local storage.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ComputeDependence.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ComputeDependence.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ComputeDependence.cpp:14,Integrability,depend,dependent,14,// Never type-dependent (C++ [temp.dep.expr]p3).; // Value-dependent if the argument is type-dependent.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ComputeDependence.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ComputeDependence.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ComputeDependence.cpp:59,Integrability,depend,dependent,59,// Never type-dependent (C++ [temp.dep.expr]p3).; // Value-dependent if the argument is type-dependent.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ComputeDependence.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ComputeDependence.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ComputeDependence.cpp:93,Integrability,depend,dependent,93,// Never type-dependent (C++ [temp.dep.expr]p3).; // Value-dependent if the argument is type-dependent.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ComputeDependence.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ComputeDependence.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ComputeDependence.cpp:9,Integrability,depend,dependent,9,// Value-dependent if the argument is type-dependent.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ComputeDependence.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ComputeDependence.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ComputeDependence.cpp:43,Integrability,depend,dependent,43,// Value-dependent if the argument is type-dependent.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ComputeDependence.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ComputeDependence.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ComputeDependence.cpp:77,Integrability,depend,dependent,77,// Check to see if we are in the situation where alignof(decl) should be; // dependent because decl's alignment is dependent.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ComputeDependence.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ComputeDependence.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ComputeDependence.cpp:115,Integrability,depend,dependent,115,// Check to see if we are in the situation where alignof(decl) should be; // dependent because decl's alignment is dependent.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ComputeDependence.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ComputeDependence.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ComputeDependence.cpp:50,Integrability,depend,dependence,50,"// We model implicit conversions as combining the dependence of their; // subexpression, apart from its type, with the semantic portion of the; // target type.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ComputeDependence.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ComputeDependence.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ComputeDependence.cpp:29,Integrability,depend,dependent,29,"// Cast expressions are type-dependent if the type is; // dependent (C++ [temp.dep.expr]p3).; // Cast expressions are value-dependent if the type is; // dependent or if the subexpression is value-dependent.; //; // Note that we also need to consider the dependence of the actual type here,; // because when the type as written is a deduced type, that type is not; // dependent, but it may be deduced as a dependent type.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ComputeDependence.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ComputeDependence.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ComputeDependence.cpp:58,Integrability,depend,dependent,58,"// Cast expressions are type-dependent if the type is; // dependent (C++ [temp.dep.expr]p3).; // Cast expressions are value-dependent if the type is; // dependent or if the subexpression is value-dependent.; //; // Note that we also need to consider the dependence of the actual type here,; // because when the type as written is a deduced type, that type is not; // dependent, but it may be deduced as a dependent type.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ComputeDependence.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ComputeDependence.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ComputeDependence.cpp:124,Integrability,depend,dependent,124,"// Cast expressions are type-dependent if the type is; // dependent (C++ [temp.dep.expr]p3).; // Cast expressions are value-dependent if the type is; // dependent or if the subexpression is value-dependent.; //; // Note that we also need to consider the dependence of the actual type here,; // because when the type as written is a deduced type, that type is not; // dependent, but it may be deduced as a dependent type.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ComputeDependence.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ComputeDependence.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ComputeDependence.cpp:153,Integrability,depend,dependent,153,"// Cast expressions are type-dependent if the type is; // dependent (C++ [temp.dep.expr]p3).; // Cast expressions are value-dependent if the type is; // dependent or if the subexpression is value-dependent.; //; // Note that we also need to consider the dependence of the actual type here,; // because when the type as written is a deduced type, that type is not; // dependent, but it may be deduced as a dependent type.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ComputeDependence.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ComputeDependence.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ComputeDependence.cpp:196,Integrability,depend,dependent,196,"// Cast expressions are type-dependent if the type is; // dependent (C++ [temp.dep.expr]p3).; // Cast expressions are value-dependent if the type is; // dependent or if the subexpression is value-dependent.; //; // Note that we also need to consider the dependence of the actual type here,; // because when the type as written is a deduced type, that type is not; // dependent, but it may be deduced as a dependent type.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ComputeDependence.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ComputeDependence.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ComputeDependence.cpp:254,Integrability,depend,dependence,254,"// Cast expressions are type-dependent if the type is; // dependent (C++ [temp.dep.expr]p3).; // Cast expressions are value-dependent if the type is; // dependent or if the subexpression is value-dependent.; //; // Note that we also need to consider the dependence of the actual type here,; // because when the type as written is a deduced type, that type is not; // dependent, but it may be deduced as a dependent type.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ComputeDependence.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ComputeDependence.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ComputeDependence.cpp:367,Integrability,depend,dependent,367,"// Cast expressions are type-dependent if the type is; // dependent (C++ [temp.dep.expr]p3).; // Cast expressions are value-dependent if the type is; // dependent or if the subexpression is value-dependent.; //; // Note that we also need to consider the dependence of the actual type here,; // because when the type as written is a deduced type, that type is not; // dependent, but it may be deduced as a dependent type.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ComputeDependence.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ComputeDependence.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ComputeDependence.cpp:405,Integrability,depend,dependent,405,"// Cast expressions are type-dependent if the type is; // dependent (C++ [temp.dep.expr]p3).; // Cast expressions are value-dependent if the type is; // dependent or if the subexpression is value-dependent.; //; // Note that we also need to consider the dependence of the actual type here,; // because when the type as written is a deduced type, that type is not; // dependent, but it may be deduced as a dependent type.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ComputeDependence.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ComputeDependence.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ComputeDependence.cpp:40,Integrability,depend,depends,40,"// The type of the conditional operator depends on the type of the conditional; // to support the GCC vector conditional extension. Additionally,; // [temp.dep.expr] does specify state that this should be dependent on ALL sub; // expressions.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ComputeDependence.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ComputeDependence.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ComputeDependence.cpp:205,Integrability,depend,dependent,205,"// The type of the conditional operator depends on the type of the conditional; // to support the GCC vector conditional extension. Additionally,; // [temp.dep.expr] does specify state that this should be dependent on ALL sub; // expressions.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ComputeDependence.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ComputeDependence.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ComputeDependence.cpp:13,Integrability,depend,dependence,13,// Propagate dependence of the result.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ComputeDependence.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ComputeDependence.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ComputeDependence.cpp:46,Integrability,depend,dependent,46,// Note: we treat a statement-expression in a dependent context as always; // being value- and instantiation-dependent. This matches the behavior of; // lambda-expressions and GCC.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ComputeDependence.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ComputeDependence.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ComputeDependence.cpp:109,Integrability,depend,dependent,109,// Note: we treat a statement-expression in a dependent context as always; // being value- and instantiation-dependent. This matches the behavior of; // lambda-expressions and GCC.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ComputeDependence.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ComputeDependence.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ComputeDependence.cpp:25,Integrability,depend,dependency,25,// Take type- and value- dependency from the active branch. Propagate all; // other flags from all branches.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ComputeDependence.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ComputeDependence.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ComputeDependence.cpp:24,Integrability,depend,dependent,24,// typeid is never type-dependent (C++ [temp.dep.expr]p4),MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ComputeDependence.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ComputeDependence.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ComputeDependence.cpp:18,Integrability,depend,dependent,18,// 'this' is type-dependent if the class type of the enclosing; // member function is dependent (C++ [temp.dep.expr]p2),MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ComputeDependence.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ComputeDependence.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ComputeDependence.cpp:86,Integrability,depend,dependent,86,// 'this' is type-dependent if the class type of the enclosing; // member function is dependent (C++ [temp.dep.expr]p2),MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ComputeDependence.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ComputeDependence.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ComputeDependence.cpp:14,Integrability,depend,dependent,14,// Never type-dependent.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ComputeDependence.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ComputeDependence.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ComputeDependence.cpp:9,Integrability,depend,dependent,9,// Value-dependent if the argument is type-dependent.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ComputeDependence.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ComputeDependence.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ComputeDependence.cpp:43,Integrability,depend,dependent,43,// Value-dependent if the argument is type-dependent.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ComputeDependence.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ComputeDependence.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ComputeDependence.cpp:50,Integrability,depend,dependent,50,"// If the type is omitted, it's 'int', and is not dependent in any way.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ComputeDependence.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ComputeDependence.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ComputeDependence.cpp:49,Integrability,depend,dependence,49,"/// Compute the type-, value-, and instantiation-dependence of a; /// declaration reference; /// based on the declaration being referenced.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ComputeDependence.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ComputeDependence.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ComputeDependence.cpp:55,Integrability,depend,dependent,55,"// C++ [temp.dep.expr]p3:; // An id-expression is type-dependent if it contains:; // - an identifier associated by name lookup with one or more declarations; // declared with a dependent type; // - an identifier associated by name lookup with an entity captured by; // copy ([expr.prim.lambda.capture]); // in a lambda-expression that has an explicit object parameter whose; // type is dependent ([dcl.fct]),; //; // [The ""or more"" case is not modeled as a DeclRefExpr. There are a bunch; // more bullets here that we handle by treating the declaration as having a; // dependent type if they involve a placeholder type that can't be deduced.]",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ComputeDependence.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ComputeDependence.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ComputeDependence.cpp:177,Integrability,depend,dependent,177,"// C++ [temp.dep.expr]p3:; // An id-expression is type-dependent if it contains:; // - an identifier associated by name lookup with one or more declarations; // declared with a dependent type; // - an identifier associated by name lookup with an entity captured by; // copy ([expr.prim.lambda.capture]); // in a lambda-expression that has an explicit object parameter whose; // type is dependent ([dcl.fct]),; //; // [The ""or more"" case is not modeled as a DeclRefExpr. There are a bunch; // more bullets here that we handle by treating the declaration as having a; // dependent type if they involve a placeholder type that can't be deduced.]",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ComputeDependence.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ComputeDependence.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ComputeDependence.cpp:386,Integrability,depend,dependent,386,"// C++ [temp.dep.expr]p3:; // An id-expression is type-dependent if it contains:; // - an identifier associated by name lookup with one or more declarations; // declared with a dependent type; // - an identifier associated by name lookup with an entity captured by; // copy ([expr.prim.lambda.capture]); // in a lambda-expression that has an explicit object parameter whose; // type is dependent ([dcl.fct]),; //; // [The ""or more"" case is not modeled as a DeclRefExpr. There are a bunch; // more bullets here that we handle by treating the declaration as having a; // dependent type if they involve a placeholder type that can't be deduced.]",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ComputeDependence.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ComputeDependence.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ComputeDependence.cpp:569,Integrability,depend,dependent,569,"// C++ [temp.dep.expr]p3:; // An id-expression is type-dependent if it contains:; // - an identifier associated by name lookup with one or more declarations; // declared with a dependent type; // - an identifier associated by name lookup with an entity captured by; // copy ([expr.prim.lambda.capture]); // in a lambda-expression that has an explicit object parameter whose; // type is dependent ([dcl.fct]),; //; // [The ""or more"" case is not modeled as a DeclRefExpr. There are a bunch; // more bullets here that we handle by treating the declaration as having a; // dependent type if they involve a placeholder type that can't be deduced.]",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ComputeDependence.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ComputeDependence.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ComputeDependence.cpp:47,Integrability,depend,dependent,47,// - a conversion-function-id that specifies a dependent type,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ComputeDependence.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ComputeDependence.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ComputeDependence.cpp:27,Integrability,depend,dependent,27,"// - a template-id that is dependent,; // - a nested-name-specifier or a qualified-id that names a member of an; // unknown specialization; // [These are not modeled as DeclRefExprs.]; // or if it names a dependent member of the current instantiation that is a; // static data member of type ""array of unknown bound of T"" for some T; // [handled below].; // C++ [temp.dep.constexpr]p2:; // An id-expression is value-dependent if:; // - it is type-dependent [handled above]; // - it is the name of a non-type template parameter,",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ComputeDependence.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ComputeDependence.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ComputeDependence.cpp:205,Integrability,depend,dependent,205,"// - a template-id that is dependent,; // - a nested-name-specifier or a qualified-id that names a member of an; // unknown specialization; // [These are not modeled as DeclRefExprs.]; // or if it names a dependent member of the current instantiation that is a; // static data member of type ""array of unknown bound of T"" for some T; // [handled below].; // C++ [temp.dep.constexpr]p2:; // An id-expression is value-dependent if:; // - it is type-dependent [handled above]; // - it is the name of a non-type template parameter,",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ComputeDependence.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ComputeDependence.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ComputeDependence.cpp:416,Integrability,depend,dependent,416,"// - a template-id that is dependent,; // - a nested-name-specifier or a qualified-id that names a member of an; // unknown specialization; // [These are not modeled as DeclRefExprs.]; // or if it names a dependent member of the current instantiation that is a; // static data member of type ""array of unknown bound of T"" for some T; // [handled below].; // C++ [temp.dep.constexpr]p2:; // An id-expression is value-dependent if:; // - it is type-dependent [handled above]; // - it is the name of a non-type template parameter,",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ComputeDependence.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ComputeDependence.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ComputeDependence.cpp:447,Integrability,depend,dependent,447,"// - a template-id that is dependent,; // - a nested-name-specifier or a qualified-id that names a member of an; // unknown specialization; // [These are not modeled as DeclRefExprs.]; // or if it names a dependent member of the current instantiation that is a; // static data member of type ""array of unknown bound of T"" for some T; // [handled below].; // C++ [temp.dep.constexpr]p2:; // An id-expression is value-dependent if:; // - it is type-dependent [handled above]; // - it is the name of a non-type template parameter,",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ComputeDependence.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ComputeDependence.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ComputeDependence.cpp:103,Integrability,depend,dependent,103,// - it names a potentially-constant variable that is initialized with an; // expression that is value-dependent,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ComputeDependence.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ComputeDependence.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ComputeDependence.cpp:37,Modifiability,variab,variable,37,// - it names a potentially-constant variable that is initialized with an; // expression that is value-dependent,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ComputeDependence.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ComputeDependence.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ComputeDependence.cpp:45,Integrability,depend,dependent,45,"// - it names a static data member that is a dependent member of the; // current instantiation and is not initialized in a member-declarator,",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ComputeDependence.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ComputeDependence.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ComputeDependence.cpp:49,Integrability,depend,dependent,49,"// - it names a static member function that is a dependent member of the; // current instantiation; //; // FIXME: It's unclear that the restriction to static members here has any; // effect: any use of a non-static member function name requires either; // forming a pointer-to-member or providing an object parameter, either of; // which makes the overall expression value-dependent.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ComputeDependence.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ComputeDependence.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ComputeDependence.cpp:373,Integrability,depend,dependent,373,"// - it names a static member function that is a dependent member of the; // current instantiation; //; // FIXME: It's unclear that the restriction to static members here has any; // effect: any use of a non-static member function name requires either; // forming a pointer-to-member or providing an object parameter, either of; // which makes the overall expression value-dependent.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ComputeDependence.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ComputeDependence.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ComputeDependence.cpp:3,Availability,Recover,RecoveryExpr,3,"// RecoveryExpr is; // - always value-dependent, and therefore instantiation dependent; // - contains errors (ExprDependence::Error), by definition; // - type-dependent if we don't know the type (fallback to an opaque; // dependent type), or the type is known and dependent, or it has; // type-dependent subexpressions.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ComputeDependence.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ComputeDependence.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ComputeDependence.cpp:102,Availability,error,errors,102,"// RecoveryExpr is; // - always value-dependent, and therefore instantiation dependent; // - contains errors (ExprDependence::Error), by definition; // - type-dependent if we don't know the type (fallback to an opaque; // dependent type), or the type is known and dependent, or it has; // type-dependent subexpressions.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ComputeDependence.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ComputeDependence.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ComputeDependence.cpp:126,Availability,Error,Error,126,"// RecoveryExpr is; // - always value-dependent, and therefore instantiation dependent; // - contains errors (ExprDependence::Error), by definition; // - type-dependent if we don't know the type (fallback to an opaque; // dependent type), or the type is known and dependent, or it has; // type-dependent subexpressions.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ComputeDependence.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ComputeDependence.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ComputeDependence.cpp:38,Integrability,depend,dependent,38,"// RecoveryExpr is; // - always value-dependent, and therefore instantiation dependent; // - contains errors (ExprDependence::Error), by definition; // - type-dependent if we don't know the type (fallback to an opaque; // dependent type), or the type is known and dependent, or it has; // type-dependent subexpressions.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ComputeDependence.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ComputeDependence.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ComputeDependence.cpp:77,Integrability,depend,dependent,77,"// RecoveryExpr is; // - always value-dependent, and therefore instantiation dependent; // - contains errors (ExprDependence::Error), by definition; // - type-dependent if we don't know the type (fallback to an opaque; // dependent type), or the type is known and dependent, or it has; // type-dependent subexpressions.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ComputeDependence.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ComputeDependence.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ComputeDependence.cpp:159,Integrability,depend,dependent,159,"// RecoveryExpr is; // - always value-dependent, and therefore instantiation dependent; // - contains errors (ExprDependence::Error), by definition; // - type-dependent if we don't know the type (fallback to an opaque; // dependent type), or the type is known and dependent, or it has; // type-dependent subexpressions.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ComputeDependence.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ComputeDependence.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ComputeDependence.cpp:222,Integrability,depend,dependent,222,"// RecoveryExpr is; // - always value-dependent, and therefore instantiation dependent; // - contains errors (ExprDependence::Error), by definition; // - type-dependent if we don't know the type (fallback to an opaque; // dependent type), or the type is known and dependent, or it has; // type-dependent subexpressions.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ComputeDependence.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ComputeDependence.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ComputeDependence.cpp:264,Integrability,depend,dependent,264,"// RecoveryExpr is; // - always value-dependent, and therefore instantiation dependent; // - contains errors (ExprDependence::Error), by definition; // - type-dependent if we don't know the type (fallback to an opaque; // dependent type), or the type is known and dependent, or it has; // type-dependent subexpressions.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ComputeDependence.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ComputeDependence.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ComputeDependence.cpp:294,Integrability,depend,dependent,294,"// RecoveryExpr is; // - always value-dependent, and therefore instantiation dependent; // - contains errors (ExprDependence::Error), by definition; // - type-dependent if we don't know the type (fallback to an opaque; // dependent type), or the type is known and dependent, or it has; // type-dependent subexpressions.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ComputeDependence.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ComputeDependence.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ComputeDependence.cpp:3,Safety,Recover,RecoveryExpr,3,"// RecoveryExpr is; // - always value-dependent, and therefore instantiation dependent; // - contains errors (ExprDependence::Error), by definition; // - type-dependent if we don't know the type (fallback to an opaque; // dependent type), or the type is known and dependent, or it has; // type-dependent subexpressions.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ComputeDependence.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ComputeDependence.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ComputeDependence.cpp:72,Availability,Recover,RecoveryExpr,72,"// FIXME: remove the type-dependent bit from subexpressions, if the; // RecoveryExpr has a non-dependent type.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ComputeDependence.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ComputeDependence.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ComputeDependence.cpp:26,Integrability,depend,dependent,26,"// FIXME: remove the type-dependent bit from subexpressions, if the; // RecoveryExpr has a non-dependent type.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ComputeDependence.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ComputeDependence.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ComputeDependence.cpp:95,Integrability,depend,dependent,95,"// FIXME: remove the type-dependent bit from subexpressions, if the; // RecoveryExpr has a non-dependent type.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ComputeDependence.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ComputeDependence.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ComputeDependence.cpp:72,Safety,Recover,RecoveryExpr,72,"// FIXME: remove the type-dependent bit from subexpressions, if the; // RecoveryExpr has a non-dependent type.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ComputeDependence.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ComputeDependence.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ComputeDependence.cpp:43,Modifiability,variab,variables,43,// dyn_cast_or_null is used to handle objC variables which do not; // have a declaration context.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ComputeDependence.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ComputeDependence.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ComputeDependence.cpp:23,Integrability,depend,dependent,23,// Bitfield with value-dependent width is type-dependent.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ComputeDependence.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ComputeDependence.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ComputeDependence.cpp:47,Integrability,depend,dependent,47,// Bitfield with value-dependent width is type-dependent.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ComputeDependence.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ComputeDependence.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ComputeDependence.cpp:25,Integrability,depend,dependence,25,// FIXME: move remaining dependence computation from MemberExpr::Create(),MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ComputeDependence.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ComputeDependence.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ComputeDependence.cpp:53,Integrability,depend,dependent,53,"// If we have explicit template arguments, check for dependent; // template arguments and whether they contain any unexpanded pack; // expansions.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ComputeDependence.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ComputeDependence.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/CXXABI.h:22,Integrability,Interface,Interface,22,"//===----- CXXABI.h - Interface to C++ ABIs ---------------------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This provides an abstract class for C++ AST support. Concrete; // subclasses of this implement AST support for specific C++ ABIs.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/CXXABI.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/CXXABI.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/CXXInheritance.cpp:402,Integrability,rout,routines,402,"//===- CXXInheritance.cpp - C++ Inheritance -------------------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file provides routines that help analyzing C++ inheritance hierarchies.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/CXXInheritance.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/CXXInheritance.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/CXXInheritance.cpp:32,Modifiability,Inherit,Inheritance,32,"//===- CXXInheritance.cpp - C++ Inheritance -------------------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file provides routines that help analyzing C++ inheritance hierarchies.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/CXXInheritance.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/CXXInheritance.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/CXXInheritance.cpp:435,Modifiability,inherit,inheritance,435,"//===- CXXInheritance.cpp - C++ Inheritance -------------------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file provides routines that help analyzing C++ inheritance hierarchies.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/CXXInheritance.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/CXXInheritance.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/CXXInheritance.cpp:4,Usability,clear,clear,4,/// clear - Clear out all prior path information.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/CXXInheritance.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/CXXInheritance.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/CXXInheritance.cpp:12,Usability,Clear,Clear,12,/// clear - Clear out all prior path information.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/CXXInheritance.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/CXXInheritance.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/CXXInheritance.cpp:2,Safety,Detect,DetectVirtual,2,/*DetectVirtual=*/,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/CXXInheritance.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/CXXInheritance.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/CXXInheritance.cpp:2,Safety,Detect,DetectVirtual,2,/*DetectVirtual=*/,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/CXXInheritance.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/CXXInheritance.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/CXXInheritance.cpp:18,Performance,queue,queue,18,// not actually a queue.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/CXXInheritance.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/CXXInheritance.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/CXXInheritance.cpp:26,Availability,down,down,26,// The access of the path down to this record.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/CXXInheritance.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/CXXInheritance.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/CXXInheritance.cpp:7,Security,access,access,7,// The access of the path down to this record.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/CXXInheritance.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/CXXInheritance.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/CXXInheritance.cpp:138,Integrability,depend,depends,138,"// C++ [temp.dep]p3:; // In the definition of a class template or a member of a class template,; // if a base class of the class template depends on a template-parameter,; // the base class scope is not examined during unqualified name lookup; // either at the point of definition of the class template or member or; // during an instantiation of the class tem- plate or member.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/CXXInheritance.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/CXXInheritance.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/CXXInheritance.cpp:22,Availability,down,down,22,"// Calculate the ""top-down"" access to this base class.; // The spec actually describes this bottom-up, but top-down is; // equivalent because the definition works out as follows:; // 1. Write down the access along each step in the inheritance; // chain, followed by the access of the decl itself.; // For example, in; // class A { public: int foo; };; // class B : protected A {};; // class C : public B {};; // class D : private C {};; // we would write:; // private public protected public; // 2. If 'private' appears anywhere except far-left, access is denied.; // 3. Otherwise, overall access is determined by the most restrictive; // access in the sequence.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/CXXInheritance.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/CXXInheritance.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/CXXInheritance.cpp:111,Availability,down,down,111,"// Calculate the ""top-down"" access to this base class.; // The spec actually describes this bottom-up, but top-down is; // equivalent because the definition works out as follows:; // 1. Write down the access along each step in the inheritance; // chain, followed by the access of the decl itself.; // For example, in; // class A { public: int foo; };; // class B : protected A {};; // class C : public B {};; // class D : private C {};; // we would write:; // private public protected public; // 2. If 'private' appears anywhere except far-left, access is denied.; // 3. Otherwise, overall access is determined by the most restrictive; // access in the sequence.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/CXXInheritance.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/CXXInheritance.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/CXXInheritance.cpp:192,Availability,down,down,192,"// Calculate the ""top-down"" access to this base class.; // The spec actually describes this bottom-up, but top-down is; // equivalent because the definition works out as follows:; // 1. Write down the access along each step in the inheritance; // chain, followed by the access of the decl itself.; // For example, in; // class A { public: int foo; };; // class B : protected A {};; // class C : public B {};; // class D : private C {};; // we would write:; // private public protected public; // 2. If 'private' appears anywhere except far-left, access is denied.; // 3. Otherwise, overall access is determined by the most restrictive; // access in the sequence.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/CXXInheritance.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/CXXInheritance.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/CXXInheritance.cpp:231,Modifiability,inherit,inheritance,231,"// Calculate the ""top-down"" access to this base class.; // The spec actually describes this bottom-up, but top-down is; // equivalent because the definition works out as follows:; // 1. Write down the access along each step in the inheritance; // chain, followed by the access of the decl itself.; // For example, in; // class A { public: int foo; };; // class B : protected A {};; // class C : public B {};; // class D : private C {};; // we would write:; // private public protected public; // 2. If 'private' appears anywhere except far-left, access is denied.; // 3. Otherwise, overall access is determined by the most restrictive; // access in the sequence.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/CXXInheritance.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/CXXInheritance.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/CXXInheritance.cpp:28,Security,access,access,28,"// Calculate the ""top-down"" access to this base class.; // The spec actually describes this bottom-up, but top-down is; // equivalent because the definition works out as follows:; // 1. Write down the access along each step in the inheritance; // chain, followed by the access of the decl itself.; // For example, in; // class A { public: int foo; };; // class B : protected A {};; // class C : public B {};; // class D : private C {};; // we would write:; // private public protected public; // 2. If 'private' appears anywhere except far-left, access is denied.; // 3. Otherwise, overall access is determined by the most restrictive; // access in the sequence.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/CXXInheritance.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/CXXInheritance.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/CXXInheritance.cpp:201,Security,access,access,201,"// Calculate the ""top-down"" access to this base class.; // The spec actually describes this bottom-up, but top-down is; // equivalent because the definition works out as follows:; // 1. Write down the access along each step in the inheritance; // chain, followed by the access of the decl itself.; // For example, in; // class A { public: int foo; };; // class B : protected A {};; // class C : public B {};; // class D : private C {};; // we would write:; // private public protected public; // 2. If 'private' appears anywhere except far-left, access is denied.; // 3. Otherwise, overall access is determined by the most restrictive; // access in the sequence.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/CXXInheritance.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/CXXInheritance.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/CXXInheritance.cpp:270,Security,access,access,270,"// Calculate the ""top-down"" access to this base class.; // The spec actually describes this bottom-up, but top-down is; // equivalent because the definition works out as follows:; // 1. Write down the access along each step in the inheritance; // chain, followed by the access of the decl itself.; // For example, in; // class A { public: int foo; };; // class B : protected A {};; // class C : public B {};; // class D : private C {};; // we would write:; // private public protected public; // 2. If 'private' appears anywhere except far-left, access is denied.; // 3. Otherwise, overall access is determined by the most restrictive; // access in the sequence.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/CXXInheritance.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/CXXInheritance.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/CXXInheritance.cpp:546,Security,access,access,546,"// Calculate the ""top-down"" access to this base class.; // The spec actually describes this bottom-up, but top-down is; // equivalent because the definition works out as follows:; // 1. Write down the access along each step in the inheritance; // chain, followed by the access of the decl itself.; // For example, in; // class A { public: int foo; };; // class B : protected A {};; // class C : public B {};; // class D : private C {};; // we would write:; // private public protected public; // 2. If 'private' appears anywhere except far-left, access is denied.; // 3. Otherwise, overall access is determined by the most restrictive; // access in the sequence.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/CXXInheritance.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/CXXInheritance.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/CXXInheritance.cpp:590,Security,access,access,590,"// Calculate the ""top-down"" access to this base class.; // The spec actually describes this bottom-up, but top-down is; // equivalent because the definition works out as follows:; // 1. Write down the access along each step in the inheritance; // chain, followed by the access of the decl itself.; // For example, in; // class A { public: int foo; };; // class B : protected A {};; // class C : public B {};; // class D : private C {};; // we would write:; // private public protected public; // 2. If 'private' appears anywhere except far-left, access is denied.; // 3. Otherwise, overall access is determined by the most restrictive; // access in the sequence.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/CXXInheritance.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/CXXInheritance.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/CXXInheritance.cpp:639,Security,access,access,639,"// Calculate the ""top-down"" access to this base class.; // The spec actually describes this bottom-up, but top-down is; // equivalent because the definition works out as follows:; // 1. Write down the access along each step in the inheritance; // chain, followed by the access of the decl itself.; // For example, in; // class A { public: int foo; };; // class B : protected A {};; // class C : public B {};; // class D : private C {};; // we would write:; // private public protected public; // 2. If 'private' appears anywhere except far-left, access is denied.; // 3. Otherwise, overall access is determined by the most restrictive; // access in the sequence.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/CXXInheritance.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/CXXInheritance.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/CXXInheritance.cpp:26,Security,access,access,26,// Reset the scratch path access.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/CXXInheritance.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/CXXInheritance.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/CXXInheritance.cpp:230,Deployability,patch,patch,230,"// The declaration(s) we found along this path were found in a; // subobject of a virtual base. Check whether this virtual; // base is a subobject of any other path; if so, then the; // declaration in this path are hidden by that patch.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/CXXInheritance.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/CXXInheritance.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/CXXInheritance.cpp:3,Performance,Perform,Perform,3,// Perform lookup into our base classes.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/CXXInheritance.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/CXXInheritance.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/CXXInheritance.cpp:177,Performance,cache,cached,177,"// Collect all of the overridders from the base class subobject; // and merge them into the set of overridders for this class.; // For virtual base classes, populate or use the cached virtual; // overrides so that we do not walk the virtual base class (and; // its base classes) more than once.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/CXXInheritance.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/CXXInheritance.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/CXXInheritance.cpp:223,Availability,down,down,223,"// This virtual method overrides other virtual methods, so it does; // not add any new slots into the set of overriders. Instead, we; // replace entries in the set of overriders with the new; // overrider. To do so, we dig down to the original virtual; // functions using data recursion and update all of the methods it; // overrides.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/CXXInheritance.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/CXXInheritance.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/CXXInheritance.cpp:291,Deployability,update,update,291,"// This virtual method overrides other virtual methods, so it does; // not add any new slots into the set of overriders. Instead, we; // replace entries in the set of overriders with the new; // overrider. To do so, we dig down to the original virtual; // functions using data recursion and update all of the methods it; // overrides.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/CXXInheritance.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/CXXInheritance.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/CXXInheritance.cpp:209,Modifiability,inherit,inherits,209,"// C++ [class.virtual]p2:; // A virtual member function C::vf of a class object S is; // a final overrider unless the most derived class (1.8); // of which S is a base class subobject (if any) declares; // or inherits another member function that overrides vf.; //; // Treating this object like the most derived class, we; // replace any overrides from base classes with this; // overriding virtual function.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/CXXInheritance.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/CXXInheritance.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Decl.cpp:988,Modifiability,variab,variable,988,"----------------------------------===//; // NamedDecl Implementation; //===----------------------------------------------------------------------===//; // Visibility rules aren't rigorously externally specified, but here; // are the basic principles behind what we implement:; //; // 1. An explicit visibility attribute is generally a direct expression; // of the user's intent and should be honored. Only the innermost; // visibility attribute applies. If no visibility attribute applies,; // global visibility settings are considered.; //; // 2. There is one caveat to the above: on or in a template pattern,; // an explicit visibility attribute is just a default rule, and; // visibility can be decreased by the visibility of template; // arguments. But this, too, has an exception: an attribute on an; // explicit specialization or instantiation causes all the visibility; // restrictions of the template arguments to be ignored.; //; // 3. A variable that does not otherwise have explicit visibility can; // be restricted by the visibility of its type.; //; // 4. A visibility restriction is explicit if it comes from an; // attribute (or something like it), not a global visibility setting.; // When emitting a reference to an external symbol, visibility; // restrictions are ignored unless they are explicit.; //; // 5. When computing the visibility of a non-type, including a; // non-type member of a class, only non-type visibility restrictions; // are considered: the 'visibility' attribute, global value-visibility; // settings, and a few special cases like __private_extern.; //; // 6. When computing the visibility of a type, including a type member; // of a class, only type visibility restrictions are considered:; // the 'type_visibility' attribute and global type-visibility settings.; // However, a 'visibility' attribute counts as a 'type_visibility'; // attribute on any declaration that only has the former.; //; // The visibility of a ""secondary"" entity, like a template argument",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/Decl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Decl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Decl.cpp:188,Integrability,depend,dependent,188,"// Non-type template parameters can be restricted by the value type, e.g.; // template <enum X> class A { ... };; // We have to be careful here, though, because we can be dealing with; // dependent types.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/Decl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Decl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Decl.cpp:729,Testability,log,logic,729,"// Include visibility from the template parameters and arguments; // only if this is not an explicit instantiation or specialization; // with direct explicit visibility (and note that implicit; // instantiations won't have a direct attribute).; //; // Furthermore, we want to ignore template parameters and arguments; // for an explicit specialization when computing the visibility of a; // member thereof with explicit visibility.; //; // This is a bit complex; let's unpack it.; //; // An explicit class specialization is an independent, top-level; // declaration. As such, if it or any of its members has an; // explicit visibility attribute, that must directly express the; // user's intent, and we should honor it. The same logic applies to; // an explicit instantiation of a member of such a thing.; // Fast path: if this is not an explicit instantiation or; // specialization, we always want to consider template-related; // visibility restrictions.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/Decl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Decl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Decl.cpp:106,Modifiability,variab,variable,106,"/// Should we consider visibility associated with the template; /// arguments and parameters of the given variable template; /// specialization? As usual, follow class template specialization; /// logic up to initialization.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/Decl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Decl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Decl.cpp:197,Testability,log,logic,197,"/// Should we consider visibility associated with the template; /// arguments and parameters of the given variable template; /// specialization? As usual, follow class template specialization; /// logic up to initialization.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/Decl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Decl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Decl.cpp:15,Modifiability,variab,variable,15,"// An explicit variable specialization is an independent, top-level; // declaration. As such, if it has an explicit visibility attribute,; // that must directly express the user's intent, and we should honor; // it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/Decl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Decl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Decl.cpp:72,Modifiability,variab,variable,72,"/// Merge in template-related linkage and visibility for the given; /// variable template specialization. As usual, follow class template; /// specialization logic up to initialization.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/Decl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Decl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Decl.cpp:158,Testability,log,logic,158,"/// Merge in template-related linkage and visibility for the given; /// variable template specialization. As usual, follow class template; /// specialization logic up to initialization.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/Decl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Decl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Decl.cpp:7,Modifiability,variab,variable,7,"// - a variable, variable template, function, or function template; // that is explicitly declared static; or; // (This bullet corresponds to C99 6.2.2p3.)",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/Decl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Decl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Decl.cpp:17,Modifiability,variab,variable,17,"// - a variable, variable template, function, or function template; // that is explicitly declared static; or; // (This bullet corresponds to C99 6.2.2p3.)",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/Decl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Decl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Decl.cpp:165,Integrability,interface,interface,165,"// - a non-template variable of non-volatile const-qualified type, unless; // - it is explicitly declared extern, or; // - it is declared in the purview of a module interface unit; // (outside the private-module-fragment, if any) or module partition, or; // - it is inline, or; // - it was previously declared and the prior declaration did not have; // internal linkage; // (There is no equivalent in C99.)",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/Decl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Decl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Decl.cpp:20,Modifiability,variab,variable,20,"// - a non-template variable of non-volatile const-qualified type, unless; // - it is explicitly declared extern, or; // - it is declared in the purview of a module interface unit; // (outside the private-module-fragment, if any) or module partition, or; // - it is inline, or; // - it was previously declared and the prior declaration did not have; // internal linkage; // (There is no equivalent in C99.)",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/Decl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Decl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Decl.cpp:132,Safety,avoid,avoid,132,"// FIXME: The check for extern ""C"" here is not justified by the standard; // wording, but we retain it from the pre-DR1113 model to avoid breaking; // code.; //; // C++11 [basic.link]p4:; // An unnamed namespace or a namespace declared directly or indirectly; // within an unnamed namespace has internal linkage.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/Decl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Decl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Decl.cpp:573,Modifiability,variab,variable,573,"// C++ [basic.link]p4:; // A name having namespace scope that has not been given internal linkage; // above and that is the name of; // [...bullets...]; // has its linkage determined as follows:; // - if the enclosing namespace has internal linkage, the name has; // internal linkage; [handled above]; // - otherwise, if the declaration of the name is attached to a named; // module and is not exported, the name has module linkage;; // - otherwise, the name has external linkage.; // LV is currently set up to handle the last two bullets.; //; // The bullets are:; // - a variable; or",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/Decl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Decl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Decl.cpp:45,Modifiability,variab,variables,45,"// GCC applies the following optimization to variables and static; // data members, but not to functions:; //; // Modify the variable's LV by the LV of its type unless this is; // C or extern ""C"". This follows from [basic.link]p9:; // A type without linkage shall not be used as the type of a; // variable or function with external linkage unless; // - the entity has C language linkage, or; // - the entity is declared within an unnamed namespace, or; // - the entity is not used or is defined in the same; // translation unit.; // and [basic.link]p10:; // ...the types specified by all declarations referring to a; // given variable or function shall be identical...; // C does not have an equivalent rule.; //; // Ignore this if we've got an explicit attribute; the user; // probably knows what they're doing.; //; // Note that we don't want to make the variable non-external; // because of this, but unique-external linkage suits us.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/Decl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Decl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Decl.cpp:125,Modifiability,variab,variable,125,"// GCC applies the following optimization to variables and static; // data members, but not to functions:; //; // Modify the variable's LV by the LV of its type unless this is; // C or extern ""C"". This follows from [basic.link]p9:; // A type without linkage shall not be used as the type of a; // variable or function with external linkage unless; // - the entity has C language linkage, or; // - the entity is declared within an unnamed namespace, or; // - the entity is not used or is defined in the same; // translation unit.; // and [basic.link]p10:; // ...the types specified by all declarations referring to a; // given variable or function shall be identical...; // C does not have an equivalent rule.; //; // Ignore this if we've got an explicit attribute; the user; // probably knows what they're doing.; //; // Note that we don't want to make the variable non-external; // because of this, but unique-external linkage suits us.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/Decl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Decl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Decl.cpp:297,Modifiability,variab,variable,297,"// GCC applies the following optimization to variables and static; // data members, but not to functions:; //; // Modify the variable's LV by the LV of its type unless this is; // C or extern ""C"". This follows from [basic.link]p9:; // A type without linkage shall not be used as the type of a; // variable or function with external linkage unless; // - the entity has C language linkage, or; // - the entity is declared within an unnamed namespace, or; // - the entity is not used or is defined in the same; // translation unit.; // and [basic.link]p10:; // ...the types specified by all declarations referring to a; // given variable or function shall be identical...; // C does not have an equivalent rule.; //; // Ignore this if we've got an explicit attribute; the user; // probably knows what they're doing.; //; // Note that we don't want to make the variable non-external; // because of this, but unique-external linkage suits us.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/Decl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Decl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Decl.cpp:626,Modifiability,variab,variable,626,"// GCC applies the following optimization to variables and static; // data members, but not to functions:; //; // Modify the variable's LV by the LV of its type unless this is; // C or extern ""C"". This follows from [basic.link]p9:; // A type without linkage shall not be used as the type of a; // variable or function with external linkage unless; // - the entity has C language linkage, or; // - the entity is declared within an unnamed namespace, or; // - the entity is not used or is defined in the same; // translation unit.; // and [basic.link]p10:; // ...the types specified by all declarations referring to a; // given variable or function shall be identical...; // C does not have an equivalent rule.; //; // Ignore this if we've got an explicit attribute; the user; // probably knows what they're doing.; //; // Note that we don't want to make the variable non-external; // because of this, but unique-external linkage suits us.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/Decl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Decl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Decl.cpp:857,Modifiability,variab,variable,857,"// GCC applies the following optimization to variables and static; // data members, but not to functions:; //; // Modify the variable's LV by the LV of its type unless this is; // C or extern ""C"". This follows from [basic.link]p9:; // A type without linkage shall not be used as the type of a; // variable or function with external linkage unless; // - the entity has C language linkage, or; // - the entity is declared within an unnamed namespace, or; // - the entity is not used or is defined in the same; // translation unit.; // and [basic.link]p10:; // ...the types specified by all declarations referring to a; // given variable or function shall be identical...; // C does not have an equivalent rule.; //; // Ignore this if we've got an explicit attribute; the user; // probably knows what they're doing.; //; // Note that we don't want to make the variable non-external; // because of this, but unique-external linkage suits us.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/Decl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Decl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Decl.cpp:29,Performance,optimiz,optimization,29,"// GCC applies the following optimization to variables and static; // data members, but not to functions:; //; // Modify the variable's LV by the LV of its type unless this is; // C or extern ""C"". This follows from [basic.link]p9:; // A type without linkage shall not be used as the type of a; // variable or function with external linkage unless; // - the entity has C language linkage, or; // - the entity is declared within an unnamed namespace, or; // - the entity is not used or is defined in the same; // translation unit.; // and [basic.link]p10:; // ...the types specified by all declarations referring to a; // given variable or function shall be identical...; // C does not have an equivalent rule.; //; // Ignore this if we've got an explicit attribute; the user; // probably knows what they're doing.; //; // Note that we don't want to make the variable non-external; // because of this, but unique-external linkage suits us.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/Decl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Decl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Decl.cpp:121,Modifiability,variab,variables,121,"// In theory, we can modify the function's LV by the LV of its; // type unless it has C linkage (see comment above about variables; // for justification). In practice, GCC doesn't do this, so it's; // just too painful to make work.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/Decl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Decl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Decl.cpp:289,Usability,usab,usable,289,"// Note that Sema::MergeCompatibleFunctionDecls already takes care of; // merging storage classes and visibility attributes, so we don't have to; // look at previous decls in here.; // In C++, then if the type of the function uses a type with; // unique-external linkage, it's not legally usable from outside; // this translation unit. However, we should use the C linkage; // rules instead for extern ""C"" declarations.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/Decl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Decl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Decl.cpp:63,Integrability,interface,interfaces,63,"// By extension, we assign external linkage to Objective-C; // interfaces.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/Decl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Decl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Decl.cpp:33,Modifiability,variab,variable,33,// A GUID behaves like an inline variable with external linkage. Fall; // through.; // Everything not covered here has no linkage.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/Decl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Decl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Decl.cpp:5,Usability,GUID,GUID,5,// A GUID behaves like an inline variable with external linkage. Fall; // through.; // Everything not covered here has no linkage.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/Decl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Decl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Decl.cpp:14,Modifiability,variab,variable,14,"// Modify the variable's linkage by its type, but ignore the; // type's visibility unless it's a definition.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/Decl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Decl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Decl.cpp:3,Performance,optimiz,optimization,3,// optimization: hasDVA() is true only with explicit visibility.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/Decl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Decl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Decl.cpp:113,Modifiability,variab,variable,113,"// [C++2c] [basic.scope.scope]/p5; // A declaration is name-independent if its name is _ and it declares; // - a variable with automatic storage duration,; // - a structured binding not inhabiting a namespace scope,; // - the variable introduced by an init-capture; // - or a non-static data member.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/Decl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Decl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Decl.cpp:226,Modifiability,variab,variable,226,"// [C++2c] [basic.scope.scope]/p5; // A declaration is name-independent if its name is _ and it declares; // - a variable with automatic storage duration,; // - a structured binding not inhabiting a namespace scope,; // - the variable introduced by an init-capture; // - or a non-static data member.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/Decl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Decl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Decl.cpp:21,Modifiability,variab,variable,21,// and it declares a variable with automatic storage duration,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/Decl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Decl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Decl.cpp:93,Modifiability,variab,variable,93,"// C++ [dcl.link]/7:; // Two declarations [conflict] if [...] one declares a function or; // variable with C language linkage, and the other declares [...] a; // variable that belongs to the global scope.; //; // Therefore names that are reserved at global scope are also reserved as; // names of variables and functions with C language linkage.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/Decl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Decl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Decl.cpp:162,Modifiability,variab,variable,162,"// C++ [dcl.link]/7:; // Two declarations [conflict] if [...] one declares a function or; // variable with C language linkage, and the other declares [...] a; // variable that belongs to the global scope.; //; // Therefore names that are reserved at global scope are also reserved as; // names of variables and functions with C language linkage.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/Decl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Decl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Decl.cpp:297,Modifiability,variab,variables,297,"// C++ [dcl.link]/7:; // Two declarations [conflict] if [...] one declares a function or; // variable with C language linkage, and the other declares [...] a; // variable that belongs to the global scope.; //; // Therefore names that are reserved at global scope are also reserved as; // names of variables and functions with C language linkage.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/Decl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Decl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Decl.cpp:160,Modifiability,variab,variables,160,"// If a function is hidden by -fvisibility-inlines-hidden option and; // is not explicitly attributed as a hidden function,; // we should not make static local variables in the function hidden.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/Decl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Decl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Decl.cpp:76,Integrability,interface,interface,76,"// For ObjC methods and properties, look through categories and use the; // interface as context.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/Decl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Decl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Decl.cpp:57,Availability,error,error,57,"// For parameters, pick the newer one. This is either an error or (in; // Objective-C) permitted as an extension.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/Decl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Decl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Decl.cpp:39,Energy Efficiency,allocate,allocated,39,// Make sure the extended decl info is allocated.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/Decl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Decl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Decl.cpp:17,Modifiability,extend,extended,17,// Make sure the extended decl info is allocated.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/Decl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Decl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Decl.cpp:13,Modifiability,extend,extended,13,// Save (non-extended) type source info pointer.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/Decl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Decl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Decl.cpp:3,Energy Efficiency,Allocate,Allocate,3,// Allocate external info struct.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/Decl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Decl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Decl.cpp:28,Modifiability,extend,extended,28,// Restore savedTInfo into (extended) decl info.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/Decl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Decl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Decl.cpp:39,Energy Efficiency,allocate,allocated,39,// Make sure the extended decl info is allocated.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/Decl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Decl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Decl.cpp:17,Modifiability,extend,extended,17,// Make sure the extended decl info is allocated.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/Decl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Decl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Decl.cpp:13,Modifiability,extend,extended,13,// Save (non-extended) type source info pointer.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/Decl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Decl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Decl.cpp:3,Energy Efficiency,Allocate,Allocate,3,// Allocate external info struct.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/Decl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Decl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Decl.cpp:28,Modifiability,extend,extended,28,// Restore savedTInfo into (extended) decl info.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/Decl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Decl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Decl.cpp:39,Energy Efficiency,allocate,allocated,39,// Make sure the extended decl info is allocated.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/Decl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Decl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Decl.cpp:17,Modifiability,extend,extended,17,// Make sure the extended decl info is allocated.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/Decl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Decl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Decl.cpp:13,Modifiability,extend,extended,13,// Save (non-extended) type source info pointer.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/Decl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Decl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Decl.cpp:3,Energy Efficiency,Allocate,Allocate,3,// Allocate external info struct.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/Decl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Decl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Decl.cpp:28,Modifiability,extend,extended,28,// Restore savedTInfo into (extended) decl info.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/Decl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Decl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Decl.cpp:46,Modifiability,extend,extends,46,// If the declaration has no name or the type extends past the name take the; // end location of the type.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/Decl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Decl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Decl.cpp:87,Modifiability,variab,variable,87,"// C++ [dcl.link]p1: All function types, function names with external linkage,; // and variable names with external linkage have a language linkage.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/Decl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Decl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Decl.cpp:188,Availability,error,error,188,"// If the first decl is in an extern ""C"" context, any other redeclaration; // will have C language linkage. If the first one is not in an extern ""C""; // context, we would have reported an error for any other decl being in one.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/Decl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Decl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Decl.cpp:319,Modifiability,variab,variable,319,"// C++ [basic.def]p2:; // A declaration is a definition unless [...] it contains the 'extern'; // specifier or a linkage-specification and neither an initializer [...],; // it declares a non-inline static data member in a class declaration [...],; // it declares a static data member outside a class definition and the variable; // was defined within the class with the constexpr specifier [...],; // C++1y [temp.expl.spec]p15:; // An explicit specialization of a static data member or an explicit; // specialization of a static data member template is a definition if the; // declaration includes an initializer; otherwise, it is a declaration.; //; // FIXME: How do you declare (but not define) a partial specialization of; // a static data member template outside the containing class?",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/Decl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Decl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Decl.cpp:123,Modifiability,variab,variable,123,"// If the first declaration is out-of-line, this may be an; // instantiation of an out-of-line partial specialization of a variable; // template for which we have not yet instantiated the initializer.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/Decl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Decl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Decl.cpp:5,Modifiability,variab,variable,5,// A variable template specialization (other than a static data member; // template or an explicit specialization) is a declaration until we; // instantiate its initializer.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/Decl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Decl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Decl.cpp:33,Modifiability,variab,variables,33,"// OpenCL permits const integral variables to be used in constant; // expressions, like in C++98.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/Decl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Decl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Decl.cpp:33,Usability,usab,usable,33,// Function parameters are never usable in constant expressions.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/Decl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Decl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Decl.cpp:22,Modifiability,variab,variables,22,// The values of weak variables are never usable in constant expressions.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/Decl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Decl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Decl.cpp:42,Usability,usab,usable,42,// The values of weak variables are never usable in constant expressions.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/Decl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Decl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Decl.cpp:17,Modifiability,variab,variable,17,"// In C++11, any variable of reference type can be used in a constant; // expression if it is initialized by a constant expression.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/Decl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Decl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Decl.cpp:97,Modifiability,variab,variable,97,"// Only const objects can be used in constant expressions in C++. C++98 does; // not require the variable to be non-volatile, but we consider this to be a; // defect.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/Decl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Decl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Decl.cpp:31,Modifiability,variab,variables,31,"// In C++, const, non-volatile variables of integral or enumeration types; // can be used in constant expressions.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/Decl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Decl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Decl.cpp:50,Modifiability,variab,variables,50,"// Additionally, in C++11, non-volatile constexpr variables can be used in; // constant expressions.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/Decl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Decl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Decl.cpp:31,Modifiability,variab,variable,31,// C++2a [expr.const]p3:; // A variable is usable in constant expressions after its initializing; // declaration is encountered...,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/Decl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Decl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Decl.cpp:43,Usability,usab,usable,43,// C++2a [expr.const]p3:; // A variable is usable in constant expressions after its initializing; // declaration is encountered...,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/Decl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Decl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Decl.cpp:28,Modifiability,variab,variable,28,"// ... if it is a constexpr variable, or it is of reference type or of; // const-qualified integral or enumeration type, ...",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/Decl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Decl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Decl.cpp:90,Modifiability,variab,variables,90,// C++98 [expr.const]p1:; // An integral constant-expression can involve only [...] const variables; // or static data members of integral or enumeration types initialized with; // [integer] constant expressions (dcl.init),MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/Decl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Decl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Decl.cpp:82,Energy Efficiency,allocate,allocated,82,"// Note: EvaluatedStmt contains an APValue, which usually holds; // resources not allocated from the ASTContext. We need to do some; // work to avoid leaking those, but we do so in VarDecl::evaluateValue; // where we can detect whether there's anything to clean up or not.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/Decl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Decl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Decl.cpp:144,Safety,avoid,avoid,144,"// Note: EvaluatedStmt contains an APValue, which usually holds; // resources not allocated from the ASTContext. We need to do some; // work to avoid leaking those, but we do so in VarDecl::evaluateValue; // where we can detect whether there's anything to clean up or not.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/Decl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Decl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Decl.cpp:221,Safety,detect,detect,221,"// Note: EvaluatedStmt contains an APValue, which usually holds; // resources not allocated from the ASTContext. We need to do some; // work to avoid leaking those, but we do so in VarDecl::evaluateValue; // where we can detect whether there's anything to clean up or not.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/Decl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Decl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Decl.cpp:14,Integrability,depend,depends,14,"// In C++, it depends on whether the evaluation at the point of definition; // was evaluatable as a constant initializer.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/Decl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Decl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Decl.cpp:27,Modifiability,variab,variable,27,"// If it's an instantiated variable template specialization, find the; // template or partial specialization from which it was instantiated.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/Decl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Decl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Decl.cpp:31,Modifiability,variab,variable,31,"// If this is the pattern of a variable template, find where it was; // instantiated from. FIXME: Is this necessary?",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/Decl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Decl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Decl.cpp:49,Modifiability,variab,variables,49,"// In CUDA mode without relocatable device code, variables of form 'extern; // __shared__ Foo foo[]' are pointers to the base of the GPU core's shared; // memory pool. These are never undefined variables, even if they appear; // inside of an anon namespace or static function.; //; // With CUDA relocatable device code enabled, these variables don't get; // special handling; they're treated like regular extern variables.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/Decl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Decl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Decl.cpp:194,Modifiability,variab,variables,194,"// In CUDA mode without relocatable device code, variables of form 'extern; // __shared__ Foo foo[]' are pointers to the base of the GPU core's shared; // memory pool. These are never undefined variables, even if they appear; // inside of an anon namespace or static function.; //; // With CUDA relocatable device code enabled, these variables don't get; // special handling; they're treated like regular extern variables.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/Decl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Decl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Decl.cpp:334,Modifiability,variab,variables,334,"// In CUDA mode without relocatable device code, variables of form 'extern; // __shared__ Foo foo[]' are pointers to the base of the GPU core's shared; // memory pool. These are never undefined variables, even if they appear; // inside of an anon namespace or static function.; //; // With CUDA relocatable device code enabled, these variables don't get; // special handling; they're treated like regular extern variables.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/Decl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Decl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Decl.cpp:412,Modifiability,variab,variables,412,"// In CUDA mode without relocatable device code, variables of form 'extern; // __shared__ Foo foo[]' are pointers to the base of the GPU core's shared; // memory pool. These are never undefined variables, even if they appear; // inside of an anon namespace or static function.; //; // With CUDA relocatable device code enabled, these variables don't get; // special handling; they're treated like regular extern variables.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/Decl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Decl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Decl.cpp:461,Availability,error,error,461,"// If this is a friend function defined in a class template, it does not; // have a body until it is used, nevertheless it is a definition, see; // [temp.inst]p2:; //; // ... for the purpose of determining whether an instantiated redeclaration; // is valid according to [basic.def.odr] and [class.mem], a declaration that; // corresponds to a definition in the template is considered to be a; // definition.; //; // The following code must produce redefinition error:; //; // template<typename T> struct C20 { friend void func_20() {} };; // C20<int> c20i;; // void func_20() {}; //",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/Decl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Decl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Decl.cpp:146,Integrability,depend,depends,146,// C++20 [temp.friend]p9:; // A non-template friend declaration with a requires-clause [or]; // a friend function template with a constraint that depends on a template; // parameter from an enclosing template [...] does not declare the same; // function or function template as a declaration in any other scope.; // If this isn't a friend then it's not a member-like constrained friend.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/Decl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Decl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Decl.cpp:124,Usability,simpl,simple,124,"// If these friends don't have constraints, they aren't constrained, and; // thus don't fall under temp.friend p9. Else the simple presence of a; // constraint makes them unique.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/Decl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Decl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Decl.cpp:569,Integrability,wrap,wrapper,569,"/// Returns a value indicating whether this function corresponds to a builtin; /// function.; ///; /// The function corresponds to a built-in function if it is declared at; /// translation scope or within an extern ""C"" block and its name matches with; /// the name of a builtin. The returned value will be 0 for functions that do; /// not correspond to a builtin, a value of type \c Builtin::ID if in the; /// target-independent range \c [1,Builtin::First), or a target-specific builtin; /// value.; ///; /// \param ConsiderWrapperFunctions If true, we should consider wrapper; /// functions as their wrapped builtins. This shouldn't be done in general, but; /// it's useful in Sema to diagnose calls to wrappers based on their semantics.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/Decl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Decl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Decl.cpp:601,Integrability,wrap,wrapped,601,"/// Returns a value indicating whether this function corresponds to a builtin; /// function.; ///; /// The function corresponds to a built-in function if it is declared at; /// translation scope or within an extern ""C"" block and its name matches with; /// the name of a builtin. The returned value will be 0 for functions that do; /// not correspond to a builtin, a value of type \c Builtin::ID if in the; /// target-independent range \c [1,Builtin::First), or a target-specific builtin; /// value.; ///; /// \param ConsiderWrapperFunctions If true, we should consider wrapper; /// functions as their wrapped builtins. This shouldn't be done in general, but; /// it's useful in Sema to diagnose calls to wrappers based on their semantics.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/Decl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Decl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Decl.cpp:704,Integrability,wrap,wrappers,704,"/// Returns a value indicating whether this function corresponds to a builtin; /// function.; ///; /// The function corresponds to a built-in function if it is declared at; /// translation scope or within an extern ""C"" block and its name matches with; /// the name of a builtin. The returned value will be 0 for functions that do; /// not correspond to a builtin, a value of type \c Builtin::ID if in the; /// target-independent range \c [1,Builtin::First), or a target-specific builtin; /// value.; ///; /// \param ConsiderWrapperFunctions If true, we should consider wrapper; /// functions as their wrapped builtins. This shouldn't be done in general, but; /// it's useful in Sema to diagnose calls to wrappers based on their semantics.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/Decl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Decl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Decl.cpp:94,Availability,avail,available,94,// OpenCL v1.2 s6.9.f - The library functions defined in; // the C99 standard headers are not available.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/Decl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Decl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Decl.cpp:49,Testability,test,test,49,// Only consider file-scope declarations in this test.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/Decl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Decl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Decl.cpp:196,Availability,avail,available,196,"/// For an inline function definition in C, or for a gnu_inline function; /// in C++, determine whether the definition will be externally visible.; ///; /// Inline function definitions are always available for inlining optimizations.; /// However, depending on the language dialect, declaration specifiers, and; /// attributes, the definition of an inline function may or may not be; /// ""externally"" visible to other translation units in the program.; ///; /// In C99, inline definitions are not externally visible by default. However,; /// if even one of the global-scope declarations is marked ""extern inline"", the; /// inline definition becomes externally visible (C99 6.7.4p6).; ///; /// In GNU89 mode, or if the gnu_inline attribute is attached to the function; /// definition, we use the GNU semantics for inline, which are nearly the; /// opposite of C99 semantics. In particular, ""inline"" by itself will create; /// an externally visible symbol, but ""extern inline"" will not create an; /// externally visible symbol.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/Decl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Decl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Decl.cpp:248,Integrability,depend,depending,248,"/// For an inline function definition in C, or for a gnu_inline function; /// in C++, determine whether the definition will be externally visible.; ///; /// Inline function definitions are always available for inlining optimizations.; /// However, depending on the language dialect, declaration specifiers, and; /// attributes, the definition of an inline function may or may not be; /// ""externally"" visible to other translation units in the program.; ///; /// In C99, inline definitions are not externally visible by default. However,; /// if even one of the global-scope declarations is marked ""extern inline"", the; /// inline definition becomes externally visible (C99 6.7.4p6).; ///; /// In GNU89 mode, or if the gnu_inline attribute is attached to the function; /// definition, we use the GNU semantics for inline, which are nearly the; /// opposite of C99 semantics. In particular, ""inline"" by itself will create; /// an externally visible symbol, but ""extern inline"" will not create an; /// externally visible symbol.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/Decl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Decl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Decl.cpp:219,Performance,optimiz,optimizations,219,"/// For an inline function definition in C, or for a gnu_inline function; /// in C++, determine whether the definition will be externally visible.; ///; /// Inline function definitions are always available for inlining optimizations.; /// However, depending on the language dialect, declaration specifiers, and; /// attributes, the definition of an inline function may or may not be; /// ""externally"" visible to other translation units in the program.; ///; /// In C99, inline definitions are not externally visible by default. However,; /// if even one of the global-scope declarations is marked ""extern inline"", the; /// inline definition becomes externally visible (C99 6.7.4p6).; ///; /// In GNU89 mode, or if the gnu_inline attribute is attached to the function; /// definition, we use the GNU semantics for inline, which are nearly the; /// opposite of C99 semantics. In particular, ""inline"" by itself will create; /// an externally visible symbol, but ""extern inline"" will not create an; /// externally visible symbol.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/Decl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Decl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Decl.cpp:27,Testability,log,logic,27,"// Note: If you change the logic here, please change; // doesDeclarationForceExternallyVisibleDefinition as well.; //; // If it's not the case that both 'inline' and 'extern' are; // specified on the definition, then this inline definition is; // externally visible.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/Decl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Decl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Decl.cpp:32,Usability,clear,clear,32,"// FIXME: Remove this, it's not clear what it means. (Which template; // specialization kind?)",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/Decl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Decl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Decl.cpp:5,Integrability,depend,dependent,5,"// A dependent function template specialization is an explicit specialization,; // except when it's a friend declaration.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/Decl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Decl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Decl.cpp:399,Integrability,depend,dependent,399,"// This is the same as getTemplateSpecializationKind(), except that for a; // function that is both a function template specialization and a member; // specialization, we prefer the member specialization information. Eg:; //; // template<typename T> struct A {; // template<typename U> void f() {}; // template<> void f<int>() {}; // };; //; // Within the templated CXXRecordDecl, A<T>::f<int> is a dependent function; // template specialization; both getTemplateSpecializationKind() and; // getTemplateSpecializationKindForInstantiation() will return; // TSK_ExplicitSpecialization.; //; // For A<int>::f<int>():; // * getTemplateSpecializationKind() will return TSK_ExplicitSpecialization; // * getTemplateSpecializationKindForInstantiation() will return; // TSK_ImplicitInstantiation; //; // This reflects the facts that A<int>::f<int> is an explicit specialization; // of A<int>::f, and that A<int>::f<int> should be implicitly instantiated; // from A::f<int> if a definition is needed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/Decl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Decl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Decl.cpp:44,Energy Efficiency,allocate,allocated,44,// Make sure the extended qualifier info is allocated.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/Decl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Decl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Decl.cpp:17,Modifiability,extend,extended,17,// Make sure the extended qualifier info is allocated.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/Decl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Decl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Decl.cpp:39,Energy Efficiency,allocate,allocated,39,// Make sure the extended decl info is allocated.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/Decl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Decl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Decl.cpp:17,Modifiability,extend,extended,17,// Make sure the extended decl info is allocated.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/Decl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Decl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Decl.cpp:3,Energy Efficiency,Allocate,Allocate,3,// Allocate external info struct.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/Decl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Decl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Decl.cpp:85,Testability,test,test,85,// This is necessary for correctness for C++ with modules.; // FIXME: Come up with a test case that breaks without definition.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/Decl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Decl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Decl.cpp:18,Security,hash,hash,18,// Only calculate hash on first call of getODRHash per record.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/Decl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Decl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Decl.cpp:98,Security,hash,hash,98,"// For RecordDecl the ODRHash is stored in the remaining 26; // bit of RecordDeclBits, adjust the hash to accomodate.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/Decl.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Decl.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclarationName.cpp:38,Usability,guid,guide,38,"// We never want to compare deduction guide names for templates from; // different scopes, so just compare the template-name.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/DeclarationName.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclarationName.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclarationName.cpp:38,Integrability,depend,dependent,38,// A class-scope deduction guide in a dependent context has a dependent name.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/DeclarationName.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclarationName.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclarationName.cpp:62,Integrability,depend,dependent,62,// A class-scope deduction guide in a dependent context has a dependent name.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/DeclarationName.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclarationName.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclarationName.cpp:27,Usability,guid,guide,27,// A class-scope deduction guide in a dependent context has a dependent name.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/DeclarationName.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclarationName.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclBase.cpp:3,Energy Efficiency,Allocate,Allocate,3,"// Allocate an extra 8 bytes worth of storage, which ensures that the; // resulting pointer will still be 8-byte aligned.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/DeclBase.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclBase.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclBase.cpp:188,Energy Efficiency,allocate,allocate,188,"// With local visibility enabled, we track the owning module even for local; // declarations. We create the TU decl early and may not yet know what the; // LangOpts are, so conservatively allocate the storage.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/DeclBase.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclBase.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclBase.cpp:154,Safety,avoid,avoid,154,"// Defensive maneuver for ill-formed code: we're likely not to make it to; // a point where we set the access specifier, so default it to ""public""; // to avoid triggering asserts elsewhere in the front end.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/DeclBase.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclBase.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclBase.cpp:103,Security,access,access,103,"// Defensive maneuver for ill-formed code: we're likely not to make it to; // a point where we set the access specifier, so default it to ""public""; // to avoid triggering asserts elsewhere in the front end.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/DeclBase.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclBase.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclBase.cpp:171,Testability,assert,asserts,171,"// Defensive maneuver for ill-formed code: we're likely not to make it to; // a point where we set the access specifier, so default it to ""public""; // to avoid triggering asserts elsewhere in the front end.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/DeclBase.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclBase.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclBase.cpp:175,Integrability,depend,dependent,175,"// A declaration is templated if it is a template or a template pattern, or; // is within (lexcially for a friend or local function declaration,; // semantically otherwise) a dependent context.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/DeclBase.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclBase.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclBase.cpp:16,Integrability,depend,dependent,16,"// If this is a dependent lambda, there might be an enclosing variable; // template. In this case, the next step is not the parent DeclContext (or; // even a DeclContext at all).",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/DeclBase.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclBase.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclBase.cpp:62,Modifiability,variab,variable,62,"// If this is a dependent lambda, there might be an enclosing variable; // template. In this case, the next step is not the parent DeclContext (or; // even a DeclContext at all).",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/DeclBase.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclBase.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclBase.cpp:81,Modifiability,flexible,flexible,81,"// For compatibility with existing code, we treat arrays of length 0 or; // 1 as flexible array members.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/DeclBase.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclBase.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclBase.cpp:3,Testability,Test,Test,3,// Test that the field is the last in the structure.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/DeclBase.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclBase.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclBase.cpp:94,Integrability,depend,depending,94,/// Helper to get the language options from the ASTContext.; /// Defined out of line to avoid depending on ASTContext.h.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/DeclBase.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclBase.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclBase.cpp:88,Safety,avoid,avoid,88,/// Helper to get the language options from the ASTContext.; /// Defined out of line to avoid depending on ASTContext.h.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/DeclBase.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclBase.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclBase.cpp:18,Availability,avail,availability,18,"/// Determine the availability of the given declaration based on; /// the target platform.; ///; /// When it returns an availability result other than \c AR_Available,; /// if the \p Message parameter is non-NULL, it will be set to a; /// string describing why the entity is unavailable.; ///; /// FIXME: Make these strings localizable, since they end up in; /// diagnostics.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/DeclBase.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclBase.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclBase.cpp:120,Availability,avail,availability,120,"/// Determine the availability of the given declaration based on; /// the target platform.; ///; /// When it returns an availability result other than \c AR_Available,; /// if the \p Message parameter is non-NULL, it will be set to a; /// string describing why the entity is unavailable.; ///; /// FIXME: Make these strings localizable, since they end up in; /// diagnostics.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/DeclBase.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclBase.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclBase.cpp:183,Integrability,Message,Message,183,"/// Determine the availability of the given declaration based on; /// the target platform.; ///; /// When it returns an availability result other than \c AR_Available,; /// if the \p Message parameter is non-NULL, it will be set to a; /// string describing why the entity is unavailable.; ///; /// FIXME: Make these strings localizable, since they end up in; /// diagnostics.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/DeclBase.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclBase.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclBase.cpp:3,Modifiability,Variab,Variables,3,"// Variables, if they aren't definitions.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/DeclBase.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclBase.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclBase.cpp:13,Modifiability,inherit,inheritance,13,"// Attribute inheritance is processed after attribute parsing. To keep the; // order as in the source code, add inherited attributes before non-inherited; // ones.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/DeclBase.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclBase.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclBase.cpp:112,Modifiability,inherit,inherited,112,"// Attribute inheritance is processed after attribute parsing. To keep the; // order as in the source code, add inherited attributes before non-inherited; // ones.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/DeclBase.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclBase.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclBase.cpp:144,Modifiability,inherit,inherited,144,"// Attribute inheritance is processed after attribute parsing. To keep the; // order as in the source code, add inherited attributes before non-inherited; // ones.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/DeclBase.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclBase.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclBase.cpp:39,Safety,avoid,avoid,39,// Special handling of FunctionDecl to avoid de-serializing the body from PCH.; // FunctionDecl stores EndRangeLoc for this purpose.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/DeclBase.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclBase.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclBase.cpp:404,Modifiability,extend,extended,404,// Suppress this check if any of the following hold:; // 1. this is the translation unit (and thus has no parent); // 2. this is a template parameter (and thus doesn't belong to its context); // 3. this is a non-type template parameter; // 4. the context is not a record; // 5. it's invalid; // 6. it's a C++0x static_assert.; // 7. it's a block literal declaration; // 8. it's a temporary with lifetime extended due to being default value.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/DeclBase.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclBase.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclBase.cpp:81,Security,access,access,81,// FIXME: a ClassTemplateSpecialization or CXXRecordDecl can have; // AS_none as access specifier.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/DeclBase.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclBase.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclBase.cpp:36,Integrability,depend,dependent,36,// Friend function declarations are dependent if their *lexical*; // context is dependent.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/DeclBase.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclBase.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclBase.cpp:80,Integrability,depend,dependent,80,// Friend function declarations are dependent if their *lexical*; // context is dependent.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/DeclBase.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclBase.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclBase.cpp:35,Integrability,depend,dependent,35,"// FIXME: A variable template is a dependent context, but is not a; // DeclContext. A context within it (such as a lambda-expression); // should be considered dependent.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/DeclBase.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclBase.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclBase.cpp:159,Integrability,depend,dependent,159,"// FIXME: A variable template is a dependent context, but is not a; // DeclContext. A context within it (such as a lambda-expression); // should be considered dependent.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/DeclBase.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclBase.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclBase.cpp:12,Modifiability,variab,variable,12,"// FIXME: A variable template is a dependent context, but is not a; // DeclContext. A context within it (such as a lambda-expression); // should be considered dependent.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/DeclBase.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclBase.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclBase.cpp:245,Security,expose,exposed,245,"// Each buffer, even with the same name, is a distinct construct.; // Multiple buffers with the same name are allowed for backward; // compatibility.; // As long as buffers have unique resource bindings the names don't matter.; // The names get exposed via the CPU-side reflection API which; // supports querying bindings, so we cannot remove them.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/DeclBase.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclBase.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclBase.cpp:4,Performance,Load,Load,4,/// Load the declarations within this lexical storage from an; /// external source.; /// \return \c true if any declarations were added.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/DeclBase.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclBase.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclBase.cpp:3,Performance,Load,Load,3,"// Load the external declarations, if any.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/DeclBase.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclBase.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclBase.cpp:23,Performance,load,loaded,23,"// We may have already loaded just the fields of this record, in which case; // we need to ignore them.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/DeclBase.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclBase.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclBase.cpp:76,Deployability,update,update,76,"// Notify a C++ record declaration that we've added a member, so it can; // update its class-specific state.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/DeclBase.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclBase.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclBase.cpp:101,Performance,load,loaded,101,"// If we have an external source, ensure that any later redeclarations of this; // context have been loaded, since they may add names to the result of this; // lookup (or add external visible storage).",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/DeclBase.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclBase.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclBase.cpp:40,Performance,perform,perform,40,"// If there's no external storage, just perform a normal lookup and copy; // the results.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/DeclBase.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclBase.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclBase.cpp:47,Performance,perform,perform,47,"// If we already have a lookup data structure, perform the insertion into; // it. If we might have externally-stored decls with this name, look them; // up and perform the insertion. If this decl was declared outside its; // semantic context, buildLookup won't add it, so add it now.; //; // FIXME: As a performance hack, don't add such decls into the translation; // unit unless we're in C++, since qualified lookup into the TU is never; // performed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/DeclBase.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclBase.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclBase.cpp:160,Performance,perform,perform,160,"// If we already have a lookup data structure, perform the insertion into; // it. If we might have externally-stored decls with this name, look them; // up and perform the insertion. If this decl was declared outside its; // semantic context, buildLookup won't add it, so add it now.; //; // FIXME: As a performance hack, don't add such decls into the translation; // unit unless we're in C++, since qualified lookup into the TU is never; // performed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/DeclBase.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclBase.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclBase.cpp:304,Performance,perform,performance,304,"// If we already have a lookup data structure, perform the insertion into; // it. If we might have externally-stored decls with this name, look them; // up and perform the insertion. If this decl was declared outside its; // semantic context, buildLookup won't add it, so add it now.; //; // FIXME: As a performance hack, don't add such decls into the translation; // unit unless we're in C++, since qualified lookup into the TU is never; // performed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/DeclBase.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclBase.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclBase.cpp:442,Performance,perform,performed,442,"// If we already have a lookup data structure, perform the insertion into; // it. If we might have externally-stored decls with this name, look them; // up and perform the insertion. If this decl was declared outside its; // semantic context, buildLookup won't add it, so add it now.; //; // FIXME: As a performance hack, don't add such decls into the translation; // unit unless we're in C++, since qualified lookup into the TU is never; // performed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/DeclBase.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclBase.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclBase.cpp:39,Performance,load,load,39,"// If there is an external AST source, load any declarations it knows about; // with this declaration's name.; // If the lookup table contains an entry about this name it means that we; // have already checked the external source.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/DeclBase.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclBase.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclBase.cpp:37,Performance,load,loading,37,"// If this is being added as part of loading an external declaration,; // this may not be the only external declaration with this name.; // In this case, we never try to replace an existing declaration; we'll; // handle that when we finalize the list of declarations for this name.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/DeclBase.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclBase.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclBase.cpp:29,Energy Efficiency,efficient,efficient,29,"// FIXME: Use something more efficient than normal lookup for using; // directives. In C++, using directives are looked up more than anything else.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/DeclBase.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclBase.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclBase.cpp:23,Integrability,Depend,DependentStoredDeclsMaps,23,// It's okay to delete DependentStoredDeclsMaps via a StoredDeclsMap; // pointer because the subclass doesn't add anything that needs to; // be deleted.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/DeclBase.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclBase.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclBase.cpp:3,Energy Efficiency,Allocate,Allocate,3,"// Allocate the copy of the PartialDiagnostic via the ASTContext's; // BumpPtrAllocator, rather than the ASTContext itself.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/DeclBase.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclBase.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclCXX.cpp:17,Modifiability,inherit,inherited,17,// Keep track of inherited vbases for this base class.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/DeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclCXX.cpp:8,Integrability,depend,dependent,8,// Skip dependent types; we can't do any checking on them now.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/DeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclCXX.cpp:55,Modifiability,inherit,inherits,55,// C++ [class.virtual]p1:; // A class that declares or inherits a virtual function is called a; // polymorphic class.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/DeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclCXX.cpp:99,Modifiability,polymorphi,polymorphic,99,// C++ [class.virtual]p1:; // A class that declares or inherits a virtual function is called a; // polymorphic class.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/DeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclCXX.cpp:94,Performance,perform,perform,94,"// If the base class doesn't have a simple move constructor, we'll eagerly; // declare it and perform overload resolution to determine which function; // it actually calls. If it does have a simple move constructor, this; // check is correct.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/DeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclCXX.cpp:36,Usability,simpl,simple,36,"// If the base class doesn't have a simple move constructor, we'll eagerly; // declare it and perform overload resolution to determine which function; // it actually calls. If it does have a simple move constructor, this; // check is correct.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/DeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclCXX.cpp:191,Usability,simpl,simple,191,"// If the base class doesn't have a simple move constructor, we'll eagerly; // declare it and perform overload resolution to determine which function; // it actually calls. If it does have a simple move constructor, this; // check is correct.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/DeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclCXX.cpp:93,Performance,perform,perform,93,"// If the base class doesn't have a simple move assignment, we'll eagerly; // declare it and perform overload resolution to determine which function; // it actually calls. If it does have a simple move assignment, this; // check is correct.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/DeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclCXX.cpp:36,Usability,simpl,simple,36,"// If the base class doesn't have a simple move assignment, we'll eagerly; // declare it and perform overload resolution to determine which function; // it actually calls. If it does have a simple move assignment, this; // check is correct.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/DeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclCXX.cpp:190,Usability,simpl,simple,190,"// If the base class doesn't have a simple move assignment, we'll eagerly; // declare it and perform overload resolution to determine which function; // it actually calls. If it does have a simple move assignment, this; // check is correct.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/DeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclCXX.cpp:25,Security,hash,hash,25,// Previously calculated hash is stored in DefinitionData.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/DeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclCXX.cpp:18,Security,hash,hash,18,// Only calculate hash on first call of getODRHash per record.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/DeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclCXX.cpp:55,Modifiability,inherit,inherits,55,// C++ [class.virtual]p1:; // A class that declares or inherits a virtual function is called a; // polymorphic class.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/DeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclCXX.cpp:99,Modifiability,polymorphi,polymorphic,99,// C++ [class.virtual]p1:; // A class that declares or inherits a virtual function is called a; // polymorphic class.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/DeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclCXX.cpp:116,Usability,clear,clear,116,"// C++ [class]p4:; // A POD-struct is an aggregate class [...]; // Since the POD bit is meant to be C++03 POD-ness, clear it even if; // the type is technically an aggregate in C++0x since it wouldn't be; // in 03.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/DeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclCXX.cpp:40,Modifiability,inherit,inherited,40,"// Handle constructors, including those inherited from base classes.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/DeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclCXX.cpp:212,Modifiability,inherit,inherited,212,// Record if we see any constexpr constructors which are neither copy; // nor move constructors.; // C++1z [basic.types]p10:; // [...] has at least one constexpr constructor or constructor template; // (possibly inherited from a base class) that is not a copy or move; // constructor [...],MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/DeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclCXX.cpp:22,Safety,unsafe,unsafe,22,"// FIXME: We use the 'unsafe' accessor for the access specifier here,; // because Sema may not have set it yet. That's really just a misdesign; // in Sema. However, LLDB *will* have set the access specifier correctly,; // and adds declarations after the class is technically completed,; // so completeDefinition()'s overriding of the access specifiers doesn't; // work.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/DeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclCXX.cpp:30,Security,access,accessor,30,"// FIXME: We use the 'unsafe' accessor for the access specifier here,; // because Sema may not have set it yet. That's really just a misdesign; // in Sema. However, LLDB *will* have set the access specifier correctly,; // and adds declarations after the class is technically completed,; // so completeDefinition()'s overriding of the access specifiers doesn't; // work.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/DeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclCXX.cpp:47,Security,access,access,47,"// FIXME: We use the 'unsafe' accessor for the access specifier here,; // because Sema may not have set it yet. That's really just a misdesign; // in Sema. However, LLDB *will* have set the access specifier correctly,; // and adds declarations after the class is technically completed,; // so completeDefinition()'s overriding of the access specifiers doesn't; // work.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/DeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclCXX.cpp:190,Security,access,access,190,"// FIXME: We use the 'unsafe' accessor for the access specifier here,; // because Sema may not have set it yet. That's really just a misdesign; // in Sema. However, LLDB *will* have set the access specifier correctly,; // and adds declarations after the class is technically completed,; // so completeDefinition()'s overriding of the access specifiers doesn't; // work.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/DeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclCXX.cpp:334,Security,access,access,334,"// FIXME: We use the 'unsafe' accessor for the access specifier here,; // because Sema may not have set it yet. That's really just a misdesign; // in Sema. However, LLDB *will* have set the access specifier correctly,; // and adds declarations after the class is technically completed,; // so completeDefinition()'s overriding of the access specifiers doesn't; // work.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/DeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclCXX.cpp:270,Usability,clear,clear,270,"// C++03 [class]p4:; // A POD-struct is an aggregate class that has [...] no user-defined; // copy assignment operator and no user-defined destructor.; //; // Since the POD bit is meant to be C++03 POD-ness, and in C++03,; // aggregates could not have any constructors, clear it even for an; // explicitly defaulted or deleted constructor.; // type is technically an aggregate in C++0x since it wouldn't be in; // 03.; //; // Also, a user-declared move assignment operator makes a class; // non-POD. This is an extension in C++03.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/DeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclCXX.cpp:95,Security,access,access,95,"// C++0x [class]p7:; // A standard-layout class is a class that:; // [...]; // -- has the same access control for all non-static data members,",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/DeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclCXX.cpp:18,Performance,perform,perform,18,// We may need to perform overload resolution to determine whether a; // field can be moved if it's const or volatile qualified.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/DeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclCXX.cpp:63,Performance,perform,perform,63,"// For an anonymous union member, our overload resolution will perform; // overload resolution for its members.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/DeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclCXX.cpp:31,Usability,simpl,simple,31,"// If the field doesn't have a simple move constructor, we'll eagerly; // declare the move constructor for this class and we'll decide whether; // it's trivial then.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/DeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclCXX.cpp:31,Usability,simpl,simple,31,"// If the field doesn't have a simple move assignment, we'll eagerly; // declare the move assignment for this class and we'll decide whether; // it's trivial then.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/DeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclCXX.cpp:76,Modifiability,inherit,inherited,76,// C++1z [dcl.init.aggr]p1:; // An aggregate is [...] a class [...] with no inherited constructors,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/DeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclCXX.cpp:115,Usability,clear,clear,115,"// If the destructor is explicitly defaulted and not trivial or not public; // or if the destructor is deleted, we clear HasIrrelevantDestructor in; // finishedDefaultedOrDeletedMember.; // C++11 [class.dtor]p5:; // A destructor is trivial if [...] the destructor is not virtual.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/DeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclCXX.cpp:3,Deployability,Update,Update,3,// Update which trivial / non-trivial special members we have.; // addedMember will have skipped this step for this member.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/DeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclCXX.cpp:260,Modifiability,inherit,inheritance,260,/// Collect the visible conversions of a base class.; ///; /// \param Record a base class of the class we're considering; /// \param InVirtual whether this base class is a virtual base (or a base; /// of a virtual base); /// \param Access the access along the inheritance path to this base; /// \param ParentHiddenTypes the conversions provided by the inheritors; /// of this base; /// \param Output the set to which to add conversions from non-virtual bases; /// \param VOutput the set to which to add conversions from virtual bases; /// \param HiddenVBaseCs the set of conversions which were hidden in a; /// virtual base along some inheritance path,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/DeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclCXX.cpp:352,Modifiability,inherit,inheritors,352,/// Collect the visible conversions of a base class.; ///; /// \param Record a base class of the class we're considering; /// \param InVirtual whether this base class is a virtual base (or a base; /// of a virtual base); /// \param Access the access along the inheritance path to this base; /// \param ParentHiddenTypes the conversions provided by the inheritors; /// of this base; /// \param Output the set to which to add conversions from non-virtual bases; /// \param VOutput the set to which to add conversions from virtual bases; /// \param HiddenVBaseCs the set of conversions which were hidden in a; /// virtual base along some inheritance path,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/DeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclCXX.cpp:635,Modifiability,inherit,inheritance,635,/// Collect the visible conversions of a base class.; ///; /// \param Record a base class of the class we're considering; /// \param InVirtual whether this base class is a virtual base (or a base; /// of a virtual base); /// \param Access the access along the inheritance path to this base; /// \param ParentHiddenTypes the conversions provided by the inheritors; /// of this base; /// \param Output the set to which to add conversions from non-virtual bases; /// \param VOutput the set to which to add conversions from virtual bases; /// \param HiddenVBaseCs the set of conversions which were hidden in a; /// virtual base along some inheritance path,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/DeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclCXX.cpp:232,Security,Access,Access,232,/// Collect the visible conversions of a base class.; ///; /// \param Record a base class of the class we're considering; /// \param InVirtual whether this base class is a virtual base (or a base; /// of a virtual base); /// \param Access the access along the inheritance path to this base; /// \param ParentHiddenTypes the conversions provided by the inheritors; /// of this base; /// \param Output the set to which to add conversions from non-virtual bases; /// \param VOutput the set to which to add conversions from virtual bases; /// \param HiddenVBaseCs the set of conversions which were hidden in a; /// virtual base along some inheritance path,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/DeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclCXX.cpp:243,Security,access,access,243,/// Collect the visible conversions of a base class.; ///; /// \param Record a base class of the class we're considering; /// \param InVirtual whether this base class is a virtual base (or a base; /// of a virtual base); /// \param Access the access along the inheritance path to this base; /// \param ParentHiddenTypes the conversions provided by the inheritors; /// of this base; /// \param Output the set to which to add conversions from non-virtual bases; /// \param VOutput the set to which to add conversions from virtual bases; /// \param HiddenVBaseCs the set of conversions which were hidden in a; /// virtual base along some inheritance path,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/DeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclCXX.cpp:86,Performance,optimiz,optimization,86,"// The set of types which have conversions in this class or its; // subclasses. As an optimization, we don't copy the derived set; // unless it might change.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/DeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclCXX.cpp:102,Modifiability,inherit,inheritance,102,"// If this conversion is hidden and we're in a virtual base,; // remember that it's hidden along some inheritance path.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/DeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclCXX.cpp:107,Integrability,depend,dependent,107,"// If a destructor was marked as not selected, we skip it. We don't always; // have a selected destructor: dependent types, unnamed structs.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/DeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclCXX.cpp:37,Integrability,interface,interface-like,37,// All __interfaces are inheritently interface-like.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/DeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclCXX.cpp:24,Modifiability,inherit,inheritently,24,// All __interfaces are inheritently interface-like.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/DeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclCXX.cpp:3,Integrability,Interface,Interface-like,3,"// Interface-like types cannot have a user declared constructor, destructor,; // friends, VBases, conversion functions, or fields. Additionally, lambdas; // cannot be interface types.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/DeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclCXX.cpp:167,Integrability,interface,interface,167,"// Interface-like types cannot have a user declared constructor, destructor,; // friends, VBases, conversion functions, or fields. Additionally, lambdas; // cannot be interface types.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/DeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclCXX.cpp:6,Integrability,interface,interface-like,6,// No interface-like type can have a method with a definition.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/DeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclCXX.cpp:67,Integrability,interface,interface,67,"// FIXME: Any access specifiers is supposed to make this no longer interface; // like.; // If this isn't a 'special' type, it must have a single interface-like base.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/DeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclCXX.cpp:145,Integrability,interface,interface-like,145,"// FIXME: Any access specifiers is supposed to make this no longer interface; // like.; // If this isn't a 'special' type, it must have a single interface-like base.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/DeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclCXX.cpp:14,Security,access,access,14,"// FIXME: Any access specifiers is supposed to make this no longer interface; // like.; // If this isn't a 'special' type, it must have a single interface-like base.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/DeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclCXX.cpp:69,Modifiability,inherit,inherits,69,// C++ [class.abstract]p4:; // A class is abstract if it contains or inherits at least one; // pure virtual function for which the final overrider is pure; // virtual.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/DeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclCXX.cpp:7,Security,access,access,7,// Set access bits correctly on the directly-declared conversions.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/DeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclCXX.cpp:116,Deployability,patch,patching,116,"// When building with -fapple-kext, all calls must go through the vtable since; // the kernel linker can do runtime patching of vtables.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/DeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclCXX.cpp:42,Security,access,accessed,42,"// We can devirtualize calls on an object accessed by a class member access; // expression, since by C++11 [basic.life]p6 we know that it can't refer to; // a derived class object constructed in the same location.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/DeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclCXX.cpp:69,Security,access,access,69,"// We can devirtualize calls on an object accessed by a class member access; // expression, since by C++11 [basic.life]p6 we know that it can't refer to; // a derived class object constructed in the same location.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/DeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclCXX.cpp:35,Security,access,accessed,35,// Likewise for calls on an object accessed by a (non-reference) pointer to; // member access.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/DeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclCXX.cpp:87,Security,access,access,87,// Likewise for calls on an object accessed by a (non-reference) pointer to; // member access.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/DeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclCXX.cpp:520,Usability,clear,clear,520,"// C++ <=14 [basic.stc.dynamic.deallocation]p2:; // [...] If class T does not declare such an operator delete but does; // declare a member deallocation function named operator delete with; // exactly two parameters, the second of which has type std::size_t (18.1),; // then this function is a usual deallocation function.; //; // C++17 says a usual deallocation function is one with the signature; // (void* [, size_t] [, std::align_val_t] [, ...]); // and all such functions are usual deallocation functions. It's not clear; // that allowing varargs functions was intentional.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/DeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclCXX.cpp:79,Usability,GUID,GUID,79,"// FIXME: We only need to check this once, not once each time we compute a; // GUID APValue.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/DeclCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclObjC.cpp:56,Integrability,interface,interface,56,// Get the local instance/class method declared in this interface.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/DeclObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclObjC.cpp:31,Integrability,protocol,protocol,31,"// If this context is a hidden protocol definition, don't find any; // methods there.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/DeclObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclObjC.cpp:121,Integrability,interface,interface,121,"// Since instance & class methods can have the same name, the loop below; // ensures we get the correct method.; //; // @interface Whatever; // - (int) class_method;; // + (float) class_method;; // @end",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/DeclObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclObjC.cpp:9,Integrability,rout,routine,9,"/// This routine returns 'true' if a user declared setter method was; /// found in the class, its protocols, its super classes or categories.; /// It also returns 'true' if one of its categories has declared a 'readwrite'; /// property. This is because, user must provide a setter method for the; /// category's 'readwrite' property.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/DeclObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclObjC.cpp:98,Integrability,protocol,protocols,98,"/// This routine returns 'true' if a user declared setter method was; /// found in the class, its protocols, its super classes or categories.; /// It also returns 'true' if one of its categories has declared a 'readwrite'; /// property. This is because, user must provide a setter method for the; /// category's 'readwrite' property.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/DeclObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclObjC.cpp:18,Integrability,protocol,protocols,18,"// Also look into protocols, for a user declared instance method.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/DeclObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclObjC.cpp:31,Integrability,protocol,protocol,31,"// If this context is a hidden protocol definition, don't find any; // property.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/DeclObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclObjC.cpp:39,Integrability,protocol,protocol,39,// Don't find properties within hidden protocol definitions.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/DeclObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclObjC.cpp:16,Integrability,protocol,protocols,16,// Look through protocols.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/DeclObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclObjC.cpp:16,Integrability,protocol,protocols,16,// Look through protocols.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/DeclObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclObjC.cpp:143,Integrability,protocol,protocols,143,/// FindPropertyVisibleInPrimaryClass - Finds declaration of the property; /// with name 'PropertyId' in the primary class; including those in protocols; /// (direct or indirect) used by the primary class.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/DeclObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclObjC.cpp:16,Integrability,protocol,protocols,16,// Look through protocols.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/DeclObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclObjC.cpp:94,Integrability,interface,interface,94,"// Note, the properties declared only in class extensions are still copied; // into the main @interface's property list, and therefore we don't; // explicitly, have to search class extension properties.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/DeclObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclObjC.cpp:23,Integrability,protocol,protocol,23,// Check for duplicate protocol in class's protocol list.; // This is O(n*m). But it is extremely rare and number of protocols in; // class or its extension are very few.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/DeclObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclObjC.cpp:43,Integrability,protocol,protocol,43,// Check for duplicate protocol in class's protocol list.; // This is O(n*m). But it is extremely rare and number of protocols in; // class or its extension are very few.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/DeclObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclObjC.cpp:117,Integrability,protocol,protocols,117,// Check for duplicate protocol in class's protocol list.; // This is O(n*m). But it is extremely rare and number of protocols in; // class or its extension are very few.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/DeclObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclObjC.cpp:27,Integrability,protocol,protocol,27,// Do we want to warn on a protocol in extension class which; // already exist in the class? Probably not.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/DeclObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclObjC.cpp:9,Integrability,Protocol,ProtocolRefs,9,// Merge ProtocolRefs into class's protocol list;,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/DeclObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclObjC.cpp:35,Integrability,protocol,protocol,35,// Merge ProtocolRefs into class's protocol list;,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/DeclObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclObjC.cpp:134,Safety,avoid,avoid,134,// If the class introduced initializers we conservatively assume that we; // don't know if any of them is a designated initializer to avoid possible; // misleading warnings.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/DeclObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclObjC.cpp:39,Availability,recover,recover,39,// Check for a complete definition and recover if not so.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/DeclObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclObjC.cpp:39,Safety,recover,recover,39,// Check for a complete definition and recover if not so.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/DeclObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclObjC.cpp:39,Availability,recover,recover,39,// Check for a complete definition and recover if not so.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/DeclObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclObjC.cpp:39,Safety,recover,recover,39,// Check for a complete definition and recover if not so.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/DeclObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclObjC.cpp:3,Deployability,Update,Update,3,// Update all of the declarations with a pointer to the definition.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/DeclObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclObjC.cpp:57,Integrability,protocol,protocols,57,// 3. Didn't find one yet - look through primary class's protocols.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/DeclObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclObjC.cpp:57,Integrability,protocol,protocols,57,// 4. Didn't find one yet - now look through categories' protocols,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/DeclObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclObjC.cpp:38,Integrability,protocol,protocols,38,// Didn't find one yet - look through protocols.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/DeclObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclObjC.cpp:25,Security,hash,hash,25,// Previously calculated hash is stored in DefinitionData.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/DeclObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclObjC.cpp:18,Security,hash,hash,18,// Only calculate hash on first call of getODRHash per record.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/DeclObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclObjC.cpp:33,Integrability,interface,interface,33,/// A definition will return its interface declaration.; /// An interface declaration will return its definition.; /// Otherwise it will return itself.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/DeclObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclObjC.cpp:64,Integrability,interface,interface,64,/// A definition will return its interface declaration.; /// An interface declaration will return its definition.; /// Otherwise it will return itself.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/DeclObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclObjC.cpp:138,Integrability,Interface,Interface,138,"// When the container is the ObjCImplementationDecl (the primary; // @implementation), then the canonical Decl is either in; // the class Interface, or in any of its extension.; //; // So when we don't find it in the ObjCInterfaceDecl,; // sift through extensions too.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/DeclObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclObjC.cpp:3,Performance,Cache,Cache,3,// Cache the result.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/DeclObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclObjC.cpp:44,Availability,error,error,44,// There may be no interface context due to error in declaration; // of the interface (which has been reported). Recover gracefully.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/DeclObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclObjC.cpp:113,Availability,Recover,Recover,113,// There may be no interface context due to error in declaration; // of the interface (which has been reported). Recover gracefully.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/DeclObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclObjC.cpp:19,Integrability,interface,interface,19,// There may be no interface context due to error in declaration; // of the interface (which has been reported). Recover gracefully.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/DeclObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclObjC.cpp:76,Integrability,interface,interface,76,// There may be no interface context due to error in declaration; // of the interface (which has been reported). Recover gracefully.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/DeclObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclObjC.cpp:113,Safety,Recover,Recover,113,// There may be no interface context due to error in declaration; // of the interface (which has been reported). Recover gracefully.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/DeclObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclObjC.cpp:50,Integrability,protocol,protocols,50,"// In categories look for overridden methods from protocols. A method from; // category is not ""overridden"" since it is considered as the ""same"" method; // (same USR) as the one from the interface.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/DeclObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclObjC.cpp:187,Integrability,interface,interface,187,"// In categories look for overridden methods from protocols. A method from; // category is not ""overridden"" since it is considered as the ""same"" method; // (same USR) as the one from the interface.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/DeclObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclObjC.cpp:80,Integrability,protocol,protocols,80,// We found an override at this category; there is no need to look; // into its protocols.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/DeclObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclObjC.cpp:79,Integrability,protocol,protocols,79,// We found an override at this level; there is no need to look; // into other protocols or categories.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/DeclObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclObjC.cpp:72,Integrability,interface,interface,72,// Start searching for overridden methods using the method from the; // interface as starting point.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/DeclObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclObjC.cpp:72,Integrability,interface,interface,72,// Start searching for overridden methods using the method from the; // interface as starting point.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/DeclObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclObjC.cpp:38,Integrability,interface,interface,38,"// For accessor stubs, go back to the interface.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/DeclObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclObjC.cpp:7,Security,access,accessor,7,"// For accessor stubs, go back to the interface.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/DeclObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclObjC.cpp:16,Testability,stub,stubs,16,"// For accessor stubs, go back to the interface.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/DeclObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclObjC.cpp:39,Availability,recover,recover,39,// Check for a complete definition and recover if not so.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/DeclObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclObjC.cpp:39,Safety,recover,recover,39,// Check for a complete definition and recover if not so.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/DeclObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclObjC.cpp:39,Availability,recover,recover,39,// Check for a complete definition and recover if not so.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/DeclObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclObjC.cpp:39,Safety,recover,recover,39,// Check for a complete definition and recover if not so.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/DeclObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclObjC.cpp:290,Deployability,update,updated,290,"// namespace; /// all_declared_ivar_begin - return first ivar declared in this class,; /// its extensions and its implementation. Lazily build the list on first; /// access.; ///; /// Caveat: The list returned by this method reflects the current; /// state of the parser. The cache will be updated for every ivar; /// added by an extension or the implementation when they are; /// encountered.; /// See also ObjCIvarDecl::Create().",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/DeclObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclObjC.cpp:276,Performance,cache,cache,276,"// namespace; /// all_declared_ivar_begin - return first ivar declared in this class,; /// its extensions and its implementation. Lazily build the list on first; /// access.; ///; /// Caveat: The list returned by this method reflects the current; /// state of the parser. The cache will be updated for every ivar; /// added by an extension or the implementation when they are; /// encountered.; /// See also ObjCIvarDecl::Create().",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/DeclObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclObjC.cpp:166,Security,access,access,166,"// namespace; /// all_declared_ivar_begin - return first ivar declared in this class,; /// its extensions and its implementation. Lazily build the list on first; /// access.; ///; /// Caveat: The list returned by this method reflects the current; /// state of the parser. The cache will be updated for every ivar; /// added by an extension or the implementation when they are; /// encountered.; /// See also ObjCIvarDecl::Create().",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/DeclObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclObjC.cpp:3,Performance,cache,cached,3,// cached and complete!,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/DeclObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclObjC.cpp:51,Integrability,protocol,protocol,51,"/// ClassImplementsProtocol - Checks that 'lProto' protocol; /// has been implemented in IDecl class, its super class or categories (if; /// lookupCategory is true).",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/DeclObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclObjC.cpp:320,Availability,error,error,320,"// This is dubious and is added to be compatible with gcc. In gcc, it is; // also allowed assigning a protocol-qualified 'id' type to a LHS object; // when protocol in qualified LHS is in list of protocols in the rhs 'id'; // object. This IMO, should be a bug.; // FIXME: Treat this as an extension, and flag this as an error when GCC; // extensions are not enabled.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/DeclObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclObjC.cpp:102,Integrability,protocol,protocol-qualified,102,"// This is dubious and is added to be compatible with gcc. In gcc, it is; // also allowed assigning a protocol-qualified 'id' type to a LHS object; // when protocol in qualified LHS is in list of protocols in the rhs 'id'; // object. This IMO, should be a bug.; // FIXME: Treat this as an extension, and flag this as an error when GCC; // extensions are not enabled.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/DeclObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclObjC.cpp:156,Integrability,protocol,protocol,156,"// This is dubious and is added to be compatible with gcc. In gcc, it is; // also allowed assigning a protocol-qualified 'id' type to a LHS object; // when protocol in qualified LHS is in list of protocols in the rhs 'id'; // object. This IMO, should be a bug.; // FIXME: Treat this as an extension, and flag this as an error when GCC; // extensions are not enabled.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/DeclObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclObjC.cpp:196,Integrability,protocol,protocols,196,"// This is dubious and is added to be compatible with gcc. In gcc, it is; // also allowed assigning a protocol-qualified 'id' type to a LHS object; // when protocol in qualified LHS is in list of protocols in the rhs 'id'; // object. This IMO, should be a bug.; // FIXME: Treat this as an extension, and flag this as an error when GCC; // extensions are not enabled.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/DeclObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclObjC.cpp:399,Availability,error,error,399,"// Ivar's can only appear in interfaces, implementations (via synthesized; // properties), and class extensions (via direct declaration, or synthesized; // properties).; //; // FIXME: This should really be asserting this:; // (isa<ObjCCategoryDecl>(DC) &&; // cast<ObjCCategoryDecl>(DC)->IsClassExtension())); // but unfortunately we sometimes place ivars into non-class extension; // categories on error. This breaks an AST invariant, and should not be; // fixed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/DeclObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclObjC.cpp:29,Integrability,interface,interfaces,29,"// Ivar's can only appear in interfaces, implementations (via synthesized; // properties), and class extensions (via direct declaration, or synthesized; // properties).; //; // FIXME: This should really be asserting this:; // (isa<ObjCCategoryDecl>(DC) &&; // cast<ObjCCategoryDecl>(DC)->IsClassExtension())); // but unfortunately we sometimes place ivars into non-class extension; // categories on error. This breaks an AST invariant, and should not be; // fixed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/DeclObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclObjC.cpp:206,Testability,assert,asserting,206,"// Ivar's can only appear in interfaces, implementations (via synthesized; // properties), and class extensions (via direct declaration, or synthesized; // properties).; //; // FIXME: This should really be asserting this:; // (isa<ObjCCategoryDecl>(DC) &&; // cast<ObjCCategoryDecl>(DC)->IsClassExtension())); // but unfortunately we sometimes place ivars into non-class extension; // categories on error. This breaks an AST invariant, and should not be; // fixed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/DeclObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclObjC.cpp:56,Integrability,protocol,protocol,56,// lookupMethod - Lookup a instance/class method in the protocol and protocols; // it inherited.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/DeclObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclObjC.cpp:69,Integrability,protocol,protocols,69,// lookupMethod - Lookup a instance/class method in the protocol and protocols; // it inherited.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/DeclObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclObjC.cpp:86,Modifiability,inherit,inherited,86,// lookupMethod - Lookup a instance/class method in the protocol and protocols; // it inherited.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/DeclObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclObjC.cpp:3,Deployability,Update,Update,3,// Update all of the declarations with a pointer to the definition.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/DeclObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclObjC.cpp:16,Integrability,protocol,protocol,16,// Scan through protocol's protocols.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/DeclObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclObjC.cpp:27,Integrability,protocol,protocols,27,// Scan through protocol's protocols.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/DeclObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclObjC.cpp:16,Integrability,protocol,protocol,16,// Scan through protocol's protocols which did not have a matching property.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/DeclObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclObjC.cpp:27,Integrability,protocol,protocols,27,// Scan through protocol's protocols which did not have a matching property.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/DeclObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclObjC.cpp:25,Security,hash,hash,25,// Previously calculated hash is stored in DefinitionData.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/DeclObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclObjC.cpp:18,Security,hash,hash,18,// Only calculate hash on first call of getODRHash per record.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/DeclObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclObjC.cpp:13,Integrability,interface,interface,13,// The class interface might be NULL if we are working with invalid code.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/DeclObjC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclObjC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclPrinter.cpp:25,Availability,error,error,25,// This must be a syntax error.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/DeclPrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclPrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclPrinter.cpp:19,Modifiability,variab,variable,19,"// In case it is a variable declaration with a ctor, then allow; // printing on the left side for readbility.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/DeclPrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclPrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclPrinter.cpp:242,Safety,avoid,avoid,242,"// The next bits of code handle stuff like ""struct {int x;} a,b""; we're; // forced to merge the declarations because there's no other way to; // refer to the struct in question. When that struct is named instead, we; // also need to merge to avoid splitting off a stand-alone struct; // declaration that produces the warning ext_no_declarators in some; // contexts.; //; // This limited merging is safe without a bunch of other checks because it; // only merges declarations directly referring to the tag, not typedefs.; //; // Check whether the current declaration should be grouped with a previous; // non-free-standing tag declaration.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/DeclPrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclPrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclPrinter.cpp:398,Safety,safe,safe,398,"// The next bits of code handle stuff like ""struct {int x;} a,b""; we're; // forced to merge the declarations because there's no other way to; // refer to the struct in question. When that struct is named instead, we; // also need to merge to avoid splitting off a stand-alone struct; // declaration that produces the warning ext_no_declarators in some; // contexts.; //; // This limited merging is safe without a bunch of other checks because it; // only merges declarations directly referring to the tag, not typedefs.; //; // Check whether the current declaration should be grouped with a previous; // non-free-standing tag declaration.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/DeclPrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclPrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclPrinter.cpp:55,Security,access,access,55,"// Print the class definition; // FIXME: Doesn't print access specifiers, e.g., ""public:""",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/DeclPrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclPrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclPrinter.cpp:46,Usability,guid,guides,46,"// Never print ""instantiations"" for deduction guides (they don't really; // have them).",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/DeclPrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclPrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclPrinter.cpp:3,Integrability,Protocol,Protocols,3,// Protocols?,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/DeclPrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclPrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclPrinter.cpp:3,Integrability,Protocol,Protocols,3,// Protocols?,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/DeclPrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclPrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclPrinter.cpp:74,Modifiability,inherit,inheriting,74,// Use the correct record name when the using declaration is used for; // inheriting constructors.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/DeclPrinter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclPrinter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclTemplate.cpp:39,Energy Efficiency,allocate,allocate,39,"// If we never found a common pointer, allocate one now.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/DeclTemplate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclTemplate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclTemplate.cpp:82,Deployability,update,update,82,"// FIXME: If any of the declarations is from an AST file, we probably; // need an update record to add the common data.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/DeclTemplate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclTemplate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclTemplate.cpp:3,Deployability,Update,Update,3,// Update any previous declarations we saw with the common pointer.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/DeclTemplate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclTemplate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclTemplate.cpp:52,Performance,load,loaded,52,// Grab the most recent declaration to ensure we've loaded any lazy; // redeclarations of this template.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/DeclTemplate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclTemplate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclTemplate.cpp:21,Performance,load,loaded,21,// Skip over already loaded specializations.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/DeclTemplate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclTemplate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclTemplate.cpp:16,Performance,load,loaded,16,// Note that we loaded the specialization.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/DeclTemplate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclTemplate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclTemplate.cpp:49,Performance,load,load,49,"// Due to hash collisions, it can happen that we load another template; // specialization with the same hash. This is fine, as long as the next; // call to findSpecializationImpl does not find a matching Decl for the; // template arguments.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/DeclTemplate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclTemplate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclTemplate.cpp:10,Security,hash,hash,10,"// Due to hash collisions, it can happen that we load another template; // specialization with the same hash. This is fine, as long as the next; // call to findSpecializationImpl does not find a matching Decl for the; // template arguments.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/DeclTemplate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclTemplate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclTemplate.cpp:104,Security,hash,hash,104,"// Due to hash collisions, it can happen that we load another template; // specialization with the same hash. This is fine, as long as the next; // call to findSpecializationImpl does not find a matching Decl for the; // template arguments.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/DeclTemplate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclTemplate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclTemplate.cpp:20,Availability,avail,available,20,// No explicit info available.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/DeclTemplate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclTemplate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Expr.cpp:3,Testability,Log,Logical,3,// Logical OR operator.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/Expr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Expr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Expr.cpp:126,Modifiability,variab,variable,126,"// For blocks we only emit something if it is enclosed in a function; // For top-level block we'd like to include the name of variable, but we; // don't have it at this point.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/Expr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Expr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Expr.cpp:87,Safety,avoid,avoid,87,"// For incorrect code, there might not be an ObjCInterfaceDecl. Do; // a null check to avoid a crash.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/Expr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Expr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Expr.cpp:37,Modifiability,extend,extended,37,"// A character literal might be sign-extended, which; // would result in an invalid \U escape sequence.; // FIXME: multicharacter literals such as '\xFF\xFF\xFF\xFF'; // are not correctly handled.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/Expr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Expr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Expr.cpp:3,Safety,Avoid,Avoid,3,"// Avoid the expensive division. The compiler should be able to figure it; // out by itself. However as of clang 7, even with the appropriate; // llvm_unreachable added just here, it is not able to do so.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/Expr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Expr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Expr.cpp:64,Safety,safe,safe,64,// Initialize the trailing array of SourceLocation.; // This is safe since SourceLocation is POD-like.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/Expr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Expr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Expr.cpp:522,Deployability,update,updates,522,"/// getLocationOfByte - Return a source location that points to the specified; /// byte of this string literal.; ///; /// Strings are amazingly complex. They can be formed from multiple tokens and; /// can have escape sequences in them in addition to the usual trigraph and; /// escaped newline business. This routine handles this complexity.; ///; /// The *StartToken sets the first token to be searched in this function and; /// the *StartTokenByteOffset is the byte offset of the first token. Before; /// returning, it updates the *StartToken to the TokNo of the token being found; /// and sets *StartTokenByteOffset to the byte offset of the token in the; /// string.; /// Using these two parameters can reduce the time complexity from O(n^2) to; /// O(n) if one wants to get the location of byte for all the tokens in a; /// string.; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/Expr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Expr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Expr.cpp:708,Energy Efficiency,reduce,reduce,708,"/// getLocationOfByte - Return a source location that points to the specified; /// byte of this string literal.; ///; /// Strings are amazingly complex. They can be formed from multiple tokens and; /// can have escape sequences in them in addition to the usual trigraph and; /// escaped newline business. This routine handles this complexity.; ///; /// The *StartToken sets the first token to be searched in this function and; /// the *StartTokenByteOffset is the byte offset of the first token. Before; /// returning, it updates the *StartToken to the TokNo of the token being found; /// and sets *StartTokenByteOffset to the byte offset of the token in the; /// string.; /// Using these two parameters can reduce the time complexity from O(n^2) to; /// O(n) if one wants to get the location of byte for all the tokens in a; /// string.; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/Expr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Expr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Expr.cpp:310,Integrability,rout,routine,310,"/// getLocationOfByte - Return a source location that points to the specified; /// byte of this string literal.; ///; /// Strings are amazingly complex. They can be formed from multiple tokens and; /// can have escape sequences in them in addition to the usual trigraph and; /// escaped newline business. This routine handles this complexity.; ///; /// The *StartToken sets the first token to be searched in this function and; /// the *StartTokenByteOffset is the byte offset of the first token. Before; /// returning, it updates the *StartToken to the TokNo of the token being found; /// and sets *StartTokenByteOffset to the byte offset of the token in the; /// string.; /// Using these two parameters can reduce the time complexity from O(n^2) to; /// O(n) if one wants to get the location of byte for all the tokens in a; /// string.; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/Expr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Expr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Expr.cpp:69,Integrability,depend,dependent,69,"// If the Callee is a record type, then it is a not-yet-resolved; // dependent call to the call operator of that type.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/Expr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Expr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Expr.cpp:27,Integrability,depend,dependence,27,// FIXME: remove remaining dependence computation to computeDependence().,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/Expr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Expr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Expr.cpp:73,Safety,detect,detect,73,"// FIXME: We don't want this to happen. Rather, we should be able to; // detect all kinds of implicit accesses more cleanly.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/Expr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Expr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Expr.cpp:102,Security,access,accesses,102,"// FIXME: We don't want this to happen. Rather, we should be able to; // detect all kinds of implicit accesses more cleanly.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/Expr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Expr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Expr.cpp:28,Modifiability,inherit,inheritance,28,// These should not have an inheritance path.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/Expr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Expr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Expr.cpp:6,Integrability,depend,dependent,6,"// In dependent contexts, function names may change.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/Expr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Expr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Expr.cpp:104,Integrability,Rout,Routines,104,//===----------------------------------------------------------------------===//; // Generic Expression Routines; //===----------------------------------------------------------------------===//,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/Expr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Expr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Expr.cpp:18,Security,access,access,18,"// - class member access (5.2.5),",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/Expr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Expr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Expr.cpp:34,Integrability,depend,dependent,34,// Don't warn if the expr is type dependent. The type could end up; // instantiating to void.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/Expr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Expr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Expr.cpp:70,Integrability,depend,dependent,70,// This is just the 'operator co_await' call inside the guts of a; // dependent co_await call.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/Expr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Expr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Expr.cpp:3,Security,access,accessing,3,// accessing a piece of a volatile complex is a side-effect.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/Expr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Expr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Expr.cpp:358,Deployability,update,updated,358,"// Warn about operator ==,!=,<,>,<=, and >= even when user-defined operator; // overloads as there is no reasonable way to define these such that they; // have non-trivial, desirable side-effects. See the -Wunused-comparison; // warning: operators == and != are commonly typo'ed, and so warning on them; // provides additional value as well. If this list is updated,; // DiagnoseUnusedComparison should be as well.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/Expr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Expr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Expr.cpp:211,Deployability,update,updated,211,"// If the callee has attribute pure, const, or warn_unused_result, warn; // about it. void foo() { strlen(""bar""); } should warn.; //; // Note: If new cases are added here, DiagnoseUnusedExprResult should be; // updated to match for QoI.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/Expr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Expr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Expr.cpp:25,Testability,log,logically,25,"// Statement exprs don't logically have side effects themselves, but are; // sometimes used in macros in ways that give them a type that is unused.; // For example ({ blah; foo(); }) will end up with a type if foo has a type.; // however, if the result of the stmt expr is dead, we don't want to emit a; // warning.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/Expr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Expr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Expr.cpp:368,Performance,load,load,368,"// Ignore an explicit cast to void, except in C++98 if the operand is a; // volatile glvalue for which we would trigger an implicit read in any; // other language mode. (Such an implicit read always happens as part of; // the lvalue conversion in C, and happens in C++ for expressions of all; // forms where it seems likely the user intended to trigger a volatile; // load.)",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/Expr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Expr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Expr.cpp:104,Modifiability,variab,variable,104,"// Suppress the ""unused value"" warning for idiomatic usage of; // '(void)var;' used to suppress ""unused variable"" warnings.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/Expr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Expr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Expr.cpp:159,Performance,load,load,159,"// The lvalue-to-rvalue conversion would have no effect for an array.; // It's implausible that the programmer expected this to result in a; // volatile array load, so don't warn.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/Expr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Expr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Expr.cpp:44,Integrability,message,message,44,"// In this context, property reference is a message call and is pr-value.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/Expr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Expr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Expr.cpp:94,Integrability,depend,dependent,94,/// hasAnyTypeDependentArguments - Determines if any of the expressions; /// in Exprs is type-dependent.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/Expr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Expr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Expr.cpp:80,Availability,error,error,80,"// FIXME: We should be able to return ""true"" here, but it can lead to extra; // error messages. E.g. in Sema/array-init.c.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/Expr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Expr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Expr.cpp:86,Integrability,message,messages,86,"// FIXME: We should be able to return ""true"" here, but it can lead to extra; // error messages. E.g. in Sema/array-init.c.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/Expr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Expr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Expr.cpp:38,Integrability,depend,dependent,38,// Make a conservative assumption for dependent nodes.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/Expr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Expr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Expr.cpp:145,Safety,detect,detected,145,"/// isNullPointerConstant - C99 6.3.2.3p3 - Return whether this is a null; /// pointer constant or not, as well as the specific kind of constant detected.; /// Null pointer constants can be integer constant expressions with the; /// value zero, casts of zero to void*, nullptr (C++0X), or __null; /// (a GNU extension).",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/Expr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Expr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Expr.cpp:3,Availability,Error,Error-dependent,3,// Error-dependent expr should never be a null pointer.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/Expr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Expr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Expr.cpp:9,Integrability,depend,dependent,9,// Error-dependent expr should never be a null pointer.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/Expr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Expr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Expr.cpp:79,Testability,test,test,79,"// If we have an integer constant expression, we need to *evaluate* it and; // test for the value 0.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/Expr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Expr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Expr.cpp:19,Modifiability,variab,variable,19,// A static member variable can end the MemberExpr chain with either; // a MemberExpr or a DeclRefExpr.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/Expr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Expr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Expr.cpp:59,Security,access,access,59,/// containsDuplicateElements - Return true if any element access is repeated.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/Expr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Expr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Expr.cpp:10,Modifiability,Refactor,Refactor,10,"// FIXME: Refactor this code to an accessor on the AST node which returns the; // ""type"" of component access, and share with code below and in Sema.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/Expr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Expr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Expr.cpp:35,Security,access,accessor,35,"// FIXME: Refactor this code to an accessor on the AST node which returns the; // ""type"" of component access, and share with code below and in Sema.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/Expr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Expr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Expr.cpp:102,Security,access,access,102,"// FIXME: Refactor this code to an accessor on the AST node which returns the; // ""type"" of component access, and share with code below and in Sema.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/Expr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Expr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Expr.cpp:70,Integrability,depend,dependence,70,"// Copy the designators and their subexpressions, computing; // value-dependence along the way.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/Expr.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Expr.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprClassification.cpp:15,Testability,assert,assertion,15,// Enable this assertion for testing.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ExprClassification.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprClassification.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprClassification.cpp:29,Testability,test,testing,29,// Enable this assertion for testing.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ExprClassification.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprClassification.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprClassification.cpp:17,Modifiability,variab,variables,17,// ObjC instance variables are lvalues; // FIXME: ObjC++0x might have different rules,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ExprClassification.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprClassification.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprClassification.cpp:248,Security,access,access,248,"// C, C++98 [expr.sub]p1: The result is an lvalue of type ""T"".; // C++11 (DR1213): in the case of an array operand, the result is an lvalue; // if that operand is an lvalue and an xvalue otherwise.; // Subscripting vector types is more like member access.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ExprClassification.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprClassification.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprClassification.cpp:49,Security,access,accesses,49,// Subscripting matrix types behaves like member accesses.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ExprClassification.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprClassification.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprClassification.cpp:89,Modifiability,variab,variable,89,// C++ [expr.prim.general]p3: The result is an lvalue if the entity is a; // function or variable and a prvalue otherwise.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ExprClassification.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprClassification.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprClassification.cpp:10,Security,access,access,10,// Member access is complex.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ExprClassification.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprClassification.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprClassification.cpp:47,Performance,perform,performs,47,// C++ [expr.unary.op]p1: The unary * operator performs indirection:; // [...] the result is an lvalue referring to the object or function; // to which the expression points.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ExprClassification.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprClassification.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprClassification.cpp:19,Usability,simpl,simply,19,"// GNU extensions, simply look through them.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ExprClassification.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprClassification.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprClassification.cpp:44,Deployability,update,updated,44,"// C++ [expr.pre.incr]p1: The result is the updated operand; it is an; // lvalue, [...]; // Not so in C.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ExprClassification.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprClassification.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprClassification.cpp:3,Modifiability,Extend,Extended,3,// Extended vector element access is an lvalue unless there are duplicates; // in the shuffle expression.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ExprClassification.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprClassification.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprClassification.cpp:27,Security,access,access,27,// Extended vector element access is an lvalue unless there are duplicates; // in the shuffle expression.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ExprClassification.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprClassification.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprClassification.cpp:3,Usability,Simpl,Simply,3,// Simply look at the actual default argument.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ExprClassification.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprClassification.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprClassification.cpp:9,Integrability,depend,depend,9,// Casts depend completely on the target type. All casts work the same.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ExprClassification.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprClassification.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprClassification.cpp:8,Integrability,message,message,8,"// ObjC message sends are effectively function calls, if the target function; // is known.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ExprClassification.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprClassification.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprClassification.cpp:253,Performance,tune,tune,253,"// An init list can be an lvalue if it is bound to a reference and; // contains only one element. In that case, we look at that element; // for an exact classification. Init list creation takes care of the; // value kind for us, so we only need to fine-tune.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ExprClassification.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprClassification.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprClassification.cpp:87,Modifiability,variab,variable,87,"// C++ [expr.prim.general]p6: The result is an lvalue if the entity is a; // function, variable, or data member and a prvalue otherwise.; // In C, functions are not lvalues.; // In addition, NonTypeTemplateParmDecl derives from VarDecl but isn't an; // lvalue unless it's a reference type (C++ [temp.param]p6), so we need to; // special-case this.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ExprClassification.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprClassification.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprClassification.cpp:29,Security,access,access,29,"// C99 6.5.2.3p3; // For dot access, the expression is an lvalue if the first part is. For; // arrow access, it always is an lvalue.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ExprClassification.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprClassification.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprClassification.cpp:101,Security,access,access,101,"// C99 6.5.2.3p3; // For dot access, the expression is an lvalue if the first part is. For; // arrow access, it always is an lvalue.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ExprClassification.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprClassification.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprClassification.cpp:17,Security,access,accesses,17,"// ObjC property accesses are not lvalues, but get special treatment.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ExprClassification.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprClassification.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprClassification.cpp:44,Performance,perform,performed,44,"// Note that at this point, we have already performed all conversions; // according to [expr.cond]p3.; // C++ [expr.cond]p4: If the second and third operands are glvalues of the; // same value category [...], the result is of that [...] value category.; // C++ [expr.cond]p5: Otherwise, the result is a prvalue.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ExprClassification.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprClassification.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprClassification.cpp:58,Security,access,access,58,// Assignment to a property in ObjC is an implicit setter access. But a; // setter might not exist.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ExprClassification.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprClassification.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConcepts.cpp:58,Availability,Recover,RecoveryExpr,58,"// Search through the requirements, and see if any have a RecoveryExpr in it,; // which means this RequiresExpr ALSO needs to be invalid.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ExprConcepts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConcepts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConcepts.cpp:58,Safety,Recover,RecoveryExpr,58,"// Search through the requirements, and see if any have a RecoveryExpr in it,; // which means this RequiresExpr ALSO needs to be invalid.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ExprConcepts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConcepts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConcepts.cpp:29,Integrability,depend,dependency,29,// FIXME: move the computing dependency logic to ComputeDependence.h,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ExprConcepts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConcepts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConcepts.cpp:40,Testability,log,logic,40,// FIXME: move the computing dependency logic to ComputeDependence.h,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ExprConcepts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConcepts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConcepts.cpp:58,Integrability,depend,dependent,58,"// FIXME: this is incorrect for cases where we have a non-dependent; // requirement, but its parameters are instantiation-dependent. RequiresExpr; // should be instantiation-dependent if it has instantiation-dependent; // parameters.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ExprConcepts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConcepts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConcepts.cpp:122,Integrability,depend,dependent,122,"// FIXME: this is incorrect for cases where we have a non-dependent; // requirement, but its parameters are instantiation-dependent. RequiresExpr; // should be instantiation-dependent if it has instantiation-dependent; // parameters.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ExprConcepts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConcepts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConcepts.cpp:174,Integrability,depend,dependent,174,"// FIXME: this is incorrect for cases where we have a non-dependent; // requirement, but its parameters are instantiation-dependent. RequiresExpr; // should be instantiation-dependent if it has instantiation-dependent; // parameters.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ExprConcepts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConcepts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConcepts.cpp:208,Integrability,depend,dependent,208,"// FIXME: this is incorrect for cases where we have a non-dependent; // requirement, but its parameters are instantiation-dependent. RequiresExpr; // should be instantiation-dependent if it has instantiation-dependent; // parameters.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ExprConcepts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConcepts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp:520,Availability,failure,failure,520,"//===--- ExprConstant.cpp - Expression Constant Evaluator -----------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements the Expr constant evaluator.; //; // Constant expression evaluation produces four main results:; //; // * A success/failure flag indicating whether constant folding was successful.; // This is the 'bool' return value used by most of the code in this file. A; // 'false' return value indicates that constant folding has failed, and any; // appropriate diagnostic has already been produced.; //; // * An evaluated result, valid only if constant folding has not failed.; //; // * A flag indicating if evaluation encountered (unevaluated) side-effects.; // These arise in cases such as (sideEffect(), 0) and (sideEffect() || 1),; // where it is possible to determine the evaluated result regardless.; //; // * A set of notes indicating why the evaluation was not a constant expression; // (under the C++11 / C++1y rules only, at the moment), or, if folding failed; // too, why the expression could not be folded.; //; // If we are checking for a potential constant expression, failure to constant; // fold a potential constant sub-expression will be indicated by a 'false'; // return value (the expression could not be folded) and no diagnostic (the; // expression is not necessarily non-constant).; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp:1377,Availability,failure,failure,1377,"//===--- ExprConstant.cpp - Expression Constant Evaluator -----------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements the Expr constant evaluator.; //; // Constant expression evaluation produces four main results:; //; // * A success/failure flag indicating whether constant folding was successful.; // This is the 'bool' return value used by most of the code in this file. A; // 'false' return value indicates that constant folding has failed, and any; // appropriate diagnostic has already been produced.; //; // * An evaluated result, valid only if constant folding has not failed.; //; // * A flag indicating if evaluation encountered (unevaluated) side-effects.; // These arise in cases such as (sideEffect(), 0) and (sideEffect() || 1),; // where it is possible to determine the evaluated result regardless.; //; // * A set of notes indicating why the evaluation was not a constant expression; // (under the C++11 / C++1y rules only, at the moment), or, if folding failed; // too, why the expression could not be folded.; //; // If we are checking for a potential constant expression, failure to constant; // fold a potential constant sub-expression will be indicated by a 'false'; // return value (the expression could not be folded) and no diagnostic (the; // expression is not necessarily non-constant).; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp:20,Modifiability,variab,variable,20,"// If we're doing a variable assignment from e.g. malloc(N), there will; // probably be a cast of some kind. In exotic cases, we might also see a; // top-level ExprWithCleanups. Ignore them either way.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp:173,Performance,perform,perform,173,"/// True if the subobject was named in a manner not supported by C++11. Such; /// lvalues can still be folded, but they are not core constant expressions; /// and we cannot perform lvalue-to-rvalue conversions on them.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp:82,Availability,failure,failure,82,/// Determine what the most derived array's size is. Results in an assertion; /// failure if the most derived array lacks a size.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp:67,Testability,assert,assertion,67,/// Determine what the most derived array's size is. Results in an assertion; /// failure if the most derived array lacks a size.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp:4,Deployability,Update,Update,4,/// Update this designator to refer to the first element within this array.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp:4,Deployability,Update,Update,4,/// Update this designator to refer to the first element within the array of; /// elements of type T. This is an array of unknown size.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp:4,Deployability,Update,Update,4,/// Update this designator to refer to the given base or member of this; /// object.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp:4,Deployability,Update,Update,4,/// Update this designator to refer to the given complex component.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp:370,Modifiability,variab,variables,370,// FIXME: Adding this to every 'CallStackFrame' may have a nontrivial impact; // on the overall stack usage of deeply-recursing constexpr evaluations.; // (We should cache this map rather than recomputing it repeatedly.); // But let's try this and see how it goes; we can look into caching the map; // as a later change.; /// LambdaCaptureFields - Mapping from captured variables/this to; /// corresponding data members in the closure class.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp:166,Performance,cache,cache,166,// FIXME: Adding this to every 'CallStackFrame' may have a nontrivial impact; // on the overall stack usage of deeply-recursing constexpr evaluations.; // (We should cache this map rather than recomputing it repeatedly.); // But let's try this and see how it goes; we can look into caching the map; // as a later change.; /// LambdaCaptureFields - Mapping from captured variables/this to; /// corresponding data members in the closure class.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp:4,Energy Efficiency,Allocate,Allocate,4,"/// Allocate storage for an object of type T in this stack frame.; /// Populates LV with a handle to the created object. Key identifies; /// the temporary within the stack frame, and must not be reused without; /// bumping the temporary version number.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp:4,Energy Efficiency,Allocate,Allocate,4,/// Allocate storage for a parameter of a function call made in this frame.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp:123,Testability,test,test,123,"// A shorthand time trace scope struct, prints source range, for example; // {""name"":""EvaluateAsRValue"",""args"":{""detail"":""<test.cc:8:21, col:25>""}}}",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp:60,Modifiability,extend,extended,60,"/// A cleanup, and a flag indicating whether it is lifetime-extended.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp:45,Performance,perform,performed,45,/// Determine whether this cleanup should be performed at the end of the; /// given kind of scope.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp:18,Energy Efficiency,allocate,allocated,18,/// A dynamically-allocated heap object.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp:27,Energy Efficiency,allocate,allocated,27,/// The value of this heap-allocated object.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp:171,Energy Efficiency,allocate,allocate,171,/// The allocating expression; used for diagnostics. Either a CXXNewExpr; /// or a CallExpr (the latter is for direct calls to operator new inside; /// std::allocator<T>::allocate).,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp:81,Performance,perform,perform,81,/// StepsLeft - The remaining number of evaluation steps we're permitted; /// to perform. This is essentially a limit for the number of statements; /// we will evaluate.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp:116,Availability,error,error,116,"/// Enable the experimental new constant interpreter. If an expression is; /// not supported by the interpreter, an error is triggered.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp:74,Energy Efficiency,allocate,allocated,74,"/// Current heap allocations, along with the location where each was; /// allocated. We use std::map here because we need stable addresses; /// for the stored APValues.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp:35,Performance,perform,performed,35,/// The number of heap allocations performed so far in this evaluation.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp:53,Performance,perform,performing,53,"/// The current array initialization index, if we're performing array; /// initialization.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp:154,Performance,optimiz,optimizer,154,"/// Evaluate as a constant expression. Stop if we find that the expression; /// is not a constant expression. Some expressions can be retried in the; /// optimizer if we don't constant fold them here, but in an unevaluated; /// context we try to fold them immediately since the optimizer never; /// gets a chance to look at it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp:278,Performance,optimiz,optimizer,278,"/// Evaluate as a constant expression. Stop if we find that the expression; /// is not a constant expression. Some expressions can be retried in the; /// optimizer if we don't constant fold them here, but in an unevaluated; /// context we try to fold them immediately since the optimizer never; /// gets a chance to look at it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp:9,Performance,perform,perform,9,// Don't perform any constexpr calls (other than the call we're checking); // when checking a potential constant expression.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp:21,Integrability,wrap,wrapped,21,// NextCallIndex has wrapped around.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp:29,Energy Efficiency,allocate,allocate,29,"// FIXME: GH63562; // Arrays allocate an APValue per element.; // We use the number of constexpr steps as a proxy for the maximum size; // of arrays to avoid exhausting the system resources, as initialization; // of each element is likely to take some number of steps anyway.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp:152,Safety,avoid,avoid,152,"// FIXME: GH63562; // Arrays allocate an APValue per element.; // We use the number of constexpr steps as a proxy for the maximum size; // of arrays to avoid exhausting the system resources, as initialization; // of each element is likely to take some number of steps anyway.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp:12,Energy Efficiency,allocate,allocated,12,/// Get the allocated storage for the given parameter of the given call.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp:63,Energy Efficiency,allocate,allocate,63,/// Information about a stack frame for std::allocator<T>::[de]allocate.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp:37,Modifiability,extend,extended,37,// Disable the cleanups for lifetime-extended temporaries.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp:105,Energy Efficiency,reduce,reduced,105,/// Should we continue evaluation as much as possible after encountering a; /// construct which can't be reduced to a value?,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp:88,Integrability,depend,depend,88,"/// Notes that we failed to evaluate an expression that other expressions; /// directly depend on, and determine if we should keep evaluating. This; /// should only be called if we actually intend to keep evaluating.; ///; /// Call noteSideEffect() instead if we may be able to ignore the value that; /// we failed to evaluate, e.g. if we failed to evaluate Foo() in:; ///; /// (Foo(), 1) // use noteSideEffect; /// (Foo() || true) // use noteSideEffect; /// Foo() + 1 // use noteFailure",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp:3,Availability,Failure,Failure,3,"// Failure when evaluating some expression often means there is some; // subexpression whose evaluation was skipped. Therefore, (because we; // don't track whether we skipped an expression when unwinding after an; // evaluation failure) every evaluation failure that bubbles up from a; // subexpression implies that a side-effect has potentially happened. We; // skip setting the HasSideEffects flag to true until we decide to; // continue evaluating after that point, which happens here.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp:228,Availability,failure,failure,228,"// Failure when evaluating some expression often means there is some; // subexpression whose evaluation was skipped. Therefore, (because we; // don't track whether we skipped an expression when unwinding after an; // evaluation failure) every evaluation failure that bubbles up from a; // subexpression implies that a side-effect has potentially happened. We; // skip setting the HasSideEffects flag to true until we decide to; // continue evaluating after that point, which happens here.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp:254,Availability,failure,failure,254,"// Failure when evaluating some expression often means there is some; // subexpression whose evaluation was skipped. Therefore, (because we; // don't track whether we skipped an expression when unwinding after an; // evaluation failure) every evaluation failure that bubbles up from a; // subexpression implies that a side-effect has potentially happened. We; // skip setting the HasSideEffects flag to true until we decide to; // continue evaluating after that point, which happens here.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp:16,Integrability,wrap,wrapping,16,"/// RAII object wrapping a full-expression or block scope, and handling; /// the ending of the lifetime of temporaries created within it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp:56,Modifiability,extend,extended,56,"// Run all cleanups for a block scope, and non-lifetime-extended cleanups; // for a full-expression scope.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp:15,Security,access,access,15,/// Is this an access per the C++ definition?,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp:52,Integrability,wrap,wrapping,52,"// Compute the new offset in the appropriate width, wrapping at 64 bits.; // FIXME: When compiling for a 32-bit target, we should use 32-bit; // offsets.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp:63,Availability,down,down,63,/// Perform a cast towards the class of the Decl (either up or down the; /// hierarchy).,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp:4,Performance,Perform,Perform,4,/// Perform a cast towards the class of the Decl (either up or down the; /// hierarchy).,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp:4,Performance,Perform,Perform,4,/// Perform a base-to-derived member pointer cast.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp:4,Performance,Perform,Perform,4,/// Perform a derived-to-base member pointer cast.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp:293,Modifiability,extend,extending,293,"//===----------------------------------------------------------------------===//; // Misc utilities; //===----------------------------------------------------------------------===//; /// Negate an APSInt in place, converting it to a signed form if necessary, and; /// preserving its value (by extending by up to one bit as needed).",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp:4,Energy Efficiency,Allocate,Allocate,4,/// Allocate storage for a parameter of a function call made in this frame.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp:159,Modifiability,portab,portable,159,"// We always destroy parameters at the end of the call, even if we'd allow; // them to live to the end of the full-expression at runtime, in order to; // give portable results and match other compilers.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp:59,Usability,GUID,GUID,59,"// ... the address of a function,; // ... the address of a GUID [MS extension],; // ... the address of an unnamed global constant",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp:53,Modifiability,extend,extended,53,// A materialized temporary might have been lifetime-extended to static; // storage duration.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp:84,Modifiability,variab,variables,84,// A Block literal expression may be used as the initialization value for; // Block variables at global or local static scope.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp:178,Modifiability,variab,variable,178,"// FIXME:; // We can never form an lvalue with an implicit value initialization as its; // base through expression evaluation, so these only appear in one case: the; // implicit variable declaration we invent when checking whether a constexpr; // constructor can produce a constant expression. We must assume that such; // an expression might be a global lvalue.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp:30,Modifiability,variab,variables,30,// Non-static local constexpr variables have unintuitive semantics:; // constexpr int a = 1;; // constexpr const int *p = &a;; // ... is invalid because the address of 'a' is not constant. Suggest; // adding a 'static' in this case.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp:35,Modifiability,variab,variable,35,// Check if this is a thread-local variable.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp:15,Modifiability,variab,variable,15,"// A dllimport variable never acts like a constant, unless we're; // evaluating a value for use only in name mangling.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp:52,Modifiability,variab,variables,52,"// In CUDA/HIP device compilation, only device side variables have; // constant addresses.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp:548,Performance,perform,perform,548,"// __declspec(dllimport) must be handled very carefully:; // We must never initialize an expression with the thunk in C++.; // Doing otherwise would allow the same id-expression to yield; // different addresses for the same function in different translation; // units. However, this means that we must dynamically initialize the; // expression with the contents of the import address table at runtime.; //; // The C language has no notion of ODR; furthermore, it has no notion of; // dynamic initialization. This means that we are permitted to; // perform initialization with the address of the thunk.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp:68,Performance,load,loaded,68,/// Check that this evaluated value is fully-initialized and can be loaded by; /// an lvalue-to-rvalue conversion.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp:86,Energy Efficiency,allocate,allocated,86,"/// Enforce C++2a [expr.const]/4.17, which disallows new-expressions unless; /// ""the allocated storage is deallocated within the evaluation"".",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp:206,Integrability,depend,depend,206,"/// Get rounding mode to use in evaluation of the specified expression.; ///; /// If rounding mode is unknown at compile time, still try to evaluate the; /// expression. If the result is exact, it does not depend on rounding mode.; /// So return ""tonearest"" mode instead of ""dynamic"".",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp:32,Integrability,depend,depends,32,"// Inexact result means that it depends on rounding mode. If the requested; // mode is dynamic, the evaluation cannot be made in compile time.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp:168,Modifiability,variab,variable,168,"// FIXME: if:; // - evaluation triggered other FP exception, and; // - exception mode is not ""ignore"", and; // - the expression being evaluated is not a part of global variable; // initializer,; // the evaluation probably need to be rejected.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp:37,Modifiability,extend,extend,37,"// Figure out if this is a truncate, extend or noop cast.; // If the input is signed, do a sign extend, noop, or truncate.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp:96,Modifiability,extend,extend,96,"// Figure out if this is a truncate, extend or noop cast.; // If the input is signed, do a sign extend, noop, or truncate.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp:4,Performance,Perform,Perform,4,"/// Perform the given integer operation, which is known to need at most BitWidth; /// bits, and check for overflow in the original type (if that type was not an; /// unsigned type).",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp:4,Performance,Perform,Perform,4,/// Perform the given binary integer operation.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp:4,Performance,Perform,Perform,4,"/// Perform the given binary floating-point operation, in-place, on LHS.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp:89,Availability,mask,mask,89,// The boolean operations on these vector types use an instruction that; // results in a mask of '-1' for the 'truth' value. Ensure that we negate 1; // to -1 to make sure that we produce the correct value.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp:3,Performance,Perform,Perform,3,"// Perform binary operations for vector types, in place on the LHS.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp:2,Safety,Detect,DetectVirtual,2,/*DetectVirtual=*/,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp:4,Deployability,Update,Update,4,"/// Update LVal to refer to the given field, which must be a member of the type; /// currently described by LVal.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp:4,Deployability,Update,Update,4,/// Update LVal to refer to the given indirect field.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp:4,Deployability,Update,Update,4,"/// Update a pointer value to model pointer arithmetic.; /// \param Info - Information about the ongoing evaluation.; /// \param E - The expression being evaluated, for diagnostic purposes.; /// \param LVal - The pointer value to be updated.; /// \param EltTy - The pointee type represented by LVal.; /// \param Adjustment - The adjustment, in objects of type EltTy, to add.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp:233,Deployability,update,updated,233,"/// Update a pointer value to model pointer arithmetic.; /// \param Info - Information about the ongoing evaluation.; /// \param E - The expression being evaluated, for diagnostic purposes.; /// \param LVal - The pointer value to be updated.; /// \param EltTy - The pointee type represented by LVal.; /// \param Adjustment - The adjustment, in objects of type EltTy, to add.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp:4,Deployability,Update,Update,4,"/// Update an lvalue to refer to a component of a complex number.; /// \param Info - Information about the ongoing evaluation.; /// \param LVal - The lvalue to be updated.; /// \param EltTy - The complex number's component type.; /// \param Imag - False for the real component, true for the imaginary.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp:163,Deployability,update,updated,163,"/// Update an lvalue to refer to a component of a complex number.; /// \param Info - Information about the ongoing evaluation.; /// \param LVal - The lvalue to be updated.; /// \param EltTy - The complex number's component type.; /// \param Imag - False for the real component, true for the imaginary.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp:42,Modifiability,variab,variable,42,/// Try to evaluate the initializer for a variable declaration.; ///; /// \param Info Information about the ongoing evaluation.; /// \param E An expression to be used when printing diagnostics.; /// \param VD The variable whose initializer should be obtained.; /// \param Version The version of the variable within the frame.; /// \param Frame The frame in which the variable was created. Must be null; /// if this variable is not local to the evaluation.; /// \param Result Filled in with a pointer to the value of the variable.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp:213,Modifiability,variab,variable,213,/// Try to evaluate the initializer for a variable declaration.; ///; /// \param Info Information about the ongoing evaluation.; /// \param E An expression to be used when printing diagnostics.; /// \param VD The variable whose initializer should be obtained.; /// \param Version The version of the variable within the frame.; /// \param Frame The frame in which the variable was created. Must be null; /// if this variable is not local to the evaluation.; /// \param Result Filled in with a pointer to the value of the variable.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp:299,Modifiability,variab,variable,299,/// Try to evaluate the initializer for a variable declaration.; ///; /// \param Info Information about the ongoing evaluation.; /// \param E An expression to be used when printing diagnostics.; /// \param VD The variable whose initializer should be obtained.; /// \param Version The version of the variable within the frame.; /// \param Frame The frame in which the variable was created. Must be null; /// if this variable is not local to the evaluation.; /// \param Result Filled in with a pointer to the value of the variable.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp:367,Modifiability,variab,variable,367,/// Try to evaluate the initializer for a variable declaration.; ///; /// \param Info Information about the ongoing evaluation.; /// \param E An expression to be used when printing diagnostics.; /// \param VD The variable whose initializer should be obtained.; /// \param Version The version of the variable within the frame.; /// \param Frame The frame in which the variable was created. Must be null; /// if this variable is not local to the evaluation.; /// \param Result Filled in with a pointer to the value of the variable.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp:415,Modifiability,variab,variable,415,/// Try to evaluate the initializer for a variable declaration.; ///; /// \param Info Information about the ongoing evaluation.; /// \param E An expression to be used when printing diagnostics.; /// \param VD The variable whose initializer should be obtained.; /// \param Version The version of the variable within the frame.; /// \param Frame The frame in which the variable was created. Must be null; /// if this variable is not local to the evaluation.; /// \param Result Filled in with a pointer to the value of the variable.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp:520,Modifiability,variab,variable,520,/// Try to evaluate the initializer for a variable declaration.; ///; /// \param Info Information about the ongoing evaluation.; /// \param E An expression to be used when printing diagnostics.; /// \param VD The variable whose initializer should be obtained.; /// \param Version The version of the variable within the frame.; /// \param Frame The frame in which the variable was created. Must be null; /// if this variable is not local to the evaluation.; /// \param Result Filled in with a pointer to the value of the variable.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp:22,Modifiability,variab,variable,22,"// If this is a local variable, dig out its value.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp:10,Modifiability,variab,variables,10,"// Assume variables referenced within a lambda's call operator that were; // not declared within the call operator are captures and during checking; // of a potential constant expression, assume they are unknown constant; // expressions.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp:60,Usability,usab,usable,60,// Assume parameters of a potential constant expression are usable in; // constant expressions.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp:126,Modifiability,variab,variable,126,"// Dig out the initializer, and use the declaration which it's attached to.; // FIXME: We should eventually check whether the variable has a reachable; // initializing declaration.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp:32,Integrability,depend,dependent,32,"// The DeclRefExpr is not value-dependent, but the variable it refers to; // has a value-dependent initializer. This should only happen in; // constant-folding cases, where the variable is not actually of a suitable; // type for use in a constant expression (otherwise the DeclRefExpr would; // have been value-dependent too), so diagnose that.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp:89,Integrability,depend,dependent,89,"// The DeclRefExpr is not value-dependent, but the variable it refers to; // has a value-dependent initializer. This should only happen in; // constant-folding cases, where the variable is not actually of a suitable; // type for use in a constant expression (otherwise the DeclRefExpr would; // have been value-dependent too), so diagnose that.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp:311,Integrability,depend,dependent,311,"// The DeclRefExpr is not value-dependent, but the variable it refers to; // has a value-dependent initializer. This should only happen in; // constant-folding cases, where the variable is not actually of a suitable; // type for use in a constant expression (otherwise the DeclRefExpr would; // have been value-dependent too), so diagnose that.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp:51,Modifiability,variab,variable,51,"// The DeclRefExpr is not value-dependent, but the variable it refers to; // has a value-dependent initializer. This should only happen in; // constant-folding cases, where the variable is not actually of a suitable; // type for use in a constant expression (otherwise the DeclRefExpr would; // have been value-dependent too), so diagnose that.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp:177,Modifiability,variab,variable,177,"// The DeclRefExpr is not value-dependent, but the variable it refers to; // has a value-dependent initializer. This should only happen in; // constant-folding cases, where the variable is not actually of a suitable; // type for use in a constant expression (otherwise the DeclRefExpr would; // have been value-dependent too), so diagnose that.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp:18,Modifiability,variab,variable,18,"// Check that the variable is actually usable in constant expressions. For a; // const integral variable or a reference, we might have a non-constant; // initializer that we can nonetheless evaluate the initializer for. Such; // variables are not usable in constant expressions. In C++98, the; // initializer also syntactically needs to be an ICE.; //; // FIXME: We don't diagnose cases that aren't potentially usable in constant; // expressions here; doing so would regress diagnostics for things like; // reading from a volatile constexpr variable.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp:96,Modifiability,variab,variable,96,"// Check that the variable is actually usable in constant expressions. For a; // const integral variable or a reference, we might have a non-constant; // initializer that we can nonetheless evaluate the initializer for. Such; // variables are not usable in constant expressions. In C++98, the; // initializer also syntactically needs to be an ICE.; //; // FIXME: We don't diagnose cases that aren't potentially usable in constant; // expressions here; doing so would regress diagnostics for things like; // reading from a volatile constexpr variable.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp:229,Modifiability,variab,variables,229,"// Check that the variable is actually usable in constant expressions. For a; // const integral variable or a reference, we might have a non-constant; // initializer that we can nonetheless evaluate the initializer for. Such; // variables are not usable in constant expressions. In C++98, the; // initializer also syntactically needs to be an ICE.; //; // FIXME: We don't diagnose cases that aren't potentially usable in constant; // expressions here; doing so would regress diagnostics for things like; // reading from a volatile constexpr variable.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp:541,Modifiability,variab,variable,541,"// Check that the variable is actually usable in constant expressions. For a; // const integral variable or a reference, we might have a non-constant; // initializer that we can nonetheless evaluate the initializer for. Such; // variables are not usable in constant expressions. In C++98, the; // initializer also syntactically needs to be an ICE.; //; // FIXME: We don't diagnose cases that aren't potentially usable in constant; // expressions here; doing so would regress diagnostics for things like; // reading from a volatile constexpr variable.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp:39,Usability,usab,usable,39,"// Check that the variable is actually usable in constant expressions. For a; // const integral variable or a reference, we might have a non-constant; // initializer that we can nonetheless evaluate the initializer for. Such; // variables are not usable in constant expressions. In C++98, the; // initializer also syntactically needs to be an ICE.; //; // FIXME: We don't diagnose cases that aren't potentially usable in constant; // expressions here; doing so would regress diagnostics for things like; // reading from a volatile constexpr variable.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp:247,Usability,usab,usable,247,"// Check that the variable is actually usable in constant expressions. For a; // const integral variable or a reference, we might have a non-constant; // initializer that we can nonetheless evaluate the initializer for. Such; // variables are not usable in constant expressions. In C++98, the; // initializer also syntactically needs to be an ICE.; //; // FIXME: We don't diagnose cases that aren't potentially usable in constant; // expressions here; doing so would regress diagnostics for things like; // reading from a volatile constexpr variable.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp:411,Usability,usab,usable,411,"// Check that the variable is actually usable in constant expressions. For a; // const integral variable or a reference, we might have a non-constant; // initializer that we can nonetheless evaluate the initializer for. Such; // variables are not usable in constant expressions. In C++98, the; // initializer also syntactically needs to be an ICE.; //; // FIXME: We don't diagnose cases that aren't potentially usable in constant; // expressions here; doing so would regress diagnostics for things like; // reading from a volatile constexpr variable.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp:39,Modifiability,variab,variable,39,"// Never use the initializer of a weak variable, not even for constant; // folding. We can't be sure that this is the definition that will be used.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp:7,Modifiability,variab,variable,7,// The variable whose initializer we're evaluating.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp:24,Modifiability,extend,extended,24,// A temporary lifetime-extended by the variable whose initializer we're; // evaluating.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp:40,Modifiability,variab,variable,40,// A temporary lifetime-extended by the variable whose initializer we're; // evaluating.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp:30,Modifiability,extend,extend,30,"// FIXME: We can meaningfully extend this to cover non-const objects, but; // we will need special handling: we should be able to access only; // subobjects of such objects that are themselves declared const.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp:130,Security,access,access,130,"// FIXME: We can meaningfully extend this to cover non-const objects, but; // we will need special handling: we should be able to access only; // subobjects of such objects that are themselves declared const.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp:26,Security,access,access,26,"// If this isn't a ""real"" access (eg, if it's just accessing the type; // info), allow it. We assume the type doesn't change dynamically for; // subobjects of constexpr objects (even though we'd hit UB here if it; // did). FIXME: Is this right?",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp:51,Security,access,accessing,51,"// If this isn't a ""real"" access (eg, if it's just accessing the type; // info), allow it. We assume the type doesn't change dynamically for; // subobjects of constexpr objects (even though we'd hit UB here if it; // did). FIXME: Is this right?",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp:3,Security,Access,Accesses,3,// Accesses to volatile objects are prohibited.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp:150,Performance,perform,perform,150,"// If we are reading an object of class type, there may still be more; // things we need to check: if there are any mutable subobjects, we; // cannot perform this read. (This only happens when performing a trivial; // copy or assignment.)",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp:193,Performance,perform,performing,193,"// If we are reading an object of class type, there may still be more; // things we need to check: if there are any mutable subobjects, we; // cannot perform this read. (This only happens when performing a trivial; // copy or assignment.)",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp:4,Deployability,Update,Update,4,/// Update the designated sub-object of an rvalue to the given value.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp:24,Usability,GUID,GUID,24,// Allow reading from a GUID declaration.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp:112,Modifiability,variab,variables,112,"// In C++98, const, non-volatile integers initialized with ICEs are ICEs.; // In C++11, constexpr, non-volatile variables initialized with constant; // expressions are constant expressions too. Inside constexpr functions,; // parameters are constant expressions even if they're non-const.; // In C++1y, objects local to a constant expression (those with a Frame) are; // both readable and writable inside constant expressions.; // In C, such things can also be folded, although they are not ICEs.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp:35,Modifiability,variab,variable,35,"// Unless we're looking at a local variable or argument in a constexpr call,; // the variable we're reading must be const.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp:85,Modifiability,variab,variable,85,"// Unless we're looking at a local variable or argument in a constexpr call,; // the variable we're reading must be const.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp:3,Security,Access,Access,3,"// Access of a parameter that's not associated with a frame isn't going; // to work out, but we can leave it to evaluateVarDeclInit to provide a; // suitable diagnostic.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp:24,Modifiability,variab,variable,24,"// OK, we can read this variable.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp:8,Modifiability,variab,variable,8,// This variable might end up being constexpr. Don't diagnose it yet.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp:196,Modifiability,extend,extended,196,"// C++20 [expr.const]p4: [DR2126]; // An object or reference is usable in constant expressions if it is; // - a temporary object of non-volatile const-qualified literal type; // whose lifetime is extended to that of a variable that is usable; // in constant expressions; //; // C++20 [expr.const]p5:; // an lvalue-to-rvalue conversion [is not allowed unless it applies to]; // - a non-volatile glvalue that refers to an object that is usable; // in constant expressions, or; // - a non-volatile glvalue of literal type that refers to a; // non-volatile object whose lifetime began within the evaluation; // of E;; //; // C++11 misses the 'began within the evaluation of e' check and; // instead allows all temporaries, including things like:; // int &&r = 1;; // int x = ++r;; // constexpr int k = r;; // Therefore we use the C++14-onwards rules in C++11 too.; //; // Note that temporaries whose lifetimes began while evaluating a; // variable's constructor are not usable while evaluating the; // corresponding destructor, not even if they're of const-qualified; // types.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp:218,Modifiability,variab,variable,218,"// C++20 [expr.const]p4: [DR2126]; // An object or reference is usable in constant expressions if it is; // - a temporary object of non-volatile const-qualified literal type; // whose lifetime is extended to that of a variable that is usable; // in constant expressions; //; // C++20 [expr.const]p5:; // an lvalue-to-rvalue conversion [is not allowed unless it applies to]; // - a non-volatile glvalue that refers to an object that is usable; // in constant expressions, or; // - a non-volatile glvalue of literal type that refers to a; // non-volatile object whose lifetime began within the evaluation; // of E;; //; // C++11 misses the 'began within the evaluation of e' check and; // instead allows all temporaries, including things like:; // int &&r = 1;; // int x = ++r;; // constexpr int k = r;; // Therefore we use the C++14-onwards rules in C++11 too.; //; // Note that temporaries whose lifetimes began while evaluating a; // variable's constructor are not usable while evaluating the; // corresponding destructor, not even if they're of const-qualified; // types.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp:935,Modifiability,variab,variable,935,"// C++20 [expr.const]p4: [DR2126]; // An object or reference is usable in constant expressions if it is; // - a temporary object of non-volatile const-qualified literal type; // whose lifetime is extended to that of a variable that is usable; // in constant expressions; //; // C++20 [expr.const]p5:; // an lvalue-to-rvalue conversion [is not allowed unless it applies to]; // - a non-volatile glvalue that refers to an object that is usable; // in constant expressions, or; // - a non-volatile glvalue of literal type that refers to a; // non-volatile object whose lifetime began within the evaluation; // of E;; //; // C++11 misses the 'began within the evaluation of e' check and; // instead allows all temporaries, including things like:; // int &&r = 1;; // int x = ++r;; // constexpr int k = r;; // Therefore we use the C++14-onwards rules in C++11 too.; //; // Note that temporaries whose lifetimes began while evaluating a; // variable's constructor are not usable while evaluating the; // corresponding destructor, not even if they're of const-qualified; // types.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp:64,Usability,usab,usable,64,"// C++20 [expr.const]p4: [DR2126]; // An object or reference is usable in constant expressions if it is; // - a temporary object of non-volatile const-qualified literal type; // whose lifetime is extended to that of a variable that is usable; // in constant expressions; //; // C++20 [expr.const]p5:; // an lvalue-to-rvalue conversion [is not allowed unless it applies to]; // - a non-volatile glvalue that refers to an object that is usable; // in constant expressions, or; // - a non-volatile glvalue of literal type that refers to a; // non-volatile object whose lifetime began within the evaluation; // of E;; //; // C++11 misses the 'began within the evaluation of e' check and; // instead allows all temporaries, including things like:; // int &&r = 1;; // int x = ++r;; // constexpr int k = r;; // Therefore we use the C++14-onwards rules in C++11 too.; //; // Note that temporaries whose lifetimes began while evaluating a; // variable's constructor are not usable while evaluating the; // corresponding destructor, not even if they're of const-qualified; // types.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp:235,Usability,usab,usable,235,"// C++20 [expr.const]p4: [DR2126]; // An object or reference is usable in constant expressions if it is; // - a temporary object of non-volatile const-qualified literal type; // whose lifetime is extended to that of a variable that is usable; // in constant expressions; //; // C++20 [expr.const]p5:; // an lvalue-to-rvalue conversion [is not allowed unless it applies to]; // - a non-volatile glvalue that refers to an object that is usable; // in constant expressions, or; // - a non-volatile glvalue of literal type that refers to a; // non-volatile object whose lifetime began within the evaluation; // of E;; //; // C++11 misses the 'began within the evaluation of e' check and; // instead allows all temporaries, including things like:; // int &&r = 1;; // int x = ++r;; // constexpr int k = r;; // Therefore we use the C++14-onwards rules in C++11 too.; //; // Note that temporaries whose lifetimes began while evaluating a; // variable's constructor are not usable while evaluating the; // corresponding destructor, not even if they're of const-qualified; // types.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp:435,Usability,usab,usable,435,"// C++20 [expr.const]p4: [DR2126]; // An object or reference is usable in constant expressions if it is; // - a temporary object of non-volatile const-qualified literal type; // whose lifetime is extended to that of a variable that is usable; // in constant expressions; //; // C++20 [expr.const]p5:; // an lvalue-to-rvalue conversion [is not allowed unless it applies to]; // - a non-volatile glvalue that refers to an object that is usable; // in constant expressions, or; // - a non-volatile glvalue of literal type that refers to a; // non-volatile object whose lifetime began within the evaluation; // of E;; //; // C++11 misses the 'began within the evaluation of e' check and; // instead allows all temporaries, including things like:; // int &&r = 1;; // int x = ++r;; // constexpr int k = r;; // Therefore we use the C++14-onwards rules in C++11 too.; //; // Note that temporaries whose lifetimes began while evaluating a; // variable's constructor are not usable while evaluating the; // corresponding destructor, not even if they're of const-qualified; // types.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp:966,Usability,usab,usable,966,"// C++20 [expr.const]p4: [DR2126]; // An object or reference is usable in constant expressions if it is; // - a temporary object of non-volatile const-qualified literal type; // whose lifetime is extended to that of a variable that is usable; // in constant expressions; //; // C++20 [expr.const]p5:; // an lvalue-to-rvalue conversion [is not allowed unless it applies to]; // - a non-volatile glvalue that refers to an object that is usable; // in constant expressions, or; // - a non-volatile glvalue of literal type that refers to a; // non-volatile object whose lifetime began within the evaluation; // of E;; //; // C++11 misses the 'began within the evaluation of e' check and; // instead allows all temporaries, including things like:; // int &&r = 1;; // int x = ++r;; // constexpr int k = r;; // Therefore we use the C++14-onwards rules in C++11 too.; //; // Note that temporaries whose lifetimes began while evaluating a; // variable's constructor are not usable while evaluating the; // corresponding destructor, not even if they're of const-qualified; // types.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp:22,Safety,safe,safely,22,"// In C++14, we can't safely access any mutable state when we might be; // evaluating after an unmodeled side effect. Parameters are modeled as state; // in the caller, but aren't visible once the call returns, so they can be; // modified in a speculatively-evaluated call.; //; // FIXME: Not all local state is mutable. Allow local constant subobjects; // to be read here (but take care with 'mutable' fields).",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp:29,Security,access,access,29,"// In C++14, we can't safely access any mutable state when we might be; // evaluating after an unmodeled side effect. Parameters are modeled as state; // in the caller, but aren't visible once the call returns, so they can be; // modified in a speculatively-evaluated call.; //; // FIXME: Not all local state is mutable. Allow local constant subobjects; // to be read here (but take care with 'mutable' fields).",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp:4,Performance,Perform,Perform,4,"/// Perform an lvalue-to-rvalue conversion on the given glvalue. This; /// can also be used for 'lvalue-to-lvalue' conversions for looking up the; /// glvalue referred to by an entity of reference type.; ///; /// \param Info - Information about the ongoing evaluation.; /// \param Conv - The expression for which we are performing the conversion.; /// Used for diagnostics.; /// \param Type - The type of the glvalue (before stripping cv-qualifiers in the; /// case of a non-class type).; /// \param LVal - The glvalue on which we are attempting to perform this action.; /// \param RVal - The produced value will be placed here.; /// \param WantObjectRepresentation - If true, we're looking for the object; /// representation rather than the value, and in particular,; /// there is no requirement that the result be fully initialized.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp:320,Performance,perform,performing,320,"/// Perform an lvalue-to-rvalue conversion on the given glvalue. This; /// can also be used for 'lvalue-to-lvalue' conversions for looking up the; /// glvalue referred to by an entity of reference type.; ///; /// \param Info - Information about the ongoing evaluation.; /// \param Conv - The expression for which we are performing the conversion.; /// Used for diagnostics.; /// \param Type - The type of the glvalue (before stripping cv-qualifiers in the; /// case of a non-class type).; /// \param LVal - The glvalue on which we are attempting to perform this action.; /// \param RVal - The produced value will be placed here.; /// \param WantObjectRepresentation - If true, we're looking for the object; /// representation rather than the value, and in particular,; /// there is no requirement that the result be fully initialized.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp:549,Performance,perform,perform,549,"/// Perform an lvalue-to-rvalue conversion on the given glvalue. This; /// can also be used for 'lvalue-to-lvalue' conversions for looking up the; /// glvalue referred to by an entity of reference type.; ///; /// \param Info - Information about the ongoing evaluation.; /// \param Conv - The expression for which we are performing the conversion.; /// Used for diagnostics.; /// \param Type - The type of the glvalue (before stripping cv-qualifiers in the; /// case of a non-class type).; /// \param LVal - The glvalue on which we are attempting to perform this action.; /// \param RVal - The produced value will be placed here.; /// \param WantObjectRepresentation - If true, we're looking for the object; /// representation rather than the value, and in particular,; /// there is no requirement that the result be fully initialized.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp:348,Modifiability,variab,variable,348,"// According to GCC info page:; //; // 6.28 Compound Literals; //; // As an optimization, G++ sometimes gives array compound literals longer; // lifetimes: when the array either appears outside a function or has a; // const-qualified type. If foo and its initializer had elements of type; // char *const rather than char *, or if foo were a global variable, the; // array would have static storage duration. But it is probably safest; // just to avoid the use of array compound literals in C++ code.; //; // Obey that rule by checking constness for converted array types.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp:76,Performance,optimiz,optimization,76,"// According to GCC info page:; //; // 6.28 Compound Literals; //; // As an optimization, G++ sometimes gives array compound literals longer; // lifetimes: when the array either appears outside a function or has a; // const-qualified type. If foo and its initializer had elements of type; // char *const rather than char *, or if foo were a global variable, the; // array would have static storage duration. But it is probably safest; // just to avoid the use of array compound literals in C++ code.; //; // Obey that rule by checking constness for converted array types.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp:427,Safety,safe,safest,427,"// According to GCC info page:; //; // 6.28 Compound Literals; //; // As an optimization, G++ sometimes gives array compound literals longer; // lifetimes: when the array either appears outside a function or has a; // const-qualified type. If foo and its initializer had elements of type; // char *const rather than char *, or if foo were a global variable, the; // array would have static storage duration. But it is probably safest; // just to avoid the use of array compound literals in C++ code.; //; // Obey that rule by checking constness for converted array types.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp:446,Safety,avoid,avoid,446,"// According to GCC info page:; //; // 6.28 Compound Literals; //; // As an optimization, G++ sometimes gives array compound literals longer; // lifetimes: when the array either appears outside a function or has a; // const-qualified type. If foo and its initializer had elements of type; // char *const rather than char *, or if foo were a global variable, the; // array would have static storage duration. But it is probably safest; // just to avoid the use of array compound literals in C++ code.; //; // Obey that rule by checking constness for converted array types.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp:4,Performance,Perform,Perform,4,/// Perform an assignment of Val to LVal. Takes ownership of Val.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp:4,Performance,Perform,Perform,4,/// Perform a compound assignment of LVal <op>= RVal.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp:29,Usability,clear,clear,29,"// Stash the old value. Also clear Old, so we don't clobber it later; // if we're post-incrementing a complex.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp:80,Energy Efficiency,reduce,reduce,80,"// bool arithmetic promotes to int, and the conversion back to bool; // doesn't reduce mod 2^n, so special-case it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp:32,Performance,Perform,Perform,32,// end anonymous namespace; /// Perform an increment or decrement on LVal.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp:50,Security,access,access,50,"/// HandleMemberPointerAccess - Evaluate a member access operation and build an; /// lvalue referring to the result.; ///; /// \param Info - Information about the ongoing evaluation.; /// \param LV - An lvalue referring to the base of the member pointer.; /// \param RHS - The member pointer expression.; /// \param IncludeMember - Specifies whether the member itself is included in; /// the resulting LValue subobject designator. This is not possible when; /// creating a bound member function.; /// \return The field or method declaration to which the member pointer refers,; /// or 0 if evaluation fails.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp:3,Modifiability,Extend,Extend,3,// Extend the LValue path with the member pointer's path.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp:8,Availability,down,down,8,// Walk down to the appropriate base class.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp:35,Modifiability,variab,variable,35,/// Evaluate a condition (either a variable declaration or an expression).,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp:80,Performance,Cache,Cache,80,// Find the switch case corresponding to the value of the condition.; // FIXME: Cache this lookup.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp:185,Modifiability,variab,variable,185,// An expression E is a core constant expression unless the evaluation of E; // would evaluate one of the following: [C++23] - a control flow that passes; // through a declaration of a variable with static or thread storage duration; // unless that variable is usable in constant expressions.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp:249,Modifiability,variab,variable,249,// An expression E is a core constant expression unless the evaluation of E; // would evaluate one of the following: [C++23] - a control flow that passes; // through a declaration of a variable with static or thread storage duration; // unless that variable is usable in constant expressions.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp:261,Usability,usab,usable,261,// An expression E is a core constant expression unless the evaluation of E; // would evaluate one of the following: [C++23] - a control flow that passes; // through a declaration of a variable with static or thread storage duration; // unless that variable is usable in constant expressions.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp:20,Availability,down,down,20,"// If we're hunting down a 'case' or 'default' label, recurse through; // substatements until we hit the label.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp:120,Performance,perform,performing,120,"// FIXME: Precompute which substatement of a compound statement we; // would jump to, and go straight there rather than performing a; // linear scan each time.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp:3,Integrability,Wrap,Wrap,3,"// Wrap the evaluation in a block scope, in case it's a DeclStmt; // preceded by our switch label.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp:73,Modifiability,variab,variable,73,// Step into the init statement in case it brings an (uninitialized); // variable into scope.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp:13,Modifiability,variab,variable,13,"// Condition variable must be initialized if it exists.; // FIXME: We can skip evaluating the body if there's a condition; // variable, as there can't be any case labels within it.; // (The same is true for 'for' statements.)",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp:126,Modifiability,variab,variable,126,"// Condition variable must be initialized if it exists.; // FIXME: We can skip evaluating the body if there's a condition; // variable, as there can't be any case labels within it.; // (The same is true for 'for' statements.)",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp:73,Modifiability,variab,variable,73,// Step into the init statement in case it brings an (uninitialized); // variable into scope.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp:43,Modifiability,variab,variables,43,// Start the lifetime of any uninitialized variables we encounter. They; // might be used by the selected branch of the switch.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp:17,Modifiability,variab,variable,17,"// FIXME: If the variable has initialization that can't be jumped; // over, bail out of any immediately-surrounding compound-statement; // too. There can't be any case labels here.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp:26,Modifiability,variab,variable,26,// Initialize the __range variable.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp:6,Availability,error,error-recovery,6,// In error-recovery cases it's possible to get here even if we failed to; // synthesize the __begin and __end variables.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp:111,Modifiability,variab,variables,111,// In error-recovery cases it's possible to get here even if we failed to; // synthesize the __begin and __end variables.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp:12,Safety,recover,recovery,12,// In error-recovery cases it's possible to get here even if we failed to; // synthesize the __begin and __end variables.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp:10,Modifiability,variab,variable,10,"// User's variable declaration, initialized by *__begin.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp:54,Modifiability,inherit,inherited,54,"// If this function is not constexpr because it is an inherited; // non-constexpr constructor, diagnose that directly.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp:82,Modifiability,inherit,inheriting,82,"// FIXME: If DiagDecl is an implicitly-declared special member function; // or an inheriting constructor, we should be much more explicit about why; // it's not constexpr.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp:50,Security,access,access,50,// end anonymous namespace; /// Check that we can access the notional vptr of an object / determine its; /// dynamic type.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp:21,Usability,usab,usable,21,"// The object is not usable in constant expressions, so we can't inspect; // its value to see if it's in-lifetime or what the active union members; // are. We can still check for a one-past-the-end lvalue.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp:38,Modifiability,polymorphi,polymorphic,38,// Conservatively refuse to perform a polymorphic operation if we would; // not be able to read a notional 'vptr' value.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp:28,Performance,perform,perform,28,// Conservatively refuse to perform a polymorphic operation if we would; // not be able to read a notional 'vptr' value.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp:162,Modifiability,polymorphi,polymorphic,162,"// CWG issue 1517: we're constructing a base class of the object described by; // 'This', so that object has not yet begun its period of construction and; // any polymorphic operation on it results in undefined behavior.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp:4,Performance,Perform,Perform,4,/// Perform virtual dispatch.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp:3,Performance,Perform,Perform,3,// Perform 'this' adjustment.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp:4,Performance,Perform,Perform,4,"/// Perform the adjustment from a value returned by a virtual function to; /// a value of the statically expected type, which may be a pointer or; /// reference to a base class of the returned type.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp:34,Modifiability,inherit,inheritance,34,// We can only walk across public inheritance edges.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp:2,Safety,Detect,DetectVirtual,2,/*DetectVirtual=*/,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp:3,Availability,Down,Downcast,3,// Downcast to the dynamic type...,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp:22,Performance,perform,perform,22,"// We are supposed to perform no initialization but begin the lifetime of; // the object. We interpret that as meaning to do what default; // initialization of the object would do if all constructors involved were; // trivial:; // * All base, non-variant member, and array element subobjects' lifetimes; // begin; // * No variant members' lifetimes begin; // * All scalar subobjects whose lifetimes begin have indeterminate values",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp:137,Security,access,access,137,"/// Handle a builtin simple-assignment or a call to a trivial assignment; /// operator whose left-hand side might involve a union member access. If it; /// does, implicitly start the lifetime of any accessed union elements per; /// C++20 [class.union]5.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp:199,Security,access,accessed,199,"/// Handle a builtin simple-assignment or a call to a trivial assignment; /// operator whose left-hand side might involve a union member access. If it; /// does, implicitly start the lifetime of any accessed union elements per; /// C++20 [class.union]5.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp:21,Usability,simpl,simple-assignment,21,"/// Handle a builtin simple-assignment or a call to a trivial assignment; /// operator whose left-hand side might involve a union member access. If it; /// does, implicitly start the lifetime of any accessed union elements per; /// C++20 [class.union]5.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp:31,Security,access,access,31,"// if modification of X [would access an inactive union member], an object; // of the type of X is implicitly created",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp:203,Performance,perform,performing,203,"// Create the parameter slot and register its destruction. For a vararg; // argument, create a temporary.; // FIXME: For calling conventions that destroy parameters in the callee,; // should we consider performing destruction when the function returns; // instead?",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp:4,Performance,Perform,Perform,4,"/// Perform a trivial copy from Param, which is the parameter of a copy or move; /// constructor or assignment operator.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp:42,Performance,perform,perform,42,"// For a trivial copy or move assignment, perform an APValue copy. This is; // essential for unions, where the operations performed by the assignment; // operator cannot be represented as statements.; //; // Skip this for non-union classes with no fields; in that case, the defaulted; // copy/move does not actually read the object.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp:122,Performance,perform,performed,122,"// For a trivial copy or move assignment, perform an APValue copy. This is; // essential for unions, where the operations performed by the assignment; // operator cannot be represented as statements.; //; // Skip this for non-union classes with no fields; in that case, the defaulted; // copy/move does not actually read the object.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp:280,Security,access,access,280,"// We're in a lambda; determine the lambda capture field maps unless we're; // just constexpr checking a lambda's call operator. constexpr checking is; // done before the captures have been added to the closure object (unless; // we're inferring constexpr-ness), so we don't have access to them in this; // case. But since we don't need the captures to constexpr check, we can; // just ignore them.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp:43,Performance,perform,perform,43,"// For a trivial copy or move constructor, perform an APValue copy. This is; // essential for unions (or classes with anonymous union members), where the; // operations performed by the constructor cannot be represented by; // ctor-initializers.; //; // Skip this for empty non-union classes; we should not perform an; // lvalue-to-rvalue conversion on them because their copy constructor does not; // actually read them.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp:169,Performance,perform,performed,169,"// For a trivial copy or move constructor, perform an APValue copy. This is; // essential for unions (or classes with anonymous union members), where the; // operations performed by the constructor cannot be represented by; // ctor-initializers.; //; // Skip this for empty non-union classes; we should not perform an; // lvalue-to-rvalue conversion on them because their copy constructor does not; // actually read them.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp:307,Performance,perform,perform,307,"// For a trivial copy or move constructor, perform an APValue copy. This is; // essential for unions (or classes with anonymous union members), where the; // operations performed by the constructor cannot be represented by; // ctor-initializers.; //; // Skip this for empty non-union classes; we should not perform an; // lvalue-to-rvalue conversion on them because their copy constructor does not; // actually read them.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp:36,Modifiability,extend,extended,36,// A scope for temporaries lifetime-extended by reference members.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp:45,Availability,avail,available,45,"// Ensure that we have actual array elements available to destroy; the; // destructors might mutate the value, so we can't run them on the array; // filler.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp:4,Performance,Perform,Perform,4,"/// Perform a destructor or pseudo-destructor call on the given object, which; /// might in general not be a complete object.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp:4,Performance,Perform,Perform,4,/// Perform a call to 'operator new' or to `__builtin_operator_new'.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp:62,Energy Efficiency,allocate,allocate,62,// This is permitted only within a call to std::allocator<T>::allocate.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp:222,Availability,failure,failure,222,"/// Check that the given object is a suitable pointer to a heap allocation that; /// still exists and is of the right kind for the purpose of a deletion.; ///; /// On success, returns the heap allocation to deallocate. On failure, produces; /// a diagnostic and returns std::nullopt.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp:3,Performance,Perform,Perform,3,// Perform a call to 'operator delete' or '__builtin_operator_delete'.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp:111,Integrability,contract,contract,111,"// Deleting a null pointer would have no effect, but it's not permitted by; // std::allocator<T>::deallocate's contract.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp:123,Usability,simpl,simply,123,"// The vector's size in bits is not a multiple of the target's byte size,; // so its layout is unspecified. For now, we'll simply treat these cases; // as unsupported (this should only be possible with OpenCL bool vectors; // whose element count isn't a multiple of the byte size).",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp:37,Availability,error,error,37,"// Emit an unsupported bit_cast type error. Sema refuses to build a bit_cast; // with an invalid type, so anything left is a deficiency on our part (FIXME).; // Ideally this will be unreachable.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp:62,Testability,log,logic,62,"// FIXME: We don't currently support bit-fields. A lot of the logic for; // this is in CodeGen, so we need to factor it around.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp:123,Usability,simpl,simply,123,"// The vector's size in bits is not a multiple of the target's byte size,; // so its layout is unspecified. For now, we'll simply treat these cases; // as unsupported (this should only be possible with OpenCL bool vectors; // whose element count isn't a multiple of the byte size).",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp:497,Security,access,accessed,497,"// Special handling for OpenCL bool vectors:; // Since these vectors are stored as packed bits, but we can't read; // individual bits from the BitCastBuffer, we'll buffer all of the; // elements together into an appropriately sized APInt and write them all; // out at once. Because we don't accept vectors where NElts * EltSize; // isn't a multiple of the char size, there will be no padding space, so; // we don't have to worry about reading any padding data which didn't; // actually need to be accessed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp:25,Availability,error,error,25,"/// Report an evaluation error. This should only be called when an error is; /// first discovered. When propagating an error, just return false.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp:67,Availability,error,error,67,"/// Report an evaluation error. This should only be called when an error is; /// first discovered. When propagating an error, just return false.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp:119,Availability,error,error,119,"/// Report an evaluation error. This should only be called when an error is; /// first discovered. When propagating an error, just return false.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp:16,Performance,cache,cache,16,"// Evaluate and cache the common expression. We treat it as a temporary,; // even though it's not quite the same thing.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp:30,Usability,simpl,simple,30,"// If this is syntactically a simple assignment using a trivial; // assignment operator, start the lifetimes of union members as needed,; // per C++20 [class.union]5.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp:3,Performance,Perform,Perform,3,"// Perform virtual dispatch, if necessary.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp:1123,Modifiability,extend,extended,1123,"//===----------------------------------------------------------------------===//; // LValue Evaluation; //; // This is used for evaluating lvalues (in C and C++), xvalues (in C++11),; // function designators (in C), decl references to void objects (in C), and; // temporaries (if building with -Wno-address-of-temporary).; //; // LValue evaluation produces values comprising a base expression of one of the; // following types:; // - Declarations; // * VarDecl; // * FunctionDecl; // - Literals; // * CompoundLiteralExpr in C (and in global scope in C++); // * StringLiteral; // * PredefinedExpr; // * ObjCStringLiteralExpr; // * ObjCEncodeExpr; // * AddrLabelExpr; // * BlockExpr; // * CallExpr for a MakeStringConstant builtin; // - typeid(T) expressions, as TypeInfoLValues; // - Locals and temporaries; // * MaterializeTemporaryExpr; // * Any Expr, with a CallIndex indicating the function in which the temporary; // was evaluated, for cases where the MaterializeTemporaryExpr is missing; // from the AST (FIXME).; // * A MaterializeTemporaryExpr that has static storage duration, with no; // CallIndex, for a lifetime-extended temporary.; // * The ConstantExpr that is currently being evaluated during evaluation of an; // immediate invocation.; // plus an offset in bytes.; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp:12,Deployability,update,update,12,// ... then update it to refer to the field of the closure object; // that represents the capture.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp:42,Deployability,update,update,42,"// And if the field is of reference type, update 'Result' to refer to what; // the field refers to.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp:19,Modifiability,variab,variable,19,"// Only if a local variable was declared in the function currently being; // evaluated, do we expect to be able to find its value in the current; // frame. (Otherwise it was likely declared in an enclosing context and; // could either have a valid evaluatable value (for e.g. a constexpr; // variable) or be ill-formed (and trigger an appropriate evaluation; // diagnostic)).",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp:292,Modifiability,variab,variable,292,"// Only if a local variable was declared in the function currently being; // evaluated, do we expect to be able to find its value in the current; // frame. (Otherwise it was likely declared in an enclosing context and; // could either have a valid evaluatable value (for e.g. a constexpr; // variable) or be ill-formed (and trigger an appropriate evaluation; // diagnostic)).",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp:104,Modifiability,inherit,inherited,104,"// Function parameters are stored in some caller's frame. (Usually the; // immediate caller, but for an inherited constructor they may be more; // distant.)",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp:231,Availability,avail,available,231,//===----------------------------------------------------------------------===//; // Pointer Evaluation; //===----------------------------------------------------------------------===//; /// Attempts to compute the number of bytes available at the pointer; /// returned by a function with the alloc_size attribute. Returns true if we; /// were successful. Places an unsigned number into `Result`.; ///; /// This expects the given CallExpr to be a call to a function with an; /// alloc_size attribute.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp:67,Modifiability,variab,variables,67,"// Because we do no form of static analysis, we only support const variables.; //; // Additionally, we can't support parameters, nor can we support static; // variables (in the latter case, use-before-assign isn't UB; in the former,; // we have no clue what they'll be assigned to).",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp:159,Modifiability,variab,variables,159,"// Because we do no form of static analysis, we only support const variables.; //; // Additionally, we can't support parameters, nor can we support static; // variables (in the latter case, use-before-assign isn't UB; in the former,; // we have no clue what they'll be assigned to).",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp:96,Availability,error,error,96,"// Ensure we actually have captured 'this'. If something was wrong with; // 'this' capture, the error would have been previously reported.; // Otherwise we can be inside of a default initialization of an object; // declared by lambda's body, so no need to return false.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp:244,Deployability,Update,Update,244,"// If we have captured 'this', the 'this' expression refers; // to the enclosing '*this' object (either by value or reference) which is; // either copied into the closure object's field that represents the; // '*this' or refers to '*this'.; // Update 'Result' to refer to the data member/field of the closure object; // that represents the '*this' capture.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp:20,Integrability,protocol,protocol,20,"// FIXME: Missing: @protocol, @selector",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp:40,Energy Efficiency,allocate,allocate,40,"// 1. We'll allow it in std::allocator::allocate, and anything which that; // calls.; // 2. HACK 2022-03-28: Work around an issue with libstdc++'s; // <source_location> header. Fixed in GCC 12 and later (2022-04-??).; // We'll allow it in the body of std::source_location::current. GCC's; // implementation had a parameter of type `void*`, and casts from; // that back to `const __impl*` in its body.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp:54,Testability,log,logic,54,"// The kinds of expressions that we have special-case logic here for; // should be kept up to date with the special checks for those; // expressions in Sema.; // alignof decl is always accepted, even if it doesn't make sense: we default; // to 1 in those cases.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp:72,Availability,down,down,72,"/// Evaluate the value of the alignment argument to __builtin_align_{up,down},; /// __builtin_is_aligned and __builtin_assume_aligned.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp:87,Testability,assert,assert,87,// Ensure both alignment and source value have the same bit width so that we; // don't assert when computing the resulting value.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp:9,Usability,clear,clear,9,// To be clear: this happily visits unsupported builtins. Better name welcomed.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp:81,Testability,assert,asserted,81,"// We need to be very careful here because: if the pointer does not have the; // asserted alignment, then the behavior is undefined, and undefined; // behavior is non-constant.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp:332,Performance,perform,perform,332,"// The alignment could be greater than the minimum at run-time, so we cannot; // infer much about the resulting pointer value. One case is possible:; // For `_Alignas(32) char buf[N]; __builtin_align_down(&buf[idx], 32)` we; // can infer the correct index if the requested alignment is smaller than; // the base alignment so we can perform the computation on the offset.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp:418,Modifiability,extend,extended,418,"// The only new-placement list we support is of the form (std::nothrow).; //; // FIXME: There is no restriction on this, but it's not clear that any; // other form makes any sense. We get here for cases such as:; //; // new (std::align_val_t{N}) X(int); //; // (which should presumably be valid only if N is a multiple of; // alignof(int), and in any case can't be deallocated unless N is; // alignof(X) and X has new-extended alignment).",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp:134,Usability,clear,clear,134,"// The only new-placement list we support is of the form (std::nothrow).; //; // FIXME: There is no restriction on this, but it's not clear that any; // other form makes any sense. We get here for cases such as:; //; // new (std::align_val_t{N}) X(int); //; // (which should presumably be valid only if N is a multiple of; // alignof(int), and in any case can't be deallocated unless N is; // alignof(X) and X has new-extended alignment).",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp:45,Energy Efficiency,allocate,allocated,45,// -- its value is such that the size of the allocated object would; // exceed the implementation-defined limit,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp:24,Performance,perform,performed,24,// No initialization is performed.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp:3,Performance,Perform,Perform,3,// Perform the allocation and obtain a pointer to the resulting object.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp:4,Performance,Perform,Perform,4,"/// Perform zero-initialization on an object of non-union class type.; /// C++11 [dcl.init]p5:; /// To zero-initialize an object or reference of type T means:; /// [...]; /// -- if T is a (possibly cv-qualified) non-union class type,; /// each non-static data member and each base-class subobject is; /// zero-initialized",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp:53,Performance,perform,performed,53,"// -- if T is a reference type, no initialization is performed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp:3,Performance,Perform,Perform,3,// Perform an implicit value-initialization for members beyond the end of; // the initializer list.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp:20,Performance,perform,performed,20,"// If we've already performed zero-initialization, we're already done.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp:3,Safety,Avoid,Avoid,3,// Avoid materializing a temporary for an elidable copy/move constructor.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp:32,Usability,simpl,simplest,32,"// FIXME: This only handles the simplest case, where the source object; // is passed directly as the first argument to the constructor.; // This should also handle stepping though implicit casts and; // and conversion sequences which involve two steps, with a; // conversion operator followed by a converting constructor.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp:10,Performance,Perform,Perform,10,// FIXME: Perform the checks on the field types in SemaInit.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp:58,Availability,error,error,58,"// If there is no initializer, either this is a VLA or an error has; // occurred.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp:40,Modifiability,flexible,flexible,40,"// We can be asked to zero-initialize a flexible array member; this; // is represented as an ImplicitValueInitExpr of incomplete array; // type. In this case, the array has zero elements.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp:46,Integrability,depend,depend,46,// Return true iff the given array filler may depend on the element index.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp:28,Integrability,depend,depend,28,"// If the initializer might depend on the array index, run it for each; // array element.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp:200,Safety,avoid,avoid,200,"// We do the whole initialization in two passes, first for just one element,; // then for the whole array. It's possible we may find out we can't do const; // init in the first pass, in which case we avoid allocating a potentially; // large array. We don't do more passes because expanding array requires; // copying the data, which is wasteful.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp:77,Availability,error,error,77,// When checking for const initilization any diagnostic is considered; // an error.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp:413,Usability,simpl,simple,413,"// end anonymous namespace; /// EvaluateIntegerOrLValue - Evaluate an rvalue integral-typed expression, and; /// produce either the integer value or a pointer.; ///; /// GCC has a heinous extension which folds casts between pointer types and; /// pointer-sized integral types. We support this by allowing the evaluation of; /// an integer rvalue to produce a pointer (represented as an lvalue) instead.; /// Some simple arithmetic on such values is supported (they are treated much; /// like char*).",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp:42,Testability,assert,assertions,42,// Get rid of mismatch (otherwise Success assertions will fail); // by computing a new value matching the type of E.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp:92,Usability,simpl,simple,92,"// We only conservatively allow a few kinds of casts, because this code is; // inherently a simple solution that seeks to support the common case.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp:4,Testability,Test,Tests,4,"/// Tests to see if the LValue has a user-specified designator (that isn't; /// necessarily valid). Note that this always returns 'true' if the LValue has; /// an unsized array as its first designator entry, because there's currently no; /// way to tell if the user typed *foo or foo[0].",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp:16,Safety,detect,detect,16,/// Attempts to detect a user writing into a piece of memory that's impossible; /// to figure out the size of by just using types.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp:254,Modifiability,flexible,flexible,254,"// Notes:; // - Users can only write off of the end when we have an invalid base. Invalid; // bases imply we don't know where the memory came from.; // - We used to be a bit more aggressive here; we'd only be conservative if; // the array at the end was flexible, or if it had 0 or 1 elements. This; // broke some common standard library extensions (PR30346), but was; // otherwise seemingly fine. It may be useful to reintroduce this behavior; // with some sort of list. OTOH, it seems that GCC is always; // conservative with the last element in structs (if it's an array), so our; // current behavior is more compatible than an explicit list approach would; // be.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp:88,Modifiability,flexible,flexible,88,"/// If we're evaluating the object size of an instance of a struct that; /// contains a flexible array member, add the size of the initializer.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp:225,Integrability,depend,depending,225,"/// Helper for tryEvaluateBuiltinObjectSize -- Given an LValue, this will; /// determine how many bytes exist from the beginning of the object to either; /// the end of the current subobject, or the end of the object itself, depending; /// on what the LValue looks like + the value of Type.; ///; /// If this returns false, the value of Result is undefined.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp:192,Availability,failure,failure,192,"/// Tries to evaluate the __builtin_object_size for @p E. If successful,; /// returns true and stores the result in @p Size.; ///; /// If @p WasError is non-null, this will report whether the failure to evaluate; /// is to be treated as an Error in IntExprEvaluator.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp:240,Availability,Error,Error,240,"/// Tries to evaluate the __builtin_object_size for @p E. If successful,; /// returns true and stores the result in @p Size.; ///; /// If @p WasError is non-null, this will report whether the failure to evaluate; /// is to be treated as an Error in IntExprEvaluator.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp:63,Security,access,accessible,63,"// If we point to before the start of the object, there are no accessible; // bytes.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp:3,Energy Efficiency,Reduce,Reduce,3,// Reduce it to a constant now.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp:119,Availability,down,down,119,"// Otherwise we can't infer whether the value is sufficiently aligned.; // TODO: __builtin_is_aligned(__builtin_align_{down,up{(expr, N), N); // in cases where we can't fully evaluate the pointer.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp:105,Safety,avoid,avoid,105,"// Outside a constant context, eagerly evaluate to false in the presence; // of side-effects in order to avoid -Wunsequenced false-positives in; // a branch on __builtin_constant_p(expr).",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp:31,Safety,avoid,avoid,31,// FIXME: Find a better way to avoid duplicated diagnostics.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp:67,Energy Efficiency,power,power,67,"// For __atomic_is_lock_free(sizeof(_Atomic(T))), if the size is a power; // of two less than or equal to the maximum inline atomic width, we know it; // is lock-free. If the size isn't a power of two, or greater than the; // maximum alignment where we promote atomics, we know it is not lock-free; // (at least not in the sense of atomic_is_lock_free). Otherwise,; // the answer can only be determined at runtime; for example, 16-byte; // atomics have lock-free implementations on some, but not all,; // x86-64 processors.; // Check power-of-two.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp:188,Energy Efficiency,power,power,188,"// For __atomic_is_lock_free(sizeof(_Atomic(T))), if the size is a power; // of two less than or equal to the maximum inline atomic width, we know it; // is lock-free. If the size isn't a power of two, or greater than the; // maximum alignment where we promote atomics, we know it is not lock-free; // (at least not in the sense of atomic_is_lock_free). Otherwise,; // the answer can only be determined at runtime; for example, 16-byte; // atomics have lock-free implementations on some, but not all,; // x86-64 processors.; // Check power-of-two.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp:534,Energy Efficiency,power,power-of-two,534,"// For __atomic_is_lock_free(sizeof(_Atomic(T))), if the size is a power; // of two less than or equal to the maximum inline atomic width, we know it; // is lock-free. If the size isn't a power of two, or greater than the; // maximum alignment where we promote atomics, we know it is not lock-free; // (at least not in the sense of atomic_is_lock_free). Otherwise,; // the answer can only be determined at runtime; for example, 16-byte; // atomics have lock-free implementations on some, but not all,; // x86-64 processors.; // Check power-of-two.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp:141,Testability,log,logical,141,"/// True if \param E is a binary operator that we are going to handle; /// data recursively.; /// We handle binary operators that are comma, logical, or that have operands; /// with integral or enumeration type.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp:52,Integrability,wrap,wrapping,52,"// Compute the new offset in the appropriate width, wrapping at 64 bits.; // FIXME: When compiling for a 32-bit target, we should use 32-bit; // offsets.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp:102,Performance,perform,performing,102,"// Set up the width and signedness manually, in case it can't be deduced; // from the operation we're performing.; // FIXME: Don't do this in the cases where we can deduce it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp:272,Security,access,access,272,"// C++11 [expr.rel]p2:; // - If two pointers point to non-static data members of the same object,; // or to subobjects or array elements fo such members, recursively, the; // pointer to the later declared member compares greater provided the; // two members have the same access control and provided their class is; // not a union.; // [...]; // - Otherwise pointer comparisons are unspecified.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp:195,Security,access,access,195,"// At the point where the designators diverge, the comparison has a; // specified value if:; // - we are comparing array indices; // - we are comparing fields of a union, or fields with the same access; // Otherwise, the result is unspecified and thus the comparison is not a; // constant expression.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp:45,Performance,perform,performed,45,"// The comparison here must be unsigned, and performed with the same; // width as the pointer.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp:147,Integrability,depend,depends,147,"// If there is a base and this is a relational operator, we can only; // compare pointers within the object in question; otherwise, the result; // depends on where the object is located in memory.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp:95,Usability,clear,clear,95,"// FIXME: Should extension allow i-c-e extension expressions in its scope?; // If so, we could clear the diagnostic ID.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp:211,Safety,detect,detect,211,// Allow casts of address-of-label differences if they are no-ops; // or narrowing. (The narrowing case isn't actually guaranteed to; // be constant-evaluatable except in some narrow cases which are hard; // to detect here. We let it through on the assumption the user knows; // what they are doing.),MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp:222,Modifiability,variab,variable,222,// We know if we are here that we are in a context that we might require; // a constant expression or a context that requires a constant; // value. But if we are initializing a value we don't know if it is a; // constexpr variable or not. We can check the EvaluatingDecl to determine; // if it constexpr or not. If not then we don't want to emit a diagnostic.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp:146,Availability,down,down,146,"// Only allow based lvalue casts if they are lossless.; // FIXME: Allow a larger integer size than the pointer size, and allow; // narrowing back down to pointer width in subsequent integral casts.; // FIXME: Check integer type's active bits, not its type size.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp:99,Usability,simpl,simplify,99,// Track whether the LHS or RHS is real at the type system level. When this is; // the case we can simplify our evaluation strategy.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp:72,Availability,robust,robustly,72,"// In the fully general case, we need to handle NaNs and infinities; // robustly.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp:11,Performance,optimiz,optimizations,11,"// No real optimizations we can do here, stub out with zero.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp:41,Testability,stub,stub,41,"// No real optimizations we can do here, stub out with zero.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp:83,Integrability,wrap,wrapped,83,"// For atomic-qualified class (and array) types in C++, initialize the; // _Atomic-wrapped subobject directly, in-place.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp:182,Energy Efficiency,allocate,allocated,182,"// This is the only case where we need to produce an extension warning:; // the only other way we can succeed is if we find a dynamic allocation,; // and we will have warned when we allocated it in that case.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp:56,Performance,perform,performing,56,"/// EvaluateAsRValue - Try to evaluate this expression, performing an implicit; /// lvalue-to-rvalue cast if it is an lvalue.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp:293,Testability,test,test,293,"// C++23 [intro.execution]/p5; // A full-expression is ... an init-declarator ([dcl.decl]) or a; // mem-initializer.; // So we need to make sure temporary objects are destroyed after having; // evaluated the expression (per C++23 [class.temporary]/p4).; //; // FIXME: Otherwise this may break test/Modules/pr68702.cpp because the; // serialization code calls ParmVarDecl::getDefaultArg() which strips the; // outermost FullExpr, such as ExprWithCleanups.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp:31,Modifiability,extend,extended,31,"// At this point, any lifetime-extended temporaries are completely; // initialized.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp:110,Usability,usab,usable,110,// Only treat the destruction as constant destruction if we formally have; // constant initialization (or are usable in a constant expression).,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp:470,Energy Efficiency,reduce,reduce,470,"/// isIntegerConstantExpr - this recursive routine will test if an expression is; /// an integer constant expression.; /// FIXME: Pass up a reason why! Invalid operation in i-c-e, division by zero,; /// comma, etc; // CheckICE - This function does the fundamental ICE checking: the returned; // ICEDiag contains an ICEKind indicating whether the expression is an ICE,; // and a (possibly null) SourceLocation indicating the location of the problem.; //; // Note that to reduce code duplication, this helper does no evaluation; // itself; the caller checks whether the expression is evaluatable, and; // in the rare cases where CheckICE actually cares about the evaluated; // value, it calls into Evaluate.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp:43,Integrability,rout,routine,43,"/// isIntegerConstantExpr - this recursive routine will test if an expression is; /// an integer constant expression.; /// FIXME: Pass up a reason why! Invalid operation in i-c-e, division by zero,; /// comma, etc; // CheckICE - This function does the fundamental ICE checking: the returned; // ICEDiag contains an ICEKind indicating whether the expression is an ICE,; // and a (possibly null) SourceLocation indicating the location of the problem.; //; // Note that to reduce code duplication, this helper does no evaluation; // itself; the caller checks whether the expression is evaluatable, and; // in the rare cases where CheckICE actually cares about the evaluated; // value, it calls into Evaluate.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp:56,Testability,test,test,56,"/// isIntegerConstantExpr - this recursive routine will test if an expression is; /// an integer constant expression.; /// FIXME: Pass up a reason why! Invalid operation in i-c-e, division by zero,; /// comma, etc; // CheckICE - This function does the fundamental ICE checking: the returned; // ICEDiag contains an ICEKind indicating whether the expression is an ICE,; // and a (possibly null) SourceLocation indicating the location of the problem.; //; // Note that to reduce code duplication, this helper does no evaluation; // itself; the caller checks whether the expression is evaluatable, and; // in the rare cases where CheckICE actually cares about the evaluated; // value, it calls into Evaluate.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp:85,Modifiability,variab,variables,85,"// C++ and OpenCL (FIXME: spec reference?) allow reading const-qualified; // integer variables in constant expressions:; //; // C++ 7.1.5.1p2; // A variable of non-volatile const-qualified integral or enumeration; // type initialized by an ICE can be used in ICEs.; //; // We sometimes use CheckICE to check the C++98 rules in C++11 mode. In; // that mode, use of reference variables should not be allowed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp:148,Modifiability,variab,variable,148,"// C++ and OpenCL (FIXME: spec reference?) allow reading const-qualified; // integer variables in constant expressions:; //; // C++ 7.1.5.1p2; // A variable of non-volatile const-qualified integral or enumeration; // type initialized by an ICE can be used in ICEs.; //; // We sometimes use CheckICE to check the C++98 rules in C++11 mode. In; // that mode, use of reference variables should not be allowed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp:374,Modifiability,variab,variables,374,"// C++ and OpenCL (FIXME: spec reference?) allow reading const-qualified; // integer variables in constant expressions:; //; // C++ 7.1.5.1p2; // A variable of non-volatile const-qualified integral or enumeration; // type initialized by an ICE can be used in ICEs.; //; // We sometimes use CheckICE to check the C++98 rules in C++11 mode. In; // that mode, use of reference variables should not be allowed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp:29,Availability,error,error,29,"// EvaluateAsRValue gives an error for undefined Div/Rem, so make sure; // we don't evaluate one.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp:35,Integrability,depend,depend,35,"// Rare case where the diagnostics depend on which side is evaluated; // Note that if we get here, CondResult is 0, and at least one of; // TrueResult and FalseResult is non-zero.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp:43,Integrability,depend,dependent,43,// Expression evaluator can't succeed on a dependent expression.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp:61,Safety,safe,safe,61,// Ignore any side-effects from a failed evaluation. This is safe because; // they can't interfere with any other argument evaluation.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp:61,Safety,safe,safe,61,// Ignore any side-effects from a failed evaluation. This is safe because; // they can't interfere with any other argument evaluation.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp:186,Integrability,depend,dependent,186,"// FIXME: It would be useful to check constexpr function templates, but at the; // moment the constant expression evaluator cannot cope with the non-rigorous; // ASTs which we build for dependent expressions.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprCXX.cpp:61,Modifiability,rewrite,rewrite,61,// Remove an outer '!' if it exists (only happens for a '!=' rewrite).,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprCXX.cpp:29,Modifiability,rewrite,rewrite,29,"// If this isn't a spaceship rewrite, we're done.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprCXX.cpp:98,Modifiability,polymorphi,polymorphic,98,"// C++11 [expr.typeid]p3:; // When typeid is applied to an expression other than a glvalue of; // polymorphic class type, [...] the expression is an unevaluated operand.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprCXX.cpp:53,Integrability,depend,dependent,53,// The type-to-delete may not be a pointer if it's a dependent type.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprCXX.cpp:3,Integrability,Depend,DependentScopeDeclRefExpr,3,// DependentScopeDeclRefExpr,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprCXX.cpp:3,Energy Efficiency,Allocate,Allocate,3,// Allocate storage for the trailing objects of CallExpr.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprCXX.cpp:3,Energy Efficiency,Allocate,Allocate,3,// Allocate storage for the trailing objects of CallExpr.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprCXX.cpp:3,Energy Efficiency,Allocate,Allocate,3,// Allocate storage for the trailing objects of CallExpr.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprCXX.cpp:3,Energy Efficiency,Allocate,Allocate,3,// Allocate storage for the trailing objects of CallExpr.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprCXX.cpp:71,Deployability,Update,Update,71,// FIXME: Will eventually need to cope with member pointers.; // NOTE: Update makeTailCallIfSwiftAsync on fixing this.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprCXX.cpp:3,Energy Efficiency,Allocate,Allocate,3,// Allocate storage for the trailing objects of CallExpr.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprCXX.cpp:3,Energy Efficiency,Allocate,Allocate,3,// Allocate storage for the trailing objects of CallExpr.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprCXX.cpp:3,Integrability,Depend,Dependent,3,// Dependent,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprCXX.cpp:156,Integrability,depend,dependent,156,"// Unlike for UnresolvedLookupExpr, it is very easy to re-derive this.; // If there was a nested name specifier, it names the naming class.; // It can't be dependent: after all, we were actually able to do the; // lookup.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprCXX.cpp:18,Energy Efficiency,allocate,allocate,18,// We may need to allocate extra storage for the mangling number and the; // extended-by ValueDecl.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprCXX.cpp:77,Modifiability,extend,extended-by,77,// We may need to allocate extra storage for the mangling number and the; // extended-by ValueDecl.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprCXX.cpp:191,Modifiability,extend,extended,191,// C++20 [expr.const]p4:; // An object or reference is usable in constant expressions if it is [...]; // a temporary object of non-volatile const-qualified literal type; // whose lifetime is extended to that of a variable that is usable; // in constant expressions,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprCXX.cpp:213,Modifiability,variab,variable,213,// C++20 [expr.const]p4:; // An object or reference is usable in constant expressions if it is [...]; // a temporary object of non-volatile const-qualified literal type; // whose lifetime is extended to that of a variable that is usable; // in constant expressions,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprCXX.cpp:55,Usability,usab,usable,55,// C++20 [expr.const]p4:; // An object or reference is usable in constant expressions if it is [...]; // a temporary object of non-volatile const-qualified literal type; // whose lifetime is extended to that of a variable that is usable; // in constant expressions,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprCXX.cpp:230,Usability,usab,usable,230,// C++20 [expr.const]p4:; // An object or reference is usable in constant expressions if it is [...]; // a temporary object of non-volatile const-qualified literal type; // whose lifetime is extended to that of a variable that is usable; // in constant expressions,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprCXX.cpp:3,Energy Efficiency,Allocate,Allocate,3,// Allocate storage for the trailing objects of CallExpr.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprCXX.cpp:3,Energy Efficiency,Allocate,Allocate,3,// Allocate storage for the trailing objects of CallExpr.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ExprCXX.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprCXX.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExternalASTMerger.cpp:52,Integrability,Interface,Interface,52,"//===- ExternalASTMerger.cpp - Merging External AST Interface ---*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements the ExternalASTMerger, which vends a combination of; // ASTs from several different ASTContext/FileManager pairs; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ExternalASTMerger.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExternalASTMerger.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExternalASTMerger.cpp:52,Performance,perform,perform,52,"/// For the given DC, return the DC that is safe to perform lookups on. This is; /// the DC we actually want to work with most of the time.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ExternalASTMerger.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExternalASTMerger.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExternalASTMerger.cpp:44,Safety,safe,safe,44,"/// For the given DC, return the DC that is safe to perform lookups on. This is; /// the DC we actually want to work with most of the time.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ExternalASTMerger.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExternalASTMerger.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExternalASTMerger.cpp:490,Deployability,update,updates,490,"/// A custom implementation of ASTImporter, for ExternalASTMerger's purposes.; ///; /// There are several modifications:; ///; /// - It enables lazy lookup (via the HasExternalLexicalStorage flag and a few; /// others), which instructs Clang to refer to ExternalASTMerger. Also, it; /// forces MinimalImport to true, which is necessary to make this work.; /// - It maintains a reverse importer for use with names. This allows lookup of; /// arbitrary names in the source context.; /// - It updates the ExternalASTMerger's origin map as needed whenever a; /// it sees a DeclContext.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ExternalASTMerger.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExternalASTMerger.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExternalASTMerger.cpp:617,Safety,safe,safely,617,"// If we get here, then this source is importing from a temporary ASTContext; // that also has another ExternalASTMerger attached. It could be; // possible that the current ExternalASTMerger and the temporary ASTContext; // share a common ImporterSource, which means that the temporary; // AST could contain declarations that were imported from a source; // that this ExternalASTMerger can access directly. Instead of importing; // such declarations from the temporary ASTContext, they should instead; // be directly imported by this ExternalASTMerger from the original; // source. This way the ExternalASTMerger can safely do a minimal import; // without creating incomplete declarations originated from a temporary; // ASTContext. If we would try to complete such declarations later on, we; // would fail to do so as their temporary AST could be deleted (which means; // that the missing parts of the minimally imported declaration in that; // ASTContext were also deleted).; //; // The following code tracks back any declaration that needs to be; // imported from the temporary ASTContext to a persistent ASTContext.; // Then the ExternalASTMerger tries to import from the persistent; // ASTContext directly by using the associated ASTImporter. If that; // succeeds, this ASTImporter just maps the declarations imported by; // the other (persistent) ASTImporter to this (temporary) ASTImporter.; // The steps can be visualized like this:; //; // Target AST <--- 3. Indirect import --- Persistent AST; // ^ of persistent decl ^; // | |; // 1. Current import 2. Tracking back to persistent decl; // 4. Map persistent decl |; // & pretend we imported. |; // | |; // Temporary AST -------------------------------'; // First, ask the ExternalASTMerger of the source where the temporary; // declaration originated from.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ExternalASTMerger.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExternalASTMerger.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExternalASTMerger.cpp:390,Security,access,access,390,"// If we get here, then this source is importing from a temporary ASTContext; // that also has another ExternalASTMerger attached. It could be; // possible that the current ExternalASTMerger and the temporary ASTContext; // share a common ImporterSource, which means that the temporary; // AST could contain declarations that were imported from a source; // that this ExternalASTMerger can access directly. Instead of importing; // such declarations from the temporary ASTContext, they should instead; // be directly imported by this ExternalASTMerger from the original; // source. This way the ExternalASTMerger can safely do a minimal import; // without creating incomplete declarations originated from a temporary; // ASTContext. If we would try to complete such declarations later on, we; // would fail to do so as their temporary AST could be deleted (which means; // that the missing parts of the minimally imported declaration in that; // ASTContext were also deleted).; //; // The following code tracks back any declaration that needs to be; // imported from the temporary ASTContext to a persistent ASTContext.; // Then the ExternalASTMerger tries to import from the persistent; // ASTContext directly by using the associated ASTImporter. If that; // succeeds, this ASTImporter just maps the declarations imported by; // the other (persistent) ASTImporter to this (temporary) ASTImporter.; // The steps can be visualized like this:; //; // Target AST <--- 3. Indirect import --- Persistent AST; // ^ of persistent decl ^; // | |; // 1. Current import 2. Tracking back to persistent decl; // 4. Map persistent decl |; // & pretend we imported. |; // | |; // Temporary AST -------------------------------'; // First, ask the ExternalASTMerger of the source where the temporary; // declaration originated from.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ExternalASTMerger.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExternalASTMerger.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExternalASTMerger.cpp:3,Availability,Error,Errors,3,// Errors when importing the persistent decl are treated as if we; // had errors with importing the temporary decl.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ExternalASTMerger.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExternalASTMerger.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExternalASTMerger.cpp:74,Availability,error,errors,74,// Errors when importing the persistent decl are treated as if we; // had errors with importing the temporary decl.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ExternalASTMerger.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExternalASTMerger.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExternalASTMerger.cpp:31,Integrability,interface,interface,31,/// Implements the ASTImporter interface for tracking back a declaration; /// to its original declaration it came from.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ExternalASTMerger.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExternalASTMerger.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExternalASTMerger.cpp:51,Availability,avail,available,51,"// If we don't import specialization, they are not available via lookup; // because the lookup result is imported TemplateDecl and it does not; // reference its specializations until they are imported explicitly.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ExternalASTMerger.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExternalASTMerger.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExternalASTSource.cpp:53,Integrability,Interface,Interface,53,"//===- ExternalASTSource.cpp - Abstract External AST Interface ------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file provides the default implementation of the ExternalASTSource; // interface, which enables construction of AST nodes from some external; // source.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ExternalASTSource.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExternalASTSource.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExternalASTSource.cpp:458,Integrability,interface,interface,458,"//===- ExternalASTSource.cpp - Abstract External AST Interface ------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file provides the default implementation of the ExternalASTSource; // interface, which enables construction of AST nodes from some external; // source.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ExternalASTSource.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExternalASTSource.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/FormatString.cpp:3,Deployability,Update,Update,3,// Update the caller's pointer if we decided to consume; // these characters.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/FormatString.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/FormatString.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/FormatString.cpp:150,Deployability,update,updated,150,"// If the invalid specifier is a multibyte UTF-8 string, return the; // total length accordingly so that the conversion specifier can be; // properly updated to reflect a complete UTF-8 specifier.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/FormatString.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/FormatString.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/FormatString.cpp:29,Integrability,bridg,bridging,29,// Handle implicit toll-free bridging.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/FormatString.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/FormatString.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/FormatString.cpp:117,Integrability,bridg,bridged,117,"// Things such as CFTypeRef are really just opaque pointers; // to C structs representing CF types that can often be bridged; // to Objective-C objects. Since the compiler doesn't know which; // structs can be toll-free bridged, we just accept them all.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/FormatString.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/FormatString.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/FormatString.cpp:220,Integrability,bridg,bridged,220,"// Things such as CFTypeRef are really just opaque pointers; // to C structs representing CF types that can often be bridged; // to Objective-C objects. Since the compiler doesn't know which; // structs can be toll-free bridged, we just accept them all.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/FormatString.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/FormatString.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/FormatStringParsing.h:52,Deployability,install,installed,52,"/// Returns true if a LengthModifier was parsed and installed in the; /// FormatSpecifier& argument, and false otherwise.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/FormatStringParsing.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/FormatStringParsing.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/InheritViz.cpp:7,Modifiability,Inherit,InheritViz,7,"//===- InheritViz.cpp - Graphviz visualization for inheritance --*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements CXXRecordDecl::viewInheritance, which; // generates a GraphViz DOT file that depicts the class inheritance; // diagram and then calls Graphviz/dot+gv on it.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/InheritViz.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/InheritViz.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/InheritViz.cpp:51,Modifiability,inherit,inheritance,51,"//===- InheritViz.cpp - Graphviz visualization for inheritance --*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements CXXRecordDecl::viewInheritance, which; // generates a GraphViz DOT file that depicts the class inheritance; // diagram and then calls Graphviz/dot+gv on it.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/InheritViz.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/InheritViz.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/InheritViz.cpp:499,Modifiability,inherit,inheritance,499,"//===- InheritViz.cpp - Graphviz visualization for inheritance --*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements CXXRecordDecl::viewInheritance, which; // generates a GraphViz DOT file that depicts the class inheritance; // diagram and then calls Graphviz/dot+gv on it.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/InheritViz.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/InheritViz.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/InheritViz.cpp:225,Integrability,interface,interface,225,"/// InheritanceHierarchyWriter - Helper class that writes out a; /// GraphViz file that diagrams the inheritance hierarchy starting at; /// a given C++ class type. Note that we do not use LLVM's; /// GraphWriter, because the interface does not permit us to properly; /// differentiate between uses of types as virtual bases; /// vs. non-virtual bases.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/InheritViz.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/InheritViz.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/InheritViz.cpp:4,Modifiability,Inherit,InheritanceHierarchyWriter,4,"/// InheritanceHierarchyWriter - Helper class that writes out a; /// GraphViz file that diagrams the inheritance hierarchy starting at; /// a given C++ class type. Note that we do not use LLVM's; /// GraphWriter, because the interface does not permit us to properly; /// differentiate between uses of types as virtual bases; /// vs. non-virtual bases.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/InheritViz.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/InheritViz.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/InheritViz.cpp:101,Modifiability,inherit,inheritance,101,"/// InheritanceHierarchyWriter - Helper class that writes out a; /// GraphViz file that diagrams the inheritance hierarchy starting at; /// a given C++ class type. Note that we do not use LLVM's; /// GraphWriter, because the interface does not permit us to properly; /// differentiate between uses of types as virtual bases; /// vs. non-virtual bases.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/InheritViz.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/InheritViz.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/InheritViz.cpp:57,Modifiability,inherit,inheritance,57,"/// WriteNode - Write out the description of node in the inheritance; /// diagram, which may be a base class or it may be the root node.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/InheritViz.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/InheritViz.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/InheritViz.cpp:26,Modifiability,inherit,inheritance,26,"// If this is not virtual inheritance, bump the direct base; // count for the type.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/InheritViz.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/InheritViz.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/InheritViz.cpp:49,Modifiability,inherit,inheritance,49,// Write out edge attributes to show the kind of inheritance.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/InheritViz.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/InheritViz.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/InheritViz.cpp:34,Modifiability,inherit,inheritance,34,/// viewInheritance - Display the inheritance hierarchy of this C++; /// class using GraphViz.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/InheritViz.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/InheritViz.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ItaniumCXXABI.cpp:4,Modifiability,Variab,Variable,4,/// Variable decls are numbered by identifier.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ItaniumCXXABI.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ItaniumCXXABI.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ItaniumMangle.cpp:213,Modifiability,variab,variable,213,"/// In the ""DisableDerivedAbiTags"" mode derived ABI tags are not calculated.; /// This mode is used when mangler creates another mangler recursively to; /// calculate ABI tags for the function return value or the variable type.; /// Also it is required to avoid infinite recursion in some cases.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ItaniumMangle.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ItaniumMangle.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ItaniumMangle.cpp:256,Safety,avoid,avoid,256,"/// In the ""DisableDerivedAbiTags"" mode derived ABI tags are not calculated.; /// This mode is used when mangler creates another mangler recursively to; /// calculate ABI tags for the function return value or the variable type.; /// Also it is required to avoid infinite recursion in some cases.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ItaniumMangle.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ItaniumMangle.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ItaniumMangle.cpp:3,Performance,Perform,Perform,3,// Perform the same check for block literals.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ItaniumMangle.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ItaniumMangle.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ItaniumMangle.cpp:49,Usability,simpl,simple,49,// C++ functions and those whose names are not a simple identifier need; // mangling.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ItaniumMangle.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ItaniumMangle.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ItaniumMangle.cpp:5,Modifiability,variab,variables,5,// C variables are not mangled.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ItaniumMangle.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ItaniumMangle.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ItaniumMangle.cpp:3,Modifiability,Variab,Variables,3,// Variables at global scope are not mangled unless they have internal; // linkage or are specializations or are attached to a named module.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ItaniumMangle.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ItaniumMangle.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ItaniumMangle.cpp:20,Modifiability,variab,variable,20,// Check for extern variable declared locally.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ItaniumMangle.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ItaniumMangle.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ItaniumMangle.cpp:42,Usability,simpl,simplest,42,"// There are no tags for return type, the simplest case. Enter the function; // parameter scope before mangling the name, because a template using; // constrained `auto` can have references to its parameters within its; // template argument list:; //; // template<typename T> void f(T x, C<decltype(x)> auto); // ... is mangled as ...; // template<typename T, C<decltype(param 1)> U> void f(T, U)",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ItaniumMangle.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ItaniumMangle.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ItaniumMangle.cpp:20,Modifiability,inherit,inheriting,20,"// When mangling an inheriting constructor, the bare function type used is; // that of the inherited constructor.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ItaniumMangle.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ItaniumMangle.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ItaniumMangle.cpp:91,Modifiability,inherit,inherited,91,"// When mangling an inheriting constructor, the bare function type used is; // that of the inherited constructor.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ItaniumMangle.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ItaniumMangle.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ItaniumMangle.cpp:68,Integrability,depend,depends,68,"// Whether the mangling of a function type includes the return type depends on; // the context and the nature of the function. The rules for deciding whether; // the return type is included are:; //; // 1. Template functions (names or types) have return types encoded, with; // the exceptions listed below.; // 2. Function types not appearing as part of a function name mangling,; // e.g. parameters, pointer types, etc., have return type encoded, with the; // exceptions listed below.; // 3. Non-template function names do not have return types encoded.; //; // The exceptions mentioned in (1) and (2) above, for which the return type is; // never included, are; // 1. Constructors.; // 2. Destructors.; // 3. Conversion operator functions, e.g. operator int.",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ItaniumMangle.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ItaniumMangle.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ItaniumMangle.cpp:22,Modifiability,variab,variable,22,// Check if we have a variable template.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ItaniumMangle.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ItaniumMangle.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ItaniumMangle.cpp:3,Modifiability,Variab,Variables,3,// Variables should have implicit tags from its type.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ItaniumMangle.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ItaniumMangle.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ItaniumMangle.cpp:18,Modifiability,variab,variable,18,// Simple case no variable type tags.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ItaniumMangle.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ItaniumMangle.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ItaniumMangle.cpp:3,Usability,Simpl,Simple,3,// Simple case no variable type tags.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ItaniumMangle.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ItaniumMangle.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ItaniumMangle.cpp:10,Modifiability,variab,variable,10,// Mangle variable name to null stream to collect tags.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ItaniumMangle.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ItaniumMangle.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ItaniumMangle.cpp:17,Modifiability,variab,variable,17,// Get tags from variable type that are not present in its name.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ItaniumMangle.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ItaniumMangle.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ItaniumMangle.cpp:24,Modifiability,variab,variable,24,"// If this is an extern variable declared locally, the relevant DeclContext; // is that of the containing namespace, or the translation unit.; // FIXME: This is a hack; extern variables declared locally should have; // a proper semantic declaration context!",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ItaniumMangle.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ItaniumMangle.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ItaniumMangle.cpp:176,Modifiability,variab,variables,176,"// If this is an extern variable declared locally, the relevant DeclContext; // is that of the containing namespace, or the translation unit.; // FIXME: This is a hack; extern variables declared locally should have; // a proper semantic declaration context!",MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ItaniumMangle.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ItaniumMangle.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ItaniumMangle.cpp:3,Energy Efficiency,Allocate,Allocate,3,// Allocate a buffer of the right number of characters.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ItaniumMangle.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ItaniumMangle.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ItaniumMangle.cpp:102,Integrability,depend,dependent,102,// FIXME: GCC does not appear to mangle the template arguments when; // the template in question is a dependent template name. Should we; // emulate that badness?,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ItaniumMangle.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ItaniumMangle.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ItaniumMangle.cpp:102,Integrability,depend,dependent,102,// FIXME: GCC does not appear to mangle the template arguments when; // the template in question is a dependent template name. Should we; // emulate that badness?,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ItaniumMangle.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ItaniumMangle.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ItaniumMangle.cpp:31,Usability,simpl,simple-id,31,// <base-unresolved-name> ::= <simple-id>,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ItaniumMangle.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ItaniumMangle.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ItaniumMangle.cpp:8,Usability,simpl,simple-id,8,// The <simple-id> and on <operator-name> productions end in an optional; // <template-args>.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ItaniumMangle.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ItaniumMangle.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ItaniumMangle.cpp:64,Modifiability,variab,variables,64,// We follow MSVC in mangling GUID declarations as if they were variables; // with a particular reserved name. Continue the pretense here.,MatchSource.CODE_COMMENT,interpreter/llvm-project/clang/lib/AST/ItaniumMangle.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ItaniumMangle.cpp
